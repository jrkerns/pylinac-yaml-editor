"use strict";
(self["webpackChunkpylinac_yaml_editor"] = self["webpackChunkpylinac_yaml_editor"] || []).push([["node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensDto_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/base/common/buffer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/buffer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VSBuffer: () => (/* binding */ VSBuffer),
/* harmony export */   readUInt16LE: () => (/* binding */ readUInt16LE),
/* harmony export */   readUInt32BE: () => (/* binding */ readUInt32BE),
/* harmony export */   readUInt8: () => (/* binding */ readUInt8),
/* harmony export */   writeUInt16LE: () => (/* binding */ writeUInt16LE),
/* harmony export */   writeUInt32BE: () => (/* binding */ writeUInt32BE),
/* harmony export */   writeUInt8: () => (/* binding */ writeUInt8)
/* harmony export */ });
/* harmony import */ var _lazy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lazy.js */ "./node_modules/monaco-editor/esm/vs/base/common/lazy.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const hasBuffer = (typeof Buffer !== 'undefined');
const indexOfTable = new _lazy_js__WEBPACK_IMPORTED_MODULE_0__.Lazy(() => new Uint8Array(256));
let textDecoder;
class VSBuffer {
    /**
     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
     * which is not transferrable.
     */
    static wrap(actual) {
        if (hasBuffer && !(Buffer.isBuffer(actual))) {
            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array
            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
        }
        return new VSBuffer(actual);
    }
    constructor(buffer) {
        this.buffer = buffer;
        this.byteLength = this.buffer.byteLength;
    }
    toString() {
        if (hasBuffer) {
            return this.buffer.toString();
        }
        else {
            if (!textDecoder) {
                textDecoder = new TextDecoder();
            }
            return textDecoder.decode(this.buffer);
        }
    }
}
function readUInt16LE(source, offset) {
    return (((source[offset + 0] << 0) >>> 0) |
        ((source[offset + 1] << 8) >>> 0));
}
function writeUInt16LE(destination, value, offset) {
    destination[offset + 0] = (value & 0b11111111);
    value = value >>> 8;
    destination[offset + 1] = (value & 0b11111111);
}
function readUInt32BE(source, offset) {
    return (source[offset] * 2 ** 24
        + source[offset + 1] * 2 ** 16
        + source[offset + 2] * 2 ** 8
        + source[offset + 3]);
}
function writeUInt32BE(destination, value, offset) {
    destination[offset + 3] = value;
    value = value >>> 8;
    destination[offset + 2] = value;
    value = value >>> 8;
    destination[offset + 1] = value;
    value = value >>> 8;
    destination[offset] = value;
}
function readUInt8(source, offset) {
    return source[offset];
}
function writeUInt8(destination, value, offset) {
    destination[offset] = value;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encodeSemanticTokensDto: () => (/* binding */ encodeSemanticTokensDto)
/* harmony export */ });
/* harmony import */ var _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/buffer.js */ "./node_modules/monaco-editor/esm/vs/base/common/buffer.js");
/* harmony import */ var _base_common_platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function reverseEndianness(arr) {
    for (let i = 0, len = arr.length; i < len; i += 4) {
        // flip bytes 0<->3 and 1<->2
        const b0 = arr[i + 0];
        const b1 = arr[i + 1];
        const b2 = arr[i + 2];
        const b3 = arr[i + 3];
        arr[i + 0] = b3;
        arr[i + 1] = b2;
        arr[i + 2] = b1;
        arr[i + 3] = b0;
    }
}
function toLittleEndianBuffer(arr) {
    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);
    if (!_base_common_platform_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian()) {
        // the byte order must be changed
        reverseEndianness(uint8Arr);
    }
    return _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__.VSBuffer.wrap(uint8Arr);
}
function encodeSemanticTokensDto(semanticTokens) {
    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));
    let offset = 0;
    dest[offset++] = semanticTokens.id;
    if (semanticTokens.type === 'full') {
        dest[offset++] = 1 /* EncodedSemanticTokensType.Full */;
        dest[offset++] = semanticTokens.data.length;
        dest.set(semanticTokens.data, offset);
        offset += semanticTokens.data.length;
    }
    else {
        dest[offset++] = 2 /* EncodedSemanticTokensType.Delta */;
        dest[offset++] = semanticTokens.deltas.length;
        for (const delta of semanticTokens.deltas) {
            dest[offset++] = delta.start;
            dest[offset++] = delta.deleteCount;
            if (delta.data) {
                dest[offset++] = delta.data.length;
                dest.set(delta.data, offset);
                offset += delta.data.length;
            }
            else {
                dest[offset++] = 0;
            }
        }
    }
    return toLittleEndianBuffer(dest);
}
function encodeSemanticTokensDtoSize(semanticTokens) {
    let result = 0;
    result += (+1 // id
        + 1 // type
    );
    if (semanticTokens.type === 'full') {
        result += (+1 // data length
            + semanticTokens.data.length);
    }
    else {
        result += (+1 // delta count
        );
        result += (+1 // start
            + 1 // deleteCount
            + 1 // data length
        ) * semanticTokens.deltas.length;
        for (const delta of semanticTokens.deltas) {
            if (delta.data) {
                result += delta.data.length;
            }
        }
    }
    return result;
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfc2VtYW50aWNUb2tlbnNEdG9fanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDaUM7QUFDakM7QUFDQSx5QkFBeUIsMENBQUk7QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQzBEO0FBQ0c7QUFDN0Q7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0VBQXVCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vYnVmZmVyLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9zZW1hbnRpY1Rva2Vuc0R0by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IExhenkgfSBmcm9tICcuL2xhenkuanMnO1xuY29uc3QgaGFzQnVmZmVyID0gKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcbmNvbnN0IGluZGV4T2ZUYWJsZSA9IG5ldyBMYXp5KCgpID0+IG5ldyBVaW50OEFycmF5KDI1NikpO1xubGV0IHRleHREZWNvZGVyO1xuZXhwb3J0IGNsYXNzIFZTQnVmZmVyIHtcbiAgICAvKipcbiAgICAgKiBXaGVuIHJ1bm5pbmcgaW4gYSBub2RlanMgY29udGV4dCwgaWYgYGFjdHVhbGAgaXMgbm90IGEgbm9kZWpzIEJ1ZmZlciwgdGhlIGJhY2tpbmcgc3RvcmUgZm9yXG4gICAgICogdGhlIHJldHVybmVkIGBWU0J1ZmZlcmAgaW5zdGFuY2UgbWlnaHQgdXNlIGEgbm9kZWpzIEJ1ZmZlciBhbGxvY2F0ZWQgZnJvbSBub2RlJ3MgQnVmZmVyIHBvb2wsXG4gICAgICogd2hpY2ggaXMgbm90IHRyYW5zZmVycmFibGUuXG4gICAgICovXG4gICAgc3RhdGljIHdyYXAoYWN0dWFsKSB7XG4gICAgICAgIGlmIChoYXNCdWZmZXIgJiYgIShCdWZmZXIuaXNCdWZmZXIoYWN0dWFsKSkpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12MTAueC9kb2NzL2FwaS9idWZmZXIuaHRtbCNidWZmZXJfY2xhc3NfbWV0aG9kX2J1ZmZlcl9mcm9tX2FycmF5YnVmZmVyX2J5dGVvZmZzZXRfbGVuZ3RoXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB6ZXJvLWNvcHkgQnVmZmVyIHdyYXBwZXIgYXJvdW5kIHRoZSBBcnJheUJ1ZmZlciBwb2ludGVkIHRvIGJ5IHRoZSBVaW50OEFycmF5XG4gICAgICAgICAgICBhY3R1YWwgPSBCdWZmZXIuZnJvbShhY3R1YWwuYnVmZmVyLCBhY3R1YWwuYnl0ZU9mZnNldCwgYWN0dWFsLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVlNCdWZmZXIoYWN0dWFsKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKGhhc0J1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRleHREZWNvZGVyKSB7XG4gICAgICAgICAgICAgICAgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy5idWZmZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVSW50MTZMRShzb3VyY2UsIG9mZnNldCkge1xuICAgIHJldHVybiAoKChzb3VyY2Vbb2Zmc2V0ICsgMF0gPDwgMCkgPj4+IDApIHxcbiAgICAgICAgKChzb3VyY2Vbb2Zmc2V0ICsgMV0gPDwgOCkgPj4+IDApKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFKGRlc3RpbmF0aW9uLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgMF0gPSAodmFsdWUgJiAwYjExMTExMTExKTtcbiAgICB2YWx1ZSA9IHZhbHVlID4+PiA4O1xuICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDFdID0gKHZhbHVlICYgMGIxMTExMTExMSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZFVJbnQzMkJFKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChzb3VyY2Vbb2Zmc2V0XSAqIDIgKiogMjRcbiAgICAgICAgKyBzb3VyY2Vbb2Zmc2V0ICsgMV0gKiAyICoqIDE2XG4gICAgICAgICsgc291cmNlW29mZnNldCArIDJdICogMiAqKiA4XG4gICAgICAgICsgc291cmNlW29mZnNldCArIDNdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFKGRlc3RpbmF0aW9uLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgM10gPSB2YWx1ZTtcbiAgICB2YWx1ZSA9IHZhbHVlID4+PiA4O1xuICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDJdID0gdmFsdWU7XG4gICAgdmFsdWUgPSB2YWx1ZSA+Pj4gODtcbiAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAxXSA9IHZhbHVlO1xuICAgIHZhbHVlID0gdmFsdWUgPj4+IDg7XG4gICAgZGVzdGluYXRpb25bb2Zmc2V0XSA9IHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVSW50OChzb3VyY2UsIG9mZnNldCkge1xuICAgIHJldHVybiBzb3VyY2Vbb2Zmc2V0XTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVVJbnQ4KGRlc3RpbmF0aW9uLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgZGVzdGluYXRpb25bb2Zmc2V0XSA9IHZhbHVlO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBWU0J1ZmZlciB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2J1ZmZlci5qcyc7XG5pbXBvcnQgKiBhcyBwbGF0Zm9ybSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9wbGF0Zm9ybS5qcyc7XG5mdW5jdGlvbiByZXZlcnNlRW5kaWFubmVzcyhhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIC8vIGZsaXAgYnl0ZXMgMDwtPjMgYW5kIDE8LT4yXG4gICAgICAgIGNvbnN0IGIwID0gYXJyW2kgKyAwXTtcbiAgICAgICAgY29uc3QgYjEgPSBhcnJbaSArIDFdO1xuICAgICAgICBjb25zdCBiMiA9IGFycltpICsgMl07XG4gICAgICAgIGNvbnN0IGIzID0gYXJyW2kgKyAzXTtcbiAgICAgICAgYXJyW2kgKyAwXSA9IGIzO1xuICAgICAgICBhcnJbaSArIDFdID0gYjI7XG4gICAgICAgIGFycltpICsgMl0gPSBiMTtcbiAgICAgICAgYXJyW2kgKyAzXSA9IGIwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvTGl0dGxlRW5kaWFuQnVmZmVyKGFycikge1xuICAgIGNvbnN0IHVpbnQ4QXJyID0gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5sZW5ndGggKiA0KTtcbiAgICBpZiAoIXBsYXRmb3JtLmlzTGl0dGxlRW5kaWFuKCkpIHtcbiAgICAgICAgLy8gdGhlIGJ5dGUgb3JkZXIgbXVzdCBiZSBjaGFuZ2VkXG4gICAgICAgIHJldmVyc2VFbmRpYW5uZXNzKHVpbnQ4QXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIFZTQnVmZmVyLndyYXAodWludDhBcnIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVNlbWFudGljVG9rZW5zRHRvKHNlbWFudGljVG9rZW5zKSB7XG4gICAgY29uc3QgZGVzdCA9IG5ldyBVaW50MzJBcnJheShlbmNvZGVTZW1hbnRpY1Rva2Vuc0R0b1NpemUoc2VtYW50aWNUb2tlbnMpKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBkZXN0W29mZnNldCsrXSA9IHNlbWFudGljVG9rZW5zLmlkO1xuICAgIGlmIChzZW1hbnRpY1Rva2Vucy50eXBlID09PSAnZnVsbCcpIHtcbiAgICAgICAgZGVzdFtvZmZzZXQrK10gPSAxIC8qIEVuY29kZWRTZW1hbnRpY1Rva2Vuc1R5cGUuRnVsbCAqLztcbiAgICAgICAgZGVzdFtvZmZzZXQrK10gPSBzZW1hbnRpY1Rva2Vucy5kYXRhLmxlbmd0aDtcbiAgICAgICAgZGVzdC5zZXQoc2VtYW50aWNUb2tlbnMuZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHNlbWFudGljVG9rZW5zLmRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVzdFtvZmZzZXQrK10gPSAyIC8qIEVuY29kZWRTZW1hbnRpY1Rva2Vuc1R5cGUuRGVsdGEgKi87XG4gICAgICAgIGRlc3Rbb2Zmc2V0KytdID0gc2VtYW50aWNUb2tlbnMuZGVsdGFzLmxlbmd0aDtcbiAgICAgICAgZm9yIChjb25zdCBkZWx0YSBvZiBzZW1hbnRpY1Rva2Vucy5kZWx0YXMpIHtcbiAgICAgICAgICAgIGRlc3Rbb2Zmc2V0KytdID0gZGVsdGEuc3RhcnQ7XG4gICAgICAgICAgICBkZXN0W29mZnNldCsrXSA9IGRlbHRhLmRlbGV0ZUNvdW50O1xuICAgICAgICAgICAgaWYgKGRlbHRhLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBkZXN0W29mZnNldCsrXSA9IGRlbHRhLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRlc3Quc2V0KGRlbHRhLmRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRlbHRhLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFtvZmZzZXQrK10gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b0xpdHRsZUVuZGlhbkJ1ZmZlcihkZXN0KTtcbn1cbmZ1bmN0aW9uIGVuY29kZVNlbWFudGljVG9rZW5zRHRvU2l6ZShzZW1hbnRpY1Rva2Vucykge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIHJlc3VsdCArPSAoKzEgLy8gaWRcbiAgICAgICAgKyAxIC8vIHR5cGVcbiAgICApO1xuICAgIGlmIChzZW1hbnRpY1Rva2Vucy50eXBlID09PSAnZnVsbCcpIHtcbiAgICAgICAgcmVzdWx0ICs9ICgrMSAvLyBkYXRhIGxlbmd0aFxuICAgICAgICAgICAgKyBzZW1hbnRpY1Rva2Vucy5kYXRhLmxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gKCsxIC8vIGRlbHRhIGNvdW50XG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdCArPSAoKzEgLy8gc3RhcnRcbiAgICAgICAgICAgICsgMSAvLyBkZWxldGVDb3VudFxuICAgICAgICAgICAgKyAxIC8vIGRhdGEgbGVuZ3RoXG4gICAgICAgICkgKiBzZW1hbnRpY1Rva2Vucy5kZWx0YXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGNvbnN0IGRlbHRhIG9mIHNlbWFudGljVG9rZW5zLmRlbHRhcykge1xuICAgICAgICAgICAgaWYgKGRlbHRhLmRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZGVsdGEuZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==