"use strict";
(self["webpackChunkpylinac_yaml_editor"] = self["webpackChunkpylinac_yaml_editor"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_base_common_glob_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/base/common/glob.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/glob.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLOBSTAR: () => (/* binding */ GLOBSTAR),
/* harmony export */   GLOB_SPLIT: () => (/* binding */ GLOB_SPLIT),
/* harmony export */   isRelativePattern: () => (/* binding */ isRelativePattern),
/* harmony export */   match: () => (/* binding */ match),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   splitGlobAware: () => (/* binding */ splitGlobAware)
/* harmony export */ });
/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async.js */ "./node_modules/monaco-editor/esm/vs/base/common/async.js");
/* harmony import */ var _extpath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extpath.js */ "./node_modules/monaco-editor/esm/vs/base/common/extpath.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ "./node_modules/monaco-editor/esm/vs/base/common/map.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./path.js */ "./node_modules/monaco-editor/esm/vs/base/common/path.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");






const GLOBSTAR = '**';
const GLOB_SPLIT = '/';
const PATH_REGEX = '[/\\\\]'; // any slash or backslash
const NO_PATH_REGEX = '[^/\\\\]'; // any non-slash and non-backslash
const ALL_FORWARD_SLASHES = /\//g;
function starsToRegExp(starCount, isLastPattern) {
    switch (starCount) {
        case 0:
            return '';
        case 1:
            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
        default:
            // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern
            //           in which case also matches (Path Sep followed by Path Val)
            // Group is non capturing because we don't need to capture at all (?:...)
            // Overall we use non-greedy matching because it could be that we match too much
            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;
    }
}
function splitGlobAware(pattern, splitChar) {
    if (!pattern) {
        return [];
    }
    const segments = [];
    let inBraces = false;
    let inBrackets = false;
    let curVal = '';
    for (const char of pattern) {
        switch (char) {
            case splitChar:
                if (!inBraces && !inBrackets) {
                    segments.push(curVal);
                    curVal = '';
                    continue;
                }
                break;
            case '{':
                inBraces = true;
                break;
            case '}':
                inBraces = false;
                break;
            case '[':
                inBrackets = true;
                break;
            case ']':
                inBrackets = false;
                break;
        }
        curVal += char;
    }
    // Tail
    if (curVal) {
        segments.push(curVal);
    }
    return segments;
}
function parseRegExp(pattern) {
    if (!pattern) {
        return '';
    }
    let regEx = '';
    // Split up into segments for each slash found
    const segments = splitGlobAware(pattern, GLOB_SPLIT);
    // Special case where we only have globstars
    if (segments.every(segment => segment === GLOBSTAR)) {
        regEx = '.*';
    }
    // Build regex over segments
    else {
        let previousSegmentWasGlobStar = false;
        segments.forEach((segment, index) => {
            // Treat globstar specially
            if (segment === GLOBSTAR) {
                // if we have more than one globstar after another, just ignore it
                if (previousSegmentWasGlobStar) {
                    return;
                }
                regEx += starsToRegExp(2, index === segments.length - 1);
            }
            // Anything else, not globstar
            else {
                // States
                let inBraces = false;
                let braceVal = '';
                let inBrackets = false;
                let bracketVal = '';
                for (const char of segment) {
                    // Support brace expansion
                    if (char !== '}' && inBraces) {
                        braceVal += char;
                        continue;
                    }
                    // Support brackets
                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {
                        let res;
                        // range operator
                        if (char === '-') {
                            res = char;
                        }
                        // negation operator (only valid on first index in bracket)
                        else if ((char === '^' || char === '!') && !bracketVal) {
                            res = '^';
                        }
                        // glob split matching is not allowed within character ranges
                        // see http://man7.org/linux/man-pages/man7/glob.7.html
                        else if (char === GLOB_SPLIT) {
                            res = '';
                        }
                        // anything else gets escaped
                        else {
                            res = (0,_strings_js__WEBPACK_IMPORTED_MODULE_5__.escapeRegExpCharacters)(char);
                        }
                        bracketVal += res;
                        continue;
                    }
                    switch (char) {
                        case '{':
                            inBraces = true;
                            continue;
                        case '[':
                            inBrackets = true;
                            continue;
                        case '}': {
                            const choices = splitGlobAware(braceVal, ',');
                            // Converts {foo,bar} => [foo|bar]
                            const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;
                            regEx += braceRegExp;
                            inBraces = false;
                            braceVal = '';
                            break;
                        }
                        case ']': {
                            regEx += ('[' + bracketVal + ']');
                            inBrackets = false;
                            bracketVal = '';
                            break;
                        }
                        case '?':
                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \)
                            continue;
                        case '*':
                            regEx += starsToRegExp(1);
                            continue;
                        default:
                            regEx += (0,_strings_js__WEBPACK_IMPORTED_MODULE_5__.escapeRegExpCharacters)(char);
                    }
                }
                // Tail: Add the slash we had split on if there is more to
                // come and the remaining pattern is not a globstar
                // For example if pattern: some/**/*.js we want the "/" after
                // some to be included in the RegEx to prevent a folder called
                // "something" to match as well.
                if (index < segments.length - 1 && // more segments to come after this
                    (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...
                        index + 2 < segments.length // ...next segment is ** but there is more segments after that
                    )) {
                    regEx += PATH_REGEX;
                }
            }
            // update globstar state
            previousSegmentWasGlobStar = (segment === GLOBSTAR);
        });
    }
    return regEx;
}
// regexes to check for trivial glob patterns that just check for String#endsWith
const T1 = /^\*\*\/\*\.[\w\.-]+$/; // **/*.something
const T2 = /^\*\*\/([\w\.-]+)\/?$/; // **/something
const T3 = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}
const T3_2 = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/; // Like T3, with optional trailing /**
const T4 = /^\*\*((\/[\w\.-]+)+)\/?$/; // **/something/else
const T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/; // something/else
const CACHE = new _map_js__WEBPACK_IMPORTED_MODULE_2__.LRUCache(10000); // bounded to 10000 elements
const FALSE = function () {
    return false;
};
const NULL = function () {
    return null;
};
function parsePattern(arg1, options) {
    if (!arg1) {
        return NULL;
    }
    // Handle relative patterns
    let pattern;
    if (typeof arg1 !== 'string') {
        pattern = arg1.pattern;
    }
    else {
        pattern = arg1;
    }
    // Whitespace trimming
    pattern = pattern.trim();
    // Check cache
    const patternKey = `${pattern}_${!!options.trimForExclusions}`;
    let parsedPattern = CACHE.get(patternKey);
    if (parsedPattern) {
        return wrapRelativePattern(parsedPattern, arg1);
    }
    // Check for Trivials
    let match;
    if (T1.test(pattern)) {
        parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check
    }
    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check
        parsedPattern = trivia2(match[1], pattern);
    }
    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}
        parsedPattern = trivia3(pattern, options);
    }
    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check
        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);
    }
    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check
        parsedPattern = trivia4and5(match[1], pattern, false);
    }
    // Otherwise convert to pattern
    else {
        parsedPattern = toRegExp(pattern);
    }
    // Cache
    CACHE.set(patternKey, parsedPattern);
    return wrapRelativePattern(parsedPattern, arg1);
}
function wrapRelativePattern(parsedPattern, arg2) {
    if (typeof arg2 === 'string') {
        return parsedPattern;
    }
    const wrappedPattern = function (path, basename) {
        if (!(0,_extpath_js__WEBPACK_IMPORTED_MODULE_1__.isEqualOrParent)(path, arg2.base, !_platform_js__WEBPACK_IMPORTED_MODULE_4__.isLinux)) {
            // skip glob matching if `base` is not a parent of `path`
            return null;
        }
        // Given we have checked `base` being a parent of `path`,
        // we can now remove the `base` portion of the `path`
        // and only match on the remaining path components
        // For that we try to extract the portion of the `path`
        // that comes after the `base` portion. We have to account
        // for the fact that `base` might end in a path separator
        // (https://github.com/microsoft/vscode/issues/162498)
        return parsedPattern((0,_strings_js__WEBPACK_IMPORTED_MODULE_5__.ltrim)(path.substr(arg2.base.length), _path_js__WEBPACK_IMPORTED_MODULE_3__.sep), basename);
    };
    // Make sure to preserve associated metadata
    wrappedPattern.allBasenames = parsedPattern.allBasenames;
    wrappedPattern.allPaths = parsedPattern.allPaths;
    wrappedPattern.basenames = parsedPattern.basenames;
    wrappedPattern.patterns = parsedPattern.patterns;
    return wrappedPattern;
}
function trimForExclusions(pattern, options) {
    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later
}
// common pattern: **/*.txt just need endsWith check
function trivia1(base, pattern) {
    return function (path, basename) {
        return typeof path === 'string' && path.endsWith(base) ? pattern : null;
    };
}
// common pattern: **/some.txt just need basename check
function trivia2(base, pattern) {
    const slashBase = `/${base}`;
    const backslashBase = `\\${base}`;
    const parsedPattern = function (path, basename) {
        if (typeof path !== 'string') {
            return null;
        }
        if (basename) {
            return basename === base ? pattern : null;
        }
        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;
    };
    const basenames = [base];
    parsedPattern.basenames = basenames;
    parsedPattern.patterns = [pattern];
    parsedPattern.allBasenames = basenames;
    return parsedPattern;
}
// repetition of common patterns (see above) {**/*.txt,**/*.png}
function trivia3(pattern, options) {
    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)
        .split(',')
        .map(pattern => parsePattern(pattern, options))
        .filter(pattern => pattern !== NULL), pattern);
    const patternsLength = parsedPatterns.length;
    if (!patternsLength) {
        return NULL;
    }
    if (patternsLength === 1) {
        return parsedPatterns[0];
    }
    const parsedPattern = function (path, basename) {
        for (let i = 0, n = parsedPatterns.length; i < n; i++) {
            if (parsedPatterns[i](path, basename)) {
                return pattern;
            }
        }
        return null;
    };
    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);
    if (withBasenames) {
        parsedPattern.allBasenames = withBasenames.allBasenames;
    }
    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
    if (allPaths.length) {
        parsedPattern.allPaths = allPaths;
    }
    return parsedPattern;
}
// common patterns: **/something/else just need endsWith check, something/else just needs and equals check
function trivia4and5(targetPath, pattern, matchPathEnds) {
    const usingPosixSep = _path_js__WEBPACK_IMPORTED_MODULE_3__.sep === _path_js__WEBPACK_IMPORTED_MODULE_3__.posix.sep;
    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, _path_js__WEBPACK_IMPORTED_MODULE_3__.sep);
    const nativePathEnd = _path_js__WEBPACK_IMPORTED_MODULE_3__.sep + nativePath;
    const targetPathEnd = _path_js__WEBPACK_IMPORTED_MODULE_3__.posix.sep + targetPath;
    let parsedPattern;
    if (matchPathEnds) {
        parsedPattern = function (path, basename) {
            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;
        };
    }
    else {
        parsedPattern = function (path, basename) {
            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;
        };
    }
    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];
    return parsedPattern;
}
function toRegExp(pattern) {
    try {
        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);
        return function (path) {
            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!
            return typeof path === 'string' && regExp.test(path) ? pattern : null;
        };
    }
    catch (error) {
        return NULL;
    }
}
function match(arg1, path, hasSibling) {
    if (!arg1 || typeof path !== 'string') {
        return false;
    }
    return parse(arg1)(path, undefined, hasSibling);
}
function parse(arg1, options = {}) {
    if (!arg1) {
        return FALSE;
    }
    // Glob with String
    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {
        const parsedPattern = parsePattern(arg1, options);
        if (parsedPattern === NULL) {
            return FALSE;
        }
        const resultPattern = function (path, basename) {
            return !!parsedPattern(path, basename);
        };
        if (parsedPattern.allBasenames) {
            resultPattern.allBasenames = parsedPattern.allBasenames;
        }
        if (parsedPattern.allPaths) {
            resultPattern.allPaths = parsedPattern.allPaths;
        }
        return resultPattern;
    }
    // Glob with Expression
    return parsedExpression(arg1, options);
}
function isRelativePattern(obj) {
    const rp = obj;
    if (!rp) {
        return false;
    }
    return typeof rp.base === 'string' && typeof rp.pattern === 'string';
}
function parsedExpression(expression, options) {
    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)
        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))
        .filter(pattern => pattern !== NULL));
    const patternsLength = parsedPatterns.length;
    if (!patternsLength) {
        return NULL;
    }
    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {
        if (patternsLength === 1) {
            return parsedPatterns[0];
        }
        const resultExpression = function (path, basename) {
            let resultPromises = undefined;
            for (let i = 0, n = parsedPatterns.length; i < n; i++) {
                const result = parsedPatterns[i](path, basename);
                if (typeof result === 'string') {
                    return result; // immediately return as soon as the first expression matches
                }
                // If the result is a promise, we have to keep it for
                // later processing and await the result properly.
                if ((0,_async_js__WEBPACK_IMPORTED_MODULE_0__.isThenable)(result)) {
                    if (!resultPromises) {
                        resultPromises = [];
                    }
                    resultPromises.push(result);
                }
            }
            // With result promises, we have to loop over each and
            // await the result before we can return any result.
            if (resultPromises) {
                return (async () => {
                    for (const resultPromise of resultPromises) {
                        const result = await resultPromise;
                        if (typeof result === 'string') {
                            return result;
                        }
                    }
                    return null;
                })();
            }
            return null;
        };
        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);
        if (withBasenames) {
            resultExpression.allBasenames = withBasenames.allBasenames;
        }
        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
        if (allPaths.length) {
            resultExpression.allPaths = allPaths;
        }
        return resultExpression;
    }
    const resultExpression = function (path, base, hasSibling) {
        let name = undefined;
        let resultPromises = undefined;
        for (let i = 0, n = parsedPatterns.length; i < n; i++) {
            // Pattern matches path
            const parsedPattern = parsedPatterns[i];
            if (parsedPattern.requiresSiblings && hasSibling) {
                if (!base) {
                    base = (0,_path_js__WEBPACK_IMPORTED_MODULE_3__.basename)(path);
                }
                if (!name) {
                    name = base.substr(0, base.length - (0,_path_js__WEBPACK_IMPORTED_MODULE_3__.extname)(path).length);
                }
            }
            const result = parsedPattern(path, base, name, hasSibling);
            if (typeof result === 'string') {
                return result; // immediately return as soon as the first expression matches
            }
            // If the result is a promise, we have to keep it for
            // later processing and await the result properly.
            if ((0,_async_js__WEBPACK_IMPORTED_MODULE_0__.isThenable)(result)) {
                if (!resultPromises) {
                    resultPromises = [];
                }
                resultPromises.push(result);
            }
        }
        // With result promises, we have to loop over each and
        // await the result before we can return any result.
        if (resultPromises) {
            return (async () => {
                for (const resultPromise of resultPromises) {
                    const result = await resultPromise;
                    if (typeof result === 'string') {
                        return result;
                    }
                }
                return null;
            })();
        }
        return null;
    };
    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);
    if (withBasenames) {
        resultExpression.allBasenames = withBasenames.allBasenames;
    }
    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
    if (allPaths.length) {
        resultExpression.allPaths = allPaths;
    }
    return resultExpression;
}
function parseExpressionPattern(pattern, value, options) {
    if (value === false) {
        return NULL; // pattern is disabled
    }
    const parsedPattern = parsePattern(pattern, options);
    if (parsedPattern === NULL) {
        return NULL;
    }
    // Expression Pattern is <boolean>
    if (typeof value === 'boolean') {
        return parsedPattern;
    }
    // Expression Pattern is <SiblingClause>
    if (value) {
        const when = value.when;
        if (typeof when === 'string') {
            const result = (path, basename, name, hasSibling) => {
                if (!hasSibling || !parsedPattern(path, basename)) {
                    return null;
                }
                const clausePattern = when.replace('$(basename)', () => name);
                const matched = hasSibling(clausePattern);
                return (0,_async_js__WEBPACK_IMPORTED_MODULE_0__.isThenable)(matched) ?
                    matched.then(match => match ? pattern : null) :
                    matched ? pattern : null;
            };
            result.requiresSiblings = true;
            return result;
        }
    }
    // Expression is anything
    return parsedPattern;
}
function aggregateBasenameMatches(parsedPatterns, result) {
    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);
    if (basenamePatterns.length < 2) {
        return parsedPatterns;
    }
    const basenames = basenamePatterns.reduce((all, current) => {
        const basenames = current.basenames;
        return basenames ? all.concat(basenames) : all;
    }, []);
    let patterns;
    if (result) {
        patterns = [];
        for (let i = 0, n = basenames.length; i < n; i++) {
            patterns.push(result);
        }
    }
    else {
        patterns = basenamePatterns.reduce((all, current) => {
            const patterns = current.patterns;
            return patterns ? all.concat(patterns) : all;
        }, []);
    }
    const aggregate = function (path, basename) {
        if (typeof path !== 'string') {
            return null;
        }
        if (!basename) {
            let i;
            for (i = path.length; i > 0; i--) {
                const ch = path.charCodeAt(i - 1);
                if (ch === 47 /* CharCode.Slash */ || ch === 92 /* CharCode.Backslash */) {
                    break;
                }
            }
            basename = path.substr(i);
        }
        const index = basenames.indexOf(basename);
        return index !== -1 ? patterns[index] : null;
    };
    aggregate.basenames = basenames;
    aggregate.patterns = patterns;
    aggregate.allBasenames = basenames;
    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);
    aggregatedPatterns.push(aggregate);
    return aggregatedPatterns;
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfYmFzZV9jb21tb25fZ2xvYl9qcy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ087QUFDWDtBQUNzQjtBQUNsQjtBQUNxQjtBQUN0RDtBQUNBO0FBQ1AsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVyxHQUFHLGNBQWMsR0FBRyxXQUFXLEVBQUUsb0JBQW9CLFdBQVcsRUFBRSxjQUFjLFFBQVE7QUFDNUg7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUVBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7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QUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZ2xvYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1RoZW5hYmxlIH0gZnJvbSAnLi9hc3luYy5qcyc7XG5pbXBvcnQgeyBpc0VxdWFsT3JQYXJlbnQgfSBmcm9tICcuL2V4dHBhdGguanMnO1xuaW1wb3J0IHsgTFJVQ2FjaGUgfSBmcm9tICcuL21hcC5qcyc7XG5pbXBvcnQgeyBiYXNlbmFtZSwgZXh0bmFtZSwgcG9zaXgsIHNlcCB9IGZyb20gJy4vcGF0aC5qcyc7XG5pbXBvcnQgeyBpc0xpbnV4IH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgeyBlc2NhcGVSZWdFeHBDaGFyYWN0ZXJzLCBsdHJpbSB9IGZyb20gJy4vc3RyaW5ncy5qcyc7XG5leHBvcnQgY29uc3QgR0xPQlNUQVIgPSAnKionO1xuZXhwb3J0IGNvbnN0IEdMT0JfU1BMSVQgPSAnLyc7XG5jb25zdCBQQVRIX1JFR0VYID0gJ1svXFxcXFxcXFxdJzsgLy8gYW55IHNsYXNoIG9yIGJhY2tzbGFzaFxuY29uc3QgTk9fUEFUSF9SRUdFWCA9ICdbXi9cXFxcXFxcXF0nOyAvLyBhbnkgbm9uLXNsYXNoIGFuZCBub24tYmFja3NsYXNoXG5jb25zdCBBTExfRk9SV0FSRF9TTEFTSEVTID0gL1xcLy9nO1xuZnVuY3Rpb24gc3RhcnNUb1JlZ0V4cChzdGFyQ291bnQsIGlzTGFzdFBhdHRlcm4pIHtcbiAgICBzd2l0Y2ggKHN0YXJDb3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBgJHtOT19QQVRIX1JFR0VYfSo/YDsgLy8gMSBzdGFyIG1hdGNoZXMgYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VwdCBwYXRoIHNlcGFyYXRvciAoLyBhbmQgXFwpIC0gbm9uIGdyZWVkeSAoPylcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIE1hdGNoZXM6ICAoUGF0aCBTZXAgT1IgUGF0aCBWYWwgZm9sbG93ZWQgYnkgUGF0aCBTZXApIDAtbWFueSB0aW1lcyBleGNlcHQgd2hlbiBpdCdzIHRoZSBsYXN0IHBhdHRlcm5cbiAgICAgICAgICAgIC8vICAgICAgICAgICBpbiB3aGljaCBjYXNlIGFsc28gbWF0Y2hlcyAoUGF0aCBTZXAgZm9sbG93ZWQgYnkgUGF0aCBWYWwpXG4gICAgICAgICAgICAvLyBHcm91cCBpcyBub24gY2FwdHVyaW5nIGJlY2F1c2Ugd2UgZG9uJ3QgbmVlZCB0byBjYXB0dXJlIGF0IGFsbCAoPzouLi4pXG4gICAgICAgICAgICAvLyBPdmVyYWxsIHdlIHVzZSBub24tZ3JlZWR5IG1hdGNoaW5nIGJlY2F1c2UgaXQgY291bGQgYmUgdGhhdCB3ZSBtYXRjaCB0b28gbXVjaFxuICAgICAgICAgICAgcmV0dXJuIGAoPzoke1BBVEhfUkVHRVh9fCR7Tk9fUEFUSF9SRUdFWH0rJHtQQVRIX1JFR0VYfSR7aXNMYXN0UGF0dGVybiA/IGB8JHtQQVRIX1JFR0VYfSR7Tk9fUEFUSF9SRUdFWH0rYCA6ICcnfSkqP2A7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0R2xvYkF3YXJlKHBhdHRlcm4sIHNwbGl0Q2hhcikge1xuICAgIGlmICghcGF0dGVybikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgbGV0IGluQnJhY2VzID0gZmFsc2U7XG4gICAgbGV0IGluQnJhY2tldHMgPSBmYWxzZTtcbiAgICBsZXQgY3VyVmFsID0gJyc7XG4gICAgZm9yIChjb25zdCBjaGFyIG9mIHBhdHRlcm4pIHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgICBjYXNlIHNwbGl0Q2hhcjpcbiAgICAgICAgICAgICAgICBpZiAoIWluQnJhY2VzICYmICFpbkJyYWNrZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goY3VyVmFsKTtcbiAgICAgICAgICAgICAgICAgICAgY3VyVmFsID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIGluQnJhY2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgICAgIGluQnJhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICBpbkJyYWNrZXRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgIGluQnJhY2tldHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJWYWwgKz0gY2hhcjtcbiAgICB9XG4gICAgLy8gVGFpbFxuICAgIGlmIChjdXJWYWwpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChjdXJWYWwpO1xuICAgIH1cbiAgICByZXR1cm4gc2VnbWVudHM7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ0V4cChwYXR0ZXJuKSB7XG4gICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IHJlZ0V4ID0gJyc7XG4gICAgLy8gU3BsaXQgdXAgaW50byBzZWdtZW50cyBmb3IgZWFjaCBzbGFzaCBmb3VuZFxuICAgIGNvbnN0IHNlZ21lbnRzID0gc3BsaXRHbG9iQXdhcmUocGF0dGVybiwgR0xPQl9TUExJVCk7XG4gICAgLy8gU3BlY2lhbCBjYXNlIHdoZXJlIHdlIG9ubHkgaGF2ZSBnbG9ic3RhcnNcbiAgICBpZiAoc2VnbWVudHMuZXZlcnkoc2VnbWVudCA9PiBzZWdtZW50ID09PSBHTE9CU1RBUikpIHtcbiAgICAgICAgcmVnRXggPSAnLionO1xuICAgIH1cbiAgICAvLyBCdWlsZCByZWdleCBvdmVyIHNlZ21lbnRzXG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBwcmV2aW91c1NlZ21lbnRXYXNHbG9iU3RhciA9IGZhbHNlO1xuICAgICAgICBzZWdtZW50cy5mb3JFYWNoKChzZWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgLy8gVHJlYXQgZ2xvYnN0YXIgc3BlY2lhbGx5XG4gICAgICAgICAgICBpZiAoc2VnbWVudCA9PT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgZ2xvYnN0YXIgYWZ0ZXIgYW5vdGhlciwganVzdCBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNTZWdtZW50V2FzR2xvYlN0YXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWdFeCArPSBzdGFyc1RvUmVnRXhwKDIsIGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFueXRoaW5nIGVsc2UsIG5vdCBnbG9ic3RhclxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhdGVzXG4gICAgICAgICAgICAgICAgbGV0IGluQnJhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IGJyYWNlVmFsID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IGluQnJhY2tldHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgYnJhY2tldFZhbCA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hhciBvZiBzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgYnJhY2UgZXhwYW5zaW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyICE9PSAnfScgJiYgaW5CcmFjZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyYWNlVmFsICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGJyYWNrZXRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkJyYWNrZXRzICYmIChjaGFyICE9PSAnXScgfHwgIWJyYWNrZXRWYWwpIC8qIF0gaXMgbGl0ZXJhbGx5IG9ubHkgYWxsb3dlZCBhcyBmaXJzdCBjaGFyYWN0ZXIgaW4gYnJhY2tldHMgdG8gbWF0Y2ggaXQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByYW5nZSBvcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWdhdGlvbiBvcGVyYXRvciAob25seSB2YWxpZCBvbiBmaXJzdCBpbmRleCBpbiBicmFja2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKGNoYXIgPT09ICdeJyB8fCBjaGFyID09PSAnIScpICYmICFicmFja2V0VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gJ14nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYiBzcGxpdCBtYXRjaGluZyBpcyBub3QgYWxsb3dlZCB3aXRoaW4gY2hhcmFjdGVyIHJhbmdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGh0dHA6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuNy9nbG9iLjcuaHRtbFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gR0xPQl9TUExJVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBnZXRzIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoY2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmFja2V0VmFsICs9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5CcmFjZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5CcmFja2V0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd9Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNob2ljZXMgPSBzcGxpdEdsb2JBd2FyZShicmFjZVZhbCwgJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0cyB7Zm9vLGJhcn0gPT4gW2Zvb3xiYXJdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnJhY2VSZWdFeHAgPSBgKD86JHtjaG9pY2VzLm1hcChjaG9pY2UgPT4gcGFyc2VSZWdFeHAoY2hvaWNlKSkuam9pbignfCcpfSlgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ0V4ICs9IGJyYWNlUmVnRXhwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluQnJhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2VWYWwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ10nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnRXggKz0gKCdbJyArIGJyYWNrZXRWYWwgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluQnJhY2tldHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFja2V0VmFsID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdFeCArPSBOT19QQVRIX1JFR0VYOyAvLyAxID8gbWF0Y2hlcyBhbnkgc2luZ2xlIGNoYXJhY3RlciBleGNlcHQgcGF0aCBzZXBhcmF0b3IgKC8gYW5kIFxcKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnRXggKz0gc3RhcnNUb1JlZ0V4cCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnRXggKz0gZXNjYXBlUmVnRXhwQ2hhcmFjdGVycyhjaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUYWlsOiBBZGQgdGhlIHNsYXNoIHdlIGhhZCBzcGxpdCBvbiBpZiB0aGVyZSBpcyBtb3JlIHRvXG4gICAgICAgICAgICAgICAgLy8gY29tZSBhbmQgdGhlIHJlbWFpbmluZyBwYXR0ZXJuIGlzIG5vdCBhIGdsb2JzdGFyXG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUgaWYgcGF0dGVybjogc29tZS8qKi8qLmpzIHdlIHdhbnQgdGhlIFwiL1wiIGFmdGVyXG4gICAgICAgICAgICAgICAgLy8gc29tZSB0byBiZSBpbmNsdWRlZCBpbiB0aGUgUmVnRXggdG8gcHJldmVudCBhIGZvbGRlciBjYWxsZWRcbiAgICAgICAgICAgICAgICAvLyBcInNvbWV0aGluZ1wiIHRvIG1hdGNoIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgc2VnbWVudHMubGVuZ3RoIC0gMSAmJiAvLyBtb3JlIHNlZ21lbnRzIHRvIGNvbWUgYWZ0ZXIgdGhpc1xuICAgICAgICAgICAgICAgICAgICAoc2VnbWVudHNbaW5kZXggKyAxXSAhPT0gR0xPQlNUQVIgfHwgLy8gbmV4dCBzZWdtZW50IGlzIG5vdCAqKiwgb3IuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICsgMiA8IHNlZ21lbnRzLmxlbmd0aCAvLyAuLi5uZXh0IHNlZ21lbnQgaXMgKiogYnV0IHRoZXJlIGlzIG1vcmUgc2VnbWVudHMgYWZ0ZXIgdGhhdFxuICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ0V4ICs9IFBBVEhfUkVHRVg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXBkYXRlIGdsb2JzdGFyIHN0YXRlXG4gICAgICAgICAgICBwcmV2aW91c1NlZ21lbnRXYXNHbG9iU3RhciA9IChzZWdtZW50ID09PSBHTE9CU1RBUik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVnRXg7XG59XG4vLyByZWdleGVzIHRvIGNoZWNrIGZvciB0cml2aWFsIGdsb2IgcGF0dGVybnMgdGhhdCBqdXN0IGNoZWNrIGZvciBTdHJpbmcjZW5kc1dpdGhcbmNvbnN0IFQxID0gL15cXCpcXCpcXC9cXCpcXC5bXFx3XFwuLV0rJC87IC8vICoqLyouc29tZXRoaW5nXG5jb25zdCBUMiA9IC9eXFwqXFwqXFwvKFtcXHdcXC4tXSspXFwvPyQvOyAvLyAqKi9zb21ldGhpbmdcbmNvbnN0IFQzID0gL157XFwqXFwqXFwvXFwqP1tcXHdcXC4tXStcXC8/KCxcXCpcXCpcXC9cXCo/W1xcd1xcLi1dK1xcLz8pKn0kLzsgLy8geyoqLyouc29tZXRoaW5nLCoqLyouZWxzZX0gb3IgeyoqL3BhY2thZ2UuanNvbiwqKi9wcm9qZWN0Lmpzb259XG5jb25zdCBUM18yID0gL157XFwqXFwqXFwvXFwqP1tcXHdcXC4tXSsoXFwvKFxcKlxcKik/KT8oLFxcKlxcKlxcL1xcKj9bXFx3XFwuLV0rKFxcLyhcXCpcXCopPyk/KSp9JC87IC8vIExpa2UgVDMsIHdpdGggb3B0aW9uYWwgdHJhaWxpbmcgLyoqXG5jb25zdCBUNCA9IC9eXFwqXFwqKChcXC9bXFx3XFwuLV0rKSspXFwvPyQvOyAvLyAqKi9zb21ldGhpbmcvZWxzZVxuY29uc3QgVDUgPSAvXihbXFx3XFwuLV0rKFxcL1tcXHdcXC4tXSspKilcXC8/JC87IC8vIHNvbWV0aGluZy9lbHNlXG5jb25zdCBDQUNIRSA9IG5ldyBMUlVDYWNoZSgxMDAwMCk7IC8vIGJvdW5kZWQgdG8gMTAwMDAgZWxlbWVudHNcbmNvbnN0IEZBTFNFID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBOVUxMID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xufTtcbmZ1bmN0aW9uIHBhcnNlUGF0dGVybihhcmcxLCBvcHRpb25zKSB7XG4gICAgaWYgKCFhcmcxKSB7XG4gICAgICAgIHJldHVybiBOVUxMO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgcmVsYXRpdmUgcGF0dGVybnNcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAodHlwZW9mIGFyZzEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdHRlcm4gPSBhcmcxLnBhdHRlcm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gYXJnMTtcbiAgICB9XG4gICAgLy8gV2hpdGVzcGFjZSB0cmltbWluZ1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnRyaW0oKTtcbiAgICAvLyBDaGVjayBjYWNoZVxuICAgIGNvbnN0IHBhdHRlcm5LZXkgPSBgJHtwYXR0ZXJufV8keyEhb3B0aW9ucy50cmltRm9yRXhjbHVzaW9uc31gO1xuICAgIGxldCBwYXJzZWRQYXR0ZXJuID0gQ0FDSEUuZ2V0KHBhdHRlcm5LZXkpO1xuICAgIGlmIChwYXJzZWRQYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiB3cmFwUmVsYXRpdmVQYXR0ZXJuKHBhcnNlZFBhdHRlcm4sIGFyZzEpO1xuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgVHJpdmlhbHNcbiAgICBsZXQgbWF0Y2g7XG4gICAgaWYgKFQxLnRlc3QocGF0dGVybikpIHtcbiAgICAgICAgcGFyc2VkUGF0dGVybiA9IHRyaXZpYTEocGF0dGVybi5zdWJzdHIoNCksIHBhdHRlcm4pOyAvLyBjb21tb24gcGF0dGVybjogKiovKi50eHQganVzdCBuZWVkIGVuZHNXaXRoIGNoZWNrXG4gICAgfVxuICAgIGVsc2UgaWYgKG1hdGNoID0gVDIuZXhlYyh0cmltRm9yRXhjbHVzaW9ucyhwYXR0ZXJuLCBvcHRpb25zKSkpIHsgLy8gY29tbW9uIHBhdHRlcm46ICoqL3NvbWUudHh0IGp1c3QgbmVlZCBiYXNlbmFtZSBjaGVja1xuICAgICAgICBwYXJzZWRQYXR0ZXJuID0gdHJpdmlhMihtYXRjaFsxXSwgcGF0dGVybik7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcHRpb25zLnRyaW1Gb3JFeGNsdXNpb25zID8gVDNfMiA6IFQzKS50ZXN0KHBhdHRlcm4pKSB7IC8vIHJlcGV0aXRpb24gb2YgY29tbW9uIHBhdHRlcm5zIChzZWUgYWJvdmUpIHsqKi8qLnR4dCwqKi8qLnBuZ31cbiAgICAgICAgcGFyc2VkUGF0dGVybiA9IHRyaXZpYTMocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1hdGNoID0gVDQuZXhlYyh0cmltRm9yRXhjbHVzaW9ucyhwYXR0ZXJuLCBvcHRpb25zKSkpIHsgLy8gY29tbW9uIHBhdHRlcm46ICoqL3NvbWV0aGluZy9lbHNlIGp1c3QgbmVlZCBlbmRzV2l0aCBjaGVja1xuICAgICAgICBwYXJzZWRQYXR0ZXJuID0gdHJpdmlhNGFuZDUobWF0Y2hbMV0uc3Vic3RyKDEpLCBwYXR0ZXJuLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2ggPSBUNS5leGVjKHRyaW1Gb3JFeGNsdXNpb25zKHBhdHRlcm4sIG9wdGlvbnMpKSkgeyAvLyBjb21tb24gcGF0dGVybjogc29tZXRoaW5nL2Vsc2UganVzdCBuZWVkIGVxdWFscyBjaGVja1xuICAgICAgICBwYXJzZWRQYXR0ZXJuID0gdHJpdmlhNGFuZDUobWF0Y2hbMV0sIHBhdHRlcm4sIGZhbHNlKTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlIGNvbnZlcnQgdG8gcGF0dGVyblxuICAgIGVsc2Uge1xuICAgICAgICBwYXJzZWRQYXR0ZXJuID0gdG9SZWdFeHAocGF0dGVybik7XG4gICAgfVxuICAgIC8vIENhY2hlXG4gICAgQ0FDSEUuc2V0KHBhdHRlcm5LZXksIHBhcnNlZFBhdHRlcm4pO1xuICAgIHJldHVybiB3cmFwUmVsYXRpdmVQYXR0ZXJuKHBhcnNlZFBhdHRlcm4sIGFyZzEpO1xufVxuZnVuY3Rpb24gd3JhcFJlbGF0aXZlUGF0dGVybihwYXJzZWRQYXR0ZXJuLCBhcmcyKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFyc2VkUGF0dGVybjtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZFBhdHRlcm4gPSBmdW5jdGlvbiAocGF0aCwgYmFzZW5hbWUpIHtcbiAgICAgICAgaWYgKCFpc0VxdWFsT3JQYXJlbnQocGF0aCwgYXJnMi5iYXNlLCAhaXNMaW51eCkpIHtcbiAgICAgICAgICAgIC8vIHNraXAgZ2xvYiBtYXRjaGluZyBpZiBgYmFzZWAgaXMgbm90IGEgcGFyZW50IG9mIGBwYXRoYFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2l2ZW4gd2UgaGF2ZSBjaGVja2VkIGBiYXNlYCBiZWluZyBhIHBhcmVudCBvZiBgcGF0aGAsXG4gICAgICAgIC8vIHdlIGNhbiBub3cgcmVtb3ZlIHRoZSBgYmFzZWAgcG9ydGlvbiBvZiB0aGUgYHBhdGhgXG4gICAgICAgIC8vIGFuZCBvbmx5IG1hdGNoIG9uIHRoZSByZW1haW5pbmcgcGF0aCBjb21wb25lbnRzXG4gICAgICAgIC8vIEZvciB0aGF0IHdlIHRyeSB0byBleHRyYWN0IHRoZSBwb3J0aW9uIG9mIHRoZSBgcGF0aGBcbiAgICAgICAgLy8gdGhhdCBjb21lcyBhZnRlciB0aGUgYGJhc2VgIHBvcnRpb24uIFdlIGhhdmUgdG8gYWNjb3VudFxuICAgICAgICAvLyBmb3IgdGhlIGZhY3QgdGhhdCBgYmFzZWAgbWlnaHQgZW5kIGluIGEgcGF0aCBzZXBhcmF0b3JcbiAgICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvdnNjb2RlL2lzc3Vlcy8xNjI0OTgpXG4gICAgICAgIHJldHVybiBwYXJzZWRQYXR0ZXJuKGx0cmltKHBhdGguc3Vic3RyKGFyZzIuYmFzZS5sZW5ndGgpLCBzZXApLCBiYXNlbmFtZSk7XG4gICAgfTtcbiAgICAvLyBNYWtlIHN1cmUgdG8gcHJlc2VydmUgYXNzb2NpYXRlZCBtZXRhZGF0YVxuICAgIHdyYXBwZWRQYXR0ZXJuLmFsbEJhc2VuYW1lcyA9IHBhcnNlZFBhdHRlcm4uYWxsQmFzZW5hbWVzO1xuICAgIHdyYXBwZWRQYXR0ZXJuLmFsbFBhdGhzID0gcGFyc2VkUGF0dGVybi5hbGxQYXRocztcbiAgICB3cmFwcGVkUGF0dGVybi5iYXNlbmFtZXMgPSBwYXJzZWRQYXR0ZXJuLmJhc2VuYW1lcztcbiAgICB3cmFwcGVkUGF0dGVybi5wYXR0ZXJucyA9IHBhcnNlZFBhdHRlcm4ucGF0dGVybnM7XG4gICAgcmV0dXJuIHdyYXBwZWRQYXR0ZXJuO1xufVxuZnVuY3Rpb24gdHJpbUZvckV4Y2x1c2lvbnMocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnRyaW1Gb3JFeGNsdXNpb25zICYmIHBhdHRlcm4uZW5kc1dpdGgoJy8qKicpID8gcGF0dGVybi5zdWJzdHIoMCwgcGF0dGVybi5sZW5ndGggLSAyKSA6IHBhdHRlcm47IC8vIGRyb3BwaW5nICoqLCB0YWlsaW5nIC8gaXMgZHJvcHBlZCBsYXRlclxufVxuLy8gY29tbW9uIHBhdHRlcm46ICoqLyoudHh0IGp1c3QgbmVlZCBlbmRzV2l0aCBjaGVja1xuZnVuY3Rpb24gdHJpdmlhMShiYXNlLCBwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoLCBiYXNlbmFtZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmIHBhdGguZW5kc1dpdGgoYmFzZSkgPyBwYXR0ZXJuIDogbnVsbDtcbiAgICB9O1xufVxuLy8gY29tbW9uIHBhdHRlcm46ICoqL3NvbWUudHh0IGp1c3QgbmVlZCBiYXNlbmFtZSBjaGVja1xuZnVuY3Rpb24gdHJpdmlhMihiYXNlLCBwYXR0ZXJuKSB7XG4gICAgY29uc3Qgc2xhc2hCYXNlID0gYC8ke2Jhc2V9YDtcbiAgICBjb25zdCBiYWNrc2xhc2hCYXNlID0gYFxcXFwke2Jhc2V9YDtcbiAgICBjb25zdCBwYXJzZWRQYXR0ZXJuID0gZnVuY3Rpb24gKHBhdGgsIGJhc2VuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VuYW1lID09PSBiYXNlID8gcGF0dGVybiA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGggPT09IGJhc2UgfHwgcGF0aC5lbmRzV2l0aChzbGFzaEJhc2UpIHx8IHBhdGguZW5kc1dpdGgoYmFja3NsYXNoQmFzZSkgPyBwYXR0ZXJuIDogbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VuYW1lcyA9IFtiYXNlXTtcbiAgICBwYXJzZWRQYXR0ZXJuLmJhc2VuYW1lcyA9IGJhc2VuYW1lcztcbiAgICBwYXJzZWRQYXR0ZXJuLnBhdHRlcm5zID0gW3BhdHRlcm5dO1xuICAgIHBhcnNlZFBhdHRlcm4uYWxsQmFzZW5hbWVzID0gYmFzZW5hbWVzO1xuICAgIHJldHVybiBwYXJzZWRQYXR0ZXJuO1xufVxuLy8gcmVwZXRpdGlvbiBvZiBjb21tb24gcGF0dGVybnMgKHNlZSBhYm92ZSkgeyoqLyoudHh0LCoqLyoucG5nfVxuZnVuY3Rpb24gdHJpdmlhMyhwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFyc2VkUGF0dGVybnMgPSBhZ2dyZWdhdGVCYXNlbmFtZU1hdGNoZXMocGF0dGVybi5zbGljZSgxLCAtMSlcbiAgICAgICAgLnNwbGl0KCcsJylcbiAgICAgICAgLm1hcChwYXR0ZXJuID0+IHBhcnNlUGF0dGVybihwYXR0ZXJuLCBvcHRpb25zKSlcbiAgICAgICAgLmZpbHRlcihwYXR0ZXJuID0+IHBhdHRlcm4gIT09IE5VTEwpLCBwYXR0ZXJuKTtcbiAgICBjb25zdCBwYXR0ZXJuc0xlbmd0aCA9IHBhcnNlZFBhdHRlcm5zLmxlbmd0aDtcbiAgICBpZiAoIXBhdHRlcm5zTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBOVUxMO1xuICAgIH1cbiAgICBpZiAocGF0dGVybnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZFBhdHRlcm5zWzBdO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRQYXR0ZXJuID0gZnVuY3Rpb24gKHBhdGgsIGJhc2VuYW1lKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gcGFyc2VkUGF0dGVybnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VkUGF0dGVybnNbaV0ocGF0aCwgYmFzZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCB3aXRoQmFzZW5hbWVzID0gcGFyc2VkUGF0dGVybnMuZmluZChwYXR0ZXJuID0+ICEhcGF0dGVybi5hbGxCYXNlbmFtZXMpO1xuICAgIGlmICh3aXRoQmFzZW5hbWVzKSB7XG4gICAgICAgIHBhcnNlZFBhdHRlcm4uYWxsQmFzZW5hbWVzID0gd2l0aEJhc2VuYW1lcy5hbGxCYXNlbmFtZXM7XG4gICAgfVxuICAgIGNvbnN0IGFsbFBhdGhzID0gcGFyc2VkUGF0dGVybnMucmVkdWNlKChhbGwsIGN1cnJlbnQpID0+IGN1cnJlbnQuYWxsUGF0aHMgPyBhbGwuY29uY2F0KGN1cnJlbnQuYWxsUGF0aHMpIDogYWxsLCBbXSk7XG4gICAgaWYgKGFsbFBhdGhzLmxlbmd0aCkge1xuICAgICAgICBwYXJzZWRQYXR0ZXJuLmFsbFBhdGhzID0gYWxsUGF0aHM7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRQYXR0ZXJuO1xufVxuLy8gY29tbW9uIHBhdHRlcm5zOiAqKi9zb21ldGhpbmcvZWxzZSBqdXN0IG5lZWQgZW5kc1dpdGggY2hlY2ssIHNvbWV0aGluZy9lbHNlIGp1c3QgbmVlZHMgYW5kIGVxdWFscyBjaGVja1xuZnVuY3Rpb24gdHJpdmlhNGFuZDUodGFyZ2V0UGF0aCwgcGF0dGVybiwgbWF0Y2hQYXRoRW5kcykge1xuICAgIGNvbnN0IHVzaW5nUG9zaXhTZXAgPSBzZXAgPT09IHBvc2l4LnNlcDtcbiAgICBjb25zdCBuYXRpdmVQYXRoID0gdXNpbmdQb3NpeFNlcCA/IHRhcmdldFBhdGggOiB0YXJnZXRQYXRoLnJlcGxhY2UoQUxMX0ZPUldBUkRfU0xBU0hFUywgc2VwKTtcbiAgICBjb25zdCBuYXRpdmVQYXRoRW5kID0gc2VwICsgbmF0aXZlUGF0aDtcbiAgICBjb25zdCB0YXJnZXRQYXRoRW5kID0gcG9zaXguc2VwICsgdGFyZ2V0UGF0aDtcbiAgICBsZXQgcGFyc2VkUGF0dGVybjtcbiAgICBpZiAobWF0Y2hQYXRoRW5kcykge1xuICAgICAgICBwYXJzZWRQYXR0ZXJuID0gZnVuY3Rpb24gKHBhdGgsIGJhc2VuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmICgocGF0aCA9PT0gbmF0aXZlUGF0aCB8fCBwYXRoLmVuZHNXaXRoKG5hdGl2ZVBhdGhFbmQpKSB8fCAhdXNpbmdQb3NpeFNlcCAmJiAocGF0aCA9PT0gdGFyZ2V0UGF0aCB8fCBwYXRoLmVuZHNXaXRoKHRhcmdldFBhdGhFbmQpKSkgPyBwYXR0ZXJuIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcnNlZFBhdHRlcm4gPSBmdW5jdGlvbiAocGF0aCwgYmFzZW5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgKHBhdGggPT09IG5hdGl2ZVBhdGggfHwgKCF1c2luZ1Bvc2l4U2VwICYmIHBhdGggPT09IHRhcmdldFBhdGgpKSA/IHBhdHRlcm4gOiBudWxsO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXJzZWRQYXR0ZXJuLmFsbFBhdGhzID0gWyhtYXRjaFBhdGhFbmRzID8gJyovJyA6ICcuLycpICsgdGFyZ2V0UGF0aF07XG4gICAgcmV0dXJuIHBhcnNlZFBhdHRlcm47XG59XG5mdW5jdGlvbiB0b1JlZ0V4cChwYXR0ZXJuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cChgXiR7cGFyc2VSZWdFeHAocGF0dGVybil9JGApO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwOyAvLyByZXNldCBSZWdFeHAgdG8gaXRzIGluaXRpYWwgc3RhdGUgdG8gcmV1c2UgaXQhXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmIHJlZ0V4cC50ZXN0KHBhdGgpID8gcGF0dGVybiA6IG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gTlVMTDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbWF0Y2goYXJnMSwgcGF0aCwgaGFzU2libGluZykge1xuICAgIGlmICghYXJnMSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UoYXJnMSkocGF0aCwgdW5kZWZpbmVkLCBoYXNTaWJsaW5nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShhcmcxLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWFyZzEpIHtcbiAgICAgICAgcmV0dXJuIEZBTFNFO1xuICAgIH1cbiAgICAvLyBHbG9iIHdpdGggU3RyaW5nXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnc3RyaW5nJyB8fCBpc1JlbGF0aXZlUGF0dGVybihhcmcxKSkge1xuICAgICAgICBjb25zdCBwYXJzZWRQYXR0ZXJuID0gcGFyc2VQYXR0ZXJuKGFyZzEsIG9wdGlvbnMpO1xuICAgICAgICBpZiAocGFyc2VkUGF0dGVybiA9PT0gTlVMTCkge1xuICAgICAgICAgICAgcmV0dXJuIEZBTFNFO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdFBhdHRlcm4gPSBmdW5jdGlvbiAocGF0aCwgYmFzZW5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXBhcnNlZFBhdHRlcm4ocGF0aCwgYmFzZW5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocGFyc2VkUGF0dGVybi5hbGxCYXNlbmFtZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdFBhdHRlcm4uYWxsQmFzZW5hbWVzID0gcGFyc2VkUGF0dGVybi5hbGxCYXNlbmFtZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZFBhdHRlcm4uYWxsUGF0aHMpIHtcbiAgICAgICAgICAgIHJlc3VsdFBhdHRlcm4uYWxsUGF0aHMgPSBwYXJzZWRQYXR0ZXJuLmFsbFBhdGhzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRQYXR0ZXJuO1xuICAgIH1cbiAgICAvLyBHbG9iIHdpdGggRXhwcmVzc2lvblxuICAgIHJldHVybiBwYXJzZWRFeHByZXNzaW9uKGFyZzEsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVsYXRpdmVQYXR0ZXJuKG9iaikge1xuICAgIGNvbnN0IHJwID0gb2JqO1xuICAgIGlmICghcnApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHJwLmJhc2UgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBycC5wYXR0ZXJuID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIHBhcnNlZEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhcnNlZFBhdHRlcm5zID0gYWdncmVnYXRlQmFzZW5hbWVNYXRjaGVzKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGV4cHJlc3Npb24pXG4gICAgICAgIC5tYXAocGF0dGVybiA9PiBwYXJzZUV4cHJlc3Npb25QYXR0ZXJuKHBhdHRlcm4sIGV4cHJlc3Npb25bcGF0dGVybl0sIG9wdGlvbnMpKVxuICAgICAgICAuZmlsdGVyKHBhdHRlcm4gPT4gcGF0dGVybiAhPT0gTlVMTCkpO1xuICAgIGNvbnN0IHBhdHRlcm5zTGVuZ3RoID0gcGFyc2VkUGF0dGVybnMubGVuZ3RoO1xuICAgIGlmICghcGF0dGVybnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIE5VTEw7XG4gICAgfVxuICAgIGlmICghcGFyc2VkUGF0dGVybnMuc29tZShwYXJzZWRQYXR0ZXJuID0+ICEhcGFyc2VkUGF0dGVybi5yZXF1aXJlc1NpYmxpbmdzKSkge1xuICAgICAgICBpZiAocGF0dGVybnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRQYXR0ZXJuc1swXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHBhdGgsIGJhc2VuYW1lKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0UHJvbWlzZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHBhcnNlZFBhdHRlcm5zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlZFBhdHRlcm5zW2ldKHBhdGgsIGJhc2VuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsgLy8gaW1tZWRpYXRlbHkgcmV0dXJuIGFzIHNvb24gYXMgdGhlIGZpcnN0IGV4cHJlc3Npb24gbWF0Y2hlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIGEgcHJvbWlzZSwgd2UgaGF2ZSB0byBrZWVwIGl0IGZvclxuICAgICAgICAgICAgICAgIC8vIGxhdGVyIHByb2Nlc3NpbmcgYW5kIGF3YWl0IHRoZSByZXN1bHQgcHJvcGVybHkuXG4gICAgICAgICAgICAgICAgaWYgKGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2VzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaXRoIHJlc3VsdCBwcm9taXNlcywgd2UgaGF2ZSB0byBsb29wIG92ZXIgZWFjaCBhbmRcbiAgICAgICAgICAgIC8vIGF3YWl0IHRoZSByZXN1bHQgYmVmb3JlIHdlIGNhbiByZXR1cm4gYW55IHJlc3VsdC5cbiAgICAgICAgICAgIGlmIChyZXN1bHRQcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdFByb21pc2Ugb2YgcmVzdWx0UHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3VsdFByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgd2l0aEJhc2VuYW1lcyA9IHBhcnNlZFBhdHRlcm5zLmZpbmQocGF0dGVybiA9PiAhIXBhdHRlcm4uYWxsQmFzZW5hbWVzKTtcbiAgICAgICAgaWYgKHdpdGhCYXNlbmFtZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdEV4cHJlc3Npb24uYWxsQmFzZW5hbWVzID0gd2l0aEJhc2VuYW1lcy5hbGxCYXNlbmFtZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsUGF0aHMgPSBwYXJzZWRQYXR0ZXJucy5yZWR1Y2UoKGFsbCwgY3VycmVudCkgPT4gY3VycmVudC5hbGxQYXRocyA/IGFsbC5jb25jYXQoY3VycmVudC5hbGxQYXRocykgOiBhbGwsIFtdKTtcbiAgICAgICAgaWYgKGFsbFBhdGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0RXhwcmVzc2lvbi5hbGxQYXRocyA9IGFsbFBhdGhzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRFeHByZXNzaW9uO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHBhdGgsIGJhc2UsIGhhc1NpYmxpbmcpIHtcbiAgICAgICAgbGV0IG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXN1bHRQcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBwYXJzZWRQYXR0ZXJucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFBhdHRlcm4gbWF0Y2hlcyBwYXRoXG4gICAgICAgICAgICBjb25zdCBwYXJzZWRQYXR0ZXJuID0gcGFyc2VkUGF0dGVybnNbaV07XG4gICAgICAgICAgICBpZiAocGFyc2VkUGF0dGVybi5yZXF1aXJlc1NpYmxpbmdzICYmIGhhc1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2VuYW1lKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGJhc2Uuc3Vic3RyKDAsIGJhc2UubGVuZ3RoIC0gZXh0bmFtZShwYXRoKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlZFBhdHRlcm4ocGF0aCwgYmFzZSwgbmFtZSwgaGFzU2libGluZyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0OyAvLyBpbW1lZGlhdGVseSByZXR1cm4gYXMgc29vbiBhcyB0aGUgZmlyc3QgZXhwcmVzc2lvbiBtYXRjaGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIGEgcHJvbWlzZSwgd2UgaGF2ZSB0byBrZWVwIGl0IGZvclxuICAgICAgICAgICAgLy8gbGF0ZXIgcHJvY2Vzc2luZyBhbmQgYXdhaXQgdGhlIHJlc3VsdCBwcm9wZXJseS5cbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2VzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXaXRoIHJlc3VsdCBwcm9taXNlcywgd2UgaGF2ZSB0byBsb29wIG92ZXIgZWFjaCBhbmRcbiAgICAgICAgLy8gYXdhaXQgdGhlIHJlc3VsdCBiZWZvcmUgd2UgY2FuIHJldHVybiBhbnkgcmVzdWx0LlxuICAgICAgICBpZiAocmVzdWx0UHJvbWlzZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0UHJvbWlzZSBvZiByZXN1bHRQcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXN1bHRQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3Qgd2l0aEJhc2VuYW1lcyA9IHBhcnNlZFBhdHRlcm5zLmZpbmQocGF0dGVybiA9PiAhIXBhdHRlcm4uYWxsQmFzZW5hbWVzKTtcbiAgICBpZiAod2l0aEJhc2VuYW1lcykge1xuICAgICAgICByZXN1bHRFeHByZXNzaW9uLmFsbEJhc2VuYW1lcyA9IHdpdGhCYXNlbmFtZXMuYWxsQmFzZW5hbWVzO1xuICAgIH1cbiAgICBjb25zdCBhbGxQYXRocyA9IHBhcnNlZFBhdHRlcm5zLnJlZHVjZSgoYWxsLCBjdXJyZW50KSA9PiBjdXJyZW50LmFsbFBhdGhzID8gYWxsLmNvbmNhdChjdXJyZW50LmFsbFBhdGhzKSA6IGFsbCwgW10pO1xuICAgIGlmIChhbGxQYXRocy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0RXhwcmVzc2lvbi5hbGxQYXRocyA9IGFsbFBhdGhzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0RXhwcmVzc2lvbjtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvblBhdHRlcm4ocGF0dGVybiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBOVUxMOyAvLyBwYXR0ZXJuIGlzIGRpc2FibGVkXG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFBhdHRlcm4gPSBwYXJzZVBhdHRlcm4ocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgaWYgKHBhcnNlZFBhdHRlcm4gPT09IE5VTEwpIHtcbiAgICAgICAgcmV0dXJuIE5VTEw7XG4gICAgfVxuICAgIC8vIEV4cHJlc3Npb24gUGF0dGVybiBpcyA8Ym9vbGVhbj5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZFBhdHRlcm47XG4gICAgfVxuICAgIC8vIEV4cHJlc3Npb24gUGF0dGVybiBpcyA8U2libGluZ0NsYXVzZT5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgd2hlbiA9IHZhbHVlLndoZW47XG4gICAgICAgIGlmICh0eXBlb2Ygd2hlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChwYXRoLCBiYXNlbmFtZSwgbmFtZSwgaGFzU2libGluZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaGFzU2libGluZyB8fCAhcGFyc2VkUGF0dGVybihwYXRoLCBiYXNlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXVzZVBhdHRlcm4gPSB3aGVuLnJlcGxhY2UoJyQoYmFzZW5hbWUpJywgKCkgPT4gbmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZCA9IGhhc1NpYmxpbmcoY2xhdXNlUGF0dGVybik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVGhlbmFibGUobWF0Y2hlZCkgP1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnRoZW4obWF0Y2ggPT4gbWF0Y2ggPyBwYXR0ZXJuIDogbnVsbCkgOlxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID8gcGF0dGVybiA6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0LnJlcXVpcmVzU2libGluZ3MgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBFeHByZXNzaW9uIGlzIGFueXRoaW5nXG4gICAgcmV0dXJuIHBhcnNlZFBhdHRlcm47XG59XG5mdW5jdGlvbiBhZ2dyZWdhdGVCYXNlbmFtZU1hdGNoZXMocGFyc2VkUGF0dGVybnMsIHJlc3VsdCkge1xuICAgIGNvbnN0IGJhc2VuYW1lUGF0dGVybnMgPSBwYXJzZWRQYXR0ZXJucy5maWx0ZXIocGFyc2VkUGF0dGVybiA9PiAhIXBhcnNlZFBhdHRlcm4uYmFzZW5hbWVzKTtcbiAgICBpZiAoYmFzZW5hbWVQYXR0ZXJucy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWRQYXR0ZXJucztcbiAgICB9XG4gICAgY29uc3QgYmFzZW5hbWVzID0gYmFzZW5hbWVQYXR0ZXJucy5yZWR1Y2UoKGFsbCwgY3VycmVudCkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlbmFtZXMgPSBjdXJyZW50LmJhc2VuYW1lcztcbiAgICAgICAgcmV0dXJuIGJhc2VuYW1lcyA/IGFsbC5jb25jYXQoYmFzZW5hbWVzKSA6IGFsbDtcbiAgICB9LCBbXSk7XG4gICAgbGV0IHBhdHRlcm5zO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcGF0dGVybnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBiYXNlbmFtZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBwYXR0ZXJucy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhdHRlcm5zID0gYmFzZW5hbWVQYXR0ZXJucy5yZWR1Y2UoKGFsbCwgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybnMgPSBjdXJyZW50LnBhdHRlcm5zO1xuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm5zID8gYWxsLmNvbmNhdChwYXR0ZXJucykgOiBhbGw7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgY29uc3QgYWdncmVnYXRlID0gZnVuY3Rpb24gKHBhdGgsIGJhc2VuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmFzZW5hbWUpIHtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IHBhdGguY2hhckNvZGVBdChpIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSA0NyAvKiBDaGFyQ29kZS5TbGFzaCAqLyB8fCBjaCA9PT0gOTIgLyogQ2hhckNvZGUuQmFja3NsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2VuYW1lID0gcGF0aC5zdWJzdHIoaSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSBiYXNlbmFtZXMuaW5kZXhPZihiYXNlbmFtZSk7XG4gICAgICAgIHJldHVybiBpbmRleCAhPT0gLTEgPyBwYXR0ZXJuc1tpbmRleF0gOiBudWxsO1xuICAgIH07XG4gICAgYWdncmVnYXRlLmJhc2VuYW1lcyA9IGJhc2VuYW1lcztcbiAgICBhZ2dyZWdhdGUucGF0dGVybnMgPSBwYXR0ZXJucztcbiAgICBhZ2dyZWdhdGUuYWxsQmFzZW5hbWVzID0gYmFzZW5hbWVzO1xuICAgIGNvbnN0IGFnZ3JlZ2F0ZWRQYXR0ZXJucyA9IHBhcnNlZFBhdHRlcm5zLmZpbHRlcihwYXJzZWRQYXR0ZXJuID0+ICFwYXJzZWRQYXR0ZXJuLmJhc2VuYW1lcyk7XG4gICAgYWdncmVnYXRlZFBhdHRlcm5zLnB1c2goYWdncmVnYXRlKTtcbiAgICByZXR1cm4gYWdncmVnYXRlZFBhdHRlcm5zO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9