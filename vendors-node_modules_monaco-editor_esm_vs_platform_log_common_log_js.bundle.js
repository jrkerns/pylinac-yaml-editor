"use strict";
(self["webpackChunkpylinac_yaml_editor"] = self["webpackChunkpylinac_yaml_editor"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_platform_log_common_log_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js":
/*!************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContextKeyAndExpr: () => (/* binding */ ContextKeyAndExpr),
/* harmony export */   ContextKeyDefinedExpr: () => (/* binding */ ContextKeyDefinedExpr),
/* harmony export */   ContextKeyEqualsExpr: () => (/* binding */ ContextKeyEqualsExpr),
/* harmony export */   ContextKeyExpr: () => (/* binding */ ContextKeyExpr),
/* harmony export */   ContextKeyFalseExpr: () => (/* binding */ ContextKeyFalseExpr),
/* harmony export */   ContextKeyGreaterEqualsExpr: () => (/* binding */ ContextKeyGreaterEqualsExpr),
/* harmony export */   ContextKeyGreaterExpr: () => (/* binding */ ContextKeyGreaterExpr),
/* harmony export */   ContextKeyInExpr: () => (/* binding */ ContextKeyInExpr),
/* harmony export */   ContextKeyNotEqualsExpr: () => (/* binding */ ContextKeyNotEqualsExpr),
/* harmony export */   ContextKeyNotExpr: () => (/* binding */ ContextKeyNotExpr),
/* harmony export */   ContextKeyNotInExpr: () => (/* binding */ ContextKeyNotInExpr),
/* harmony export */   ContextKeyNotRegexExpr: () => (/* binding */ ContextKeyNotRegexExpr),
/* harmony export */   ContextKeyOrExpr: () => (/* binding */ ContextKeyOrExpr),
/* harmony export */   ContextKeyRegexExpr: () => (/* binding */ ContextKeyRegexExpr),
/* harmony export */   ContextKeySmallerEqualsExpr: () => (/* binding */ ContextKeySmallerEqualsExpr),
/* harmony export */   ContextKeySmallerExpr: () => (/* binding */ ContextKeySmallerExpr),
/* harmony export */   ContextKeyTrueExpr: () => (/* binding */ ContextKeyTrueExpr),
/* harmony export */   IContextKeyService: () => (/* binding */ IContextKeyService),
/* harmony export */   Parser: () => (/* binding */ Parser),
/* harmony export */   RawContextKey: () => (/* binding */ RawContextKey),
/* harmony export */   expressionsAreEqualWithConstantSubstitution: () => (/* binding */ expressionsAreEqualWithConstantSubstitution),
/* harmony export */   implies: () => (/* binding */ implies)
/* harmony export */ });
/* harmony import */ var _base_common_platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _scanner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scanner.js */ "./node_modules/monaco-editor/esm/vs/platform/contextkey/common/scanner.js");
/* harmony import */ var _instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../instantiation/common/instantiation.js */ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js");
/* harmony import */ var _nls_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../nls.js */ "./node_modules/monaco-editor/esm/vs/nls.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





const CONSTANT_VALUES = new Map();
CONSTANT_VALUES.set('false', false);
CONSTANT_VALUES.set('true', true);
CONSTANT_VALUES.set('isMac', _base_common_platform_js__WEBPACK_IMPORTED_MODULE_0__.isMacintosh);
CONSTANT_VALUES.set('isLinux', _base_common_platform_js__WEBPACK_IMPORTED_MODULE_0__.isLinux);
CONSTANT_VALUES.set('isWindows', _base_common_platform_js__WEBPACK_IMPORTED_MODULE_0__.isWindows);
CONSTANT_VALUES.set('isWeb', _base_common_platform_js__WEBPACK_IMPORTED_MODULE_0__.isWeb);
CONSTANT_VALUES.set('isMacNative', _base_common_platform_js__WEBPACK_IMPORTED_MODULE_0__.isMacintosh && !_base_common_platform_js__WEBPACK_IMPORTED_MODULE_0__.isWeb);
CONSTANT_VALUES.set('isEdge', _base_common_platform_js__WEBPACK_IMPORTED_MODULE_0__.isEdge);
CONSTANT_VALUES.set('isFirefox', _base_common_platform_js__WEBPACK_IMPORTED_MODULE_0__.isFirefox);
CONSTANT_VALUES.set('isChrome', _base_common_platform_js__WEBPACK_IMPORTED_MODULE_0__.isChrome);
CONSTANT_VALUES.set('isSafari', _base_common_platform_js__WEBPACK_IMPORTED_MODULE_0__.isSafari);
const hasOwnProperty = Object.prototype.hasOwnProperty;
const defaultConfig = {
    regexParsingWithErrorRecovery: true
};
const errorEmptyString = (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('contextkey.parser.error.emptyString', "Empty context key expression");
const hintEmptyString = (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('contextkey.parser.error.emptyString.hint', "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.");
const errorNoInAfterNot = (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('contextkey.parser.error.noInAfterNot', "'in' after 'not'.");
const errorClosingParenthesis = (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('contextkey.parser.error.closingParenthesis', "closing parenthesis ')'");
const errorUnexpectedToken = (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('contextkey.parser.error.unexpectedToken', "Unexpected token");
const hintUnexpectedToken = (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('contextkey.parser.error.unexpectedToken.hint', "Did you forget to put && or || before the token?");
const errorUnexpectedEOF = (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('contextkey.parser.error.unexpectedEOF', "Unexpected end of expression");
const hintUnexpectedEOF = (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('contextkey.parser.error.unexpectedEOF.hint', "Did you forget to put a context key?");
/**
 * A parser for context key expressions.
 *
 * Example:
 * ```ts
 * const parser = new Parser();
 * const expr = parser.parse('foo == "bar" && baz == true');
 *
 * if (expr === undefined) {
 * 	// there were lexing or parsing errors
 * 	// process lexing errors with `parser.lexingErrors`
 *  // process parsing errors with `parser.parsingErrors`
 * } else {
 * 	// expr is a valid expression
 * }
 * ```
 */
class Parser {
    // Note: this doesn't produce an exact syntax tree but a normalized one
    // ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize
    static { this._parseError = new Error(); }
    constructor(_config = defaultConfig) {
        this._config = _config;
        // lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`
        this._scanner = new _scanner_js__WEBPACK_IMPORTED_MODULE_2__.Scanner();
        // lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`
        this._tokens = [];
        this._current = 0; // invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`
        this._parsingErrors = [];
        this._flagsGYRe = /g|y/g;
    }
    /**
     * Parse a context key expression.
     *
     * @param input the expression to parse
     * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors
     */
    parse(input) {
        if (input === '') {
            this._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: '', additionalInfo: hintEmptyString });
            return undefined;
        }
        this._tokens = this._scanner.reset(input).scan();
        // @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery
        this._current = 0;
        this._parsingErrors = [];
        try {
            const expr = this._expr();
            if (!this._isAtEnd()) {
                const peek = this._peek();
                const additionalInfo = peek.type === 17 /* TokenType.Str */ ? hintUnexpectedToken : undefined;
                this._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: _scanner_js__WEBPACK_IMPORTED_MODULE_2__.Scanner.getLexeme(peek), additionalInfo });
                throw Parser._parseError;
            }
            return expr;
        }
        catch (e) {
            if (!(e === Parser._parseError)) {
                throw e;
            }
            return undefined;
        }
    }
    _expr() {
        return this._or();
    }
    _or() {
        const expr = [this._and()];
        while (this._matchOne(16 /* TokenType.Or */)) {
            const right = this._and();
            expr.push(right);
        }
        return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);
    }
    _and() {
        const expr = [this._term()];
        while (this._matchOne(15 /* TokenType.And */)) {
            const right = this._term();
            expr.push(right);
        }
        return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);
    }
    _term() {
        if (this._matchOne(2 /* TokenType.Neg */)) {
            const peek = this._peek();
            switch (peek.type) {
                case 11 /* TokenType.True */:
                    this._advance();
                    return ContextKeyFalseExpr.INSTANCE;
                case 12 /* TokenType.False */:
                    this._advance();
                    return ContextKeyTrueExpr.INSTANCE;
                case 0 /* TokenType.LParen */: {
                    this._advance();
                    const expr = this._expr();
                    this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);
                    return expr?.negate();
                }
                case 17 /* TokenType.Str */:
                    this._advance();
                    return ContextKeyNotExpr.create(peek.lexeme);
                default:
                    throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);
            }
        }
        return this._primary();
    }
    _primary() {
        const peek = this._peek();
        switch (peek.type) {
            case 11 /* TokenType.True */:
                this._advance();
                return ContextKeyExpr.true();
            case 12 /* TokenType.False */:
                this._advance();
                return ContextKeyExpr.false();
            case 0 /* TokenType.LParen */: {
                this._advance();
                const expr = this._expr();
                this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);
                return expr;
            }
            case 17 /* TokenType.Str */: {
                // KEY
                const key = peek.lexeme;
                this._advance();
                // =~ regex
                if (this._matchOne(9 /* TokenType.RegexOp */)) {
                    // @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes
                    const expr = this._peek();
                    if (!this._config.regexParsingWithErrorRecovery) {
                        this._advance();
                        if (expr.type !== 10 /* TokenType.RegexStr */) {
                            throw this._errExpectedButGot(`REGEX`, expr);
                        }
                        const regexLexeme = expr.lexeme;
                        const closingSlashIndex = regexLexeme.lastIndexOf('/');
                        const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));
                        let regexp;
                        try {
                            regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
                        }
                        catch (e) {
                            throw this._errExpectedButGot(`REGEX`, expr);
                        }
                        return ContextKeyRegexExpr.create(key, regexp);
                    }
                    switch (expr.type) {
                        case 10 /* TokenType.RegexStr */:
                        case 19 /* TokenType.Error */: { // also handle an ErrorToken in case of smth such as /(/file)/
                            const lexemeReconstruction = [expr.lexeme]; // /REGEX/ or /REGEX/FLAGS
                            this._advance();
                            let followingToken = this._peek();
                            let parenBalance = 0;
                            for (let i = 0; i < expr.lexeme.length; i++) {
                                if (expr.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {
                                    parenBalance++;
                                }
                                else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {
                                    parenBalance--;
                                }
                            }
                            while (!this._isAtEnd() && followingToken.type !== 15 /* TokenType.And */ && followingToken.type !== 16 /* TokenType.Or */) {
                                switch (followingToken.type) {
                                    case 0 /* TokenType.LParen */:
                                        parenBalance++;
                                        break;
                                    case 1 /* TokenType.RParen */:
                                        parenBalance--;
                                        break;
                                    case 10 /* TokenType.RegexStr */:
                                    case 18 /* TokenType.QuotedStr */:
                                        for (let i = 0; i < followingToken.lexeme.length; i++) {
                                            if (followingToken.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {
                                                parenBalance++;
                                            }
                                            else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {
                                                parenBalance--;
                                            }
                                        }
                                }
                                if (parenBalance < 0) {
                                    break;
                                }
                                lexemeReconstruction.push(_scanner_js__WEBPACK_IMPORTED_MODULE_2__.Scanner.getLexeme(followingToken));
                                this._advance();
                                followingToken = this._peek();
                            }
                            const regexLexeme = lexemeReconstruction.join('');
                            const closingSlashIndex = regexLexeme.lastIndexOf('/');
                            const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));
                            let regexp;
                            try {
                                regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
                            }
                            catch (e) {
                                throw this._errExpectedButGot(`REGEX`, expr);
                            }
                            return ContextKeyExpr.regex(key, regexp);
                        }
                        case 18 /* TokenType.QuotedStr */: {
                            const serializedValue = expr.lexeme;
                            this._advance();
                            // replicate old regex parsing behavior
                            let regex = null;
                            if (!(0,_base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.isFalsyOrWhitespace)(serializedValue)) {
                                const start = serializedValue.indexOf('/');
                                const end = serializedValue.lastIndexOf('/');
                                if (start !== end && start >= 0) {
                                    const value = serializedValue.slice(start + 1, end);
                                    const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';
                                    try {
                                        regex = new RegExp(value, caseIgnoreFlag);
                                    }
                                    catch (_e) {
                                        throw this._errExpectedButGot(`REGEX`, expr);
                                    }
                                }
                            }
                            if (regex === null) {
                                throw this._errExpectedButGot('REGEX', expr);
                            }
                            return ContextKeyRegexExpr.create(key, regex);
                        }
                        default:
                            throw this._errExpectedButGot('REGEX', this._peek());
                    }
                }
                // [ 'not' 'in' value ]
                if (this._matchOne(14 /* TokenType.Not */)) {
                    this._consume(13 /* TokenType.In */, errorNoInAfterNot);
                    const right = this._value();
                    return ContextKeyExpr.notIn(key, right);
                }
                // [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]
                const maybeOp = this._peek().type;
                switch (maybeOp) {
                    case 3 /* TokenType.Eq */: {
                        this._advance();
                        const right = this._value();
                        if (this._previous().type === 18 /* TokenType.QuotedStr */) { // to preserve old parser behavior: "foo == 'true'" is preserved as "foo == 'true'", but "foo == true" is optimized as "foo"
                            return ContextKeyExpr.equals(key, right);
                        }
                        switch (right) {
                            case 'true':
                                return ContextKeyExpr.has(key);
                            case 'false':
                                return ContextKeyExpr.not(key);
                            default:
                                return ContextKeyExpr.equals(key, right);
                        }
                    }
                    case 4 /* TokenType.NotEq */: {
                        this._advance();
                        const right = this._value();
                        if (this._previous().type === 18 /* TokenType.QuotedStr */) { // same as above with "foo != 'true'"
                            return ContextKeyExpr.notEquals(key, right);
                        }
                        switch (right) {
                            case 'true':
                                return ContextKeyExpr.not(key);
                            case 'false':
                                return ContextKeyExpr.has(key);
                            default:
                                return ContextKeyExpr.notEquals(key, right);
                        }
                    }
                    // TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number
                    // consequently, package.json linter should _warn_ the user if they're passing undesired things to ops
                    case 5 /* TokenType.Lt */:
                        this._advance();
                        return ContextKeySmallerExpr.create(key, this._value());
                    case 6 /* TokenType.LtEq */:
                        this._advance();
                        return ContextKeySmallerEqualsExpr.create(key, this._value());
                    case 7 /* TokenType.Gt */:
                        this._advance();
                        return ContextKeyGreaterExpr.create(key, this._value());
                    case 8 /* TokenType.GtEq */:
                        this._advance();
                        return ContextKeyGreaterEqualsExpr.create(key, this._value());
                    case 13 /* TokenType.In */:
                        this._advance();
                        return ContextKeyExpr.in(key, this._value());
                    default:
                        return ContextKeyExpr.has(key);
                }
            }
            case 20 /* TokenType.EOF */:
                this._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: '', additionalInfo: hintUnexpectedEOF });
                throw Parser._parseError;
            default:
                throw this._errExpectedButGot(`true | false | KEY \n\t| KEY '=~' REGEX \n\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());
        }
    }
    _value() {
        const token = this._peek();
        switch (token.type) {
            case 17 /* TokenType.Str */:
            case 18 /* TokenType.QuotedStr */:
                this._advance();
                return token.lexeme;
            case 11 /* TokenType.True */:
                this._advance();
                return 'true';
            case 12 /* TokenType.False */:
                this._advance();
                return 'false';
            case 13 /* TokenType.In */: // we support `in` as a value, e.g., "when": "languageId == in" - exists in existing extensions
                this._advance();
                return 'in';
            default:
                // this allows "when": "foo == " which's used by existing extensions
                // we do not call `_advance` on purpose - we don't want to eat unintended tokens
                return '';
        }
    }
    _removeFlagsGY(flags) {
        return flags.replaceAll(this._flagsGYRe, '');
    }
    // careful: this can throw if current token is the initial one (ie index = 0)
    _previous() {
        return this._tokens[this._current - 1];
    }
    _matchOne(token) {
        if (this._check(token)) {
            this._advance();
            return true;
        }
        return false;
    }
    _advance() {
        if (!this._isAtEnd()) {
            this._current++;
        }
        return this._previous();
    }
    _consume(type, message) {
        if (this._check(type)) {
            return this._advance();
        }
        throw this._errExpectedButGot(message, this._peek());
    }
    _errExpectedButGot(expected, got, additionalInfo) {
        const message = (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('contextkey.parser.error.expectedButGot', "Expected: {0}\nReceived: '{1}'.", expected, _scanner_js__WEBPACK_IMPORTED_MODULE_2__.Scanner.getLexeme(got));
        const offset = got.offset;
        const lexeme = _scanner_js__WEBPACK_IMPORTED_MODULE_2__.Scanner.getLexeme(got);
        this._parsingErrors.push({ message, offset, lexeme, additionalInfo });
        return Parser._parseError;
    }
    _check(type) {
        return this._peek().type === type;
    }
    _peek() {
        return this._tokens[this._current];
    }
    _isAtEnd() {
        return this._peek().type === 20 /* TokenType.EOF */;
    }
}
class ContextKeyExpr {
    static false() {
        return ContextKeyFalseExpr.INSTANCE;
    }
    static true() {
        return ContextKeyTrueExpr.INSTANCE;
    }
    static has(key) {
        return ContextKeyDefinedExpr.create(key);
    }
    static equals(key, value) {
        return ContextKeyEqualsExpr.create(key, value);
    }
    static notEquals(key, value) {
        return ContextKeyNotEqualsExpr.create(key, value);
    }
    static regex(key, value) {
        return ContextKeyRegexExpr.create(key, value);
    }
    static in(key, value) {
        return ContextKeyInExpr.create(key, value);
    }
    static notIn(key, value) {
        return ContextKeyNotInExpr.create(key, value);
    }
    static not(key) {
        return ContextKeyNotExpr.create(key);
    }
    static and(...expr) {
        return ContextKeyAndExpr.create(expr, null, true);
    }
    static or(...expr) {
        return ContextKeyOrExpr.create(expr, null, true);
    }
    static { this._parser = new Parser({ regexParsingWithErrorRecovery: false }); }
    static deserialize(serialized) {
        if (serialized === undefined || serialized === null) { // an empty string needs to be handled by the parser to get a corresponding parsing error reported
            return undefined;
        }
        const expr = this._parser.parse(serialized);
        return expr;
    }
}
function expressionsAreEqualWithConstantSubstitution(a, b) {
    const aExpr = a ? a.substituteConstants() : undefined;
    const bExpr = b ? b.substituteConstants() : undefined;
    if (!aExpr && !bExpr) {
        return true;
    }
    if (!aExpr || !bExpr) {
        return false;
    }
    return aExpr.equals(bExpr);
}
function cmp(a, b) {
    return a.cmp(b);
}
class ContextKeyFalseExpr {
    static { this.INSTANCE = new ContextKeyFalseExpr(); }
    constructor() {
        this.type = 0 /* ContextKeyExprType.False */;
    }
    cmp(other) {
        return this.type - other.type;
    }
    equals(other) {
        return (other.type === this.type);
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        return false;
    }
    serialize() {
        return 'false';
    }
    keys() {
        return [];
    }
    negate() {
        return ContextKeyTrueExpr.INSTANCE;
    }
}
class ContextKeyTrueExpr {
    static { this.INSTANCE = new ContextKeyTrueExpr(); }
    constructor() {
        this.type = 1 /* ContextKeyExprType.True */;
    }
    cmp(other) {
        return this.type - other.type;
    }
    equals(other) {
        return (other.type === this.type);
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        return true;
    }
    serialize() {
        return 'true';
    }
    keys() {
        return [];
    }
    negate() {
        return ContextKeyFalseExpr.INSTANCE;
    }
}
class ContextKeyDefinedExpr {
    static create(key, negated = null) {
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === 'boolean') {
            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return new ContextKeyDefinedExpr(key, negated);
    }
    constructor(key, negated) {
        this.key = key;
        this.negated = negated;
        this.type = 2 /* ContextKeyExprType.Defined */;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp1(this.key, other.key);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key);
        }
        return false;
    }
    substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === 'boolean') {
            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return this;
    }
    evaluate(context) {
        return (!!context.getValue(this.key));
    }
    serialize() {
        return this.key;
    }
    keys() {
        return [this.key];
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyNotExpr.create(this.key, this);
        }
        return this.negated;
    }
}
class ContextKeyEqualsExpr {
    static create(key, value, negated = null) {
        if (typeof value === 'boolean') {
            return (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));
        }
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === 'boolean') {
            const trueValue = constantValue ? 'true' : 'false';
            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);
        }
        return new ContextKeyEqualsExpr(key, value, negated);
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 4 /* ContextKeyExprType.Equals */;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === 'boolean') {
            const trueValue = constantValue ? 'true' : 'false';
            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);
        }
        return this;
    }
    evaluate(context) {
        // Intentional ==
        // eslint-disable-next-line eqeqeq
        return (context.getValue(this.key) == this.value);
    }
    serialize() {
        return `${this.key} == '${this.value}'`;
    }
    keys() {
        return [this.key];
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeyInExpr {
    static create(key, valueKey) {
        return new ContextKeyInExpr(key, valueKey);
    }
    constructor(key, valueKey) {
        this.key = key;
        this.valueKey = valueKey;
        this.type = 10 /* ContextKeyExprType.In */;
        this.negated = null;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.valueKey, other.key, other.valueKey);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.valueKey === other.valueKey);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        const source = context.getValue(this.valueKey);
        const item = context.getValue(this.key);
        if (Array.isArray(source)) {
            return source.includes(item);
        }
        if (typeof item === 'string' && typeof source === 'object' && source !== null) {
            return hasOwnProperty.call(source, item);
        }
        return false;
    }
    serialize() {
        return `${this.key} in '${this.valueKey}'`;
    }
    keys() {
        return [this.key, this.valueKey];
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);
        }
        return this.negated;
    }
}
class ContextKeyNotInExpr {
    static create(key, valueKey) {
        return new ContextKeyNotInExpr(key, valueKey);
    }
    constructor(key, valueKey) {
        this.key = key;
        this.valueKey = valueKey;
        this.type = 11 /* ContextKeyExprType.NotIn */;
        this._negated = ContextKeyInExpr.create(key, valueKey);
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return this._negated.cmp(other._negated);
    }
    equals(other) {
        if (other.type === this.type) {
            return this._negated.equals(other._negated);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        return !this._negated.evaluate(context);
    }
    serialize() {
        return `${this.key} not in '${this.valueKey}'`;
    }
    keys() {
        return this._negated.keys();
    }
    negate() {
        return this._negated;
    }
}
class ContextKeyNotEqualsExpr {
    static create(key, value, negated = null) {
        if (typeof value === 'boolean') {
            if (value) {
                return ContextKeyNotExpr.create(key, negated);
            }
            return ContextKeyDefinedExpr.create(key, negated);
        }
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === 'boolean') {
            const falseValue = constantValue ? 'true' : 'false';
            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);
        }
        return new ContextKeyNotEqualsExpr(key, value, negated);
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 5 /* ContextKeyExprType.NotEquals */;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === 'boolean') {
            const falseValue = constantValue ? 'true' : 'false';
            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);
        }
        return this;
    }
    evaluate(context) {
        // Intentional !=
        // eslint-disable-next-line eqeqeq
        return (context.getValue(this.key) != this.value);
    }
    serialize() {
        return `${this.key} != '${this.value}'`;
    }
    keys() {
        return [this.key];
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeyNotExpr {
    static create(key, negated = null) {
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === 'boolean') {
            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);
        }
        return new ContextKeyNotExpr(key, negated);
    }
    constructor(key, negated) {
        this.key = key;
        this.negated = negated;
        this.type = 3 /* ContextKeyExprType.Not */;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp1(this.key, other.key);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key);
        }
        return false;
    }
    substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === 'boolean') {
            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);
        }
        return this;
    }
    evaluate(context) {
        return (!context.getValue(this.key));
    }
    serialize() {
        return `!${this.key}`;
    }
    keys() {
        return [this.key];
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyDefinedExpr.create(this.key, this);
        }
        return this.negated;
    }
}
function withFloatOrStr(value, callback) {
    if (typeof value === 'string') {
        const n = parseFloat(value);
        if (!isNaN(n)) {
            value = n;
        }
    }
    if (typeof value === 'string' || typeof value === 'number') {
        return callback(value);
    }
    return ContextKeyFalseExpr.INSTANCE;
}
class ContextKeyGreaterExpr {
    static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 12 /* ContextKeyExprType.Greater */;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        if (typeof this.value === 'string') {
            return false;
        }
        return (parseFloat(context.getValue(this.key)) > this.value);
    }
    serialize() {
        return `${this.key} > ${this.value}`;
    }
    keys() {
        return [this.key];
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeyGreaterEqualsExpr {
    static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 13 /* ContextKeyExprType.GreaterEquals */;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        if (typeof this.value === 'string') {
            return false;
        }
        return (parseFloat(context.getValue(this.key)) >= this.value);
    }
    serialize() {
        return `${this.key} >= ${this.value}`;
    }
    keys() {
        return [this.key];
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeySmallerExpr {
    static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 14 /* ContextKeyExprType.Smaller */;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        if (typeof this.value === 'string') {
            return false;
        }
        return (parseFloat(context.getValue(this.key)) < this.value);
    }
    serialize() {
        return `${this.key} < ${this.value}`;
    }
    keys() {
        return [this.key];
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeySmallerEqualsExpr {
    static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 15 /* ContextKeyExprType.SmallerEquals */;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        if (typeof this.value === 'string') {
            return false;
        }
        return (parseFloat(context.getValue(this.key)) <= this.value);
    }
    serialize() {
        return `${this.key} <= ${this.value}`;
    }
    keys() {
        return [this.key];
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeyRegexExpr {
    static create(key, regexp) {
        return new ContextKeyRegexExpr(key, regexp);
    }
    constructor(key, regexp) {
        this.key = key;
        this.regexp = regexp;
        this.type = 7 /* ContextKeyExprType.Regex */;
        this.negated = null;
        //
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        if (this.key < other.key) {
            return -1;
        }
        if (this.key > other.key) {
            return 1;
        }
        const thisSource = this.regexp ? this.regexp.source : '';
        const otherSource = other.regexp ? other.regexp.source : '';
        if (thisSource < otherSource) {
            return -1;
        }
        if (thisSource > otherSource) {
            return 1;
        }
        return 0;
    }
    equals(other) {
        if (other.type === this.type) {
            const thisSource = this.regexp ? this.regexp.source : '';
            const otherSource = other.regexp ? other.regexp.source : '';
            return (this.key === other.key && thisSource === otherSource);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        const value = context.getValue(this.key);
        return this.regexp ? this.regexp.test(value) : false;
    }
    serialize() {
        const value = this.regexp
            ? `/${this.regexp.source}/${this.regexp.flags}`
            : '/invalid/';
        return `${this.key} =~ ${value}`;
    }
    keys() {
        return [this.key];
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyNotRegexExpr.create(this);
        }
        return this.negated;
    }
}
class ContextKeyNotRegexExpr {
    static create(actual) {
        return new ContextKeyNotRegexExpr(actual);
    }
    constructor(_actual) {
        this._actual = _actual;
        this.type = 8 /* ContextKeyExprType.NotRegex */;
        //
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return this._actual.cmp(other._actual);
    }
    equals(other) {
        if (other.type === this.type) {
            return this._actual.equals(other._actual);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        return !this._actual.evaluate(context);
    }
    serialize() {
        return `!(${this._actual.serialize()})`;
    }
    keys() {
        return this._actual.keys();
    }
    negate() {
        return this._actual;
    }
}
/**
 * @returns the same instance if nothing changed.
 */
function eliminateConstantsInArray(arr) {
    // Allocate array only if there is a difference
    let newArr = null;
    for (let i = 0, len = arr.length; i < len; i++) {
        const newExpr = arr[i].substituteConstants();
        if (arr[i] !== newExpr) {
            // something has changed!
            // allocate array on first difference
            if (newArr === null) {
                newArr = [];
                for (let j = 0; j < i; j++) {
                    newArr[j] = arr[j];
                }
            }
        }
        if (newArr !== null) {
            newArr[i] = newExpr;
        }
    }
    if (newArr === null) {
        return arr;
    }
    return newArr;
}
class ContextKeyAndExpr {
    static create(_expr, negated, extraRedundantCheck) {
        return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);
    }
    constructor(expr, negated) {
        this.expr = expr;
        this.negated = negated;
        this.type = 6 /* ContextKeyExprType.And */;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        if (this.expr.length < other.expr.length) {
            return -1;
        }
        if (this.expr.length > other.expr.length) {
            return 1;
        }
        for (let i = 0, len = this.expr.length; i < len; i++) {
            const r = cmp(this.expr[i], other.expr[i]);
            if (r !== 0) {
                return r;
            }
        }
        return 0;
    }
    equals(other) {
        if (other.type === this.type) {
            if (this.expr.length !== other.expr.length) {
                return false;
            }
            for (let i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].equals(other.expr[i])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    substituteConstants() {
        const exprArr = eliminateConstantsInArray(this.expr);
        if (exprArr === this.expr) {
            // no change
            return this;
        }
        return ContextKeyAndExpr.create(exprArr, this.negated, false);
    }
    evaluate(context) {
        for (let i = 0, len = this.expr.length; i < len; i++) {
            if (!this.expr[i].evaluate(context)) {
                return false;
            }
        }
        return true;
    }
    static _normalizeArr(arr, negated, extraRedundantCheck) {
        const expr = [];
        let hasTrue = false;
        for (const e of arr) {
            if (!e) {
                continue;
            }
            if (e.type === 1 /* ContextKeyExprType.True */) {
                // anything && true ==> anything
                hasTrue = true;
                continue;
            }
            if (e.type === 0 /* ContextKeyExprType.False */) {
                // anything && false ==> false
                return ContextKeyFalseExpr.INSTANCE;
            }
            if (e.type === 6 /* ContextKeyExprType.And */) {
                expr.push(...e.expr);
                continue;
            }
            expr.push(e);
        }
        if (expr.length === 0 && hasTrue) {
            return ContextKeyTrueExpr.INSTANCE;
        }
        if (expr.length === 0) {
            return undefined;
        }
        if (expr.length === 1) {
            return expr[0];
        }
        expr.sort(cmp);
        // eliminate duplicate terms
        for (let i = 1; i < expr.length; i++) {
            if (expr[i - 1].equals(expr[i])) {
                expr.splice(i, 1);
                i--;
            }
        }
        if (expr.length === 1) {
            return expr[0];
        }
        // We must distribute any OR expression because we don't support parens
        // OR extensions will be at the end (due to sorting rules)
        while (expr.length > 1) {
            const lastElement = expr[expr.length - 1];
            if (lastElement.type !== 9 /* ContextKeyExprType.Or */) {
                break;
            }
            // pop the last element
            expr.pop();
            // pop the second to last element
            const secondToLastElement = expr.pop();
            const isFinished = (expr.length === 0);
            // distribute `lastElement` over `secondToLastElement`
            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);
            if (resultElement) {
                expr.push(resultElement);
                expr.sort(cmp);
            }
        }
        if (expr.length === 1) {
            return expr[0];
        }
        // resolve false AND expressions
        if (extraRedundantCheck) {
            for (let i = 0; i < expr.length; i++) {
                for (let j = i + 1; j < expr.length; j++) {
                    if (expr[i].negate().equals(expr[j])) {
                        // A && !A case
                        return ContextKeyFalseExpr.INSTANCE;
                    }
                }
            }
            if (expr.length === 1) {
                return expr[0];
            }
        }
        return new ContextKeyAndExpr(expr, negated);
    }
    serialize() {
        return this.expr.map(e => e.serialize()).join(' && ');
    }
    keys() {
        const result = [];
        for (const expr of this.expr) {
            result.push(...expr.keys());
        }
        return result;
    }
    negate() {
        if (!this.negated) {
            const result = [];
            for (const expr of this.expr) {
                result.push(expr.negate());
            }
            this.negated = ContextKeyOrExpr.create(result, this, true);
        }
        return this.negated;
    }
}
class ContextKeyOrExpr {
    static create(_expr, negated, extraRedundantCheck) {
        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);
    }
    constructor(expr, negated) {
        this.expr = expr;
        this.negated = negated;
        this.type = 9 /* ContextKeyExprType.Or */;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        if (this.expr.length < other.expr.length) {
            return -1;
        }
        if (this.expr.length > other.expr.length) {
            return 1;
        }
        for (let i = 0, len = this.expr.length; i < len; i++) {
            const r = cmp(this.expr[i], other.expr[i]);
            if (r !== 0) {
                return r;
            }
        }
        return 0;
    }
    equals(other) {
        if (other.type === this.type) {
            if (this.expr.length !== other.expr.length) {
                return false;
            }
            for (let i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].equals(other.expr[i])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    substituteConstants() {
        const exprArr = eliminateConstantsInArray(this.expr);
        if (exprArr === this.expr) {
            // no change
            return this;
        }
        return ContextKeyOrExpr.create(exprArr, this.negated, false);
    }
    evaluate(context) {
        for (let i = 0, len = this.expr.length; i < len; i++) {
            if (this.expr[i].evaluate(context)) {
                return true;
            }
        }
        return false;
    }
    static _normalizeArr(arr, negated, extraRedundantCheck) {
        let expr = [];
        let hasFalse = false;
        if (arr) {
            for (let i = 0, len = arr.length; i < len; i++) {
                const e = arr[i];
                if (!e) {
                    continue;
                }
                if (e.type === 0 /* ContextKeyExprType.False */) {
                    // anything || false ==> anything
                    hasFalse = true;
                    continue;
                }
                if (e.type === 1 /* ContextKeyExprType.True */) {
                    // anything || true ==> true
                    return ContextKeyTrueExpr.INSTANCE;
                }
                if (e.type === 9 /* ContextKeyExprType.Or */) {
                    expr = expr.concat(e.expr);
                    continue;
                }
                expr.push(e);
            }
            if (expr.length === 0 && hasFalse) {
                return ContextKeyFalseExpr.INSTANCE;
            }
            expr.sort(cmp);
        }
        if (expr.length === 0) {
            return undefined;
        }
        if (expr.length === 1) {
            return expr[0];
        }
        // eliminate duplicate terms
        for (let i = 1; i < expr.length; i++) {
            if (expr[i - 1].equals(expr[i])) {
                expr.splice(i, 1);
                i--;
            }
        }
        if (expr.length === 1) {
            return expr[0];
        }
        // resolve true OR expressions
        if (extraRedundantCheck) {
            for (let i = 0; i < expr.length; i++) {
                for (let j = i + 1; j < expr.length; j++) {
                    if (expr[i].negate().equals(expr[j])) {
                        // A || !A case
                        return ContextKeyTrueExpr.INSTANCE;
                    }
                }
            }
            if (expr.length === 1) {
                return expr[0];
            }
        }
        return new ContextKeyOrExpr(expr, negated);
    }
    serialize() {
        return this.expr.map(e => e.serialize()).join(' || ');
    }
    keys() {
        const result = [];
        for (const expr of this.expr) {
            result.push(...expr.keys());
        }
        return result;
    }
    negate() {
        if (!this.negated) {
            const result = [];
            for (const expr of this.expr) {
                result.push(expr.negate());
            }
            // We don't support parens, so here we distribute the AND over the OR terminals
            // We always take the first 2 AND pairs and distribute them
            while (result.length > 1) {
                const LEFT = result.shift();
                const RIGHT = result.shift();
                const all = [];
                for (const left of getTerminals(LEFT)) {
                    for (const right of getTerminals(RIGHT)) {
                        all.push(ContextKeyAndExpr.create([left, right], null, false));
                    }
                }
                result.unshift(ContextKeyOrExpr.create(all, null, false));
            }
            this.negated = ContextKeyOrExpr.create(result, this, true);
        }
        return this.negated;
    }
}
class RawContextKey extends ContextKeyDefinedExpr {
    static { this._info = []; }
    static all() {
        return RawContextKey._info.values();
    }
    constructor(key, defaultValue, metaOrHide) {
        super(key, null);
        this._defaultValue = defaultValue;
        // collect all context keys into a central place
        if (typeof metaOrHide === 'object') {
            RawContextKey._info.push({ ...metaOrHide, key });
        }
        else if (metaOrHide !== true) {
            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });
        }
    }
    bindTo(target) {
        return target.createKey(this.key, this._defaultValue);
    }
    getValue(target) {
        return target.getContextKeyValue(this.key);
    }
    toNegated() {
        return this.negate();
    }
    isEqualTo(value) {
        return ContextKeyEqualsExpr.create(this.key, value);
    }
}
const IContextKeyService = (0,_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_3__.createDecorator)('contextKeyService');
function cmp1(key1, key2) {
    if (key1 < key2) {
        return -1;
    }
    if (key1 > key2) {
        return 1;
    }
    return 0;
}
function cmp2(key1, value1, key2, value2) {
    if (key1 < key2) {
        return -1;
    }
    if (key1 > key2) {
        return 1;
    }
    if (value1 < value2) {
        return -1;
    }
    if (value1 > value2) {
        return 1;
    }
    return 0;
}
/**
 * Returns true if it is provable `p` implies `q`.
 */
function implies(p, q) {
    if (p.type === 0 /* ContextKeyExprType.False */ || q.type === 1 /* ContextKeyExprType.True */) {
        // false implies anything
        // anything implies true
        return true;
    }
    if (p.type === 9 /* ContextKeyExprType.Or */) {
        if (q.type === 9 /* ContextKeyExprType.Or */) {
            // `a || b || c` can only imply something like `a || b || c || d`
            return allElementsIncluded(p.expr, q.expr);
        }
        return false;
    }
    if (q.type === 9 /* ContextKeyExprType.Or */) {
        for (const element of q.expr) {
            if (implies(p, element)) {
                return true;
            }
        }
        return false;
    }
    if (p.type === 6 /* ContextKeyExprType.And */) {
        if (q.type === 6 /* ContextKeyExprType.And */) {
            // `a && b && c` implies `a && c`
            return allElementsIncluded(q.expr, p.expr);
        }
        for (const element of p.expr) {
            if (implies(element, q)) {
                return true;
            }
        }
        return false;
    }
    return p.equals(q);
}
/**
 * Returns true if all elements in `p` are also present in `q`.
 * The two arrays are assumed to be sorted
 */
function allElementsIncluded(p, q) {
    let pIndex = 0;
    let qIndex = 0;
    while (pIndex < p.length && qIndex < q.length) {
        const cmp = p[pIndex].cmp(q[qIndex]);
        if (cmp < 0) {
            // an element from `p` is missing from `q`
            return false;
        }
        else if (cmp === 0) {
            pIndex++;
            qIndex++;
        }
        else {
            qIndex++;
        }
    }
    return (pIndex === p.length);
}
function getTerminals(node) {
    if (node.type === 9 /* ContextKeyExprType.Or */) {
        return node.expr;
    }
    return [node];
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/platform/contextkey/common/scanner.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/platform/contextkey/common/scanner.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Scanner: () => (/* binding */ Scanner)
/* harmony export */ });
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _nls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../nls.js */ "./node_modules/monaco-editor/esm/vs/nls.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function hintDidYouMean(...meant) {
    switch (meant.length) {
        case 1:
            return (0,_nls_js__WEBPACK_IMPORTED_MODULE_1__.localize)('contextkey.scanner.hint.didYouMean1', "Did you mean {0}?", meant[0]);
        case 2:
            return (0,_nls_js__WEBPACK_IMPORTED_MODULE_1__.localize)('contextkey.scanner.hint.didYouMean2', "Did you mean {0} or {1}?", meant[0], meant[1]);
        case 3:
            return (0,_nls_js__WEBPACK_IMPORTED_MODULE_1__.localize)('contextkey.scanner.hint.didYouMean3', "Did you mean {0}, {1} or {2}?", meant[0], meant[1], meant[2]);
        default: // we just don't expect that many
            return undefined;
    }
}
const hintDidYouForgetToOpenOrCloseQuote = (0,_nls_js__WEBPACK_IMPORTED_MODULE_1__.localize)('contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote', "Did you forget to open or close the quote?");
const hintDidYouForgetToEscapeSlash = (0,_nls_js__WEBPACK_IMPORTED_MODULE_1__.localize)('contextkey.scanner.hint.didYouForgetToEscapeSlash', "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/\'.");
/**
 * A simple scanner for context keys.
 *
 * Example:
 *
 * ```ts
 * const scanner = new Scanner().reset('resourceFileName =~ /docker/ && !config.docker.enabled');
 * const tokens = [...scanner];
 * if (scanner.errorTokens.length > 0) {
 *     scanner.errorTokens.forEach(err => console.error(`Unexpected token at ${err.offset}: ${err.lexeme}\nHint: ${err.additional}`));
 * } else {
 *     // process tokens
 * }
 * ```
 */
class Scanner {
    constructor() {
        this._input = '';
        this._start = 0;
        this._current = 0;
        this._tokens = [];
        this._errors = [];
        // u - unicode, y - sticky // TODO@ulugbekna: we accept double quotes as part of the string rather than as a delimiter (to preserve old parser's behavior)
        this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
    }
    static getLexeme(token) {
        switch (token.type) {
            case 0 /* TokenType.LParen */:
                return '(';
            case 1 /* TokenType.RParen */:
                return ')';
            case 2 /* TokenType.Neg */:
                return '!';
            case 3 /* TokenType.Eq */:
                return token.isTripleEq ? '===' : '==';
            case 4 /* TokenType.NotEq */:
                return token.isTripleEq ? '!==' : '!=';
            case 5 /* TokenType.Lt */:
                return '<';
            case 6 /* TokenType.LtEq */:
                return '<=';
            case 7 /* TokenType.Gt */:
                return '>=';
            case 8 /* TokenType.GtEq */:
                return '>=';
            case 9 /* TokenType.RegexOp */:
                return '=~';
            case 10 /* TokenType.RegexStr */:
                return token.lexeme;
            case 11 /* TokenType.True */:
                return 'true';
            case 12 /* TokenType.False */:
                return 'false';
            case 13 /* TokenType.In */:
                return 'in';
            case 14 /* TokenType.Not */:
                return 'not';
            case 15 /* TokenType.And */:
                return '&&';
            case 16 /* TokenType.Or */:
                return '||';
            case 17 /* TokenType.Str */:
                return token.lexeme;
            case 18 /* TokenType.QuotedStr */:
                return token.lexeme;
            case 19 /* TokenType.Error */:
                return token.lexeme;
            case 20 /* TokenType.EOF */:
                return 'EOF';
            default:
                throw (0,_base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.illegalState)(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);
        }
    }
    static { this._regexFlags = new Set(['i', 'g', 's', 'm', 'y', 'u'].map(ch => ch.charCodeAt(0))); }
    static { this._keywords = new Map([
        ['not', 14 /* TokenType.Not */],
        ['in', 13 /* TokenType.In */],
        ['false', 12 /* TokenType.False */],
        ['true', 11 /* TokenType.True */],
    ]); }
    reset(value) {
        this._input = value;
        this._start = 0;
        this._current = 0;
        this._tokens = [];
        this._errors = [];
        return this;
    }
    scan() {
        while (!this._isAtEnd()) {
            this._start = this._current;
            const ch = this._advance();
            switch (ch) {
                case 40 /* CharCode.OpenParen */:
                    this._addToken(0 /* TokenType.LParen */);
                    break;
                case 41 /* CharCode.CloseParen */:
                    this._addToken(1 /* TokenType.RParen */);
                    break;
                case 33 /* CharCode.ExclamationMark */:
                    if (this._match(61 /* CharCode.Equals */)) {
                        const isTripleEq = this._match(61 /* CharCode.Equals */); // eat last `=` if `!==`
                        this._tokens.push({ type: 4 /* TokenType.NotEq */, offset: this._start, isTripleEq });
                    }
                    else {
                        this._addToken(2 /* TokenType.Neg */);
                    }
                    break;
                case 39 /* CharCode.SingleQuote */:
                    this._quotedString();
                    break;
                case 47 /* CharCode.Slash */:
                    this._regex();
                    break;
                case 61 /* CharCode.Equals */:
                    if (this._match(61 /* CharCode.Equals */)) { // support `==`
                        const isTripleEq = this._match(61 /* CharCode.Equals */); // eat last `=` if `===`
                        this._tokens.push({ type: 3 /* TokenType.Eq */, offset: this._start, isTripleEq });
                    }
                    else if (this._match(126 /* CharCode.Tilde */)) {
                        this._addToken(9 /* TokenType.RegexOp */);
                    }
                    else {
                        this._error(hintDidYouMean('==', '=~'));
                    }
                    break;
                case 60 /* CharCode.LessThan */:
                    this._addToken(this._match(61 /* CharCode.Equals */) ? 6 /* TokenType.LtEq */ : 5 /* TokenType.Lt */);
                    break;
                case 62 /* CharCode.GreaterThan */:
                    this._addToken(this._match(61 /* CharCode.Equals */) ? 8 /* TokenType.GtEq */ : 7 /* TokenType.Gt */);
                    break;
                case 38 /* CharCode.Ampersand */:
                    if (this._match(38 /* CharCode.Ampersand */)) {
                        this._addToken(15 /* TokenType.And */);
                    }
                    else {
                        this._error(hintDidYouMean('&&'));
                    }
                    break;
                case 124 /* CharCode.Pipe */:
                    if (this._match(124 /* CharCode.Pipe */)) {
                        this._addToken(16 /* TokenType.Or */);
                    }
                    else {
                        this._error(hintDidYouMean('||'));
                    }
                    break;
                // TODO@ulugbekna: 1) rewrite using a regex 2) reconsider what characters are considered whitespace, including unicode, nbsp, etc.
                case 32 /* CharCode.Space */:
                case 13 /* CharCode.CarriageReturn */:
                case 9 /* CharCode.Tab */:
                case 10 /* CharCode.LineFeed */:
                case 160 /* CharCode.NoBreakSpace */: // &nbsp
                    break;
                default:
                    this._string();
            }
        }
        this._start = this._current;
        this._addToken(20 /* TokenType.EOF */);
        return Array.from(this._tokens);
    }
    _match(expected) {
        if (this._isAtEnd()) {
            return false;
        }
        if (this._input.charCodeAt(this._current) !== expected) {
            return false;
        }
        this._current++;
        return true;
    }
    _advance() {
        return this._input.charCodeAt(this._current++);
    }
    _peek() {
        return this._isAtEnd() ? 0 /* CharCode.Null */ : this._input.charCodeAt(this._current);
    }
    _addToken(type) {
        this._tokens.push({ type, offset: this._start });
    }
    _error(additional) {
        const offset = this._start;
        const lexeme = this._input.substring(this._start, this._current);
        const errToken = { type: 19 /* TokenType.Error */, offset: this._start, lexeme };
        this._errors.push({ offset, lexeme, additionalInfo: additional });
        this._tokens.push(errToken);
    }
    _string() {
        this.stringRe.lastIndex = this._start;
        const match = this.stringRe.exec(this._input);
        if (match) {
            this._current = this._start + match[0].length;
            const lexeme = this._input.substring(this._start, this._current);
            const keyword = Scanner._keywords.get(lexeme);
            if (keyword) {
                this._addToken(keyword);
            }
            else {
                this._tokens.push({ type: 17 /* TokenType.Str */, lexeme, offset: this._start });
            }
        }
    }
    // captures the lexeme without the leading and trailing '
    _quotedString() {
        while (this._peek() !== 39 /* CharCode.SingleQuote */ && !this._isAtEnd()) { // TODO@ulugbekna: add support for escaping ' ?
            this._advance();
        }
        if (this._isAtEnd()) {
            this._error(hintDidYouForgetToOpenOrCloseQuote);
            return;
        }
        // consume the closing '
        this._advance();
        this._tokens.push({ type: 18 /* TokenType.QuotedStr */, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });
    }
    /*
     * Lexing a regex expression: /.../[igsmyu]*
     * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181
     *
     * Note that we want slashes within a regex to be escaped, e.g., /file:\\/\\/\\// should match `file:///`
     */
    _regex() {
        let p = this._current;
        let inEscape = false;
        let inCharacterClass = false;
        while (true) {
            if (p >= this._input.length) {
                this._current = p;
                this._error(hintDidYouForgetToEscapeSlash);
                return;
            }
            const ch = this._input.charCodeAt(p);
            if (inEscape) { // parsing an escape character
                inEscape = false;
            }
            else if (ch === 47 /* CharCode.Slash */ && !inCharacterClass) { // end of regex
                p++;
                break;
            }
            else if (ch === 91 /* CharCode.OpenSquareBracket */) {
                inCharacterClass = true;
            }
            else if (ch === 92 /* CharCode.Backslash */) {
                inEscape = true;
            }
            else if (ch === 93 /* CharCode.CloseSquareBracket */) {
                inCharacterClass = false;
            }
            p++;
        }
        // Consume flags // TODO@ulugbekna: use regex instead
        while (p < this._input.length && Scanner._regexFlags.has(this._input.charCodeAt(p))) {
            p++;
        }
        this._current = p;
        const lexeme = this._input.substring(this._start, this._current);
        this._tokens.push({ type: 10 /* TokenType.RegexStr */, lexeme, offset: this._start });
    }
    _isAtEnd() {
        return this._current >= this._input.length;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/platform/log/common/log.js":
/*!**********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/platform/log/common/log.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractLogger: () => (/* binding */ AbstractLogger),
/* harmony export */   CONTEXT_LOG_LEVEL: () => (/* binding */ CONTEXT_LOG_LEVEL),
/* harmony export */   ConsoleLogger: () => (/* binding */ ConsoleLogger),
/* harmony export */   DEFAULT_LOG_LEVEL: () => (/* binding */ DEFAULT_LOG_LEVEL),
/* harmony export */   ILogService: () => (/* binding */ ILogService),
/* harmony export */   LogLevel: () => (/* binding */ LogLevel),
/* harmony export */   LogLevelToString: () => (/* binding */ LogLevelToString),
/* harmony export */   MultiplexLogger: () => (/* binding */ MultiplexLogger)
/* harmony export */ });
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _contextkey_common_contextkey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../contextkey/common/contextkey.js */ "./node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js");
/* harmony import */ var _instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../instantiation/common/instantiation.js */ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js");




const ILogService = (0,_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_3__.createDecorator)('logService');
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Off"] = 0] = "Off";
    LogLevel[LogLevel["Trace"] = 1] = "Trace";
    LogLevel[LogLevel["Debug"] = 2] = "Debug";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Warning"] = 4] = "Warning";
    LogLevel[LogLevel["Error"] = 5] = "Error";
})(LogLevel || (LogLevel = {}));
const DEFAULT_LOG_LEVEL = LogLevel.Info;
class AbstractLogger extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    constructor() {
        super(...arguments);
        this.level = DEFAULT_LOG_LEVEL;
        this._onDidChangeLogLevel = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter());
        this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
    }
    setLevel(level) {
        if (this.level !== level) {
            this.level = level;
            this._onDidChangeLogLevel.fire(this.level);
        }
    }
    getLevel() {
        return this.level;
    }
    checkLogLevel(level) {
        return this.level !== LogLevel.Off && this.level <= level;
    }
}
class ConsoleLogger extends AbstractLogger {
    constructor(logLevel = DEFAULT_LOG_LEVEL, useColors = true) {
        super();
        this.useColors = useColors;
        this.setLevel(logLevel);
    }
    trace(message, ...args) {
        if (this.checkLogLevel(LogLevel.Trace)) {
            if (this.useColors) {
                console.log('%cTRACE', 'color: #888', message, ...args);
            }
            else {
                console.log(message, ...args);
            }
        }
    }
    debug(message, ...args) {
        if (this.checkLogLevel(LogLevel.Debug)) {
            if (this.useColors) {
                console.log('%cDEBUG', 'background: #eee; color: #888', message, ...args);
            }
            else {
                console.log(message, ...args);
            }
        }
    }
    info(message, ...args) {
        if (this.checkLogLevel(LogLevel.Info)) {
            if (this.useColors) {
                console.log('%c INFO', 'color: #33f', message, ...args);
            }
            else {
                console.log(message, ...args);
            }
        }
    }
    warn(message, ...args) {
        if (this.checkLogLevel(LogLevel.Warning)) {
            if (this.useColors) {
                console.log('%c WARN', 'color: #993', message, ...args);
            }
            else {
                console.log(message, ...args);
            }
        }
    }
    error(message, ...args) {
        if (this.checkLogLevel(LogLevel.Error)) {
            if (this.useColors) {
                console.log('%c  ERR', 'color: #f33', message, ...args);
            }
            else {
                console.error(message, ...args);
            }
        }
    }
}
class MultiplexLogger extends AbstractLogger {
    constructor(loggers) {
        super();
        this.loggers = loggers;
        if (loggers.length) {
            this.setLevel(loggers[0].getLevel());
        }
    }
    setLevel(level) {
        for (const logger of this.loggers) {
            logger.setLevel(level);
        }
        super.setLevel(level);
    }
    trace(message, ...args) {
        for (const logger of this.loggers) {
            logger.trace(message, ...args);
        }
    }
    debug(message, ...args) {
        for (const logger of this.loggers) {
            logger.debug(message, ...args);
        }
    }
    info(message, ...args) {
        for (const logger of this.loggers) {
            logger.info(message, ...args);
        }
    }
    warn(message, ...args) {
        for (const logger of this.loggers) {
            logger.warn(message, ...args);
        }
    }
    error(message, ...args) {
        for (const logger of this.loggers) {
            logger.error(message, ...args);
        }
    }
    dispose() {
        for (const logger of this.loggers) {
            logger.dispose();
        }
        super.dispose();
    }
}
function LogLevelToString(logLevel) {
    switch (logLevel) {
        case LogLevel.Trace: return 'trace';
        case LogLevel.Debug: return 'debug';
        case LogLevel.Info: return 'info';
        case LogLevel.Warning: return 'warn';
        case LogLevel.Error: return 'error';
        case LogLevel.Off: return 'off';
    }
}
// Contexts
const CONTEXT_LOG_LEVEL = new _contextkey_common_contextkey_js__WEBPACK_IMPORTED_MODULE_2__.RawContextKey('logLevel', LogLevelToString(LogLevel.Info));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfcGxhdGZvcm1fbG9nX2NvbW1vbl9sb2dfanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lJO0FBQzNEO0FBQy9CO0FBQ3VDO0FBQ25DO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRUFBVztBQUN4QywrQkFBK0IsNkRBQU87QUFDdEMsaUNBQWlDLCtEQUFTO0FBQzFDLDZCQUE2QiwyREFBSztBQUNsQyxtQ0FBbUMsaUVBQVcsS0FBSywyREFBSztBQUN4RCw4QkFBOEIsNERBQU07QUFDcEMsaUNBQWlDLCtEQUFTO0FBQzFDLGdDQUFnQyw4REFBUTtBQUN4QyxnQ0FBZ0MsOERBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQVE7QUFDakMsd0JBQXdCLGlEQUFRO0FBQ2hDLDBCQUEwQixpREFBUTtBQUNsQyxnQ0FBZ0MsaURBQVE7QUFDeEMsNkJBQTZCLGlEQUFRO0FBQ3JDLDRCQUE0QixpREFBUTtBQUNwQywyQkFBMkIsaURBQVE7QUFDbkMsMEJBQTBCLGlEQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQU87QUFDbkM7QUFDQTtBQUNBLDJCQUEyQix5REFBeUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtRkFBbUY7QUFDMUg7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRCQUE0QixzQ0FBc0M7QUFDL0U7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVUsTUFBTSxXQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVLE1BQU0sY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVLFVBQVUsY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVLE1BQU0sV0FBVztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxJQUFJLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxLQUFLLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxJQUFJLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxLQUFLLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUIsR0FBRyxrQkFBa0I7QUFDMUQ7QUFDQSxrQkFBa0IsVUFBVSxLQUFLLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0EsdUNBQXVDLDJIQUEySDtBQUNsSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsdUZBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMWdEQTtBQUNBO0FB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L25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9wbGF0Zm9ybS9jb250ZXh0a2V5L2NvbW1vbi9jb250ZXh0a2V5LmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvcGxhdGZvcm0vY29udGV4dGtleS9jb21tb24vc2Nhbm5lci5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL3BsYXRmb3JtL2xvZy9jb21tb24vbG9nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgaXNDaHJvbWUsIGlzRWRnZSwgaXNGaXJlZm94LCBpc0xpbnV4LCBpc01hY2ludG9zaCwgaXNTYWZhcmksIGlzV2ViLCBpc1dpbmRvd3MgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgeyBpc0ZhbHN5T3JXaGl0ZXNwYWNlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7XG5pbXBvcnQgeyBTY2FubmVyIH0gZnJvbSAnLi9zY2FubmVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZURlY29yYXRvciB9IGZyb20gJy4uLy4uL2luc3RhbnRpYXRpb24vY29tbW9uL2luc3RhbnRpYXRpb24uanMnO1xuaW1wb3J0IHsgbG9jYWxpemUgfSBmcm9tICcuLi8uLi8uLi9ubHMuanMnO1xuY29uc3QgQ09OU1RBTlRfVkFMVUVTID0gbmV3IE1hcCgpO1xuQ09OU1RBTlRfVkFMVUVTLnNldCgnZmFsc2UnLCBmYWxzZSk7XG5DT05TVEFOVF9WQUxVRVMuc2V0KCd0cnVlJywgdHJ1ZSk7XG5DT05TVEFOVF9WQUxVRVMuc2V0KCdpc01hYycsIGlzTWFjaW50b3NoKTtcbkNPTlNUQU5UX1ZBTFVFUy5zZXQoJ2lzTGludXgnLCBpc0xpbnV4KTtcbkNPTlNUQU5UX1ZBTFVFUy5zZXQoJ2lzV2luZG93cycsIGlzV2luZG93cyk7XG5DT05TVEFOVF9WQUxVRVMuc2V0KCdpc1dlYicsIGlzV2ViKTtcbkNPTlNUQU5UX1ZBTFVFUy5zZXQoJ2lzTWFjTmF0aXZlJywgaXNNYWNpbnRvc2ggJiYgIWlzV2ViKTtcbkNPTlNUQU5UX1ZBTFVFUy5zZXQoJ2lzRWRnZScsIGlzRWRnZSk7XG5DT05TVEFOVF9WQUxVRVMuc2V0KCdpc0ZpcmVmb3gnLCBpc0ZpcmVmb3gpO1xuQ09OU1RBTlRfVkFMVUVTLnNldCgnaXNDaHJvbWUnLCBpc0Nocm9tZSk7XG5DT05TVEFOVF9WQUxVRVMuc2V0KCdpc1NhZmFyaScsIGlzU2FmYXJpKTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgcmVnZXhQYXJzaW5nV2l0aEVycm9yUmVjb3Zlcnk6IHRydWVcbn07XG5jb25zdCBlcnJvckVtcHR5U3RyaW5nID0gbG9jYWxpemUoJ2NvbnRleHRrZXkucGFyc2VyLmVycm9yLmVtcHR5U3RyaW5nJywgXCJFbXB0eSBjb250ZXh0IGtleSBleHByZXNzaW9uXCIpO1xuY29uc3QgaGludEVtcHR5U3RyaW5nID0gbG9jYWxpemUoJ2NvbnRleHRrZXkucGFyc2VyLmVycm9yLmVtcHR5U3RyaW5nLmhpbnQnLCBcIkRpZCB5b3UgZm9yZ2V0IHRvIHdyaXRlIGFuIGV4cHJlc3Npb24/IFlvdSBjYW4gYWxzbyBwdXQgJ2ZhbHNlJyBvciAndHJ1ZScgdG8gYWx3YXlzIGV2YWx1YXRlIHRvIGZhbHNlIG9yIHRydWUsIHJlc3BlY3RpdmVseS5cIik7XG5jb25zdCBlcnJvck5vSW5BZnRlck5vdCA9IGxvY2FsaXplKCdjb250ZXh0a2V5LnBhcnNlci5lcnJvci5ub0luQWZ0ZXJOb3QnLCBcIidpbicgYWZ0ZXIgJ25vdCcuXCIpO1xuY29uc3QgZXJyb3JDbG9zaW5nUGFyZW50aGVzaXMgPSBsb2NhbGl6ZSgnY29udGV4dGtleS5wYXJzZXIuZXJyb3IuY2xvc2luZ1BhcmVudGhlc2lzJywgXCJjbG9zaW5nIHBhcmVudGhlc2lzICcpJ1wiKTtcbmNvbnN0IGVycm9yVW5leHBlY3RlZFRva2VuID0gbG9jYWxpemUoJ2NvbnRleHRrZXkucGFyc2VyLmVycm9yLnVuZXhwZWN0ZWRUb2tlbicsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbmNvbnN0IGhpbnRVbmV4cGVjdGVkVG9rZW4gPSBsb2NhbGl6ZSgnY29udGV4dGtleS5wYXJzZXIuZXJyb3IudW5leHBlY3RlZFRva2VuLmhpbnQnLCBcIkRpZCB5b3UgZm9yZ2V0IHRvIHB1dCAmJiBvciB8fCBiZWZvcmUgdGhlIHRva2VuP1wiKTtcbmNvbnN0IGVycm9yVW5leHBlY3RlZEVPRiA9IGxvY2FsaXplKCdjb250ZXh0a2V5LnBhcnNlci5lcnJvci51bmV4cGVjdGVkRU9GJywgXCJVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uXCIpO1xuY29uc3QgaGludFVuZXhwZWN0ZWRFT0YgPSBsb2NhbGl6ZSgnY29udGV4dGtleS5wYXJzZXIuZXJyb3IudW5leHBlY3RlZEVPRi5oaW50JywgXCJEaWQgeW91IGZvcmdldCB0byBwdXQgYSBjb250ZXh0IGtleT9cIik7XG4vKipcbiAqIEEgcGFyc2VyIGZvciBjb250ZXh0IGtleSBleHByZXNzaW9ucy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoKTtcbiAqIGNvbnN0IGV4cHIgPSBwYXJzZXIucGFyc2UoJ2ZvbyA9PSBcImJhclwiICYmIGJheiA9PSB0cnVlJyk7XG4gKlxuICogaWYgKGV4cHIgPT09IHVuZGVmaW5lZCkge1xuICogXHQvLyB0aGVyZSB3ZXJlIGxleGluZyBvciBwYXJzaW5nIGVycm9yc1xuICogXHQvLyBwcm9jZXNzIGxleGluZyBlcnJvcnMgd2l0aCBgcGFyc2VyLmxleGluZ0Vycm9yc2BcbiAqICAvLyBwcm9jZXNzIHBhcnNpbmcgZXJyb3JzIHdpdGggYHBhcnNlci5wYXJzaW5nRXJyb3JzYFxuICogfSBlbHNlIHtcbiAqIFx0Ly8gZXhwciBpcyBhIHZhbGlkIGV4cHJlc3Npb25cbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgUGFyc2VyIHtcbiAgICAvLyBOb3RlOiB0aGlzIGRvZXNuJ3QgcHJvZHVjZSBhbiBleGFjdCBzeW50YXggdHJlZSBidXQgYSBub3JtYWxpemVkIG9uZVxuICAgIC8vIENvbnRleHRLZXlFeHByZXNzaW9uJ3MgdGhhdCB3ZSB1c2UgYXMgQVNUIG5vZGVzIGRvIG5vdCBleHBvc2UgY29uc3RydWN0b3JzIHRoYXQgZG8gbm90IG5vcm1hbGl6ZVxuICAgIHN0YXRpYyB7IHRoaXMuX3BhcnNlRXJyb3IgPSBuZXcgRXJyb3IoKTsgfVxuICAgIGNvbnN0cnVjdG9yKF9jb25maWcgPSBkZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIC8vIGxpZmV0aW1lIG5vdGU6IGBfc2Nhbm5lcmAgbGl2ZXMgYXMgbG9uZyBhcyB0aGUgcGFyc2VyIGRvZXMsIGkuZS4sIGlzIG5vdCByZXNldCBiZXR3ZWVuIGNhbGxzIHRvIGBwYXJzZWBcbiAgICAgICAgdGhpcy5fc2Nhbm5lciA9IG5ldyBTY2FubmVyKCk7XG4gICAgICAgIC8vIGxpZmV0aW1lIG5vdGU6IGBfdG9rZW5zYCwgYF9jdXJyZW50YCwgYW5kIGBfcGFyc2luZ0Vycm9yc2AgbXVzdCBiZSByZXNldCBiZXR3ZWVuIGNhbGxzIHRvIGBwYXJzZWBcbiAgICAgICAgdGhpcy5fdG9rZW5zID0gW107XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwOyAvLyBpbnZhcmlhbnQ6IDAgPD0gdGhpcy5fY3VycmVudCA8IHRoaXMuX3Rva2Vucy5sZW5ndGggOyBhbnkgaW5jcmVtZW50YXRpb24gb2YgdGhpcyB2YWx1ZSBtdXN0IGZpcnN0IGNhbGwgYF9pc0F0RW5kYFxuICAgICAgICB0aGlzLl9wYXJzaW5nRXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuX2ZsYWdzR1lSZSA9IC9nfHkvZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBjb250ZXh0IGtleSBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IHRoZSBleHByZXNzaW9uIHRvIHBhcnNlXG4gICAgICogQHJldHVybnMgdGhlIHBhcnNlZCBleHByZXNzaW9uIG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlJ3MgYW4gZXJyb3IgLSBjYWxsIGBsZXhpbmdFcnJvcnNgIGFuZCBgcGFyc2luZ0Vycm9yc2AgdG8gc2VlIHRoZSBlcnJvcnNcbiAgICAgKi9cbiAgICBwYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQgPT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzaW5nRXJyb3JzLnB1c2goeyBtZXNzYWdlOiBlcnJvckVtcHR5U3RyaW5nLCBvZmZzZXQ6IDAsIGxleGVtZTogJycsIGFkZGl0aW9uYWxJbmZvOiBoaW50RW1wdHlTdHJpbmcgfSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rva2VucyA9IHRoaXMuX3NjYW5uZXIucmVzZXQoaW5wdXQpLnNjYW4oKTtcbiAgICAgICAgLy8gQHVsdWdiZWtuYTogd2UgZG8gbm90IHN0b3AgcGFyc2luZyBpZiB0aGVyZSBhcmUgbGV4aW5nIGVycm9ycyB0byBiZSBhYmxlIHRvIHJlY29uc3RydWN0IHJlZ2V4ZXMgd2l0aCB1bmVzY2FwZWQgc2xhc2hlczsgVE9ET0B1bHVnYmVrbmE6IG1ha2UgdGhpcyByZXNwZWN0IGNvbmZpZyBvcHRpb24gZm9yIHJlY292ZXJ5XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgICAgICB0aGlzLl9wYXJzaW5nRXJyb3JzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBleHByID0gdGhpcy5fZXhwcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0F0RW5kKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZWVrID0gdGhpcy5fcGVlaygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxJbmZvID0gcGVlay50eXBlID09PSAxNyAvKiBUb2tlblR5cGUuU3RyICovID8gaGludFVuZXhwZWN0ZWRUb2tlbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzaW5nRXJyb3JzLnB1c2goeyBtZXNzYWdlOiBlcnJvclVuZXhwZWN0ZWRUb2tlbiwgb2Zmc2V0OiBwZWVrLm9mZnNldCwgbGV4ZW1lOiBTY2FubmVyLmdldExleGVtZShwZWVrKSwgYWRkaXRpb25hbEluZm8gfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgUGFyc2VyLl9wYXJzZUVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghKGUgPT09IFBhcnNlci5fcGFyc2VFcnJvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZXhwcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yKCk7XG4gICAgfVxuICAgIF9vcigpIHtcbiAgICAgICAgY29uc3QgZXhwciA9IFt0aGlzLl9hbmQoKV07XG4gICAgICAgIHdoaWxlICh0aGlzLl9tYXRjaE9uZSgxNiAvKiBUb2tlblR5cGUuT3IgKi8pKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMuX2FuZCgpO1xuICAgICAgICAgICAgZXhwci5wdXNoKHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwci5sZW5ndGggPT09IDEgPyBleHByWzBdIDogQ29udGV4dEtleUV4cHIub3IoLi4uZXhwcik7XG4gICAgfVxuICAgIF9hbmQoKSB7XG4gICAgICAgIGNvbnN0IGV4cHIgPSBbdGhpcy5fdGVybSgpXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX21hdGNoT25lKDE1IC8qIFRva2VuVHlwZS5BbmQgKi8pKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMuX3Rlcm0oKTtcbiAgICAgICAgICAgIGV4cHIucHVzaChyaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHIubGVuZ3RoID09PSAxID8gZXhwclswXSA6IENvbnRleHRLZXlFeHByLmFuZCguLi5leHByKTtcbiAgICB9XG4gICAgX3Rlcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXRjaE9uZSgyIC8qIFRva2VuVHlwZS5OZWcgKi8pKSB7XG4gICAgICAgICAgICBjb25zdCBwZWVrID0gdGhpcy5fcGVlaygpO1xuICAgICAgICAgICAgc3dpdGNoIChwZWVrLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDExIC8qIFRva2VuVHlwZS5UcnVlICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5RmFsc2VFeHByLklOU1RBTkNFO1xuICAgICAgICAgICAgICAgIGNhc2UgMTIgLyogVG9rZW5UeXBlLkZhbHNlICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5VHJ1ZUV4cHIuSU5TVEFOQ0U7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFRva2VuVHlwZS5MUGFyZW4gKi86IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByID0gdGhpcy5fZXhwcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lKDEgLyogVG9rZW5UeXBlLlJQYXJlbiAqLywgZXJyb3JDbG9zaW5nUGFyZW50aGVzaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcj8ubmVnYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTcgLyogVG9rZW5UeXBlLlN0ciAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29udGV4dEtleU5vdEV4cHIuY3JlYXRlKHBlZWsubGV4ZW1lKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9lcnJFeHBlY3RlZEJ1dEdvdChgS0VZIHwgdHJ1ZSB8IGZhbHNlIHwgJygnIGV4cHJlc3Npb24gJyknYCwgcGVlayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW1hcnkoKTtcbiAgICB9XG4gICAgX3ByaW1hcnkoKSB7XG4gICAgICAgIGNvbnN0IHBlZWsgPSB0aGlzLl9wZWVrKCk7XG4gICAgICAgIHN3aXRjaCAocGVlay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDExIC8qIFRva2VuVHlwZS5UcnVlICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udGV4dEtleUV4cHIudHJ1ZSgpO1xuICAgICAgICAgICAgY2FzZSAxMiAvKiBUb2tlblR5cGUuRmFsc2UgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5RXhwci5mYWxzZSgpO1xuICAgICAgICAgICAgY2FzZSAwIC8qIFRva2VuVHlwZS5MUGFyZW4gKi86IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwciA9IHRoaXMuX2V4cHIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lKDEgLyogVG9rZW5UeXBlLlJQYXJlbiAqLywgZXJyb3JDbG9zaW5nUGFyZW50aGVzaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxNyAvKiBUb2tlblR5cGUuU3RyICovOiB7XG4gICAgICAgICAgICAgICAgLy8gS0VZXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGVlay5sZXhlbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIC8vID1+IHJlZ2V4XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoT25lKDkgLyogVG9rZW5UeXBlLlJlZ2V4T3AgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB1bHVnYmVrbmE6IHdlIG5lZWQgdG8gcmVjb25zdHJ1Y3QgdGhlIHJlZ2V4IGZyb20gdGhlIHRva2VucyBiZWNhdXNlIHNvbWUgZXh0ZW5zaW9ucyB1c2UgdW5lc2NhcGVkIHNsYXNoZXMgaW4gcmVnZXhlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByID0gdGhpcy5fcGVlaygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5yZWdleFBhcnNpbmdXaXRoRXJyb3JSZWNvdmVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIudHlwZSAhPT0gMTAgLyogVG9rZW5UeXBlLlJlZ2V4U3RyICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyRXhwZWN0ZWRCdXRHb3QoYFJFR0VYYCwgZXhwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWdleExleGVtZSA9IGV4cHIubGV4ZW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xvc2luZ1NsYXNoSW5kZXggPSByZWdleExleGVtZS5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBjbG9zaW5nU2xhc2hJbmRleCA9PT0gcmVnZXhMZXhlbWUubGVuZ3RoIC0gMSA/IHVuZGVmaW5lZCA6IHRoaXMuX3JlbW92ZUZsYWdzR1kocmVnZXhMZXhlbWUuc3Vic3RyaW5nKGNsb3NpbmdTbGFzaEluZGV4ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlZ2V4cDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cChyZWdleExleGVtZS5zdWJzdHJpbmcoMSwgY2xvc2luZ1NsYXNoSW5kZXgpLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2VyckV4cGVjdGVkQnV0R290KGBSRUdFWGAsIGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRleHRLZXlSZWdleEV4cHIuY3JlYXRlKGtleSwgcmVnZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMCAvKiBUb2tlblR5cGUuUmVnZXhTdHIgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE5IC8qIFRva2VuVHlwZS5FcnJvciAqLzogeyAvLyBhbHNvIGhhbmRsZSBhbiBFcnJvclRva2VuIGluIGNhc2Ugb2Ygc210aCBzdWNoIGFzIC8oL2ZpbGUpL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxleGVtZVJlY29uc3RydWN0aW9uID0gW2V4cHIubGV4ZW1lXTsgLy8gL1JFR0VYLyBvciAvUkVHRVgvRkxBR1NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvbGxvd2luZ1Rva2VuID0gdGhpcy5fcGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbkJhbGFuY2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwci5sZXhlbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIubGV4ZW1lLmNoYXJDb2RlQXQoaSkgPT09IDQwIC8qIENoYXJDb2RlLk9wZW5QYXJlbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW5CYWxhbmNlKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXhwci5sZXhlbWUuY2hhckNvZGVBdChpKSA9PT0gNDEgLyogQ2hhckNvZGUuQ2xvc2VQYXJlbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW5CYWxhbmNlLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCF0aGlzLl9pc0F0RW5kKCkgJiYgZm9sbG93aW5nVG9rZW4udHlwZSAhPT0gMTUgLyogVG9rZW5UeXBlLkFuZCAqLyAmJiBmb2xsb3dpbmdUb2tlbi50eXBlICE9PSAxNiAvKiBUb2tlblR5cGUuT3IgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmb2xsb3dpbmdUb2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDAgLyogVG9rZW5UeXBlLkxQYXJlbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbkJhbGFuY2UrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBUb2tlblR5cGUuUlBhcmVuICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVuQmFsYW5jZS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMCAvKiBUb2tlblR5cGUuUmVnZXhTdHIgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4IC8qIFRva2VuVHlwZS5RdW90ZWRTdHIgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb2xsb3dpbmdUb2tlbi5sZXhlbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGxvd2luZ1Rva2VuLmxleGVtZS5jaGFyQ29kZUF0KGkpID09PSA0MCAvKiBDaGFyQ29kZS5PcGVuUGFyZW4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVuQmFsYW5jZSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4cHIubGV4ZW1lLmNoYXJDb2RlQXQoaSkgPT09IDQxIC8qIENoYXJDb2RlLkNsb3NlUGFyZW4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVuQmFsYW5jZS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbkJhbGFuY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXhlbWVSZWNvbnN0cnVjdGlvbi5wdXNoKFNjYW5uZXIuZ2V0TGV4ZW1lKGZvbGxvd2luZ1Rva2VuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9sbG93aW5nVG9rZW4gPSB0aGlzLl9wZWVrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4TGV4ZW1lID0gbGV4ZW1lUmVjb25zdHJ1Y3Rpb24uam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xvc2luZ1NsYXNoSW5kZXggPSByZWdleExleGVtZS5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gY2xvc2luZ1NsYXNoSW5kZXggPT09IHJlZ2V4TGV4ZW1lLmxlbmd0aCAtIDEgPyB1bmRlZmluZWQgOiB0aGlzLl9yZW1vdmVGbGFnc0dZKHJlZ2V4TGV4ZW1lLnN1YnN0cmluZyhjbG9zaW5nU2xhc2hJbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVnZXhwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAocmVnZXhMZXhlbWUuc3Vic3RyaW5nKDEsIGNsb3NpbmdTbGFzaEluZGV4KSwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9lcnJFeHBlY3RlZEJ1dEdvdChgUkVHRVhgLCBleHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRleHRLZXlFeHByLnJlZ2V4KGtleSwgcmVnZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTggLyogVG9rZW5UeXBlLlF1b3RlZFN0ciAqLzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRWYWx1ZSA9IGV4cHIubGV4ZW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBsaWNhdGUgb2xkIHJlZ2V4IHBhcnNpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVnZXggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGYWxzeU9yV2hpdGVzcGFjZShzZXJpYWxpemVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc2VyaWFsaXplZFZhbHVlLmluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gc2VyaWFsaXplZFZhbHVlLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCAhPT0gZW5kICYmIHN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc2VyaWFsaXplZFZhbHVlLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc2VJZ25vcmVGbGFnID0gc2VyaWFsaXplZFZhbHVlW2VuZCArIDFdID09PSAnaScgPyAnaScgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHZhbHVlLCBjYXNlSWdub3JlRmxhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9lcnJFeHBlY3RlZEJ1dEdvdChgUkVHRVhgLCBleHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyRXhwZWN0ZWRCdXRHb3QoJ1JFR0VYJywgZXhwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5UmVnZXhFeHByLmNyZWF0ZShrZXksIHJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyRXhwZWN0ZWRCdXRHb3QoJ1JFR0VYJywgdGhpcy5fcGVlaygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBbICdub3QnICdpbicgdmFsdWUgXVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaE9uZSgxNCAvKiBUb2tlblR5cGUuTm90ICovKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lKDEzIC8qIFRva2VuVHlwZS5JbiAqLywgZXJyb3JOb0luQWZ0ZXJOb3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMuX3ZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5RXhwci5ub3RJbihrZXksIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gWyAoJz09JyB8ICchPScgfCAnPCcgfCAnPD0nIHwgJz4nIHwgJz49JyB8ICdpbicpIHZhbHVlIF1cbiAgICAgICAgICAgICAgICBjb25zdCBtYXliZU9wID0gdGhpcy5fcGVlaygpLnR5cGU7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtYXliZU9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBUb2tlblR5cGUuRXEgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5fdmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2aW91cygpLnR5cGUgPT09IDE4IC8qIFRva2VuVHlwZS5RdW90ZWRTdHIgKi8pIHsgLy8gdG8gcHJlc2VydmUgb2xkIHBhcnNlciBiZWhhdmlvcjogXCJmb28gPT0gJ3RydWUnXCIgaXMgcHJlc2VydmVkIGFzIFwiZm9vID09ICd0cnVlJ1wiLCBidXQgXCJmb28gPT0gdHJ1ZVwiIGlzIG9wdGltaXplZCBhcyBcImZvb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRleHRLZXlFeHByLmVxdWFscyhrZXksIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnVlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRleHRLZXlFeHByLmhhcyhrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRleHRLZXlFeHByLm5vdChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5RXhwci5lcXVhbHMoa2V5LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0IC8qIFRva2VuVHlwZS5Ob3RFcSAqLzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLl92YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzKCkudHlwZSA9PT0gMTggLyogVG9rZW5UeXBlLlF1b3RlZFN0ciAqLykgeyAvLyBzYW1lIGFzIGFib3ZlIHdpdGggXCJmb28gIT0gJ3RydWUnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29udGV4dEtleUV4cHIubm90RXF1YWxzKGtleSwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RydWUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29udGV4dEtleUV4cHIubm90KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFsc2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29udGV4dEtleUV4cHIuaGFzKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRleHRLZXlFeHByLm5vdEVxdWFscyhrZXksIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBDb250ZXh0S2V5RXhwci5zbWFsbGVyKGtleSwgcmlnaHQpIGFjY2VwdHMgb25seSBgbnVtYmVyYCBhcyBgcmlnaHRgIEFORCBkdXJpbmcgZXZhbCBvZiB0aGlzIG5vZGUsIHdlIGp1c3QgZXZhbCB0byBgZmFsc2VgIGlmIGByaWdodGAgaXMgbm90IGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNlcXVlbnRseSwgcGFja2FnZS5qc29uIGxpbnRlciBzaG91bGQgX3dhcm5fIHRoZSB1c2VyIGlmIHRoZXkncmUgcGFzc2luZyB1bmRlc2lyZWQgdGhpbmdzIHRvIG9wc1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDUgLyogVG9rZW5UeXBlLkx0ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRleHRLZXlTbWFsbGVyRXhwci5jcmVhdGUoa2V5LCB0aGlzLl92YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2IC8qIFRva2VuVHlwZS5MdEVxICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRleHRLZXlTbWFsbGVyRXF1YWxzRXhwci5jcmVhdGUoa2V5LCB0aGlzLl92YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3IC8qIFRva2VuVHlwZS5HdCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5R3JlYXRlckV4cHIuY3JlYXRlKGtleSwgdGhpcy5fdmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOCAvKiBUb2tlblR5cGUuR3RFcSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5R3JlYXRlckVxdWFsc0V4cHIuY3JlYXRlKGtleSwgdGhpcy5fdmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTMgLyogVG9rZW5UeXBlLkluICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRleHRLZXlFeHByLmluKGtleSwgdGhpcy5fdmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29udGV4dEtleUV4cHIuaGFzKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyMCAvKiBUb2tlblR5cGUuRU9GICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNpbmdFcnJvcnMucHVzaCh7IG1lc3NhZ2U6IGVycm9yVW5leHBlY3RlZEVPRiwgb2Zmc2V0OiBwZWVrLm9mZnNldCwgbGV4ZW1lOiAnJywgYWRkaXRpb25hbEluZm86IGhpbnRVbmV4cGVjdGVkRU9GIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IFBhcnNlci5fcGFyc2VFcnJvcjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyRXhwZWN0ZWRCdXRHb3QoYHRydWUgfCBmYWxzZSB8IEtFWSBcXG5cXHR8IEtFWSAnPX4nIFJFR0VYIFxcblxcdHwgS0VZICgnPT0nIHwgJyE9JyB8ICc8JyB8ICc8PScgfCAnPicgfCAnPj0nIHwgJ2luJyB8ICdub3QnICdpbicpIHZhbHVlYCwgdGhpcy5fcGVlaygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfdmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5fcGVlaygpO1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMTcgLyogVG9rZW5UeXBlLlN0ciAqLzpcbiAgICAgICAgICAgIGNhc2UgMTggLyogVG9rZW5UeXBlLlF1b3RlZFN0ciAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLmxleGVtZTtcbiAgICAgICAgICAgIGNhc2UgMTEgLyogVG9rZW5UeXBlLlRydWUgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAndHJ1ZSc7XG4gICAgICAgICAgICBjYXNlIDEyIC8qIFRva2VuVHlwZS5GYWxzZSAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmYWxzZSc7XG4gICAgICAgICAgICBjYXNlIDEzIC8qIFRva2VuVHlwZS5JbiAqLzogLy8gd2Ugc3VwcG9ydCBgaW5gIGFzIGEgdmFsdWUsIGUuZy4sIFwid2hlblwiOiBcImxhbmd1YWdlSWQgPT0gaW5cIiAtIGV4aXN0cyBpbiBleGlzdGluZyBleHRlbnNpb25zXG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnaW4nO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGFsbG93cyBcIndoZW5cIjogXCJmb28gPT0gXCIgd2hpY2gncyB1c2VkIGJ5IGV4aXN0aW5nIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAvLyB3ZSBkbyBub3QgY2FsbCBgX2FkdmFuY2VgIG9uIHB1cnBvc2UgLSB3ZSBkb24ndCB3YW50IHRvIGVhdCB1bmludGVuZGVkIHRva2Vuc1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVtb3ZlRmxhZ3NHWShmbGFncykge1xuICAgICAgICByZXR1cm4gZmxhZ3MucmVwbGFjZUFsbCh0aGlzLl9mbGFnc0dZUmUsICcnKTtcbiAgICB9XG4gICAgLy8gY2FyZWZ1bDogdGhpcyBjYW4gdGhyb3cgaWYgY3VycmVudCB0b2tlbiBpcyB0aGUgaW5pdGlhbCBvbmUgKGllIGluZGV4ID0gMClcbiAgICBfcHJldmlvdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbnNbdGhpcy5fY3VycmVudCAtIDFdO1xuICAgIH1cbiAgICBfbWF0Y2hPbmUodG9rZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrKHRva2VuKSkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0F0RW5kKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXMoKTtcbiAgICB9XG4gICAgX2NvbnN1bWUodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5fY2hlY2sodHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdGhpcy5fZXJyRXhwZWN0ZWRCdXRHb3QobWVzc2FnZSwgdGhpcy5fcGVlaygpKTtcbiAgICB9XG4gICAgX2VyckV4cGVjdGVkQnV0R290KGV4cGVjdGVkLCBnb3QsIGFkZGl0aW9uYWxJbmZvKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBsb2NhbGl6ZSgnY29udGV4dGtleS5wYXJzZXIuZXJyb3IuZXhwZWN0ZWRCdXRHb3QnLCBcIkV4cGVjdGVkOiB7MH1cXG5SZWNlaXZlZDogJ3sxfScuXCIsIGV4cGVjdGVkLCBTY2FubmVyLmdldExleGVtZShnb3QpKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZ290Lm9mZnNldDtcbiAgICAgICAgY29uc3QgbGV4ZW1lID0gU2Nhbm5lci5nZXRMZXhlbWUoZ290KTtcbiAgICAgICAgdGhpcy5fcGFyc2luZ0Vycm9ycy5wdXNoKHsgbWVzc2FnZSwgb2Zmc2V0LCBsZXhlbWUsIGFkZGl0aW9uYWxJbmZvIH0pO1xuICAgICAgICByZXR1cm4gUGFyc2VyLl9wYXJzZUVycm9yO1xuICAgIH1cbiAgICBfY2hlY2sodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVlaygpLnR5cGUgPT09IHR5cGU7XG4gICAgfVxuICAgIF9wZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5zW3RoaXMuX2N1cnJlbnRdO1xuICAgIH1cbiAgICBfaXNBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlZWsoKS50eXBlID09PSAyMCAvKiBUb2tlblR5cGUuRU9GICovO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb250ZXh0S2V5RXhwciB7XG4gICAgc3RhdGljIGZhbHNlKCkge1xuICAgICAgICByZXR1cm4gQ29udGV4dEtleUZhbHNlRXhwci5JTlNUQU5DRTtcbiAgICB9XG4gICAgc3RhdGljIHRydWUoKSB7XG4gICAgICAgIHJldHVybiBDb250ZXh0S2V5VHJ1ZUV4cHIuSU5TVEFOQ0U7XG4gICAgfVxuICAgIHN0YXRpYyBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBDb250ZXh0S2V5RGVmaW5lZEV4cHIuY3JlYXRlKGtleSk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQ29udGV4dEtleUVxdWFsc0V4cHIuY3JlYXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgbm90RXF1YWxzKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRLZXlOb3RFcXVhbHNFeHByLmNyZWF0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIHJlZ2V4KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRLZXlSZWdleEV4cHIuY3JlYXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgaW4oa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQ29udGV4dEtleUluRXhwci5jcmVhdGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBub3RJbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBDb250ZXh0S2V5Tm90SW5FeHByLmNyZWF0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIG5vdChrZXkpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRLZXlOb3RFeHByLmNyZWF0ZShrZXkpO1xuICAgIH1cbiAgICBzdGF0aWMgYW5kKC4uLmV4cHIpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRLZXlBbmRFeHByLmNyZWF0ZShleHByLCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgc3RhdGljIG9yKC4uLmV4cHIpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRLZXlPckV4cHIuY3JlYXRlKGV4cHIsIG51bGwsIHRydWUpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLl9wYXJzZXIgPSBuZXcgUGFyc2VyKHsgcmVnZXhQYXJzaW5nV2l0aEVycm9yUmVjb3Zlcnk6IGZhbHNlIH0pOyB9XG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWQgPT09IHVuZGVmaW5lZCB8fCBzZXJpYWxpemVkID09PSBudWxsKSB7IC8vIGFuIGVtcHR5IHN0cmluZyBuZWVkcyB0byBiZSBoYW5kbGVkIGJ5IHRoZSBwYXJzZXIgdG8gZ2V0IGEgY29ycmVzcG9uZGluZyBwYXJzaW5nIGVycm9yIHJlcG9ydGVkXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLl9wYXJzZXIucGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBleHByZXNzaW9uc0FyZUVxdWFsV2l0aENvbnN0YW50U3Vic3RpdHV0aW9uKGEsIGIpIHtcbiAgICBjb25zdCBhRXhwciA9IGEgPyBhLnN1YnN0aXR1dGVDb25zdGFudHMoKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBiRXhwciA9IGIgPyBiLnN1YnN0aXR1dGVDb25zdGFudHMoKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIWFFeHByICYmICFiRXhwcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhRXhwciB8fCAhYkV4cHIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYUV4cHIuZXF1YWxzKGJFeHByKTtcbn1cbmZ1bmN0aW9uIGNtcChhLCBiKSB7XG4gICAgcmV0dXJuIGEuY21wKGIpO1xufVxuZXhwb3J0IGNsYXNzIENvbnRleHRLZXlGYWxzZUV4cHIge1xuICAgIHN0YXRpYyB7IHRoaXMuSU5TVEFOQ0UgPSBuZXcgQ29udGV4dEtleUZhbHNlRXhwcigpOyB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogQ29udGV4dEtleUV4cHJUeXBlLkZhbHNlICovO1xuICAgIH1cbiAgICBjbXAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSAtIG90aGVyLnR5cGU7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyLnR5cGUgPT09IHRoaXMudHlwZSk7XG4gICAgfVxuICAgIHN1YnN0aXR1dGVDb25zdGFudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gJ2ZhbHNlJztcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBDb250ZXh0S2V5VHJ1ZUV4cHIuSU5TVEFOQ0U7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnRleHRLZXlUcnVlRXhwciB7XG4gICAgc3RhdGljIHsgdGhpcy5JTlNUQU5DRSA9IG5ldyBDb250ZXh0S2V5VHJ1ZUV4cHIoKTsgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAxIC8qIENvbnRleHRLZXlFeHByVHlwZS5UcnVlICovO1xuICAgIH1cbiAgICBjbXAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSAtIG90aGVyLnR5cGU7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyLnR5cGUgPT09IHRoaXMudHlwZSk7XG4gICAgfVxuICAgIHN1YnN0aXR1dGVDb25zdGFudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiAndHJ1ZSc7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gQ29udGV4dEtleUZhbHNlRXhwci5JTlNUQU5DRTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29udGV4dEtleURlZmluZWRFeHByIHtcbiAgICBzdGF0aWMgY3JlYXRlKGtleSwgbmVnYXRlZCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29uc3RhbnRWYWx1ZSA9IENPTlNUQU5UX1ZBTFVFUy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zdGFudFZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zdGFudFZhbHVlID8gQ29udGV4dEtleVRydWVFeHByLklOU1RBTkNFIDogQ29udGV4dEtleUZhbHNlRXhwci5JTlNUQU5DRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnRleHRLZXlEZWZpbmVkRXhwcihrZXksIG5lZ2F0ZWQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihrZXksIG5lZ2F0ZWQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMubmVnYXRlZCA9IG5lZ2F0ZWQ7XG4gICAgICAgIHRoaXMudHlwZSA9IDIgLyogQ29udGV4dEtleUV4cHJUeXBlLkRlZmluZWQgKi87XG4gICAgfVxuICAgIGNtcChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlIC0gb3RoZXIudHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY21wMSh0aGlzLmtleSwgb3RoZXIua2V5KTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci50eXBlID09PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5rZXkgPT09IG90aGVyLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdWJzdGl0dXRlQ29uc3RhbnRzKCkge1xuICAgICAgICBjb25zdCBjb25zdGFudFZhbHVlID0gQ09OU1RBTlRfVkFMVUVTLmdldCh0aGlzLmtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc3RhbnRWYWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc3RhbnRWYWx1ZSA/IENvbnRleHRLZXlUcnVlRXhwci5JTlNUQU5DRSA6IENvbnRleHRLZXlGYWxzZUV4cHIuSU5TVEFOQ0U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICghIWNvbnRleHQuZ2V0VmFsdWUodGhpcy5rZXkpKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5rZXldO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5uZWdhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5lZ2F0ZWQgPSBDb250ZXh0S2V5Tm90RXhwci5jcmVhdGUodGhpcy5rZXksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZWQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnRleHRLZXlFcXVhbHNFeHByIHtcbiAgICBzdGF0aWMgY3JlYXRlKGtleSwgdmFsdWUsIG5lZ2F0ZWQgPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA/IENvbnRleHRLZXlEZWZpbmVkRXhwci5jcmVhdGUoa2V5LCBuZWdhdGVkKSA6IENvbnRleHRLZXlOb3RFeHByLmNyZWF0ZShrZXksIG5lZ2F0ZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25zdGFudFZhbHVlID0gQ09OU1RBTlRfVkFMVUVTLmdldChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnN0YW50VmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgY29uc3QgdHJ1ZVZhbHVlID0gY29uc3RhbnRWYWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlID09PSB0cnVlVmFsdWUgPyBDb250ZXh0S2V5VHJ1ZUV4cHIuSU5TVEFOQ0UgOiBDb250ZXh0S2V5RmFsc2VFeHByLklOU1RBTkNFKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnRleHRLZXlFcXVhbHNFeHByKGtleSwgdmFsdWUsIG5lZ2F0ZWQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBuZWdhdGVkKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmVnYXRlZCA9IG5lZ2F0ZWQ7XG4gICAgICAgIHRoaXMudHlwZSA9IDQgLyogQ29udGV4dEtleUV4cHJUeXBlLkVxdWFscyAqLztcbiAgICB9XG4gICAgY21wKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgLSBvdGhlci50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbXAyKHRoaXMua2V5LCB0aGlzLnZhbHVlLCBvdGhlci5rZXksIG90aGVyLnZhbHVlKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci50eXBlID09PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5rZXkgPT09IG90aGVyLmtleSAmJiB0aGlzLnZhbHVlID09PSBvdGhlci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdWJzdGl0dXRlQ29uc3RhbnRzKCkge1xuICAgICAgICBjb25zdCBjb25zdGFudFZhbHVlID0gQ09OU1RBTlRfVkFMVUVTLmdldCh0aGlzLmtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc3RhbnRWYWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBjb25zdCB0cnVlVmFsdWUgPSBjb25zdGFudFZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSA9PT0gdHJ1ZVZhbHVlID8gQ29udGV4dEtleVRydWVFeHByLklOU1RBTkNFIDogQ29udGV4dEtleUZhbHNlRXhwci5JTlNUQU5DRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICAgICAgLy8gSW50ZW50aW9uYWwgPT1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICByZXR1cm4gKGNvbnRleHQuZ2V0VmFsdWUodGhpcy5rZXkpID09IHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmtleX0gPT0gJyR7dGhpcy52YWx1ZX0nYDtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmtleV07XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5lZ2F0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmVnYXRlZCA9IENvbnRleHRLZXlOb3RFcXVhbHNFeHByLmNyZWF0ZSh0aGlzLmtleSwgdGhpcy52YWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29udGV4dEtleUluRXhwciB7XG4gICAgc3RhdGljIGNyZWF0ZShrZXksIHZhbHVlS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGV4dEtleUluRXhwcihrZXksIHZhbHVlS2V5KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZUtleSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZUtleSA9IHZhbHVlS2V5O1xuICAgICAgICB0aGlzLnR5cGUgPSAxMCAvKiBDb250ZXh0S2V5RXhwclR5cGUuSW4gKi87XG4gICAgICAgIHRoaXMubmVnYXRlZCA9IG51bGw7XG4gICAgfVxuICAgIGNtcChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlIC0gb3RoZXIudHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY21wMih0aGlzLmtleSwgdGhpcy52YWx1ZUtleSwgb3RoZXIua2V5LCBvdGhlci52YWx1ZUtleSk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSA9PT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMua2V5ID09PSBvdGhlci5rZXkgJiYgdGhpcy52YWx1ZUtleSA9PT0gb3RoZXIudmFsdWVLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3Vic3RpdHV0ZUNvbnN0YW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gY29udGV4dC5nZXRWYWx1ZSh0aGlzLnZhbHVlS2V5KTtcbiAgICAgICAgY29uc3QgaXRlbSA9IGNvbnRleHQuZ2V0VmFsdWUodGhpcy5rZXkpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmluY2x1ZGVzKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5rZXl9IGluICcke3RoaXMudmFsdWVLZXl9J2A7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5rZXksIHRoaXMudmFsdWVLZXldO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5uZWdhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5lZ2F0ZWQgPSBDb250ZXh0S2V5Tm90SW5FeHByLmNyZWF0ZSh0aGlzLmtleSwgdGhpcy52YWx1ZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29udGV4dEtleU5vdEluRXhwciB7XG4gICAgc3RhdGljIGNyZWF0ZShrZXksIHZhbHVlS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGV4dEtleU5vdEluRXhwcihrZXksIHZhbHVlS2V5KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZUtleSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZUtleSA9IHZhbHVlS2V5O1xuICAgICAgICB0aGlzLnR5cGUgPSAxMSAvKiBDb250ZXh0S2V5RXhwclR5cGUuTm90SW4gKi87XG4gICAgICAgIHRoaXMuX25lZ2F0ZWQgPSBDb250ZXh0S2V5SW5FeHByLmNyZWF0ZShrZXksIHZhbHVlS2V5KTtcbiAgICB9XG4gICAgY21wKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgLSBvdGhlci50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9uZWdhdGVkLmNtcChvdGhlci5fbmVnYXRlZCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSA9PT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmVnYXRlZC5lcXVhbHMob3RoZXIuX25lZ2F0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3Vic3RpdHV0ZUNvbnN0YW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9uZWdhdGVkLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmtleX0gbm90IGluICcke3RoaXMudmFsdWVLZXl9J2A7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZWdhdGVkLmtleXMoKTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmVnYXRlZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29udGV4dEtleU5vdEVxdWFsc0V4cHIge1xuICAgIHN0YXRpYyBjcmVhdGUoa2V5LCB2YWx1ZSwgbmVnYXRlZCA9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udGV4dEtleU5vdEV4cHIuY3JlYXRlKGtleSwgbmVnYXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ29udGV4dEtleURlZmluZWRFeHByLmNyZWF0ZShrZXksIG5lZ2F0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnN0YW50VmFsdWUgPSBDT05TVEFOVF9WQUxVRVMuZ2V0KGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc3RhbnRWYWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBjb25zdCBmYWxzZVZhbHVlID0gY29uc3RhbnRWYWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlID09PSBmYWxzZVZhbHVlID8gQ29udGV4dEtleUZhbHNlRXhwci5JTlNUQU5DRSA6IENvbnRleHRLZXlUcnVlRXhwci5JTlNUQU5DRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb250ZXh0S2V5Tm90RXF1YWxzRXhwcihrZXksIHZhbHVlLCBuZWdhdGVkKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgbmVnYXRlZCkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5lZ2F0ZWQgPSBuZWdhdGVkO1xuICAgICAgICB0aGlzLnR5cGUgPSA1IC8qIENvbnRleHRLZXlFeHByVHlwZS5Ob3RFcXVhbHMgKi87XG4gICAgfVxuICAgIGNtcChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlIC0gb3RoZXIudHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY21wMih0aGlzLmtleSwgdGhpcy52YWx1ZSwgb3RoZXIua2V5LCBvdGhlci52YWx1ZSk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSA9PT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMua2V5ID09PSBvdGhlci5rZXkgJiYgdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3Vic3RpdHV0ZUNvbnN0YW50cygpIHtcbiAgICAgICAgY29uc3QgY29uc3RhbnRWYWx1ZSA9IENPTlNUQU5UX1ZBTFVFUy5nZXQodGhpcy5rZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnN0YW50VmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgY29uc3QgZmFsc2VWYWx1ZSA9IGNvbnN0YW50VmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlID09PSBmYWxzZVZhbHVlID8gQ29udGV4dEtleUZhbHNlRXhwci5JTlNUQU5DRSA6IENvbnRleHRLZXlUcnVlRXhwci5JTlNUQU5DRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICAgICAgLy8gSW50ZW50aW9uYWwgIT1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICByZXR1cm4gKGNvbnRleHQuZ2V0VmFsdWUodGhpcy5rZXkpICE9IHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmtleX0gIT0gJyR7dGhpcy52YWx1ZX0nYDtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmtleV07XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5lZ2F0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmVnYXRlZCA9IENvbnRleHRLZXlFcXVhbHNFeHByLmNyZWF0ZSh0aGlzLmtleSwgdGhpcy52YWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29udGV4dEtleU5vdEV4cHIge1xuICAgIHN0YXRpYyBjcmVhdGUoa2V5LCBuZWdhdGVkID0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb25zdGFudFZhbHVlID0gQ09OU1RBTlRfVkFMVUVTLmdldChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnN0YW50VmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIChjb25zdGFudFZhbHVlID8gQ29udGV4dEtleUZhbHNlRXhwci5JTlNUQU5DRSA6IENvbnRleHRLZXlUcnVlRXhwci5JTlNUQU5DRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb250ZXh0S2V5Tm90RXhwcihrZXksIG5lZ2F0ZWQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihrZXksIG5lZ2F0ZWQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMubmVnYXRlZCA9IG5lZ2F0ZWQ7XG4gICAgICAgIHRoaXMudHlwZSA9IDMgLyogQ29udGV4dEtleUV4cHJUeXBlLk5vdCAqLztcbiAgICB9XG4gICAgY21wKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgLSBvdGhlci50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbXAxKHRoaXMua2V5LCBvdGhlci5rZXkpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLnR5cGUgPT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmtleSA9PT0gb3RoZXIua2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN1YnN0aXR1dGVDb25zdGFudHMoKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50VmFsdWUgPSBDT05TVEFOVF9WQUxVRVMuZ2V0KHRoaXMua2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zdGFudFZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiAoY29uc3RhbnRWYWx1ZSA/IENvbnRleHRLZXlGYWxzZUV4cHIuSU5TVEFOQ0UgOiBDb250ZXh0S2V5VHJ1ZUV4cHIuSU5TVEFOQ0UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoIWNvbnRleHQuZ2V0VmFsdWUodGhpcy5rZXkpKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gYCEke3RoaXMua2V5fWA7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5rZXldO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5uZWdhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5lZ2F0ZWQgPSBDb250ZXh0S2V5RGVmaW5lZEV4cHIuY3JlYXRlKHRoaXMua2V5LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdpdGhGbG9hdE9yU3RyKHZhbHVlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc05hTihuKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIENvbnRleHRLZXlGYWxzZUV4cHIuSU5TVEFOQ0U7XG59XG5leHBvcnQgY2xhc3MgQ29udGV4dEtleUdyZWF0ZXJFeHByIHtcbiAgICBzdGF0aWMgY3JlYXRlKGtleSwgX3ZhbHVlLCBuZWdhdGVkID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gd2l0aEZsb2F0T3JTdHIoX3ZhbHVlLCAodmFsdWUpID0+IG5ldyBDb250ZXh0S2V5R3JlYXRlckV4cHIoa2V5LCB2YWx1ZSwgbmVnYXRlZCkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBuZWdhdGVkKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmVnYXRlZCA9IG5lZ2F0ZWQ7XG4gICAgICAgIHRoaXMudHlwZSA9IDEyIC8qIENvbnRleHRLZXlFeHByVHlwZS5HcmVhdGVyICovO1xuICAgIH1cbiAgICBjbXAob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSAtIG90aGVyLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNtcDIodGhpcy5rZXksIHRoaXMudmFsdWUsIG90aGVyLmtleSwgb3RoZXIudmFsdWUpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLnR5cGUgPT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmtleSA9PT0gb3RoZXIua2V5ICYmIHRoaXMudmFsdWUgPT09IG90aGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN1YnN0aXR1dGVDb25zdGFudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHBhcnNlRmxvYXQoY29udGV4dC5nZXRWYWx1ZSh0aGlzLmtleSkpID4gdGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMua2V5fSA+ICR7dGhpcy52YWx1ZX1gO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMua2V5XTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMubmVnYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5uZWdhdGVkID0gQ29udGV4dEtleVNtYWxsZXJFcXVhbHNFeHByLmNyZWF0ZSh0aGlzLmtleSwgdGhpcy52YWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29udGV4dEtleUdyZWF0ZXJFcXVhbHNFeHByIHtcbiAgICBzdGF0aWMgY3JlYXRlKGtleSwgX3ZhbHVlLCBuZWdhdGVkID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gd2l0aEZsb2F0T3JTdHIoX3ZhbHVlLCAodmFsdWUpID0+IG5ldyBDb250ZXh0S2V5R3JlYXRlckVxdWFsc0V4cHIoa2V5LCB2YWx1ZSwgbmVnYXRlZCkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBuZWdhdGVkKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmVnYXRlZCA9IG5lZ2F0ZWQ7XG4gICAgICAgIHRoaXMudHlwZSA9IDEzIC8qIENvbnRleHRLZXlFeHByVHlwZS5HcmVhdGVyRXF1YWxzICovO1xuICAgIH1cbiAgICBjbXAob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSAtIG90aGVyLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNtcDIodGhpcy5rZXksIHRoaXMudmFsdWUsIG90aGVyLmtleSwgb3RoZXIudmFsdWUpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLnR5cGUgPT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmtleSA9PT0gb3RoZXIua2V5ICYmIHRoaXMudmFsdWUgPT09IG90aGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN1YnN0aXR1dGVDb25zdGFudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHBhcnNlRmxvYXQoY29udGV4dC5nZXRWYWx1ZSh0aGlzLmtleSkpID49IHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmtleX0gPj0gJHt0aGlzLnZhbHVlfWA7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5rZXldO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5uZWdhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5lZ2F0ZWQgPSBDb250ZXh0S2V5U21hbGxlckV4cHIuY3JlYXRlKHRoaXMua2V5LCB0aGlzLnZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGVkO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb250ZXh0S2V5U21hbGxlckV4cHIge1xuICAgIHN0YXRpYyBjcmVhdGUoa2V5LCBfdmFsdWUsIG5lZ2F0ZWQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB3aXRoRmxvYXRPclN0cihfdmFsdWUsICh2YWx1ZSkgPT4gbmV3IENvbnRleHRLZXlTbWFsbGVyRXhwcihrZXksIHZhbHVlLCBuZWdhdGVkKSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIG5lZ2F0ZWQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uZWdhdGVkID0gbmVnYXRlZDtcbiAgICAgICAgdGhpcy50eXBlID0gMTQgLyogQ29udGV4dEtleUV4cHJUeXBlLlNtYWxsZXIgKi87XG4gICAgfVxuICAgIGNtcChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlIC0gb3RoZXIudHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY21wMih0aGlzLmtleSwgdGhpcy52YWx1ZSwgb3RoZXIua2V5LCBvdGhlci52YWx1ZSk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSA9PT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMua2V5ID09PSBvdGhlci5rZXkgJiYgdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3Vic3RpdHV0ZUNvbnN0YW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocGFyc2VGbG9hdChjb250ZXh0LmdldFZhbHVlKHRoaXMua2V5KSkgPCB0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5rZXl9IDwgJHt0aGlzLnZhbHVlfWA7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5rZXldO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5uZWdhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5lZ2F0ZWQgPSBDb250ZXh0S2V5R3JlYXRlckVxdWFsc0V4cHIuY3JlYXRlKHRoaXMua2V5LCB0aGlzLnZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGVkO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb250ZXh0S2V5U21hbGxlckVxdWFsc0V4cHIge1xuICAgIHN0YXRpYyBjcmVhdGUoa2V5LCBfdmFsdWUsIG5lZ2F0ZWQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB3aXRoRmxvYXRPclN0cihfdmFsdWUsICh2YWx1ZSkgPT4gbmV3IENvbnRleHRLZXlTbWFsbGVyRXF1YWxzRXhwcihrZXksIHZhbHVlLCBuZWdhdGVkKSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIG5lZ2F0ZWQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uZWdhdGVkID0gbmVnYXRlZDtcbiAgICAgICAgdGhpcy50eXBlID0gMTUgLyogQ29udGV4dEtleUV4cHJUeXBlLlNtYWxsZXJFcXVhbHMgKi87XG4gICAgfVxuICAgIGNtcChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlIC0gb3RoZXIudHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY21wMih0aGlzLmtleSwgdGhpcy52YWx1ZSwgb3RoZXIua2V5LCBvdGhlci52YWx1ZSk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSA9PT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMua2V5ID09PSBvdGhlci5rZXkgJiYgdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3Vic3RpdHV0ZUNvbnN0YW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocGFyc2VGbG9hdChjb250ZXh0LmdldFZhbHVlKHRoaXMua2V5KSkgPD0gdGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMua2V5fSA8PSAke3RoaXMudmFsdWV9YDtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmtleV07XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5lZ2F0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmVnYXRlZCA9IENvbnRleHRLZXlHcmVhdGVyRXhwci5jcmVhdGUodGhpcy5rZXksIHRoaXMudmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZWQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnRleHRLZXlSZWdleEV4cHIge1xuICAgIHN0YXRpYyBjcmVhdGUoa2V5LCByZWdleHApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250ZXh0S2V5UmVnZXhFeHByKGtleSwgcmVnZXhwKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioa2V5LCByZWdleHApIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucmVnZXhwID0gcmVnZXhwO1xuICAgICAgICB0aGlzLnR5cGUgPSA3IC8qIENvbnRleHRLZXlFeHByVHlwZS5SZWdleCAqLztcbiAgICAgICAgdGhpcy5uZWdhdGVkID0gbnVsbDtcbiAgICAgICAgLy9cbiAgICB9XG4gICAgY21wKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgLSBvdGhlci50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmtleSA8IG90aGVyLmtleSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmtleSA+IG90aGVyLmtleSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhpc1NvdXJjZSA9IHRoaXMucmVnZXhwID8gdGhpcy5yZWdleHAuc291cmNlIDogJyc7XG4gICAgICAgIGNvbnN0IG90aGVyU291cmNlID0gb3RoZXIucmVnZXhwID8gb3RoZXIucmVnZXhwLnNvdXJjZSA6ICcnO1xuICAgICAgICBpZiAodGhpc1NvdXJjZSA8IG90aGVyU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNTb3VyY2UgPiBvdGhlclNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSA9PT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjb25zdCB0aGlzU291cmNlID0gdGhpcy5yZWdleHAgPyB0aGlzLnJlZ2V4cC5zb3VyY2UgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IG90aGVyU291cmNlID0gb3RoZXIucmVnZXhwID8gb3RoZXIucmVnZXhwLnNvdXJjZSA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmtleSA9PT0gb3RoZXIua2V5ICYmIHRoaXNTb3VyY2UgPT09IG90aGVyU291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN1YnN0aXR1dGVDb25zdGFudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dC5nZXRWYWx1ZSh0aGlzLmtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IHRoaXMucmVnZXhwLnRlc3QodmFsdWUpIDogZmFsc2U7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlZ2V4cFxuICAgICAgICAgICAgPyBgLyR7dGhpcy5yZWdleHAuc291cmNlfS8ke3RoaXMucmVnZXhwLmZsYWdzfWBcbiAgICAgICAgICAgIDogJy9pbnZhbGlkLyc7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmtleX0gPX4gJHt2YWx1ZX1gO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMua2V5XTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMubmVnYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5uZWdhdGVkID0gQ29udGV4dEtleU5vdFJlZ2V4RXhwci5jcmVhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29udGV4dEtleU5vdFJlZ2V4RXhwciB7XG4gICAgc3RhdGljIGNyZWF0ZShhY3R1YWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250ZXh0S2V5Tm90UmVnZXhFeHByKGFjdHVhbCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9hY3R1YWwpIHtcbiAgICAgICAgdGhpcy5fYWN0dWFsID0gX2FjdHVhbDtcbiAgICAgICAgdGhpcy50eXBlID0gOCAvKiBDb250ZXh0S2V5RXhwclR5cGUuTm90UmVnZXggKi87XG4gICAgICAgIC8vXG4gICAgfVxuICAgIGNtcChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlIC0gb3RoZXIudHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsLmNtcChvdGhlci5fYWN0dWFsKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci50eXBlID09PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3R1YWwuZXF1YWxzKG90aGVyLl9hY3R1YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3Vic3RpdHV0ZUNvbnN0YW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9hY3R1YWwuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIGAhKCR7dGhpcy5fYWN0dWFsLnNlcmlhbGl6ZSgpfSlgO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsLmtleXMoKTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsO1xuICAgIH1cbn1cbi8qKlxuICogQHJldHVybnMgdGhlIHNhbWUgaW5zdGFuY2UgaWYgbm90aGluZyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBlbGltaW5hdGVDb25zdGFudHNJbkFycmF5KGFycikge1xuICAgIC8vIEFsbG9jYXRlIGFycmF5IG9ubHkgaWYgdGhlcmUgaXMgYSBkaWZmZXJlbmNlXG4gICAgbGV0IG5ld0FyciA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBuZXdFeHByID0gYXJyW2ldLnN1YnN0aXR1dGVDb25zdGFudHMoKTtcbiAgICAgICAgaWYgKGFycltpXSAhPT0gbmV3RXhwcikge1xuICAgICAgICAgICAgLy8gc29tZXRoaW5nIGhhcyBjaGFuZ2VkIVxuICAgICAgICAgICAgLy8gYWxsb2NhdGUgYXJyYXkgb24gZmlyc3QgZGlmZmVyZW5jZVxuICAgICAgICAgICAgaWYgKG5ld0FyciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld0FyciA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FycltqXSA9IGFycltqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0FyciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3QXJyW2ldID0gbmV3RXhwcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3QXJyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnI7XG59XG5leHBvcnQgY2xhc3MgQ29udGV4dEtleUFuZEV4cHIge1xuICAgIHN0YXRpYyBjcmVhdGUoX2V4cHIsIG5lZ2F0ZWQsIGV4dHJhUmVkdW5kYW50Q2hlY2spIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRLZXlBbmRFeHByLl9ub3JtYWxpemVBcnIoX2V4cHIsIG5lZ2F0ZWQsIGV4dHJhUmVkdW5kYW50Q2hlY2spO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihleHByLCBuZWdhdGVkKSB7XG4gICAgICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gICAgICAgIHRoaXMubmVnYXRlZCA9IG5lZ2F0ZWQ7XG4gICAgICAgIHRoaXMudHlwZSA9IDYgLyogQ29udGV4dEtleUV4cHJUeXBlLkFuZCAqLztcbiAgICB9XG4gICAgY21wKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgLSBvdGhlci50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4cHIubGVuZ3RoIDwgb3RoZXIuZXhwci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leHByLmxlbmd0aCA+IG90aGVyLmV4cHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5leHByLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByID0gY21wKHRoaXMuZXhwcltpXSwgb3RoZXIuZXhwcltpXSk7XG4gICAgICAgICAgICBpZiAociAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLnR5cGUgPT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhwci5sZW5ndGggIT09IG90aGVyLmV4cHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuZXhwci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5leHByW2ldLmVxdWFscyhvdGhlci5leHByW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdWJzdGl0dXRlQ29uc3RhbnRzKCkge1xuICAgICAgICBjb25zdCBleHByQXJyID0gZWxpbWluYXRlQ29uc3RhbnRzSW5BcnJheSh0aGlzLmV4cHIpO1xuICAgICAgICBpZiAoZXhwckFyciA9PT0gdGhpcy5leHByKSB7XG4gICAgICAgICAgICAvLyBubyBjaGFuZ2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb250ZXh0S2V5QW5kRXhwci5jcmVhdGUoZXhwckFyciwgdGhpcy5uZWdhdGVkLCBmYWxzZSk7XG4gICAgfVxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuZXhwci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4cHJbaV0uZXZhbHVhdGUoY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHN0YXRpYyBfbm9ybWFsaXplQXJyKGFyciwgbmVnYXRlZCwgZXh0cmFSZWR1bmRhbnRDaGVjaykge1xuICAgICAgICBjb25zdCBleHByID0gW107XG4gICAgICAgIGxldCBoYXNUcnVlID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgZSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gMSAvKiBDb250ZXh0S2V5RXhwclR5cGUuVHJ1ZSAqLykge1xuICAgICAgICAgICAgICAgIC8vIGFueXRoaW5nICYmIHRydWUgPT0+IGFueXRoaW5nXG4gICAgICAgICAgICAgICAgaGFzVHJ1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSAwIC8qIENvbnRleHRLZXlFeHByVHlwZS5GYWxzZSAqLykge1xuICAgICAgICAgICAgICAgIC8vIGFueXRoaW5nICYmIGZhbHNlID09PiBmYWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5RmFsc2VFeHByLklOU1RBTkNFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gNiAvKiBDb250ZXh0S2V5RXhwclR5cGUuQW5kICovKSB7XG4gICAgICAgICAgICAgICAgZXhwci5wdXNoKC4uLmUuZXhwcik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHIubGVuZ3RoID09PSAwICYmIGhhc1RydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5VHJ1ZUV4cHIuSU5TVEFOQ0U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHByLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJbMF07XG4gICAgICAgIH1cbiAgICAgICAgZXhwci5zb3J0KGNtcCk7XG4gICAgICAgIC8vIGVsaW1pbmF0ZSBkdXBsaWNhdGUgdGVybXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBleHByLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXhwcltpIC0gMV0uZXF1YWxzKGV4cHJbaV0pKSB7XG4gICAgICAgICAgICAgICAgZXhwci5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHByLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbXVzdCBkaXN0cmlidXRlIGFueSBPUiBleHByZXNzaW9uIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBwYXJlbnNcbiAgICAgICAgLy8gT1IgZXh0ZW5zaW9ucyB3aWxsIGJlIGF0IHRoZSBlbmQgKGR1ZSB0byBzb3J0aW5nIHJ1bGVzKVxuICAgICAgICB3aGlsZSAoZXhwci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0RWxlbWVudCA9IGV4cHJbZXhwci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0RWxlbWVudC50eXBlICE9PSA5IC8qIENvbnRleHRLZXlFeHByVHlwZS5PciAqLykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcG9wIHRoZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgICAgIGV4cHIucG9wKCk7XG4gICAgICAgICAgICAvLyBwb3AgdGhlIHNlY29uZCB0byBsYXN0IGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZFRvTGFzdEVsZW1lbnQgPSBleHByLnBvcCgpO1xuICAgICAgICAgICAgY29uc3QgaXNGaW5pc2hlZCA9IChleHByLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgICAgICAvLyBkaXN0cmlidXRlIGBsYXN0RWxlbWVudGAgb3ZlciBgc2Vjb25kVG9MYXN0RWxlbWVudGBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdEVsZW1lbnQgPSBDb250ZXh0S2V5T3JFeHByLmNyZWF0ZShsYXN0RWxlbWVudC5leHByLm1hcChlbCA9PiBDb250ZXh0S2V5QW5kRXhwci5jcmVhdGUoW2VsLCBzZWNvbmRUb0xhc3RFbGVtZW50XSwgbnVsbCwgZXh0cmFSZWR1bmRhbnRDaGVjaykpLCBudWxsLCBpc0ZpbmlzaGVkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZXhwci5wdXNoKHJlc3VsdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGV4cHIuc29ydChjbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHByLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBmYWxzZSBBTkQgZXhwcmVzc2lvbnNcbiAgICAgICAgaWYgKGV4dHJhUmVkdW5kYW50Q2hlY2spIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGV4cHIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJbaV0ubmVnYXRlKCkuZXF1YWxzKGV4cHJbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBICYmICFBIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5RmFsc2VFeHByLklOU1RBTkNFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb250ZXh0S2V5QW5kRXhwcihleHByLCBuZWdhdGVkKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByLm1hcChlID0+IGUuc2VyaWFsaXplKCkpLmpvaW4oJyAmJiAnKTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZXhwciBvZiB0aGlzLmV4cHIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLmV4cHIua2V5cygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5uZWdhdGVkKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXhwciBvZiB0aGlzLmV4cHIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChleHByLm5lZ2F0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmVnYXRlZCA9IENvbnRleHRLZXlPckV4cHIuY3JlYXRlKHJlc3VsdCwgdGhpcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29udGV4dEtleU9yRXhwciB7XG4gICAgc3RhdGljIGNyZWF0ZShfZXhwciwgbmVnYXRlZCwgZXh0cmFSZWR1bmRhbnRDaGVjaykge1xuICAgICAgICByZXR1cm4gQ29udGV4dEtleU9yRXhwci5fbm9ybWFsaXplQXJyKF9leHByLCBuZWdhdGVkLCBleHRyYVJlZHVuZGFudENoZWNrKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZXhwciwgbmVnYXRlZCkge1xuICAgICAgICB0aGlzLmV4cHIgPSBleHByO1xuICAgICAgICB0aGlzLm5lZ2F0ZWQgPSBuZWdhdGVkO1xuICAgICAgICB0aGlzLnR5cGUgPSA5IC8qIENvbnRleHRLZXlFeHByVHlwZS5PciAqLztcbiAgICB9XG4gICAgY21wKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgLSBvdGhlci50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4cHIubGVuZ3RoIDwgb3RoZXIuZXhwci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leHByLmxlbmd0aCA+IG90aGVyLmV4cHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5leHByLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByID0gY21wKHRoaXMuZXhwcltpXSwgb3RoZXIuZXhwcltpXSk7XG4gICAgICAgICAgICBpZiAociAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLnR5cGUgPT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhwci5sZW5ndGggIT09IG90aGVyLmV4cHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuZXhwci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5leHByW2ldLmVxdWFscyhvdGhlci5leHByW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdWJzdGl0dXRlQ29uc3RhbnRzKCkge1xuICAgICAgICBjb25zdCBleHByQXJyID0gZWxpbWluYXRlQ29uc3RhbnRzSW5BcnJheSh0aGlzLmV4cHIpO1xuICAgICAgICBpZiAoZXhwckFyciA9PT0gdGhpcy5leHByKSB7XG4gICAgICAgICAgICAvLyBubyBjaGFuZ2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb250ZXh0S2V5T3JFeHByLmNyZWF0ZShleHByQXJyLCB0aGlzLm5lZ2F0ZWQsIGZhbHNlKTtcbiAgICB9XG4gICAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5leHByLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5leHByW2ldLmV2YWx1YXRlKGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgX25vcm1hbGl6ZUFycihhcnIsIG5lZ2F0ZWQsIGV4dHJhUmVkdW5kYW50Q2hlY2spIHtcbiAgICAgICAgbGV0IGV4cHIgPSBbXTtcbiAgICAgICAgbGV0IGhhc0ZhbHNlID0gZmFsc2U7XG4gICAgICAgIGlmIChhcnIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gYXJyW2ldO1xuICAgICAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gMCAvKiBDb250ZXh0S2V5RXhwclR5cGUuRmFsc2UgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW55dGhpbmcgfHwgZmFsc2UgPT0+IGFueXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIGhhc0ZhbHNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IDEgLyogQ29udGV4dEtleUV4cHJUeXBlLlRydWUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW55dGhpbmcgfHwgdHJ1ZSA9PT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29udGV4dEtleVRydWVFeHByLklOU1RBTkNFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSA5IC8qIENvbnRleHRLZXlFeHByVHlwZS5PciAqLykge1xuICAgICAgICAgICAgICAgICAgICBleHByID0gZXhwci5jb25jYXQoZS5leHByKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cHIucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLmxlbmd0aCA9PT0gMCAmJiBoYXNGYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5RmFsc2VFeHByLklOU1RBTkNFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwci5zb3J0KGNtcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHByLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxpbWluYXRlIGR1cGxpY2F0ZSB0ZXJtc1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGV4cHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChleHByW2kgLSAxXS5lcXVhbHMoZXhwcltpXSkpIHtcbiAgICAgICAgICAgICAgICBleHByLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwclswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNvbHZlIHRydWUgT1IgZXhwcmVzc2lvbnNcbiAgICAgICAgaWYgKGV4dHJhUmVkdW5kYW50Q2hlY2spIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGV4cHIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJbaV0ubmVnYXRlKCkuZXF1YWxzKGV4cHJbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHx8ICFBIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDb250ZXh0S2V5VHJ1ZUV4cHIuSU5TVEFOQ0U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwclswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnRleHRLZXlPckV4cHIoZXhwciwgbmVnYXRlZCk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwci5tYXAoZSA9PiBlLnNlcmlhbGl6ZSgpKS5qb2luKCcgfHwgJyk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV4cHIgb2YgdGhpcy5leHByKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCguLi5leHByLmtleXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMubmVnYXRlZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4cHIgb2YgdGhpcy5leHByKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZXhwci5uZWdhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHBhcmVucywgc28gaGVyZSB3ZSBkaXN0cmlidXRlIHRoZSBBTkQgb3ZlciB0aGUgT1IgdGVybWluYWxzXG4gICAgICAgICAgICAvLyBXZSBhbHdheXMgdGFrZSB0aGUgZmlyc3QgMiBBTkQgcGFpcnMgYW5kIGRpc3RyaWJ1dGUgdGhlbVxuICAgICAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgTEVGVCA9IHJlc3VsdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFJJR0hUID0gcmVzdWx0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsZWZ0IG9mIGdldFRlcm1pbmFscyhMRUZUKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJpZ2h0IG9mIGdldFRlcm1pbmFscyhSSUdIVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbC5wdXNoKENvbnRleHRLZXlBbmRFeHByLmNyZWF0ZShbbGVmdCwgcmlnaHRdLCBudWxsLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KENvbnRleHRLZXlPckV4cHIuY3JlYXRlKGFsbCwgbnVsbCwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmVnYXRlZCA9IENvbnRleHRLZXlPckV4cHIuY3JlYXRlKHJlc3VsdCwgdGhpcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmF3Q29udGV4dEtleSBleHRlbmRzIENvbnRleHRLZXlEZWZpbmVkRXhwciB7XG4gICAgc3RhdGljIHsgdGhpcy5faW5mbyA9IFtdOyB9XG4gICAgc3RhdGljIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIFJhd0NvbnRleHRLZXkuX2luZm8udmFsdWVzKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGtleSwgZGVmYXVsdFZhbHVlLCBtZXRhT3JIaWRlKSB7XG4gICAgICAgIHN1cGVyKGtleSwgbnVsbCk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgLy8gY29sbGVjdCBhbGwgY29udGV4dCBrZXlzIGludG8gYSBjZW50cmFsIHBsYWNlXG4gICAgICAgIGlmICh0eXBlb2YgbWV0YU9ySGlkZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIFJhd0NvbnRleHRLZXkuX2luZm8ucHVzaCh7IC4uLm1ldGFPckhpZGUsIGtleSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXRhT3JIaWRlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBSYXdDb250ZXh0S2V5Ll9pbmZvLnB1c2goeyBrZXksIGRlc2NyaXB0aW9uOiBtZXRhT3JIaWRlLCB0eXBlOiBkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgPyB0eXBlb2YgZGVmYXVsdFZhbHVlIDogdW5kZWZpbmVkIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmRUbyh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5jcmVhdGVLZXkodGhpcy5rZXksIHRoaXMuX2RlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIGdldFZhbHVlKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmdldENvbnRleHRLZXlWYWx1ZSh0aGlzLmtleSk7XG4gICAgfVxuICAgIHRvTmVnYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCk7XG4gICAgfVxuICAgIGlzRXF1YWxUbyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQ29udGV4dEtleUVxdWFsc0V4cHIuY3JlYXRlKHRoaXMua2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IElDb250ZXh0S2V5U2VydmljZSA9IGNyZWF0ZURlY29yYXRvcignY29udGV4dEtleVNlcnZpY2UnKTtcbmZ1bmN0aW9uIGNtcDEoa2V5MSwga2V5Mikge1xuICAgIGlmIChrZXkxIDwga2V5Mikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChrZXkxID4ga2V5Mikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjbXAyKGtleTEsIHZhbHVlMSwga2V5MiwgdmFsdWUyKSB7XG4gICAgaWYgKGtleTEgPCBrZXkyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGtleTEgPiBrZXkyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodmFsdWUxIDwgdmFsdWUyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHZhbHVlMSA+IHZhbHVlMikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBpdCBpcyBwcm92YWJsZSBgcGAgaW1wbGllcyBgcWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbXBsaWVzKHAsIHEpIHtcbiAgICBpZiAocC50eXBlID09PSAwIC8qIENvbnRleHRLZXlFeHByVHlwZS5GYWxzZSAqLyB8fCBxLnR5cGUgPT09IDEgLyogQ29udGV4dEtleUV4cHJUeXBlLlRydWUgKi8pIHtcbiAgICAgICAgLy8gZmFsc2UgaW1wbGllcyBhbnl0aGluZ1xuICAgICAgICAvLyBhbnl0aGluZyBpbXBsaWVzIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwLnR5cGUgPT09IDkgLyogQ29udGV4dEtleUV4cHJUeXBlLk9yICovKSB7XG4gICAgICAgIGlmIChxLnR5cGUgPT09IDkgLyogQ29udGV4dEtleUV4cHJUeXBlLk9yICovKSB7XG4gICAgICAgICAgICAvLyBgYSB8fCBiIHx8IGNgIGNhbiBvbmx5IGltcGx5IHNvbWV0aGluZyBsaWtlIGBhIHx8IGIgfHwgYyB8fCBkYFxuICAgICAgICAgICAgcmV0dXJuIGFsbEVsZW1lbnRzSW5jbHVkZWQocC5leHByLCBxLmV4cHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHEudHlwZSA9PT0gOSAvKiBDb250ZXh0S2V5RXhwclR5cGUuT3IgKi8pIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHEuZXhwcikge1xuICAgICAgICAgICAgaWYgKGltcGxpZXMocCwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwLnR5cGUgPT09IDYgLyogQ29udGV4dEtleUV4cHJUeXBlLkFuZCAqLykge1xuICAgICAgICBpZiAocS50eXBlID09PSA2IC8qIENvbnRleHRLZXlFeHByVHlwZS5BbmQgKi8pIHtcbiAgICAgICAgICAgIC8vIGBhICYmIGIgJiYgY2AgaW1wbGllcyBgYSAmJiBjYFxuICAgICAgICAgICAgcmV0dXJuIGFsbEVsZW1lbnRzSW5jbHVkZWQocS5leHByLCBwLmV4cHIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBwLmV4cHIpIHtcbiAgICAgICAgICAgIGlmIChpbXBsaWVzKGVsZW1lbnQsIHEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcC5lcXVhbHMocSk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbGwgZWxlbWVudHMgaW4gYHBgIGFyZSBhbHNvIHByZXNlbnQgaW4gYHFgLlxuICogVGhlIHR3byBhcnJheXMgYXJlIGFzc3VtZWQgdG8gYmUgc29ydGVkXG4gKi9cbmZ1bmN0aW9uIGFsbEVsZW1lbnRzSW5jbHVkZWQocCwgcSkge1xuICAgIGxldCBwSW5kZXggPSAwO1xuICAgIGxldCBxSW5kZXggPSAwO1xuICAgIHdoaWxlIChwSW5kZXggPCBwLmxlbmd0aCAmJiBxSW5kZXggPCBxLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjbXAgPSBwW3BJbmRleF0uY21wKHFbcUluZGV4XSk7XG4gICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAvLyBhbiBlbGVtZW50IGZyb20gYHBgIGlzIG1pc3NpbmcgZnJvbSBgcWBcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgIHBJbmRleCsrO1xuICAgICAgICAgICAgcUluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxSW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHBJbmRleCA9PT0gcC5sZW5ndGgpO1xufVxuZnVuY3Rpb24gZ2V0VGVybWluYWxzKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSA5IC8qIENvbnRleHRLZXlFeHByVHlwZS5PciAqLykge1xuICAgICAgICByZXR1cm4gbm9kZS5leHByO1xuICAgIH1cbiAgICByZXR1cm4gW25vZGVdO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBpbGxlZ2FsU3RhdGUgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgbG9jYWxpemUgfSBmcm9tICcuLi8uLi8uLi9ubHMuanMnO1xuZnVuY3Rpb24gaGludERpZFlvdU1lYW4oLi4ubWVhbnQpIHtcbiAgICBzd2l0Y2ggKG1lYW50Lmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxpemUoJ2NvbnRleHRrZXkuc2Nhbm5lci5oaW50LmRpZFlvdU1lYW4xJywgXCJEaWQgeW91IG1lYW4gezB9P1wiLCBtZWFudFswXSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGl6ZSgnY29udGV4dGtleS5zY2FubmVyLmhpbnQuZGlkWW91TWVhbjInLCBcIkRpZCB5b3UgbWVhbiB7MH0gb3IgezF9P1wiLCBtZWFudFswXSwgbWVhbnRbMV0pO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxpemUoJ2NvbnRleHRrZXkuc2Nhbm5lci5oaW50LmRpZFlvdU1lYW4zJywgXCJEaWQgeW91IG1lYW4gezB9LCB7MX0gb3IgezJ9P1wiLCBtZWFudFswXSwgbWVhbnRbMV0sIG1lYW50WzJdKTtcbiAgICAgICAgZGVmYXVsdDogLy8gd2UganVzdCBkb24ndCBleHBlY3QgdGhhdCBtYW55XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNvbnN0IGhpbnREaWRZb3VGb3JnZXRUb09wZW5PckNsb3NlUXVvdGUgPSBsb2NhbGl6ZSgnY29udGV4dGtleS5zY2FubmVyLmhpbnQuZGlkWW91Rm9yZ2V0VG9PcGVuT3JDbG9zZVF1b3RlJywgXCJEaWQgeW91IGZvcmdldCB0byBvcGVuIG9yIGNsb3NlIHRoZSBxdW90ZT9cIik7XG5jb25zdCBoaW50RGlkWW91Rm9yZ2V0VG9Fc2NhcGVTbGFzaCA9IGxvY2FsaXplKCdjb250ZXh0a2V5LnNjYW5uZXIuaGludC5kaWRZb3VGb3JnZXRUb0VzY2FwZVNsYXNoJywgXCJEaWQgeW91IGZvcmdldCB0byBlc2NhcGUgdGhlICcvJyAoc2xhc2gpIGNoYXJhY3Rlcj8gUHV0IHR3byBiYWNrc2xhc2hlcyBiZWZvcmUgaXQgdG8gZXNjYXBlLCBlLmcuLCAnXFxcXFxcXFwvXFwnLlwiKTtcbi8qKlxuICogQSBzaW1wbGUgc2Nhbm5lciBmb3IgY29udGV4dCBrZXlzLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHNjYW5uZXIgPSBuZXcgU2Nhbm5lcigpLnJlc2V0KCdyZXNvdXJjZUZpbGVOYW1lID1+IC9kb2NrZXIvICYmICFjb25maWcuZG9ja2VyLmVuYWJsZWQnKTtcbiAqIGNvbnN0IHRva2VucyA9IFsuLi5zY2FubmVyXTtcbiAqIGlmIChzY2FubmVyLmVycm9yVG9rZW5zLmxlbmd0aCA+IDApIHtcbiAqICAgICBzY2FubmVyLmVycm9yVG9rZW5zLmZvckVhY2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYFVuZXhwZWN0ZWQgdG9rZW4gYXQgJHtlcnIub2Zmc2V0fTogJHtlcnIubGV4ZW1lfVxcbkhpbnQ6ICR7ZXJyLmFkZGl0aW9uYWx9YCkpO1xuICogfSBlbHNlIHtcbiAqICAgICAvLyBwcm9jZXNzIHRva2Vuc1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTY2FubmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSAnJztcbiAgICAgICAgdGhpcy5fc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gMDtcbiAgICAgICAgdGhpcy5fdG9rZW5zID0gW107XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICAvLyB1IC0gdW5pY29kZSwgeSAtIHN0aWNreSAvLyBUT0RPQHVsdWdiZWtuYTogd2UgYWNjZXB0IGRvdWJsZSBxdW90ZXMgYXMgcGFydCBvZiB0aGUgc3RyaW5nIHJhdGhlciB0aGFuIGFzIGEgZGVsaW1pdGVyICh0byBwcmVzZXJ2ZSBvbGQgcGFyc2VyJ3MgYmVoYXZpb3IpXG4gICAgICAgIHRoaXMuc3RyaW5nUmUgPSAvW2EtekEtWjAtOV88PlxcLVxcLi9cXFxcOlxcKlxcP1xcK1xcW1xcXVxcXiwjQDtcIiVcXCRcXHB7TH0tXSsvdXk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRMZXhlbWUodG9rZW4pIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogVG9rZW5UeXBlLkxQYXJlbiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJygnO1xuICAgICAgICAgICAgY2FzZSAxIC8qIFRva2VuVHlwZS5SUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICcpJztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBUb2tlblR5cGUuTmVnICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnISc7XG4gICAgICAgICAgICBjYXNlIDMgLyogVG9rZW5UeXBlLkVxICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi5pc1RyaXBsZUVxID8gJz09PScgOiAnPT0nO1xuICAgICAgICAgICAgY2FzZSA0IC8qIFRva2VuVHlwZS5Ob3RFcSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4uaXNUcmlwbGVFcSA/ICchPT0nIDogJyE9JztcbiAgICAgICAgICAgIGNhc2UgNSAvKiBUb2tlblR5cGUuTHQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8JztcbiAgICAgICAgICAgIGNhc2UgNiAvKiBUb2tlblR5cGUuTHRFcSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJzw9JztcbiAgICAgICAgICAgIGNhc2UgNyAvKiBUb2tlblR5cGUuR3QgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICc+PSc7XG4gICAgICAgICAgICBjYXNlIDggLyogVG9rZW5UeXBlLkd0RXEgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICc+PSc7XG4gICAgICAgICAgICBjYXNlIDkgLyogVG9rZW5UeXBlLlJlZ2V4T3AgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICc9fic7XG4gICAgICAgICAgICBjYXNlIDEwIC8qIFRva2VuVHlwZS5SZWdleFN0ciAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ubGV4ZW1lO1xuICAgICAgICAgICAgY2FzZSAxMSAvKiBUb2tlblR5cGUuVHJ1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RydWUnO1xuICAgICAgICAgICAgY2FzZSAxMiAvKiBUb2tlblR5cGUuRmFsc2UgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmYWxzZSc7XG4gICAgICAgICAgICBjYXNlIDEzIC8qIFRva2VuVHlwZS5JbiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2luJztcbiAgICAgICAgICAgIGNhc2UgMTQgLyogVG9rZW5UeXBlLk5vdCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vdCc7XG4gICAgICAgICAgICBjYXNlIDE1IC8qIFRva2VuVHlwZS5BbmQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICcmJic7XG4gICAgICAgICAgICBjYXNlIDE2IC8qIFRva2VuVHlwZS5PciAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3x8JztcbiAgICAgICAgICAgIGNhc2UgMTcgLyogVG9rZW5UeXBlLlN0ciAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ubGV4ZW1lO1xuICAgICAgICAgICAgY2FzZSAxOCAvKiBUb2tlblR5cGUuUXVvdGVkU3RyICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi5sZXhlbWU7XG4gICAgICAgICAgICBjYXNlIDE5IC8qIFRva2VuVHlwZS5FcnJvciAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ubGV4ZW1lO1xuICAgICAgICAgICAgY2FzZSAyMCAvKiBUb2tlblR5cGUuRU9GICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnRU9GJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbFN0YXRlKGB1bmhhbmRsZWQgdG9rZW4gdHlwZTogJHtKU09OLnN0cmluZ2lmeSh0b2tlbil9OyBoYXZlIHlvdSBmb3Jnb3R0ZW4gdG8gYWRkIGEgY2FzZT9gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLl9yZWdleEZsYWdzID0gbmV3IFNldChbJ2knLCAnZycsICdzJywgJ20nLCAneScsICd1J10ubWFwKGNoID0+IGNoLmNoYXJDb2RlQXQoMCkpKTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuX2tleXdvcmRzID0gbmV3IE1hcChbXG4gICAgICAgIFsnbm90JywgMTQgLyogVG9rZW5UeXBlLk5vdCAqL10sXG4gICAgICAgIFsnaW4nLCAxMyAvKiBUb2tlblR5cGUuSW4gKi9dLFxuICAgICAgICBbJ2ZhbHNlJywgMTIgLyogVG9rZW5UeXBlLkZhbHNlICovXSxcbiAgICAgICAgWyd0cnVlJywgMTEgLyogVG9rZW5UeXBlLlRydWUgKi9dLFxuICAgIF0pOyB9XG4gICAgcmVzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gMDtcbiAgICAgICAgdGhpcy5fdG9rZW5zID0gW107XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2NhbigpIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLl9pc0F0RW5kKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgNDAgLyogQ2hhckNvZGUuT3BlblBhcmVuICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb2tlbigwIC8qIFRva2VuVHlwZS5MUGFyZW4gKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQxIC8qIENoYXJDb2RlLkNsb3NlUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRva2VuKDEgLyogVG9rZW5UeXBlLlJQYXJlbiAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzMgLyogQ2hhckNvZGUuRXhjbGFtYXRpb25NYXJrICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2goNjEgLyogQ2hhckNvZGUuRXF1YWxzICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNUcmlwbGVFcSA9IHRoaXMuX21hdGNoKDYxIC8qIENoYXJDb2RlLkVxdWFscyAqLyk7IC8vIGVhdCBsYXN0IGA9YCBpZiBgIT09YFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5zLnB1c2goeyB0eXBlOiA0IC8qIFRva2VuVHlwZS5Ob3RFcSAqLywgb2Zmc2V0OiB0aGlzLl9zdGFydCwgaXNUcmlwbGVFcSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRva2VuKDIgLyogVG9rZW5UeXBlLk5lZyAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOSAvKiBDaGFyQ29kZS5TaW5nbGVRdW90ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVvdGVkU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDcgLyogQ2hhckNvZGUuU2xhc2ggKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2V4KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjEgLyogQ2hhckNvZGUuRXF1YWxzICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2goNjEgLyogQ2hhckNvZGUuRXF1YWxzICovKSkgeyAvLyBzdXBwb3J0IGA9PWBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVHJpcGxlRXEgPSB0aGlzLl9tYXRjaCg2MSAvKiBDaGFyQ29kZS5FcXVhbHMgKi8pOyAvLyBlYXQgbGFzdCBgPWAgaWYgYD09PWBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rva2Vucy5wdXNoKHsgdHlwZTogMyAvKiBUb2tlblR5cGUuRXEgKi8sIG9mZnNldDogdGhpcy5fc3RhcnQsIGlzVHJpcGxlRXEgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fbWF0Y2goMTI2IC8qIENoYXJDb2RlLlRpbGRlICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9rZW4oOSAvKiBUb2tlblR5cGUuUmVnZXhPcCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcihoaW50RGlkWW91TWVhbignPT0nLCAnPX4nKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2MCAvKiBDaGFyQ29kZS5MZXNzVGhhbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9rZW4odGhpcy5fbWF0Y2goNjEgLyogQ2hhckNvZGUuRXF1YWxzICovKSA/IDYgLyogVG9rZW5UeXBlLkx0RXEgKi8gOiA1IC8qIFRva2VuVHlwZS5MdCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjIgLyogQ2hhckNvZGUuR3JlYXRlclRoYW4gKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRva2VuKHRoaXMuX21hdGNoKDYxIC8qIENoYXJDb2RlLkVxdWFscyAqLykgPyA4IC8qIFRva2VuVHlwZS5HdEVxICovIDogNyAvKiBUb2tlblR5cGUuR3QgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM4IC8qIENoYXJDb2RlLkFtcGVyc2FuZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoKDM4IC8qIENoYXJDb2RlLkFtcGVyc2FuZCAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRva2VuKDE1IC8qIFRva2VuVHlwZS5BbmQgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IoaGludERpZFlvdU1lYW4oJyYmJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI0IC8qIENoYXJDb2RlLlBpcGUgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaCgxMjQgLyogQ2hhckNvZGUuUGlwZSAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRva2VuKDE2IC8qIFRva2VuVHlwZS5PciAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcihoaW50RGlkWW91TWVhbignfHwnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gVE9ET0B1bHVnYmVrbmE6IDEpIHJld3JpdGUgdXNpbmcgYSByZWdleCAyKSByZWNvbnNpZGVyIHdoYXQgY2hhcmFjdGVycyBhcmUgY29uc2lkZXJlZCB3aGl0ZXNwYWNlLCBpbmNsdWRpbmcgdW5pY29kZSwgbmJzcCwgZXRjLlxuICAgICAgICAgICAgICAgIGNhc2UgMzIgLyogQ2hhckNvZGUuU3BhY2UgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDkgLyogQ2hhckNvZGUuVGFiICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxNjAgLyogQ2hhckNvZGUuTm9CcmVha1NwYWNlICovOiAvLyAmbmJzcFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgIHRoaXMuX2FkZFRva2VuKDIwIC8qIFRva2VuVHlwZS5FT0YgKi8pO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl90b2tlbnMpO1xuICAgIH1cbiAgICBfbWF0Y2goZXhwZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQXRFbmQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMuX2N1cnJlbnQpICE9PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9hZHZhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5wdXQuY2hhckNvZGVBdCh0aGlzLl9jdXJyZW50KyspO1xuICAgIH1cbiAgICBfcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQXRFbmQoKSA/IDAgLyogQ2hhckNvZGUuTnVsbCAqLyA6IHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5fY3VycmVudCk7XG4gICAgfVxuICAgIF9hZGRUb2tlbih0eXBlKSB7XG4gICAgICAgIHRoaXMuX3Rva2Vucy5wdXNoKHsgdHlwZSwgb2Zmc2V0OiB0aGlzLl9zdGFydCB9KTtcbiAgICB9XG4gICAgX2Vycm9yKGFkZGl0aW9uYWwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgIGNvbnN0IGxleGVtZSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9zdGFydCwgdGhpcy5fY3VycmVudCk7XG4gICAgICAgIGNvbnN0IGVyclRva2VuID0geyB0eXBlOiAxOSAvKiBUb2tlblR5cGUuRXJyb3IgKi8sIG9mZnNldDogdGhpcy5fc3RhcnQsIGxleGVtZSB9O1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaCh7IG9mZnNldCwgbGV4ZW1lLCBhZGRpdGlvbmFsSW5mbzogYWRkaXRpb25hbCB9KTtcbiAgICAgICAgdGhpcy5fdG9rZW5zLnB1c2goZXJyVG9rZW4pO1xuICAgIH1cbiAgICBfc3RyaW5nKCkge1xuICAgICAgICB0aGlzLnN0cmluZ1JlLmxhc3RJbmRleCA9IHRoaXMuX3N0YXJ0O1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMuc3RyaW5nUmUuZXhlYyh0aGlzLl9pbnB1dCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX3N0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbGV4ZW1lID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX3N0YXJ0LCB0aGlzLl9jdXJyZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmQgPSBTY2FubmVyLl9rZXl3b3Jkcy5nZXQobGV4ZW1lKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9rZW4oa2V5d29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b2tlbnMucHVzaCh7IHR5cGU6IDE3IC8qIFRva2VuVHlwZS5TdHIgKi8sIGxleGVtZSwgb2Zmc2V0OiB0aGlzLl9zdGFydCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjYXB0dXJlcyB0aGUgbGV4ZW1lIHdpdGhvdXQgdGhlIGxlYWRpbmcgYW5kIHRyYWlsaW5nICdcbiAgICBfcXVvdGVkU3RyaW5nKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcGVlaygpICE9PSAzOSAvKiBDaGFyQ29kZS5TaW5nbGVRdW90ZSAqLyAmJiAhdGhpcy5faXNBdEVuZCgpKSB7IC8vIFRPRE9AdWx1Z2Jla25hOiBhZGQgc3VwcG9ydCBmb3IgZXNjYXBpbmcgJyA/XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzQXRFbmQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoaGludERpZFlvdUZvcmdldFRvT3Blbk9yQ2xvc2VRdW90ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc3VtZSB0aGUgY2xvc2luZyAnXG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgdGhpcy5fdG9rZW5zLnB1c2goeyB0eXBlOiAxOCAvKiBUb2tlblR5cGUuUXVvdGVkU3RyICovLCBsZXhlbWU6IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9zdGFydCArIDEsIHRoaXMuX2N1cnJlbnQgLSAxKSwgb2Zmc2V0OiB0aGlzLl9zdGFydCArIDEgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICogTGV4aW5nIGEgcmVnZXggZXhwcmVzc2lvbjogLy4uLi9baWdzbXl1XSpcbiAgICAgKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvYmxvYi85MjQ3ZWYxMTVlNjE3ODA1OTgzNzQwYmE3OTVkN2E4MTY0YmFiZjg5L3NyYy9jb21waWxlci9zY2FubmVyLnRzI0wyMTI5LUwyMTgxXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2Ugd2FudCBzbGFzaGVzIHdpdGhpbiBhIHJlZ2V4IHRvIGJlIGVzY2FwZWQsIGUuZy4sIC9maWxlOlxcXFwvXFxcXC9cXFxcLy8gc2hvdWxkIG1hdGNoIGBmaWxlOi8vL2BcbiAgICAgKi9cbiAgICBfcmVnZXgoKSB7XG4gICAgICAgIGxldCBwID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgbGV0IGluRXNjYXBlID0gZmFsc2U7XG4gICAgICAgIGxldCBpbkNoYXJhY3RlckNsYXNzID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAocCA+PSB0aGlzLl9pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gcDtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcihoaW50RGlkWW91Rm9yZ2V0VG9Fc2NhcGVTbGFzaCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2ggPSB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHApO1xuICAgICAgICAgICAgaWYgKGluRXNjYXBlKSB7IC8vIHBhcnNpbmcgYW4gZXNjYXBlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGluRXNjYXBlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gNDcgLyogQ2hhckNvZGUuU2xhc2ggKi8gJiYgIWluQ2hhcmFjdGVyQ2xhc3MpIHsgLy8gZW5kIG9mIHJlZ2V4XG4gICAgICAgICAgICAgICAgcCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDkxIC8qIENoYXJDb2RlLk9wZW5TcXVhcmVCcmFja2V0ICovKSB7XG4gICAgICAgICAgICAgICAgaW5DaGFyYWN0ZXJDbGFzcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gOTIgLyogQ2hhckNvZGUuQmFja3NsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgaW5Fc2NhcGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDkzIC8qIENoYXJDb2RlLkNsb3NlU3F1YXJlQnJhY2tldCAqLykge1xuICAgICAgICAgICAgICAgIGluQ2hhcmFjdGVyQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHArKztcbiAgICAgICAgfVxuICAgICAgICAvLyBDb25zdW1lIGZsYWdzIC8vIFRPRE9AdWx1Z2Jla25hOiB1c2UgcmVnZXggaW5zdGVhZFxuICAgICAgICB3aGlsZSAocCA8IHRoaXMuX2lucHV0Lmxlbmd0aCAmJiBTY2FubmVyLl9yZWdleEZsYWdzLmhhcyh0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHApKSkge1xuICAgICAgICAgICAgcCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSBwO1xuICAgICAgICBjb25zdCBsZXhlbWUgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fc3RhcnQsIHRoaXMuX2N1cnJlbnQpO1xuICAgICAgICB0aGlzLl90b2tlbnMucHVzaCh7IHR5cGU6IDEwIC8qIFRva2VuVHlwZS5SZWdleFN0ciAqLywgbGV4ZW1lLCBvZmZzZXQ6IHRoaXMuX3N0YXJ0IH0pO1xuICAgIH1cbiAgICBfaXNBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQgPj0gdGhpcy5faW5wdXQubGVuZ3RoO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9ldmVudC5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IFJhd0NvbnRleHRLZXkgfSBmcm9tICcuLi8uLi9jb250ZXh0a2V5L2NvbW1vbi9jb250ZXh0a2V5LmpzJztcbmltcG9ydCB7IGNyZWF0ZURlY29yYXRvciB9IGZyb20gJy4uLy4uL2luc3RhbnRpYXRpb24vY29tbW9uL2luc3RhbnRpYXRpb24uanMnO1xuZXhwb3J0IGNvbnN0IElMb2dTZXJ2aWNlID0gY3JlYXRlRGVjb3JhdG9yKCdsb2dTZXJ2aWNlJyk7XG5leHBvcnQgdmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiT2ZmXCJdID0gMF0gPSBcIk9mZlwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiVHJhY2VcIl0gPSAxXSA9IFwiVHJhY2VcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRlYnVnXCJdID0gMl0gPSBcIkRlYnVnXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJbmZvXCJdID0gM10gPSBcIkluZm9cIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5pbmdcIl0gPSA0XSA9IFwiV2FybmluZ1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRXJyb3JcIl0gPSA1XSA9IFwiRXJyb3JcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG5leHBvcnQgY29uc3QgREVGQVVMVF9MT0dfTEVWRUwgPSBMb2dMZXZlbC5JbmZvO1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0TG9nZ2VyIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBERUZBVUxUX0xPR19MRVZFTDtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VMb2dMZXZlbCA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBFbWl0dGVyKCkpO1xuICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlTG9nTGV2ZWwgPSB0aGlzLl9vbkRpZENoYW5nZUxvZ0xldmVsLmV2ZW50O1xuICAgIH1cbiAgICBzZXRMZXZlbChsZXZlbCkge1xuICAgICAgICBpZiAodGhpcy5sZXZlbCAhPT0gbGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlTG9nTGV2ZWwuZmlyZSh0aGlzLmxldmVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWw7XG4gICAgfVxuICAgIGNoZWNrTG9nTGV2ZWwobGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWwgIT09IExvZ0xldmVsLk9mZiAmJiB0aGlzLmxldmVsIDw9IGxldmVsO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb25zb2xlTG9nZ2VyIGV4dGVuZHMgQWJzdHJhY3RMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvZ0xldmVsID0gREVGQVVMVF9MT0dfTEVWRUwsIHVzZUNvbG9ycyA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG4gICAgICAgIHRoaXMuc2V0TGV2ZWwobG9nTGV2ZWwpO1xuICAgIH1cbiAgICB0cmFjZShtZXNzYWdlLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrTG9nTGV2ZWwoTG9nTGV2ZWwuVHJhY2UpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VDb2xvcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnJWNUUkFDRScsICdjb2xvcjogIzg4OCcsIG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVidWcobWVzc2FnZSwgLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5jaGVja0xvZ0xldmVsKExvZ0xldmVsLkRlYnVnKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlQ29sb3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVjREVCVUcnLCAnYmFja2dyb3VuZDogI2VlZTsgY29sb3I6ICM4ODgnLCBtZXNzYWdlLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGluZm8obWVzc2FnZSwgLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5jaGVja0xvZ0xldmVsKExvZ0xldmVsLkluZm8pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VDb2xvcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnJWMgSU5GTycsICdjb2xvcjogIzMzZicsIG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2FybihtZXNzYWdlLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrTG9nTGV2ZWwoTG9nTGV2ZWwuV2FybmluZykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZUNvbG9ycykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCclYyBXQVJOJywgJ2NvbG9yOiAjOTkzJywgbWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvcihtZXNzYWdlLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrTG9nTGV2ZWwoTG9nTGV2ZWwuRXJyb3IpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VDb2xvcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnJWMgIEVSUicsICdjb2xvcjogI2YzMycsIG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNdWx0aXBsZXhMb2dnZXIgZXh0ZW5kcyBBYnN0cmFjdExvZ2dlciB7XG4gICAgY29uc3RydWN0b3IobG9nZ2Vycykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvZ2dlcnMgPSBsb2dnZXJzO1xuICAgICAgICBpZiAobG9nZ2Vycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGV2ZWwobG9nZ2Vyc1swXS5nZXRMZXZlbCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRMZXZlbChsZXZlbCkge1xuICAgICAgICBmb3IgKGNvbnN0IGxvZ2dlciBvZiB0aGlzLmxvZ2dlcnMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5zZXRMZXZlbChsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc2V0TGV2ZWwobGV2ZWwpO1xuICAgIH1cbiAgICB0cmFjZShtZXNzYWdlLCAuLi5hcmdzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbG9nZ2VyIG9mIHRoaXMubG9nZ2Vycykge1xuICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlYnVnKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBsb2dnZXIgb2YgdGhpcy5sb2dnZXJzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5mbyhtZXNzYWdlLCAuLi5hcmdzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbG9nZ2VyIG9mIHRoaXMubG9nZ2Vycykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8obWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2FybihtZXNzYWdlLCAuLi5hcmdzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbG9nZ2VyIG9mIHRoaXMubG9nZ2Vycykge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4obWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXJyb3IobWVzc2FnZSwgLi4uYXJncykge1xuICAgICAgICBmb3IgKGNvbnN0IGxvZ2dlciBvZiB0aGlzLmxvZ2dlcnMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtZXNzYWdlLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGxvZ2dlciBvZiB0aGlzLmxvZ2dlcnMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBMb2dMZXZlbFRvU3RyaW5nKGxvZ0xldmVsKSB7XG4gICAgc3dpdGNoIChsb2dMZXZlbCkge1xuICAgICAgICBjYXNlIExvZ0xldmVsLlRyYWNlOiByZXR1cm4gJ3RyYWNlJztcbiAgICAgICAgY2FzZSBMb2dMZXZlbC5EZWJ1ZzogcmV0dXJuICdkZWJ1Zyc7XG4gICAgICAgIGNhc2UgTG9nTGV2ZWwuSW5mbzogcmV0dXJuICdpbmZvJztcbiAgICAgICAgY2FzZSBMb2dMZXZlbC5XYXJuaW5nOiByZXR1cm4gJ3dhcm4nO1xuICAgICAgICBjYXNlIExvZ0xldmVsLkVycm9yOiByZXR1cm4gJ2Vycm9yJztcbiAgICAgICAgY2FzZSBMb2dMZXZlbC5PZmY6IHJldHVybiAnb2ZmJztcbiAgICB9XG59XG4vLyBDb250ZXh0c1xuZXhwb3J0IGNvbnN0IENPTlRFWFRfTE9HX0xFVkVMID0gbmV3IFJhd0NvbnRleHRLZXkoJ2xvZ0xldmVsJywgTG9nTGV2ZWxUb1N0cmluZyhMb2dMZXZlbC5JbmZvKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=