"use strict";
(self["webpackChunkpylinac_yaml_editor"] = self["webpackChunkpylinac_yaml_editor"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensProviderStyling_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   countEOL: () => (/* binding */ countEOL)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function countEOL(text) {
    let eolCount = 0;
    let firstLineLength = 0;
    let lastLineStart = 0;
    let eol = 0 /* StringEOL.Unknown */;
    for (let i = 0, len = text.length; i < len; i++) {
        const chr = text.charCodeAt(i);
        if (chr === 13 /* CharCode.CarriageReturn */) {
            if (eolCount === 0) {
                firstLineLength = i;
            }
            eolCount++;
            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {
                // \r\n... case
                eol |= 2 /* StringEOL.CRLF */;
                i++; // skip \n
            }
            else {
                // \r... case
                eol |= 3 /* StringEOL.Invalid */;
            }
            lastLineStart = i + 1;
        }
        else if (chr === 10 /* CharCode.LineFeed */) {
            // \n... case
            eol |= 1 /* StringEOL.LF */;
            if (eolCount === 0) {
                firstLineLength = i;
            }
            eolCount++;
            lastLineStart = i + 1;
        }
    }
    if (eolCount === 0) {
        firstLineLength = text.length;
    }
    return [eolCount, firstLineLength, text.length - lastLineStart, eol];
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TokenMetadata: () => (/* binding */ TokenMetadata)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 */
class TokenMetadata {
    static getLanguageId(metadata) {
        return (metadata & 255 /* MetadataConsts.LANGUAGEID_MASK */) >>> 0 /* MetadataConsts.LANGUAGEID_OFFSET */;
    }
    static getTokenType(metadata) {
        return (metadata & 768 /* MetadataConsts.TOKEN_TYPE_MASK */) >>> 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */;
    }
    static containsBalancedBrackets(metadata) {
        return (metadata & 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) !== 0;
    }
    static getFontStyle(metadata) {
        return (metadata & 30720 /* MetadataConsts.FONT_STYLE_MASK */) >>> 11 /* MetadataConsts.FONT_STYLE_OFFSET */;
    }
    static getForeground(metadata) {
        return (metadata & 16744448 /* MetadataConsts.FOREGROUND_MASK */) >>> 15 /* MetadataConsts.FOREGROUND_OFFSET */;
    }
    static getBackground(metadata) {
        return (metadata & 4278190080 /* MetadataConsts.BACKGROUND_MASK */) >>> 24 /* MetadataConsts.BACKGROUND_OFFSET */;
    }
    static getClassNameFromMetadata(metadata) {
        const foreground = this.getForeground(metadata);
        let className = 'mtk' + foreground;
        const fontStyle = this.getFontStyle(metadata);
        if (fontStyle & 1 /* FontStyle.Italic */) {
            className += ' mtki';
        }
        if (fontStyle & 2 /* FontStyle.Bold */) {
            className += ' mtkb';
        }
        if (fontStyle & 4 /* FontStyle.Underline */) {
            className += ' mtku';
        }
        if (fontStyle & 8 /* FontStyle.Strikethrough */) {
            className += ' mtks';
        }
        return className;
    }
    static getInlineStyleFromMetadata(metadata, colorMap) {
        const foreground = this.getForeground(metadata);
        const fontStyle = this.getFontStyle(metadata);
        let result = `color: ${colorMap[foreground]};`;
        if (fontStyle & 1 /* FontStyle.Italic */) {
            result += 'font-style: italic;';
        }
        if (fontStyle & 2 /* FontStyle.Bold */) {
            result += 'font-weight: bold;';
        }
        let textDecoration = '';
        if (fontStyle & 4 /* FontStyle.Underline */) {
            textDecoration += ' underline';
        }
        if (fontStyle & 8 /* FontStyle.Strikethrough */) {
            textDecoration += ' line-through';
        }
        if (textDecoration) {
            result += `text-decoration:${textDecoration};`;
        }
        return result;
    }
    static getPresentationFromMetadata(metadata) {
        const foreground = this.getForeground(metadata);
        const fontStyle = this.getFontStyle(metadata);
        return {
            foreground: foreground,
            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),
            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),
            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),
            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */),
        };
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/language.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/language.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ILanguageService: () => (/* binding */ ILanguageService)
/* harmony export */ });
/* harmony import */ var _platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/instantiation/common/instantiation.js */ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const ILanguageService = (0,_platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_0__.createDecorator)('languageService');


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SemanticTokensProviderStyling: () => (/* binding */ SemanticTokensProviderStyling),
/* harmony export */   toMultilineTokens2: () => (/* binding */ toMultilineTokens2)
/* harmony export */ });
/* harmony import */ var _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../encodedTokenAttributes.js */ "./node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js");
/* harmony import */ var _platform_theme_common_themeService_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../platform/theme/common/themeService.js */ "./node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js");
/* harmony import */ var _platform_log_common_log_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../platform/log/common/log.js */ "./node_modules/monaco-editor/esm/vs/platform/log/common/log.js");
/* harmony import */ var _tokens_sparseMultilineTokens_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tokens/sparseMultilineTokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js");
/* harmony import */ var _languages_language_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../languages/language.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/language.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};





const ENABLE_TRACE = false;
let SemanticTokensProviderStyling = class SemanticTokensProviderStyling {
    constructor(_legend, _themeService, _languageService, _logService) {
        this._legend = _legend;
        this._themeService = _themeService;
        this._languageService = _languageService;
        this._logService = _logService;
        this._hasWarnedOverlappingTokens = false;
        this._hasWarnedInvalidLengthTokens = false;
        this._hasWarnedInvalidEditStart = false;
        this._hashTable = new HashTable();
    }
    getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {
        const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);
        const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);
        let metadata;
        if (entry) {
            metadata = entry.metadata;
            if (ENABLE_TRACE && this._logService.getLevel() === _platform_log_common_log_js__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace) {
                this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${_encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getForeground(metadata)}, fontStyle ${_encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getFontStyle(metadata).toString(2)}`);
            }
        }
        else {
            let tokenType = this._legend.tokenTypes[tokenTypeIndex];
            const tokenModifiers = [];
            if (tokenType) {
                let modifierSet = tokenModifierSet;
                for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {
                    if (modifierSet & 1) {
                        tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);
                    }
                    modifierSet = modifierSet >> 1;
                }
                if (ENABLE_TRACE && modifierSet > 0 && this._logService.getLevel() === _platform_log_common_log_js__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace) {
                    this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);
                    tokenModifiers.push('not-in-legend');
                }
                const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);
                if (typeof tokenStyle === 'undefined') {
                    metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;
                }
                else {
                    metadata = 0;
                    if (typeof tokenStyle.italic !== 'undefined') {
                        const italicBit = (tokenStyle.italic ? 1 /* FontStyle.Italic */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;
                        metadata |= italicBit | 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */;
                    }
                    if (typeof tokenStyle.bold !== 'undefined') {
                        const boldBit = (tokenStyle.bold ? 2 /* FontStyle.Bold */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;
                        metadata |= boldBit | 2 /* MetadataConsts.SEMANTIC_USE_BOLD */;
                    }
                    if (typeof tokenStyle.underline !== 'undefined') {
                        const underlineBit = (tokenStyle.underline ? 4 /* FontStyle.Underline */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;
                        metadata |= underlineBit | 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */;
                    }
                    if (typeof tokenStyle.strikethrough !== 'undefined') {
                        const strikethroughBit = (tokenStyle.strikethrough ? 8 /* FontStyle.Strikethrough */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;
                        metadata |= strikethroughBit | 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */;
                    }
                    if (tokenStyle.foreground) {
                        const foregroundBits = (tokenStyle.foreground) << 15 /* MetadataConsts.FOREGROUND_OFFSET */;
                        metadata |= foregroundBits | 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */;
                    }
                    if (metadata === 0) {
                        // Nothing!
                        metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;
                    }
                }
            }
            else {
                if (ENABLE_TRACE && this._logService.getLevel() === _platform_log_common_log_js__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace) {
                    this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);
                }
                metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;
                tokenType = 'not-in-legend';
            }
            this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);
            if (ENABLE_TRACE && this._logService.getLevel() === _platform_log_common_log_js__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace) {
                this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${_encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getForeground(metadata)}, fontStyle ${_encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getFontStyle(metadata).toString(2)}`);
            }
        }
        return metadata;
    }
    warnOverlappingSemanticTokens(lineNumber, startColumn) {
        if (!this._hasWarnedOverlappingTokens) {
            this._hasWarnedOverlappingTokens = true;
            this._logService.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);
        }
    }
    warnInvalidLengthSemanticTokens(lineNumber, startColumn) {
        if (!this._hasWarnedInvalidLengthTokens) {
            this._hasWarnedInvalidLengthTokens = true;
            this._logService.warn(`Semantic token with invalid length detected at lineNumber ${lineNumber}, column ${startColumn}`);
        }
    }
    warnInvalidEditStart(previousResultId, resultId, editIndex, editStart, maxExpectedStart) {
        if (!this._hasWarnedInvalidEditStart) {
            this._hasWarnedInvalidEditStart = true;
            this._logService.warn(`Invalid semantic tokens edit detected (previousResultId: ${previousResultId}, resultId: ${resultId}) at edit #${editIndex}: The provided start offset ${editStart} is outside the previous data (length ${maxExpectedStart}).`);
        }
    }
};
SemanticTokensProviderStyling = __decorate([
    __param(1, _platform_theme_common_themeService_js__WEBPACK_IMPORTED_MODULE_1__.IThemeService),
    __param(2, _languages_language_js__WEBPACK_IMPORTED_MODULE_4__.ILanguageService),
    __param(3, _platform_log_common_log_js__WEBPACK_IMPORTED_MODULE_2__.ILogService)
], SemanticTokensProviderStyling);

function toMultilineTokens2(tokens, styling, languageId) {
    const srcData = tokens.data;
    const tokenCount = (tokens.data.length / 5) | 0;
    const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* SemanticColoringConstants.DesiredMaxAreas */), 400 /* SemanticColoringConstants.DesiredTokensPerArea */);
    const result = [];
    let tokenIndex = 0;
    let lastLineNumber = 1;
    let lastStartCharacter = 0;
    while (tokenIndex < tokenCount) {
        const tokenStartIndex = tokenIndex;
        let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);
        // Keep tokens on the same line in the same area...
        if (tokenEndIndex < tokenCount) {
            let smallTokenEndIndex = tokenEndIndex;
            while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {
                smallTokenEndIndex--;
            }
            if (smallTokenEndIndex - 1 === tokenStartIndex) {
                // there are so many tokens on this line that our area would be empty, we must now go right
                let bigTokenEndIndex = tokenEndIndex;
                while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {
                    bigTokenEndIndex++;
                }
                tokenEndIndex = bigTokenEndIndex;
            }
            else {
                tokenEndIndex = smallTokenEndIndex;
            }
        }
        let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);
        let destOffset = 0;
        let areaLine = 0;
        let prevLineNumber = 0;
        let prevEndCharacter = 0;
        while (tokenIndex < tokenEndIndex) {
            const srcOffset = 5 * tokenIndex;
            const deltaLine = srcData[srcOffset];
            const deltaCharacter = srcData[srcOffset + 1];
            // Casting both `lineNumber`, `startCharacter` and `endCharacter` here to uint32 using `|0`
            // to validate below with the actual values that will be inserted in the Uint32Array result
            const lineNumber = (lastLineNumber + deltaLine) | 0;
            const startCharacter = (deltaLine === 0 ? (lastStartCharacter + deltaCharacter) | 0 : deltaCharacter);
            const length = srcData[srcOffset + 2];
            const endCharacter = (startCharacter + length) | 0;
            const tokenTypeIndex = srcData[srcOffset + 3];
            const tokenModifierSet = srcData[srcOffset + 4];
            if (endCharacter <= startCharacter) {
                // this token is invalid (most likely a negative length casted to uint32)
                styling.warnInvalidLengthSemanticTokens(lineNumber, startCharacter + 1);
            }
            else if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {
                // this token overlaps with the previous token
                styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);
            }
            else {
                const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);
                if (metadata !== 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */) {
                    if (areaLine === 0) {
                        areaLine = lineNumber;
                    }
                    destData[destOffset] = lineNumber - areaLine;
                    destData[destOffset + 1] = startCharacter;
                    destData[destOffset + 2] = endCharacter;
                    destData[destOffset + 3] = metadata;
                    destOffset += 4;
                    prevLineNumber = lineNumber;
                    prevEndCharacter = endCharacter;
                }
            }
            lastLineNumber = lineNumber;
            lastStartCharacter = startCharacter;
            tokenIndex++;
        }
        if (destOffset !== destData.length) {
            destData = destData.subarray(0, destOffset);
        }
        const tokens = _tokens_sparseMultilineTokens_js__WEBPACK_IMPORTED_MODULE_3__.SparseMultilineTokens.create(areaLine, destData);
        result.push(tokens);
    }
    return result;
}
class HashTableEntry {
    constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
        this.tokenTypeIndex = tokenTypeIndex;
        this.tokenModifierSet = tokenModifierSet;
        this.languageId = languageId;
        this.metadata = metadata;
        this.next = null;
    }
}
class HashTable {
    static { this._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143]; }
    constructor() {
        this._elementsCount = 0;
        this._currentLengthIndex = 0;
        this._currentLength = HashTable._SIZES[this._currentLengthIndex];
        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
        this._elements = [];
        HashTable._nullOutEntries(this._elements, this._currentLength);
    }
    static _nullOutEntries(entries, length) {
        for (let i = 0; i < length; i++) {
            entries[i] = null;
        }
    }
    _hash2(n1, n2) {
        return (((n1 << 5) - n1) + n2) | 0; // n1 * 31 + n2, keep as int32
    }
    _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {
        return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;
    }
    get(tokenTypeIndex, tokenModifierSet, languageId) {
        const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);
        let p = this._elements[hash];
        while (p) {
            if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {
                return p;
            }
            p = p.next;
        }
        return null;
    }
    add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
        this._elementsCount++;
        if (this._growCount !== 0 && this._elementsCount >= this._growCount) {
            // expand!
            const oldElements = this._elements;
            this._currentLengthIndex++;
            this._currentLength = HashTable._SIZES[this._currentLengthIndex];
            this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
            this._elements = [];
            HashTable._nullOutEntries(this._elements, this._currentLength);
            for (const first of oldElements) {
                let p = first;
                while (p) {
                    const oldNext = p.next;
                    p.next = null;
                    this._add(p);
                    p = oldNext;
                }
            }
        }
        this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));
    }
    _add(element) {
        const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);
        element.next = this._elements[hash];
        this._elements[hash] = element;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SparseLineTokens: () => (/* binding */ SparseLineTokens),
/* harmony export */   SparseMultilineTokens: () => (/* binding */ SparseMultilineTokens)
/* harmony export */ });
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _core_eolCounter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/eolCounter.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



/**
 * Represents sparse tokens over a contiguous range of lines.
 */
class SparseMultilineTokens {
    static create(startLineNumber, tokens) {
        return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));
    }
    /**
     * (Inclusive) start line number for these tokens.
     */
    get startLineNumber() {
        return this._startLineNumber;
    }
    /**
     * (Inclusive) end line number for these tokens.
     */
    get endLineNumber() {
        return this._endLineNumber;
    }
    constructor(startLineNumber, tokens) {
        this._startLineNumber = startLineNumber;
        this._tokens = tokens;
        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
    }
    toString() {
        return this._tokens.toString(this._startLineNumber);
    }
    _updateEndLineNumber() {
        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
    }
    isEmpty() {
        return this._tokens.isEmpty();
    }
    getLineTokens(lineNumber) {
        if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {
            return this._tokens.getLineTokens(lineNumber - this._startLineNumber);
        }
        return null;
    }
    getRange() {
        const deltaRange = this._tokens.getRange();
        if (!deltaRange) {
            return deltaRange;
        }
        return new _core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);
    }
    removeTokens(range) {
        const startLineIndex = range.startLineNumber - this._startLineNumber;
        const endLineIndex = range.endLineNumber - this._startLineNumber;
        this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);
        this._updateEndLineNumber();
    }
    split(range) {
        // split tokens to two:
        // a) all the tokens before `range`
        // b) all the tokens after `range`
        const startLineIndex = range.startLineNumber - this._startLineNumber;
        const endLineIndex = range.endLineNumber - this._startLineNumber;
        const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);
        return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];
    }
    applyEdit(range, text) {
        const [eolCount, firstLineLength, lastLineLength] = (0,_core_eolCounter_js__WEBPACK_IMPORTED_MODULE_2__.countEOL)(text);
        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* CharCode.Null */);
    }
    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {
        this._acceptDeleteRange(range);
        this._acceptInsertText(new _core_position_js__WEBPACK_IMPORTED_MODULE_0__.Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);
        this._updateEndLineNumber();
    }
    _acceptDeleteRange(range) {
        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
            // Nothing to delete
            return;
        }
        const firstLineIndex = range.startLineNumber - this._startLineNumber;
        const lastLineIndex = range.endLineNumber - this._startLineNumber;
        if (lastLineIndex < 0) {
            // this deletion occurs entirely before this block, so we only need to adjust line numbers
            const deletedLinesCount = lastLineIndex - firstLineIndex;
            this._startLineNumber -= deletedLinesCount;
            return;
        }
        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();
        if (firstLineIndex >= tokenMaxDeltaLine + 1) {
            // this deletion occurs entirely after this block, so there is nothing to do
            return;
        }
        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {
            // this deletion completely encompasses this block
            this._startLineNumber = 0;
            this._tokens.clear();
            return;
        }
        if (firstLineIndex < 0) {
            const deletedBefore = -firstLineIndex;
            this._startLineNumber -= deletedBefore;
            this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);
        }
        else {
            this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);
        }
    }
    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {
        if (eolCount === 0 && firstLineLength === 0) {
            // Nothing to insert
            return;
        }
        const lineIndex = position.lineNumber - this._startLineNumber;
        if (lineIndex < 0) {
            // this insertion occurs before this block, so we only need to adjust line numbers
            this._startLineNumber += eolCount;
            return;
        }
        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();
        if (lineIndex >= tokenMaxDeltaLine + 1) {
            // this insertion occurs after this block, so there is nothing to do
            return;
        }
        this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);
    }
}
class SparseMultilineTokensStorage {
    constructor(tokens) {
        this._tokens = tokens;
        this._tokenCount = tokens.length / 4;
    }
    toString(startLineNumber) {
        const pieces = [];
        for (let i = 0; i < this._tokenCount; i++) {
            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);
        }
        return `[${pieces.join(',')}]`;
    }
    getMaxDeltaLine() {
        const tokenCount = this._getTokenCount();
        if (tokenCount === 0) {
            return -1;
        }
        return this._getDeltaLine(tokenCount - 1);
    }
    getRange() {
        const tokenCount = this._getTokenCount();
        if (tokenCount === 0) {
            return null;
        }
        const startChar = this._getStartCharacter(0);
        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);
        const endChar = this._getEndCharacter(tokenCount - 1);
        return new _core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range(0, startChar + 1, maxDeltaLine, endChar + 1);
    }
    _getTokenCount() {
        return this._tokenCount;
    }
    _getDeltaLine(tokenIndex) {
        return this._tokens[4 * tokenIndex];
    }
    _getStartCharacter(tokenIndex) {
        return this._tokens[4 * tokenIndex + 1];
    }
    _getEndCharacter(tokenIndex) {
        return this._tokens[4 * tokenIndex + 2];
    }
    isEmpty() {
        return (this._getTokenCount() === 0);
    }
    getLineTokens(deltaLine) {
        let low = 0;
        let high = this._getTokenCount() - 1;
        while (low < high) {
            const mid = low + Math.floor((high - low) / 2);
            const midDeltaLine = this._getDeltaLine(mid);
            if (midDeltaLine < deltaLine) {
                low = mid + 1;
            }
            else if (midDeltaLine > deltaLine) {
                high = mid - 1;
            }
            else {
                let min = mid;
                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {
                    min--;
                }
                let max = mid;
                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {
                    max++;
                }
                return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));
            }
        }
        if (this._getDeltaLine(low) === deltaLine) {
            return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));
        }
        return null;
    }
    clear() {
        this._tokenCount = 0;
    }
    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {
        const tokens = this._tokens;
        const tokenCount = this._tokenCount;
        let newTokenCount = 0;
        let hasDeletedTokens = false;
        let firstDeltaLine = 0;
        for (let i = 0; i < tokenCount; i++) {
            const srcOffset = 4 * i;
            const tokenDeltaLine = tokens[srcOffset];
            const tokenStartCharacter = tokens[srcOffset + 1];
            const tokenEndCharacter = tokens[srcOffset + 2];
            const tokenMetadata = tokens[srcOffset + 3];
            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))
                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {
                hasDeletedTokens = true;
            }
            else {
                if (newTokenCount === 0) {
                    firstDeltaLine = tokenDeltaLine;
                }
                if (hasDeletedTokens) {
                    // must move the token to the left
                    const destOffset = 4 * newTokenCount;
                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;
                    tokens[destOffset + 1] = tokenStartCharacter;
                    tokens[destOffset + 2] = tokenEndCharacter;
                    tokens[destOffset + 3] = tokenMetadata;
                }
                newTokenCount++;
            }
        }
        this._tokenCount = newTokenCount;
        return firstDeltaLine;
    }
    split(startDeltaLine, startChar, endDeltaLine, endChar) {
        const tokens = this._tokens;
        const tokenCount = this._tokenCount;
        const aTokens = [];
        const bTokens = [];
        let destTokens = aTokens;
        let destOffset = 0;
        let destFirstDeltaLine = 0;
        for (let i = 0; i < tokenCount; i++) {
            const srcOffset = 4 * i;
            const tokenDeltaLine = tokens[srcOffset];
            const tokenStartCharacter = tokens[srcOffset + 1];
            const tokenEndCharacter = tokens[srcOffset + 2];
            const tokenMetadata = tokens[srcOffset + 3];
            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {
                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {
                    // this token is touching the range
                    continue;
                }
                else {
                    // this token is after the range
                    if (destTokens !== bTokens) {
                        // this token is the first token after the range
                        destTokens = bTokens;
                        destOffset = 0;
                        destFirstDeltaLine = tokenDeltaLine;
                    }
                }
            }
            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;
            destTokens[destOffset++] = tokenStartCharacter;
            destTokens[destOffset++] = tokenEndCharacter;
            destTokens[destOffset++] = tokenMetadata;
        }
        return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];
    }
    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {
        // This is a bit complex, here are the cases I used to think about this:
        //
        // 1. The token starts before the deletion range
        // 1a. The token is completely before the deletion range
        //               -----------
        //                          xxxxxxxxxxx
        // 1b. The token starts before, the deletion range ends after the token
        //               -----------
        //                      xxxxxxxxxxx
        // 1c. The token starts before, the deletion range ends precisely with the token
        //               ---------------
        //                      xxxxxxxx
        // 1d. The token starts before, the deletion range is inside the token
        //               ---------------
        //                    xxxxx
        //
        // 2. The token starts at the same position with the deletion range
        // 2a. The token starts at the same position, and ends inside the deletion range
        //               -------
        //               xxxxxxxxxxx
        // 2b. The token starts at the same position, and ends at the same position as the deletion range
        //               ----------
        //               xxxxxxxxxx
        // 2c. The token starts at the same position, and ends after the deletion range
        //               -------------
        //               xxxxxxx
        //
        // 3. The token starts inside the deletion range
        // 3a. The token is inside the deletion range
        //                -------
        //             xxxxxxxxxxxxx
        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range
        //                ----------
        //             xxxxxxxxxxxxx
        // 3c. The token starts inside the deletion range, and ends after the deletion range
        //                ------------
        //             xxxxxxxxxxx
        //
        // 4. The token starts after the deletion range
        //                  -----------
        //          xxxxxxxx
        //
        const tokens = this._tokens;
        const tokenCount = this._tokenCount;
        const deletedLineCount = (endDeltaLine - startDeltaLine);
        let newTokenCount = 0;
        let hasDeletedTokens = false;
        for (let i = 0; i < tokenCount; i++) {
            const srcOffset = 4 * i;
            let tokenDeltaLine = tokens[srcOffset];
            let tokenStartCharacter = tokens[srcOffset + 1];
            let tokenEndCharacter = tokens[srcOffset + 2];
            const tokenMetadata = tokens[srcOffset + 3];
            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {
                // 1a. The token is completely before the deletion range
                // => nothing to do
                newTokenCount++;
                continue;
            }
            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {
                // 1b, 1c, 1d
                // => the token survives, but it needs to shrink
                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {
                    // 1d. The token starts before, the deletion range is inside the token
                    // => the token shrinks by the deletion character count
                    tokenEndCharacter -= (endCharacter - startCharacter);
                }
                else {
                    // 1b. The token starts before, the deletion range ends after the token
                    // 1c. The token starts before, the deletion range ends precisely with the token
                    // => the token shrinks its ending to the deletion start
                    tokenEndCharacter = startCharacter;
                }
            }
            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {
                // 2a, 2b, 2c
                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {
                    // 2c. The token starts at the same position, and ends after the deletion range
                    // => the token shrinks by the deletion character count
                    tokenEndCharacter -= (endCharacter - startCharacter);
                }
                else {
                    // 2a. The token starts at the same position, and ends inside the deletion range
                    // 2b. The token starts at the same position, and ends at the same position as the deletion range
                    // => the token is deleted
                    hasDeletedTokens = true;
                    continue;
                }
            }
            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {
                // 3a, 3b, 3c
                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {
                    // 3c. The token starts inside the deletion range, and ends after the deletion range
                    // => the token moves to continue right after the deletion
                    tokenDeltaLine = startDeltaLine;
                    tokenStartCharacter = startCharacter;
                    tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);
                }
                else {
                    // 3a. The token is inside the deletion range
                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range
                    // => the token is deleted
                    hasDeletedTokens = true;
                    continue;
                }
            }
            else if (tokenDeltaLine > endDeltaLine) {
                // 4. (partial) The token starts after the deletion range, on a line below...
                if (deletedLineCount === 0 && !hasDeletedTokens) {
                    // early stop, there is no need to walk all the tokens and do nothing...
                    newTokenCount = tokenCount;
                    break;
                }
                tokenDeltaLine -= deletedLineCount;
            }
            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {
                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs
                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {
                    tokenStartCharacter += horizontalShiftForFirstLineTokens;
                    tokenEndCharacter += horizontalShiftForFirstLineTokens;
                }
                tokenDeltaLine -= deletedLineCount;
                tokenStartCharacter -= (endCharacter - startCharacter);
                tokenEndCharacter -= (endCharacter - startCharacter);
            }
            else {
                throw new Error(`Not possible!`);
            }
            const destOffset = 4 * newTokenCount;
            tokens[destOffset] = tokenDeltaLine;
            tokens[destOffset + 1] = tokenStartCharacter;
            tokens[destOffset + 2] = tokenEndCharacter;
            tokens[destOffset + 3] = tokenMetadata;
            newTokenCount++;
        }
        this._tokenCount = newTokenCount;
    }
    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {
        // Here are the cases I used to think about this:
        //
        // 1. The token is completely before the insertion point
        //            -----------   |
        // 2. The token ends precisely at the insertion point
        //            -----------|
        // 3. The token contains the insertion point
        //            -----|------
        // 4. The token starts precisely at the insertion point
        //            |-----------
        // 5. The token is completely after the insertion point
        //            |   -----------
        //
        const isInsertingPreciselyOneWordCharacter = (eolCount === 0
            && firstLineLength === 1
            && ((firstCharCode >= 48 /* CharCode.Digit0 */ && firstCharCode <= 57 /* CharCode.Digit9 */)
                || (firstCharCode >= 65 /* CharCode.A */ && firstCharCode <= 90 /* CharCode.Z */)
                || (firstCharCode >= 97 /* CharCode.a */ && firstCharCode <= 122 /* CharCode.z */)));
        const tokens = this._tokens;
        const tokenCount = this._tokenCount;
        for (let i = 0; i < tokenCount; i++) {
            const offset = 4 * i;
            let tokenDeltaLine = tokens[offset];
            let tokenStartCharacter = tokens[offset + 1];
            let tokenEndCharacter = tokens[offset + 2];
            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {
                // 1. The token is completely before the insertion point
                // => nothing to do
                continue;
            }
            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {
                // 2. The token ends precisely at the insertion point
                // => expand the end character only if inserting precisely one character that is a word character
                if (isInsertingPreciselyOneWordCharacter) {
                    tokenEndCharacter += 1;
                }
                else {
                    continue;
                }
            }
            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {
                // 3. The token contains the insertion point
                if (eolCount === 0) {
                    // => just expand the end character
                    tokenEndCharacter += firstLineLength;
                }
                else {
                    // => cut off the token
                    tokenEndCharacter = character;
                }
            }
            else {
                // 4. or 5.
                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {
                    // 4. The token starts precisely at the insertion point
                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character
                    // => otherwise behave as in case 5.
                    if (isInsertingPreciselyOneWordCharacter) {
                        continue;
                    }
                }
                // => the token must move and keep its size constant
                if (tokenDeltaLine === deltaLine) {
                    tokenDeltaLine += eolCount;
                    // this token is on the line where the insertion is taking place
                    if (eolCount === 0) {
                        tokenStartCharacter += firstLineLength;
                        tokenEndCharacter += firstLineLength;
                    }
                    else {
                        const tokenLength = tokenEndCharacter - tokenStartCharacter;
                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);
                        tokenEndCharacter = tokenStartCharacter + tokenLength;
                    }
                }
                else {
                    tokenDeltaLine += eolCount;
                }
            }
            tokens[offset] = tokenDeltaLine;
            tokens[offset + 1] = tokenStartCharacter;
            tokens[offset + 2] = tokenEndCharacter;
        }
    }
}
class SparseLineTokens {
    constructor(tokens) {
        this._tokens = tokens;
    }
    getCount() {
        return this._tokens.length / 4;
    }
    getStartCharacter(tokenIndex) {
        return this._tokens[4 * tokenIndex + 1];
    }
    getEndCharacter(tokenIndex) {
        return this._tokens[4 * tokenIndex + 2];
    }
    getMetadata(tokenIndex) {
        return this._tokens[4 * tokenIndex + 3];
    }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19zZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZ19qcy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQzBGO0FBQ25GLHlCQUF5QixnR0FBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTC9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQUksSUFBSSxTQUFJO0FBQzlCO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0EsZUFBZSxTQUFJLElBQUksU0FBSTtBQUMzQixvQ0FBb0M7QUFDcEM7QUFDNkQ7QUFDa0I7QUFDSDtBQUNEO0FBQ2Y7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlFQUFRO0FBQ3hFLGlGQUFpRixnQkFBZ0IsSUFBSSxpQkFBaUIsZUFBZSxxRUFBYSx5QkFBeUIsY0FBYyxxRUFBYSxvQ0FBb0M7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUVBQXVFO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsaUVBQVE7QUFDL0YsMkdBQTJHLDhCQUE4QixjQUFjLDRDQUE0QztBQUNuTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGlFQUFRO0FBQzVFLHVHQUF1RyxnQkFBZ0IsY0FBYyx3Q0FBd0M7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxpRUFBUTtBQUN4RSx3RUFBd0UsZ0JBQWdCLEdBQUcsVUFBVSxNQUFNLGtCQUFrQixHQUFHLHlCQUF5QixnQkFBZ0IscUVBQWEseUJBQXlCLGNBQWMscUVBQWEsb0NBQW9DO0FBQzlRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLFdBQVcsV0FBVyxZQUFZO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsV0FBVyxXQUFXLFlBQVk7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixpQkFBaUIsY0FBYyxTQUFTLGFBQWEsVUFBVSw4QkFBOEIsV0FBVyx1Q0FBdUMsaUJBQWlCO0FBQzlQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRkFBYTtBQUM1QixlQUFlLG9FQUFnQjtBQUMvQixlQUFlLG9FQUFXO0FBQzFCO0FBQ3lDO0FBQ2xDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1GQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDblJBO0FBQ0E7QUFDQTtBQUNBO0FBQytDO0FBQ047QUFDUTtBQUNqRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNkRBQVE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdURBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDLDRCQUE0Qix3Q0FBd0MsR0FBRywyQkFBMkIsR0FBRyx5QkFBeUI7QUFDOUg7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9lb2xDb3VudGVyLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9lbmNvZGVkVG9rZW5BdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMvbGFuZ3VhZ2UuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3NlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi90b2tlbnMvc3BhcnNlTXVsdGlsaW5lVG9rZW5zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGNvdW50RU9MKHRleHQpIHtcbiAgICBsZXQgZW9sQ291bnQgPSAwO1xuICAgIGxldCBmaXJzdExpbmVMZW5ndGggPSAwO1xuICAgIGxldCBsYXN0TGluZVN0YXJ0ID0gMDtcbiAgICBsZXQgZW9sID0gMCAvKiBTdHJpbmdFT0wuVW5rbm93biAqLztcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjaHIgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaHIgPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovKSB7XG4gICAgICAgICAgICBpZiAoZW9sQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdExpbmVMZW5ndGggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW9sQ291bnQrKztcbiAgICAgICAgICAgIGlmIChpICsgMSA8IGxlbiAmJiB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIFxcclxcbi4uLiBjYXNlXG4gICAgICAgICAgICAgICAgZW9sIHw9IDIgLyogU3RyaW5nRU9MLkNSTEYgKi87XG4gICAgICAgICAgICAgICAgaSsrOyAvLyBza2lwIFxcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gXFxyLi4uIGNhc2VcbiAgICAgICAgICAgICAgICBlb2wgfD0gMyAvKiBTdHJpbmdFT0wuSW52YWxpZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RMaW5lU3RhcnQgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaHIgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XG4gICAgICAgICAgICAvLyBcXG4uLi4gY2FzZVxuICAgICAgICAgICAgZW9sIHw9IDEgLyogU3RyaW5nRU9MLkxGICovO1xuICAgICAgICAgICAgaWYgKGVvbENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RMaW5lTGVuZ3RoID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVvbENvdW50Kys7XG4gICAgICAgICAgICBsYXN0TGluZVN0YXJ0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVvbENvdW50ID09PSAwKSB7XG4gICAgICAgIGZpcnN0TGluZUxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gW2VvbENvdW50LCBmaXJzdExpbmVMZW5ndGgsIHRleHQubGVuZ3RoIC0gbGFzdExpbmVTdGFydCwgZW9sXTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKi9cbmV4cG9ydCBjbGFzcyBUb2tlbk1ldGFkYXRhIHtcbiAgICBzdGF0aWMgZ2V0TGFuZ3VhZ2VJZChtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gKG1ldGFkYXRhICYgMjU1IC8qIE1ldGFkYXRhQ29uc3RzLkxBTkdVQUdFSURfTUFTSyAqLykgPj4+IDAgLyogTWV0YWRhdGFDb25zdHMuTEFOR1VBR0VJRF9PRkZTRVQgKi87XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUb2tlblR5cGUobWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIChtZXRhZGF0YSAmIDc2OCAvKiBNZXRhZGF0YUNvbnN0cy5UT0tFTl9UWVBFX01BU0sgKi8pID4+PiA4IC8qIE1ldGFkYXRhQ29uc3RzLlRPS0VOX1RZUEVfT0ZGU0VUICovO1xuICAgIH1cbiAgICBzdGF0aWMgY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiAobWV0YWRhdGEgJiAxMDI0IC8qIE1ldGFkYXRhQ29uc3RzLkJBTEFOQ0VEX0JSQUNLRVRTX01BU0sgKi8pICE9PSAwO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Rm9udFN0eWxlKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiAobWV0YWRhdGEgJiAzMDcyMCAvKiBNZXRhZGF0YUNvbnN0cy5GT05UX1NUWUxFX01BU0sgKi8pID4+PiAxMSAvKiBNZXRhZGF0YUNvbnN0cy5GT05UX1NUWUxFX09GRlNFVCAqLztcbiAgICB9XG4gICAgc3RhdGljIGdldEZvcmVncm91bmQobWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIChtZXRhZGF0YSAmIDE2NzQ0NDQ4IC8qIE1ldGFkYXRhQ29uc3RzLkZPUkVHUk9VTkRfTUFTSyAqLykgPj4+IDE1IC8qIE1ldGFkYXRhQ29uc3RzLkZPUkVHUk9VTkRfT0ZGU0VUICovO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmFja2dyb3VuZChtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gKG1ldGFkYXRhICYgNDI3ODE5MDA4MCAvKiBNZXRhZGF0YUNvbnN0cy5CQUNLR1JPVU5EX01BU0sgKi8pID4+PiAyNCAvKiBNZXRhZGF0YUNvbnN0cy5CQUNLR1JPVU5EX09GRlNFVCAqLztcbiAgICB9XG4gICAgc3RhdGljIGdldENsYXNzTmFtZUZyb21NZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBmb3JlZ3JvdW5kID0gdGhpcy5nZXRGb3JlZ3JvdW5kKG1ldGFkYXRhKTtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9ICdtdGsnICsgZm9yZWdyb3VuZDtcbiAgICAgICAgY29uc3QgZm9udFN0eWxlID0gdGhpcy5nZXRGb250U3R5bGUobWV0YWRhdGEpO1xuICAgICAgICBpZiAoZm9udFN0eWxlICYgMSAvKiBGb250U3R5bGUuSXRhbGljICovKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgKz0gJyBtdGtpJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9udFN0eWxlICYgMiAvKiBGb250U3R5bGUuQm9sZCAqLykge1xuICAgICAgICAgICAgY2xhc3NOYW1lICs9ICcgbXRrYic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbnRTdHlsZSAmIDQgLyogRm9udFN0eWxlLlVuZGVybGluZSAqLykge1xuICAgICAgICAgICAgY2xhc3NOYW1lICs9ICcgbXRrdSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbnRTdHlsZSAmIDggLyogRm9udFN0eWxlLlN0cmlrZXRocm91Z2ggKi8pIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSAnIG10a3MnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRJbmxpbmVTdHlsZUZyb21NZXRhZGF0YShtZXRhZGF0YSwgY29sb3JNYXApIHtcbiAgICAgICAgY29uc3QgZm9yZWdyb3VuZCA9IHRoaXMuZ2V0Rm9yZWdyb3VuZChtZXRhZGF0YSk7XG4gICAgICAgIGNvbnN0IGZvbnRTdHlsZSA9IHRoaXMuZ2V0Rm9udFN0eWxlKG1ldGFkYXRhKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGBjb2xvcjogJHtjb2xvck1hcFtmb3JlZ3JvdW5kXX07YDtcbiAgICAgICAgaWYgKGZvbnRTdHlsZSAmIDEgLyogRm9udFN0eWxlLkl0YWxpYyAqLykge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdmb250LXN0eWxlOiBpdGFsaWM7JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9udFN0eWxlICYgMiAvKiBGb250U3R5bGUuQm9sZCAqLykge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdmb250LXdlaWdodDogYm9sZDsnO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZXh0RGVjb3JhdGlvbiA9ICcnO1xuICAgICAgICBpZiAoZm9udFN0eWxlICYgNCAvKiBGb250U3R5bGUuVW5kZXJsaW5lICovKSB7XG4gICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbiArPSAnIHVuZGVybGluZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbnRTdHlsZSAmIDggLyogRm9udFN0eWxlLlN0cmlrZXRocm91Z2ggKi8pIHtcbiAgICAgICAgICAgIHRleHREZWNvcmF0aW9uICs9ICcgbGluZS10aHJvdWdoJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgdGV4dC1kZWNvcmF0aW9uOiR7dGV4dERlY29yYXRpb259O2A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGdldFByZXNlbnRhdGlvbkZyb21NZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBmb3JlZ3JvdW5kID0gdGhpcy5nZXRGb3JlZ3JvdW5kKG1ldGFkYXRhKTtcbiAgICAgICAgY29uc3QgZm9udFN0eWxlID0gdGhpcy5nZXRGb250U3R5bGUobWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9yZWdyb3VuZDogZm9yZWdyb3VuZCxcbiAgICAgICAgICAgIGl0YWxpYzogQm9vbGVhbihmb250U3R5bGUgJiAxIC8qIEZvbnRTdHlsZS5JdGFsaWMgKi8pLFxuICAgICAgICAgICAgYm9sZDogQm9vbGVhbihmb250U3R5bGUgJiAyIC8qIEZvbnRTdHlsZS5Cb2xkICovKSxcbiAgICAgICAgICAgIHVuZGVybGluZTogQm9vbGVhbihmb250U3R5bGUgJiA0IC8qIEZvbnRTdHlsZS5VbmRlcmxpbmUgKi8pLFxuICAgICAgICAgICAgc3RyaWtldGhyb3VnaDogQm9vbGVhbihmb250U3R5bGUgJiA4IC8qIEZvbnRTdHlsZS5TdHJpa2V0aHJvdWdoICovKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGNyZWF0ZURlY29yYXRvciB9IGZyb20gJy4uLy4uLy4uL3BsYXRmb3JtL2luc3RhbnRpYXRpb24vY29tbW9uL2luc3RhbnRpYXRpb24uanMnO1xuZXhwb3J0IGNvbnN0IElMYW5ndWFnZVNlcnZpY2UgPSBjcmVhdGVEZWNvcmF0b3IoJ2xhbmd1YWdlU2VydmljZScpO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IFRva2VuTWV0YWRhdGEgfSBmcm9tICcuLi9lbmNvZGVkVG9rZW5BdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IElUaGVtZVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9wbGF0Zm9ybS90aGVtZS9jb21tb24vdGhlbWVTZXJ2aWNlLmpzJztcbmltcG9ydCB7IElMb2dTZXJ2aWNlLCBMb2dMZXZlbCB9IGZyb20gJy4uLy4uLy4uL3BsYXRmb3JtL2xvZy9jb21tb24vbG9nLmpzJztcbmltcG9ydCB7IFNwYXJzZU11bHRpbGluZVRva2VucyB9IGZyb20gJy4uL3Rva2Vucy9zcGFyc2VNdWx0aWxpbmVUb2tlbnMuanMnO1xuaW1wb3J0IHsgSUxhbmd1YWdlU2VydmljZSB9IGZyb20gJy4uL2xhbmd1YWdlcy9sYW5ndWFnZS5qcyc7XG5jb25zdCBFTkFCTEVfVFJBQ0UgPSBmYWxzZTtcbmxldCBTZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZyA9IGNsYXNzIFNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihfbGVnZW5kLCBfdGhlbWVTZXJ2aWNlLCBfbGFuZ3VhZ2VTZXJ2aWNlLCBfbG9nU2VydmljZSkge1xuICAgICAgICB0aGlzLl9sZWdlbmQgPSBfbGVnZW5kO1xuICAgICAgICB0aGlzLl90aGVtZVNlcnZpY2UgPSBfdGhlbWVTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZVNlcnZpY2UgPSBfbGFuZ3VhZ2VTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9sb2dTZXJ2aWNlID0gX2xvZ1NlcnZpY2U7XG4gICAgICAgIHRoaXMuX2hhc1dhcm5lZE92ZXJsYXBwaW5nVG9rZW5zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hhc1dhcm5lZEludmFsaWRMZW5ndGhUb2tlbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGFzV2FybmVkSW52YWxpZEVkaXRTdGFydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oYXNoVGFibGUgPSBuZXcgSGFzaFRhYmxlKCk7XG4gICAgfVxuICAgIGdldE1ldGFkYXRhKHRva2VuVHlwZUluZGV4LCB0b2tlbk1vZGlmaWVyU2V0LCBsYW5ndWFnZUlkKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWRMYW5ndWFnZUlkID0gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLmxhbmd1YWdlSWRDb2RlYy5lbmNvZGVMYW5ndWFnZUlkKGxhbmd1YWdlSWQpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuX2hhc2hUYWJsZS5nZXQodG9rZW5UeXBlSW5kZXgsIHRva2VuTW9kaWZpZXJTZXQsIGVuY29kZWRMYW5ndWFnZUlkKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gZW50cnkubWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAoRU5BQkxFX1RSQUNFICYmIHRoaXMuX2xvZ1NlcnZpY2UuZ2V0TGV2ZWwoKSA9PT0gTG9nTGV2ZWwuVHJhY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dTZXJ2aWNlLnRyYWNlKGBTZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZyBbQ0FDSEVEXSAke3Rva2VuVHlwZUluZGV4fSAvICR7dG9rZW5Nb2RpZmllclNldH06IGZvcmVncm91bmQgJHtUb2tlbk1ldGFkYXRhLmdldEZvcmVncm91bmQobWV0YWRhdGEpfSwgZm9udFN0eWxlICR7VG9rZW5NZXRhZGF0YS5nZXRGb250U3R5bGUobWV0YWRhdGEpLnRvU3RyaW5nKDIpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRva2VuVHlwZSA9IHRoaXMuX2xlZ2VuZC50b2tlblR5cGVzW3Rva2VuVHlwZUluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuTW9kaWZpZXJzID0gW107XG4gICAgICAgICAgICBpZiAodG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vZGlmaWVyU2V0ID0gdG9rZW5Nb2RpZmllclNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBtb2RpZmllckluZGV4ID0gMDsgbW9kaWZpZXJTZXQgPiAwICYmIG1vZGlmaWVySW5kZXggPCB0aGlzLl9sZWdlbmQudG9rZW5Nb2RpZmllcnMubGVuZ3RoOyBtb2RpZmllckluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVyU2V0ICYgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Nb2RpZmllcnMucHVzaCh0aGlzLl9sZWdlbmQudG9rZW5Nb2RpZmllcnNbbW9kaWZpZXJJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVyU2V0ID0gbW9kaWZpZXJTZXQgPj4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEVOQUJMRV9UUkFDRSAmJiBtb2RpZmllclNldCA+IDAgJiYgdGhpcy5fbG9nU2VydmljZS5nZXRMZXZlbCgpID09PSBMb2dMZXZlbC5UcmFjZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dTZXJ2aWNlLnRyYWNlKGBTZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZzogdW5rbm93biB0b2tlbiBtb2RpZmllciBpbmRleDogJHt0b2tlbk1vZGlmaWVyU2V0LnRvU3RyaW5nKDIpfSBmb3IgbGVnZW5kOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuX2xlZ2VuZC50b2tlbk1vZGlmaWVycyl9YCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuTW9kaWZpZXJzLnB1c2goJ25vdC1pbi1sZWdlbmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5TdHlsZSA9IHRoaXMuX3RoZW1lU2VydmljZS5nZXRDb2xvclRoZW1lKCkuZ2V0VG9rZW5TdHlsZU1ldGFkYXRhKHRva2VuVHlwZSwgdG9rZW5Nb2RpZmllcnMsIGxhbmd1YWdlSWQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5TdHlsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSAyMTQ3NDgzNjQ3IC8qIFNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nQ29uc3RhbnRzLk5PX1NUWUxJTkcgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5TdHlsZS5pdGFsaWMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGFsaWNCaXQgPSAodG9rZW5TdHlsZS5pdGFsaWMgPyAxIC8qIEZvbnRTdHlsZS5JdGFsaWMgKi8gOiAwKSA8PCAxMSAvKiBNZXRhZGF0YUNvbnN0cy5GT05UX1NUWUxFX09GRlNFVCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhIHw9IGl0YWxpY0JpdCB8IDEgLyogTWV0YWRhdGFDb25zdHMuU0VNQU5USUNfVVNFX0lUQUxJQyAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuU3R5bGUuYm9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvbGRCaXQgPSAodG9rZW5TdHlsZS5ib2xkID8gMiAvKiBGb250U3R5bGUuQm9sZCAqLyA6IDApIDw8IDExIC8qIE1ldGFkYXRhQ29uc3RzLkZPTlRfU1RZTEVfT0ZGU0VUICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgfD0gYm9sZEJpdCB8IDIgLyogTWV0YWRhdGFDb25zdHMuU0VNQU5USUNfVVNFX0JPTEQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlblN0eWxlLnVuZGVybGluZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuZGVybGluZUJpdCA9ICh0b2tlblN0eWxlLnVuZGVybGluZSA/IDQgLyogRm9udFN0eWxlLlVuZGVybGluZSAqLyA6IDApIDw8IDExIC8qIE1ldGFkYXRhQ29uc3RzLkZPTlRfU1RZTEVfT0ZGU0VUICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgfD0gdW5kZXJsaW5lQml0IHwgNCAvKiBNZXRhZGF0YUNvbnN0cy5TRU1BTlRJQ19VU0VfVU5ERVJMSU5FICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5TdHlsZS5zdHJpa2V0aHJvdWdoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaWtldGhyb3VnaEJpdCA9ICh0b2tlblN0eWxlLnN0cmlrZXRocm91Z2ggPyA4IC8qIEZvbnRTdHlsZS5TdHJpa2V0aHJvdWdoICovIDogMCkgPDwgMTEgLyogTWV0YWRhdGFDb25zdHMuRk9OVF9TVFlMRV9PRkZTRVQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSB8PSBzdHJpa2V0aHJvdWdoQml0IHwgOCAvKiBNZXRhZGF0YUNvbnN0cy5TRU1BTlRJQ19VU0VfU1RSSUtFVEhST1VHSCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHlsZS5mb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JlZ3JvdW5kQml0cyA9ICh0b2tlblN0eWxlLmZvcmVncm91bmQpIDw8IDE1IC8qIE1ldGFkYXRhQ29uc3RzLkZPUkVHUk9VTkRfT0ZGU0VUICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgfD0gZm9yZWdyb3VuZEJpdHMgfCAxNiAvKiBNZXRhZGF0YUNvbnN0cy5TRU1BTlRJQ19VU0VfRk9SRUdST1VORCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmchXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IDIxNDc0ODM2NDcgLyogU2VtYW50aWNUb2tlbnNQcm92aWRlclN0eWxpbmdDb25zdGFudHMuTk9fU1RZTElORyAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChFTkFCTEVfVFJBQ0UgJiYgdGhpcy5fbG9nU2VydmljZS5nZXRMZXZlbCgpID09PSBMb2dMZXZlbC5UcmFjZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dTZXJ2aWNlLnRyYWNlKGBTZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZzogdW5rbm93biB0b2tlbiB0eXBlIGluZGV4OiAke3Rva2VuVHlwZUluZGV4fSBmb3IgbGVnZW5kOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuX2xlZ2VuZC50b2tlblR5cGVzKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSAyMTQ3NDgzNjQ3IC8qIFNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nQ29uc3RhbnRzLk5PX1NUWUxJTkcgKi87XG4gICAgICAgICAgICAgICAgdG9rZW5UeXBlID0gJ25vdC1pbi1sZWdlbmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faGFzaFRhYmxlLmFkZCh0b2tlblR5cGVJbmRleCwgdG9rZW5Nb2RpZmllclNldCwgZW5jb2RlZExhbmd1YWdlSWQsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChFTkFCTEVfVFJBQ0UgJiYgdGhpcy5fbG9nU2VydmljZS5nZXRMZXZlbCgpID09PSBMb2dMZXZlbC5UcmFjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ1NlcnZpY2UudHJhY2UoYFNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nICR7dG9rZW5UeXBlSW5kZXh9ICgke3Rva2VuVHlwZX0pIC8gJHt0b2tlbk1vZGlmaWVyU2V0fSAoJHt0b2tlbk1vZGlmaWVycy5qb2luKCcgJyl9KTogZm9yZWdyb3VuZCAke1Rva2VuTWV0YWRhdGEuZ2V0Rm9yZWdyb3VuZChtZXRhZGF0YSl9LCBmb250U3R5bGUgJHtUb2tlbk1ldGFkYXRhLmdldEZvbnRTdHlsZShtZXRhZGF0YSkudG9TdHJpbmcoMil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICB3YXJuT3ZlcmxhcHBpbmdTZW1hbnRpY1Rva2VucyhsaW5lTnVtYmVyLCBzdGFydENvbHVtbikge1xuICAgICAgICBpZiAoIXRoaXMuX2hhc1dhcm5lZE92ZXJsYXBwaW5nVG9rZW5zKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNXYXJuZWRPdmVybGFwcGluZ1Rva2VucyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9sb2dTZXJ2aWNlLndhcm4oYE92ZXJsYXBwaW5nIHNlbWFudGljIHRva2VucyBkZXRlY3RlZCBhdCBsaW5lTnVtYmVyICR7bGluZU51bWJlcn0sIGNvbHVtbiAke3N0YXJ0Q29sdW1ufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhcm5JbnZhbGlkTGVuZ3RoU2VtYW50aWNUb2tlbnMobGluZU51bWJlciwgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNXYXJuZWRJbnZhbGlkTGVuZ3RoVG9rZW5zKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNXYXJuZWRJbnZhbGlkTGVuZ3RoVG9rZW5zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2xvZ1NlcnZpY2Uud2FybihgU2VtYW50aWMgdG9rZW4gd2l0aCBpbnZhbGlkIGxlbmd0aCBkZXRlY3RlZCBhdCBsaW5lTnVtYmVyICR7bGluZU51bWJlcn0sIGNvbHVtbiAke3N0YXJ0Q29sdW1ufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhcm5JbnZhbGlkRWRpdFN0YXJ0KHByZXZpb3VzUmVzdWx0SWQsIHJlc3VsdElkLCBlZGl0SW5kZXgsIGVkaXRTdGFydCwgbWF4RXhwZWN0ZWRTdGFydCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hhc1dhcm5lZEludmFsaWRFZGl0U3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc1dhcm5lZEludmFsaWRFZGl0U3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fbG9nU2VydmljZS53YXJuKGBJbnZhbGlkIHNlbWFudGljIHRva2VucyBlZGl0IGRldGVjdGVkIChwcmV2aW91c1Jlc3VsdElkOiAke3ByZXZpb3VzUmVzdWx0SWR9LCByZXN1bHRJZDogJHtyZXN1bHRJZH0pIGF0IGVkaXQgIyR7ZWRpdEluZGV4fTogVGhlIHByb3ZpZGVkIHN0YXJ0IG9mZnNldCAke2VkaXRTdGFydH0gaXMgb3V0c2lkZSB0aGUgcHJldmlvdXMgZGF0YSAobGVuZ3RoICR7bWF4RXhwZWN0ZWRTdGFydH0pLmApO1xuICAgICAgICB9XG4gICAgfVxufTtcblNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgxLCBJVGhlbWVTZXJ2aWNlKSxcbiAgICBfX3BhcmFtKDIsIElMYW5ndWFnZVNlcnZpY2UpLFxuICAgIF9fcGFyYW0oMywgSUxvZ1NlcnZpY2UpXG5dLCBTZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZyk7XG5leHBvcnQgeyBTZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZyB9O1xuZXhwb3J0IGZ1bmN0aW9uIHRvTXVsdGlsaW5lVG9rZW5zMih0b2tlbnMsIHN0eWxpbmcsIGxhbmd1YWdlSWQpIHtcbiAgICBjb25zdCBzcmNEYXRhID0gdG9rZW5zLmRhdGE7XG4gICAgY29uc3QgdG9rZW5Db3VudCA9ICh0b2tlbnMuZGF0YS5sZW5ndGggLyA1KSB8IDA7XG4gICAgY29uc3QgdG9rZW5zUGVyQXJlYSA9IE1hdGgubWF4KE1hdGguY2VpbCh0b2tlbkNvdW50IC8gMTAyNCAvKiBTZW1hbnRpY0NvbG9yaW5nQ29uc3RhbnRzLkRlc2lyZWRNYXhBcmVhcyAqLyksIDQwMCAvKiBTZW1hbnRpY0NvbG9yaW5nQ29uc3RhbnRzLkRlc2lyZWRUb2tlbnNQZXJBcmVhICovKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgdG9rZW5JbmRleCA9IDA7XG4gICAgbGV0IGxhc3RMaW5lTnVtYmVyID0gMTtcbiAgICBsZXQgbGFzdFN0YXJ0Q2hhcmFjdGVyID0gMDtcbiAgICB3aGlsZSAodG9rZW5JbmRleCA8IHRva2VuQ291bnQpIHtcbiAgICAgICAgY29uc3QgdG9rZW5TdGFydEluZGV4ID0gdG9rZW5JbmRleDtcbiAgICAgICAgbGV0IHRva2VuRW5kSW5kZXggPSBNYXRoLm1pbih0b2tlblN0YXJ0SW5kZXggKyB0b2tlbnNQZXJBcmVhLCB0b2tlbkNvdW50KTtcbiAgICAgICAgLy8gS2VlcCB0b2tlbnMgb24gdGhlIHNhbWUgbGluZSBpbiB0aGUgc2FtZSBhcmVhLi4uXG4gICAgICAgIGlmICh0b2tlbkVuZEluZGV4IDwgdG9rZW5Db3VudCkge1xuICAgICAgICAgICAgbGV0IHNtYWxsVG9rZW5FbmRJbmRleCA9IHRva2VuRW5kSW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoc21hbGxUb2tlbkVuZEluZGV4IC0gMSA+IHRva2VuU3RhcnRJbmRleCAmJiBzcmNEYXRhWzUgKiBzbWFsbFRva2VuRW5kSW5kZXhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc21hbGxUb2tlbkVuZEluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc21hbGxUb2tlbkVuZEluZGV4IC0gMSA9PT0gdG9rZW5TdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgYXJlIHNvIG1hbnkgdG9rZW5zIG9uIHRoaXMgbGluZSB0aGF0IG91ciBhcmVhIHdvdWxkIGJlIGVtcHR5LCB3ZSBtdXN0IG5vdyBnbyByaWdodFxuICAgICAgICAgICAgICAgIGxldCBiaWdUb2tlbkVuZEluZGV4ID0gdG9rZW5FbmRJbmRleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYmlnVG9rZW5FbmRJbmRleCArIDEgPCB0b2tlbkNvdW50ICYmIHNyY0RhdGFbNSAqIGJpZ1Rva2VuRW5kSW5kZXhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpZ1Rva2VuRW5kSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW5FbmRJbmRleCA9IGJpZ1Rva2VuRW5kSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbkVuZEluZGV4ID0gc21hbGxUb2tlbkVuZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkZXN0RGF0YSA9IG5ldyBVaW50MzJBcnJheSgodG9rZW5FbmRJbmRleCAtIHRva2VuU3RhcnRJbmRleCkgKiA0KTtcbiAgICAgICAgbGV0IGRlc3RPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgYXJlYUxpbmUgPSAwO1xuICAgICAgICBsZXQgcHJldkxpbmVOdW1iZXIgPSAwO1xuICAgICAgICBsZXQgcHJldkVuZENoYXJhY3RlciA9IDA7XG4gICAgICAgIHdoaWxlICh0b2tlbkluZGV4IDwgdG9rZW5FbmRJbmRleCkge1xuICAgICAgICAgICAgY29uc3Qgc3JjT2Zmc2V0ID0gNSAqIHRva2VuSW5kZXg7XG4gICAgICAgICAgICBjb25zdCBkZWx0YUxpbmUgPSBzcmNEYXRhW3NyY09mZnNldF07XG4gICAgICAgICAgICBjb25zdCBkZWx0YUNoYXJhY3RlciA9IHNyY0RhdGFbc3JjT2Zmc2V0ICsgMV07XG4gICAgICAgICAgICAvLyBDYXN0aW5nIGJvdGggYGxpbmVOdW1iZXJgLCBgc3RhcnRDaGFyYWN0ZXJgIGFuZCBgZW5kQ2hhcmFjdGVyYCBoZXJlIHRvIHVpbnQzMiB1c2luZyBgfDBgXG4gICAgICAgICAgICAvLyB0byB2YWxpZGF0ZSBiZWxvdyB3aXRoIHRoZSBhY3R1YWwgdmFsdWVzIHRoYXQgd2lsbCBiZSBpbnNlcnRlZCBpbiB0aGUgVWludDMyQXJyYXkgcmVzdWx0XG4gICAgICAgICAgICBjb25zdCBsaW5lTnVtYmVyID0gKGxhc3RMaW5lTnVtYmVyICsgZGVsdGFMaW5lKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzdGFydENoYXJhY3RlciA9IChkZWx0YUxpbmUgPT09IDAgPyAobGFzdFN0YXJ0Q2hhcmFjdGVyICsgZGVsdGFDaGFyYWN0ZXIpIHwgMCA6IGRlbHRhQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHNyY0RhdGFbc3JjT2Zmc2V0ICsgMl07XG4gICAgICAgICAgICBjb25zdCBlbmRDaGFyYWN0ZXIgPSAoc3RhcnRDaGFyYWN0ZXIgKyBsZW5ndGgpIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuVHlwZUluZGV4ID0gc3JjRGF0YVtzcmNPZmZzZXQgKyAzXTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuTW9kaWZpZXJTZXQgPSBzcmNEYXRhW3NyY09mZnNldCArIDRdO1xuICAgICAgICAgICAgaWYgKGVuZENoYXJhY3RlciA8PSBzdGFydENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgdG9rZW4gaXMgaW52YWxpZCAobW9zdCBsaWtlbHkgYSBuZWdhdGl2ZSBsZW5ndGggY2FzdGVkIHRvIHVpbnQzMilcbiAgICAgICAgICAgICAgICBzdHlsaW5nLndhcm5JbnZhbGlkTGVuZ3RoU2VtYW50aWNUb2tlbnMobGluZU51bWJlciwgc3RhcnRDaGFyYWN0ZXIgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZXZMaW5lTnVtYmVyID09PSBsaW5lTnVtYmVyICYmIHByZXZFbmRDaGFyYWN0ZXIgPiBzdGFydENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgdG9rZW4gb3ZlcmxhcHMgd2l0aCB0aGUgcHJldmlvdXMgdG9rZW5cbiAgICAgICAgICAgICAgICBzdHlsaW5nLndhcm5PdmVybGFwcGluZ1NlbWFudGljVG9rZW5zKGxpbmVOdW1iZXIsIHN0YXJ0Q2hhcmFjdGVyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHN0eWxpbmcuZ2V0TWV0YWRhdGEodG9rZW5UeXBlSW5kZXgsIHRva2VuTW9kaWZpZXJTZXQsIGxhbmd1YWdlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSAhPT0gMjE0NzQ4MzY0NyAvKiBTZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZ0NvbnN0YW50cy5OT19TVFlMSU5HICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhTGluZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJlYUxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlc3REYXRhW2Rlc3RPZmZzZXRdID0gbGluZU51bWJlciAtIGFyZWFMaW5lO1xuICAgICAgICAgICAgICAgICAgICBkZXN0RGF0YVtkZXN0T2Zmc2V0ICsgMV0gPSBzdGFydENoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICAgICAgZGVzdERhdGFbZGVzdE9mZnNldCArIDJdID0gZW5kQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICBkZXN0RGF0YVtkZXN0T2Zmc2V0ICsgM10gPSBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdE9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBwcmV2TGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIHByZXZFbmRDaGFyYWN0ZXIgPSBlbmRDaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgICAgbGFzdFN0YXJ0Q2hhcmFjdGVyID0gc3RhcnRDaGFyYWN0ZXI7XG4gICAgICAgICAgICB0b2tlbkluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc3RPZmZzZXQgIT09IGRlc3REYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzdERhdGEgPSBkZXN0RGF0YS5zdWJhcnJheSgwLCBkZXN0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbnMgPSBTcGFyc2VNdWx0aWxpbmVUb2tlbnMuY3JlYXRlKGFyZWFMaW5lLCBkZXN0RGF0YSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBIYXNoVGFibGVFbnRyeSB7XG4gICAgY29uc3RydWN0b3IodG9rZW5UeXBlSW5kZXgsIHRva2VuTW9kaWZpZXJTZXQsIGxhbmd1YWdlSWQsIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlSW5kZXggPSB0b2tlblR5cGVJbmRleDtcbiAgICAgICAgdGhpcy50b2tlbk1vZGlmaWVyU2V0ID0gdG9rZW5Nb2RpZmllclNldDtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIH1cbn1cbmNsYXNzIEhhc2hUYWJsZSB7XG4gICAgc3RhdGljIHsgdGhpcy5fU0laRVMgPSBbMywgNywgMTMsIDMxLCA2MSwgMTI3LCAyNTEsIDUwOSwgMTAyMSwgMjAzOSwgNDA5MywgODE5MSwgMTYzODEsIDMyNzQ5LCA2NTUyMSwgMTMxMDcxLCAyNjIxMzksIDUyNDI4NywgMTA0ODU3MywgMjA5NzE0M107IH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudHNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRMZW5ndGhJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRMZW5ndGggPSBIYXNoVGFibGUuX1NJWkVTW3RoaXMuX2N1cnJlbnRMZW5ndGhJbmRleF07XG4gICAgICAgIHRoaXMuX2dyb3dDb3VudCA9IE1hdGgucm91bmQodGhpcy5fY3VycmVudExlbmd0aEluZGV4ICsgMSA8IEhhc2hUYWJsZS5fU0laRVMubGVuZ3RoID8gMiAvIDMgKiB0aGlzLl9jdXJyZW50TGVuZ3RoIDogMCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzID0gW107XG4gICAgICAgIEhhc2hUYWJsZS5fbnVsbE91dEVudHJpZXModGhpcy5fZWxlbWVudHMsIHRoaXMuX2N1cnJlbnRMZW5ndGgpO1xuICAgIH1cbiAgICBzdGF0aWMgX251bGxPdXRFbnRyaWVzKGVudHJpZXMsIGxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlbnRyaWVzW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaGFzaDIobjEsIG4yKSB7XG4gICAgICAgIHJldHVybiAoKChuMSA8PCA1KSAtIG4xKSArIG4yKSB8IDA7IC8vIG4xICogMzEgKyBuMiwga2VlcCBhcyBpbnQzMlxuICAgIH1cbiAgICBfaGFzaEZ1bmModG9rZW5UeXBlSW5kZXgsIHRva2VuTW9kaWZpZXJTZXQsIGxhbmd1YWdlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2gyKHRoaXMuX2hhc2gyKHRva2VuVHlwZUluZGV4LCB0b2tlbk1vZGlmaWVyU2V0KSwgbGFuZ3VhZ2VJZCkgJSB0aGlzLl9jdXJyZW50TGVuZ3RoO1xuICAgIH1cbiAgICBnZXQodG9rZW5UeXBlSW5kZXgsIHRva2VuTW9kaWZpZXJTZXQsIGxhbmd1YWdlSWQpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuX2hhc2hGdW5jKHRva2VuVHlwZUluZGV4LCB0b2tlbk1vZGlmaWVyU2V0LCBsYW5ndWFnZUlkKTtcbiAgICAgICAgbGV0IHAgPSB0aGlzLl9lbGVtZW50c1toYXNoXTtcbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIGlmIChwLnRva2VuVHlwZUluZGV4ID09PSB0b2tlblR5cGVJbmRleCAmJiBwLnRva2VuTW9kaWZpZXJTZXQgPT09IHRva2VuTW9kaWZpZXJTZXQgJiYgcC5sYW5ndWFnZUlkID09PSBsYW5ndWFnZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhZGQodG9rZW5UeXBlSW5kZXgsIHRva2VuTW9kaWZpZXJTZXQsIGxhbmd1YWdlSWQsIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzQ291bnQrKztcbiAgICAgICAgaWYgKHRoaXMuX2dyb3dDb3VudCAhPT0gMCAmJiB0aGlzLl9lbGVtZW50c0NvdW50ID49IHRoaXMuX2dyb3dDb3VudCkge1xuICAgICAgICAgICAgLy8gZXhwYW5kIVxuICAgICAgICAgICAgY29uc3Qgb2xkRWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZW5ndGhJbmRleCsrO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExlbmd0aCA9IEhhc2hUYWJsZS5fU0laRVNbdGhpcy5fY3VycmVudExlbmd0aEluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuX2dyb3dDb3VudCA9IE1hdGgucm91bmQodGhpcy5fY3VycmVudExlbmd0aEluZGV4ICsgMSA8IEhhc2hUYWJsZS5fU0laRVMubGVuZ3RoID8gMiAvIDMgKiB0aGlzLl9jdXJyZW50TGVuZ3RoIDogMCk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgSGFzaFRhYmxlLl9udWxsT3V0RW50cmllcyh0aGlzLl9lbGVtZW50cywgdGhpcy5fY3VycmVudExlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpcnN0IG9mIG9sZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBmaXJzdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGROZXh0ID0gcC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICBwLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBvbGROZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGQobmV3IEhhc2hUYWJsZUVudHJ5KHRva2VuVHlwZUluZGV4LCB0b2tlbk1vZGlmaWVyU2V0LCBsYW5ndWFnZUlkLCBtZXRhZGF0YSkpO1xuICAgIH1cbiAgICBfYWRkKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuX2hhc2hGdW5jKGVsZW1lbnQudG9rZW5UeXBlSW5kZXgsIGVsZW1lbnQudG9rZW5Nb2RpZmllclNldCwgZWxlbWVudC5sYW5ndWFnZUlkKTtcbiAgICAgICAgZWxlbWVudC5uZXh0ID0gdGhpcy5fZWxlbWVudHNbaGFzaF07XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzW2hhc2hdID0gZWxlbWVudDtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgY291bnRFT0wgfSBmcm9tICcuLi9jb3JlL2VvbENvdW50ZXIuanMnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHNwYXJzZSB0b2tlbnMgb3ZlciBhIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgbGluZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGFyc2VNdWx0aWxpbmVUb2tlbnMge1xuICAgIHN0YXRpYyBjcmVhdGUoc3RhcnRMaW5lTnVtYmVyLCB0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VNdWx0aWxpbmVUb2tlbnMoc3RhcnRMaW5lTnVtYmVyLCBuZXcgU3BhcnNlTXVsdGlsaW5lVG9rZW5zU3RvcmFnZSh0b2tlbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogKEluY2x1c2l2ZSkgc3RhcnQgbGluZSBudW1iZXIgZm9yIHRoZXNlIHRva2Vucy5cbiAgICAgKi9cbiAgICBnZXQgc3RhcnRMaW5lTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRMaW5lTnVtYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAoSW5jbHVzaXZlKSBlbmQgbGluZSBudW1iZXIgZm9yIHRoZXNlIHRva2Vucy5cbiAgICAgKi9cbiAgICBnZXQgZW5kTGluZU51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZExpbmVOdW1iZXI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0YXJ0TGluZU51bWJlciwgdG9rZW5zKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0TGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5fdG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLl9lbmRMaW5lTnVtYmVyID0gdGhpcy5fc3RhcnRMaW5lTnVtYmVyICsgdGhpcy5fdG9rZW5zLmdldE1heERlbHRhTGluZSgpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vucy50b1N0cmluZyh0aGlzLl9zdGFydExpbmVOdW1iZXIpO1xuICAgIH1cbiAgICBfdXBkYXRlRW5kTGluZU51bWJlcigpIHtcbiAgICAgICAgdGhpcy5fZW5kTGluZU51bWJlciA9IHRoaXMuX3N0YXJ0TGluZU51bWJlciArIHRoaXMuX3Rva2Vucy5nZXRNYXhEZWx0YUxpbmUoKTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vucy5pc0VtcHR5KCk7XG4gICAgfVxuICAgIGdldExpbmVUb2tlbnMobGluZU51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5fc3RhcnRMaW5lTnVtYmVyIDw9IGxpbmVOdW1iZXIgJiYgbGluZU51bWJlciA8PSB0aGlzLl9lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5zLmdldExpbmVUb2tlbnMobGluZU51bWJlciAtIHRoaXMuX3N0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldFJhbmdlKCkge1xuICAgICAgICBjb25zdCBkZWx0YVJhbmdlID0gdGhpcy5fdG9rZW5zLmdldFJhbmdlKCk7XG4gICAgICAgIGlmICghZGVsdGFSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhUmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLl9zdGFydExpbmVOdW1iZXIgKyBkZWx0YVJhbmdlLnN0YXJ0TGluZU51bWJlciwgZGVsdGFSYW5nZS5zdGFydENvbHVtbiwgdGhpcy5fc3RhcnRMaW5lTnVtYmVyICsgZGVsdGFSYW5nZS5lbmRMaW5lTnVtYmVyLCBkZWx0YVJhbmdlLmVuZENvbHVtbik7XG4gICAgfVxuICAgIHJlbW92ZVRva2VucyhyYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydExpbmVJbmRleCA9IHJhbmdlLnN0YXJ0TGluZU51bWJlciAtIHRoaXMuX3N0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgY29uc3QgZW5kTGluZUluZGV4ID0gcmFuZ2UuZW5kTGluZU51bWJlciAtIHRoaXMuX3N0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5fc3RhcnRMaW5lTnVtYmVyICs9IHRoaXMuX3Rva2Vucy5yZW1vdmVUb2tlbnMoc3RhcnRMaW5lSW5kZXgsIHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSwgZW5kTGluZUluZGV4LCByYW5nZS5lbmRDb2x1bW4gLSAxKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRW5kTGluZU51bWJlcigpO1xuICAgIH1cbiAgICBzcGxpdChyYW5nZSkge1xuICAgICAgICAvLyBzcGxpdCB0b2tlbnMgdG8gdHdvOlxuICAgICAgICAvLyBhKSBhbGwgdGhlIHRva2VucyBiZWZvcmUgYHJhbmdlYFxuICAgICAgICAvLyBiKSBhbGwgdGhlIHRva2VucyBhZnRlciBgcmFuZ2VgXG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZUluZGV4ID0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gdGhpcy5fc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICBjb25zdCBlbmRMaW5lSW5kZXggPSByYW5nZS5lbmRMaW5lTnVtYmVyIC0gdGhpcy5fc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICBjb25zdCBbYSwgYiwgYkRlbHRhTGluZV0gPSB0aGlzLl90b2tlbnMuc3BsaXQoc3RhcnRMaW5lSW5kZXgsIHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSwgZW5kTGluZUluZGV4LCByYW5nZS5lbmRDb2x1bW4gLSAxKTtcbiAgICAgICAgcmV0dXJuIFtuZXcgU3BhcnNlTXVsdGlsaW5lVG9rZW5zKHRoaXMuX3N0YXJ0TGluZU51bWJlciwgYSksIG5ldyBTcGFyc2VNdWx0aWxpbmVUb2tlbnModGhpcy5fc3RhcnRMaW5lTnVtYmVyICsgYkRlbHRhTGluZSwgYildO1xuICAgIH1cbiAgICBhcHBseUVkaXQocmFuZ2UsIHRleHQpIHtcbiAgICAgICAgY29uc3QgW2VvbENvdW50LCBmaXJzdExpbmVMZW5ndGgsIGxhc3RMaW5lTGVuZ3RoXSA9IGNvdW50RU9MKHRleHQpO1xuICAgICAgICB0aGlzLmFjY2VwdEVkaXQocmFuZ2UsIGVvbENvdW50LCBmaXJzdExpbmVMZW5ndGgsIGxhc3RMaW5lTGVuZ3RoLCB0ZXh0Lmxlbmd0aCA+IDAgPyB0ZXh0LmNoYXJDb2RlQXQoMCkgOiAwIC8qIENoYXJDb2RlLk51bGwgKi8pO1xuICAgIH1cbiAgICBhY2NlcHRFZGl0KHJhbmdlLCBlb2xDb3VudCwgZmlyc3RMaW5lTGVuZ3RoLCBsYXN0TGluZUxlbmd0aCwgZmlyc3RDaGFyQ29kZSkge1xuICAgICAgICB0aGlzLl9hY2NlcHREZWxldGVSYW5nZShyYW5nZSk7XG4gICAgICAgIHRoaXMuX2FjY2VwdEluc2VydFRleHQobmV3IFBvc2l0aW9uKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4pLCBlb2xDb3VudCwgZmlyc3RMaW5lTGVuZ3RoLCBsYXN0TGluZUxlbmd0aCwgZmlyc3RDaGFyQ29kZSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVuZExpbmVOdW1iZXIoKTtcbiAgICB9XG4gICAgX2FjY2VwdERlbGV0ZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgcmFuZ2Uuc3RhcnRDb2x1bW4gPT09IHJhbmdlLmVuZENvbHVtbikge1xuICAgICAgICAgICAgLy8gTm90aGluZyB0byBkZWxldGVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdExpbmVJbmRleCA9IHJhbmdlLnN0YXJ0TGluZU51bWJlciAtIHRoaXMuX3N0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgY29uc3QgbGFzdExpbmVJbmRleCA9IHJhbmdlLmVuZExpbmVOdW1iZXIgLSB0aGlzLl9zdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGlmIChsYXN0TGluZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgLy8gdGhpcyBkZWxldGlvbiBvY2N1cnMgZW50aXJlbHkgYmVmb3JlIHRoaXMgYmxvY2ssIHNvIHdlIG9ubHkgbmVlZCB0byBhZGp1c3QgbGluZSBudW1iZXJzXG4gICAgICAgICAgICBjb25zdCBkZWxldGVkTGluZXNDb3VudCA9IGxhc3RMaW5lSW5kZXggLSBmaXJzdExpbmVJbmRleDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0TGluZU51bWJlciAtPSBkZWxldGVkTGluZXNDb3VudDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbk1heERlbHRhTGluZSA9IHRoaXMuX3Rva2Vucy5nZXRNYXhEZWx0YUxpbmUoKTtcbiAgICAgICAgaWYgKGZpcnN0TGluZUluZGV4ID49IHRva2VuTWF4RGVsdGFMaW5lICsgMSkge1xuICAgICAgICAgICAgLy8gdGhpcyBkZWxldGlvbiBvY2N1cnMgZW50aXJlbHkgYWZ0ZXIgdGhpcyBibG9jaywgc28gdGhlcmUgaXMgbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdExpbmVJbmRleCA8IDAgJiYgbGFzdExpbmVJbmRleCA+PSB0b2tlbk1heERlbHRhTGluZSArIDEpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgZGVsZXRpb24gY29tcGxldGVseSBlbmNvbXBhc3NlcyB0aGlzIGJsb2NrXG4gICAgICAgICAgICB0aGlzLl9zdGFydExpbmVOdW1iZXIgPSAwO1xuICAgICAgICAgICAgdGhpcy5fdG9rZW5zLmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0TGluZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlZEJlZm9yZSA9IC1maXJzdExpbmVJbmRleDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0TGluZU51bWJlciAtPSBkZWxldGVkQmVmb3JlO1xuICAgICAgICAgICAgdGhpcy5fdG9rZW5zLmFjY2VwdERlbGV0ZVJhbmdlKHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSwgMCwgMCwgbGFzdExpbmVJbmRleCwgcmFuZ2UuZW5kQ29sdW1uIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2tlbnMuYWNjZXB0RGVsZXRlUmFuZ2UoMCwgZmlyc3RMaW5lSW5kZXgsIHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSwgbGFzdExpbmVJbmRleCwgcmFuZ2UuZW5kQ29sdW1uIC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FjY2VwdEluc2VydFRleHQocG9zaXRpb24sIGVvbENvdW50LCBmaXJzdExpbmVMZW5ndGgsIGxhc3RMaW5lTGVuZ3RoLCBmaXJzdENoYXJDb2RlKSB7XG4gICAgICAgIGlmIChlb2xDb3VudCA9PT0gMCAmJiBmaXJzdExpbmVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gaW5zZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZUluZGV4ID0gcG9zaXRpb24ubGluZU51bWJlciAtIHRoaXMuX3N0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgaWYgKGxpbmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaW5zZXJ0aW9uIG9jY3VycyBiZWZvcmUgdGhpcyBibG9jaywgc28gd2Ugb25seSBuZWVkIHRvIGFkanVzdCBsaW5lIG51bWJlcnNcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0TGluZU51bWJlciArPSBlb2xDb3VudDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbk1heERlbHRhTGluZSA9IHRoaXMuX3Rva2Vucy5nZXRNYXhEZWx0YUxpbmUoKTtcbiAgICAgICAgaWYgKGxpbmVJbmRleCA+PSB0b2tlbk1heERlbHRhTGluZSArIDEpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaW5zZXJ0aW9uIG9jY3VycyBhZnRlciB0aGlzIGJsb2NrLCBzbyB0aGVyZSBpcyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdG9rZW5zLmFjY2VwdEluc2VydFRleHQobGluZUluZGV4LCBwb3NpdGlvbi5jb2x1bW4gLSAxLCBlb2xDb3VudCwgZmlyc3RMaW5lTGVuZ3RoLCBsYXN0TGluZUxlbmd0aCwgZmlyc3RDaGFyQ29kZSk7XG4gICAgfVxufVxuY2xhc3MgU3BhcnNlTXVsdGlsaW5lVG9rZW5zU3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IodG9rZW5zKSB7XG4gICAgICAgIHRoaXMuX3Rva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5fdG9rZW5Db3VudCA9IHRva2Vucy5sZW5ndGggLyA0O1xuICAgIH1cbiAgICB0b1N0cmluZyhzdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgY29uc3QgcGllY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdG9rZW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICBwaWVjZXMucHVzaChgKCR7dGhpcy5fZ2V0RGVsdGFMaW5lKGkpICsgc3RhcnRMaW5lTnVtYmVyfSwke3RoaXMuX2dldFN0YXJ0Q2hhcmFjdGVyKGkpfS0ke3RoaXMuX2dldEVuZENoYXJhY3RlcihpKX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBbJHtwaWVjZXMuam9pbignLCcpfV1gO1xuICAgIH1cbiAgICBnZXRNYXhEZWx0YUxpbmUoKSB7XG4gICAgICAgIGNvbnN0IHRva2VuQ291bnQgPSB0aGlzLl9nZXRUb2tlbkNvdW50KCk7XG4gICAgICAgIGlmICh0b2tlbkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldERlbHRhTGluZSh0b2tlbkNvdW50IC0gMSk7XG4gICAgfVxuICAgIGdldFJhbmdlKCkge1xuICAgICAgICBjb25zdCB0b2tlbkNvdW50ID0gdGhpcy5fZ2V0VG9rZW5Db3VudCgpO1xuICAgICAgICBpZiAodG9rZW5Db3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRDaGFyID0gdGhpcy5fZ2V0U3RhcnRDaGFyYWN0ZXIoMCk7XG4gICAgICAgIGNvbnN0IG1heERlbHRhTGluZSA9IHRoaXMuX2dldERlbHRhTGluZSh0b2tlbkNvdW50IC0gMSk7XG4gICAgICAgIGNvbnN0IGVuZENoYXIgPSB0aGlzLl9nZXRFbmRDaGFyYWN0ZXIodG9rZW5Db3VudCAtIDEpO1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKDAsIHN0YXJ0Q2hhciArIDEsIG1heERlbHRhTGluZSwgZW5kQ2hhciArIDEpO1xuICAgIH1cbiAgICBfZ2V0VG9rZW5Db3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuQ291bnQ7XG4gICAgfVxuICAgIF9nZXREZWx0YUxpbmUodG9rZW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5zWzQgKiB0b2tlbkluZGV4XTtcbiAgICB9XG4gICAgX2dldFN0YXJ0Q2hhcmFjdGVyKHRva2VuSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vuc1s0ICogdG9rZW5JbmRleCArIDFdO1xuICAgIH1cbiAgICBfZ2V0RW5kQ2hhcmFjdGVyKHRva2VuSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vuc1s0ICogdG9rZW5JbmRleCArIDJdO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2dldFRva2VuQ291bnQoKSA9PT0gMCk7XG4gICAgfVxuICAgIGdldExpbmVUb2tlbnMoZGVsdGFMaW5lKSB7XG4gICAgICAgIGxldCBsb3cgPSAwO1xuICAgICAgICBsZXQgaGlnaCA9IHRoaXMuX2dldFRva2VuQ291bnQoKSAtIDE7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBsb3cgKyBNYXRoLmZsb29yKChoaWdoIC0gbG93KSAvIDIpO1xuICAgICAgICAgICAgY29uc3QgbWlkRGVsdGFMaW5lID0gdGhpcy5fZ2V0RGVsdGFMaW5lKG1pZCk7XG4gICAgICAgICAgICBpZiAobWlkRGVsdGFMaW5lIDwgZGVsdGFMaW5lKSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1pZERlbHRhTGluZSA+IGRlbHRhTGluZSkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1pbiA9IG1pZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobWluID4gbG93ICYmIHRoaXMuX2dldERlbHRhTGluZShtaW4gLSAxKSA9PT0gZGVsdGFMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbWF4ID0gbWlkO1xuICAgICAgICAgICAgICAgIHdoaWxlIChtYXggPCBoaWdoICYmIHRoaXMuX2dldERlbHRhTGluZShtYXggKyAxKSA9PT0gZGVsdGFMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZUxpbmVUb2tlbnModGhpcy5fdG9rZW5zLnN1YmFycmF5KDQgKiBtaW4sIDQgKiBtYXggKyA0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2dldERlbHRhTGluZShsb3cpID09PSBkZWx0YUxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlTGluZVRva2Vucyh0aGlzLl90b2tlbnMuc3ViYXJyYXkoNCAqIGxvdywgNCAqIGxvdyArIDQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX3Rva2VuQ291bnQgPSAwO1xuICAgIH1cbiAgICByZW1vdmVUb2tlbnMoc3RhcnREZWx0YUxpbmUsIHN0YXJ0Q2hhciwgZW5kRGVsdGFMaW5lLCBlbmRDaGFyKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMuX3Rva2VucztcbiAgICAgICAgY29uc3QgdG9rZW5Db3VudCA9IHRoaXMuX3Rva2VuQ291bnQ7XG4gICAgICAgIGxldCBuZXdUb2tlbkNvdW50ID0gMDtcbiAgICAgICAgbGV0IGhhc0RlbGV0ZWRUb2tlbnMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZpcnN0RGVsdGFMaW5lID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbkNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNyY09mZnNldCA9IDQgKiBpO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5EZWx0YUxpbmUgPSB0b2tlbnNbc3JjT2Zmc2V0XTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuU3RhcnRDaGFyYWN0ZXIgPSB0b2tlbnNbc3JjT2Zmc2V0ICsgMV07XG4gICAgICAgICAgICBjb25zdCB0b2tlbkVuZENoYXJhY3RlciA9IHRva2Vuc1tzcmNPZmZzZXQgKyAyXTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuTWV0YWRhdGEgPSB0b2tlbnNbc3JjT2Zmc2V0ICsgM107XG4gICAgICAgICAgICBpZiAoKHRva2VuRGVsdGFMaW5lID4gc3RhcnREZWx0YUxpbmUgfHwgKHRva2VuRGVsdGFMaW5lID09PSBzdGFydERlbHRhTGluZSAmJiB0b2tlbkVuZENoYXJhY3RlciA+PSBzdGFydENoYXIpKVxuICAgICAgICAgICAgICAgICYmICh0b2tlbkRlbHRhTGluZSA8IGVuZERlbHRhTGluZSB8fCAodG9rZW5EZWx0YUxpbmUgPT09IGVuZERlbHRhTGluZSAmJiB0b2tlblN0YXJ0Q2hhcmFjdGVyIDw9IGVuZENoYXIpKSkge1xuICAgICAgICAgICAgICAgIGhhc0RlbGV0ZWRUb2tlbnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1Rva2VuQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REZWx0YUxpbmUgPSB0b2tlbkRlbHRhTGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RlbGV0ZWRUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbXVzdCBtb3ZlIHRoZSB0b2tlbiB0byB0aGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0T2Zmc2V0ID0gNCAqIG5ld1Rva2VuQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1tkZXN0T2Zmc2V0XSA9IHRva2VuRGVsdGFMaW5lIC0gZmlyc3REZWx0YUxpbmU7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1tkZXN0T2Zmc2V0ICsgMV0gPSB0b2tlblN0YXJ0Q2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbZGVzdE9mZnNldCArIDJdID0gdG9rZW5FbmRDaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1tkZXN0T2Zmc2V0ICsgM10gPSB0b2tlbk1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdUb2tlbkNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdG9rZW5Db3VudCA9IG5ld1Rva2VuQ291bnQ7XG4gICAgICAgIHJldHVybiBmaXJzdERlbHRhTGluZTtcbiAgICB9XG4gICAgc3BsaXQoc3RhcnREZWx0YUxpbmUsIHN0YXJ0Q2hhciwgZW5kRGVsdGFMaW5lLCBlbmRDaGFyKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMuX3Rva2VucztcbiAgICAgICAgY29uc3QgdG9rZW5Db3VudCA9IHRoaXMuX3Rva2VuQ291bnQ7XG4gICAgICAgIGNvbnN0IGFUb2tlbnMgPSBbXTtcbiAgICAgICAgY29uc3QgYlRva2VucyA9IFtdO1xuICAgICAgICBsZXQgZGVzdFRva2VucyA9IGFUb2tlbnM7XG4gICAgICAgIGxldCBkZXN0T2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGRlc3RGaXJzdERlbHRhTGluZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzcmNPZmZzZXQgPSA0ICogaTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuRGVsdGFMaW5lID0gdG9rZW5zW3NyY09mZnNldF07XG4gICAgICAgICAgICBjb25zdCB0b2tlblN0YXJ0Q2hhcmFjdGVyID0gdG9rZW5zW3NyY09mZnNldCArIDFdO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5FbmRDaGFyYWN0ZXIgPSB0b2tlbnNbc3JjT2Zmc2V0ICsgMl07XG4gICAgICAgICAgICBjb25zdCB0b2tlbk1ldGFkYXRhID0gdG9rZW5zW3NyY09mZnNldCArIDNdO1xuICAgICAgICAgICAgaWYgKCh0b2tlbkRlbHRhTGluZSA+IHN0YXJ0RGVsdGFMaW5lIHx8ICh0b2tlbkRlbHRhTGluZSA9PT0gc3RhcnREZWx0YUxpbmUgJiYgdG9rZW5FbmRDaGFyYWN0ZXIgPj0gc3RhcnRDaGFyKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHRva2VuRGVsdGFMaW5lIDwgZW5kRGVsdGFMaW5lIHx8ICh0b2tlbkRlbHRhTGluZSA9PT0gZW5kRGVsdGFMaW5lICYmIHRva2VuU3RhcnRDaGFyYWN0ZXIgPD0gZW5kQ2hhcikpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdG9rZW4gaXMgdG91Y2hpbmcgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB0b2tlbiBpcyBhZnRlciB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RUb2tlbnMgIT09IGJUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdG9rZW4gaXMgdGhlIGZpcnN0IHRva2VuIGFmdGVyIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFRva2VucyA9IGJUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RGaXJzdERlbHRhTGluZSA9IHRva2VuRGVsdGFMaW5lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdFRva2Vuc1tkZXN0T2Zmc2V0KytdID0gdG9rZW5EZWx0YUxpbmUgLSBkZXN0Rmlyc3REZWx0YUxpbmU7XG4gICAgICAgICAgICBkZXN0VG9rZW5zW2Rlc3RPZmZzZXQrK10gPSB0b2tlblN0YXJ0Q2hhcmFjdGVyO1xuICAgICAgICAgICAgZGVzdFRva2Vuc1tkZXN0T2Zmc2V0KytdID0gdG9rZW5FbmRDaGFyYWN0ZXI7XG4gICAgICAgICAgICBkZXN0VG9rZW5zW2Rlc3RPZmZzZXQrK10gPSB0b2tlbk1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbmV3IFNwYXJzZU11bHRpbGluZVRva2Vuc1N0b3JhZ2UobmV3IFVpbnQzMkFycmF5KGFUb2tlbnMpKSwgbmV3IFNwYXJzZU11bHRpbGluZVRva2Vuc1N0b3JhZ2UobmV3IFVpbnQzMkFycmF5KGJUb2tlbnMpKSwgZGVzdEZpcnN0RGVsdGFMaW5lXTtcbiAgICB9XG4gICAgYWNjZXB0RGVsZXRlUmFuZ2UoaG9yaXpvbnRhbFNoaWZ0Rm9yRmlyc3RMaW5lVG9rZW5zLCBzdGFydERlbHRhTGluZSwgc3RhcnRDaGFyYWN0ZXIsIGVuZERlbHRhTGluZSwgZW5kQ2hhcmFjdGVyKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBiaXQgY29tcGxleCwgaGVyZSBhcmUgdGhlIGNhc2VzIEkgdXNlZCB0byB0aGluayBhYm91dCB0aGlzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBUaGUgdG9rZW4gc3RhcnRzIGJlZm9yZSB0aGUgZGVsZXRpb24gcmFuZ2VcbiAgICAgICAgLy8gMWEuIFRoZSB0b2tlbiBpcyBjb21wbGV0ZWx5IGJlZm9yZSB0aGUgZGVsZXRpb24gcmFuZ2VcbiAgICAgICAgLy8gICAgICAgICAgICAgICAtLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgeHh4eHh4eHh4eHhcbiAgICAgICAgLy8gMWIuIFRoZSB0b2tlbiBzdGFydHMgYmVmb3JlLCB0aGUgZGVsZXRpb24gcmFuZ2UgZW5kcyBhZnRlciB0aGUgdG9rZW5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAtLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICB4eHh4eHh4eHh4eFxuICAgICAgICAvLyAxYy4gVGhlIHRva2VuIHN0YXJ0cyBiZWZvcmUsIHRoZSBkZWxldGlvbiByYW5nZSBlbmRzIHByZWNpc2VseSB3aXRoIHRoZSB0b2tlblxuICAgICAgICAvLyAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICB4eHh4eHh4eFxuICAgICAgICAvLyAxZC4gVGhlIHRva2VuIHN0YXJ0cyBiZWZvcmUsIHRoZSBkZWxldGlvbiByYW5nZSBpcyBpbnNpZGUgdGhlIHRva2VuXG4gICAgICAgIC8vICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICB4eHh4eFxuICAgICAgICAvL1xuICAgICAgICAvLyAyLiBUaGUgdG9rZW4gc3RhcnRzIGF0IHRoZSBzYW1lIHBvc2l0aW9uIHdpdGggdGhlIGRlbGV0aW9uIHJhbmdlXG4gICAgICAgIC8vIDJhLiBUaGUgdG9rZW4gc3RhcnRzIGF0IHRoZSBzYW1lIHBvc2l0aW9uLCBhbmQgZW5kcyBpbnNpZGUgdGhlIGRlbGV0aW9uIHJhbmdlXG4gICAgICAgIC8vICAgICAgICAgICAgICAgLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgIHh4eHh4eHh4eHh4XG4gICAgICAgIC8vIDJiLiBUaGUgdG9rZW4gc3RhcnRzIGF0IHRoZSBzYW1lIHBvc2l0aW9uLCBhbmQgZW5kcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiBhcyB0aGUgZGVsZXRpb24gcmFuZ2VcbiAgICAgICAgLy8gICAgICAgICAgICAgICAtLS0tLS0tLS0tXG4gICAgICAgIC8vICAgICAgICAgICAgICAgeHh4eHh4eHh4eFxuICAgICAgICAvLyAyYy4gVGhlIHRva2VuIHN0YXJ0cyBhdCB0aGUgc2FtZSBwb3NpdGlvbiwgYW5kIGVuZHMgYWZ0ZXIgdGhlIGRlbGV0aW9uIHJhbmdlXG4gICAgICAgIC8vICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgIHh4eHh4eHhcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMy4gVGhlIHRva2VuIHN0YXJ0cyBpbnNpZGUgdGhlIGRlbGV0aW9uIHJhbmdlXG4gICAgICAgIC8vIDNhLiBUaGUgdG9rZW4gaXMgaW5zaWRlIHRoZSBkZWxldGlvbiByYW5nZVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAtLS0tLS0tXG4gICAgICAgIC8vICAgICAgICAgICAgIHh4eHh4eHh4eHh4eHhcbiAgICAgICAgLy8gM2IuIFRoZSB0b2tlbiBzdGFydHMgaW5zaWRlIHRoZSBkZWxldGlvbiByYW5nZSwgYW5kIGVuZHMgYXQgdGhlIHNhbWUgcG9zaXRpb24gYXMgdGhlIGRlbGV0aW9uIHJhbmdlXG4gICAgICAgIC8vICAgICAgICAgICAgICAgIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgeHh4eHh4eHh4eHh4eFxuICAgICAgICAvLyAzYy4gVGhlIHRva2VuIHN0YXJ0cyBpbnNpZGUgdGhlIGRlbGV0aW9uIHJhbmdlLCBhbmQgZW5kcyBhZnRlciB0aGUgZGVsZXRpb24gcmFuZ2VcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vICAgICAgICAgICAgIHh4eHh4eHh4eHh4XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDQuIFRoZSB0b2tlbiBzdGFydHMgYWZ0ZXIgdGhlIGRlbGV0aW9uIHJhbmdlXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgeHh4eHh4eHhcbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5fdG9rZW5zO1xuICAgICAgICBjb25zdCB0b2tlbkNvdW50ID0gdGhpcy5fdG9rZW5Db3VudDtcbiAgICAgICAgY29uc3QgZGVsZXRlZExpbmVDb3VudCA9IChlbmREZWx0YUxpbmUgLSBzdGFydERlbHRhTGluZSk7XG4gICAgICAgIGxldCBuZXdUb2tlbkNvdW50ID0gMDtcbiAgICAgICAgbGV0IGhhc0RlbGV0ZWRUb2tlbnMgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbkNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNyY09mZnNldCA9IDQgKiBpO1xuICAgICAgICAgICAgbGV0IHRva2VuRGVsdGFMaW5lID0gdG9rZW5zW3NyY09mZnNldF07XG4gICAgICAgICAgICBsZXQgdG9rZW5TdGFydENoYXJhY3RlciA9IHRva2Vuc1tzcmNPZmZzZXQgKyAxXTtcbiAgICAgICAgICAgIGxldCB0b2tlbkVuZENoYXJhY3RlciA9IHRva2Vuc1tzcmNPZmZzZXQgKyAyXTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuTWV0YWRhdGEgPSB0b2tlbnNbc3JjT2Zmc2V0ICsgM107XG4gICAgICAgICAgICBpZiAodG9rZW5EZWx0YUxpbmUgPCBzdGFydERlbHRhTGluZSB8fCAodG9rZW5EZWx0YUxpbmUgPT09IHN0YXJ0RGVsdGFMaW5lICYmIHRva2VuRW5kQ2hhcmFjdGVyIDw9IHN0YXJ0Q2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIDFhLiBUaGUgdG9rZW4gaXMgY29tcGxldGVseSBiZWZvcmUgdGhlIGRlbGV0aW9uIHJhbmdlXG4gICAgICAgICAgICAgICAgLy8gPT4gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgICAgIG5ld1Rva2VuQ291bnQrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuRGVsdGFMaW5lID09PSBzdGFydERlbHRhTGluZSAmJiB0b2tlblN0YXJ0Q2hhcmFjdGVyIDwgc3RhcnRDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyAxYiwgMWMsIDFkXG4gICAgICAgICAgICAgICAgLy8gPT4gdGhlIHRva2VuIHN1cnZpdmVzLCBidXQgaXQgbmVlZHMgdG8gc2hyaW5rXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRGVsdGFMaW5lID09PSBlbmREZWx0YUxpbmUgJiYgdG9rZW5FbmRDaGFyYWN0ZXIgPiBlbmRDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMWQuIFRoZSB0b2tlbiBzdGFydHMgYmVmb3JlLCB0aGUgZGVsZXRpb24gcmFuZ2UgaXMgaW5zaWRlIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAvLyA9PiB0aGUgdG9rZW4gc2hyaW5rcyBieSB0aGUgZGVsZXRpb24gY2hhcmFjdGVyIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kQ2hhcmFjdGVyIC09IChlbmRDaGFyYWN0ZXIgLSBzdGFydENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAxYi4gVGhlIHRva2VuIHN0YXJ0cyBiZWZvcmUsIHRoZSBkZWxldGlvbiByYW5nZSBlbmRzIGFmdGVyIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAvLyAxYy4gVGhlIHRva2VuIHN0YXJ0cyBiZWZvcmUsIHRoZSBkZWxldGlvbiByYW5nZSBlbmRzIHByZWNpc2VseSB3aXRoIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAvLyA9PiB0aGUgdG9rZW4gc2hyaW5rcyBpdHMgZW5kaW5nIHRvIHRoZSBkZWxldGlvbiBzdGFydFxuICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZENoYXJhY3RlciA9IHN0YXJ0Q2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuRGVsdGFMaW5lID09PSBzdGFydERlbHRhTGluZSAmJiB0b2tlblN0YXJ0Q2hhcmFjdGVyID09PSBzdGFydENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIC8vIDJhLCAyYiwgMmNcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5EZWx0YUxpbmUgPT09IGVuZERlbHRhTGluZSAmJiB0b2tlbkVuZENoYXJhY3RlciA+IGVuZENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyAyYy4gVGhlIHRva2VuIHN0YXJ0cyBhdCB0aGUgc2FtZSBwb3NpdGlvbiwgYW5kIGVuZHMgYWZ0ZXIgdGhlIGRlbGV0aW9uIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIC8vID0+IHRoZSB0b2tlbiBzaHJpbmtzIGJ5IHRoZSBkZWxldGlvbiBjaGFyYWN0ZXIgY291bnRcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmRDaGFyYWN0ZXIgLT0gKGVuZENoYXJhY3RlciAtIHN0YXJ0Q2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDJhLiBUaGUgdG9rZW4gc3RhcnRzIGF0IHRoZSBzYW1lIHBvc2l0aW9uLCBhbmQgZW5kcyBpbnNpZGUgdGhlIGRlbGV0aW9uIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIC8vIDJiLiBUaGUgdG9rZW4gc3RhcnRzIGF0IHRoZSBzYW1lIHBvc2l0aW9uLCBhbmQgZW5kcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiBhcyB0aGUgZGVsZXRpb24gcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gPT4gdGhlIHRva2VuIGlzIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgaGFzRGVsZXRlZFRva2VucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuRGVsdGFMaW5lIDwgZW5kRGVsdGFMaW5lIHx8ICh0b2tlbkRlbHRhTGluZSA9PT0gZW5kRGVsdGFMaW5lICYmIHRva2VuU3RhcnRDaGFyYWN0ZXIgPCBlbmRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gM2EsIDNiLCAzY1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkRlbHRhTGluZSA9PT0gZW5kRGVsdGFMaW5lICYmIHRva2VuRW5kQ2hhcmFjdGVyID4gZW5kQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDNjLiBUaGUgdG9rZW4gc3RhcnRzIGluc2lkZSB0aGUgZGVsZXRpb24gcmFuZ2UsIGFuZCBlbmRzIGFmdGVyIHRoZSBkZWxldGlvbiByYW5nZVxuICAgICAgICAgICAgICAgICAgICAvLyA9PiB0aGUgdG9rZW4gbW92ZXMgdG8gY29udGludWUgcmlnaHQgYWZ0ZXIgdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRva2VuRGVsdGFMaW5lID0gc3RhcnREZWx0YUxpbmU7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RhcnRDaGFyYWN0ZXIgPSBzdGFydENoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmRDaGFyYWN0ZXIgPSB0b2tlblN0YXJ0Q2hhcmFjdGVyICsgKHRva2VuRW5kQ2hhcmFjdGVyIC0gZW5kQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDNhLiBUaGUgdG9rZW4gaXMgaW5zaWRlIHRoZSBkZWxldGlvbiByYW5nZVxuICAgICAgICAgICAgICAgICAgICAvLyAzYi4gVGhlIHRva2VuIHN0YXJ0cyBpbnNpZGUgdGhlIGRlbGV0aW9uIHJhbmdlLCBhbmQgZW5kcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiBhcyB0aGUgZGVsZXRpb24gcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gPT4gdGhlIHRva2VuIGlzIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgaGFzRGVsZXRlZFRva2VucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuRGVsdGFMaW5lID4gZW5kRGVsdGFMaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gNC4gKHBhcnRpYWwpIFRoZSB0b2tlbiBzdGFydHMgYWZ0ZXIgdGhlIGRlbGV0aW9uIHJhbmdlLCBvbiBhIGxpbmUgYmVsb3cuLi5cbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlZExpbmVDb3VudCA9PT0gMCAmJiAhaGFzRGVsZXRlZFRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlYXJseSBzdG9wLCB0aGVyZSBpcyBubyBuZWVkIHRvIHdhbGsgYWxsIHRoZSB0b2tlbnMgYW5kIGRvIG5vdGhpbmcuLi5cbiAgICAgICAgICAgICAgICAgICAgbmV3VG9rZW5Db3VudCA9IHRva2VuQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbkRlbHRhTGluZSAtPSBkZWxldGVkTGluZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5EZWx0YUxpbmUgPT09IGVuZERlbHRhTGluZSAmJiB0b2tlblN0YXJ0Q2hhcmFjdGVyID49IGVuZENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIC8vIDQuIChjb250aW51ZWQpIFRoZSB0b2tlbiBzdGFydHMgYWZ0ZXIgdGhlIGRlbGV0aW9uIHJhbmdlLCBvbiB0aGUgbGFzdCBsaW5lIHdoZXJlIGEgZGVsZXRpb24gb2NjdXJzXG4gICAgICAgICAgICAgICAgaWYgKGhvcml6b250YWxTaGlmdEZvckZpcnN0TGluZVRva2VucyAmJiB0b2tlbkRlbHRhTGluZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlblN0YXJ0Q2hhcmFjdGVyICs9IGhvcml6b250YWxTaGlmdEZvckZpcnN0TGluZVRva2VucztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmRDaGFyYWN0ZXIgKz0gaG9yaXpvbnRhbFNoaWZ0Rm9yRmlyc3RMaW5lVG9rZW5zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbkRlbHRhTGluZSAtPSBkZWxldGVkTGluZUNvdW50O1xuICAgICAgICAgICAgICAgIHRva2VuU3RhcnRDaGFyYWN0ZXIgLT0gKGVuZENoYXJhY3RlciAtIHN0YXJ0Q2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICB0b2tlbkVuZENoYXJhY3RlciAtPSAoZW5kQ2hhcmFjdGVyIC0gc3RhcnRDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgcG9zc2libGUhYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXN0T2Zmc2V0ID0gNCAqIG5ld1Rva2VuQ291bnQ7XG4gICAgICAgICAgICB0b2tlbnNbZGVzdE9mZnNldF0gPSB0b2tlbkRlbHRhTGluZTtcbiAgICAgICAgICAgIHRva2Vuc1tkZXN0T2Zmc2V0ICsgMV0gPSB0b2tlblN0YXJ0Q2hhcmFjdGVyO1xuICAgICAgICAgICAgdG9rZW5zW2Rlc3RPZmZzZXQgKyAyXSA9IHRva2VuRW5kQ2hhcmFjdGVyO1xuICAgICAgICAgICAgdG9rZW5zW2Rlc3RPZmZzZXQgKyAzXSA9IHRva2VuTWV0YWRhdGE7XG4gICAgICAgICAgICBuZXdUb2tlbkNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdG9rZW5Db3VudCA9IG5ld1Rva2VuQ291bnQ7XG4gICAgfVxuICAgIGFjY2VwdEluc2VydFRleHQoZGVsdGFMaW5lLCBjaGFyYWN0ZXIsIGVvbENvdW50LCBmaXJzdExpbmVMZW5ndGgsIGxhc3RMaW5lTGVuZ3RoLCBmaXJzdENoYXJDb2RlKSB7XG4gICAgICAgIC8vIEhlcmUgYXJlIHRoZSBjYXNlcyBJIHVzZWQgdG8gdGhpbmsgYWJvdXQgdGhpczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMS4gVGhlIHRva2VuIGlzIGNvbXBsZXRlbHkgYmVmb3JlIHRoZSBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgLy8gICAgICAgICAgICAtLS0tLS0tLS0tLSAgIHxcbiAgICAgICAgLy8gMi4gVGhlIHRva2VuIGVuZHMgcHJlY2lzZWx5IGF0IHRoZSBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgLy8gICAgICAgICAgICAtLS0tLS0tLS0tLXxcbiAgICAgICAgLy8gMy4gVGhlIHRva2VuIGNvbnRhaW5zIHRoZSBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgLy8gICAgICAgICAgICAtLS0tLXwtLS0tLS1cbiAgICAgICAgLy8gNC4gVGhlIHRva2VuIHN0YXJ0cyBwcmVjaXNlbHkgYXQgdGhlIGluc2VydGlvbiBwb2ludFxuICAgICAgICAvLyAgICAgICAgICAgIHwtLS0tLS0tLS0tLVxuICAgICAgICAvLyA1LiBUaGUgdG9rZW4gaXMgY29tcGxldGVseSBhZnRlciB0aGUgaW5zZXJ0aW9uIHBvaW50XG4gICAgICAgIC8vICAgICAgICAgICAgfCAgIC0tLS0tLS0tLS0tXG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IGlzSW5zZXJ0aW5nUHJlY2lzZWx5T25lV29yZENoYXJhY3RlciA9IChlb2xDb3VudCA9PT0gMFxuICAgICAgICAgICAgJiYgZmlyc3RMaW5lTGVuZ3RoID09PSAxXG4gICAgICAgICAgICAmJiAoKGZpcnN0Q2hhckNvZGUgPj0gNDggLyogQ2hhckNvZGUuRGlnaXQwICovICYmIGZpcnN0Q2hhckNvZGUgPD0gNTcgLyogQ2hhckNvZGUuRGlnaXQ5ICovKVxuICAgICAgICAgICAgICAgIHx8IChmaXJzdENoYXJDb2RlID49IDY1IC8qIENoYXJDb2RlLkEgKi8gJiYgZmlyc3RDaGFyQ29kZSA8PSA5MCAvKiBDaGFyQ29kZS5aICovKVxuICAgICAgICAgICAgICAgIHx8IChmaXJzdENoYXJDb2RlID49IDk3IC8qIENoYXJDb2RlLmEgKi8gJiYgZmlyc3RDaGFyQ29kZSA8PSAxMjIgLyogQ2hhckNvZGUueiAqLykpKTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5fdG9rZW5zO1xuICAgICAgICBjb25zdCB0b2tlbkNvdW50ID0gdGhpcy5fdG9rZW5Db3VudDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbkNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IDQgKiBpO1xuICAgICAgICAgICAgbGV0IHRva2VuRGVsdGFMaW5lID0gdG9rZW5zW29mZnNldF07XG4gICAgICAgICAgICBsZXQgdG9rZW5TdGFydENoYXJhY3RlciA9IHRva2Vuc1tvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgIGxldCB0b2tlbkVuZENoYXJhY3RlciA9IHRva2Vuc1tvZmZzZXQgKyAyXTtcbiAgICAgICAgICAgIGlmICh0b2tlbkRlbHRhTGluZSA8IGRlbHRhTGluZSB8fCAodG9rZW5EZWx0YUxpbmUgPT09IGRlbHRhTGluZSAmJiB0b2tlbkVuZENoYXJhY3RlciA8IGNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAvLyAxLiBUaGUgdG9rZW4gaXMgY29tcGxldGVseSBiZWZvcmUgdGhlIGluc2VydGlvbiBwb2ludFxuICAgICAgICAgICAgICAgIC8vID0+IG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuRGVsdGFMaW5lID09PSBkZWx0YUxpbmUgJiYgdG9rZW5FbmRDaGFyYWN0ZXIgPT09IGNoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIC8vIDIuIFRoZSB0b2tlbiBlbmRzIHByZWNpc2VseSBhdCB0aGUgaW5zZXJ0aW9uIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gPT4gZXhwYW5kIHRoZSBlbmQgY2hhcmFjdGVyIG9ubHkgaWYgaW5zZXJ0aW5nIHByZWNpc2VseSBvbmUgY2hhcmFjdGVyIHRoYXQgaXMgYSB3b3JkIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChpc0luc2VydGluZ1ByZWNpc2VseU9uZVdvcmRDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmRDaGFyYWN0ZXIgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuRGVsdGFMaW5lID09PSBkZWx0YUxpbmUgJiYgdG9rZW5TdGFydENoYXJhY3RlciA8IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIgPCB0b2tlbkVuZENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIC8vIDMuIFRoZSB0b2tlbiBjb250YWlucyB0aGUgaW5zZXJ0aW9uIHBvaW50XG4gICAgICAgICAgICAgICAgaWYgKGVvbENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vID0+IGp1c3QgZXhwYW5kIHRoZSBlbmQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kQ2hhcmFjdGVyICs9IGZpcnN0TGluZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vID0+IGN1dCBvZmYgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kQ2hhcmFjdGVyID0gY2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDQuIG9yIDUuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRGVsdGFMaW5lID09PSBkZWx0YUxpbmUgJiYgdG9rZW5TdGFydENoYXJhY3RlciA9PT0gY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDQuIFRoZSB0b2tlbiBzdGFydHMgcHJlY2lzZWx5IGF0IHRoZSBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gPT4gZ3JvdyB0aGUgdG9rZW4gKGJ5IGtlZXBpbmcgaXRzIHN0YXJ0IGNvbnN0YW50KSBvbmx5IGlmIGluc2VydGluZyBwcmVjaXNlbHkgb25lIGNoYXJhY3RlciB0aGF0IGlzIGEgd29yZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gPT4gb3RoZXJ3aXNlIGJlaGF2ZSBhcyBpbiBjYXNlIDUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0luc2VydGluZ1ByZWNpc2VseU9uZVdvcmRDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vID0+IHRoZSB0b2tlbiBtdXN0IG1vdmUgYW5kIGtlZXAgaXRzIHNpemUgY29uc3RhbnRcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5EZWx0YUxpbmUgPT09IGRlbHRhTGluZSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkRlbHRhTGluZSArPSBlb2xDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB0b2tlbiBpcyBvbiB0aGUgbGluZSB3aGVyZSB0aGUgaW5zZXJ0aW9uIGlzIHRha2luZyBwbGFjZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW9sQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RhcnRDaGFyYWN0ZXIgKz0gZmlyc3RMaW5lTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmRDaGFyYWN0ZXIgKz0gZmlyc3RMaW5lTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5MZW5ndGggPSB0b2tlbkVuZENoYXJhY3RlciAtIHRva2VuU3RhcnRDaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0YXJ0Q2hhcmFjdGVyID0gbGFzdExpbmVMZW5ndGggKyAodG9rZW5TdGFydENoYXJhY3RlciAtIGNoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZENoYXJhY3RlciA9IHRva2VuU3RhcnRDaGFyYWN0ZXIgKyB0b2tlbkxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5EZWx0YUxpbmUgKz0gZW9sQ291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW5zW29mZnNldF0gPSB0b2tlbkRlbHRhTGluZTtcbiAgICAgICAgICAgIHRva2Vuc1tvZmZzZXQgKyAxXSA9IHRva2VuU3RhcnRDaGFyYWN0ZXI7XG4gICAgICAgICAgICB0b2tlbnNbb2Zmc2V0ICsgMl0gPSB0b2tlbkVuZENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTcGFyc2VMaW5lVG9rZW5zIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMpIHtcbiAgICAgICAgdGhpcy5fdG9rZW5zID0gdG9rZW5zO1xuICAgIH1cbiAgICBnZXRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vucy5sZW5ndGggLyA0O1xuICAgIH1cbiAgICBnZXRTdGFydENoYXJhY3Rlcih0b2tlbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbnNbNCAqIHRva2VuSW5kZXggKyAxXTtcbiAgICB9XG4gICAgZ2V0RW5kQ2hhcmFjdGVyKHRva2VuSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vuc1s0ICogdG9rZW5JbmRleCArIDJdO1xuICAgIH1cbiAgICBnZXRNZXRhZGF0YSh0b2tlbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbnNbNCAqIHRva2VuSW5kZXggKyAzXTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=