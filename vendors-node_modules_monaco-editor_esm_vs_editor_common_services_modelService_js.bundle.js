"use strict";
(self["webpackChunkpylinac_yaml_editor"] = self["webpackChunkpylinac_yaml_editor"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_editor_common_services_modelService_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/base/common/buffer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/buffer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VSBuffer: () => (/* binding */ VSBuffer),
/* harmony export */   readUInt16LE: () => (/* binding */ readUInt16LE),
/* harmony export */   readUInt32BE: () => (/* binding */ readUInt32BE),
/* harmony export */   readUInt8: () => (/* binding */ readUInt8),
/* harmony export */   writeUInt16LE: () => (/* binding */ writeUInt16LE),
/* harmony export */   writeUInt32BE: () => (/* binding */ writeUInt32BE),
/* harmony export */   writeUInt8: () => (/* binding */ writeUInt8)
/* harmony export */ });
/* harmony import */ var _lazy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lazy.js */ "./node_modules/monaco-editor/esm/vs/base/common/lazy.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const hasBuffer = (typeof Buffer !== 'undefined');
const indexOfTable = new _lazy_js__WEBPACK_IMPORTED_MODULE_0__.Lazy(() => new Uint8Array(256));
let textDecoder;
class VSBuffer {
    /**
     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
     * which is not transferrable.
     */
    static wrap(actual) {
        if (hasBuffer && !(Buffer.isBuffer(actual))) {
            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array
            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
        }
        return new VSBuffer(actual);
    }
    constructor(buffer) {
        this.buffer = buffer;
        this.byteLength = this.buffer.byteLength;
    }
    toString() {
        if (hasBuffer) {
            return this.buffer.toString();
        }
        else {
            if (!textDecoder) {
                textDecoder = new TextDecoder();
            }
            return textDecoder.decode(this.buffer);
        }
    }
}
function readUInt16LE(source, offset) {
    return (((source[offset + 0] << 0) >>> 0) |
        ((source[offset + 1] << 8) >>> 0));
}
function writeUInt16LE(destination, value, offset) {
    destination[offset + 0] = (value & 0b11111111);
    value = value >>> 8;
    destination[offset + 1] = (value & 0b11111111);
}
function readUInt32BE(source, offset) {
    return (source[offset] * 2 ** 24
        + source[offset + 1] * 2 ** 16
        + source[offset + 2] * 2 ** 8
        + source[offset + 3]);
}
function writeUInt32BE(destination, value, offset) {
    destination[offset + 3] = value;
    value = value >>> 8;
    destination[offset + 2] = value;
    value = value >>> 8;
    destination[offset + 1] = value;
    value = value >>> 8;
    destination[offset] = value;
}
function readUInt8(source, offset) {
    return source[offset];
}
function writeUInt8(destination, value, offset) {
    destination[offset] = value;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CursorColumns: () => (/* binding */ CursorColumns)
/* harmony export */ });
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * A column in a position is the gap between two adjacent characters. The methods here
 * work with a concept called "visible column". A visible column is a very rough approximation
 * of the horizontal screen position of a column. For example, using a tab size of 4:
 * ```txt
 * |<TAB>|<TAB>|T|ext
 * |     |     | \---- column = 4, visible column = 9
 * |     |     \------ column = 3, visible column = 8
 * |     \------------ column = 2, visible column = 4
 * \------------------ column = 1, visible column = 0
 * ```
 *
 * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.
 *
 * **NOTE**: These methods work and make sense both on the model and on the view model.
 */
class CursorColumns {
    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {
        if (codePoint === 9 /* CharCode.Tab */) {
            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);
        }
        if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.isFullWidthCharacter(codePoint) || _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.isEmojiImprecise(codePoint)) {
            return visibleColumn + 2;
        }
        return visibleColumn + 1;
    }
    /**
     * Returns a visible column from a column.
     * @see {@link CursorColumns}
     */
    static visibleColumnFromColumn(lineContent, column, tabSize) {
        const textLen = Math.min(column - 1, lineContent.length);
        const text = lineContent.substring(0, textLen);
        const iterator = new _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.GraphemeIterator(text);
        let result = 0;
        while (!iterator.eol()) {
            const codePoint = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.getNextCodePoint(text, textLen, iterator.offset);
            iterator.nextGraphemeLength();
            result = this._nextVisibleColumn(codePoint, result, tabSize);
        }
        return result;
    }
    /**
     * Returns a column from a visible column.
     * @see {@link CursorColumns}
     */
    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {
        if (visibleColumn <= 0) {
            return 1;
        }
        const lineContentLength = lineContent.length;
        const iterator = new _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.GraphemeIterator(lineContent);
        let beforeVisibleColumn = 0;
        let beforeColumn = 1;
        while (!iterator.eol()) {
            const codePoint = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.getNextCodePoint(lineContent, lineContentLength, iterator.offset);
            iterator.nextGraphemeLength();
            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);
            const afterColumn = iterator.offset + 1;
            if (afterVisibleColumn >= visibleColumn) {
                const beforeDelta = visibleColumn - beforeVisibleColumn;
                const afterDelta = afterVisibleColumn - visibleColumn;
                if (afterDelta < beforeDelta) {
                    return afterColumn;
                }
                else {
                    return beforeColumn;
                }
            }
            beforeVisibleColumn = afterVisibleColumn;
            beforeColumn = afterColumn;
        }
        // walked the entire string
        return lineContentLength + 1;
    }
    /**
     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
     * @see {@link CursorColumns}
     */
    static nextRenderTabStop(visibleColumn, tabSize) {
        return visibleColumn + tabSize - visibleColumn % tabSize;
    }
    /**
     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
     * @see {@link CursorColumns}
     */
    static nextIndentTabStop(visibleColumn, indentSize) {
        return visibleColumn + indentSize - visibleColumn % indentSize;
    }
    /**
     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
     * @see {@link CursorColumns}
     */
    static prevRenderTabStop(column, tabSize) {
        return Math.max(0, column - 1 - (column - 1) % tabSize);
    }
    /**
     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
     * @see {@link CursorColumns}
     */
    static prevIndentTabStop(column, indentSize) {
        return Math.max(0, column - 1 - (column - 1) % indentSize);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   normalizeIndentation: () => (/* binding */ normalizeIndentation)
/* harmony export */ });
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _cursorColumns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cursorColumns.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {
    let spacesCnt = 0;
    for (let i = 0; i < str.length; i++) {
        if (str.charAt(i) === '\t') {
            spacesCnt = _cursorColumns_js__WEBPACK_IMPORTED_MODULE_1__.CursorColumns.nextIndentTabStop(spacesCnt, indentSize);
        }
        else {
            spacesCnt++;
        }
    }
    let result = '';
    if (!insertSpaces) {
        const tabsCnt = Math.floor(spacesCnt / indentSize);
        spacesCnt = spacesCnt % indentSize;
        for (let i = 0; i < tabsCnt; i++) {
            result += '\t';
        }
    }
    for (let i = 0; i < spacesCnt; i++) {
        result += ' ';
    }
    return result;
}
function normalizeIndentation(str, indentSize, insertSpaces) {
    let firstNonWhitespaceIndex = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.firstNonWhitespaceIndex(str);
    if (firstNonWhitespaceIndex === -1) {
        firstNonWhitespaceIndex = str.length;
    }
    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringBuilder: () => (/* binding */ StringBuilder),
/* harmony export */   decodeUTF16LE: () => (/* binding */ decodeUTF16LE),
/* harmony export */   getPlatformTextDecoder: () => (/* binding */ getPlatformTextDecoder)
/* harmony export */ });
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _base_common_platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/buffer.js */ "./node_modules/monaco-editor/esm/vs/base/common/buffer.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



let _utf16LE_TextDecoder;
function getUTF16LE_TextDecoder() {
    if (!_utf16LE_TextDecoder) {
        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');
    }
    return _utf16LE_TextDecoder;
}
let _utf16BE_TextDecoder;
function getUTF16BE_TextDecoder() {
    if (!_utf16BE_TextDecoder) {
        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');
    }
    return _utf16BE_TextDecoder;
}
let _platformTextDecoder;
function getPlatformTextDecoder() {
    if (!_platformTextDecoder) {
        _platformTextDecoder = _base_common_platform_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();
    }
    return _platformTextDecoder;
}
function decodeUTF16LE(source, offset, len) {
    const view = new Uint16Array(source.buffer, offset, len);
    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {
        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark
        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)
        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained
        // So we use the manual decoder
        return compatDecodeUTF16LE(source, offset, len);
    }
    return getUTF16LE_TextDecoder().decode(view);
}
function compatDecodeUTF16LE(source, offset, len) {
    const result = [];
    let resultLen = 0;
    for (let i = 0; i < len; i++) {
        const charCode = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_2__.readUInt16LE(source, offset);
        offset += 2;
        result[resultLen++] = String.fromCharCode(charCode);
    }
    return result.join('');
}
class StringBuilder {
    constructor(capacity) {
        this._capacity = capacity | 0;
        this._buffer = new Uint16Array(this._capacity);
        this._completedStrings = null;
        this._bufferLength = 0;
    }
    reset() {
        this._completedStrings = null;
        this._bufferLength = 0;
    }
    build() {
        if (this._completedStrings !== null) {
            this._flushBuffer();
            return this._completedStrings.join('');
        }
        return this._buildBuffer();
    }
    _buildBuffer() {
        if (this._bufferLength === 0) {
            return '';
        }
        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
        return getPlatformTextDecoder().decode(view);
    }
    _flushBuffer() {
        const bufferString = this._buildBuffer();
        this._bufferLength = 0;
        if (this._completedStrings === null) {
            this._completedStrings = [bufferString];
        }
        else {
            this._completedStrings[this._completedStrings.length] = bufferString;
        }
    }
    /**
     * Append a char code (<2^16)
     */
    appendCharCode(charCode) {
        const remainingSpace = this._capacity - this._bufferLength;
        if (remainingSpace <= 1) {
            if (remainingSpace === 0 || _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.isHighSurrogate(charCode)) {
                this._flushBuffer();
            }
        }
        this._buffer[this._bufferLength++] = charCode;
    }
    /**
     * Append an ASCII char code (<2^8)
     */
    appendASCIICharCode(charCode) {
        if (this._bufferLength === this._capacity) {
            // buffer is full
            this._flushBuffer();
        }
        this._buffer[this._bufferLength++] = charCode;
    }
    appendString(str) {
        const strLen = str.length;
        if (this._bufferLength + strLen >= this._capacity) {
            // This string does not fit in the remaining buffer space
            this._flushBuffer();
            this._completedStrings[this._completedStrings.length] = str;
            return;
        }
        for (let i = 0; i < strLen; i++) {
            this._buffer[this._bufferLength++] = str.charCodeAt(i);
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextChange: () => (/* binding */ TextChange),
/* harmony export */   compressConsecutiveTextChanges: () => (/* binding */ compressConsecutiveTextChanges)
/* harmony export */ });
/* harmony import */ var _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/buffer.js */ "./node_modules/monaco-editor/esm/vs/base/common/buffer.js");
/* harmony import */ var _stringBuilder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringBuilder.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function escapeNewLine(str) {
    return (str
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r'));
}
class TextChange {
    get oldLength() {
        return this.oldText.length;
    }
    get oldEnd() {
        return this.oldPosition + this.oldText.length;
    }
    get newLength() {
        return this.newText.length;
    }
    get newEnd() {
        return this.newPosition + this.newText.length;
    }
    constructor(oldPosition, oldText, newPosition, newText) {
        this.oldPosition = oldPosition;
        this.oldText = oldText;
        this.newPosition = newPosition;
        this.newText = newText;
    }
    toString() {
        if (this.oldText.length === 0) {
            return `(insert@${this.oldPosition} "${escapeNewLine(this.newText)}")`;
        }
        if (this.newText.length === 0) {
            return `(delete@${this.oldPosition} "${escapeNewLine(this.oldText)}")`;
        }
        return `(replace@${this.oldPosition} "${escapeNewLine(this.oldText)}" with "${escapeNewLine(this.newText)}")`;
    }
    static _writeStringSize(str) {
        return (4 + 2 * str.length);
    }
    static _writeString(b, str, offset) {
        const len = str.length;
        _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt32BE(b, len, offset);
        offset += 4;
        for (let i = 0; i < len; i++) {
            _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt16LE(b, str.charCodeAt(i), offset);
            offset += 2;
        }
        return offset;
    }
    static _readString(b, offset) {
        const len = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__.readUInt32BE(b, offset);
        offset += 4;
        return (0,_stringBuilder_js__WEBPACK_IMPORTED_MODULE_1__.decodeUTF16LE)(b, offset, len);
    }
    writeSize() {
        return (+4 // oldPosition
            + 4 // newPosition
            + TextChange._writeStringSize(this.oldText)
            + TextChange._writeStringSize(this.newText));
    }
    write(b, offset) {
        _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt32BE(b, this.oldPosition, offset);
        offset += 4;
        _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt32BE(b, this.newPosition, offset);
        offset += 4;
        offset = TextChange._writeString(b, this.oldText, offset);
        offset = TextChange._writeString(b, this.newText, offset);
        return offset;
    }
    static read(b, offset, dest) {
        const oldPosition = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__.readUInt32BE(b, offset);
        offset += 4;
        const newPosition = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__.readUInt32BE(b, offset);
        offset += 4;
        const oldText = TextChange._readString(b, offset);
        offset += TextChange._writeStringSize(oldText);
        const newText = TextChange._readString(b, offset);
        offset += TextChange._writeStringSize(newText);
        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));
        return offset;
    }
}
function compressConsecutiveTextChanges(prevEdits, currEdits) {
    if (prevEdits === null || prevEdits.length === 0) {
        return currEdits;
    }
    const compressor = new TextChangeCompressor(prevEdits, currEdits);
    return compressor.compress();
}
class TextChangeCompressor {
    constructor(prevEdits, currEdits) {
        this._prevEdits = prevEdits;
        this._currEdits = currEdits;
        this._result = [];
        this._resultLen = 0;
        this._prevLen = this._prevEdits.length;
        this._prevDeltaOffset = 0;
        this._currLen = this._currEdits.length;
        this._currDeltaOffset = 0;
    }
    compress() {
        let prevIndex = 0;
        let currIndex = 0;
        let prevEdit = this._getPrev(prevIndex);
        let currEdit = this._getCurr(currIndex);
        while (prevIndex < this._prevLen || currIndex < this._currLen) {
            if (prevEdit === null) {
                this._acceptCurr(currEdit);
                currEdit = this._getCurr(++currIndex);
                continue;
            }
            if (currEdit === null) {
                this._acceptPrev(prevEdit);
                prevEdit = this._getPrev(++prevIndex);
                continue;
            }
            if (currEdit.oldEnd <= prevEdit.newPosition) {
                this._acceptCurr(currEdit);
                currEdit = this._getCurr(++currIndex);
                continue;
            }
            if (prevEdit.newEnd <= currEdit.oldPosition) {
                this._acceptPrev(prevEdit);
                prevEdit = this._getPrev(++prevIndex);
                continue;
            }
            if (currEdit.oldPosition < prevEdit.newPosition) {
                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);
                this._acceptCurr(e1);
                currEdit = e2;
                continue;
            }
            if (prevEdit.newPosition < currEdit.oldPosition) {
                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);
                this._acceptPrev(e1);
                prevEdit = e2;
                continue;
            }
            // At this point, currEdit.oldPosition === prevEdit.newPosition
            let mergePrev;
            let mergeCurr;
            if (currEdit.oldEnd === prevEdit.newEnd) {
                mergePrev = prevEdit;
                mergeCurr = currEdit;
                prevEdit = this._getPrev(++prevIndex);
                currEdit = this._getCurr(++currIndex);
            }
            else if (currEdit.oldEnd < prevEdit.newEnd) {
                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);
                mergePrev = e1;
                mergeCurr = currEdit;
                prevEdit = e2;
                currEdit = this._getCurr(++currIndex);
            }
            else {
                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);
                mergePrev = prevEdit;
                mergeCurr = e1;
                prevEdit = this._getPrev(++prevIndex);
                currEdit = e2;
            }
            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);
            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;
            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;
        }
        const merged = TextChangeCompressor._merge(this._result);
        const cleaned = TextChangeCompressor._removeNoOps(merged);
        return cleaned;
    }
    _acceptCurr(currEdit) {
        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);
        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;
    }
    _getCurr(currIndex) {
        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);
    }
    _acceptPrev(prevEdit) {
        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);
        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;
    }
    _getPrev(prevIndex) {
        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);
    }
    static _rebaseCurr(prevDeltaOffset, currEdit) {
        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);
    }
    static _rebasePrev(currDeltaOffset, prevEdit) {
        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);
    }
    static _splitPrev(edit, offset) {
        const preText = edit.newText.substr(0, offset);
        const postText = edit.newText.substr(offset);
        return [
            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),
            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)
        ];
    }
    static _splitCurr(edit, offset) {
        const preText = edit.oldText.substr(0, offset);
        const postText = edit.oldText.substr(offset);
        return [
            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),
            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')
        ];
    }
    static _merge(edits) {
        if (edits.length === 0) {
            return edits;
        }
        const result = [];
        let resultLen = 0;
        let prev = edits[0];
        for (let i = 1; i < edits.length; i++) {
            const curr = edits[i];
            if (prev.oldEnd === curr.oldPosition) {
                // Merge into `prev`
                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);
            }
            else {
                result[resultLen++] = prev;
                prev = curr;
            }
        }
        result[resultLen++] = prev;
        return result;
    }
    static _removeNoOps(edits) {
        if (edits.length === 0) {
            return edits;
        }
        const result = [];
        let resultLen = 0;
        for (let i = 0; i < edits.length; i++) {
            const edit = edits[i];
            if (edit.oldText === edit.newText) {
                continue;
            }
            result[resultLen++] = edit;
        }
        return result;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EDITOR_MODEL_DEFAULTS: () => (/* binding */ EDITOR_MODEL_DEFAULTS)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const EDITOR_MODEL_DEFAULTS = {
    tabSize: 4,
    indentSize: 4,
    insertSpaces: true,
    detectIndentation: true,
    trimAutoWhitespace: true,
    largeFileOptimizations: true,
    bracketPairColorizationOptions: {
        enabled: true,
        independentColorPoolPerBracketType: false,
    },
};


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutoClosingPairs: () => (/* binding */ AutoClosingPairs),
/* harmony export */   IndentAction: () => (/* binding */ IndentAction),
/* harmony export */   StandardAutoClosingPairConditional: () => (/* binding */ StandardAutoClosingPairConditional)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Describes what to do with the indentation when pressing Enter.
 */
var IndentAction;
(function (IndentAction) {
    /**
     * Insert new line and copy the previous line's indentation.
     */
    IndentAction[IndentAction["None"] = 0] = "None";
    /**
     * Insert new line and indent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Indent"] = 1] = "Indent";
    /**
     * Insert two new lines:
     *  - the first one indented which will hold the cursor
     *  - the second one at the same indentation level
     */
    IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
    /**
     * Insert new line and outdent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
/**
 * @internal
 */
class StandardAutoClosingPairConditional {
    constructor(source) {
        this._neutralCharacter = null;
        this._neutralCharacterSearched = false;
        this.open = source.open;
        this.close = source.close;
        // initially allowed in all tokens
        this._inString = true;
        this._inComment = true;
        this._inRegEx = true;
        if (Array.isArray(source.notIn)) {
            for (let i = 0, len = source.notIn.length; i < len; i++) {
                const notIn = source.notIn[i];
                switch (notIn) {
                    case 'string':
                        this._inString = false;
                        break;
                    case 'comment':
                        this._inComment = false;
                        break;
                    case 'regex':
                        this._inRegEx = false;
                        break;
                }
            }
        }
    }
    isOK(standardToken) {
        switch (standardToken) {
            case 0 /* StandardTokenType.Other */:
                return true;
            case 1 /* StandardTokenType.Comment */:
                return this._inComment;
            case 2 /* StandardTokenType.String */:
                return this._inString;
            case 3 /* StandardTokenType.RegEx */:
                return this._inRegEx;
        }
    }
    shouldAutoClose(context, column) {
        // Always complete on empty line
        if (context.getTokenCount() === 0) {
            return true;
        }
        const tokenIndex = context.findTokenIndexAtOffset(column - 2);
        const standardTokenType = context.getStandardTokenType(tokenIndex);
        return this.isOK(standardTokenType);
    }
    _findNeutralCharacterInRange(fromCharCode, toCharCode) {
        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {
            const character = String.fromCharCode(charCode);
            if (!this.open.includes(character) && !this.close.includes(character)) {
                return character;
            }
        }
        return null;
    }
    /**
     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
     */
    findNeutralCharacter() {
        if (!this._neutralCharacterSearched) {
            this._neutralCharacterSearched = true;
            if (!this._neutralCharacter) {
                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);
            }
            if (!this._neutralCharacter) {
                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);
            }
            if (!this._neutralCharacter) {
                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);
            }
        }
        return this._neutralCharacter;
    }
}
/**
 * @internal
 */
class AutoClosingPairs {
    constructor(autoClosingPairs) {
        this.autoClosingPairsOpenByStart = new Map();
        this.autoClosingPairsOpenByEnd = new Map();
        this.autoClosingPairsCloseByStart = new Map();
        this.autoClosingPairsCloseByEnd = new Map();
        this.autoClosingPairsCloseSingleChar = new Map();
        for (const pair of autoClosingPairs) {
            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);
            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);
            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);
            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);
            if (pair.close.length === 1 && pair.open.length === 1) {
                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);
            }
        }
    }
}
function appendEntry(target, key, value) {
    if (target.has(key)) {
        target.get(key).push(value);
    }
    else {
        target.set(key, [value]);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ILanguageConfigurationService: () => (/* binding */ ILanguageConfigurationService),
/* harmony export */   LanguageConfigurationChangeEvent: () => (/* binding */ LanguageConfigurationChangeEvent),
/* harmony export */   LanguageConfigurationRegistry: () => (/* binding */ LanguageConfigurationRegistry),
/* harmony export */   LanguageConfigurationService: () => (/* binding */ LanguageConfigurationService),
/* harmony export */   LanguageConfigurationServiceChangeEvent: () => (/* binding */ LanguageConfigurationServiceChangeEvent),
/* harmony export */   ResolvedLanguageConfiguration: () => (/* binding */ ResolvedLanguageConfiguration),
/* harmony export */   getIndentationAtPosition: () => (/* binding */ getIndentationAtPosition)
/* harmony export */ });
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/wordHelper.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js");
/* harmony import */ var _languageConfiguration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./languageConfiguration.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js");
/* harmony import */ var _supports_characterPair_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./supports/characterPair.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js");
/* harmony import */ var _supports_electricCharacter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./supports/electricCharacter.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js");
/* harmony import */ var _supports_indentRules_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./supports/indentRules.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js");
/* harmony import */ var _supports_onEnter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./supports/onEnter.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js");
/* harmony import */ var _supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./supports/richEditBrackets.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js");
/* harmony import */ var _platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../platform/instantiation/common/instantiation.js */ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js");
/* harmony import */ var _platform_configuration_common_configuration_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../platform/configuration/common/configuration.js */ "./node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js");
/* harmony import */ var _language_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./language.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/language.js");
/* harmony import */ var _platform_instantiation_common_extensions_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../platform/instantiation/common/extensions.js */ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js");
/* harmony import */ var _modesRegistry_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./modesRegistry.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js");
/* harmony import */ var _supports_languageBracketsConfiguration_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./supports/languageBracketsConfiguration.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
















class LanguageConfigurationServiceChangeEvent {
    constructor(languageId) {
        this.languageId = languageId;
    }
    affects(languageId) {
        return !this.languageId ? true : this.languageId === languageId;
    }
}
const ILanguageConfigurationService = (0,_platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_10__.createDecorator)('languageConfigurationService');
let LanguageConfigurationService = class LanguageConfigurationService extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    constructor(configurationService, languageService) {
        super();
        this.configurationService = configurationService;
        this.languageService = languageService;
        this._registry = this._register(new LanguageConfigurationRegistry());
        this.onDidChangeEmitter = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter());
        this.onDidChange = this.onDidChangeEmitter.event;
        this.configurations = new Map();
        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));
        this._register(this.configurationService.onDidChangeConfiguration((e) => {
            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));
            const localConfigChanged = e.change.overrides
                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))
                .map(([overrideLangName]) => overrideLangName);
            if (globalConfigChanged) {
                this.configurations.clear();
                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));
            }
            else {
                for (const languageId of localConfigChanged) {
                    if (this.languageService.isRegisteredLanguageId(languageId)) {
                        this.configurations.delete(languageId);
                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));
                    }
                }
            }
        }));
        this._register(this._registry.onDidChange((e) => {
            this.configurations.delete(e.languageId);
            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));
        }));
    }
    register(languageId, configuration, priority) {
        return this._registry.register(languageId, configuration, priority);
    }
    getLanguageConfiguration(languageId) {
        let result = this.configurations.get(languageId);
        if (!result) {
            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);
            this.configurations.set(languageId, result);
        }
        return result;
    }
};
LanguageConfigurationService = __decorate([
    __param(0, _platform_configuration_common_configuration_js__WEBPACK_IMPORTED_MODULE_11__.IConfigurationService),
    __param(1, _language_js__WEBPACK_IMPORTED_MODULE_12__.ILanguageService)
], LanguageConfigurationService);

function computeConfig(languageId, registry, configurationService, languageService) {
    let languageConfig = registry.getLanguageConfiguration(languageId);
    if (!languageConfig) {
        if (!languageService.isRegisteredLanguageId(languageId)) {
            // this happens for the null language, which can be returned by monarch.
            // Instead of throwing an error, we just return a default config.
            return new ResolvedLanguageConfiguration(languageId, {});
        }
        languageConfig = new ResolvedLanguageConfiguration(languageId, {});
    }
    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);
    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);
    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);
    return config;
}
const customizedLanguageConfigKeys = {
    brackets: 'editor.language.brackets',
    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'
};
function getCustomizedLanguageConfig(languageId, configurationService) {
    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {
        overrideIdentifier: languageId,
    });
    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {
        overrideIdentifier: languageId,
    });
    return {
        brackets: validateBracketPairs(brackets),
        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),
    };
}
function validateBracketPairs(data) {
    if (!Array.isArray(data)) {
        return undefined;
    }
    return data.map(pair => {
        if (!Array.isArray(pair) || pair.length !== 2) {
            return undefined;
        }
        return [pair[0], pair[1]];
    }).filter((p) => !!p);
}
function getIndentationAtPosition(model, lineNumber, column) {
    const lineText = model.getLineContent(lineNumber);
    let indentation = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.getLeadingWhitespace(lineText);
    if (indentation.length > column - 1) {
        indentation = indentation.substring(0, column - 1);
    }
    return indentation;
}
class ComposedLanguageConfiguration {
    constructor(languageId) {
        this.languageId = languageId;
        this._resolved = null;
        this._entries = [];
        this._order = 0;
        this._resolved = null;
    }
    register(configuration, priority) {
        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);
        this._entries.push(entry);
        this._resolved = null;
        return (0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
            for (let i = 0; i < this._entries.length; i++) {
                if (this._entries[i] === entry) {
                    this._entries.splice(i, 1);
                    this._resolved = null;
                    break;
                }
            }
        });
    }
    getResolvedConfiguration() {
        if (!this._resolved) {
            const config = this._resolve();
            if (config) {
                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);
            }
        }
        return this._resolved;
    }
    _resolve() {
        if (this._entries.length === 0) {
            return null;
        }
        this._entries.sort(LanguageConfigurationContribution.cmp);
        return combineLanguageConfigurations(this._entries.map(e => e.configuration));
    }
}
function combineLanguageConfigurations(configs) {
    let result = {
        comments: undefined,
        brackets: undefined,
        wordPattern: undefined,
        indentationRules: undefined,
        onEnterRules: undefined,
        autoClosingPairs: undefined,
        surroundingPairs: undefined,
        autoCloseBefore: undefined,
        folding: undefined,
        colorizedBracketPairs: undefined,
        __electricCharacterSupport: undefined,
    };
    for (const entry of configs) {
        result = {
            comments: entry.comments || result.comments,
            brackets: entry.brackets || result.brackets,
            wordPattern: entry.wordPattern || result.wordPattern,
            indentationRules: entry.indentationRules || result.indentationRules,
            onEnterRules: entry.onEnterRules || result.onEnterRules,
            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,
            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,
            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,
            folding: entry.folding || result.folding,
            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,
            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,
        };
    }
    return result;
}
class LanguageConfigurationContribution {
    constructor(configuration, priority, order) {
        this.configuration = configuration;
        this.priority = priority;
        this.order = order;
    }
    static cmp(a, b) {
        if (a.priority === b.priority) {
            // higher order last
            return a.order - b.order;
        }
        // higher priority last
        return a.priority - b.priority;
    }
}
class LanguageConfigurationChangeEvent {
    constructor(languageId) {
        this.languageId = languageId;
    }
}
class LanguageConfigurationRegistry extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    constructor() {
        super();
        this._entries = new Map();
        this._onDidChange = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter());
        this.onDidChange = this._onDidChange.event;
        this._register(this.register(_modesRegistry_js__WEBPACK_IMPORTED_MODULE_14__.PLAINTEXT_LANGUAGE_ID, {
            brackets: [
                ['(', ')'],
                ['[', ']'],
                ['{', '}'],
            ],
            surroundingPairs: [
                { open: '{', close: '}' },
                { open: '[', close: ']' },
                { open: '(', close: ')' },
                { open: '<', close: '>' },
                { open: '\"', close: '\"' },
                { open: '\'', close: '\'' },
                { open: '`', close: '`' },
            ],
            colorizedBracketPairs: [],
            folding: {
                offSide: true
            }
        }, 0));
    }
    /**
     * @param priority Use a higher number for higher priority
     */
    register(languageId, configuration, priority = 0) {
        let entries = this._entries.get(languageId);
        if (!entries) {
            entries = new ComposedLanguageConfiguration(languageId);
            this._entries.set(languageId, entries);
        }
        const disposable = entries.register(configuration, priority);
        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));
        return (0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
            disposable.dispose();
            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));
        });
    }
    getLanguageConfiguration(languageId) {
        const entries = this._entries.get(languageId);
        return entries?.getResolvedConfiguration() || null;
    }
}
/**
 * Immutable.
*/
class ResolvedLanguageConfiguration {
    constructor(languageId, underlyingConfig) {
        this.languageId = languageId;
        this.underlyingConfig = underlyingConfig;
        this._brackets = null;
        this._electricCharacter = null;
        this._onEnterSupport =
            this.underlyingConfig.brackets ||
                this.underlyingConfig.indentationRules ||
                this.underlyingConfig.onEnterRules
                ? new _supports_onEnter_js__WEBPACK_IMPORTED_MODULE_8__.OnEnterSupport(this.underlyingConfig)
                : null;
        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);
        this.characterPair = new _supports_characterPair_js__WEBPACK_IMPORTED_MODULE_5__.CharacterPairSupport(this.underlyingConfig);
        this.wordDefinition = this.underlyingConfig.wordPattern || _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_WORD_REGEXP;
        this.indentationRules = this.underlyingConfig.indentationRules;
        if (this.underlyingConfig.indentationRules) {
            this.indentRulesSupport = new _supports_indentRules_js__WEBPACK_IMPORTED_MODULE_7__.IndentRulesSupport(this.underlyingConfig.indentationRules);
        }
        else {
            this.indentRulesSupport = null;
        }
        this.foldingRules = this.underlyingConfig.folding || {};
        this.bracketsNew = new _supports_languageBracketsConfiguration_js__WEBPACK_IMPORTED_MODULE_15__.LanguageBracketsConfiguration(languageId, this.underlyingConfig);
    }
    getWordDefinition() {
        return (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_3__.ensureValidWordDefinition)(this.wordDefinition);
    }
    get brackets() {
        if (!this._brackets && this.underlyingConfig.brackets) {
            this._brackets = new _supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_9__.RichEditBrackets(this.languageId, this.underlyingConfig.brackets);
        }
        return this._brackets;
    }
    get electricCharacter() {
        if (!this._electricCharacter) {
            this._electricCharacter = new _supports_electricCharacter_js__WEBPACK_IMPORTED_MODULE_6__.BracketElectricCharacterSupport(this.brackets);
        }
        return this._electricCharacter;
    }
    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {
        if (!this._onEnterSupport) {
            return null;
        }
        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);
    }
    getAutoClosingPairs() {
        return new _languageConfiguration_js__WEBPACK_IMPORTED_MODULE_4__.AutoClosingPairs(this.characterPair.getAutoClosingPairs());
    }
    getAutoCloseBeforeSet(forQuotes) {
        return this.characterPair.getAutoCloseBeforeSet(forQuotes);
    }
    getSurroundingPairs() {
        return this.characterPair.getSurroundingPairs();
    }
    static _handleComments(conf) {
        const commentRule = conf.comments;
        if (!commentRule) {
            return null;
        }
        // comment configuration
        const comments = {};
        if (commentRule.lineComment) {
            comments.lineCommentToken = commentRule.lineComment;
        }
        if (commentRule.blockComment) {
            const [blockStart, blockEnd] = commentRule.blockComment;
            comments.blockCommentStartToken = blockStart;
            comments.blockCommentEndToken = blockEnd;
        }
        return comments;
    }
}
(0,_platform_instantiation_common_extensions_js__WEBPACK_IMPORTED_MODULE_13__.registerSingleton)(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NullState: () => (/* binding */ NullState),
/* harmony export */   nullTokenize: () => (/* binding */ nullTokenize),
/* harmony export */   nullTokenizeEncoded: () => (/* binding */ nullTokenizeEncoded)
/* harmony export */ });
/* harmony import */ var _languages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../languages.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const NullState = new class {
    clone() {
        return this;
    }
    equals(other) {
        return (this === other);
    }
};
function nullTokenize(languageId, state) {
    return new _languages_js__WEBPACK_IMPORTED_MODULE_0__.TokenizationResult([new _languages_js__WEBPACK_IMPORTED_MODULE_0__.Token(0, '', languageId)], state);
}
function nullTokenizeEncoded(languageId, state) {
    const tokens = new Uint32Array(2);
    tokens[0] = 0;
    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)
        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)
        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)
        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)
        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;
    return new _languages_js__WEBPACK_IMPORTED_MODULE_0__.EncodedTokenizationResult(tokens, state === null ? NullState : state);
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScopedLineTokens: () => (/* binding */ ScopedLineTokens),
/* harmony export */   createScopedLineTokens: () => (/* binding */ createScopedLineTokens),
/* harmony export */   ignoreBracketsInToken: () => (/* binding */ ignoreBracketsInToken)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function createScopedLineTokens(context, offset) {
    const tokenCount = context.getCount();
    const tokenIndex = context.findTokenIndexAtOffset(offset);
    const desiredLanguageId = context.getLanguageId(tokenIndex);
    let lastTokenIndex = tokenIndex;
    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {
        lastTokenIndex++;
    }
    let firstTokenIndex = tokenIndex;
    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {
        firstTokenIndex--;
    }
    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));
}
class ScopedLineTokens {
    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {
        this._scopedLineTokensBrand = undefined;
        this._actual = actual;
        this.languageId = languageId;
        this._firstTokenIndex = firstTokenIndex;
        this._lastTokenIndex = lastTokenIndex;
        this.firstCharOffset = firstCharOffset;
        this._lastCharOffset = lastCharOffset;
        this.languageIdCodec = actual.languageIdCodec;
    }
    getLineContent() {
        const actualLineContent = this._actual.getLineContent();
        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);
    }
    getLineLength() {
        return this._lastCharOffset - this.firstCharOffset;
    }
    getActualLineContentBefore(offset) {
        const actualLineContent = this._actual.getLineContent();
        return actualLineContent.substring(0, this.firstCharOffset + offset);
    }
    getTokenCount() {
        return this._lastTokenIndex - this._firstTokenIndex;
    }
    findTokenIndexAtOffset(offset) {
        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;
    }
    getStandardTokenType(tokenIndex) {
        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);
    }
    toIViewLineTokens() {
        return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);
    }
}
function ignoreBracketsInToken(standardTokenType) {
    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CharacterPairSupport: () => (/* binding */ CharacterPairSupport)
/* harmony export */ });
/* harmony import */ var _languageConfiguration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../languageConfiguration.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class CharacterPairSupport {
    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \n\t'; }
    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\'"`;:.,=}])> \n\t'; }
    constructor(config) {
        if (config.autoClosingPairs) {
            this._autoClosingPairs = config.autoClosingPairs.map(el => new _languageConfiguration_js__WEBPACK_IMPORTED_MODULE_0__.StandardAutoClosingPairConditional(el));
        }
        else if (config.brackets) {
            this._autoClosingPairs = config.brackets.map(b => new _languageConfiguration_js__WEBPACK_IMPORTED_MODULE_0__.StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));
        }
        else {
            this._autoClosingPairs = [];
        }
        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {
            const docComment = config.__electricCharacterSupport.docComment;
            // IDocComment is legacy, only partially supported
            this._autoClosingPairs.push(new _languageConfiguration_js__WEBPACK_IMPORTED_MODULE_0__.StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));
        }
        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;
        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;
        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;
    }
    getAutoClosingPairs() {
        return this._autoClosingPairs;
    }
    getAutoCloseBeforeSet(forQuotes) {
        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);
    }
    getSurroundingPairs() {
        return this._surroundingPairs;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BracketElectricCharacterSupport: () => (/* binding */ BracketElectricCharacterSupport)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _supports_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../supports.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js");
/* harmony import */ var _richEditBrackets_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./richEditBrackets.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class BracketElectricCharacterSupport {
    constructor(richEditBrackets) {
        this._richEditBrackets = richEditBrackets;
    }
    getElectricCharacters() {
        const result = [];
        if (this._richEditBrackets) {
            for (const bracket of this._richEditBrackets.brackets) {
                for (const close of bracket.close) {
                    const lastChar = close.charAt(close.length - 1);
                    result.push(lastChar);
                }
            }
        }
        return (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.distinct)(result);
    }
    onElectricCharacter(character, context, column) {
        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {
            return null;
        }
        const tokenIndex = context.findTokenIndexAtOffset(column - 1);
        if ((0,_supports_js__WEBPACK_IMPORTED_MODULE_1__.ignoreBracketsInToken)(context.getStandardTokenType(tokenIndex))) {
            return null;
        }
        const reversedBracketRegex = this._richEditBrackets.reversedRegex;
        const text = context.getLineContent().substring(0, column - 1) + character;
        const r = _richEditBrackets_js__WEBPACK_IMPORTED_MODULE_2__.BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);
        if (!r) {
            return null;
        }
        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];
        if (isOpen) {
            return null;
        }
        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);
        if (!/^\s*$/.test(textBeforeBracket)) {
            // There is other text on the line before the bracket
            return null;
        }
        return {
            matchOpenBracket: bracketText
        };
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IndentRulesSupport: () => (/* binding */ IndentRulesSupport)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function resetGlobalRegex(reg) {
    if (reg.global) {
        reg.lastIndex = 0;
    }
    return true;
}
class IndentRulesSupport {
    constructor(indentationRules) {
        this._indentationRules = indentationRules;
    }
    shouldIncrease(text) {
        if (this._indentationRules) {
            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {
                return true;
            }
            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {
            // 	return true;
            // }
        }
        return false;
    }
    shouldDecrease(text) {
        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {
            return true;
        }
        return false;
    }
    shouldIndentNextLine(text) {
        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {
            return true;
        }
        return false;
    }
    shouldIgnore(text) {
        // the text matches `unIndentedLinePattern`
        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {
            return true;
        }
        return false;
    }
    getIndentMetadata(text) {
        let ret = 0;
        if (this.shouldIncrease(text)) {
            ret += 1 /* IndentConsts.INCREASE_MASK */;
        }
        if (this.shouldDecrease(text)) {
            ret += 2 /* IndentConsts.DECREASE_MASK */;
        }
        if (this.shouldIndentNextLine(text)) {
            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;
        }
        if (this.shouldIgnore(text)) {
            ret += 8 /* IndentConsts.UNINDENT_MASK */;
        }
        return ret;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BracketKindBase: () => (/* binding */ BracketKindBase),
/* harmony export */   ClosingBracketKind: () => (/* binding */ ClosingBracketKind),
/* harmony export */   LanguageBracketsConfiguration: () => (/* binding */ LanguageBracketsConfiguration),
/* harmony export */   OpeningBracketKind: () => (/* binding */ OpeningBracketKind)
/* harmony export */ });
/* harmony import */ var _base_common_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/cache.js */ "./node_modules/monaco-editor/esm/vs/base/common/cache.js");
/* harmony import */ var _richEditBrackets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./richEditBrackets.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * Captures all bracket related configurations for a single language.
 * Immutable.
*/
class LanguageBracketsConfiguration {
    constructor(languageId, config) {
        this.languageId = languageId;
        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];
        const openingBracketInfos = new _base_common_cache_js__WEBPACK_IMPORTED_MODULE_0__.CachedFunction((bracket) => {
            const closing = new Set();
            return {
                info: new OpeningBracketKind(this, bracket, closing),
                closing,
            };
        });
        const closingBracketInfos = new _base_common_cache_js__WEBPACK_IMPORTED_MODULE_0__.CachedFunction((bracket) => {
            const opening = new Set();
            const openingColorized = new Set();
            return {
                info: new ClosingBracketKind(this, bracket, opening, openingColorized),
                opening,
                openingColorized,
            };
        });
        for (const [open, close] of bracketPairs) {
            const opening = openingBracketInfos.get(open);
            const closing = closingBracketInfos.get(close);
            opening.closing.add(closing.info);
            closing.opening.add(opening.info);
        }
        // Treat colorized brackets as brackets, and mark them as colorized.
        const colorizedBracketPairs = config.colorizedBracketPairs
            ? filterValidBrackets(config.colorizedBracketPairs)
            // If not configured: Take all brackets except `<` ... `>`
            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.
            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.
            // https://github.com/microsoft/vscode/issues/132476
            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));
        for (const [open, close] of colorizedBracketPairs) {
            const opening = openingBracketInfos.get(open);
            const closing = closingBracketInfos.get(close);
            opening.closing.add(closing.info);
            closing.openingColorized.add(opening.info);
            closing.opening.add(opening.info);
        }
        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));
        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));
    }
    /**
     * No two brackets have the same bracket text.
    */
    get openingBrackets() {
        return [...this._openingBrackets.values()];
    }
    /**
     * No two brackets have the same bracket text.
    */
    get closingBrackets() {
        return [...this._closingBrackets.values()];
    }
    getOpeningBracketInfo(bracketText) {
        return this._openingBrackets.get(bracketText);
    }
    getClosingBracketInfo(bracketText) {
        return this._closingBrackets.get(bracketText);
    }
    getBracketInfo(bracketText) {
        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);
    }
    getBracketRegExp(options) {
        const brackets = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);
        return (0,_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_1__.createBracketOrRegExp)(brackets, options);
    }
}
function filterValidBrackets(bracketPairs) {
    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');
}
class BracketKindBase {
    constructor(config, bracketText) {
        this.config = config;
        this.bracketText = bracketText;
    }
    get languageId() {
        return this.config.languageId;
    }
}
class OpeningBracketKind extends BracketKindBase {
    constructor(config, bracketText, openedBrackets) {
        super(config, bracketText);
        this.openedBrackets = openedBrackets;
        this.isOpeningBracket = true;
    }
}
class ClosingBracketKind extends BracketKindBase {
    constructor(config, bracketText, 
    /**
     * Non empty array of all opening brackets this bracket closes.
    */
    openingBrackets, openingColorizedBrackets) {
        super(config, bracketText);
        this.openingBrackets = openingBrackets;
        this.openingColorizedBrackets = openingColorizedBrackets;
        this.isOpeningBracket = false;
    }
    /**
     * Checks if this bracket closes the given other bracket.
     * If the bracket infos come from different configurations, this method will return false.
    */
    closes(other) {
        if (other['config'] !== this.config) {
            return false;
        }
        return this.openingBrackets.has(other);
    }
    closesColorized(other) {
        if (other['config'] !== this.config) {
            return false;
        }
        return this.openingColorizedBrackets.has(other);
    }
    getOpeningBrackets() {
        return [...this.openingBrackets];
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OnEnterSupport: () => (/* binding */ OnEnterSupport)
/* harmony export */ });
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _languageConfiguration_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../languageConfiguration.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class OnEnterSupport {
    constructor(opts) {
        opts = opts || {};
        opts.brackets = opts.brackets || [
            ['(', ')'],
            ['{', '}'],
            ['[', ']']
        ];
        this._brackets = [];
        opts.brackets.forEach((bracket) => {
            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);
            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);
            if (openRegExp && closeRegExp) {
                this._brackets.push({
                    open: bracket[0],
                    openRegExp: openRegExp,
                    close: bracket[1],
                    closeRegExp: closeRegExp,
                });
            }
        });
        this._regExpRules = opts.onEnterRules || [];
    }
    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {
        // (1): `regExpRules`
        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {
            for (let i = 0, len = this._regExpRules.length; i < len; i++) {
                const rule = this._regExpRules[i];
                const regResult = [{
                        reg: rule.beforeText,
                        text: beforeEnterText
                    }, {
                        reg: rule.afterText,
                        text: afterEnterText
                    }, {
                        reg: rule.previousLineText,
                        text: previousLineText
                    }].every((obj) => {
                    if (!obj.reg) {
                        return true;
                    }
                    obj.reg.lastIndex = 0; // To disable the effect of the "g" flag.
                    return obj.reg.test(obj.text);
                });
                if (regResult) {
                    return rule.action;
                }
            }
        }
        // (2): Special indent-outdent
        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {
            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {
                for (let i = 0, len = this._brackets.length; i < len; i++) {
                    const bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {
                        return { indentAction: _languageConfiguration_js__WEBPACK_IMPORTED_MODULE_2__.IndentAction.IndentOutdent };
                    }
                }
            }
        }
        // (4): Open bracket based logic
        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {
            if (beforeEnterText.length > 0) {
                for (let i = 0, len = this._brackets.length; i < len; i++) {
                    const bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText)) {
                        return { indentAction: _languageConfiguration_js__WEBPACK_IMPORTED_MODULE_2__.IndentAction.Indent };
                    }
                }
            }
        }
        return null;
    }
    static _createOpenBracketRegExp(bracket) {
        let str = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.escapeRegExpCharacters(bracket);
        if (!/\B/.test(str.charAt(0))) {
            str = '\\b' + str;
        }
        str += '\\s*$';
        return OnEnterSupport._safeRegExp(str);
    }
    static _createCloseBracketRegExp(bracket) {
        let str = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.escapeRegExpCharacters(bracket);
        if (!/\B/.test(str.charAt(str.length - 1))) {
            str = str + '\\b';
        }
        str = '^\\s*' + str;
        return OnEnterSupport._safeRegExp(str);
    }
    static _safeRegExp(def) {
        try {
            return new RegExp(def);
        }
        catch (err) {
            (0,_base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(err);
            return null;
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BracketsUtils: () => (/* binding */ BracketsUtils),
/* harmony export */   RichEditBracket: () => (/* binding */ RichEditBracket),
/* harmony export */   RichEditBrackets: () => (/* binding */ RichEditBrackets),
/* harmony export */   createBracketOrRegExp: () => (/* binding */ createBracketOrRegExp)
/* harmony export */ });
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _core_stringBuilder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/stringBuilder.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



/**
 * Represents a grouping of colliding bracket pairs.
 *
 * Most of the times this contains a single bracket pair,
 * but sometimes this contains multiple bracket pairs in cases
 * where the same string appears as a closing bracket for multiple
 * bracket pairs, or the same string appears an opening bracket for
 * multiple bracket pairs.
 *
 * e.g. of a group containing a single pair:
 *   open: ['{'], close: ['}']
 *
 * e.g. of a group containing multiple pairs:
 *   open: ['if', 'for'], close: ['end', 'end']
 */
class RichEditBracket {
    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {
        this._richEditBracketBrand = undefined;
        this.languageId = languageId;
        this.index = index;
        this.open = open;
        this.close = close;
        this.forwardRegex = forwardRegex;
        this.reversedRegex = reversedRegex;
        this._openSet = RichEditBracket._toSet(this.open);
        this._closeSet = RichEditBracket._toSet(this.close);
    }
    /**
     * Check if the provided `text` is an open bracket in this group.
     */
    isOpen(text) {
        return this._openSet.has(text);
    }
    /**
     * Check if the provided `text` is a close bracket in this group.
     */
    isClose(text) {
        return this._closeSet.has(text);
    }
    static _toSet(arr) {
        const result = new Set();
        for (const element of arr) {
            result.add(element);
        }
        return result;
    }
}
/**
 * Groups together brackets that have equal open or close sequences.
 *
 * For example, if the following brackets are defined:
 *   ['IF','END']
 *   ['for','end']
 *   ['{','}']
 *
 * Then the grouped brackets would be:
 *   { open: ['if', 'for'], close: ['end', 'end'] }
 *   { open: ['{'], close: ['}'] }
 *
 */
function groupFuzzyBrackets(brackets) {
    const N = brackets.length;
    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);
    const group = [];
    for (let i = 0; i < N; i++) {
        group[i] = i;
    }
    const areOverlapping = (a, b) => {
        const [aOpen, aClose] = a;
        const [bOpen, bClose] = b;
        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);
    };
    const mergeGroups = (g1, g2) => {
        const newG = Math.min(g1, g2);
        const oldG = Math.max(g1, g2);
        for (let i = 0; i < N; i++) {
            if (group[i] === oldG) {
                group[i] = newG;
            }
        }
    };
    // group together brackets that have the same open or the same close sequence
    for (let i = 0; i < N; i++) {
        const a = brackets[i];
        for (let j = i + 1; j < N; j++) {
            const b = brackets[j];
            if (areOverlapping(a, b)) {
                mergeGroups(group[i], group[j]);
            }
        }
    }
    const result = [];
    for (let g = 0; g < N; g++) {
        const currentOpen = [];
        const currentClose = [];
        for (let i = 0; i < N; i++) {
            if (group[i] === g) {
                const [open, close] = brackets[i];
                currentOpen.push(open);
                currentClose.push(close);
            }
        }
        if (currentOpen.length > 0) {
            result.push({
                open: currentOpen,
                close: currentClose
            });
        }
    }
    return result;
}
class RichEditBrackets {
    constructor(languageId, _brackets) {
        this._richEditBracketsBrand = undefined;
        const brackets = groupFuzzyBrackets(_brackets);
        this.brackets = brackets.map((b, index) => {
            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));
        });
        this.forwardRegex = getRegexForBrackets(this.brackets);
        this.reversedRegex = getReversedRegexForBrackets(this.brackets);
        this.textIsBracket = {};
        this.textIsOpenBracket = {};
        this.maxBracketLength = 0;
        for (const bracket of this.brackets) {
            for (const open of bracket.open) {
                this.textIsBracket[open] = bracket;
                this.textIsOpenBracket[open] = true;
                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);
            }
            for (const close of bracket.close) {
                this.textIsBracket[close] = bracket;
                this.textIsOpenBracket[close] = false;
                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);
            }
        }
    }
}
function collectSuperstrings(str, brackets, currentIndex, dest) {
    for (let i = 0, len = brackets.length; i < len; i++) {
        if (i === currentIndex) {
            continue;
        }
        const bracket = brackets[i];
        for (const open of bracket.open) {
            if (open.indexOf(str) >= 0) {
                dest.push(open);
            }
        }
        for (const close of bracket.close) {
            if (close.indexOf(str) >= 0) {
                dest.push(close);
            }
        }
    }
}
function lengthcmp(a, b) {
    return a.length - b.length;
}
function unique(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    const result = [];
    const seen = new Set();
    for (const element of arr) {
        if (seen.has(element)) {
            continue;
        }
        result.push(element);
        seen.add(element);
    }
    return result;
}
/**
 * Create a regular expression that can be used to search forward in a piece of text
 * for a group of bracket pairs. But this regex must be built in a way in which
 * it is aware of the other bracket pairs defined for the language.
 *
 * For example, if a language contains the following bracket pairs:
 *   ['begin', 'end']
 *   ['if', 'end if']
 * The two bracket pairs do not collide because no open or close brackets are equal.
 * So the function getRegexForBracketPair is called twice, once with
 * the ['begin'], ['end'] group consisting of one bracket pair, and once with
 * the ['if'], ['end if'] group consiting of the other bracket pair.
 *
 * But there could be a situation where an occurrence of 'end if' is mistaken
 * for an occurrence of 'end'.
 *
 * Therefore, for the bracket pair ['begin', 'end'], the regex will also
 * target 'end if'. The regex will be something like:
 *   /(\bend if\b)|(\bend\b)|(\bif\b)/
 *
 * The regex also searches for "superstrings" (other brackets that might be mistaken with the current bracket).
 *
 */
function getRegexForBracketPair(open, close, brackets, currentIndex) {
    // search in all brackets for other brackets that are a superstring of these brackets
    let pieces = [];
    pieces = pieces.concat(open);
    pieces = pieces.concat(close);
    for (let i = 0, len = pieces.length; i < len; i++) {
        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);
    }
    pieces = unique(pieces);
    pieces.sort(lengthcmp);
    pieces.reverse();
    return createBracketOrRegExp(pieces);
}
/**
 * Matching a regular expression in JS can only be done "forwards". So JS offers natively only
 * methods to find the first match of a regex in a string. But sometimes, it is useful to
 * find the last match of a regex in a string. For such a situation, a nice solution is to
 * simply reverse the string and then search for a reversed regex.
 *
 * This function also has the fine details of `getRegexForBracketPair`. For the same example
 * given above, the regex produced here would look like:
 *   /(\bfi dne\b)|(\bdne\b)|(\bfi\b)/
 */
function getReversedRegexForBracketPair(open, close, brackets, currentIndex) {
    // search in all brackets for other brackets that are a superstring of these brackets
    let pieces = [];
    pieces = pieces.concat(open);
    pieces = pieces.concat(close);
    for (let i = 0, len = pieces.length; i < len; i++) {
        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);
    }
    pieces = unique(pieces);
    pieces.sort(lengthcmp);
    pieces.reverse();
    return createBracketOrRegExp(pieces.map(toReversedString));
}
/**
 * Creates a regular expression that targets all bracket pairs.
 *
 * e.g. for the bracket pairs:
 *  ['{','}']
 *  ['begin,'end']
 *  ['for','end']
 * the regex would look like:
 *  /(\{)|(\})|(\bbegin\b)|(\bend\b)|(\bfor\b)/
 */
function getRegexForBrackets(brackets) {
    let pieces = [];
    for (const bracket of brackets) {
        for (const open of bracket.open) {
            pieces.push(open);
        }
        for (const close of bracket.close) {
            pieces.push(close);
        }
    }
    pieces = unique(pieces);
    return createBracketOrRegExp(pieces);
}
/**
 * Matching a regular expression in JS can only be done "forwards". So JS offers natively only
 * methods to find the first match of a regex in a string. But sometimes, it is useful to
 * find the last match of a regex in a string. For such a situation, a nice solution is to
 * simply reverse the string and then search for a reversed regex.
 *
 * e.g. for the bracket pairs:
 *  ['{','}']
 *  ['begin,'end']
 *  ['for','end']
 * the regex would look like:
 *  /(\{)|(\})|(\bnigeb\b)|(\bdne\b)|(\brof\b)/
 */
function getReversedRegexForBrackets(brackets) {
    let pieces = [];
    for (const bracket of brackets) {
        for (const open of bracket.open) {
            pieces.push(open);
        }
        for (const close of bracket.close) {
            pieces.push(close);
        }
    }
    pieces = unique(pieces);
    return createBracketOrRegExp(pieces.map(toReversedString));
}
function prepareBracketForRegExp(str) {
    // This bracket pair uses letters like e.g. "begin" - "end"
    const insertWordBoundaries = (/^[\w ]+$/.test(str));
    str = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.escapeRegExpCharacters(str);
    return (insertWordBoundaries ? `\\b${str}\\b` : str);
}
function createBracketOrRegExp(pieces, options) {
    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;
    return _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.createRegExp(regexStr, true, options);
}
const toReversedString = (function () {
    function reverse(str) {
        // create a Uint16Array and then use a TextDecoder to create a string
        const arr = new Uint16Array(str.length);
        let offset = 0;
        for (let i = str.length - 1; i >= 0; i--) {
            arr[offset++] = str.charCodeAt(i);
        }
        return _core_stringBuilder_js__WEBPACK_IMPORTED_MODULE_1__.getPlatformTextDecoder().decode(arr);
    }
    let lastInput = null;
    let lastOutput = null;
    return function toReversedString(str) {
        if (lastInput !== str) {
            lastInput = str;
            lastOutput = reverse(lastInput);
        }
        return lastOutput;
    };
})();
class BracketsUtils {
    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {
        const m = reversedText.match(reversedBracketRegex);
        if (!m) {
            return null;
        }
        const matchOffset = reversedText.length - (m.index || 0);
        const matchLength = m[0].length;
        const absoluteMatchOffset = offset + matchOffset;
        return new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);
    }
    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {
        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)
        const reversedLineText = toReversedString(lineText);
        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);
        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);
    }
    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {
        const m = text.match(bracketRegex);
        if (!m) {
            return null;
        }
        const matchOffset = m.index || 0;
        const matchLength = m[0].length;
        if (matchLength === 0) {
            return null;
        }
        const absoluteMatchOffset = offset + matchOffset;
        return new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);
    }
    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {
        const substr = lineText.substring(startOffset, endOffset);
        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BracketPairsTextModelPart: () => (/* binding */ BracketPairsTextModelPart)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _languages_supports_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../languages/supports.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js");
/* harmony import */ var _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../languages/supports/richEditBrackets.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js");
/* harmony import */ var _bracketPairsTree_bracketPairsTree_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bracketPairsTree/bracketPairsTree.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/







class BracketPairsTextModelPart extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable {
    get canBuildAST() {
        const maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;
        return this.textModel.getValueLength() <= maxSupportedDocumentLength;
    }
    constructor(textModel, languageConfigurationService) {
        super();
        this.textModel = textModel;
        this.languageConfigurationService = languageConfigurationService;
        this.bracketPairsTree = this._register(new _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.MutableDisposable());
        this.onDidChangeEmitter = new _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.bracketsRequested = false;
    }
    //#region TextModel events
    handleLanguageConfigurationServiceChange(e) {
        if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {
            this.bracketPairsTree.clear();
            this.updateBracketPairsTree();
        }
    }
    handleDidChangeOptions(e) {
        this.bracketPairsTree.clear();
        this.updateBracketPairsTree();
    }
    handleDidChangeLanguage(e) {
        this.bracketPairsTree.clear();
        this.updateBracketPairsTree();
    }
    handleDidChangeContent(change) {
        this.bracketPairsTree.value?.object.handleContentChanged(change);
    }
    handleDidChangeBackgroundTokenizationState() {
        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();
    }
    handleDidChangeTokens(e) {
        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);
    }
    //#endregion
    updateBracketPairsTree() {
        if (this.bracketsRequested && this.canBuildAST) {
            if (!this.bracketPairsTree.value) {
                const store = new _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStore();
                this.bracketPairsTree.value = createDisposableRef(store.add(new _bracketPairsTree_bracketPairsTree_js__WEBPACK_IMPORTED_MODULE_6__.BracketPairsTree(this.textModel, (languageId) => {
                    return this.languageConfigurationService.getLanguageConfiguration(languageId);
                })), store);
                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));
                this.onDidChangeEmitter.fire();
            }
        }
        else {
            if (this.bracketPairsTree.value) {
                this.bracketPairsTree.clear();
                // Important: Don't call fire if there was no change!
                this.onDidChangeEmitter.fire();
            }
        }
    }
    /**
     * Returns all bracket pairs that intersect the given range.
     * The result is sorted by the start position.
    */
    getBracketPairsInRange(range) {
        this.bracketsRequested = true;
        this.updateBracketPairsTree();
        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.CallbackIterable.empty;
    }
    getBracketPairsInRangeWithMinIndentation(range) {
        this.bracketsRequested = true;
        this.updateBracketPairsTree();
        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.CallbackIterable.empty;
    }
    getBracketsInRange(range, onlyColorizedBrackets = false) {
        this.bracketsRequested = true;
        this.updateBracketPairsTree();
        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.CallbackIterable.empty;
    }
    findMatchingBracketUp(_bracket, _position, maxDuration) {
        const position = this.textModel.validatePosition(_position);
        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);
        if (this.canBuildAST) {
            const closingBracketInfo = this.languageConfigurationService
                .getLanguageConfiguration(languageId)
                .bracketsNew.getClosingBracketInfo(_bracket);
            if (!closingBracketInfo) {
                return null;
            }
            const bracketPair = this.getBracketPairsInRange(_core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));
            if (bracketPair) {
                return bracketPair.openingBracketRange;
            }
            return null;
        }
        else {
            // Fallback to old bracket matching code:
            const bracket = _bracket.toLowerCase();
            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
            if (!bracketsSupport) {
                return null;
            }
            const data = bracketsSupport.textIsBracket[bracket];
            if (!data) {
                return null;
            }
            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));
        }
    }
    matchBracket(position, maxDuration) {
        if (this.canBuildAST) {
            const bracketPair = this.getBracketPairsInRange(_core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&
                (item.openingBracketRange.containsPosition(position) ||
                    item.closingBracketRange.containsPosition(position))).findLastMaxBy((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.compareBy)((item) => item.openingBracketRange.containsPosition(position)
                ? item.openingBracketRange
                : item.closingBracketRange, _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.compareRangesUsingStarts));
            if (bracketPair) {
                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];
            }
            return null;
        }
        else {
            // Fallback to old bracket matching code:
            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);
            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);
        }
    }
    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {
        const tokenCount = lineTokens.getCount();
        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);
        // limit search to not go before `maxBracketLength`
        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);
        for (let i = tokenIndex - 1; i >= 0; i--) {
            const tokenEndOffset = lineTokens.getEndOffset(i);
            if (tokenEndOffset <= searchStartOffset) {
                break;
            }
            if ((0,_languages_supports_js__WEBPACK_IMPORTED_MODULE_4__.ignoreBracketsInToken)(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {
                searchStartOffset = tokenEndOffset;
                break;
            }
        }
        // limit search to not go after `maxBracketLength`
        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);
        for (let i = tokenIndex + 1; i < tokenCount; i++) {
            const tokenStartOffset = lineTokens.getStartOffset(i);
            if (tokenStartOffset >= searchEndOffset) {
                break;
            }
            if ((0,_languages_supports_js__WEBPACK_IMPORTED_MODULE_4__.ignoreBracketsInToken)(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {
                searchEndOffset = tokenStartOffset;
                break;
            }
        }
        return { searchStartOffset, searchEndOffset };
    }
    _matchBracket(position, continueSearchPredicate) {
        const lineNumber = position.lineNumber;
        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
        const lineText = this.textModel.getLineContent(lineNumber);
        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        if (tokenIndex < 0) {
            return null;
        }
        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;
        // check that the token is not to be ignored
        if (currentModeBrackets && !(0,_languages_supports_js__WEBPACK_IMPORTED_MODULE_4__.ignoreBracketsInToken)(lineTokens.getStandardTokenType(tokenIndex))) {
            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);
            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets
            // `bestResult` will contain the most right-side result
            let bestResult = null;
            while (true) {
                const foundBracket = _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__.BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (!foundBracket) {
                    // there are no more brackets in this text
                    break;
                }
                // check that we didn't hit a bracket too far away from position
                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();
                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);
                    if (r) {
                        if (r instanceof BracketSearchCanceled) {
                            return null;
                        }
                        bestResult = r;
                    }
                }
                searchStartOffset = foundBracket.endColumn - 1;
            }
            if (bestResult) {
                return bestResult;
            }
        }
        // If position is in between two tokens, try also looking in the previous token
        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {
            const prevTokenIndex = tokenIndex - 1;
            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;
            // check that previous token is not to be ignored
            if (prevModeBrackets && !(0,_languages_supports_js__WEBPACK_IMPORTED_MODULE_4__.ignoreBracketsInToken)(lineTokens.getStandardTokenType(prevTokenIndex))) {
                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);
                const foundBracket = _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__.BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                // check that we didn't hit a bracket too far away from position
                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();
                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);
                    if (r) {
                        if (r instanceof BracketSearchCanceled) {
                            return null;
                        }
                        return r;
                    }
                }
            }
        }
        return null;
    }
    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {
        if (!data) {
            return null;
        }
        const matched = (isOpen
            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)
            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));
        if (!matched) {
            return null;
        }
        if (matched instanceof BracketSearchCanceled) {
            return matched;
        }
        return [foundBracket, matched];
    }
    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {
        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
        const languageId = bracket.languageId;
        const reversedBracketRegex = bracket.reversedRegex;
        let count = -1;
        let totalCallCount = 0;
        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {
            while (true) {
                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {
                    return BracketSearchCanceled.INSTANCE;
                }
                const r = _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__.BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (!r) {
                    break;
                }
                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
                if (bracket.isOpen(hitText)) {
                    count++;
                }
                else if (bracket.isClose(hitText)) {
                    count--;
                }
                if (count === 0) {
                    return r;
                }
                searchEndOffset = r.startColumn - 1;
            }
            return null;
        };
        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
            const tokenCount = lineTokens.getCount();
            const lineText = this.textModel.getLineContent(lineNumber);
            let tokenIndex = tokenCount - 1;
            let searchStartOffset = lineText.length;
            let searchEndOffset = lineText.length;
            if (lineNumber === position.lineNumber) {
                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                searchStartOffset = position.column - 1;
                searchEndOffset = position.column - 1;
            }
            let prevSearchInToken = true;
            for (; tokenIndex >= 0; tokenIndex--) {
                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !(0,_languages_supports_js__WEBPACK_IMPORTED_MODULE_4__.ignoreBracketsInToken)(lineTokens.getStandardTokenType(tokenIndex)));
                if (searchInToken) {
                    // this token should be searched
                    if (prevSearchInToken) {
                        // the previous token should be searched, simply extend searchStartOffset
                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                    }
                    else {
                        // the previous token should not be searched
                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);
                    }
                }
                else {
                    // this token should not be searched
                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
                        if (r) {
                            return r;
                        }
                    }
                }
                prevSearchInToken = searchInToken;
            }
            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                    return r;
                }
            }
        }
        return null;
    }
    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {
        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
        const languageId = bracket.languageId;
        const bracketRegex = bracket.forwardRegex;
        let count = 1;
        let totalCallCount = 0;
        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {
            while (true) {
                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {
                    return BracketSearchCanceled.INSTANCE;
                }
                const r = _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__.BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (!r) {
                    break;
                }
                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
                if (bracket.isOpen(hitText)) {
                    count++;
                }
                else if (bracket.isClose(hitText)) {
                    count--;
                }
                if (count === 0) {
                    return r;
                }
                searchStartOffset = r.endColumn - 1;
            }
            return null;
        };
        const lineCount = this.textModel.getLineCount();
        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
            const tokenCount = lineTokens.getCount();
            const lineText = this.textModel.getLineContent(lineNumber);
            let tokenIndex = 0;
            let searchStartOffset = 0;
            let searchEndOffset = 0;
            if (lineNumber === position.lineNumber) {
                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                searchStartOffset = position.column - 1;
                searchEndOffset = position.column - 1;
            }
            let prevSearchInToken = true;
            for (; tokenIndex < tokenCount; tokenIndex++) {
                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !(0,_languages_supports_js__WEBPACK_IMPORTED_MODULE_4__.ignoreBracketsInToken)(lineTokens.getStandardTokenType(tokenIndex)));
                if (searchInToken) {
                    // this token should be searched
                    if (prevSearchInToken) {
                        // the previous token should be searched, simply extend searchEndOffset
                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);
                    }
                    else {
                        // the previous token should not be searched
                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);
                    }
                }
                else {
                    // this token should not be searched
                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
                        if (r) {
                            return r;
                        }
                    }
                }
                prevSearchInToken = searchInToken;
            }
            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                    return r;
                }
            }
        }
        return null;
    }
    findPrevBracket(_position) {
        const position = this.textModel.validatePosition(_position);
        if (this.canBuildAST) {
            this.bracketsRequested = true;
            this.updateBracketPairsTree();
            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;
        }
        let languageId = null;
        let modeBrackets = null;
        let bracketConfig = null;
        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
            const tokenCount = lineTokens.getCount();
            const lineText = this.textModel.getLineContent(lineNumber);
            let tokenIndex = tokenCount - 1;
            let searchStartOffset = lineText.length;
            let searchEndOffset = lineText.length;
            if (lineNumber === position.lineNumber) {
                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                searchStartOffset = position.column - 1;
                searchEndOffset = position.column - 1;
                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                if (languageId !== tokenLanguageId) {
                    languageId = tokenLanguageId;
                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;
                }
            }
            let prevSearchInToken = true;
            for (; tokenIndex >= 0; tokenIndex--) {
                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                if (languageId !== tokenLanguageId) {
                    // language id change!
                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                        const r = _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__.BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                        if (r) {
                            return this._toFoundBracket(bracketConfig, r);
                        }
                        prevSearchInToken = false;
                    }
                    languageId = tokenLanguageId;
                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;
                }
                const searchInToken = (!!modeBrackets && !(0,_languages_supports_js__WEBPACK_IMPORTED_MODULE_4__.ignoreBracketsInToken)(lineTokens.getStandardTokenType(tokenIndex)));
                if (searchInToken) {
                    // this token should be searched
                    if (prevSearchInToken) {
                        // the previous token should be searched, simply extend searchStartOffset
                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                    }
                    else {
                        // the previous token should not be searched
                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);
                    }
                }
                else {
                    // this token should not be searched
                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                        const r = _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__.BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                        if (r) {
                            return this._toFoundBracket(bracketConfig, r);
                        }
                    }
                }
                prevSearchInToken = searchInToken;
            }
            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__.BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                    return this._toFoundBracket(bracketConfig, r);
                }
            }
        }
        return null;
    }
    findNextBracket(_position) {
        const position = this.textModel.validatePosition(_position);
        if (this.canBuildAST) {
            this.bracketsRequested = true;
            this.updateBracketPairsTree();
            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;
        }
        const lineCount = this.textModel.getLineCount();
        let languageId = null;
        let modeBrackets = null;
        let bracketConfig = null;
        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
            const tokenCount = lineTokens.getCount();
            const lineText = this.textModel.getLineContent(lineNumber);
            let tokenIndex = 0;
            let searchStartOffset = 0;
            let searchEndOffset = 0;
            if (lineNumber === position.lineNumber) {
                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                searchStartOffset = position.column - 1;
                searchEndOffset = position.column - 1;
                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                if (languageId !== tokenLanguageId) {
                    languageId = tokenLanguageId;
                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;
                }
            }
            let prevSearchInToken = true;
            for (; tokenIndex < tokenCount; tokenIndex++) {
                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                if (languageId !== tokenLanguageId) {
                    // language id change!
                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                        const r = _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__.BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                        if (r) {
                            return this._toFoundBracket(bracketConfig, r);
                        }
                        prevSearchInToken = false;
                    }
                    languageId = tokenLanguageId;
                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;
                }
                const searchInToken = (!!modeBrackets && !(0,_languages_supports_js__WEBPACK_IMPORTED_MODULE_4__.ignoreBracketsInToken)(lineTokens.getStandardTokenType(tokenIndex)));
                if (searchInToken) {
                    // this token should be searched
                    if (prevSearchInToken) {
                        // the previous token should be searched, simply extend searchEndOffset
                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);
                    }
                    else {
                        // the previous token should not be searched
                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);
                    }
                }
                else {
                    // this token should not be searched
                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                        const r = _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__.BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                        if (r) {
                            return this._toFoundBracket(bracketConfig, r);
                        }
                    }
                }
                prevSearchInToken = searchInToken;
            }
            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__.BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                    return this._toFoundBracket(bracketConfig, r);
                }
            }
        }
        return null;
    }
    findEnclosingBrackets(_position, maxDuration) {
        const position = this.textModel.validatePosition(_position);
        if (this.canBuildAST) {
            const range = _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(position);
            const bracketPair = this.getBracketPairsInRange(_core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));
            if (bracketPair) {
                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];
            }
            return null;
        }
        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);
        const lineCount = this.textModel.getLineCount();
        const savedCounts = new Map();
        let counts = [];
        const resetCounts = (languageId, modeBrackets) => {
            if (!savedCounts.has(languageId)) {
                const tmp = [];
                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {
                    tmp[i] = 0;
                }
                savedCounts.set(languageId, tmp);
            }
            counts = savedCounts.get(languageId);
        };
        let totalCallCount = 0;
        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {
            while (true) {
                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {
                    return BracketSearchCanceled.INSTANCE;
                }
                const r = _languages_supports_richEditBrackets_js__WEBPACK_IMPORTED_MODULE_5__.BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (!r) {
                    break;
                }
                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
                const bracket = modeBrackets.textIsBracket[hitText];
                if (bracket) {
                    if (bracket.isOpen(hitText)) {
                        counts[bracket.index]++;
                    }
                    else if (bracket.isClose(hitText)) {
                        counts[bracket.index]--;
                    }
                    if (counts[bracket.index] === -1) {
                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);
                    }
                }
                searchStartOffset = r.endColumn - 1;
            }
            return null;
        };
        let languageId = null;
        let modeBrackets = null;
        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
            const tokenCount = lineTokens.getCount();
            const lineText = this.textModel.getLineContent(lineNumber);
            let tokenIndex = 0;
            let searchStartOffset = 0;
            let searchEndOffset = 0;
            if (lineNumber === position.lineNumber) {
                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                searchStartOffset = position.column - 1;
                searchEndOffset = position.column - 1;
                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                if (languageId !== tokenLanguageId) {
                    languageId = tokenLanguageId;
                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
                    resetCounts(languageId, modeBrackets);
                }
            }
            let prevSearchInToken = true;
            for (; tokenIndex < tokenCount; tokenIndex++) {
                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                if (languageId !== tokenLanguageId) {
                    // language id change!
                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
                        if (r) {
                            return stripBracketSearchCanceled(r);
                        }
                        prevSearchInToken = false;
                    }
                    languageId = tokenLanguageId;
                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
                    resetCounts(languageId, modeBrackets);
                }
                const searchInToken = (!!modeBrackets && !(0,_languages_supports_js__WEBPACK_IMPORTED_MODULE_4__.ignoreBracketsInToken)(lineTokens.getStandardTokenType(tokenIndex)));
                if (searchInToken) {
                    // this token should be searched
                    if (prevSearchInToken) {
                        // the previous token should be searched, simply extend searchEndOffset
                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);
                    }
                    else {
                        // the previous token should not be searched
                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);
                    }
                }
                else {
                    // this token should not be searched
                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
                        if (r) {
                            return stripBracketSearchCanceled(r);
                        }
                    }
                }
                prevSearchInToken = searchInToken;
            }
            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                    return stripBracketSearchCanceled(r);
                }
            }
        }
        return null;
    }
    _toFoundBracket(bracketConfig, r) {
        if (!r) {
            return null;
        }
        let text = this.textModel.getValueInRange(r);
        text = text.toLowerCase();
        const bracketInfo = bracketConfig.getBracketInfo(text);
        if (!bracketInfo) {
            return null;
        }
        return {
            range: r,
            bracketInfo
        };
    }
}
function createDisposableRef(object, disposable) {
    return {
        object,
        dispose: () => disposable?.dispose(),
    };
}
function createTimeBasedContinueBracketSearchPredicate(maxDuration) {
    if (typeof maxDuration === 'undefined') {
        return () => true;
    }
    else {
        const startTime = Date.now();
        return () => {
            return (Date.now() - startTime <= maxDuration);
        };
    }
}
class BracketSearchCanceled {
    static { this.INSTANCE = new BracketSearchCanceled(); }
    constructor() {
        this._searchCanceledBrand = undefined;
    }
}
function stripBracketSearchCanceled(result) {
    if (result instanceof BracketSearchCanceled) {
        return null;
    }
    return result;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BracketAstNode: () => (/* binding */ BracketAstNode),
/* harmony export */   InvalidBracketAstNode: () => (/* binding */ InvalidBracketAstNode),
/* harmony export */   ListAstNode: () => (/* binding */ ListAstNode),
/* harmony export */   PairAstNode: () => (/* binding */ PairAstNode),
/* harmony export */   TextAstNode: () => (/* binding */ TextAstNode)
/* harmony export */ });
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _core_cursorColumns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/cursorColumns.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js");
/* harmony import */ var _length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./length.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js");
/* harmony import */ var _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./smallImmutableSet.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




/**
 * The base implementation for all AST nodes.
*/
class BaseAstNode {
    /**
     * The length of the entire node, which should equal the sum of lengths of all children.
    */
    get length() {
        return this._length;
    }
    constructor(length) {
        this._length = length;
    }
}
/**
 * Represents a bracket pair including its child (e.g. `{ ... }`).
 * Might be unclosed.
 * Immutable, if all children are immutable.
*/
class PairAstNode extends BaseAstNode {
    static create(openingBracket, child, closingBracket) {
        let length = openingBracket.length;
        if (child) {
            length = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthAdd)(length, child.length);
        }
        if (closingBracket) {
            length = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthAdd)(length, closingBracket.length);
        }
        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_3__.SmallImmutableSet.getEmpty());
    }
    get kind() {
        return 2 /* AstNodeKind.Pair */;
    }
    get listHeight() {
        return 0;
    }
    get childrenLength() {
        return 3;
    }
    getChild(idx) {
        switch (idx) {
            case 0: return this.openingBracket;
            case 1: return this.child;
            case 2: return this.closingBracket;
        }
        throw new Error('Invalid child index');
    }
    /**
     * Avoid using this property, it allocates an array!
    */
    get children() {
        const result = [];
        result.push(this.openingBracket);
        if (this.child) {
            result.push(this.child);
        }
        if (this.closingBracket) {
            result.push(this.closingBracket);
        }
        return result;
    }
    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {
        super(length);
        this.openingBracket = openingBracket;
        this.child = child;
        this.closingBracket = closingBracket;
        this.missingOpeningBracketIds = missingOpeningBracketIds;
    }
    canBeReused(openBracketIds) {
        if (this.closingBracket === null) {
            // Unclosed pair ast nodes only
            // end at the end of the document
            // or when a parent node is closed.
            // This could be improved:
            // Only return false if some next token is neither "undefined" nor a bracket that closes a parent.
            return false;
        }
        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {
            return false;
        }
        return true;
    }
    deepClone() {
        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
    }
    computeMinIndentation(offset, textModel) {
        return this.child ? this.child.computeMinIndentation((0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthAdd)(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;
    }
}
class ListAstNode extends BaseAstNode {
    /**
     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.
    */
    static create23(item1, item2, item3, immutable = false) {
        let length = item1.length;
        let missingBracketIds = item1.missingOpeningBracketIds;
        if (item1.listHeight !== item2.listHeight) {
            throw new Error('Invalid list heights');
        }
        length = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthAdd)(length, item2.length);
        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);
        if (item3) {
            if (item1.listHeight !== item3.listHeight) {
                throw new Error('Invalid list heights');
            }
            length = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthAdd)(length, item3.length);
            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);
        }
        return immutable
            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)
            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);
    }
    static getEmpty() {
        return new ImmutableArrayListAstNode(_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthZero, 0, [], _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_3__.SmallImmutableSet.getEmpty());
    }
    get kind() {
        return 4 /* AstNodeKind.List */;
    }
    get missingOpeningBracketIds() {
        return this._missingOpeningBracketIds;
    }
    /**
     * Use ListAstNode.create.
    */
    constructor(length, listHeight, _missingOpeningBracketIds) {
        super(length);
        this.listHeight = listHeight;
        this._missingOpeningBracketIds = _missingOpeningBracketIds;
        this.cachedMinIndentation = -1;
    }
    throwIfImmutable() {
        // NOOP
    }
    makeLastElementMutable() {
        this.throwIfImmutable();
        const childCount = this.childrenLength;
        if (childCount === 0) {
            return undefined;
        }
        const lastChild = this.getChild(childCount - 1);
        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;
        if (lastChild !== mutable) {
            this.setChild(childCount - 1, mutable);
        }
        return mutable;
    }
    makeFirstElementMutable() {
        this.throwIfImmutable();
        const childCount = this.childrenLength;
        if (childCount === 0) {
            return undefined;
        }
        const firstChild = this.getChild(0);
        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;
        if (firstChild !== mutable) {
            this.setChild(0, mutable);
        }
        return mutable;
    }
    canBeReused(openBracketIds) {
        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {
            return false;
        }
        if (this.childrenLength === 0) {
            // Don't reuse empty lists.
            return false;
        }
        let lastChild = this;
        while (lastChild.kind === 4 /* AstNodeKind.List */) {
            const lastLength = lastChild.childrenLength;
            if (lastLength === 0) {
                // Empty lists should never be contained in other lists.
                throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError();
            }
            lastChild = lastChild.getChild(lastLength - 1);
        }
        return lastChild.canBeReused(openBracketIds);
    }
    handleChildrenChanged() {
        this.throwIfImmutable();
        const count = this.childrenLength;
        let length = this.getChild(0).length;
        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;
        for (let i = 1; i < count; i++) {
            const child = this.getChild(i);
            length = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthAdd)(length, child.length);
            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);
        }
        this._length = length;
        this._missingOpeningBracketIds = unopenedBrackets;
        this.cachedMinIndentation = -1;
    }
    computeMinIndentation(offset, textModel) {
        if (this.cachedMinIndentation !== -1) {
            return this.cachedMinIndentation;
        }
        let minIndentation = Number.MAX_SAFE_INTEGER;
        let childOffset = offset;
        for (let i = 0; i < this.childrenLength; i++) {
            const child = this.getChild(i);
            if (child) {
                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));
                childOffset = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthAdd)(childOffset, child.length);
            }
        }
        this.cachedMinIndentation = minIndentation;
        return minIndentation;
    }
}
class TwoThreeListAstNode extends ListAstNode {
    get childrenLength() {
        return this._item3 !== null ? 3 : 2;
    }
    getChild(idx) {
        switch (idx) {
            case 0: return this._item1;
            case 1: return this._item2;
            case 2: return this._item3;
        }
        throw new Error('Invalid child index');
    }
    setChild(idx, node) {
        switch (idx) {
            case 0:
                this._item1 = node;
                return;
            case 1:
                this._item2 = node;
                return;
            case 2:
                this._item3 = node;
                return;
        }
        throw new Error('Invalid child index');
    }
    get children() {
        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];
    }
    get item1() {
        return this._item1;
    }
    get item2() {
        return this._item2;
    }
    get item3() {
        return this._item3;
    }
    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {
        super(length, listHeight, missingOpeningBracketIds);
        this._item1 = _item1;
        this._item2 = _item2;
        this._item3 = _item3;
    }
    deepClone() {
        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);
    }
    appendChildOfSameHeight(node) {
        if (this._item3) {
            throw new Error('Cannot append to a full (2,3) tree node');
        }
        this.throwIfImmutable();
        this._item3 = node;
        this.handleChildrenChanged();
    }
    unappendChild() {
        if (!this._item3) {
            throw new Error('Cannot remove from a non-full (2,3) tree node');
        }
        this.throwIfImmutable();
        const result = this._item3;
        this._item3 = null;
        this.handleChildrenChanged();
        return result;
    }
    prependChildOfSameHeight(node) {
        if (this._item3) {
            throw new Error('Cannot prepend to a full (2,3) tree node');
        }
        this.throwIfImmutable();
        this._item3 = this._item2;
        this._item2 = this._item1;
        this._item1 = node;
        this.handleChildrenChanged();
    }
    unprependChild() {
        if (!this._item3) {
            throw new Error('Cannot remove from a non-full (2,3) tree node');
        }
        this.throwIfImmutable();
        const result = this._item1;
        this._item1 = this._item2;
        this._item2 = this._item3;
        this._item3 = null;
        this.handleChildrenChanged();
        return result;
    }
    toMutable() {
        return this;
    }
}
/**
 * Immutable, if all children are immutable.
*/
class Immutable23ListAstNode extends TwoThreeListAstNode {
    toMutable() {
        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);
    }
    throwIfImmutable() {
        throw new Error('this instance is immutable');
    }
}
/**
 * For debugging.
*/
class ArrayListAstNode extends ListAstNode {
    get childrenLength() {
        return this._children.length;
    }
    getChild(idx) {
        return this._children[idx];
    }
    setChild(idx, child) {
        this._children[idx] = child;
    }
    get children() {
        return this._children;
    }
    constructor(length, listHeight, _children, missingOpeningBracketIds) {
        super(length, listHeight, missingOpeningBracketIds);
        this._children = _children;
    }
    deepClone() {
        const children = new Array(this._children.length);
        for (let i = 0; i < this._children.length; i++) {
            children[i] = this._children[i].deepClone();
        }
        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);
    }
    appendChildOfSameHeight(node) {
        this.throwIfImmutable();
        this._children.push(node);
        this.handleChildrenChanged();
    }
    unappendChild() {
        this.throwIfImmutable();
        const item = this._children.pop();
        this.handleChildrenChanged();
        return item;
    }
    prependChildOfSameHeight(node) {
        this.throwIfImmutable();
        this._children.unshift(node);
        this.handleChildrenChanged();
    }
    unprependChild() {
        this.throwIfImmutable();
        const item = this._children.shift();
        this.handleChildrenChanged();
        return item;
    }
    toMutable() {
        return this;
    }
}
/**
 * Immutable, if all children are immutable.
*/
class ImmutableArrayListAstNode extends ArrayListAstNode {
    toMutable() {
        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);
    }
    throwIfImmutable() {
        throw new Error('this instance is immutable');
    }
}
const emptyArray = [];
class ImmutableLeafAstNode extends BaseAstNode {
    get listHeight() {
        return 0;
    }
    get childrenLength() {
        return 0;
    }
    getChild(idx) {
        return null;
    }
    get children() {
        return emptyArray;
    }
    deepClone() {
        return this;
    }
}
class TextAstNode extends ImmutableLeafAstNode {
    get kind() {
        return 0 /* AstNodeKind.Text */;
    }
    get missingOpeningBracketIds() {
        return _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_3__.SmallImmutableSet.getEmpty();
    }
    canBeReused(_openedBracketIds) {
        return true;
    }
    computeMinIndentation(offset, textModel) {
        const start = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthToObj)(offset);
        // Text ast nodes don't have partial indentation (ensured by the tokenizer).
        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.
        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;
        const endLineNumber = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthGetLineCount)((0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthAdd)(offset, this.length)) + 1;
        let result = Number.MAX_SAFE_INTEGER;
        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);
            const lineContent = textModel.getLineContent(lineNumber);
            if (firstNonWsColumn === 0) {
                continue;
            }
            const visibleColumn = _core_cursorColumns_js__WEBPACK_IMPORTED_MODULE_1__.CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);
            result = Math.min(result, visibleColumn);
        }
        return result;
    }
}
class BracketAstNode extends ImmutableLeafAstNode {
    static create(length, bracketInfo, bracketIds) {
        const node = new BracketAstNode(length, bracketInfo, bracketIds);
        return node;
    }
    get kind() {
        return 1 /* AstNodeKind.Bracket */;
    }
    get missingOpeningBracketIds() {
        return _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_3__.SmallImmutableSet.getEmpty();
    }
    constructor(length, bracketInfo, 
    /**
     * In case of a opening bracket, this is the id of the opening bracket.
     * In case of a closing bracket, this contains the ids of all opening brackets it can close.
    */
    bracketIds) {
        super(length);
        this.bracketInfo = bracketInfo;
        this.bracketIds = bracketIds;
    }
    get text() {
        return this.bracketInfo.bracketText;
    }
    get languageId() {
        return this.bracketInfo.languageId;
    }
    canBeReused(_openedBracketIds) {
        // These nodes could be reused,
        // but not in a general way.
        // Their parent may be reused.
        return false;
    }
    computeMinIndentation(offset, textModel) {
        return Number.MAX_SAFE_INTEGER;
    }
}
class InvalidBracketAstNode extends ImmutableLeafAstNode {
    get kind() {
        return 3 /* AstNodeKind.UnexpectedClosingBracket */;
    }
    constructor(closingBrackets, length) {
        super(length);
        this.missingOpeningBracketIds = closingBrackets;
    }
    canBeReused(openedBracketIds) {
        return !openedBracketIds.intersects(this.missingOpeningBracketIds);
    }
    computeMinIndentation(offset, textModel) {
        return Number.MAX_SAFE_INTEGER;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BeforeEditPositionMapper: () => (/* binding */ BeforeEditPositionMapper),
/* harmony export */   TextEditInfo: () => (/* binding */ TextEditInfo)
/* harmony export */ });
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _length_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./length.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


class TextEditInfo {
    static fromModelContentChanges(changes) {
        // Must be sorted in ascending order
        const edits = changes.map(c => {
            const range = _core_range_js__WEBPACK_IMPORTED_MODULE_0__.Range.lift(c.range);
            return new TextEditInfo((0,_length_js__WEBPACK_IMPORTED_MODULE_1__.positionToLength)(range.getStartPosition()), (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.positionToLength)(range.getEndPosition()), (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthOfString)(c.text));
        }).reverse();
        return edits;
    }
    constructor(startOffset, endOffset, newLength) {
        this.startOffset = startOffset;
        this.endOffset = endOffset;
        this.newLength = newLength;
    }
    toString() {
        return `[${(0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthToObj)(this.startOffset)}...${(0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthToObj)(this.endOffset)}) -> ${(0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthToObj)(this.newLength)}`;
    }
}
class BeforeEditPositionMapper {
    /**
     * @param edits Must be sorted by offset in ascending order.
    */
    constructor(edits) {
        this.nextEditIdx = 0;
        this.deltaOldToNewLineCount = 0;
        this.deltaOldToNewColumnCount = 0;
        this.deltaLineIdxInOld = -1;
        this.edits = edits.map(edit => TextEditInfoCache.from(edit));
    }
    /**
     * @param offset Must be equal to or greater than the last offset this method has been called with.
    */
    getOffsetBeforeChange(offset) {
        this.adjustNextEdit(offset);
        return this.translateCurToOld(offset);
    }
    /**
     * @param offset Must be equal to or greater than the last offset this method has been called with.
     * Returns null if there is no edit anymore.
    */
    getDistanceToNextChange(offset) {
        this.adjustNextEdit(offset);
        const nextEdit = this.edits[this.nextEditIdx];
        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;
        if (nextChangeOffset === null) {
            return null;
        }
        return (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthDiffNonNegative)(offset, nextChangeOffset);
    }
    translateOldToCur(oldOffsetObj) {
        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {
            return (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.toLength)(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);
        }
        else {
            return (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.toLength)(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);
        }
    }
    translateCurToOld(newOffset) {
        const offsetObj = (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthToObj)(newOffset);
        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {
            return (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.toLength)(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);
        }
        else {
            return (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.toLength)(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);
        }
    }
    adjustNextEdit(offset) {
        while (this.nextEditIdx < this.edits.length) {
            const nextEdit = this.edits[this.nextEditIdx];
            // After applying the edit, what is its end offset (considering all previous edits)?
            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);
            if ((0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthLessThanEqual)(nextEditEndOffsetInCur, offset)) {
                // We are after the edit, skip it
                this.nextEditIdx++;
                const nextEditEndOffsetInCurObj = (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthToObj)(nextEditEndOffsetInCur);
                // Before applying the edit, what is its end offset (considering all previous edits)?
                const nextEditEndOffsetBeforeInCurObj = (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthToObj)(this.translateOldToCur(nextEdit.endOffsetBeforeObj));
                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;
                this.deltaOldToNewLineCount += lineDelta;
                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;
                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;
                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;
                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;
            }
            else {
                // We are in or before the edit.
                break;
            }
        }
    }
}
class TextEditInfoCache {
    static from(edit) {
        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);
    }
    constructor(startOffset, endOffset, textLength) {
        this.endOffsetBeforeObj = (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthToObj)(endOffset);
        this.endOffsetAfterObj = (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthToObj)((0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthAdd)(startOffset, textLength));
        this.offsetObj = (0,_length_js__WEBPACK_IMPORTED_MODULE_1__.lengthToObj)(startOffset);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BracketPairsTree: () => (/* binding */ BracketPairsTree)
/* harmony export */ });
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _textModelBracketPairs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../textModelBracketPairs.js */ "./node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js");
/* harmony import */ var _beforeEditPositionMapper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./beforeEditPositionMapper.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js");
/* harmony import */ var _brackets_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./brackets.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js");
/* harmony import */ var _length_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./length.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js");
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parser.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js");
/* harmony import */ var _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./smallImmutableSet.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js");
/* harmony import */ var _tokenizer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tokenizer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js");
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _combineTextEditInfos_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./combineTextEditInfos.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











class BracketPairsTree extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    didLanguageChange(languageId) {
        return this.brackets.didLanguageChange(languageId);
    }
    constructor(textModel, getLanguageConfiguration) {
        super();
        this.textModel = textModel;
        this.getLanguageConfiguration = getLanguageConfiguration;
        this.didChangeEmitter = new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter();
        this.denseKeyProvider = new _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_7__.DenseKeyProvider();
        this.brackets = new _brackets_js__WEBPACK_IMPORTED_MODULE_4__.LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);
        this.onDidChange = this.didChangeEmitter.event;
        this.queuedTextEditsForInitialAstWithoutTokens = [];
        this.queuedTextEdits = [];
        if (!textModel.tokenization.hasTokens) {
            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());
            const tokenizer = new _tokenizer_js__WEBPACK_IMPORTED_MODULE_8__.FastTokenizer(this.textModel.getValue(), brackets);
            this.initialAstWithoutTokens = (0,_parser_js__WEBPACK_IMPORTED_MODULE_6__.parseDocument)(tokenizer, [], undefined, true);
            this.astWithTokens = this.initialAstWithoutTokens;
        }
        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {
            // Skip the initial ast, as there is no flickering.
            // Directly create the tree with token information.
            this.initialAstWithoutTokens = undefined;
            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);
        }
        else {
            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments
            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);
            this.astWithTokens = this.initialAstWithoutTokens;
        }
    }
    //#region TextModel events
    handleDidChangeBackgroundTokenizationState() {
        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {
            const wasUndefined = this.initialAstWithoutTokens === undefined;
            // Clear the initial tree as we can use the tree with token information now.
            this.initialAstWithoutTokens = undefined;
            if (!wasUndefined) {
                this.didChangeEmitter.fire();
            }
        }
    }
    handleDidChangeTokens({ ranges }) {
        const edits = ranges.map(r => new _beforeEditPositionMapper_js__WEBPACK_IMPORTED_MODULE_3__.TextEditInfo((0,_length_js__WEBPACK_IMPORTED_MODULE_5__.toLength)(r.fromLineNumber - 1, 0), (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.toLength)(r.toLineNumber, 0), (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.toLength)(r.toLineNumber - r.fromLineNumber + 1, 0)));
        this.handleEdits(edits, true);
        if (!this.initialAstWithoutTokens) {
            this.didChangeEmitter.fire();
        }
    }
    handleContentChanged(change) {
        const edits = _beforeEditPositionMapper_js__WEBPACK_IMPORTED_MODULE_3__.TextEditInfo.fromModelContentChanges(change.changes);
        this.handleEdits(edits, false);
    }
    handleEdits(edits, tokenChange) {
        // Lazily queue the edits and only apply them when the tree is accessed.
        const result = (0,_combineTextEditInfos_js__WEBPACK_IMPORTED_MODULE_10__.combineTextEditInfos)(this.queuedTextEdits, edits);
        this.queuedTextEdits = result;
        if (this.initialAstWithoutTokens && !tokenChange) {
            this.queuedTextEditsForInitialAstWithoutTokens = (0,_combineTextEditInfos_js__WEBPACK_IMPORTED_MODULE_10__.combineTextEditInfos)(this.queuedTextEditsForInitialAstWithoutTokens, edits);
        }
    }
    //#endregion
    flushQueue() {
        if (this.queuedTextEdits.length > 0) {
            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);
            this.queuedTextEdits = [];
        }
        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {
            if (this.initialAstWithoutTokens) {
                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);
            }
            this.queuedTextEditsForInitialAstWithoutTokens = [];
        }
    }
    /**
     * @pure (only if isPure = true)
    */
    parseDocumentFromTextBuffer(edits, previousAst, immutable) {
        // Is much faster if `isPure = false`.
        const isPure = false;
        const previousAstClone = isPure ? previousAst?.deepClone() : previousAst;
        const tokenizer = new _tokenizer_js__WEBPACK_IMPORTED_MODULE_8__.TextBufferTokenizer(this.textModel, this.brackets);
        const result = (0,_parser_js__WEBPACK_IMPORTED_MODULE_6__.parseDocument)(tokenizer, edits, previousAstClone, immutable);
        return result;
    }
    getBracketsInRange(range, onlyColorizedBrackets) {
        this.flushQueue();
        const startOffset = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.toLength)(range.startLineNumber - 1, range.startColumn - 1);
        const endOffset = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.toLength)(range.endLineNumber - 1, range.endColumn - 1);
        return new _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_9__.CallbackIterable(cb => {
            const node = this.initialAstWithoutTokens || this.astWithTokens;
            collectBrackets(node, _length_js__WEBPACK_IMPORTED_MODULE_5__.lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);
        });
    }
    getBracketPairsInRange(range, includeMinIndentation) {
        this.flushQueue();
        const startLength = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.positionToLength)(range.getStartPosition());
        const endLength = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.positionToLength)(range.getEndPosition());
        return new _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_9__.CallbackIterable(cb => {
            const node = this.initialAstWithoutTokens || this.astWithTokens;
            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);
            collectBracketPairs(node, _length_js__WEBPACK_IMPORTED_MODULE_5__.lengthZero, node.length, startLength, endLength, context, 0, new Map());
        });
    }
    getFirstBracketAfter(position) {
        this.flushQueue();
        const node = this.initialAstWithoutTokens || this.astWithTokens;
        return getFirstBracketAfter(node, _length_js__WEBPACK_IMPORTED_MODULE_5__.lengthZero, node.length, (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.positionToLength)(position));
    }
    getFirstBracketBefore(position) {
        this.flushQueue();
        const node = this.initialAstWithoutTokens || this.astWithTokens;
        return getFirstBracketBefore(node, _length_js__WEBPACK_IMPORTED_MODULE_5__.lengthZero, node.length, (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.positionToLength)(position));
    }
}
function getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {
    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {
        const lengths = [];
        for (const child of node.children) {
            nodeOffsetEnd = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthAdd)(nodeOffsetStart, child.length);
            lengths.push({ nodeOffsetStart, nodeOffsetEnd });
            nodeOffsetStart = nodeOffsetEnd;
        }
        for (let i = lengths.length - 1; i >= 0; i--) {
            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];
            if ((0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthLessThan)(nodeOffsetStart, position)) {
                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);
                if (result) {
                    return result;
                }
            }
        }
        return null;
    }
    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {
        return null;
    }
    else if (node.kind === 1 /* AstNodeKind.Bracket */) {
        const range = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthsToRange)(nodeOffsetStart, nodeOffsetEnd);
        return {
            bracketInfo: node.bracketInfo,
            range
        };
    }
    return null;
}
function getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {
    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {
        for (const child of node.children) {
            nodeOffsetEnd = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthAdd)(nodeOffsetStart, child.length);
            if ((0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthLessThan)(position, nodeOffsetEnd)) {
                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);
                if (result) {
                    return result;
                }
            }
            nodeOffsetStart = nodeOffsetEnd;
        }
        return null;
    }
    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {
        return null;
    }
    else if (node.kind === 1 /* AstNodeKind.Bracket */) {
        const range = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthsToRange)(nodeOffsetStart, nodeOffsetEnd);
        return {
            bracketInfo: node.bracketInfo,
            range
        };
    }
    return null;
}
function collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {
    if (level > 200) {
        return true;
    }
    whileLoop: while (true) {
        switch (node.kind) {
            case 4 /* AstNodeKind.List */: {
                const childCount = node.childrenLength;
                for (let i = 0; i < childCount; i++) {
                    const child = node.getChild(i);
                    if (!child) {
                        continue;
                    }
                    nodeOffsetEnd = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthAdd)(nodeOffsetStart, child.length);
                    if ((0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthLessThanEqual)(nodeOffsetStart, endOffset) &&
                        (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthGreaterThanEqual)(nodeOffsetEnd, startOffset)) {
                        const childEndsAfterEnd = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthGreaterThanEqual)(nodeOffsetEnd, endOffset);
                        if (childEndsAfterEnd) {
                            // No child after this child in the requested window, don't recurse
                            node = child;
                            continue whileLoop;
                        }
                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);
                        if (!shouldContinue) {
                            return false;
                        }
                    }
                    nodeOffsetStart = nodeOffsetEnd;
                }
                return true;
            }
            case 2 /* AstNodeKind.Pair */: {
                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);
                let levelPerBracket = 0;
                if (levelPerBracketType) {
                    let existing = levelPerBracketType.get(node.openingBracket.text);
                    if (existing === undefined) {
                        existing = 0;
                    }
                    levelPerBracket = existing;
                    if (colorize) {
                        existing++;
                        levelPerBracketType.set(node.openingBracket.text, existing);
                    }
                }
                const childCount = node.childrenLength;
                for (let i = 0; i < childCount; i++) {
                    const child = node.getChild(i);
                    if (!child) {
                        continue;
                    }
                    nodeOffsetEnd = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthAdd)(nodeOffsetStart, child.length);
                    if ((0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthLessThanEqual)(nodeOffsetStart, endOffset) &&
                        (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthGreaterThanEqual)(nodeOffsetEnd, startOffset)) {
                        const childEndsAfterEnd = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthGreaterThanEqual)(nodeOffsetEnd, endOffset);
                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {
                            // No child after this child in the requested window, don't recurse
                            // Don't do this for brackets because of unclosed/unopened brackets
                            node = child;
                            if (colorize) {
                                level++;
                                nestingLevelOfEqualBracketType = levelPerBracket + 1;
                            }
                            else {
                                nestingLevelOfEqualBracketType = levelPerBracket;
                            }
                            continue whileLoop;
                        }
                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {
                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);
                            if (!shouldContinue) {
                                return false;
                            }
                        }
                    }
                    nodeOffsetStart = nodeOffsetEnd;
                }
                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);
                return true;
            }
            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {
                const range = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthsToRange)(nodeOffsetStart, nodeOffsetEnd);
                return push(new _textModelBracketPairs_js__WEBPACK_IMPORTED_MODULE_2__.BracketInfo(range, level - 1, 0, true));
            }
            case 1 /* AstNodeKind.Bracket */: {
                const range = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthsToRange)(nodeOffsetStart, nodeOffsetEnd);
                return push(new _textModelBracketPairs_js__WEBPACK_IMPORTED_MODULE_2__.BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));
            }
            case 0 /* AstNodeKind.Text */:
                return true;
        }
    }
}
class CollectBracketPairsContext {
    constructor(push, includeMinIndentation, textModel) {
        this.push = push;
        this.includeMinIndentation = includeMinIndentation;
        this.textModel = textModel;
    }
}
function collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {
    if (level > 200) {
        return true;
    }
    let shouldContinue = true;
    if (node.kind === 2 /* AstNodeKind.Pair */) {
        let levelPerBracket = 0;
        if (levelPerBracketType) {
            let existing = levelPerBracketType.get(node.openingBracket.text);
            if (existing === undefined) {
                existing = 0;
            }
            levelPerBracket = existing;
            existing++;
            levelPerBracketType.set(node.openingBracket.text, existing);
        }
        const openingBracketEnd = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthAdd)(nodeOffsetStart, node.openingBracket.length);
        let minIndentation = -1;
        if (context.includeMinIndentation) {
            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);
        }
        shouldContinue = context.push(new _textModelBracketPairs_js__WEBPACK_IMPORTED_MODULE_2__.BracketPairWithMinIndentationInfo((0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthsToRange)(nodeOffsetStart, nodeOffsetEnd), (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthsToRange)(nodeOffsetStart, openingBracketEnd), node.closingBracket
            ? (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthsToRange)((0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthAdd)(openingBracketEnd, node.child?.length || _length_js__WEBPACK_IMPORTED_MODULE_5__.lengthZero), nodeOffsetEnd)
            : undefined, level, levelPerBracket, node, minIndentation));
        nodeOffsetStart = openingBracketEnd;
        if (shouldContinue && node.child) {
            const child = node.child;
            nodeOffsetEnd = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthAdd)(nodeOffsetStart, child.length);
            if ((0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthLessThanEqual)(nodeOffsetStart, endOffset) &&
                (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthGreaterThanEqual)(nodeOffsetEnd, startOffset)) {
                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);
                if (!shouldContinue) {
                    return false;
                }
            }
        }
        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);
    }
    else {
        let curOffset = nodeOffsetStart;
        for (const child of node.children) {
            const childOffset = curOffset;
            curOffset = (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthAdd)(curOffset, child.length);
            if ((0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthLessThanEqual)(childOffset, endOffset) &&
                (0,_length_js__WEBPACK_IMPORTED_MODULE_5__.lengthLessThanEqual)(startOffset, curOffset)) {
                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);
                if (!shouldContinue) {
                    return false;
                }
            }
        }
    }
    return shouldContinue;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BracketTokens: () => (/* binding */ BracketTokens),
/* harmony export */   LanguageAgnosticBracketTokens: () => (/* binding */ LanguageAgnosticBracketTokens)
/* harmony export */ });
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _ast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ast.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js");
/* harmony import */ var _length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./length.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js");
/* harmony import */ var _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./smallImmutableSet.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js");
/* harmony import */ var _tokenizer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tokenizer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





class BracketTokens {
    static createFromLanguage(configuration, denseKeyProvider) {
        function getId(bracketInfo) {
            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);
        }
        const map = new Map();
        for (const openingBracket of configuration.bracketsNew.openingBrackets) {
            const length = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.toLength)(0, openingBracket.bracketText.length);
            const openingTextId = getId(openingBracket);
            const bracketIds = _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_3__.SmallImmutableSet.getEmpty().add(openingTextId, _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_3__.identityKeyProvider);
            map.set(openingBracket.bracketText, new _tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, _ast_js__WEBPACK_IMPORTED_MODULE_1__.BracketAstNode.create(length, openingBracket, bracketIds)));
        }
        for (const closingBracket of configuration.bracketsNew.closingBrackets) {
            const length = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.toLength)(0, closingBracket.bracketText.length);
            let bracketIds = _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_3__.SmallImmutableSet.getEmpty();
            const closingBrackets = closingBracket.getOpeningBrackets();
            for (const bracket of closingBrackets) {
                bracketIds = bracketIds.add(getId(bracket), _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_3__.identityKeyProvider);
            }
            map.set(closingBracket.bracketText, new _tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, _ast_js__WEBPACK_IMPORTED_MODULE_1__.BracketAstNode.create(length, closingBracket, bracketIds)));
        }
        return new BracketTokens(map);
    }
    constructor(map) {
        this.map = map;
        this.hasRegExp = false;
        this._regExpGlobal = null;
    }
    getRegExpStr() {
        if (this.isEmpty) {
            return null;
        }
        else {
            const keys = [...this.map.keys()];
            keys.sort();
            keys.reverse();
            return keys.map(k => prepareBracketForRegExp(k)).join('|');
        }
    }
    /**
     * Returns null if there is no such regexp (because there are no brackets).
    */
    get regExpGlobal() {
        if (!this.hasRegExp) {
            const regExpStr = this.getRegExpStr();
            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;
            this.hasRegExp = true;
        }
        return this._regExpGlobal;
    }
    getToken(value) {
        return this.map.get(value.toLowerCase());
    }
    findClosingTokenText(openingBracketIds) {
        for (const [closingText, info] of this.map) {
            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {
                return closingText;
            }
        }
        return undefined;
    }
    get isEmpty() {
        return this.map.size === 0;
    }
}
function prepareBracketForRegExp(str) {
    let escaped = (0,_base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.escapeRegExpCharacters)(str);
    // These bracket pair delimiters start or end with letters
    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440
    if (/^[\w ]+/.test(str)) {
        escaped = `\\b${escaped}`;
    }
    if (/[\w ]+$/.test(str)) {
        escaped = `${escaped}\\b`;
    }
    return escaped;
}
class LanguageAgnosticBracketTokens {
    constructor(denseKeyProvider, getLanguageConfiguration) {
        this.denseKeyProvider = denseKeyProvider;
        this.getLanguageConfiguration = getLanguageConfiguration;
        this.languageIdToBracketTokens = new Map();
    }
    didLanguageChange(languageId) {
        // Report a change whenever the language configuration updates.
        return this.languageIdToBracketTokens.has(languageId);
    }
    getSingleLanguageBracketTokens(languageId) {
        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);
        if (!singleLanguageBracketTokens) {
            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);
            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);
        }
        return singleLanguageBracketTokens;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   combineTextEditInfos: () => (/* binding */ combineTextEditInfos)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _beforeEditPositionMapper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./beforeEditPositionMapper.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js");
/* harmony import */ var _length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./length.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {
    if (textEditInfoFirst.length === 0) {
        return textEditInfoSecond;
    }
    if (textEditInfoSecond.length === 0) {
        return textEditInfoFirst;
    }
    // s0: State before any edits
    const s0ToS1Map = new _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.ArrayQueue(toLengthMapping(textEditInfoFirst));
    // s1: State after first edit, but before second edit
    const s1ToS2Map = toLengthMapping(textEditInfoSecond);
    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new
    // s2: State after both edits
    let curItem = s0ToS1Map.dequeue();
    /**
     * @param s1Length Use undefined for length "infinity"
     */
    function nextS0ToS1MapWithS1LengthOf(s1Length) {
        if (s1Length === undefined) {
            const arr = s0ToS1Map.takeWhile(v => true) || [];
            if (curItem) {
                arr.unshift(curItem);
            }
            return arr;
        }
        const result = [];
        while (curItem && !(0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthIsZero)(s1Length)) {
            const [item, remainingItem] = curItem.splitAt(s1Length);
            result.push(item);
            s1Length = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthDiffNonNegative)(item.lengthAfter, s1Length);
            curItem = remainingItem ?? s0ToS1Map.dequeue();
        }
        if (!(0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthIsZero)(s1Length)) {
            result.push(new LengthMapping(false, s1Length, s1Length));
        }
        return result;
    }
    const result = [];
    function pushEdit(startOffset, endOffset, newLength) {
        if (result.length > 0 && (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthEquals)(result[result.length - 1].endOffset, startOffset)) {
            const lastResult = result[result.length - 1];
            result[result.length - 1] = new _beforeEditPositionMapper_js__WEBPACK_IMPORTED_MODULE_1__.TextEditInfo(lastResult.startOffset, endOffset, (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthAdd)(lastResult.newLength, newLength));
        }
        else {
            result.push({ startOffset, endOffset, newLength });
        }
    }
    let s0offset = _length_js__WEBPACK_IMPORTED_MODULE_2__.lengthZero;
    for (const s1ToS2 of s1ToS2Map) {
        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);
        if (s1ToS2.modified) {
            const s0Length = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.sumLengths)(s0ToS1Map, s => s.lengthBefore);
            const s0EndOffset = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthAdd)(s0offset, s0Length);
            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);
            s0offset = s0EndOffset;
        }
        else {
            for (const s1 of s0ToS1Map) {
                const s0startOffset = s0offset;
                s0offset = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthAdd)(s0offset, s1.lengthBefore);
                if (s1.modified) {
                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);
                }
            }
        }
    }
    return result;
}
class LengthMapping {
    constructor(
    /**
     * If false, length before and length after equal.
     */
    modified, lengthBefore, lengthAfter) {
        this.modified = modified;
        this.lengthBefore = lengthBefore;
        this.lengthAfter = lengthAfter;
    }
    splitAt(lengthAfter) {
        const remainingLengthAfter = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthDiffNonNegative)(lengthAfter, this.lengthAfter);
        if ((0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthEquals)(remainingLengthAfter, _length_js__WEBPACK_IMPORTED_MODULE_2__.lengthZero)) {
            return [this, undefined];
        }
        else if (this.modified) {
            return [
                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),
                new LengthMapping(this.modified, _length_js__WEBPACK_IMPORTED_MODULE_2__.lengthZero, remainingLengthAfter)
            ];
        }
        else {
            return [
                new LengthMapping(this.modified, lengthAfter, lengthAfter),
                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)
            ];
        }
    }
    toString() {
        return `${this.modified ? 'M' : 'U'}:${(0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthToObj)(this.lengthBefore)} -> ${(0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthToObj)(this.lengthAfter)}`;
    }
}
function toLengthMapping(textEditInfos) {
    const result = [];
    let lastOffset = _length_js__WEBPACK_IMPORTED_MODULE_2__.lengthZero;
    for (const textEditInfo of textEditInfos) {
        const spaceLength = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthDiffNonNegative)(lastOffset, textEditInfo.startOffset);
        if (!(0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthIsZero)(spaceLength)) {
            result.push(new LengthMapping(false, spaceLength, spaceLength));
        }
        const lengthBefore = (0,_length_js__WEBPACK_IMPORTED_MODULE_2__.lengthDiffNonNegative)(textEditInfo.startOffset, textEditInfo.endOffset);
        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));
        lastOffset = textEditInfo.endOffset;
    }
    return result;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concat23Trees: () => (/* binding */ concat23Trees),
/* harmony export */   concat23TreesOfSameHeight: () => (/* binding */ concat23TreesOfSameHeight)
/* harmony export */ });
/* harmony import */ var _ast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.
 * This mutates the items of the input array!
 * If all items have the same height, this method has runtime O(items.length).
 * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).
*/
function concat23Trees(items) {
    if (items.length === 0) {
        return null;
    }
    if (items.length === 1) {
        return items[0];
    }
    let i = 0;
    /**
     * Reads nodes of same height and concatenates them to a single node.
    */
    function readNode() {
        if (i >= items.length) {
            return null;
        }
        const start = i;
        const height = items[start].listHeight;
        i++;
        while (i < items.length && items[i].listHeight === height) {
            i++;
        }
        if (i - start >= 2) {
            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);
        }
        else {
            return items[start];
        }
    }
    // The items might not have the same height.
    // We merge all items by using a binary concat operator.
    let first = readNode(); // There must be a first item
    let second = readNode();
    if (!second) {
        return first;
    }
    for (let item = readNode(); item; item = readNode()) {
        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.
        if (heightDiff(first, second) <= heightDiff(second, item)) {
            first = concat(first, second);
            second = item;
        }
        else {
            second = concat(second, item);
        }
    }
    const result = concat(first, second);
    return result;
}
function concat23TreesOfSameHeight(items, createImmutableLists = false) {
    if (items.length === 0) {
        return null;
    }
    if (items.length === 1) {
        return items[0];
    }
    let length = items.length;
    // All trees have same height, just create parent nodes.
    while (length > 3) {
        const newLength = length >> 1;
        for (let i = 0; i < newLength; i++) {
            const j = i << 1;
            items[i] = _ast_js__WEBPACK_IMPORTED_MODULE_0__.ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);
        }
        length = newLength;
    }
    return _ast_js__WEBPACK_IMPORTED_MODULE_0__.ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);
}
function heightDiff(node1, node2) {
    return Math.abs(node1.listHeight - node2.listHeight);
}
function concat(node1, node2) {
    if (node1.listHeight === node2.listHeight) {
        return _ast_js__WEBPACK_IMPORTED_MODULE_0__.ListAstNode.create23(node1, node2, null, false);
    }
    else if (node1.listHeight > node2.listHeight) {
        // node1 is the tree we want to insert into
        return append(node1, node2);
    }
    else {
        return prepend(node2, node1);
    }
}
/**
 * Appends the given node to the end of this (2,3) tree.
 * Returns the new root.
*/
function append(list, nodeToAppend) {
    list = list.toMutable();
    let curNode = list;
    const parents = [];
    let nodeToAppendOfCorrectHeight;
    while (true) {
        // assert nodeToInsert.listHeight <= curNode.listHeight
        if (nodeToAppend.listHeight === curNode.listHeight) {
            nodeToAppendOfCorrectHeight = nodeToAppend;
            break;
        }
        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight
        if (curNode.kind !== 4 /* AstNodeKind.List */) {
            throw new Error('unexpected');
        }
        parents.push(curNode);
        // assert 2 <= curNode.childrenLength <= 3
        curNode = curNode.makeLastElementMutable();
    }
    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight
    for (let i = parents.length - 1; i >= 0; i--) {
        const parent = parents[i];
        if (nodeToAppendOfCorrectHeight) {
            // Can we take the element?
            if (parent.childrenLength >= 3) {
                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1
                // we need to split to maintain (2,3)-tree property.
                // Send the third element + the new element to the parent.
                nodeToAppendOfCorrectHeight = _ast_js__WEBPACK_IMPORTED_MODULE_0__.ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);
            }
            else {
                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);
                nodeToAppendOfCorrectHeight = undefined;
            }
        }
        else {
            parent.handleChildrenChanged();
        }
    }
    if (nodeToAppendOfCorrectHeight) {
        return _ast_js__WEBPACK_IMPORTED_MODULE_0__.ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);
    }
    else {
        return list;
    }
}
/**
 * Prepends the given node to the end of this (2,3) tree.
 * Returns the new root.
*/
function prepend(list, nodeToAppend) {
    list = list.toMutable();
    let curNode = list;
    const parents = [];
    // assert nodeToInsert.listHeight <= curNode.listHeight
    while (nodeToAppend.listHeight !== curNode.listHeight) {
        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight
        if (curNode.kind !== 4 /* AstNodeKind.List */) {
            throw new Error('unexpected');
        }
        parents.push(curNode);
        // assert 2 <= curNode.childrenFast.length <= 3
        curNode = curNode.makeFirstElementMutable();
    }
    let nodeToPrependOfCorrectHeight = nodeToAppend;
    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight
    for (let i = parents.length - 1; i >= 0; i--) {
        const parent = parents[i];
        if (nodeToPrependOfCorrectHeight) {
            // Can we take the element?
            if (parent.childrenLength >= 3) {
                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1
                // we need to split to maintain (2,3)-tree property.
                // Send the third element + the new element to the parent.
                nodeToPrependOfCorrectHeight = _ast_js__WEBPACK_IMPORTED_MODULE_0__.ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);
            }
            else {
                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);
                nodeToPrependOfCorrectHeight = undefined;
            }
        }
        else {
            parent.handleChildrenChanged();
        }
    }
    if (nodeToPrependOfCorrectHeight) {
        return _ast_js__WEBPACK_IMPORTED_MODULE_0__.ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);
    }
    else {
        return list;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lengthAdd: () => (/* binding */ lengthAdd),
/* harmony export */   lengthDiff: () => (/* binding */ lengthDiff),
/* harmony export */   lengthDiffNonNegative: () => (/* binding */ lengthDiffNonNegative),
/* harmony export */   lengthEquals: () => (/* binding */ lengthEquals),
/* harmony export */   lengthGetColumnCountIfZeroLineCount: () => (/* binding */ lengthGetColumnCountIfZeroLineCount),
/* harmony export */   lengthGetLineCount: () => (/* binding */ lengthGetLineCount),
/* harmony export */   lengthGreaterThanEqual: () => (/* binding */ lengthGreaterThanEqual),
/* harmony export */   lengthIsZero: () => (/* binding */ lengthIsZero),
/* harmony export */   lengthLessThan: () => (/* binding */ lengthLessThan),
/* harmony export */   lengthLessThanEqual: () => (/* binding */ lengthLessThanEqual),
/* harmony export */   lengthOfString: () => (/* binding */ lengthOfString),
/* harmony export */   lengthToObj: () => (/* binding */ lengthToObj),
/* harmony export */   lengthZero: () => (/* binding */ lengthZero),
/* harmony export */   lengthsToRange: () => (/* binding */ lengthsToRange),
/* harmony export */   positionToLength: () => (/* binding */ positionToLength),
/* harmony export */   sumLengths: () => (/* binding */ sumLengths),
/* harmony export */   toLength: () => (/* binding */ toLength)
/* harmony export */ });
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _core_textLength_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/textLength.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



/**
 * The end must be greater than or equal to the start.
*/
function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {
    return (startLineCount !== endLineCount)
        ? toLength(endLineCount - startLineCount, endColumnCount)
        : toLength(0, endColumnCount - startColumnCount);
}
const lengthZero = 0;
function lengthIsZero(length) {
    return length === 0;
}
/*
 * We have 52 bits available in a JS number.
 * We use the upper 26 bits to store the line and the lower 26 bits to store the column.
 */
///*
const factor = 2 ** 26;
/*/
const factor = 1000000;
// */
function toLength(lineCount, columnCount) {
    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)
    //       line count (26 bits)    column count (26 bits)
    // If there is no overflow (all values/sums below 2^26 = 67108864),
    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.
    return (lineCount * factor + columnCount);
}
function lengthToObj(length) {
    const l = length;
    const lineCount = Math.floor(l / factor);
    const columnCount = l - lineCount * factor;
    return new _core_textLength_js__WEBPACK_IMPORTED_MODULE_2__.TextLength(lineCount, columnCount);
}
function lengthGetLineCount(length) {
    return Math.floor(length / factor);
}
/**
 * Returns the amount of columns of the given length, assuming that it does not span any line.
*/
function lengthGetColumnCountIfZeroLineCount(length) {
    return length;
}
function lengthAdd(l1, l2) {
    let r = l1 + l2;
    if (l2 >= factor) {
        r = r - (l1 % factor);
    }
    return r;
}
function sumLengths(items, lengthFn) {
    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);
}
function lengthEquals(length1, length2) {
    return length1 === length2;
}
/**
 * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.
 */
function lengthDiffNonNegative(length1, length2) {
    const l1 = length1;
    const l2 = length2;
    const diff = l2 - l1;
    if (diff <= 0) {
        // line-count of length1 is higher than line-count of length2
        // or they are equal and column-count of length1 is higher than column-count of length2
        return lengthZero;
    }
    const lineCount1 = Math.floor(l1 / factor);
    const lineCount2 = Math.floor(l2 / factor);
    const colCount2 = l2 - lineCount2 * factor;
    if (lineCount1 === lineCount2) {
        const colCount1 = l1 - lineCount1 * factor;
        return toLength(0, colCount2 - colCount1);
    }
    else {
        return toLength(lineCount2 - lineCount1, colCount2);
    }
}
function lengthLessThan(length1, length2) {
    // First, compare line counts, then column counts.
    return length1 < length2;
}
function lengthLessThanEqual(length1, length2) {
    return length1 <= length2;
}
function lengthGreaterThanEqual(length1, length2) {
    return length1 >= length2;
}
function positionToLength(position) {
    return toLength(position.lineNumber - 1, position.column - 1);
}
function lengthsToRange(lengthStart, lengthEnd) {
    const l = lengthStart;
    const lineCount = Math.floor(l / factor);
    const colCount = l - lineCount * factor;
    const l2 = lengthEnd;
    const lineCount2 = Math.floor(l2 / factor);
    const colCount2 = l2 - lineCount2 * factor;
    return new _core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);
}
function lengthOfString(str) {
    const lines = (0,_base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitLines)(str);
    return toLength(lines.length - 1, lines[lines.length - 1].length);
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NodeReader: () => (/* binding */ NodeReader)
/* harmony export */ });
/* harmony import */ var _length_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./length.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Allows to efficiently find a longest child at a given offset in a fixed node.
 * The requested offsets must increase monotonously.
*/
class NodeReader {
    constructor(node) {
        this.lastOffset = _length_js__WEBPACK_IMPORTED_MODULE_0__.lengthZero;
        this.nextNodes = [node];
        this.offsets = [_length_js__WEBPACK_IMPORTED_MODULE_0__.lengthZero];
        this.idxs = [];
    }
    /**
     * Returns the longest node at `offset` that satisfies the predicate.
     * @param offset must be greater than or equal to the last offset this method has been called with!
    */
    readLongestNodeAt(offset, predicate) {
        if ((0,_length_js__WEBPACK_IMPORTED_MODULE_0__.lengthLessThan)(offset, this.lastOffset)) {
            throw new Error('Invalid offset');
        }
        this.lastOffset = offset;
        // Find the longest node of all those that are closest to the current offset.
        while (true) {
            const curNode = lastOrUndefined(this.nextNodes);
            if (!curNode) {
                return undefined;
            }
            const curNodeOffset = lastOrUndefined(this.offsets);
            if ((0,_length_js__WEBPACK_IMPORTED_MODULE_0__.lengthLessThan)(offset, curNodeOffset)) {
                // The next best node is not here yet.
                // The reader must advance before a cached node is hit.
                return undefined;
            }
            if ((0,_length_js__WEBPACK_IMPORTED_MODULE_0__.lengthLessThan)(curNodeOffset, offset)) {
                // The reader is ahead of the current node.
                if ((0,_length_js__WEBPACK_IMPORTED_MODULE_0__.lengthAdd)(curNodeOffset, curNode.length) <= offset) {
                    // The reader is after the end of the current node.
                    this.nextNodeAfterCurrent();
                }
                else {
                    // The reader is somewhere in the current node.
                    const nextChildIdx = getNextChildIdx(curNode);
                    if (nextChildIdx !== -1) {
                        // Go to the first child and repeat.
                        this.nextNodes.push(curNode.getChild(nextChildIdx));
                        this.offsets.push(curNodeOffset);
                        this.idxs.push(nextChildIdx);
                    }
                    else {
                        // We don't have children
                        this.nextNodeAfterCurrent();
                    }
                }
            }
            else {
                // readerOffsetBeforeChange === curNodeOffset
                if (predicate(curNode)) {
                    this.nextNodeAfterCurrent();
                    return curNode;
                }
                else {
                    const nextChildIdx = getNextChildIdx(curNode);
                    // look for shorter node
                    if (nextChildIdx === -1) {
                        // There is no shorter node.
                        this.nextNodeAfterCurrent();
                        return undefined;
                    }
                    else {
                        // Descend into first child & repeat.
                        this.nextNodes.push(curNode.getChild(nextChildIdx));
                        this.offsets.push(curNodeOffset);
                        this.idxs.push(nextChildIdx);
                    }
                }
            }
        }
    }
    // Navigates to the longest node that continues after the current node.
    nextNodeAfterCurrent() {
        while (true) {
            const currentOffset = lastOrUndefined(this.offsets);
            const currentNode = lastOrUndefined(this.nextNodes);
            this.nextNodes.pop();
            this.offsets.pop();
            if (this.idxs.length === 0) {
                // We just popped the root node, there is no next node.
                break;
            }
            // Parent is not undefined, because idxs is not empty
            const parent = lastOrUndefined(this.nextNodes);
            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);
            if (nextChildIdx !== -1) {
                this.nextNodes.push(parent.getChild(nextChildIdx));
                this.offsets.push((0,_length_js__WEBPACK_IMPORTED_MODULE_0__.lengthAdd)(currentOffset, currentNode.length));
                this.idxs[this.idxs.length - 1] = nextChildIdx;
                break;
            }
            else {
                this.idxs.pop();
            }
            // We fully consumed the parent.
            // Current node is now parent, so call nextNodeAfterCurrent again
        }
    }
}
function getNextChildIdx(node, curIdx = -1) {
    while (true) {
        curIdx++;
        if (curIdx >= node.childrenLength) {
            return -1;
        }
        if (node.getChild(curIdx)) {
            return curIdx;
        }
    }
}
function lastOrUndefined(arr) {
    return arr.length > 0 ? arr[arr.length - 1] : undefined;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseDocument: () => (/* binding */ parseDocument)
/* harmony export */ });
/* harmony import */ var _ast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js");
/* harmony import */ var _beforeEditPositionMapper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./beforeEditPositionMapper.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js");
/* harmony import */ var _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./smallImmutableSet.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js");
/* harmony import */ var _length_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./length.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js");
/* harmony import */ var _concat23Trees_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./concat23Trees.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js");
/* harmony import */ var _nodeReader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nodeReader.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






/**
 * Non incrementally built ASTs are immutable.
*/
function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {
    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);
    return parser.parseDocument();
}
/**
 * Non incrementally built ASTs are immutable.
*/
class Parser {
    constructor(tokenizer, edits, oldNode, createImmutableLists) {
        this.tokenizer = tokenizer;
        this.createImmutableLists = createImmutableLists;
        this._itemsConstructed = 0;
        this._itemsFromCache = 0;
        if (oldNode && createImmutableLists) {
            throw new Error('Not supported');
        }
        this.oldNodeReader = oldNode ? new _nodeReader_js__WEBPACK_IMPORTED_MODULE_5__.NodeReader(oldNode) : undefined;
        this.positionMapper = new _beforeEditPositionMapper_js__WEBPACK_IMPORTED_MODULE_1__.BeforeEditPositionMapper(edits);
    }
    parseDocument() {
        this._itemsConstructed = 0;
        this._itemsFromCache = 0;
        let result = this.parseList(_smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_2__.SmallImmutableSet.getEmpty(), 0);
        if (!result) {
            result = _ast_js__WEBPACK_IMPORTED_MODULE_0__.ListAstNode.getEmpty();
        }
        return result;
    }
    parseList(openedBracketIds, level) {
        const items = [];
        while (true) {
            let child = this.tryReadChildFromCache(openedBracketIds);
            if (!child) {
                const token = this.tokenizer.peek();
                if (!token ||
                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&
                        token.bracketIds.intersects(openedBracketIds))) {
                    break;
                }
                child = this.parseChild(openedBracketIds, level + 1);
            }
            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {
                continue;
            }
            items.push(child);
        }
        // When there is no oldNodeReader, all items are created from scratch and must have the same height.
        const result = this.oldNodeReader ? (0,_concat23Trees_js__WEBPACK_IMPORTED_MODULE_4__.concat23Trees)(items) : (0,_concat23Trees_js__WEBPACK_IMPORTED_MODULE_4__.concat23TreesOfSameHeight)(items, this.createImmutableLists);
        return result;
    }
    tryReadChildFromCache(openedBracketIds) {
        if (this.oldNodeReader) {
            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);
            if (maxCacheableLength === null || !(0,_length_js__WEBPACK_IMPORTED_MODULE_3__.lengthIsZero)(maxCacheableLength)) {
                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {
                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.
                    // If there is no edit anymore, we can re-use the node in any case.
                    if (maxCacheableLength !== null && !(0,_length_js__WEBPACK_IMPORTED_MODULE_3__.lengthLessThan)(curNode.length, maxCacheableLength)) {
                        // Either the node contains edited text or touches edited text.
                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.
                        return false;
                    }
                    const canBeReused = curNode.canBeReused(openedBracketIds);
                    return canBeReused;
                });
                if (cachedNode) {
                    this._itemsFromCache++;
                    this.tokenizer.skip(cachedNode.length);
                    return cachedNode;
                }
            }
        }
        return undefined;
    }
    parseChild(openedBracketIds, level) {
        this._itemsConstructed++;
        const token = this.tokenizer.read();
        switch (token.kind) {
            case 2 /* TokenKind.ClosingBracket */:
                return new _ast_js__WEBPACK_IMPORTED_MODULE_0__.InvalidBracketAstNode(token.bracketIds, token.length);
            case 0 /* TokenKind.Text */:
                return token.astNode;
            case 1 /* TokenKind.OpeningBracket */: {
                if (level > 300) {
                    // To prevent stack overflows
                    return new _ast_js__WEBPACK_IMPORTED_MODULE_0__.TextAstNode(token.length);
                }
                const set = openedBracketIds.merge(token.bracketIds);
                const child = this.parseList(set, level + 1);
                const nextToken = this.tokenizer.peek();
                if (nextToken &&
                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&
                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {
                    this.tokenizer.read();
                    return _ast_js__WEBPACK_IMPORTED_MODULE_0__.PairAstNode.create(token.astNode, child, nextToken.astNode);
                }
                else {
                    return _ast_js__WEBPACK_IMPORTED_MODULE_0__.PairAstNode.create(token.astNode, child, null);
                }
            }
            default:
                throw new Error('unexpected');
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DenseKeyProvider: () => (/* binding */ DenseKeyProvider),
/* harmony export */   SmallImmutableSet: () => (/* binding */ SmallImmutableSet),
/* harmony export */   identityKeyProvider: () => (/* binding */ identityKeyProvider)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const emptyArr = [];
/**
 * Represents an immutable set that works best for a small number of elements (less than 32).
 * It uses bits to encode element membership efficiently.
*/
class SmallImmutableSet {
    static { this.cache = new Array(129); }
    static create(items, additionalItems) {
        if (items <= 128 && additionalItems.length === 0) {
            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.
            let cached = SmallImmutableSet.cache[items];
            if (!cached) {
                cached = new SmallImmutableSet(items, additionalItems);
                SmallImmutableSet.cache[items] = cached;
            }
            return cached;
        }
        return new SmallImmutableSet(items, additionalItems);
    }
    static { this.empty = SmallImmutableSet.create(0, emptyArr); }
    static getEmpty() {
        return this.empty;
    }
    constructor(items, additionalItems) {
        this.items = items;
        this.additionalItems = additionalItems;
    }
    add(value, keyProvider) {
        const key = keyProvider.getKey(value);
        let idx = key >> 5; // divided by 32
        if (idx === 0) {
            // fast path
            const newItem = (1 << key) | this.items;
            if (newItem === this.items) {
                return this;
            }
            return SmallImmutableSet.create(newItem, this.additionalItems);
        }
        idx--;
        const newItems = this.additionalItems.slice(0);
        while (newItems.length < idx) {
            newItems.push(0);
        }
        newItems[idx] |= 1 << (key & 31);
        return SmallImmutableSet.create(this.items, newItems);
    }
    merge(other) {
        const merged = this.items | other.items;
        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {
            // fast path
            if (merged === this.items) {
                return this;
            }
            if (merged === other.items) {
                return other;
            }
            return SmallImmutableSet.create(merged, emptyArr);
        }
        // This can be optimized, but it's not a common case
        const newItems = [];
        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {
            const item1 = this.additionalItems[i] || 0;
            const item2 = other.additionalItems[i] || 0;
            newItems.push(item1 | item2);
        }
        return SmallImmutableSet.create(merged, newItems);
    }
    intersects(other) {
        if ((this.items & other.items) !== 0) {
            return true;
        }
        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {
            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {
                return true;
            }
        }
        return false;
    }
}
const identityKeyProvider = {
    getKey(value) {
        return value;
    }
};
/**
 * Assigns values a unique incrementing key.
*/
class DenseKeyProvider {
    constructor() {
        this.items = new Map();
    }
    getKey(value) {
        let existing = this.items.get(value);
        if (existing === undefined) {
            existing = this.items.size;
            this.items.set(value, existing);
        }
        return existing;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FastTokenizer: () => (/* binding */ FastTokenizer),
/* harmony export */   TextBufferTokenizer: () => (/* binding */ TextBufferTokenizer),
/* harmony export */   Token: () => (/* binding */ Token)
/* harmony export */ });
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../encodedTokenAttributes.js */ "./node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js");
/* harmony import */ var _ast_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ast.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js");
/* harmony import */ var _length_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./length.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js");
/* harmony import */ var _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./smallImmutableSet.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





class Token {
    constructor(length, kind, 
    /**
     * If this token is an opening bracket, this is the id of the opening bracket.
     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.
     * Otherwise, it is -1.
     */
    bracketId, 
    /**
     * If this token is an opening bracket, this just contains `bracketId`.
     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.
     * Otherwise, it is empty.
     */
    bracketIds, astNode) {
        this.length = length;
        this.kind = kind;
        this.bracketId = bracketId;
        this.bracketIds = bracketIds;
        this.astNode = astNode;
    }
}
class TextBufferTokenizer {
    constructor(textModel, bracketTokens) {
        this.textModel = textModel;
        this.bracketTokens = bracketTokens;
        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);
        this._offset = _length_js__WEBPACK_IMPORTED_MODULE_3__.lengthZero;
        this.didPeek = false;
        this.peeked = null;
        this.textBufferLineCount = textModel.getLineCount();
        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);
    }
    get offset() {
        return this._offset;
    }
    get length() {
        return (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.toLength)(this.textBufferLineCount - 1, this.textBufferLastLineLength);
    }
    skip(length) {
        this.didPeek = false;
        this._offset = (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.lengthAdd)(this._offset, length);
        const obj = (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.lengthToObj)(this._offset);
        this.reader.setPosition(obj.lineCount, obj.columnCount);
    }
    read() {
        let token;
        if (this.peeked) {
            this.didPeek = false;
            token = this.peeked;
        }
        else {
            token = this.reader.read();
        }
        if (token) {
            this._offset = (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.lengthAdd)(this._offset, token.length);
        }
        return token;
    }
    peek() {
        if (!this.didPeek) {
            this.peeked = this.reader.read();
            this.didPeek = true;
        }
        return this.peeked;
    }
}
/**
 * Does not support peek.
*/
class NonPeekableTextBufferTokenizer {
    constructor(textModel, bracketTokens) {
        this.textModel = textModel;
        this.bracketTokens = bracketTokens;
        this.lineIdx = 0;
        this.line = null;
        this.lineCharOffset = 0;
        this.lineTokens = null;
        this.lineTokenOffset = 0;
        /** Must be a zero line token. The end of the document cannot be peeked. */
        this.peekedToken = null;
        this.textBufferLineCount = textModel.getLineCount();
        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);
    }
    setPosition(lineIdx, column) {
        // We must not jump into a token!
        if (lineIdx === this.lineIdx) {
            this.lineCharOffset = column;
            if (this.line !== null) {
                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);
            }
        }
        else {
            this.lineIdx = lineIdx;
            this.lineCharOffset = column;
            this.line = null;
        }
        this.peekedToken = null;
    }
    read() {
        if (this.peekedToken) {
            const token = this.peekedToken;
            this.peekedToken = null;
            this.lineCharOffset += (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.lengthGetColumnCountIfZeroLineCount)(token.length);
            return token;
        }
        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {
            // We are after the end
            return null;
        }
        if (this.line === null) {
            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);
            this.line = this.lineTokens.getLineContent();
            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);
        }
        const startLineIdx = this.lineIdx;
        const startLineCharOffset = this.lineCharOffset;
        // limits the length of text tokens.
        // If text tokens get too long, incremental updates will be slow
        let lengthHeuristic = 0;
        while (true) {
            const lineTokens = this.lineTokens;
            const tokenCount = lineTokens.getCount();
            let peekedBracketToken = null;
            if (this.lineTokenOffset < tokenCount) {
                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);
                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {
                    // Skip tokens that are identical.
                    // Sometimes, (bracket) identifiers are split up into multiple tokens.
                    this.lineTokenOffset++;
                }
                const isOther = _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_1__.TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;
                const containsBracketType = _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_1__.TokenMetadata.containsBalancedBrackets(tokenMetadata);
                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);
                // Is there a bracket token next? Only consume text.
                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {
                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);
                    const text = this.line.substring(this.lineCharOffset, endOffset);
                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);
                    const regexp = brackets.regExpGlobal;
                    if (regexp) {
                        regexp.lastIndex = 0;
                        const match = regexp.exec(text);
                        if (match) {
                            peekedBracketToken = brackets.getToken(match[0]);
                            if (peekedBracketToken) {
                                // Consume leading text of the token
                                this.lineCharOffset += match.index;
                            }
                        }
                    }
                }
                lengthHeuristic += endOffset - this.lineCharOffset;
                if (peekedBracketToken) {
                    // Don't skip the entire token, as a single token could contain multiple brackets.
                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {
                        // There is text before the bracket
                        this.peekedToken = peekedBracketToken;
                        break;
                    }
                    else {
                        // Consume the peeked token
                        this.lineCharOffset += (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.lengthGetColumnCountIfZeroLineCount)(peekedBracketToken.length);
                        return peekedBracketToken;
                    }
                }
                else {
                    // Skip the entire token, as the token contains no brackets at all.
                    this.lineTokenOffset++;
                    this.lineCharOffset = endOffset;
                }
            }
            else {
                if (this.lineIdx === this.textBufferLineCount - 1) {
                    break;
                }
                this.lineIdx++;
                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);
                this.lineTokenOffset = 0;
                this.line = this.lineTokens.getLineContent();
                this.lineCharOffset = 0;
                lengthHeuristic += 33; // max 1000/33 = 30 lines
                // This limits the amount of work to recompute min-indentation
                if (lengthHeuristic > 1000) {
                    // only break (automatically) at the end of line.
                    break;
                }
            }
            if (lengthHeuristic > 1500) {
                // Eventually break regardless of the line length so that
                // very long lines do not cause bad performance.
                // This effective limits max indentation to 500, as
                // indentation is not computed across multiple text nodes.
                break;
            }
        }
        // If a token contains some proper indentation, it also contains \n{INDENTATION+}(?!{INDENTATION}),
        // unless the line is too long.
        // Thus, the min indentation of the document is the minimum min indentation of every text node.
        const length = (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.lengthDiff)(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);
        return new Token(length, 0 /* TokenKind.Text */, -1, _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_4__.SmallImmutableSet.getEmpty(), new _ast_js__WEBPACK_IMPORTED_MODULE_2__.TextAstNode(length));
    }
}
class FastTokenizer {
    constructor(text, brackets) {
        this.text = text;
        this._offset = _length_js__WEBPACK_IMPORTED_MODULE_3__.lengthZero;
        this.idx = 0;
        const regExpStr = brackets.getRegExpStr();
        const regexp = regExpStr ? new RegExp(regExpStr + '|\n', 'gi') : null;
        const tokens = [];
        let match;
        let curLineCount = 0;
        let lastLineBreakOffset = 0;
        let lastTokenEndOffset = 0;
        let lastTokenEndLine = 0;
        const smallTextTokens0Line = [];
        for (let i = 0; i < 60; i++) {
            smallTextTokens0Line.push(new Token((0,_length_js__WEBPACK_IMPORTED_MODULE_3__.toLength)(0, i), 0 /* TokenKind.Text */, -1, _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_4__.SmallImmutableSet.getEmpty(), new _ast_js__WEBPACK_IMPORTED_MODULE_2__.TextAstNode((0,_length_js__WEBPACK_IMPORTED_MODULE_3__.toLength)(0, i))));
        }
        const smallTextTokens1Line = [];
        for (let i = 0; i < 60; i++) {
            smallTextTokens1Line.push(new Token((0,_length_js__WEBPACK_IMPORTED_MODULE_3__.toLength)(1, i), 0 /* TokenKind.Text */, -1, _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_4__.SmallImmutableSet.getEmpty(), new _ast_js__WEBPACK_IMPORTED_MODULE_2__.TextAstNode((0,_length_js__WEBPACK_IMPORTED_MODULE_3__.toLength)(1, i))));
        }
        if (regexp) {
            regexp.lastIndex = 0;
            // If a token contains indentation, it also contains \n{INDENTATION+}(?!{INDENTATION})
            while ((match = regexp.exec(text)) !== null) {
                const curOffset = match.index;
                const value = match[0];
                if (value === '\n') {
                    curLineCount++;
                    lastLineBreakOffset = curOffset + 1;
                }
                else {
                    if (lastTokenEndOffset !== curOffset) {
                        let token;
                        if (lastTokenEndLine === curLineCount) {
                            const colCount = curOffset - lastTokenEndOffset;
                            if (colCount < smallTextTokens0Line.length) {
                                token = smallTextTokens0Line[colCount];
                            }
                            else {
                                const length = (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.toLength)(0, colCount);
                                token = new Token(length, 0 /* TokenKind.Text */, -1, _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_4__.SmallImmutableSet.getEmpty(), new _ast_js__WEBPACK_IMPORTED_MODULE_2__.TextAstNode(length));
                            }
                        }
                        else {
                            const lineCount = curLineCount - lastTokenEndLine;
                            const colCount = curOffset - lastLineBreakOffset;
                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {
                                token = smallTextTokens1Line[colCount];
                            }
                            else {
                                const length = (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.toLength)(lineCount, colCount);
                                token = new Token(length, 0 /* TokenKind.Text */, -1, _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_4__.SmallImmutableSet.getEmpty(), new _ast_js__WEBPACK_IMPORTED_MODULE_2__.TextAstNode(length));
                            }
                        }
                        tokens.push(token);
                    }
                    // value is matched by regexp, so the token must exist
                    tokens.push(brackets.getToken(value));
                    lastTokenEndOffset = curOffset + value.length;
                    lastTokenEndLine = curLineCount;
                }
            }
        }
        const offset = text.length;
        if (lastTokenEndOffset !== offset) {
            const length = (lastTokenEndLine === curLineCount)
                ? (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.toLength)(0, offset - lastTokenEndOffset)
                : (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.toLength)(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);
            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, _smallImmutableSet_js__WEBPACK_IMPORTED_MODULE_4__.SmallImmutableSet.getEmpty(), new _ast_js__WEBPACK_IMPORTED_MODULE_2__.TextAstNode(length)));
        }
        this.length = (0,_length_js__WEBPACK_IMPORTED_MODULE_3__.toLength)(curLineCount, offset - lastLineBreakOffset);
        this.tokens = tokens;
    }
    get offset() {
        return this._offset;
    }
    read() {
        return this.tokens[this.idx++] || null;
    }
    peek() {
        return this.tokens[this.idx] || null;
    }
    skip(length) {
        throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.NotSupportedError();
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorizedBracketPairsDecorationProvider: () => (/* binding */ ColorizedBracketPairsDecorationProvider)
/* harmony export */ });
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _core_editorColorRegistry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/editorColorRegistry.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js");
/* harmony import */ var _platform_theme_common_themeService_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../platform/theme/common/themeService.js */ "./node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





class ColorizedBracketPairsDecorationProvider extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    constructor(textModel) {
        super();
        this.textModel = textModel;
        this.colorProvider = new ColorProvider();
        this.onDidChangeEmitter = new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;
        this._register(textModel.bracketPairs.onDidChange(e => {
            this.onDidChangeEmitter.fire();
        }));
    }
    //#region TextModel events
    handleDidChangeOptions(e) {
        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;
    }
    //#endregion
    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {
        if (onlyMinimapDecorations) {
            // Bracket pair colorization decorations are not rendered in the minimap
            return [];
        }
        if (ownerId === undefined) {
            return [];
        }
        if (!this.colorizationOptions.enabled) {
            return [];
        }
        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({
            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,
            options: {
                description: 'BracketPairColorization',
                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),
            },
            ownerId: 0,
            range: bracket.range,
        })).toArray();
        return result;
    }
    getAllDecorations(ownerId, filterOutValidation) {
        if (ownerId === undefined) {
            return [];
        }
        if (!this.colorizationOptions.enabled) {
            return [];
        }
        return this.getDecorationsInRange(new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);
    }
}
class ColorProvider {
    constructor() {
        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';
    }
    getInlineClassName(bracket, independentColorPoolPerBracketType) {
        if (bracket.isInvalid) {
            return this.unexpectedClosingBracketClassName;
        }
        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);
    }
    getInlineClassNameOfLevel(level) {
        // To support a dynamic amount of colors up to 6 colors,
        // we use a number that is a lcm of all numbers from 1 to 6.
        return `bracket-highlighting-${level % 30}`;
    }
}
(0,_platform_theme_common_themeService_js__WEBPACK_IMPORTED_MODULE_4__.registerThemingParticipant)((theme, collector) => {
    const colors = [
        _core_editorColorRegistry_js__WEBPACK_IMPORTED_MODULE_3__.editorBracketHighlightingForeground1,
        _core_editorColorRegistry_js__WEBPACK_IMPORTED_MODULE_3__.editorBracketHighlightingForeground2,
        _core_editorColorRegistry_js__WEBPACK_IMPORTED_MODULE_3__.editorBracketHighlightingForeground3,
        _core_editorColorRegistry_js__WEBPACK_IMPORTED_MODULE_3__.editorBracketHighlightingForeground4,
        _core_editorColorRegistry_js__WEBPACK_IMPORTED_MODULE_3__.editorBracketHighlightingForeground5,
        _core_editorColorRegistry_js__WEBPACK_IMPORTED_MODULE_3__.editorBracketHighlightingForeground6
    ];
    const colorProvider = new ColorProvider();
    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(_core_editorColorRegistry_js__WEBPACK_IMPORTED_MODULE_3__.editorBracketHighlightingUnexpectedBracketForeground)}; }`);
    const colorValues = colors
        .map(c => theme.getColor(c))
        .filter((c) => !!c)
        .filter(c => !c.isTransparent());
    for (let level = 0; level < 30; level++) {
        const color = colorValues[level % colorValues.length];
        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);
    }
});


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EditStack: () => (/* binding */ EditStack),
/* harmony export */   MultiModelEditStackElement: () => (/* binding */ MultiModelEditStackElement),
/* harmony export */   SingleModelEditStackData: () => (/* binding */ SingleModelEditStackData),
/* harmony export */   SingleModelEditStackElement: () => (/* binding */ SingleModelEditStackElement),
/* harmony export */   isEditStackElement: () => (/* binding */ isEditStackElement)
/* harmony export */ });
/* harmony import */ var _nls_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../nls.js */ "./node_modules/monaco-editor/esm/vs/nls.js");
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _core_selection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/selection.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js");
/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/uri.js */ "./node_modules/monaco-editor/esm/vs/base/common/uri.js");
/* harmony import */ var _core_textChange_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/textChange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js");
/* harmony import */ var _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../base/common/buffer.js */ "./node_modules/monaco-editor/esm/vs/base/common/buffer.js");
/* harmony import */ var _base_common_resources_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../base/common/resources.js */ "./node_modules/monaco-editor/esm/vs/base/common/resources.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/







function uriGetComparisonKey(resource) {
    return resource.toString();
}
class SingleModelEditStackData {
    static create(model, beforeCursorState) {
        const alternativeVersionId = model.getAlternativeVersionId();
        const eol = getModelEOL(model);
        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);
    }
    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {
        this.beforeVersionId = beforeVersionId;
        this.afterVersionId = afterVersionId;
        this.beforeEOL = beforeEOL;
        this.afterEOL = afterEOL;
        this.beforeCursorState = beforeCursorState;
        this.afterCursorState = afterCursorState;
        this.changes = changes;
    }
    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
        if (textChanges.length > 0) {
            this.changes = (0,_core_textChange_js__WEBPACK_IMPORTED_MODULE_4__.compressConsecutiveTextChanges)(this.changes, textChanges);
        }
        this.afterEOL = afterEOL;
        this.afterVersionId = afterVersionId;
        this.afterCursorState = afterCursorState;
    }
    static _writeSelectionsSize(selections) {
        return 4 + 4 * 4 * (selections ? selections.length : 0);
    }
    static _writeSelections(b, selections, offset) {
        _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.writeUInt32BE(b, (selections ? selections.length : 0), offset);
        offset += 4;
        if (selections) {
            for (const selection of selections) {
                _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.writeUInt32BE(b, selection.selectionStartLineNumber, offset);
                offset += 4;
                _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.writeUInt32BE(b, selection.selectionStartColumn, offset);
                offset += 4;
                _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.writeUInt32BE(b, selection.positionLineNumber, offset);
                offset += 4;
                _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.writeUInt32BE(b, selection.positionColumn, offset);
                offset += 4;
            }
        }
        return offset;
    }
    static _readSelections(b, offset, dest) {
        const count = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.readUInt32BE(b, offset);
        offset += 4;
        for (let i = 0; i < count; i++) {
            const selectionStartLineNumber = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.readUInt32BE(b, offset);
            offset += 4;
            const selectionStartColumn = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.readUInt32BE(b, offset);
            offset += 4;
            const positionLineNumber = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.readUInt32BE(b, offset);
            offset += 4;
            const positionColumn = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.readUInt32BE(b, offset);
            offset += 4;
            dest.push(new _core_selection_js__WEBPACK_IMPORTED_MODULE_2__.Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));
        }
        return offset;
    }
    serialize() {
        let necessarySize = (+4 // beforeVersionId
            + 4 // afterVersionId
            + 1 // beforeEOL
            + 1 // afterEOL
            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)
            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)
            + 4 // change count
        );
        for (const change of this.changes) {
            necessarySize += change.writeSize();
        }
        const b = new Uint8Array(necessarySize);
        let offset = 0;
        _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.writeUInt32BE(b, this.beforeVersionId, offset);
        offset += 4;
        _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.writeUInt32BE(b, this.afterVersionId, offset);
        offset += 4;
        _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.writeUInt8(b, this.beforeEOL, offset);
        offset += 1;
        _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.writeUInt8(b, this.afterEOL, offset);
        offset += 1;
        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);
        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);
        _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.writeUInt32BE(b, this.changes.length, offset);
        offset += 4;
        for (const change of this.changes) {
            offset = change.write(b, offset);
        }
        return b.buffer;
    }
    static deserialize(source) {
        const b = new Uint8Array(source);
        let offset = 0;
        const beforeVersionId = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.readUInt32BE(b, offset);
        offset += 4;
        const afterVersionId = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.readUInt32BE(b, offset);
        offset += 4;
        const beforeEOL = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.readUInt8(b, offset);
        offset += 1;
        const afterEOL = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.readUInt8(b, offset);
        offset += 1;
        const beforeCursorState = [];
        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);
        const afterCursorState = [];
        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);
        const changeCount = _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_5__.readUInt32BE(b, offset);
        offset += 4;
        const changes = [];
        for (let i = 0; i < changeCount; i++) {
            offset = _core_textChange_js__WEBPACK_IMPORTED_MODULE_4__.TextChange.read(b, offset, changes);
        }
        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);
    }
}
class SingleModelEditStackElement {
    get type() {
        return 0 /* UndoRedoElementType.Resource */;
    }
    get resource() {
        if (_base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.isUri(this.model)) {
            return this.model;
        }
        return this.model.uri;
    }
    constructor(label, code, model, beforeCursorState) {
        this.label = label;
        this.code = code;
        this.model = model;
        this._data = SingleModelEditStackData.create(model, beforeCursorState);
    }
    toString() {
        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));
        return data.changes.map(change => change.toString()).join(', ');
    }
    matchesResource(resource) {
        const uri = (_base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.isUri(this.model) ? this.model : this.model.uri);
        return (uri.toString() === resource.toString());
    }
    setModel(model) {
        this.model = model;
    }
    canAppend(model) {
        return (this.model === model && this._data instanceof SingleModelEditStackData);
    }
    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
        if (this._data instanceof SingleModelEditStackData) {
            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);
        }
    }
    close() {
        if (this._data instanceof SingleModelEditStackData) {
            this._data = this._data.serialize();
        }
    }
    open() {
        if (!(this._data instanceof SingleModelEditStackData)) {
            this._data = SingleModelEditStackData.deserialize(this._data);
        }
    }
    undo() {
        if (_base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.isUri(this.model)) {
            // don't have a model
            throw new Error(`Invalid SingleModelEditStackElement`);
        }
        if (this._data instanceof SingleModelEditStackData) {
            this._data = this._data.serialize();
        }
        const data = SingleModelEditStackData.deserialize(this._data);
        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);
    }
    redo() {
        if (_base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.isUri(this.model)) {
            // don't have a model
            throw new Error(`Invalid SingleModelEditStackElement`);
        }
        if (this._data instanceof SingleModelEditStackData) {
            this._data = this._data.serialize();
        }
        const data = SingleModelEditStackData.deserialize(this._data);
        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);
    }
    heapSize() {
        if (this._data instanceof SingleModelEditStackData) {
            this._data = this._data.serialize();
        }
        return this._data.byteLength + 168 /*heap overhead*/;
    }
}
class MultiModelEditStackElement {
    get resources() {
        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);
    }
    constructor(label, code, editStackElements) {
        this.label = label;
        this.code = code;
        this.type = 1 /* UndoRedoElementType.Workspace */;
        this._isOpen = true;
        this._editStackElementsArr = editStackElements.slice(0);
        this._editStackElementsMap = new Map();
        for (const editStackElement of this._editStackElementsArr) {
            const key = uriGetComparisonKey(editStackElement.resource);
            this._editStackElementsMap.set(key, editStackElement);
        }
        this._delegate = null;
    }
    prepareUndoRedo() {
        if (this._delegate) {
            return this._delegate.prepareUndoRedo(this);
        }
    }
    matchesResource(resource) {
        const key = uriGetComparisonKey(resource);
        return (this._editStackElementsMap.has(key));
    }
    setModel(model) {
        const key = uriGetComparisonKey(_base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.isUri(model) ? model : model.uri);
        if (this._editStackElementsMap.has(key)) {
            this._editStackElementsMap.get(key).setModel(model);
        }
    }
    canAppend(model) {
        if (!this._isOpen) {
            return false;
        }
        const key = uriGetComparisonKey(model.uri);
        if (this._editStackElementsMap.has(key)) {
            const editStackElement = this._editStackElementsMap.get(key);
            return editStackElement.canAppend(model);
        }
        return false;
    }
    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
        const key = uriGetComparisonKey(model.uri);
        const editStackElement = this._editStackElementsMap.get(key);
        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);
    }
    close() {
        this._isOpen = false;
    }
    open() {
        // cannot reopen
    }
    undo() {
        this._isOpen = false;
        for (const editStackElement of this._editStackElementsArr) {
            editStackElement.undo();
        }
    }
    redo() {
        for (const editStackElement of this._editStackElementsArr) {
            editStackElement.redo();
        }
    }
    heapSize(resource) {
        const key = uriGetComparisonKey(resource);
        if (this._editStackElementsMap.has(key)) {
            const editStackElement = this._editStackElementsMap.get(key);
            return editStackElement.heapSize();
        }
        return 0;
    }
    split() {
        return this._editStackElementsArr;
    }
    toString() {
        const result = [];
        for (const editStackElement of this._editStackElementsArr) {
            result.push(`${(0,_base_common_resources_js__WEBPACK_IMPORTED_MODULE_6__.basename)(editStackElement.resource)}: ${editStackElement}`);
        }
        return `{${result.join(', ')}}`;
    }
}
function getModelEOL(model) {
    const eol = model.getEOL();
    if (eol === '\n') {
        return 0 /* EndOfLineSequence.LF */;
    }
    else {
        return 1 /* EndOfLineSequence.CRLF */;
    }
}
function isEditStackElement(element) {
    if (!element) {
        return false;
    }
    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));
}
class EditStack {
    constructor(model, undoRedoService) {
        this._model = model;
        this._undoRedoService = undoRedoService;
    }
    pushStackElement() {
        const lastElement = this._undoRedoService.getLastElement(this._model.uri);
        if (isEditStackElement(lastElement)) {
            lastElement.close();
        }
    }
    popStackElement() {
        const lastElement = this._undoRedoService.getLastElement(this._model.uri);
        if (isEditStackElement(lastElement)) {
            lastElement.open();
        }
    }
    clear() {
        this._undoRedoService.removeElements(this._model.uri);
    }
    _getOrCreateEditStackElement(beforeCursorState, group) {
        const lastElement = this._undoRedoService.getLastElement(this._model.uri);
        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {
            return lastElement;
        }
        const newElement = new SingleModelEditStackElement(_nls_js__WEBPACK_IMPORTED_MODULE_0__.localize('edit', "Typing"), 'undoredo.textBufferEdit', this._model, beforeCursorState);
        this._undoRedoService.pushElement(newElement, group);
        return newElement;
    }
    pushEOL(eol) {
        const editStackElement = this._getOrCreateEditStackElement(null, undefined);
        this._model.setEOL(eol);
        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);
    }
    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {
        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);
        const inverseEditOperations = this._model.applyEdits(editOperations, true);
        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);
        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));
        textChanges.sort((a, b) => {
            if (a.textChange.oldPosition === b.textChange.oldPosition) {
                return a.index - b.index;
            }
            return a.textChange.oldPosition - b.textChange.oldPosition;
        });
        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);
        return afterCursorState;
    }
    static _computeCursorState(cursorStateComputer, inverseEditOperations) {
        try {
            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;
        }
        catch (e) {
            (0,_base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.onUnexpectedError)(e);
            return null;
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FixedArray: () => (/* binding */ FixedArray)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * An array that avoids being sparse by always
 * filling up unused indices with a default value.
 */
class FixedArray {
    constructor(_default) {
        this._default = _default;
        this._store = [];
    }
    get(index) {
        if (index < this._store.length) {
            return this._store[index];
        }
        return this._default;
    }
    set(index, value) {
        while (index >= this._store.length) {
            this._store[this._store.length] = this._default;
        }
        this._store[index] = value;
    }
    replace(index, oldLength, newLength) {
        if (index >= this._store.length) {
            return;
        }
        if (oldLength === 0) {
            this.insert(index, newLength);
            return;
        }
        else if (newLength === 0) {
            this.delete(index, oldLength);
            return;
        }
        const before = this._store.slice(0, index);
        const after = this._store.slice(index + oldLength);
        const insertArr = arrayFill(newLength, this._default);
        this._store = before.concat(insertArr, after);
    }
    delete(deleteIndex, deleteCount) {
        if (deleteCount === 0 || deleteIndex >= this._store.length) {
            return;
        }
        this._store.splice(deleteIndex, deleteCount);
    }
    insert(insertIndex, insertCount) {
        if (insertCount === 0 || insertIndex >= this._store.length) {
            return;
        }
        const arr = [];
        for (let i = 0; i < insertCount; i++) {
            arr[i] = this._default;
        }
        this._store = (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.arrayInsert)(this._store, insertIndex, arr);
    }
}
function arrayFill(length, value) {
    const arr = [];
    for (let i = 0; i < length; i++) {
        arr[i] = value;
    }
    return arr;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BracketPairGuidesClassNames: () => (/* binding */ BracketPairGuidesClassNames),
/* harmony export */   GuidesTextModelPart: () => (/* binding */ GuidesTextModelPart)
/* harmony export */ });
/* harmony import */ var _base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arraysFind.js */ "./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js");
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _core_cursorColumns_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/cursorColumns.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _textModelPart_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./textModelPart.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/utils.js");
/* harmony import */ var _textModelGuides_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../textModelGuides.js */ "./node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js");
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/








class GuidesTextModelPart extends _textModelPart_js__WEBPACK_IMPORTED_MODULE_4__.TextModelPart {
    constructor(textModel, languageConfigurationService) {
        super();
        this.textModel = textModel;
        this.languageConfigurationService = languageConfigurationService;
    }
    getLanguageConfiguration(languageId) {
        return this.languageConfigurationService.getLanguageConfiguration(languageId);
    }
    _computeIndentLevel(lineIndex) {
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.computeIndentLevel)(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);
    }
    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {
        this.assertNotDisposed();
        const lineCount = this.textModel.getLineCount();
        if (lineNumber < 1 || lineNumber > lineCount) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_7__.BugIndicatingError('Illegal value for lineNumber');
        }
        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;
        const offSide = Boolean(foldingRules && foldingRules.offSide);
        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */
        let up_aboveContentLineIndent = -1;
        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */
        let up_belowContentLineIndent = -1;
        const up_resolveIndents = (lineNumber) => {
            if (up_aboveContentLineIndex !== -1 &&
                (up_aboveContentLineIndex === -2 ||
                    up_aboveContentLineIndex > lineNumber - 1)) {
                up_aboveContentLineIndex = -1;
                up_aboveContentLineIndent = -1;
                // must find previous line with content
                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
                    const indent = this._computeIndentLevel(lineIndex);
                    if (indent >= 0) {
                        up_aboveContentLineIndex = lineIndex;
                        up_aboveContentLineIndent = indent;
                        break;
                    }
                }
            }
            if (up_belowContentLineIndex === -2) {
                up_belowContentLineIndex = -1;
                up_belowContentLineIndent = -1;
                // must find next line with content
                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
                    const indent = this._computeIndentLevel(lineIndex);
                    if (indent >= 0) {
                        up_belowContentLineIndex = lineIndex;
                        up_belowContentLineIndent = indent;
                        break;
                    }
                }
            }
        };
        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */
        let down_aboveContentLineIndent = -1;
        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */
        let down_belowContentLineIndent = -1;
        const down_resolveIndents = (lineNumber) => {
            if (down_aboveContentLineIndex === -2) {
                down_aboveContentLineIndex = -1;
                down_aboveContentLineIndent = -1;
                // must find previous line with content
                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
                    const indent = this._computeIndentLevel(lineIndex);
                    if (indent >= 0) {
                        down_aboveContentLineIndex = lineIndex;
                        down_aboveContentLineIndent = indent;
                        break;
                    }
                }
            }
            if (down_belowContentLineIndex !== -1 &&
                (down_belowContentLineIndex === -2 ||
                    down_belowContentLineIndex < lineNumber - 1)) {
                down_belowContentLineIndex = -1;
                down_belowContentLineIndent = -1;
                // must find next line with content
                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
                    const indent = this._computeIndentLevel(lineIndex);
                    if (indent >= 0) {
                        down_belowContentLineIndex = lineIndex;
                        down_belowContentLineIndent = indent;
                        break;
                    }
                }
            }
        };
        let startLineNumber = 0;
        let goUp = true;
        let endLineNumber = 0;
        let goDown = true;
        let indent = 0;
        let initialIndent = 0;
        for (let distance = 0; goUp || goDown; distance++) {
            const upLineNumber = lineNumber - distance;
            const downLineNumber = lineNumber + distance;
            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {
                goUp = false;
            }
            if (distance > 1 &&
                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {
                goDown = false;
            }
            if (distance > 50000) {
                // stop processing
                goUp = false;
                goDown = false;
            }
            let upLineIndentLevel = -1;
            if (goUp && upLineNumber >= 1) {
                // compute indent level going up
                const currentIndent = this._computeIndentLevel(upLineNumber - 1);
                if (currentIndent >= 0) {
                    // This line has content (besides whitespace)
                    // Use the line's indent
                    up_belowContentLineIndex = upLineNumber - 1;
                    up_belowContentLineIndent = currentIndent;
                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);
                }
                else {
                    up_resolveIndents(upLineNumber);
                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);
                }
            }
            let downLineIndentLevel = -1;
            if (goDown && downLineNumber <= lineCount) {
                // compute indent level going down
                const currentIndent = this._computeIndentLevel(downLineNumber - 1);
                if (currentIndent >= 0) {
                    // This line has content (besides whitespace)
                    // Use the line's indent
                    down_aboveContentLineIndex = downLineNumber - 1;
                    down_aboveContentLineIndent = currentIndent;
                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);
                }
                else {
                    down_resolveIndents(downLineNumber);
                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);
                }
            }
            if (distance === 0) {
                initialIndent = upLineIndentLevel;
                continue;
            }
            if (distance === 1) {
                if (downLineNumber <= lineCount &&
                    downLineIndentLevel >= 0 &&
                    initialIndent + 1 === downLineIndentLevel) {
                    // This is the beginning of a scope, we have special handling here, since we want the
                    // child scope indent to be active, not the parent scope
                    goUp = false;
                    startLineNumber = downLineNumber;
                    endLineNumber = downLineNumber;
                    indent = downLineIndentLevel;
                    continue;
                }
                if (upLineNumber >= 1 &&
                    upLineIndentLevel >= 0 &&
                    upLineIndentLevel - 1 === initialIndent) {
                    // This is the end of a scope, just like above
                    goDown = false;
                    startLineNumber = upLineNumber;
                    endLineNumber = upLineNumber;
                    indent = upLineIndentLevel;
                    continue;
                }
                startLineNumber = lineNumber;
                endLineNumber = lineNumber;
                indent = initialIndent;
                if (indent === 0) {
                    // No need to continue
                    return { startLineNumber, endLineNumber, indent };
                }
            }
            if (goUp) {
                if (upLineIndentLevel >= indent) {
                    startLineNumber = upLineNumber;
                }
                else {
                    goUp = false;
                }
            }
            if (goDown) {
                if (downLineIndentLevel >= indent) {
                    endLineNumber = downLineNumber;
                }
                else {
                    goDown = false;
                }
            }
        }
        return { startLineNumber, endLineNumber, indent };
    }
    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {
        const result = [];
        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            result.push([]);
        }
        // If requested, this could be made configurable.
        const includeSingleLinePairs = true;
        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();
        let activeBracketPairRange = undefined;
        if (activePosition && bracketPairs.length > 0) {
            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&
                activePosition.lineNumber <= endLineNumber
                // We don't need to query the brackets again if the cursor is in the viewport
                ? bracketPairs
                : this.textModel.bracketPairs.getBracketPairsInRange(_core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(activePosition)).toArray()).filter((bp) => _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.strictContainsPosition(bp.range, activePosition));
            activeBracketPairRange = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_0__.findLast)(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)?.range;
        }
        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;
        const colorProvider = new BracketPairGuidesClassNames();
        for (const pair of bracketPairs) {
            /*


                    {
                    |
                    }

                    {
                    |
                    ----}

                ____{
                |test
                ----}

                renderHorizontalEndLineAtTheBottom:
                    {
                    |
                    |x}
                    --
                renderHorizontalEndLineAtTheBottom:
                ____{
                |test
                | x }
                ----
            */
            if (!pair.closingBracketRange) {
                continue;
            }
            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);
            if (!isActive && !options.includeInactive) {
                continue;
            }
            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +
                (options.highlightActive && isActive
                    ? ' ' + colorProvider.activeClassName
                    : '');
            const start = pair.openingBracketRange.getStartPosition();
            const end = pair.closingBracketRange.getStartPosition();
            const horizontalGuides = options.horizontalGuides === _textModelGuides_js__WEBPACK_IMPORTED_MODULE_6__.HorizontalGuidesState.Enabled || (options.horizontalGuides === _textModelGuides_js__WEBPACK_IMPORTED_MODULE_6__.HorizontalGuidesState.EnabledForActive && isActive);
            if (pair.range.startLineNumber === pair.range.endLineNumber) {
                if (includeSingleLinePairs && horizontalGuides) {
                    result[pair.range.startLineNumber - startLineNumber].push(new _textModelGuides_js__WEBPACK_IMPORTED_MODULE_6__.IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new _textModelGuides_js__WEBPACK_IMPORTED_MODULE_6__.IndentGuideHorizontalLine(false, end.column), -1, -1));
                }
                continue;
            }
            const endVisibleColumn = this.getVisibleColumnFromPosition(end);
            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());
            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);
            let renderHorizontalEndLineAtTheBottom = false;
            const firstNonWsIndex = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));
            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;
            if (hasTextBeforeClosingBracket) {
                renderHorizontalEndLineAtTheBottom = true;
            }
            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);
            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);
            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;
            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {
                result[l - startLineNumber].push(new _textModelGuides_js__WEBPACK_IMPORTED_MODULE_6__.IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));
            }
            if (horizontalGuides) {
                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {
                    result[start.lineNumber - startLineNumber].push(new _textModelGuides_js__WEBPACK_IMPORTED_MODULE_6__.IndentGuide(guideVisibleColumn, -1, className, new _textModelGuides_js__WEBPACK_IMPORTED_MODULE_6__.IndentGuideHorizontalLine(false, start.column), -1, -1));
                }
                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {
                    result[end.lineNumber - startLineNumber].push(new _textModelGuides_js__WEBPACK_IMPORTED_MODULE_6__.IndentGuide(guideVisibleColumn, -1, className, new _textModelGuides_js__WEBPACK_IMPORTED_MODULE_6__.IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));
                }
            }
        }
        for (const guides of result) {
            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);
        }
        return result;
    }
    getVisibleColumnFromPosition(position) {
        return (_core_cursorColumns_js__WEBPACK_IMPORTED_MODULE_2__.CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);
    }
    getLinesIndentGuides(startLineNumber, endLineNumber) {
        this.assertNotDisposed();
        const lineCount = this.textModel.getLineCount();
        if (startLineNumber < 1 || startLineNumber > lineCount) {
            throw new Error('Illegal value for startLineNumber');
        }
        if (endLineNumber < 1 || endLineNumber > lineCount) {
            throw new Error('Illegal value for endLineNumber');
        }
        const options = this.textModel.getOptions();
        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;
        const offSide = Boolean(foldingRules && foldingRules.offSide);
        const result = new Array(endLineNumber - startLineNumber + 1);
        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */
        let aboveContentLineIndent = -1;
        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */
        let belowContentLineIndent = -1;
        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            const resultIndex = lineNumber - startLineNumber;
            const currentIndent = this._computeIndentLevel(lineNumber - 1);
            if (currentIndent >= 0) {
                // This line has content (besides whitespace)
                // Use the line's indent
                aboveContentLineIndex = lineNumber - 1;
                aboveContentLineIndent = currentIndent;
                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);
                continue;
            }
            if (aboveContentLineIndex === -2) {
                aboveContentLineIndex = -1;
                aboveContentLineIndent = -1;
                // must find previous line with content
                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
                    const indent = this._computeIndentLevel(lineIndex);
                    if (indent >= 0) {
                        aboveContentLineIndex = lineIndex;
                        aboveContentLineIndent = indent;
                        break;
                    }
                }
            }
            if (belowContentLineIndex !== -1 &&
                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {
                belowContentLineIndex = -1;
                belowContentLineIndent = -1;
                // must find next line with content
                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
                    const indent = this._computeIndentLevel(lineIndex);
                    if (indent >= 0) {
                        belowContentLineIndex = lineIndex;
                        belowContentLineIndent = indent;
                        break;
                    }
                }
            }
            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);
        }
        return result;
    }
    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {
        const options = this.textModel.getOptions();
        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {
            // At the top or bottom of the file
            return 0;
        }
        else if (aboveContentLineIndent < belowContentLineIndent) {
            // we are inside the region above
            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);
        }
        else if (aboveContentLineIndent === belowContentLineIndent) {
            // we are in between two regions
            return Math.ceil(belowContentLineIndent / options.indentSize);
        }
        else {
            if (offSide) {
                // same level as region below
                return Math.ceil(belowContentLineIndent / options.indentSize);
            }
            else {
                // we are inside the region that ends below
                return 1 + Math.floor(belowContentLineIndent / options.indentSize);
            }
        }
    }
}
class BracketPairGuidesClassNames {
    constructor() {
        this.activeClassName = 'indent-active';
    }
    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {
        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);
    }
    getInlineClassNameOfLevel(level) {
        // To support a dynamic amount of colors up to 6 colors,
        // we use a number that is a lcm of all numbers from 1 to 6.
        return `bracket-indent-guide lvl-${level % 30}`;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   guessIndentation: () => (/* binding */ guessIndentation)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class SpacesDiffResult {
    constructor() {
        this.spacesDiff = 0;
        this.looksLikeAlignment = false;
    }
}
/**
 * Compute the diff in spaces between two line's indentation.
 */
function spacesDiff(a, aLength, b, bLength, result) {
    result.spacesDiff = 0;
    result.looksLikeAlignment = false;
    // This can go both ways (e.g.):
    //  - a: "\t"
    //  - b: "\t    "
    //  => This should count 1 tab and 4 spaces
    let i;
    for (i = 0; i < aLength && i < bLength; i++) {
        const aCharCode = a.charCodeAt(i);
        const bCharCode = b.charCodeAt(i);
        if (aCharCode !== bCharCode) {
            break;
        }
    }
    let aSpacesCnt = 0, aTabsCount = 0;
    for (let j = i; j < aLength; j++) {
        const aCharCode = a.charCodeAt(j);
        if (aCharCode === 32 /* CharCode.Space */) {
            aSpacesCnt++;
        }
        else {
            aTabsCount++;
        }
    }
    let bSpacesCnt = 0, bTabsCount = 0;
    for (let j = i; j < bLength; j++) {
        const bCharCode = b.charCodeAt(j);
        if (bCharCode === 32 /* CharCode.Space */) {
            bSpacesCnt++;
        }
        else {
            bTabsCount++;
        }
    }
    if (aSpacesCnt > 0 && aTabsCount > 0) {
        return;
    }
    if (bSpacesCnt > 0 && bTabsCount > 0) {
        return;
    }
    const tabsDiff = Math.abs(aTabsCount - bTabsCount);
    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);
    if (tabsDiff === 0) {
        // check if the indentation difference might be caused by alignment reasons
        // sometime folks like to align their code, but this should not be used as a hint
        result.spacesDiff = spacesDiff;
        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {
            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {
                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {
                    // This looks like an alignment desire: e.g.
                    // const a = b + c,
                    //       d = b - c;
                    result.looksLikeAlignment = true;
                }
            }
        }
        return;
    }
    if (spacesDiff % tabsDiff === 0) {
        result.spacesDiff = spacesDiff / tabsDiff;
        return;
    }
}
function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {
    // Look at most at the first 10k lines
    const linesCount = Math.min(source.getLineCount(), 10000);
    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation
    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation
    let previousLineText = ''; // content of latest line that contained non-whitespace chars
    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char
    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].
    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8
    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores
    const tmp = new SpacesDiffResult();
    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {
        const currentLineLength = source.getLineLength(lineNumber);
        const currentLineText = source.getLineContent(lineNumber);
        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.
        // checking charCode on chunks directly is cheaper.
        const useCurrentLineText = (currentLineLength <= 65536);
        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars
        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char
        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation
        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation
        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {
            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));
            if (charCode === 9 /* CharCode.Tab */) {
                currentLineTabsCount++;
            }
            else if (charCode === 32 /* CharCode.Space */) {
                currentLineSpacesCount++;
            }
            else {
                // Hit non whitespace character on this line
                currentLineHasContent = true;
                currentLineIndentation = j;
                break;
            }
        }
        // Ignore empty or only whitespace lines
        if (!currentLineHasContent) {
            continue;
        }
        if (currentLineTabsCount > 0) {
            linesIndentedWithTabsCount++;
        }
        else if (currentLineSpacesCount > 1) {
            linesIndentedWithSpacesCount++;
        }
        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);
        if (tmp.looksLikeAlignment) {
            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation
            //
            // - item1
            //   - item2
            //
            // otherwise skip this line entirely
            //
            // const a = 1,
            //       b = 2;
            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {
                continue;
            }
        }
        const currentSpacesDiff = tmp.spacesDiff;
        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
            spacesDiffCount[currentSpacesDiff]++;
        }
        previousLineText = currentLineText;
        previousLineIndentation = currentLineIndentation;
    }
    let insertSpaces = defaultInsertSpaces;
    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {
        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);
    }
    let tabSize = defaultTabSize;
    // Guess tabSize only if inserting spaces...
    if (insertSpaces) {
        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);
        // console.log("score threshold: " + tabSizeScore);
        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {
            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];
            if (possibleTabSizeScore > tabSizeScore) {
                tabSizeScore = possibleTabSizeScore;
                tabSize = possibleTabSize;
            }
        });
        // Let a tabSize of 2 win even if it is not the maximum
        // (only in case 4 was guessed)
        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {
            tabSize = 2;
        }
    }
    // console.log('--------------------------');
    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);
    // console.log('spacesDiffCount: ' + spacesDiffCount);
    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);
    return {
        insertSpaces: insertSpaces,
        tabSize: tabSize
    };
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IntervalNode: () => (/* binding */ IntervalNode),
/* harmony export */   IntervalTree: () => (/* binding */ IntervalTree),
/* harmony export */   SENTINEL: () => (/* binding */ SENTINEL),
/* harmony export */   getNodeColor: () => (/* binding */ getNodeColor),
/* harmony export */   intervalCompare: () => (/* binding */ intervalCompare),
/* harmony export */   nodeAcceptEdit: () => (/* binding */ nodeAcceptEdit),
/* harmony export */   recomputeMaxEnd: () => (/* binding */ recomputeMaxEnd)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function getNodeColor(node) {
    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);
}
function setNodeColor(node, color) {
    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));
}
function getNodeIsVisited(node) {
    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;
}
function setNodeIsVisited(node, value) {
    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));
}
function getNodeIsForValidation(node) {
    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;
}
function setNodeIsForValidation(node, value) {
    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));
}
function getNodeIsInGlyphMargin(node) {
    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;
}
function setNodeIsInGlyphMargin(node, value) {
    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));
}
function getNodeStickiness(node) {
    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);
}
function _setNodeStickiness(node, stickiness) {
    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));
}
function getCollapseOnReplaceEdit(node) {
    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;
}
function setCollapseOnReplaceEdit(node, value) {
    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));
}
class IntervalNode {
    constructor(id, start, end) {
        this.metadata = 0;
        this.parent = this;
        this.left = this;
        this.right = this;
        setNodeColor(this, 1 /* NodeColor.Red */);
        this.start = start;
        this.end = end;
        // FORCE_OVERFLOWING_TEST: this.delta = start;
        this.delta = 0;
        this.maxEnd = end;
        this.id = id;
        this.ownerId = 0;
        this.options = null;
        setNodeIsForValidation(this, false);
        setNodeIsInGlyphMargin(this, false);
        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);
        setCollapseOnReplaceEdit(this, false);
        this.cachedVersionId = 0;
        this.cachedAbsoluteStart = start;
        this.cachedAbsoluteEnd = end;
        this.range = null;
        setNodeIsVisited(this, false);
    }
    reset(versionId, start, end, range) {
        this.start = start;
        this.end = end;
        this.maxEnd = end;
        this.cachedVersionId = versionId;
        this.cachedAbsoluteStart = start;
        this.cachedAbsoluteEnd = end;
        this.range = range;
    }
    setOptions(options) {
        this.options = options;
        const className = this.options.className;
        setNodeIsForValidation(this, (className === "squiggly-error" /* ClassName.EditorErrorDecoration */
            || className === "squiggly-warning" /* ClassName.EditorWarningDecoration */
            || className === "squiggly-info" /* ClassName.EditorInfoDecoration */));
        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);
        _setNodeStickiness(this, this.options.stickiness);
        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);
    }
    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {
        if (this.cachedVersionId !== cachedVersionId) {
            this.range = null;
        }
        this.cachedVersionId = cachedVersionId;
        this.cachedAbsoluteStart = absoluteStart;
        this.cachedAbsoluteEnd = absoluteEnd;
    }
    detach() {
        this.parent = null;
        this.left = null;
        this.right = null;
    }
}
const SENTINEL = new IntervalNode(null, 0, 0);
SENTINEL.parent = SENTINEL;
SENTINEL.left = SENTINEL;
SENTINEL.right = SENTINEL;
setNodeColor(SENTINEL, 0 /* NodeColor.Black */);
class IntervalTree {
    constructor() {
        this.root = SENTINEL;
        this.requestNormalizeDelta = false;
    }
    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
        if (this.root === SENTINEL) {
            return [];
        }
        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
    }
    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
        if (this.root === SENTINEL) {
            return [];
        }
        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
    }
    /**
     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
     */
    collectNodesFromOwner(ownerId) {
        return collectNodesFromOwner(this, ownerId);
    }
    /**
     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
     */
    collectNodesPostOrder() {
        return collectNodesPostOrder(this);
    }
    insert(node) {
        rbTreeInsert(this, node);
        this._normalizeDeltaIfNecessary();
    }
    delete(node) {
        rbTreeDelete(this, node);
        this._normalizeDeltaIfNecessary();
    }
    resolveNode(node, cachedVersionId) {
        const initialNode = node;
        let delta = 0;
        while (node !== this.root) {
            if (node === node.parent.right) {
                delta += node.parent.delta;
            }
            node = node.parent;
        }
        const nodeStart = initialNode.start + delta;
        const nodeEnd = initialNode.end + delta;
        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
    }
    acceptReplace(offset, length, textLength, forceMoveMarkers) {
        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.
        // (1) collect all nodes that are intersecting this edit as nodes of interest
        const nodesOfInterest = searchForEditing(this, offset, offset + length);
        // (2) remove all nodes that are intersecting this edit
        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {
            const node = nodesOfInterest[i];
            rbTreeDelete(this, node);
        }
        this._normalizeDeltaIfNecessary();
        // (3) edit all tree nodes except the nodes of interest
        noOverlapReplace(this, offset, offset + length, textLength);
        this._normalizeDeltaIfNecessary();
        // (4) edit the nodes of interest and insert them back in the tree
        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {
            const node = nodesOfInterest[i];
            node.start = node.cachedAbsoluteStart;
            node.end = node.cachedAbsoluteEnd;
            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);
            node.maxEnd = node.end;
            rbTreeInsert(this, node);
        }
        this._normalizeDeltaIfNecessary();
    }
    _normalizeDeltaIfNecessary() {
        if (!this.requestNormalizeDelta) {
            return;
        }
        this.requestNormalizeDelta = false;
        normalizeDelta(this);
    }
}
//#region Delta Normalization
function normalizeDelta(T) {
    let node = T.root;
    let delta = 0;
    while (node !== SENTINEL) {
        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
            // go left
            node = node.left;
            continue;
        }
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            delta += node.delta;
            node = node.right;
            continue;
        }
        // handle current node
        node.start = delta + node.start;
        node.end = delta + node.end;
        node.delta = 0;
        recomputeMaxEnd(node);
        setNodeIsVisited(node, true);
        // going up from this node
        setNodeIsVisited(node.left, false);
        setNodeIsVisited(node.right, false);
        if (node === node.parent.right) {
            delta -= node.parent.delta;
        }
        node = node.parent;
    }
    setNodeIsVisited(T.root, false);
}
function adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {
    if (markerOffset < checkOffset) {
        return true;
    }
    if (markerOffset > checkOffset) {
        return false;
    }
    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {
        return false;
    }
    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {
        return true;
    }
    return markerStickToPreviousCharacter;
}
/**
 * This is a lot more complicated than strictly necessary to maintain the same behaviour
 * as when decorations were implemented using two markers.
 */
function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {
    const nodeStickiness = getNodeStickiness(node);
    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);
    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);
    const deletingCnt = (end - start);
    const insertingCnt = textLength;
    const commonLength = Math.min(deletingCnt, insertingCnt);
    const nodeStart = node.start;
    let startDone = false;
    const nodeEnd = node.end;
    let endDone = false;
    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {
        // This edit encompasses the entire decoration range
        // and the decoration has asked to become collapsed
        node.start = start;
        startDone = true;
        node.end = start;
        endDone = true;
    }
    {
        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);
        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {
            startDone = true;
        }
        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {
            endDone = true;
        }
    }
    if (commonLength > 0 && !forceMoveMarkers) {
        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);
        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {
            startDone = true;
        }
        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {
            endDone = true;
        }
    }
    {
        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;
        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {
            node.start = start + insertingCnt;
            startDone = true;
        }
        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {
            node.end = start + insertingCnt;
            endDone = true;
        }
    }
    // Finish
    const deltaColumn = (insertingCnt - deletingCnt);
    if (!startDone) {
        node.start = Math.max(0, nodeStart + deltaColumn);
    }
    if (!endDone) {
        node.end = Math.max(0, nodeEnd + deltaColumn);
    }
    if (node.start > node.end) {
        node.end = node.start;
    }
}
function searchForEditing(T, start, end) {
    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
    // Now, it is known that two intervals A and B overlap only when both
    // A.low <= B.high and A.high >= B.low. When searching the trees for
    // nodes overlapping with a given interval, you can immediately skip:
    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.
    //  b) all nodes that have their maximum 'high' value below the start of the given interval.
    let node = T.root;
    let delta = 0;
    let nodeMaxEnd = 0;
    let nodeStart = 0;
    let nodeEnd = 0;
    const result = [];
    let resultLen = 0;
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            if (node === node.parent.right) {
                delta -= node.parent.delta;
            }
            node = node.parent;
            continue;
        }
        if (!getNodeIsVisited(node.left)) {
            // first time seeing this node
            nodeMaxEnd = delta + node.maxEnd;
            if (nodeMaxEnd < start) {
                // cover case b) from above
                // there is no need to search this node or its children
                setNodeIsVisited(node, true);
                continue;
            }
            if (node.left !== SENTINEL) {
                // go left
                node = node.left;
                continue;
            }
        }
        // handle current node
        nodeStart = delta + node.start;
        if (nodeStart > end) {
            // cover case a) from above
            // there is no need to search this node or its right subtree
            setNodeIsVisited(node, true);
            continue;
        }
        nodeEnd = delta + node.end;
        if (nodeEnd >= start) {
            node.setCachedOffsets(nodeStart, nodeEnd, 0);
            result[resultLen++] = node;
        }
        setNodeIsVisited(node, true);
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            delta += node.delta;
            node = node.right;
            continue;
        }
    }
    setNodeIsVisited(T.root, false);
    return result;
}
function noOverlapReplace(T, start, end, textLength) {
    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
    // Now, it is known that two intervals A and B overlap only when both
    // A.low <= B.high and A.high >= B.low. When searching the trees for
    // nodes overlapping with a given interval, you can immediately skip:
    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.
    //  b) all nodes that have their maximum 'high' value below the start of the given interval.
    let node = T.root;
    let delta = 0;
    let nodeMaxEnd = 0;
    let nodeStart = 0;
    const editDelta = (textLength - (end - start));
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            if (node === node.parent.right) {
                delta -= node.parent.delta;
            }
            recomputeMaxEnd(node);
            node = node.parent;
            continue;
        }
        if (!getNodeIsVisited(node.left)) {
            // first time seeing this node
            nodeMaxEnd = delta + node.maxEnd;
            if (nodeMaxEnd < start) {
                // cover case b) from above
                // there is no need to search this node or its children
                setNodeIsVisited(node, true);
                continue;
            }
            if (node.left !== SENTINEL) {
                // go left
                node = node.left;
                continue;
            }
        }
        // handle current node
        nodeStart = delta + node.start;
        if (nodeStart > end) {
            node.start += editDelta;
            node.end += editDelta;
            node.delta += editDelta;
            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {
                T.requestNormalizeDelta = true;
            }
            // cover case a) from above
            // there is no need to search this node or its right subtree
            setNodeIsVisited(node, true);
            continue;
        }
        setNodeIsVisited(node, true);
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            delta += node.delta;
            node = node.right;
            continue;
        }
    }
    setNodeIsVisited(T.root, false);
}
//#endregion
//#region Searching
function collectNodesFromOwner(T, ownerId) {
    let node = T.root;
    const result = [];
    let resultLen = 0;
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            node = node.parent;
            continue;
        }
        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
            // go left
            node = node.left;
            continue;
        }
        // handle current node
        if (node.ownerId === ownerId) {
            result[resultLen++] = node;
        }
        setNodeIsVisited(node, true);
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            node = node.right;
            continue;
        }
    }
    setNodeIsVisited(T.root, false);
    return result;
}
function collectNodesPostOrder(T) {
    let node = T.root;
    const result = [];
    let resultLen = 0;
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            node = node.parent;
            continue;
        }
        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
            // go left
            node = node.left;
            continue;
        }
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            node = node.right;
            continue;
        }
        // handle current node
        result[resultLen++] = node;
        setNodeIsVisited(node, true);
    }
    setNodeIsVisited(T.root, false);
    return result;
}
function search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
    let node = T.root;
    let delta = 0;
    let nodeStart = 0;
    let nodeEnd = 0;
    const result = [];
    let resultLen = 0;
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            if (node === node.parent.right) {
                delta -= node.parent.delta;
            }
            node = node.parent;
            continue;
        }
        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
            // go left
            node = node.left;
            continue;
        }
        // handle current node
        nodeStart = delta + node.start;
        nodeEnd = delta + node.end;
        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
        let include = true;
        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
            include = false;
        }
        if (filterOutValidation && getNodeIsForValidation(node)) {
            include = false;
        }
        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {
            include = false;
        }
        if (include) {
            result[resultLen++] = node;
        }
        setNodeIsVisited(node, true);
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            delta += node.delta;
            node = node.right;
            continue;
        }
    }
    setNodeIsVisited(T.root, false);
    return result;
}
function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
    // Now, it is known that two intervals A and B overlap only when both
    // A.low <= B.high and A.high >= B.low. When searching the trees for
    // nodes overlapping with a given interval, you can immediately skip:
    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.
    //  b) all nodes that have their maximum 'high' value below the start of the given interval.
    let node = T.root;
    let delta = 0;
    let nodeMaxEnd = 0;
    let nodeStart = 0;
    let nodeEnd = 0;
    const result = [];
    let resultLen = 0;
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            if (node === node.parent.right) {
                delta -= node.parent.delta;
            }
            node = node.parent;
            continue;
        }
        if (!getNodeIsVisited(node.left)) {
            // first time seeing this node
            nodeMaxEnd = delta + node.maxEnd;
            if (nodeMaxEnd < intervalStart) {
                // cover case b) from above
                // there is no need to search this node or its children
                setNodeIsVisited(node, true);
                continue;
            }
            if (node.left !== SENTINEL) {
                // go left
                node = node.left;
                continue;
            }
        }
        // handle current node
        nodeStart = delta + node.start;
        if (nodeStart > intervalEnd) {
            // cover case a) from above
            // there is no need to search this node or its right subtree
            setNodeIsVisited(node, true);
            continue;
        }
        nodeEnd = delta + node.end;
        if (nodeEnd >= intervalStart) {
            // There is overlap
            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
            let include = true;
            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
                include = false;
            }
            if (filterOutValidation && getNodeIsForValidation(node)) {
                include = false;
            }
            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {
                include = false;
            }
            if (include) {
                result[resultLen++] = node;
            }
        }
        setNodeIsVisited(node, true);
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            delta += node.delta;
            node = node.right;
            continue;
        }
    }
    setNodeIsVisited(T.root, false);
    return result;
}
//#endregion
//#region Insertion
function rbTreeInsert(T, newNode) {
    if (T.root === SENTINEL) {
        newNode.parent = SENTINEL;
        newNode.left = SENTINEL;
        newNode.right = SENTINEL;
        setNodeColor(newNode, 0 /* NodeColor.Black */);
        T.root = newNode;
        return T.root;
    }
    treeInsert(T, newNode);
    recomputeMaxEndWalkToRoot(newNode.parent);
    // repair tree
    let x = newNode;
    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {
        if (x.parent === x.parent.parent.left) {
            const y = x.parent.parent.right;
            if (getNodeColor(y) === 1 /* NodeColor.Red */) {
                setNodeColor(x.parent, 0 /* NodeColor.Black */);
                setNodeColor(y, 0 /* NodeColor.Black */);
                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);
                x = x.parent.parent;
            }
            else {
                if (x === x.parent.right) {
                    x = x.parent;
                    leftRotate(T, x);
                }
                setNodeColor(x.parent, 0 /* NodeColor.Black */);
                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);
                rightRotate(T, x.parent.parent);
            }
        }
        else {
            const y = x.parent.parent.left;
            if (getNodeColor(y) === 1 /* NodeColor.Red */) {
                setNodeColor(x.parent, 0 /* NodeColor.Black */);
                setNodeColor(y, 0 /* NodeColor.Black */);
                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);
                x = x.parent.parent;
            }
            else {
                if (x === x.parent.left) {
                    x = x.parent;
                    rightRotate(T, x);
                }
                setNodeColor(x.parent, 0 /* NodeColor.Black */);
                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);
                leftRotate(T, x.parent.parent);
            }
        }
    }
    setNodeColor(T.root, 0 /* NodeColor.Black */);
    return newNode;
}
function treeInsert(T, z) {
    let delta = 0;
    let x = T.root;
    const zAbsoluteStart = z.start;
    const zAbsoluteEnd = z.end;
    while (true) {
        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);
        if (cmp < 0) {
            // this node should be inserted to the left
            // => it is not affected by the node's delta
            if (x.left === SENTINEL) {
                z.start -= delta;
                z.end -= delta;
                z.maxEnd -= delta;
                x.left = z;
                break;
            }
            else {
                x = x.left;
            }
        }
        else {
            // this node should be inserted to the right
            // => it is not affected by the node's delta
            if (x.right === SENTINEL) {
                z.start -= (delta + x.delta);
                z.end -= (delta + x.delta);
                z.maxEnd -= (delta + x.delta);
                x.right = z;
                break;
            }
            else {
                delta += x.delta;
                x = x.right;
            }
        }
    }
    z.parent = x;
    z.left = SENTINEL;
    z.right = SENTINEL;
    setNodeColor(z, 1 /* NodeColor.Red */);
}
//#endregion
//#region Deletion
function rbTreeDelete(T, z) {
    let x;
    let y;
    // RB-DELETE except we don't swap z and y in case c)
    // i.e. we always delete what's pointed at by z.
    if (z.left === SENTINEL) {
        x = z.right;
        y = z;
        // x's delta is no longer influenced by z's delta
        x.delta += z.delta;
        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {
            T.requestNormalizeDelta = true;
        }
        x.start += z.delta;
        x.end += z.delta;
    }
    else if (z.right === SENTINEL) {
        x = z.left;
        y = z;
    }
    else {
        y = leftest(z.right);
        x = y.right;
        // y's delta is no longer influenced by z's delta,
        // but we don't want to walk the entire right-hand-side subtree of x.
        // we therefore maintain z's delta in y, and adjust only x
        x.start += y.delta;
        x.end += y.delta;
        x.delta += y.delta;
        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {
            T.requestNormalizeDelta = true;
        }
        y.start += z.delta;
        y.end += z.delta;
        y.delta = z.delta;
        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {
            T.requestNormalizeDelta = true;
        }
    }
    if (y === T.root) {
        T.root = x;
        setNodeColor(x, 0 /* NodeColor.Black */);
        z.detach();
        resetSentinel();
        recomputeMaxEnd(x);
        T.root.parent = SENTINEL;
        return;
    }
    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);
    if (y === y.parent.left) {
        y.parent.left = x;
    }
    else {
        y.parent.right = x;
    }
    if (y === z) {
        x.parent = y.parent;
    }
    else {
        if (y.parent === z) {
            x.parent = y;
        }
        else {
            x.parent = y.parent;
        }
        y.left = z.left;
        y.right = z.right;
        y.parent = z.parent;
        setNodeColor(y, getNodeColor(z));
        if (z === T.root) {
            T.root = y;
        }
        else {
            if (z === z.parent.left) {
                z.parent.left = y;
            }
            else {
                z.parent.right = y;
            }
        }
        if (y.left !== SENTINEL) {
            y.left.parent = y;
        }
        if (y.right !== SENTINEL) {
            y.right.parent = y;
        }
    }
    z.detach();
    if (yWasRed) {
        recomputeMaxEndWalkToRoot(x.parent);
        if (y !== z) {
            recomputeMaxEndWalkToRoot(y);
            recomputeMaxEndWalkToRoot(y.parent);
        }
        resetSentinel();
        return;
    }
    recomputeMaxEndWalkToRoot(x);
    recomputeMaxEndWalkToRoot(x.parent);
    if (y !== z) {
        recomputeMaxEndWalkToRoot(y);
        recomputeMaxEndWalkToRoot(y.parent);
    }
    // RB-DELETE-FIXUP
    let w;
    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {
        if (x === x.parent.left) {
            w = x.parent.right;
            if (getNodeColor(w) === 1 /* NodeColor.Red */) {
                setNodeColor(w, 0 /* NodeColor.Black */);
                setNodeColor(x.parent, 1 /* NodeColor.Red */);
                leftRotate(T, x.parent);
                w = x.parent.right;
            }
            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {
                setNodeColor(w, 1 /* NodeColor.Red */);
                x = x.parent;
            }
            else {
                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {
                    setNodeColor(w.left, 0 /* NodeColor.Black */);
                    setNodeColor(w, 1 /* NodeColor.Red */);
                    rightRotate(T, w);
                    w = x.parent.right;
                }
                setNodeColor(w, getNodeColor(x.parent));
                setNodeColor(x.parent, 0 /* NodeColor.Black */);
                setNodeColor(w.right, 0 /* NodeColor.Black */);
                leftRotate(T, x.parent);
                x = T.root;
            }
        }
        else {
            w = x.parent.left;
            if (getNodeColor(w) === 1 /* NodeColor.Red */) {
                setNodeColor(w, 0 /* NodeColor.Black */);
                setNodeColor(x.parent, 1 /* NodeColor.Red */);
                rightRotate(T, x.parent);
                w = x.parent.left;
            }
            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {
                setNodeColor(w, 1 /* NodeColor.Red */);
                x = x.parent;
            }
            else {
                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {
                    setNodeColor(w.right, 0 /* NodeColor.Black */);
                    setNodeColor(w, 1 /* NodeColor.Red */);
                    leftRotate(T, w);
                    w = x.parent.left;
                }
                setNodeColor(w, getNodeColor(x.parent));
                setNodeColor(x.parent, 0 /* NodeColor.Black */);
                setNodeColor(w.left, 0 /* NodeColor.Black */);
                rightRotate(T, x.parent);
                x = T.root;
            }
        }
    }
    setNodeColor(x, 0 /* NodeColor.Black */);
    resetSentinel();
}
function leftest(node) {
    while (node.left !== SENTINEL) {
        node = node.left;
    }
    return node;
}
function resetSentinel() {
    SENTINEL.parent = SENTINEL;
    SENTINEL.delta = 0; // optional
    SENTINEL.start = 0; // optional
    SENTINEL.end = 0; // optional
}
//#endregion
//#region Rotations
function leftRotate(T, x) {
    const y = x.right; // set y.
    y.delta += x.delta; // y's delta is no longer influenced by x's delta
    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {
        T.requestNormalizeDelta = true;
    }
    y.start += x.delta;
    y.end += x.delta;
    x.right = y.left; // turn y's left subtree into x's right subtree.
    if (y.left !== SENTINEL) {
        y.left.parent = x;
    }
    y.parent = x.parent; // link x's parent to y.
    if (x.parent === SENTINEL) {
        T.root = y;
    }
    else if (x === x.parent.left) {
        x.parent.left = y;
    }
    else {
        x.parent.right = y;
    }
    y.left = x; // put x on y's left.
    x.parent = y;
    recomputeMaxEnd(x);
    recomputeMaxEnd(y);
}
function rightRotate(T, y) {
    const x = y.left;
    y.delta -= x.delta;
    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {
        T.requestNormalizeDelta = true;
    }
    y.start -= x.delta;
    y.end -= x.delta;
    y.left = x.right;
    if (x.right !== SENTINEL) {
        x.right.parent = y;
    }
    x.parent = y.parent;
    if (y.parent === SENTINEL) {
        T.root = x;
    }
    else if (y === y.parent.right) {
        y.parent.right = x;
    }
    else {
        y.parent.left = x;
    }
    x.right = y;
    y.parent = x;
    recomputeMaxEnd(y);
    recomputeMaxEnd(x);
}
//#endregion
//#region max end computation
function computeMaxEnd(node) {
    let maxEnd = node.end;
    if (node.left !== SENTINEL) {
        const leftMaxEnd = node.left.maxEnd;
        if (leftMaxEnd > maxEnd) {
            maxEnd = leftMaxEnd;
        }
    }
    if (node.right !== SENTINEL) {
        const rightMaxEnd = node.right.maxEnd + node.delta;
        if (rightMaxEnd > maxEnd) {
            maxEnd = rightMaxEnd;
        }
    }
    return maxEnd;
}
function recomputeMaxEnd(node) {
    node.maxEnd = computeMaxEnd(node);
}
function recomputeMaxEndWalkToRoot(node) {
    while (node !== SENTINEL) {
        const maxEnd = computeMaxEnd(node);
        if (node.maxEnd === maxEnd) {
            // no need to go further
            return;
        }
        node.maxEnd = maxEnd;
        node = node.parent;
    }
}
//#endregion
//#region utils
function intervalCompare(aStart, aEnd, bStart, bEnd) {
    if (aStart === bStart) {
        return aEnd - bEnd;
    }
    return aStart - bStart;
}
//#endregion


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Piece: () => (/* binding */ Piece),
/* harmony export */   PieceTreeBase: () => (/* binding */ PieceTreeBase),
/* harmony export */   StringBuffer: () => (/* binding */ StringBuffer),
/* harmony export */   createLineStarts: () => (/* binding */ createLineStarts),
/* harmony export */   createLineStartsFast: () => (/* binding */ createLineStartsFast)
/* harmony export */ });
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model.js");
/* harmony import */ var _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rbTreeBase.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js");
/* harmony import */ var _textModelSearch_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../textModelSearch.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





// const lfRegex = new RegExp(/\r\n|\r|\n/g);
const AverageBufferSize = 65535;
function createUintArray(arr) {
    let r;
    if (arr[arr.length - 1] < 65536) {
        r = new Uint16Array(arr.length);
    }
    else {
        r = new Uint32Array(arr.length);
    }
    r.set(arr, 0);
    return r;
}
class LineStarts {
    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {
        this.lineStarts = lineStarts;
        this.cr = cr;
        this.lf = lf;
        this.crlf = crlf;
        this.isBasicASCII = isBasicASCII;
    }
}
function createLineStartsFast(str, readonly = true) {
    const r = [0];
    let rLength = 1;
    for (let i = 0, len = str.length; i < len; i++) {
        const chr = str.charCodeAt(i);
        if (chr === 13 /* CharCode.CarriageReturn */) {
            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {
                // \r\n... case
                r[rLength++] = i + 2;
                i++; // skip \n
            }
            else {
                // \r... case
                r[rLength++] = i + 1;
            }
        }
        else if (chr === 10 /* CharCode.LineFeed */) {
            r[rLength++] = i + 1;
        }
    }
    if (readonly) {
        return createUintArray(r);
    }
    else {
        return r;
    }
}
function createLineStarts(r, str) {
    r.length = 0;
    r[0] = 0;
    let rLength = 1;
    let cr = 0, lf = 0, crlf = 0;
    let isBasicASCII = true;
    for (let i = 0, len = str.length; i < len; i++) {
        const chr = str.charCodeAt(i);
        if (chr === 13 /* CharCode.CarriageReturn */) {
            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {
                // \r\n... case
                crlf++;
                r[rLength++] = i + 2;
                i++; // skip \n
            }
            else {
                cr++;
                // \r... case
                r[rLength++] = i + 1;
            }
        }
        else if (chr === 10 /* CharCode.LineFeed */) {
            lf++;
            r[rLength++] = i + 1;
        }
        else {
            if (isBasicASCII) {
                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {
                    isBasicASCII = false;
                }
            }
        }
    }
    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);
    r.length = 0;
    return result;
}
class Piece {
    constructor(bufferIndex, start, end, lineFeedCnt, length) {
        this.bufferIndex = bufferIndex;
        this.start = start;
        this.end = end;
        this.lineFeedCnt = lineFeedCnt;
        this.length = length;
    }
}
class StringBuffer {
    constructor(buffer, lineStarts) {
        this.buffer = buffer;
        this.lineStarts = lineStarts;
    }
}
/**
 * Readonly snapshot for piece tree.
 * In a real multiple thread environment, to make snapshot reading always work correctly, we need to
 * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.
 * 2. TreeNode/Buffers normalization should not happen during snapshot reading.
 */
class PieceTreeSnapshot {
    constructor(tree, BOM) {
        this._pieces = [];
        this._tree = tree;
        this._BOM = BOM;
        this._index = 0;
        if (tree.root !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            tree.iterate(tree.root, node => {
                if (node !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
                    this._pieces.push(node.piece);
                }
                return true;
            });
        }
    }
    read() {
        if (this._pieces.length === 0) {
            if (this._index === 0) {
                this._index++;
                return this._BOM;
            }
            else {
                return null;
            }
        }
        if (this._index > this._pieces.length - 1) {
            return null;
        }
        if (this._index === 0) {
            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);
        }
        return this._tree.getPieceContent(this._pieces[this._index++]);
    }
}
class PieceTreeSearchCache {
    constructor(limit) {
        this._limit = limit;
        this._cache = [];
    }
    get(offset) {
        for (let i = this._cache.length - 1; i >= 0; i--) {
            const nodePos = this._cache[i];
            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {
                return nodePos;
            }
        }
        return null;
    }
    get2(lineNumber) {
        for (let i = this._cache.length - 1; i >= 0; i--) {
            const nodePos = this._cache[i];
            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {
                return nodePos;
            }
        }
        return null;
    }
    set(nodePosition) {
        if (this._cache.length >= this._limit) {
            this._cache.shift();
        }
        this._cache.push(nodePosition);
    }
    validate(offset) {
        let hasInvalidVal = false;
        const tmp = this._cache;
        for (let i = 0; i < tmp.length; i++) {
            const nodePos = tmp[i];
            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {
                tmp[i] = null;
                hasInvalidVal = true;
                continue;
            }
        }
        if (hasInvalidVal) {
            const newArr = [];
            for (const entry of tmp) {
                if (entry !== null) {
                    newArr.push(entry);
                }
            }
            this._cache = newArr;
        }
    }
}
class PieceTreeBase {
    constructor(chunks, eol, eolNormalized) {
        this.create(chunks, eol, eolNormalized);
    }
    create(chunks, eol, eolNormalized) {
        this._buffers = [
            new StringBuffer('', [0])
        ];
        this._lastChangeBufferPos = { line: 0, column: 0 };
        this.root = _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL;
        this._lineCnt = 1;
        this._length = 0;
        this._EOL = eol;
        this._EOLLength = eol.length;
        this._EOLNormalized = eolNormalized;
        let lastNode = null;
        for (let i = 0, len = chunks.length; i < len; i++) {
            if (chunks[i].buffer.length > 0) {
                if (!chunks[i].lineStarts) {
                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);
                }
                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);
                this._buffers.push(chunks[i]);
                lastNode = this.rbInsertRight(lastNode, piece);
            }
        }
        this._searchCache = new PieceTreeSearchCache(1);
        this._lastVisitedLine = { lineNumber: 0, value: '' };
        this.computeBufferMetadata();
    }
    normalizeEOL(eol) {
        const averageBufferSize = AverageBufferSize;
        const min = averageBufferSize - Math.floor(averageBufferSize / 3);
        const max = min * 2;
        let tempChunk = '';
        let tempChunkLen = 0;
        const chunks = [];
        this.iterate(this.root, node => {
            const str = this.getNodeContent(node);
            const len = str.length;
            if (tempChunkLen <= min || tempChunkLen + len < max) {
                tempChunk += str;
                tempChunkLen += len;
                return true;
            }
            // flush anyways
            const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
            chunks.push(new StringBuffer(text, createLineStartsFast(text)));
            tempChunk = str;
            tempChunkLen = len;
            return true;
        });
        if (tempChunkLen > 0) {
            const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
            chunks.push(new StringBuffer(text, createLineStartsFast(text)));
        }
        this.create(chunks, eol, true);
    }
    // #region Buffer API
    getEOL() {
        return this._EOL;
    }
    setEOL(newEOL) {
        this._EOL = newEOL;
        this._EOLLength = this._EOL.length;
        this.normalizeEOL(newEOL);
    }
    createSnapshot(BOM) {
        return new PieceTreeSnapshot(this, BOM);
    }
    getOffsetAt(lineNumber, column) {
        let leftLen = 0; // inorder
        let x = this.root;
        while (x !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            if (x.left !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL && x.lf_left + 1 >= lineNumber) {
                x = x.left;
            }
            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {
                leftLen += x.size_left;
                // lineNumber >= 2
                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                return leftLen += accumualtedValInCurrentIndex + column - 1;
            }
            else {
                lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                leftLen += x.size_left + x.piece.length;
                x = x.right;
            }
        }
        return leftLen;
    }
    getPositionAt(offset) {
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        let x = this.root;
        let lfCnt = 0;
        const originalOffset = offset;
        while (x !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            if (x.size_left !== 0 && x.size_left >= offset) {
                x = x.left;
            }
            else if (x.size_left + x.piece.length >= offset) {
                const out = this.getIndexOf(x, offset - x.size_left);
                lfCnt += x.lf_left + out.index;
                if (out.index === 0) {
                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
                    const column = originalOffset - lineStartOffset;
                    return new _core_position_js__WEBPACK_IMPORTED_MODULE_0__.Position(lfCnt + 1, column + 1);
                }
                return new _core_position_js__WEBPACK_IMPORTED_MODULE_0__.Position(lfCnt + 1, out.remainder + 1);
            }
            else {
                offset -= x.size_left + x.piece.length;
                lfCnt += x.lf_left + x.piece.lineFeedCnt;
                if (x.right === _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
                    // last node
                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
                    const column = originalOffset - offset - lineStartOffset;
                    return new _core_position_js__WEBPACK_IMPORTED_MODULE_0__.Position(lfCnt + 1, column + 1);
                }
                else {
                    x = x.right;
                }
            }
        }
        return new _core_position_js__WEBPACK_IMPORTED_MODULE_0__.Position(1, 1);
    }
    getValueInRange(range, eol) {
        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
            return '';
        }
        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);
        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);
        const value = this.getValueInRange2(startPosition, endPosition);
        if (eol) {
            if (eol !== this._EOL || !this._EOLNormalized) {
                return value.replace(/\r\n|\r|\n/g, eol);
            }
            if (eol === this.getEOL() && this._EOLNormalized) {
                if (eol === '\r\n') {
                }
                return value;
            }
            return value.replace(/\r\n|\r|\n/g, eol);
        }
        return value;
    }
    getValueInRange2(startPosition, endPosition) {
        if (startPosition.node === endPosition.node) {
            const node = startPosition.node;
            const buffer = this._buffers[node.piece.bufferIndex].buffer;
            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);
        }
        let x = startPosition.node;
        const buffer = this._buffers[x.piece.bufferIndex].buffer;
        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);
        x = x.next();
        while (x !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            const buffer = this._buffers[x.piece.bufferIndex].buffer;
            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
            if (x === endPosition.node) {
                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);
                break;
            }
            else {
                ret += buffer.substr(startOffset, x.piece.length);
            }
            x = x.next();
        }
        return ret;
    }
    getLinesContent() {
        const lines = [];
        let linesLength = 0;
        let currentLine = '';
        let danglingCR = false;
        this.iterate(this.root, node => {
            if (node === _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
                return true;
            }
            const piece = node.piece;
            let pieceLength = piece.length;
            if (pieceLength === 0) {
                return true;
            }
            const buffer = this._buffers[piece.bufferIndex].buffer;
            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
            const pieceStartLine = piece.start.line;
            const pieceEndLine = piece.end.line;
            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;
            if (danglingCR) {
                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {
                    // pretend the \n was in the previous piece..
                    pieceStartOffset++;
                    pieceLength--;
                }
                lines[linesLength++] = currentLine;
                currentLine = '';
                danglingCR = false;
                if (pieceLength === 0) {
                    return true;
                }
            }
            if (pieceStartLine === pieceEndLine) {
                // this piece has no new lines
                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {
                    danglingCR = true;
                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);
                }
                else {
                    currentLine += buffer.substr(pieceStartOffset, pieceLength);
                }
                return true;
            }
            // add the text before the first line start in this piece
            currentLine += (this._EOLNormalized
                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))
                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\r\n|\r|\n)$/, ''));
            lines[linesLength++] = currentLine;
            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {
                currentLine = (this._EOLNormalized
                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)
                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\r\n|\r|\n)$/, ''));
                lines[linesLength++] = currentLine;
            }
            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {
                danglingCR = true;
                if (piece.end.column === 0) {
                    // The last line ended with a \r, let's undo the push, it will be pushed by next iteration
                    linesLength--;
                }
                else {
                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);
                }
            }
            else {
                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);
            }
            return true;
        });
        if (danglingCR) {
            lines[linesLength++] = currentLine;
            currentLine = '';
        }
        lines[linesLength++] = currentLine;
        return lines;
    }
    getLength() {
        return this._length;
    }
    getLineCount() {
        return this._lineCnt;
    }
    getLineContent(lineNumber) {
        if (this._lastVisitedLine.lineNumber === lineNumber) {
            return this._lastVisitedLine.value;
        }
        this._lastVisitedLine.lineNumber = lineNumber;
        if (lineNumber === this._lineCnt) {
            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);
        }
        else if (this._EOLNormalized) {
            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);
        }
        else {
            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\r\n|\r|\n)$/, '');
        }
        return this._lastVisitedLine.value;
    }
    _getCharCode(nodePos) {
        if (nodePos.remainder === nodePos.node.piece.length) {
            // the char we want to fetch is at the head of next node.
            const matchingNode = nodePos.node.next();
            if (!matchingNode) {
                return 0;
            }
            const buffer = this._buffers[matchingNode.piece.bufferIndex];
            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);
            return buffer.buffer.charCodeAt(startOffset);
        }
        else {
            const buffer = this._buffers[nodePos.node.piece.bufferIndex];
            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
            const targetOffset = startOffset + nodePos.remainder;
            return buffer.buffer.charCodeAt(targetOffset);
        }
    }
    getLineCharCode(lineNumber, index) {
        const nodePos = this.nodeAt2(lineNumber, index + 1);
        return this._getCharCode(nodePos);
    }
    getLineLength(lineNumber) {
        if (lineNumber === this.getLineCount()) {
            const startOffset = this.getOffsetAt(lineNumber, 1);
            return this.getLength() - startOffset;
        }
        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;
    }
    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
        const buffer = this._buffers[node.piece.bufferIndex];
        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);
        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);
        let m;
        // Reset regex to search from the beginning
        const ret = { line: 0, column: 0 };
        let searchText;
        let offsetInBuffer;
        if (searcher._wordSeparators) {
            searchText = buffer.buffer.substring(start, end);
            offsetInBuffer = (offset) => offset + start;
            searcher.reset(0);
        }
        else {
            searchText = buffer.buffer;
            offsetInBuffer = (offset) => offset;
            searcher.reset(start);
        }
        do {
            m = searcher.next(searchText);
            if (m) {
                if (offsetInBuffer(m.index) >= end) {
                    return resultLen;
                }
                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);
                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);
                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;
                const retEndColumn = retStartColumn + m[0].length;
                result[resultLen++] = (0,_textModelSearch_js__WEBPACK_IMPORTED_MODULE_4__.createFindMatch)(new _core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);
                if (offsetInBuffer(m.index) + m[0].length >= end) {
                    return resultLen;
                }
                if (resultLen >= limitResultCount) {
                    return resultLen;
                }
            }
        } while (m);
        return resultLen;
    }
    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
        const result = [];
        let resultLen = 0;
        const searcher = new _textModelSearch_js__WEBPACK_IMPORTED_MODULE_4__.Searcher(searchData.wordSeparators, searchData.regex);
        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);
        if (startPosition === null) {
            return [];
        }
        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);
        if (endPosition === null) {
            return [];
        }
        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);
        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);
        if (startPosition.node === endPosition.node) {
            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
            return result;
        }
        let startLineNumber = searchRange.startLineNumber;
        let currentNode = startPosition.node;
        while (currentNode !== endPosition.node) {
            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);
            if (lineBreakCnt >= 1) {
                // last line break position
                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;
                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);
                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];
                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);
                if (resultLen >= limitResultCount) {
                    return result;
                }
                startLineNumber += lineBreakCnt;
            }
            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
            // search for the remaining content
            if (startLineNumber === searchRange.endLineNumber) {
                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);
                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);
                return result;
            }
            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);
            if (resultLen >= limitResultCount) {
                return result;
            }
            startLineNumber++;
            startPosition = this.nodeAt2(startLineNumber, 1);
            currentNode = startPosition.node;
            start = this.positionInBuffer(startPosition.node, startPosition.remainder);
        }
        if (startLineNumber === searchRange.endLineNumber) {
            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);
            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);
            return result;
        }
        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
        return result;
    }
    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
        const wordSeparators = searchData.wordSeparators;
        if (!captureMatches && searchData.simpleSearch) {
            const searchString = searchData.simpleSearch;
            const searchStringLen = searchString.length;
            const textLength = text.length;
            let lastMatchIndex = -searchStringLen;
            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
                if (!wordSeparators || (0,_textModelSearch_js__WEBPACK_IMPORTED_MODULE_4__.isValidMatch)(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
                    result[resultLen++] = new _model_js__WEBPACK_IMPORTED_MODULE_2__.FindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
                    if (resultLen >= limitResultCount) {
                        return resultLen;
                    }
                }
            }
            return resultLen;
        }
        let m;
        // Reset regex to search from the beginning
        searcher.reset(0);
        do {
            m = searcher.next(text);
            if (m) {
                result[resultLen++] = (0,_textModelSearch_js__WEBPACK_IMPORTED_MODULE_4__.createFindMatch)(new _core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
                if (resultLen >= limitResultCount) {
                    return resultLen;
                }
            }
        } while (m);
        return resultLen;
    }
    // #endregion
    // #region Piece Table
    insert(offset, value, eolNormalized = false) {
        this._EOLNormalized = this._EOLNormalized && eolNormalized;
        this._lastVisitedLine.lineNumber = 0;
        this._lastVisitedLine.value = '';
        if (this.root !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);
            const piece = node.piece;
            const bufferIndex = piece.bufferIndex;
            const insertPosInBuffer = this.positionInBuffer(node, remainder);
            if (node.piece.bufferIndex === 0 &&
                piece.end.line === this._lastChangeBufferPos.line &&
                piece.end.column === this._lastChangeBufferPos.column &&
                (nodeStartOffset + piece.length === offset) &&
                value.length < AverageBufferSize) {
                // changed buffer
                this.appendToNode(node, value);
                this.computeBufferMetadata();
                return;
            }
            if (nodeStartOffset === offset) {
                this.insertContentToNodeLeft(value, node);
                this._searchCache.validate(offset);
            }
            else if (nodeStartOffset + node.piece.length > offset) {
                // we are inserting into the middle of a node.
                const nodesToDel = [];
                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));
                if (this.shouldCheckCRLF() && this.endWithCR(value)) {
                    const headOfRight = this.nodeCharCodeAt(node, remainder);
                    if (headOfRight === 10 /** \n */) {
                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };
                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);
                        value += '\n';
                    }
                }
                // reuse node for content before insertion point.
                if (this.shouldCheckCRLF() && this.startWithLF(value)) {
                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);
                    if (tailOfLeft === 13 /** \r */) {
                        const previousPos = this.positionInBuffer(node, remainder - 1);
                        this.deleteNodeTail(node, previousPos);
                        value = '\r' + value;
                        if (node.piece.length === 0) {
                            nodesToDel.push(node);
                        }
                    }
                    else {
                        this.deleteNodeTail(node, insertPosInBuffer);
                    }
                }
                else {
                    this.deleteNodeTail(node, insertPosInBuffer);
                }
                const newPieces = this.createNewPieces(value);
                if (newRightPiece.length > 0) {
                    this.rbInsertRight(node, newRightPiece);
                }
                let tmpNode = node;
                for (let k = 0; k < newPieces.length; k++) {
                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
                }
                this.deleteNodes(nodesToDel);
            }
            else {
                this.insertContentToNodeRight(value, node);
            }
        }
        else {
            // insert new node
            const pieces = this.createNewPieces(value);
            let node = this.rbInsertLeft(null, pieces[0]);
            for (let k = 1; k < pieces.length; k++) {
                node = this.rbInsertRight(node, pieces[k]);
            }
        }
        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.
        this.computeBufferMetadata();
    }
    delete(offset, cnt) {
        this._lastVisitedLine.lineNumber = 0;
        this._lastVisitedLine.value = '';
        if (cnt <= 0 || this.root === _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            return;
        }
        const startPosition = this.nodeAt(offset);
        const endPosition = this.nodeAt(offset + cnt);
        const startNode = startPosition.node;
        const endNode = endPosition.node;
        if (startNode === endNode) {
            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);
            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);
            if (startPosition.nodeStartOffset === offset) {
                if (cnt === startNode.piece.length) { // delete node
                    const next = startNode.next();
                    (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.rbDelete)(this, startNode);
                    this.validateCRLFWithPrevNode(next);
                    this.computeBufferMetadata();
                    return;
                }
                this.deleteNodeHead(startNode, endSplitPosInBuffer);
                this._searchCache.validate(offset);
                this.validateCRLFWithPrevNode(startNode);
                this.computeBufferMetadata();
                return;
            }
            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {
                this.deleteNodeTail(startNode, startSplitPosInBuffer);
                this.validateCRLFWithNextNode(startNode);
                this.computeBufferMetadata();
                return;
            }
            // delete content in the middle, this node will be splitted to nodes
            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);
            this.computeBufferMetadata();
            return;
        }
        const nodesToDel = [];
        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);
        this.deleteNodeTail(startNode, startSplitPosInBuffer);
        this._searchCache.validate(offset);
        if (startNode.piece.length === 0) {
            nodesToDel.push(startNode);
        }
        // update last touched node
        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);
        this.deleteNodeHead(endNode, endSplitPosInBuffer);
        if (endNode.piece.length === 0) {
            nodesToDel.push(endNode);
        }
        // delete nodes in between
        const secondNode = startNode.next();
        for (let node = secondNode; node !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL && node !== endNode; node = node.next()) {
            nodesToDel.push(node);
        }
        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;
        this.deleteNodes(nodesToDel);
        this.validateCRLFWithNextNode(prev);
        this.computeBufferMetadata();
    }
    insertContentToNodeLeft(value, node) {
        // we are inserting content to the beginning of node
        const nodesToDel = [];
        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {
            // move `\n` to new node.
            const piece = node.piece;
            const newStart = { line: piece.start.line + 1, column: 0 };
            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);
            node.piece = nPiece;
            value += '\n';
            (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.updateTreeMetadata)(this, node, -1, -1);
            if (node.piece.length === 0) {
                nodesToDel.push(node);
            }
        }
        const newPieces = this.createNewPieces(value);
        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);
        for (let k = newPieces.length - 2; k >= 0; k--) {
            newNode = this.rbInsertLeft(newNode, newPieces[k]);
        }
        this.validateCRLFWithPrevNode(newNode);
        this.deleteNodes(nodesToDel);
    }
    insertContentToNodeRight(value, node) {
        // we are inserting to the right of this node.
        if (this.adjustCarriageReturnFromNext(value, node)) {
            // move \n to the new node.
            value += '\n';
        }
        const newPieces = this.createNewPieces(value);
        const newNode = this.rbInsertRight(node, newPieces[0]);
        let tmpNode = newNode;
        for (let k = 1; k < newPieces.length; k++) {
            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
        }
        this.validateCRLFWithPrevNode(newNode);
    }
    positionInBuffer(node, remainder, ret) {
        const piece = node.piece;
        const bufferIndex = node.piece.bufferIndex;
        const lineStarts = this._buffers[bufferIndex].lineStarts;
        const startOffset = lineStarts[piece.start.line] + piece.start.column;
        const offset = startOffset + remainder;
        // binary search offset between startOffset and endOffset
        let low = piece.start.line;
        let high = piece.end.line;
        let mid = 0;
        let midStop = 0;
        let midStart = 0;
        while (low <= high) {
            mid = low + ((high - low) / 2) | 0;
            midStart = lineStarts[mid];
            if (mid === high) {
                break;
            }
            midStop = lineStarts[mid + 1];
            if (offset < midStart) {
                high = mid - 1;
            }
            else if (offset >= midStop) {
                low = mid + 1;
            }
            else {
                break;
            }
        }
        if (ret) {
            ret.line = mid;
            ret.column = offset - midStart;
            return null;
        }
        return {
            line: mid,
            column: offset - midStart
        };
    }
    getLineFeedCnt(bufferIndex, start, end) {
        // we don't need to worry about start: abc\r|\n, or abc|\r, or abc|\n, or abc|\r\n doesn't change the fact that, there is one line break after start.
        // now let's take care of end: abc\r|\n, if end is in between \r and \n, we need to add line feed count by 1
        if (end.column === 0) {
            return end.line - start.line;
        }
        const lineStarts = this._buffers[bufferIndex].lineStarts;
        if (end.line === lineStarts.length - 1) { // it means, there is no \n after end, otherwise, there will be one more lineStart.
            return end.line - start.line;
        }
        const nextLineStartOffset = lineStarts[end.line + 1];
        const endOffset = lineStarts[end.line] + end.column;
        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \n
            return end.line - start.line;
        }
        // endOffset + 1 === nextLineStartOffset
        // character at endOffset is \n, so we check the character before first
        // if character at endOffset is \r, end.column is 0 and we can't get here.
        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.
        const buffer = this._buffers[bufferIndex].buffer;
        if (buffer.charCodeAt(previousCharOffset) === 13) {
            return end.line - start.line + 1;
        }
        else {
            return end.line - start.line;
        }
    }
    offsetInBuffer(bufferIndex, cursor) {
        const lineStarts = this._buffers[bufferIndex].lineStarts;
        return lineStarts[cursor.line] + cursor.column;
    }
    deleteNodes(nodes) {
        for (let i = 0; i < nodes.length; i++) {
            (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.rbDelete)(this, nodes[i]);
        }
    }
    createNewPieces(text) {
        if (text.length > AverageBufferSize) {
            // the content is large, operations like substring, charCode becomes slow
            // so here we split it into smaller chunks, just like what we did for CR/LF normalization
            const newPieces = [];
            while (text.length > AverageBufferSize) {
                const lastChar = text.charCodeAt(AverageBufferSize - 1);
                let splitText;
                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {
                    // last character is \r or a high surrogate => keep it back
                    splitText = text.substring(0, AverageBufferSize - 1);
                    text = text.substring(AverageBufferSize - 1);
                }
                else {
                    splitText = text.substring(0, AverageBufferSize);
                    text = text.substring(AverageBufferSize);
                }
                const lineStarts = createLineStartsFast(splitText);
                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));
                this._buffers.push(new StringBuffer(splitText, lineStarts));
            }
            const lineStarts = createLineStartsFast(text);
            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));
            this._buffers.push(new StringBuffer(text, lineStarts));
            return newPieces;
        }
        let startOffset = this._buffers[0].buffer.length;
        const lineStarts = createLineStartsFast(text, false);
        let start = this._lastChangeBufferPos;
        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset
            && startOffset !== 0
            && this.startWithLF(text)
            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one
        ) {
            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };
            start = this._lastChangeBufferPos;
            for (let i = 0; i < lineStarts.length; i++) {
                lineStarts[i] += startOffset + 1;
            }
            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
            this._buffers[0].buffer += '_' + text;
            startOffset += 1;
        }
        else {
            if (startOffset !== 0) {
                for (let i = 0; i < lineStarts.length; i++) {
                    lineStarts[i] += startOffset;
                }
            }
            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
            this._buffers[0].buffer += text;
        }
        const endOffset = this._buffers[0].buffer.length;
        const endIndex = this._buffers[0].lineStarts.length - 1;
        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];
        const endPos = { line: endIndex, column: endColumn };
        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);
        this._lastChangeBufferPos = endPos;
        return [newPiece];
    }
    getLineRawContent(lineNumber, endOffset = 0) {
        let x = this.root;
        let ret = '';
        const cache = this._searchCache.get2(lineNumber);
        if (cache) {
            x = cache.node;
            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);
            const buffer = this._buffers[x.piece.bufferIndex].buffer;
            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {
                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
            }
            else {
                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);
                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
            }
        }
        else {
            let nodeStartOffset = 0;
            const originalLineNumber = lineNumber;
            while (x !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
                if (x.left !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL && x.lf_left >= lineNumber - 1) {
                    x = x.left;
                }
                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
                    const buffer = this._buffers[x.piece.bufferIndex].buffer;
                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                    nodeStartOffset += x.size_left;
                    this._searchCache.set({
                        node: x,
                        nodeStartOffset,
                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)
                    });
                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
                }
                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                    const buffer = this._buffers[x.piece.bufferIndex].buffer;
                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
                    break;
                }
                else {
                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                    nodeStartOffset += x.size_left + x.piece.length;
                    x = x.right;
                }
            }
        }
        // search in order, to find the node contains end column
        x = x.next();
        while (x !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            const buffer = this._buffers[x.piece.bufferIndex].buffer;
            if (x.piece.lineFeedCnt > 0) {
                const accumulatedValue = this.getAccumulatedValue(x, 0);
                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);
                return ret;
            }
            else {
                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                ret += buffer.substr(startOffset, x.piece.length);
            }
            x = x.next();
        }
        return ret;
    }
    computeBufferMetadata() {
        let x = this.root;
        let lfCnt = 1;
        let len = 0;
        while (x !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            lfCnt += x.lf_left + x.piece.lineFeedCnt;
            len += x.size_left + x.piece.length;
            x = x.right;
        }
        this._lineCnt = lfCnt;
        this._length = len;
        this._searchCache.validate(this._length);
    }
    // #region node operations
    getIndexOf(node, accumulatedValue) {
        const piece = node.piece;
        const pos = this.positionInBuffer(node, accumulatedValue);
        const lineCnt = pos.line - piece.start.line;
        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {
            // we are checking the end of this node, so a CRLF check is necessary.
            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);
            if (realLineCnt !== lineCnt) {
                // aha yes, CRLF
                return { index: realLineCnt, remainder: 0 };
            }
        }
        return { index: lineCnt, remainder: pos.column };
    }
    getAccumulatedValue(node, index) {
        if (index < 0) {
            return 0;
        }
        const piece = node.piece;
        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
        const expectedLineStartIndex = piece.start.line + index + 1;
        if (expectedLineStartIndex > piece.end.line) {
            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;
        }
        else {
            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;
        }
    }
    deleteNodeTail(node, pos) {
        const piece = node.piece;
        const originalLFCnt = piece.lineFeedCnt;
        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
        const newEnd = pos;
        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);
        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
        const lf_delta = newLineFeedCnt - originalLFCnt;
        const size_delta = newEndOffset - originalEndOffset;
        const newLength = piece.length + size_delta;
        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
        (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.updateTreeMetadata)(this, node, size_delta, lf_delta);
    }
    deleteNodeHead(node, pos) {
        const piece = node.piece;
        const originalLFCnt = piece.lineFeedCnt;
        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
        const newStart = pos;
        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);
        const lf_delta = newLineFeedCnt - originalLFCnt;
        const size_delta = originalStartOffset - newStartOffset;
        const newLength = piece.length + size_delta;
        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
        (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.updateTreeMetadata)(this, node, size_delta, lf_delta);
    }
    shrinkNode(node, start, end) {
        const piece = node.piece;
        const originalStartPos = piece.start;
        const originalEndPos = piece.end;
        // old piece, originalStartPos, start
        const oldLength = piece.length;
        const oldLFCnt = piece.lineFeedCnt;
        const newEnd = start;
        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);
        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
        (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.updateTreeMetadata)(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);
        // new right piece, end, originalEndPos
        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));
        const newNode = this.rbInsertRight(node, newPiece);
        this.validateCRLFWithPrevNode(newNode);
    }
    appendToNode(node, value) {
        if (this.adjustCarriageReturnFromNext(value, node)) {
            value += '\n';
        }
        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);
        const startOffset = this._buffers[0].buffer.length;
        this._buffers[0].buffer += value;
        const lineStarts = createLineStartsFast(value, false);
        for (let i = 0; i < lineStarts.length; i++) {
            lineStarts[i] += startOffset;
        }
        if (hitCRLF) {
            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
            this._buffers[0].lineStarts.pop();
            // _lastChangeBufferPos is already wrong
            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };
        }
        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
        const endIndex = this._buffers[0].lineStarts.length - 1;
        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];
        const newEnd = { line: endIndex, column: endColumn };
        const newLength = node.piece.length + value.length;
        const oldLineFeedCnt = node.piece.lineFeedCnt;
        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);
        const lf_delta = newLineFeedCnt - oldLineFeedCnt;
        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);
        this._lastChangeBufferPos = newEnd;
        (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.updateTreeMetadata)(this, node, value.length, lf_delta);
    }
    nodeAt(offset) {
        let x = this.root;
        const cache = this._searchCache.get(offset);
        if (cache) {
            return {
                node: cache.node,
                nodeStartOffset: cache.nodeStartOffset,
                remainder: offset - cache.nodeStartOffset
            };
        }
        let nodeStartOffset = 0;
        while (x !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            if (x.size_left > offset) {
                x = x.left;
            }
            else if (x.size_left + x.piece.length >= offset) {
                nodeStartOffset += x.size_left;
                const ret = {
                    node: x,
                    remainder: offset - x.size_left,
                    nodeStartOffset
                };
                this._searchCache.set(ret);
                return ret;
            }
            else {
                offset -= x.size_left + x.piece.length;
                nodeStartOffset += x.size_left + x.piece.length;
                x = x.right;
            }
        }
        return null;
    }
    nodeAt2(lineNumber, column) {
        let x = this.root;
        let nodeStartOffset = 0;
        while (x !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            if (x.left !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL && x.lf_left >= lineNumber - 1) {
                x = x.left;
            }
            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
                nodeStartOffset += x.size_left;
                return {
                    node: x,
                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),
                    nodeStartOffset
                };
            }
            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                if (prevAccumualtedValue + column - 1 <= x.piece.length) {
                    return {
                        node: x,
                        remainder: prevAccumualtedValue + column - 1,
                        nodeStartOffset
                    };
                }
                else {
                    column -= x.piece.length - prevAccumualtedValue;
                    break;
                }
            }
            else {
                lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                nodeStartOffset += x.size_left + x.piece.length;
                x = x.right;
            }
        }
        // search in order, to find the node contains position.column
        x = x.next();
        while (x !== _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            if (x.piece.lineFeedCnt > 0) {
                const accumulatedValue = this.getAccumulatedValue(x, 0);
                const nodeStartOffset = this.offsetOfNode(x);
                return {
                    node: x,
                    remainder: Math.min(column - 1, accumulatedValue),
                    nodeStartOffset
                };
            }
            else {
                if (x.piece.length >= column - 1) {
                    const nodeStartOffset = this.offsetOfNode(x);
                    return {
                        node: x,
                        remainder: column - 1,
                        nodeStartOffset
                    };
                }
                else {
                    column -= x.piece.length;
                }
            }
            x = x.next();
        }
        return null;
    }
    nodeCharCodeAt(node, offset) {
        if (node.piece.lineFeedCnt < 1) {
            return -1;
        }
        const buffer = this._buffers[node.piece.bufferIndex];
        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;
        return buffer.buffer.charCodeAt(newOffset);
    }
    offsetOfNode(node) {
        if (!node) {
            return 0;
        }
        let pos = node.size_left;
        while (node !== this.root) {
            if (node.parent.right === node) {
                pos += node.parent.size_left + node.parent.piece.length;
            }
            node = node.parent;
        }
        return pos;
    }
    // #endregion
    // #region CRLF
    shouldCheckCRLF() {
        return !(this._EOLNormalized && this._EOL === '\n');
    }
    startWithLF(val) {
        if (typeof val === 'string') {
            return val.charCodeAt(0) === 10;
        }
        if (val === _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL || val.piece.lineFeedCnt === 0) {
            return false;
        }
        const piece = val.piece;
        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
        const line = piece.start.line;
        const startOffset = lineStarts[line] + piece.start.column;
        if (line === lineStarts.length - 1) {
            // last line, so there is no line feed at the end of this line
            return false;
        }
        const nextLineOffset = lineStarts[line + 1];
        if (nextLineOffset > startOffset + 1) {
            return false;
        }
        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;
    }
    endWithCR(val) {
        if (typeof val === 'string') {
            return val.charCodeAt(val.length - 1) === 13;
        }
        if (val === _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL || val.piece.lineFeedCnt === 0) {
            return false;
        }
        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;
    }
    validateCRLFWithPrevNode(nextNode) {
        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {
            const node = nextNode.prev();
            if (this.endWithCR(node)) {
                this.fixCRLF(node, nextNode);
            }
        }
    }
    validateCRLFWithNextNode(node) {
        if (this.shouldCheckCRLF() && this.endWithCR(node)) {
            const nextNode = node.next();
            if (this.startWithLF(nextNode)) {
                this.fixCRLF(node, nextNode);
            }
        }
    }
    fixCRLF(prev, next) {
        const nodesToDel = [];
        // update node
        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;
        let newEnd;
        if (prev.piece.end.column === 0) {
            // it means, last line ends with \r, not \r\n
            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };
        }
        else {
            // \r\n
            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };
        }
        const prevNewLength = prev.piece.length - 1;
        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;
        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);
        (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.updateTreeMetadata)(this, prev, -1, -1);
        if (prev.piece.length === 0) {
            nodesToDel.push(prev);
        }
        // update nextNode
        const newStart = { line: next.piece.start.line + 1, column: 0 };
        const newLength = next.piece.length - 1;
        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);
        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);
        (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.updateTreeMetadata)(this, next, -1, -1);
        if (next.piece.length === 0) {
            nodesToDel.push(next);
        }
        // create new piece which contains \r\n
        const pieces = this.createNewPieces('\r\n');
        this.rbInsertRight(prev, pieces[0]);
        // delete empty nodes
        for (let i = 0; i < nodesToDel.length; i++) {
            (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.rbDelete)(this, nodesToDel[i]);
        }
    }
    adjustCarriageReturnFromNext(value, node) {
        if (this.shouldCheckCRLF() && this.endWithCR(value)) {
            const nextNode = node.next();
            if (this.startWithLF(nextNode)) {
                // move `\n` forward
                value += '\n';
                if (nextNode.piece.length === 1) {
                    (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.rbDelete)(this, nextNode);
                }
                else {
                    const piece = nextNode.piece;
                    const newStart = { line: piece.start.line + 1, column: 0 };
                    const newLength = piece.length - 1;
                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
                    (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.updateTreeMetadata)(this, nextNode, -1, -1);
                }
                return true;
            }
        }
        return false;
    }
    // #endregion
    // #endregion
    // #region Tree operations
    iterate(node, callback) {
        if (node === _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            return callback(_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL);
        }
        const leftRet = this.iterate(node.left, callback);
        if (!leftRet) {
            return leftRet;
        }
        return callback(node) && this.iterate(node.right, callback);
    }
    getNodeContent(node) {
        if (node === _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            return '';
        }
        const buffer = this._buffers[node.piece.bufferIndex];
        const piece = node.piece;
        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
        const currentContent = buffer.buffer.substring(startOffset, endOffset);
        return currentContent;
    }
    getPieceContent(piece) {
        const buffer = this._buffers[piece.bufferIndex];
        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
        const currentContent = buffer.buffer.substring(startOffset, endOffset);
        return currentContent;
    }
    /**
     *      node              node
     *     /  \              /  \
     *    a   b    <----   a    b
     *                         /
     *                        z
     */
    rbInsertRight(node, p) {
        const z = new _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.TreeNode(p, 1 /* NodeColor.Red */);
        z.left = _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL;
        z.right = _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL;
        z.parent = _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL;
        z.size_left = 0;
        z.lf_left = 0;
        const x = this.root;
        if (x === _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            this.root = z;
            z.color = 0 /* NodeColor.Black */;
        }
        else if (node.right === _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            node.right = z;
            z.parent = node;
        }
        else {
            const nextNode = (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.leftest)(node.right);
            nextNode.left = z;
            z.parent = nextNode;
        }
        (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.fixInsert)(this, z);
        return z;
    }
    /**
     *      node              node
     *     /  \              /  \
     *    a   b     ---->   a    b
     *                       \
     *                        z
     */
    rbInsertLeft(node, p) {
        const z = new _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.TreeNode(p, 1 /* NodeColor.Red */);
        z.left = _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL;
        z.right = _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL;
        z.parent = _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL;
        z.size_left = 0;
        z.lf_left = 0;
        if (this.root === _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            this.root = z;
            z.color = 0 /* NodeColor.Black */;
        }
        else if (node.left === _rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.SENTINEL) {
            node.left = z;
            z.parent = node;
        }
        else {
            const prevNode = (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.righttest)(node.left); // a
            prevNode.right = z;
            z.parent = prevNode;
        }
        (0,_rbTreeBase_js__WEBPACK_IMPORTED_MODULE_3__.fixInsert)(this, z);
        return z;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PieceTreeTextBuffer: () => (/* binding */ PieceTreeTextBuffer)
/* harmony export */ });
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model.js");
/* harmony import */ var _pieceTreeBase_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pieceTreeBase.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js");
/* harmony import */ var _core_eolCounter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/eolCounter.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js");
/* harmony import */ var _core_textChange_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/textChange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/








class PieceTreeTextBuffer extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_7__.Disposable {
    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {
        super();
        this._onDidChangeContent = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter());
        this._BOM = BOM;
        this._mightContainNonBasicASCII = !isBasicASCII;
        this._mightContainRTL = containsRTL;
        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;
        this._pieceTree = new _pieceTreeBase_js__WEBPACK_IMPORTED_MODULE_4__.PieceTreeBase(chunks, eol, eolNormalized);
    }
    mightContainRTL() {
        return this._mightContainRTL;
    }
    mightContainUnusualLineTerminators() {
        return this._mightContainUnusualLineTerminators;
    }
    resetMightContainUnusualLineTerminators() {
        this._mightContainUnusualLineTerminators = false;
    }
    mightContainNonBasicASCII() {
        return this._mightContainNonBasicASCII;
    }
    getBOM() {
        return this._BOM;
    }
    getEOL() {
        return this._pieceTree.getEOL();
    }
    createSnapshot(preserveBOM) {
        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');
    }
    getOffsetAt(lineNumber, column) {
        return this._pieceTree.getOffsetAt(lineNumber, column);
    }
    getPositionAt(offset) {
        return this._pieceTree.getPositionAt(offset);
    }
    getRangeAt(start, length) {
        const end = start + length;
        const startPosition = this.getPositionAt(start);
        const endPosition = this.getPositionAt(end);
        return new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
    }
    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {
        if (range.isEmpty()) {
            return '';
        }
        const lineEnding = this._getEndOfLine(eol);
        return this._pieceTree.getValueInRange(range, lineEnding);
    }
    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {
        if (range.isEmpty()) {
            return 0;
        }
        if (range.startLineNumber === range.endLineNumber) {
            return (range.endColumn - range.startColumn);
        }
        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);
        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);
        // offsets use the text EOL, so we need to compensate for length differences
        // if the requested EOL doesn't match the text EOL
        let eolOffsetCompensation = 0;
        const desiredEOL = this._getEndOfLine(eol);
        const actualEOL = this.getEOL();
        if (desiredEOL.length !== actualEOL.length) {
            const delta = desiredEOL.length - actualEOL.length;
            const eolCount = range.endLineNumber - range.startLineNumber;
            eolOffsetCompensation = delta * eolCount;
        }
        return endOffset - startOffset + eolOffsetCompensation;
    }
    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {
        if (this._mightContainNonBasicASCII) {
            // we must count by iterating
            let result = 0;
            const fromLineNumber = range.startLineNumber;
            const toLineNumber = range.endLineNumber;
            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
                const lineContent = this.getLineContent(lineNumber);
                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);
                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);
                for (let offset = fromOffset; offset < toOffset; offset++) {
                    if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.isHighSurrogate(lineContent.charCodeAt(offset))) {
                        result = result + 1;
                        offset = offset + 1;
                    }
                    else {
                        result = result + 1;
                    }
                }
            }
            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);
            return result;
        }
        return this.getValueLengthInRange(range, eol);
    }
    getLength() {
        return this._pieceTree.getLength();
    }
    getLineCount() {
        return this._pieceTree.getLineCount();
    }
    getLinesContent() {
        return this._pieceTree.getLinesContent();
    }
    getLineContent(lineNumber) {
        return this._pieceTree.getLineContent(lineNumber);
    }
    getLineCharCode(lineNumber, index) {
        return this._pieceTree.getLineCharCode(lineNumber, index);
    }
    getLineLength(lineNumber) {
        return this._pieceTree.getLineLength(lineNumber);
    }
    getLineFirstNonWhitespaceColumn(lineNumber) {
        const result = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.firstNonWhitespaceIndex(this.getLineContent(lineNumber));
        if (result === -1) {
            return 0;
        }
        return result + 1;
    }
    getLineLastNonWhitespaceColumn(lineNumber) {
        const result = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.lastNonWhitespaceIndex(this.getLineContent(lineNumber));
        if (result === -1) {
            return 0;
        }
        return result + 2;
    }
    _getEndOfLine(eol) {
        switch (eol) {
            case 1 /* EndOfLinePreference.LF */:
                return '\n';
            case 2 /* EndOfLinePreference.CRLF */:
                return '\r\n';
            case 0 /* EndOfLinePreference.TextDefined */:
                return this.getEOL();
            default:
                throw new Error('Unknown EOL preference');
        }
    }
    setEOL(newEOL) {
        this._pieceTree.setEOL(newEOL);
    }
    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {
        let mightContainRTL = this._mightContainRTL;
        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;
        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;
        let canReduceOperations = true;
        let operations = [];
        for (let i = 0; i < rawOperations.length; i++) {
            const op = rawOperations[i];
            if (canReduceOperations && op._isTracked) {
                canReduceOperations = false;
            }
            const validatedRange = op.range;
            if (op.text) {
                let textMightContainNonBasicASCII = true;
                if (!mightContainNonBasicASCII) {
                    textMightContainNonBasicASCII = !_base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.isBasicASCII(op.text);
                    mightContainNonBasicASCII = textMightContainNonBasicASCII;
                }
                if (!mightContainRTL && textMightContainNonBasicASCII) {
                    // check if the new inserted text contains RTL
                    mightContainRTL = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.containsRTL(op.text);
                }
                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {
                    // check if the new inserted text contains unusual line terminators
                    mightContainUnusualLineTerminators = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.containsUnusualLineTerminators(op.text);
                }
            }
            let validText = '';
            let eolCount = 0;
            let firstLineLength = 0;
            let lastLineLength = 0;
            if (op.text) {
                let strEOL;
                [eolCount, firstLineLength, lastLineLength, strEOL] = (0,_core_eolCounter_js__WEBPACK_IMPORTED_MODULE_5__.countEOL)(op.text);
                const bufferEOL = this.getEOL();
                const expectedStrEOL = (bufferEOL === '\r\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);
                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {
                    validText = op.text;
                }
                else {
                    validText = op.text.replace(/\r\n|\r|\n/g, bufferEOL);
                }
            }
            operations[i] = {
                sortIndex: i,
                identifier: op.identifier || null,
                range: validatedRange,
                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),
                rangeLength: this.getValueLengthInRange(validatedRange),
                text: validText,
                eolCount: eolCount,
                firstLineLength: firstLineLength,
                lastLineLength: lastLineLength,
                forceMoveMarkers: Boolean(op.forceMoveMarkers),
                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false
            };
        }
        // Sort operations ascending
        operations.sort(PieceTreeTextBuffer._sortOpsAscending);
        let hasTouchingRanges = false;
        for (let i = 0, count = operations.length - 1; i < count; i++) {
            const rangeEnd = operations[i].range.getEndPosition();
            const nextRangeStart = operations[i + 1].range.getStartPosition();
            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {
                if (nextRangeStart.isBefore(rangeEnd)) {
                    // overlapping ranges
                    throw new Error('Overlapping ranges are not allowed!');
                }
                hasTouchingRanges = true;
            }
        }
        if (canReduceOperations) {
            operations = this._reduceOperations(operations);
        }
        // Delta encode operations
        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);
        const newTrimAutoWhitespaceCandidates = [];
        if (recordTrimAutoWhitespace) {
            for (let i = 0; i < operations.length; i++) {
                const op = operations[i];
                const reverseRange = reverseRanges[i];
                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {
                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit
                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {
                        let currentLineContent = '';
                        if (lineNumber === reverseRange.startLineNumber) {
                            currentLineContent = this.getLineContent(op.range.startLineNumber);
                            if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.firstNonWhitespaceIndex(currentLineContent) !== -1) {
                                continue;
                            }
                        }
                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });
                    }
                }
            }
        }
        let reverseOperations = null;
        if (computeUndoEdits) {
            let reverseRangeDeltaOffset = 0;
            reverseOperations = [];
            for (let i = 0; i < operations.length; i++) {
                const op = operations[i];
                const reverseRange = reverseRanges[i];
                const bufferText = this.getValueInRange(op.range);
                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;
                reverseRangeDeltaOffset += (op.text.length - bufferText.length);
                reverseOperations[i] = {
                    sortIndex: op.sortIndex,
                    identifier: op.identifier,
                    range: reverseRange,
                    text: bufferText,
                    textChange: new _core_textChange_js__WEBPACK_IMPORTED_MODULE_6__.TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)
                };
            }
            // Can only sort reverse operations when the order is not significant
            if (!hasTouchingRanges) {
                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);
            }
        }
        this._mightContainRTL = mightContainRTL;
        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;
        this._mightContainNonBasicASCII = mightContainNonBasicASCII;
        const contentChanges = this._doApplyEdits(operations);
        let trimAutoWhitespaceLineNumbers = null;
        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {
            // sort line numbers auto whitespace removal candidates for next edit descending
            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);
            trimAutoWhitespaceLineNumbers = [];
            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {
                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;
                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {
                    // Do not have the same line number twice
                    continue;
                }
                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;
                const lineContent = this.getLineContent(lineNumber);
                if (lineContent.length === 0 || lineContent === prevContent || _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.firstNonWhitespaceIndex(lineContent) !== -1) {
                    continue;
                }
                trimAutoWhitespaceLineNumbers.push(lineNumber);
            }
        }
        this._onDidChangeContent.fire();
        return new _model_js__WEBPACK_IMPORTED_MODULE_3__.ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);
    }
    /**
     * Transform operations such that they represent the same logic edit,
     * but that they also do not cause OOM crashes.
     */
    _reduceOperations(operations) {
        if (operations.length < 1000) {
            // We know from empirical testing that a thousand edits work fine regardless of their shape.
            return operations;
        }
        // At one point, due to how events are emitted and how each operation is handled,
        // some operations can trigger a high amount of temporary string allocations,
        // that will immediately get edited again.
        // e.g. a formatter inserting ridiculous ammounts of \n on a model with a single line
        // Therefore, the strategy is to collapse all the operations into a huge single edit operation
        return [this._toSingleEditOperation(operations)];
    }
    _toSingleEditOperation(operations) {
        let forceMoveMarkers = false;
        const firstEditRange = operations[0].range;
        const lastEditRange = operations[operations.length - 1].range;
        const entireEditRange = new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);
        let lastEndLineNumber = firstEditRange.startLineNumber;
        let lastEndColumn = firstEditRange.startColumn;
        const result = [];
        for (let i = 0, len = operations.length; i < len; i++) {
            const operation = operations[i];
            const range = operation.range;
            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;
            // (1) -- Push old text
            result.push(this.getValueInRange(new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));
            // (2) -- Push new text
            if (operation.text.length > 0) {
                result.push(operation.text);
            }
            lastEndLineNumber = range.endLineNumber;
            lastEndColumn = range.endColumn;
        }
        const text = result.join('');
        const [eolCount, firstLineLength, lastLineLength] = (0,_core_eolCounter_js__WEBPACK_IMPORTED_MODULE_5__.countEOL)(text);
        return {
            sortIndex: 0,
            identifier: operations[0].identifier,
            range: entireEditRange,
            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),
            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),
            text: text,
            eolCount: eolCount,
            firstLineLength: firstLineLength,
            lastLineLength: lastLineLength,
            forceMoveMarkers: forceMoveMarkers,
            isAutoWhitespaceEdit: false
        };
    }
    _doApplyEdits(operations) {
        operations.sort(PieceTreeTextBuffer._sortOpsDescending);
        const contentChanges = [];
        // operations are from bottom to top
        for (let i = 0; i < operations.length; i++) {
            const op = operations[i];
            const startLineNumber = op.range.startLineNumber;
            const startColumn = op.range.startColumn;
            const endLineNumber = op.range.endLineNumber;
            const endColumn = op.range.endColumn;
            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {
                // no-op
                continue;
            }
            if (op.text) {
                // replacement
                this._pieceTree.delete(op.rangeOffset, op.rangeLength);
                this._pieceTree.insert(op.rangeOffset, op.text, true);
            }
            else {
                // deletion
                this._pieceTree.delete(op.rangeOffset, op.rangeLength);
            }
            const contentChangeRange = new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(startLineNumber, startColumn, endLineNumber, endColumn);
            contentChanges.push({
                range: contentChangeRange,
                rangeLength: op.rangeLength,
                text: op.text,
                rangeOffset: op.rangeOffset,
                forceMoveMarkers: op.forceMoveMarkers
            });
        }
        return contentChanges;
    }
    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
    }
    /**
     * Assumes `operations` are validated and sorted ascending
     */
    static _getInverseEditRanges(operations) {
        const result = [];
        let prevOpEndLineNumber = 0;
        let prevOpEndColumn = 0;
        let prevOp = null;
        for (let i = 0, len = operations.length; i < len; i++) {
            const op = operations[i];
            let startLineNumber;
            let startColumn;
            if (prevOp) {
                if (prevOp.range.endLineNumber === op.range.startLineNumber) {
                    startLineNumber = prevOpEndLineNumber;
                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);
                }
                else {
                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);
                    startColumn = op.range.startColumn;
                }
            }
            else {
                startLineNumber = op.range.startLineNumber;
                startColumn = op.range.startColumn;
            }
            let resultRange;
            if (op.text.length > 0) {
                // the operation inserts something
                const lineCount = op.eolCount + 1;
                if (lineCount === 1) {
                    // single line insert
                    resultRange = new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);
                }
                else {
                    // multi line insert
                    resultRange = new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);
                }
            }
            else {
                // There is nothing to insert
                resultRange = new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(startLineNumber, startColumn, startLineNumber, startColumn);
            }
            prevOpEndLineNumber = resultRange.endLineNumber;
            prevOpEndColumn = resultRange.endColumn;
            result.push(resultRange);
            prevOp = op;
        }
        return result;
    }
    static _sortOpsAscending(a, b) {
        const r = _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range.compareRangesUsingEnds(a.range, b.range);
        if (r === 0) {
            return a.sortIndex - b.sortIndex;
        }
        return r;
    }
    static _sortOpsDescending(a, b) {
        const r = _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range.compareRangesUsingEnds(a.range, b.range);
        if (r === 0) {
            return b.sortIndex - a.sortIndex;
        }
        return -r;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PieceTreeTextBufferBuilder: () => (/* binding */ PieceTreeTextBufferBuilder)
/* harmony export */ });
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _pieceTreeBase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pieceTreeBase.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js");
/* harmony import */ var _pieceTreeTextBuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pieceTreeTextBuffer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class PieceTreeTextBufferFactory {
    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {
        this._chunks = _chunks;
        this._bom = _bom;
        this._cr = _cr;
        this._lf = _lf;
        this._crlf = _crlf;
        this._containsRTL = _containsRTL;
        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;
        this._isBasicASCII = _isBasicASCII;
        this._normalizeEOL = _normalizeEOL;
    }
    _getEOL(defaultEOL) {
        const totalEOLCount = this._cr + this._lf + this._crlf;
        const totalCRCount = this._cr + this._crlf;
        if (totalEOLCount === 0) {
            // This is an empty file or a file with precisely one line
            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\n' : '\r\n');
        }
        if (totalCRCount > totalEOLCount / 2) {
            // More than half of the file contains \r\n ending lines
            return '\r\n';
        }
        // At least one line more ends in \n
        return '\n';
    }
    create(defaultEOL) {
        const eol = this._getEOL(defaultEOL);
        const chunks = this._chunks;
        if (this._normalizeEOL &&
            ((eol === '\r\n' && (this._cr > 0 || this._lf > 0))
                || (eol === '\n' && (this._cr > 0 || this._crlf > 0)))) {
            // Normalize pieces
            for (let i = 0, len = chunks.length; i < len; i++) {
                const str = chunks[i].buffer.replace(/\r\n|\r|\n/g, eol);
                const newLineStart = (0,_pieceTreeBase_js__WEBPACK_IMPORTED_MODULE_1__.createLineStartsFast)(str);
                chunks[i] = new _pieceTreeBase_js__WEBPACK_IMPORTED_MODULE_1__.StringBuffer(str, newLineStart);
            }
        }
        const textBuffer = new _pieceTreeTextBuffer_js__WEBPACK_IMPORTED_MODULE_2__.PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
        return { textBuffer: textBuffer, disposable: textBuffer };
    }
}
class PieceTreeTextBufferBuilder {
    constructor() {
        this.chunks = [];
        this.BOM = '';
        this._hasPreviousChar = false;
        this._previousChar = 0;
        this._tmpLineStarts = [];
        this.cr = 0;
        this.lf = 0;
        this.crlf = 0;
        this.containsRTL = false;
        this.containsUnusualLineTerminators = false;
        this.isBasicASCII = true;
    }
    acceptChunk(chunk) {
        if (chunk.length === 0) {
            return;
        }
        if (this.chunks.length === 0) {
            if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.startsWithUTF8BOM(chunk)) {
                this.BOM = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.UTF8_BOM_CHARACTER;
                chunk = chunk.substr(1);
            }
        }
        const lastChar = chunk.charCodeAt(chunk.length - 1);
        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {
            // last character is \r or a high surrogate => keep it back
            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);
            this._hasPreviousChar = true;
            this._previousChar = lastChar;
        }
        else {
            this._acceptChunk1(chunk, false);
            this._hasPreviousChar = false;
            this._previousChar = lastChar;
        }
    }
    _acceptChunk1(chunk, allowEmptyStrings) {
        if (!allowEmptyStrings && chunk.length === 0) {
            // Nothing to do
            return;
        }
        if (this._hasPreviousChar) {
            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);
        }
        else {
            this._acceptChunk2(chunk);
        }
    }
    _acceptChunk2(chunk) {
        const lineStarts = (0,_pieceTreeBase_js__WEBPACK_IMPORTED_MODULE_1__.createLineStarts)(this._tmpLineStarts, chunk);
        this.chunks.push(new _pieceTreeBase_js__WEBPACK_IMPORTED_MODULE_1__.StringBuffer(chunk, lineStarts.lineStarts));
        this.cr += lineStarts.cr;
        this.lf += lineStarts.lf;
        this.crlf += lineStarts.crlf;
        if (!lineStarts.isBasicASCII) {
            // this chunk contains non basic ASCII characters
            this.isBasicASCII = false;
            if (!this.containsRTL) {
                this.containsRTL = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.containsRTL(chunk);
            }
            if (!this.containsUnusualLineTerminators) {
                this.containsUnusualLineTerminators = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.containsUnusualLineTerminators(chunk);
            }
        }
    }
    finish(normalizeEOL = true) {
        this._finish();
        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);
    }
    _finish() {
        if (this.chunks.length === 0) {
            this._acceptChunk1('', true);
        }
        if (this._hasPreviousChar) {
            this._hasPreviousChar = false;
            // recreate last chunk
            const lastChunk = this.chunks[this.chunks.length - 1];
            lastChunk.buffer += String.fromCharCode(this._previousChar);
            const newLineStarts = (0,_pieceTreeBase_js__WEBPACK_IMPORTED_MODULE_1__.createLineStartsFast)(lastChunk.buffer);
            lastChunk.lineStarts = newLineStarts;
            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {
                this.cr++;
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SENTINEL: () => (/* binding */ SENTINEL),
/* harmony export */   TreeNode: () => (/* binding */ TreeNode),
/* harmony export */   fixInsert: () => (/* binding */ fixInsert),
/* harmony export */   leftRotate: () => (/* binding */ leftRotate),
/* harmony export */   leftest: () => (/* binding */ leftest),
/* harmony export */   rbDelete: () => (/* binding */ rbDelete),
/* harmony export */   recomputeTreeMetadata: () => (/* binding */ recomputeTreeMetadata),
/* harmony export */   rightRotate: () => (/* binding */ rightRotate),
/* harmony export */   righttest: () => (/* binding */ righttest),
/* harmony export */   updateTreeMetadata: () => (/* binding */ updateTreeMetadata)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class TreeNode {
    constructor(piece, color) {
        this.piece = piece;
        this.color = color;
        this.size_left = 0;
        this.lf_left = 0;
        this.parent = this;
        this.left = this;
        this.right = this;
    }
    next() {
        if (this.right !== SENTINEL) {
            return leftest(this.right);
        }
        let node = this;
        while (node.parent !== SENTINEL) {
            if (node.parent.left === node) {
                break;
            }
            node = node.parent;
        }
        if (node.parent === SENTINEL) {
            return SENTINEL;
        }
        else {
            return node.parent;
        }
    }
    prev() {
        if (this.left !== SENTINEL) {
            return righttest(this.left);
        }
        let node = this;
        while (node.parent !== SENTINEL) {
            if (node.parent.right === node) {
                break;
            }
            node = node.parent;
        }
        if (node.parent === SENTINEL) {
            return SENTINEL;
        }
        else {
            return node.parent;
        }
    }
    detach() {
        this.parent = null;
        this.left = null;
        this.right = null;
    }
}
const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);
SENTINEL.parent = SENTINEL;
SENTINEL.left = SENTINEL;
SENTINEL.right = SENTINEL;
SENTINEL.color = 0 /* NodeColor.Black */;
function leftest(node) {
    while (node.left !== SENTINEL) {
        node = node.left;
    }
    return node;
}
function righttest(node) {
    while (node.right !== SENTINEL) {
        node = node.right;
    }
    return node;
}
function calculateSize(node) {
    if (node === SENTINEL) {
        return 0;
    }
    return node.size_left + node.piece.length + calculateSize(node.right);
}
function calculateLF(node) {
    if (node === SENTINEL) {
        return 0;
    }
    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);
}
function resetSentinel() {
    SENTINEL.parent = SENTINEL;
}
function leftRotate(tree, x) {
    const y = x.right;
    // fix size_left
    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);
    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
    x.right = y.left;
    if (y.left !== SENTINEL) {
        y.left.parent = x;
    }
    y.parent = x.parent;
    if (x.parent === SENTINEL) {
        tree.root = y;
    }
    else if (x.parent.left === x) {
        x.parent.left = y;
    }
    else {
        x.parent.right = y;
    }
    y.left = x;
    x.parent = y;
}
function rightRotate(tree, y) {
    const x = y.left;
    y.left = x.right;
    if (x.right !== SENTINEL) {
        x.right.parent = y;
    }
    x.parent = y.parent;
    // fix size_left
    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);
    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
    if (y.parent === SENTINEL) {
        tree.root = x;
    }
    else if (y === y.parent.right) {
        y.parent.right = x;
    }
    else {
        y.parent.left = x;
    }
    x.right = y;
    y.parent = x;
}
function rbDelete(tree, z) {
    let x;
    let y;
    if (z.left === SENTINEL) {
        y = z;
        x = y.right;
    }
    else if (z.right === SENTINEL) {
        y = z;
        x = y.left;
    }
    else {
        y = leftest(z.right);
        x = y.right;
    }
    if (y === tree.root) {
        tree.root = x;
        // if x is null, we are removing the only node
        x.color = 0 /* NodeColor.Black */;
        z.detach();
        resetSentinel();
        tree.root.parent = SENTINEL;
        return;
    }
    const yWasRed = (y.color === 1 /* NodeColor.Red */);
    if (y === y.parent.left) {
        y.parent.left = x;
    }
    else {
        y.parent.right = x;
    }
    if (y === z) {
        x.parent = y.parent;
        recomputeTreeMetadata(tree, x);
    }
    else {
        if (y.parent === z) {
            x.parent = y;
        }
        else {
            x.parent = y.parent;
        }
        // as we make changes to x's hierarchy, update size_left of subtree first
        recomputeTreeMetadata(tree, x);
        y.left = z.left;
        y.right = z.right;
        y.parent = z.parent;
        y.color = z.color;
        if (z === tree.root) {
            tree.root = y;
        }
        else {
            if (z === z.parent.left) {
                z.parent.left = y;
            }
            else {
                z.parent.right = y;
            }
        }
        if (y.left !== SENTINEL) {
            y.left.parent = y;
        }
        if (y.right !== SENTINEL) {
            y.right.parent = y;
        }
        // update metadata
        // we replace z with y, so in this sub tree, the length change is z.item.length
        y.size_left = z.size_left;
        y.lf_left = z.lf_left;
        recomputeTreeMetadata(tree, y);
    }
    z.detach();
    if (x.parent.left === x) {
        const newSizeLeft = calculateSize(x);
        const newLFLeft = calculateLF(x);
        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {
            const delta = newSizeLeft - x.parent.size_left;
            const lf_delta = newLFLeft - x.parent.lf_left;
            x.parent.size_left = newSizeLeft;
            x.parent.lf_left = newLFLeft;
            updateTreeMetadata(tree, x.parent, delta, lf_delta);
        }
    }
    recomputeTreeMetadata(tree, x.parent);
    if (yWasRed) {
        resetSentinel();
        return;
    }
    // RB-DELETE-FIXUP
    let w;
    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {
        if (x === x.parent.left) {
            w = x.parent.right;
            if (w.color === 1 /* NodeColor.Red */) {
                w.color = 0 /* NodeColor.Black */;
                x.parent.color = 1 /* NodeColor.Red */;
                leftRotate(tree, x.parent);
                w = x.parent.right;
            }
            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {
                w.color = 1 /* NodeColor.Red */;
                x = x.parent;
            }
            else {
                if (w.right.color === 0 /* NodeColor.Black */) {
                    w.left.color = 0 /* NodeColor.Black */;
                    w.color = 1 /* NodeColor.Red */;
                    rightRotate(tree, w);
                    w = x.parent.right;
                }
                w.color = x.parent.color;
                x.parent.color = 0 /* NodeColor.Black */;
                w.right.color = 0 /* NodeColor.Black */;
                leftRotate(tree, x.parent);
                x = tree.root;
            }
        }
        else {
            w = x.parent.left;
            if (w.color === 1 /* NodeColor.Red */) {
                w.color = 0 /* NodeColor.Black */;
                x.parent.color = 1 /* NodeColor.Red */;
                rightRotate(tree, x.parent);
                w = x.parent.left;
            }
            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {
                w.color = 1 /* NodeColor.Red */;
                x = x.parent;
            }
            else {
                if (w.left.color === 0 /* NodeColor.Black */) {
                    w.right.color = 0 /* NodeColor.Black */;
                    w.color = 1 /* NodeColor.Red */;
                    leftRotate(tree, w);
                    w = x.parent.left;
                }
                w.color = x.parent.color;
                x.parent.color = 0 /* NodeColor.Black */;
                w.left.color = 0 /* NodeColor.Black */;
                rightRotate(tree, x.parent);
                x = tree.root;
            }
        }
    }
    x.color = 0 /* NodeColor.Black */;
    resetSentinel();
}
function fixInsert(tree, x) {
    recomputeTreeMetadata(tree, x);
    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {
        if (x.parent === x.parent.parent.left) {
            const y = x.parent.parent.right;
            if (y.color === 1 /* NodeColor.Red */) {
                x.parent.color = 0 /* NodeColor.Black */;
                y.color = 0 /* NodeColor.Black */;
                x.parent.parent.color = 1 /* NodeColor.Red */;
                x = x.parent.parent;
            }
            else {
                if (x === x.parent.right) {
                    x = x.parent;
                    leftRotate(tree, x);
                }
                x.parent.color = 0 /* NodeColor.Black */;
                x.parent.parent.color = 1 /* NodeColor.Red */;
                rightRotate(tree, x.parent.parent);
            }
        }
        else {
            const y = x.parent.parent.left;
            if (y.color === 1 /* NodeColor.Red */) {
                x.parent.color = 0 /* NodeColor.Black */;
                y.color = 0 /* NodeColor.Black */;
                x.parent.parent.color = 1 /* NodeColor.Red */;
                x = x.parent.parent;
            }
            else {
                if (x === x.parent.left) {
                    x = x.parent;
                    rightRotate(tree, x);
                }
                x.parent.color = 0 /* NodeColor.Black */;
                x.parent.parent.color = 1 /* NodeColor.Red */;
                leftRotate(tree, x.parent.parent);
            }
        }
    }
    tree.root.color = 0 /* NodeColor.Black */;
}
function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {
    // node length change or line feed count change
    while (x !== tree.root && x !== SENTINEL) {
        if (x.parent.left === x) {
            x.parent.size_left += delta;
            x.parent.lf_left += lineFeedCntDelta;
        }
        x = x.parent;
    }
}
function recomputeTreeMetadata(tree, x) {
    let delta = 0;
    let lf_delta = 0;
    if (x === tree.root) {
        return;
    }
    // go upwards till the node whose left subtree is changed.
    while (x !== tree.root && x === x.parent.right) {
        x = x.parent;
    }
    if (x === tree.root) {
        // well, it means we add a node to the end (inorder)
        return;
    }
    // x is the node whose right subtree is changed.
    x = x.parent;
    delta = calculateSize(x.left) - x.size_left;
    lf_delta = calculateLF(x.left) - x.lf_left;
    x.size_left += delta;
    x.lf_left += lf_delta;
    // go upwards till root. O(logN)
    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {
        if (x.parent.left === x) {
            x.parent.size_left += delta;
            x.parent.lf_left += lf_delta;
        }
        x = x.parent;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModelDecorationGlyphMarginOptions: () => (/* binding */ ModelDecorationGlyphMarginOptions),
/* harmony export */   ModelDecorationInjectedTextOptions: () => (/* binding */ ModelDecorationInjectedTextOptions),
/* harmony export */   ModelDecorationMinimapOptions: () => (/* binding */ ModelDecorationMinimapOptions),
/* harmony export */   ModelDecorationOptions: () => (/* binding */ ModelDecorationOptions),
/* harmony export */   ModelDecorationOverviewRulerOptions: () => (/* binding */ ModelDecorationOverviewRulerOptions),
/* harmony export */   TextModel: () => (/* binding */ TextModel),
/* harmony export */   createTextBuffer: () => (/* binding */ createTextBuffer),
/* harmony export */   createTextBufferFactory: () => (/* binding */ createTextBufferFactory),
/* harmony export */   createTextBufferFactoryFromSnapshot: () => (/* binding */ createTextBufferFactoryFromSnapshot),
/* harmony export */   indentOfLine: () => (/* binding */ indentOfLine)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _base_common_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/color.js */ "./node_modules/monaco-editor/esm/vs/base/common/color.js");
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../base/common/uri.js */ "./node_modules/monaco-editor/esm/vs/base/common/uri.js");
/* harmony import */ var _core_eolCounter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/eolCounter.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js");
/* harmony import */ var _core_indentation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/indentation.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _core_selection_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../core/selection.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js");
/* harmony import */ var _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../core/textModelDefaults.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js");
/* harmony import */ var _languages_language_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../languages/language.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/language.js");
/* harmony import */ var _languages_languageConfigurationRegistry_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../languages/languageConfigurationRegistry.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js");
/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../model.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model.js");
/* harmony import */ var _bracketPairsTextModelPart_bracketPairsImpl_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./bracketPairsTextModelPart/bracketPairsImpl.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js");
/* harmony import */ var _bracketPairsTextModelPart_colorizedBracketPairsDecorationProvider_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js");
/* harmony import */ var _editStack_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./editStack.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js");
/* harmony import */ var _guidesTextModelPart_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./guidesTextModelPart.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js");
/* harmony import */ var _indentationGuesser_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./indentationGuesser.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js");
/* harmony import */ var _intervalTree_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./intervalTree.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js");
/* harmony import */ var _pieceTreeTextBuffer_pieceTreeTextBuffer_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./pieceTreeTextBuffer/pieceTreeTextBuffer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js");
/* harmony import */ var _pieceTreeTextBuffer_pieceTreeTextBufferBuilder_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js");
/* harmony import */ var _textModelSearch_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./textModelSearch.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js");
/* harmony import */ var _tokenizationTextModelPart_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./tokenizationTextModelPart.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js");
/* harmony import */ var _tokens_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./tokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js");
/* harmony import */ var _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../textModelEvents.js */ "./node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js");
/* harmony import */ var _platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../../../platform/instantiation/common/instantiation.js */ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js");
/* harmony import */ var _platform_undoRedo_common_undoRedo_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../../../platform/undoRedo/common/undoRedo.js */ "./node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TextModel_1;






























function createTextBufferFactory(text) {
    const builder = new _pieceTreeTextBuffer_pieceTreeTextBufferBuilder_js__WEBPACK_IMPORTED_MODULE_23__.PieceTreeTextBufferBuilder();
    builder.acceptChunk(text);
    return builder.finish();
}
function createTextBufferFactoryFromSnapshot(snapshot) {
    const builder = new _pieceTreeTextBuffer_pieceTreeTextBufferBuilder_js__WEBPACK_IMPORTED_MODULE_23__.PieceTreeTextBufferBuilder();
    let chunk;
    while (typeof (chunk = snapshot.read()) === 'string') {
        builder.acceptChunk(chunk);
    }
    return builder.finish();
}
function createTextBuffer(value, defaultEOL) {
    let factory;
    if (typeof value === 'string') {
        factory = createTextBufferFactory(value);
    }
    else if (_model_js__WEBPACK_IMPORTED_MODULE_15__.isITextSnapshot(value)) {
        factory = createTextBufferFactoryFromSnapshot(value);
    }
    else {
        factory = value;
    }
    return factory.create(defaultEOL);
}
let MODEL_ID = 0;
const LIMIT_FIND_COUNT = 999;
const LONG_LINE_BOUNDARY = 10000;
class TextModelSnapshot {
    constructor(source) {
        this._source = source;
        this._eos = false;
    }
    read() {
        if (this._eos) {
            return null;
        }
        const result = [];
        let resultCnt = 0;
        let resultLength = 0;
        do {
            const tmp = this._source.read();
            if (tmp === null) {
                // end-of-stream
                this._eos = true;
                if (resultCnt === 0) {
                    return null;
                }
                else {
                    return result.join('');
                }
            }
            if (tmp.length > 0) {
                result[resultCnt++] = tmp;
                resultLength += tmp.length;
            }
            if (resultLength >= 64 * 1024) {
                return result.join('');
            }
        } while (true);
    }
}
const invalidFunc = () => { throw new Error(`Invalid change accessor`); };
let TextModel = class TextModel extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_4__.Disposable {
    static { TextModel_1 = this; }
    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests
    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;
    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines
    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage
    static { this.DEFAULT_CREATION_OPTIONS = {
        isForSimpleWidget: false,
        tabSize: _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_12__.EDITOR_MODEL_DEFAULTS.tabSize,
        indentSize: _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_12__.EDITOR_MODEL_DEFAULTS.indentSize,
        insertSpaces: _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_12__.EDITOR_MODEL_DEFAULTS.insertSpaces,
        detectIndentation: false,
        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,
        trimAutoWhitespace: _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_12__.EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,
        largeFileOptimizations: _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_12__.EDITOR_MODEL_DEFAULTS.largeFileOptimizations,
        bracketPairColorizationOptions: _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_12__.EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,
    }; }
    static resolveOptions(textBuffer, options) {
        if (options.detectIndentation) {
            const guessedIndentation = (0,_indentationGuesser_js__WEBPACK_IMPORTED_MODULE_20__.guessIndentation)(textBuffer, options.tabSize, options.insertSpaces);
            return new _model_js__WEBPACK_IMPORTED_MODULE_15__.TextModelResolvedOptions({
                tabSize: guessedIndentation.tabSize,
                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize
                insertSpaces: guessedIndentation.insertSpaces,
                trimAutoWhitespace: options.trimAutoWhitespace,
                defaultEOL: options.defaultEOL,
                bracketPairColorizationOptions: options.bracketPairColorizationOptions,
            });
        }
        return new _model_js__WEBPACK_IMPORTED_MODULE_15__.TextModelResolvedOptions(options);
    }
    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }
    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }
    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }
    onDidChangeContent(listener) {
        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));
    }
    onDidChangeContentOrInjectedText(listener) {
        return (0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_4__.combinedDisposable)(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));
    }
    _isDisposing() { return this.__isDisposing; }
    get tokenization() { return this._tokenizationTextModelPart; }
    get bracketPairs() { return this._bracketPairs; }
    get guides() { return this._guidesTextModelPart; }
    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {
        super();
        this._undoRedoService = _undoRedoService;
        this._languageService = _languageService;
        this._languageConfigurationService = _languageConfigurationService;
        this.instantiationService = instantiationService;
        //#region Events
        this._onWillDispose = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_3__.Emitter());
        this.onWillDispose = this._onWillDispose.event;
        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));
        this.onDidChangeDecorations = this._onDidChangeDecorations.event;
        this._onDidChangeOptions = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_3__.Emitter());
        this.onDidChangeOptions = this._onDidChangeOptions.event;
        this._onDidChangeAttached = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_3__.Emitter());
        this.onDidChangeAttached = this._onDidChangeAttached.event;
        this._onDidChangeInjectedText = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_3__.Emitter());
        this._eventEmitter = this._register(new DidChangeContentEmitter());
        this._languageSelectionListener = this._register(new _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_4__.MutableDisposable());
        this._deltaDecorationCallCnt = 0;
        this._attachedViews = new _tokens_js__WEBPACK_IMPORTED_MODULE_26__.AttachedViews();
        // Generate a new unique model id
        MODEL_ID++;
        this.id = '$model' + MODEL_ID;
        this.isForSimpleWidget = creationOptions.isForSimpleWidget;
        if (typeof associatedResource === 'undefined' || associatedResource === null) {
            this._associatedResource = _base_common_uri_js__WEBPACK_IMPORTED_MODULE_6__.URI.parse('inmemory://model/' + MODEL_ID);
        }
        else {
            this._associatedResource = associatedResource;
        }
        this._attachedEditorCount = 0;
        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);
        this._buffer = textBuffer;
        this._bufferDisposable = disposable;
        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);
        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);
        if (typeof languageIdOrSelection !== 'string') {
            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));
        }
        this._bracketPairs = this._register(new _bracketPairsTextModelPart_bracketPairsImpl_js__WEBPACK_IMPORTED_MODULE_16__.BracketPairsTextModelPart(this, this._languageConfigurationService));
        this._guidesTextModelPart = this._register(new _guidesTextModelPart_js__WEBPACK_IMPORTED_MODULE_19__.GuidesTextModelPart(this, this._languageConfigurationService));
        this._decorationProvider = this._register(new _bracketPairsTextModelPart_colorizedBracketPairsDecorationProvider_js__WEBPACK_IMPORTED_MODULE_17__.ColorizedBracketPairsDecorationProvider(this));
        this._tokenizationTextModelPart = this.instantiationService.createInstance(_tokenizationTextModelPart_js__WEBPACK_IMPORTED_MODULE_25__.TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);
        const bufferLineCount = this._buffer.getLineCount();
        const bufferTextLength = this._buffer.getValueLengthInRange(new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);
        // !!! Make a decision in the ctor and permanently respect this decision !!!
        // If a model is too large at construction time, it will never get tokenized,
        // under no circumstances.
        if (creationOptions.largeFileOptimizations) {
            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)
                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));
            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;
        }
        else {
            this._isTooLargeForTokenization = false;
            this._isTooLargeForHeapOperation = false;
        }
        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);
        this._versionId = 1;
        this._alternativeVersionId = 1;
        this._initialUndoRedoSnapshot = null;
        this._isDisposed = false;
        this.__isDisposing = false;
        this._instanceId = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_5__.singleLetterHash(MODEL_ID);
        this._lastDecorationId = 0;
        this._decorations = Object.create(null);
        this._decorationsTree = new DecorationsTrees();
        this._commandManager = new _editStack_js__WEBPACK_IMPORTED_MODULE_18__.EditStack(this, this._undoRedoService);
        this._isUndoing = false;
        this._isRedoing = false;
        this._trimAutoWhitespaceLines = null;
        this._register(this._decorationProvider.onDidChange(() => {
            this._onDidChangeDecorations.beginDeferredEmit();
            this._onDidChangeDecorations.fire();
            this._onDidChangeDecorations.endDeferredEmit();
        }));
        this._languageService.requestRichLanguageFeatures(languageId);
        this._register(this._languageConfigurationService.onDidChange(e => {
            this._bracketPairs.handleLanguageConfigurationServiceChange(e);
            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);
        }));
    }
    dispose() {
        this.__isDisposing = true;
        this._onWillDispose.fire();
        this._tokenizationTextModelPart.dispose();
        this._isDisposed = true;
        super.dispose();
        this._bufferDisposable.dispose();
        this.__isDisposing = false;
        // Manually release reference to previous text buffer to avoid large leaks
        // in case someone leaks a TextModel reference
        const emptyDisposedTextBuffer = new _pieceTreeTextBuffer_pieceTreeTextBuffer_js__WEBPACK_IMPORTED_MODULE_22__.PieceTreeTextBuffer([], '', '\n', false, false, true, true);
        emptyDisposedTextBuffer.dispose();
        this._buffer = emptyDisposedTextBuffer;
        this._bufferDisposable = _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_4__.Disposable.None;
    }
    _assertNotDisposed() {
        if (this._isDisposed) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__.BugIndicatingError('Model is disposed!');
        }
    }
    _emitContentChangedEvent(rawChange, change) {
        if (this.__isDisposing) {
            // Do not confuse listeners by emitting any event after disposing
            return;
        }
        this._tokenizationTextModelPart.handleDidChangeContent(change);
        this._bracketPairs.handleDidChangeContent(change);
        this._eventEmitter.fire(new _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.InternalModelContentChangeEvent(rawChange, change));
    }
    setValue(value) {
        this._assertNotDisposed();
        if (value === null || value === undefined) {
            throw (0,_base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__.illegalArgument)();
        }
        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);
        this._setValueFromTextBuffer(textBuffer, disposable);
    }
    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {
        return {
            changes: [{
                    range: range,
                    rangeOffset: rangeOffset,
                    rangeLength: rangeLength,
                    text: text,
                }],
            eol: this._buffer.getEOL(),
            isEolChange: isEolChange,
            versionId: this.getVersionId(),
            isUndoing: isUndoing,
            isRedoing: isRedoing,
            isFlush: isFlush
        };
    }
    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {
        this._assertNotDisposed();
        const oldFullModelRange = this.getFullModelRange();
        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
        const endLineNumber = this.getLineCount();
        const endColumn = this.getLineMaxColumn(endLineNumber);
        this._buffer = textBuffer;
        this._bufferDisposable.dispose();
        this._bufferDisposable = textBufferDisposable;
        this._increaseVersionId();
        // Destroy all my decorations
        this._decorations = Object.create(null);
        this._decorationsTree = new DecorationsTrees();
        // Destroy my edit history and settings
        this._commandManager.clear();
        this._trimAutoWhitespaceLines = null;
        this._emitContentChangedEvent(new _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.ModelRawContentChangedEvent([
            new _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.ModelRawFlush()
        ], this._versionId, false, false), this._createContentChanged2(new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));
    }
    setEOL(eol) {
        this._assertNotDisposed();
        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\r\n' : '\n');
        if (this._buffer.getEOL() === newEOL) {
            // Nothing to do
            return;
        }
        const oldFullModelRange = this.getFullModelRange();
        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
        const endLineNumber = this.getLineCount();
        const endColumn = this.getLineMaxColumn(endLineNumber);
        this._onBeforeEOLChange();
        this._buffer.setEOL(newEOL);
        this._increaseVersionId();
        this._onAfterEOLChange();
        this._emitContentChangedEvent(new _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.ModelRawContentChangedEvent([
            new _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.ModelRawEOLChanged()
        ], this._versionId, false, false), this._createContentChanged2(new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));
    }
    _onBeforeEOLChange() {
        // Ensure all decorations get their `range` set.
        this._decorationsTree.ensureAllNodesHaveRanges(this);
    }
    _onAfterEOLChange() {
        // Transform back `range` to offsets
        const versionId = this.getVersionId();
        const allDecorations = this._decorationsTree.collectNodesPostOrder();
        for (let i = 0, len = allDecorations.length; i < len; i++) {
            const node = allDecorations[i];
            const range = node.range; // the range is defined due to `_onBeforeEOLChange`
            const delta = node.cachedAbsoluteStart - node.start;
            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);
            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
            node.cachedAbsoluteStart = startOffset;
            node.cachedAbsoluteEnd = endOffset;
            node.cachedVersionId = versionId;
            node.start = startOffset - delta;
            node.end = endOffset - delta;
            (0,_intervalTree_js__WEBPACK_IMPORTED_MODULE_21__.recomputeMaxEnd)(node);
        }
    }
    onBeforeAttached() {
        this._attachedEditorCount++;
        if (this._attachedEditorCount === 1) {
            this._tokenizationTextModelPart.handleDidChangeAttached();
            this._onDidChangeAttached.fire(undefined);
        }
        return this._attachedViews.attachView();
    }
    onBeforeDetached(view) {
        this._attachedEditorCount--;
        if (this._attachedEditorCount === 0) {
            this._tokenizationTextModelPart.handleDidChangeAttached();
            this._onDidChangeAttached.fire(undefined);
        }
        this._attachedViews.detachView(view);
    }
    isAttachedToEditor() {
        return this._attachedEditorCount > 0;
    }
    getAttachedEditorCount() {
        return this._attachedEditorCount;
    }
    isTooLargeForSyncing() {
        return this._isTooLargeForSyncing;
    }
    isTooLargeForTokenization() {
        return this._isTooLargeForTokenization;
    }
    isTooLargeForHeapOperation() {
        return this._isTooLargeForHeapOperation;
    }
    isDisposed() {
        return this._isDisposed;
    }
    isDominatedByLongLines() {
        this._assertNotDisposed();
        if (this.isTooLargeForTokenization()) {
            // Cannot word wrap huge files anyways, so it doesn't really matter
            return false;
        }
        let smallLineCharCount = 0;
        let longLineCharCount = 0;
        const lineCount = this._buffer.getLineCount();
        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {
            const lineLength = this._buffer.getLineLength(lineNumber);
            if (lineLength >= LONG_LINE_BOUNDARY) {
                longLineCharCount += lineLength;
            }
            else {
                smallLineCharCount += lineLength;
            }
        }
        return (longLineCharCount > smallLineCharCount);
    }
    get uri() {
        return this._associatedResource;
    }
    //#region Options
    getOptions() {
        this._assertNotDisposed();
        return this._options;
    }
    getFormattingOptions() {
        return {
            tabSize: this._options.indentSize,
            insertSpaces: this._options.insertSpaces
        };
    }
    updateOptions(_newOpts) {
        this._assertNotDisposed();
        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;
        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;
        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;
        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;
        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;
        const newOpts = new _model_js__WEBPACK_IMPORTED_MODULE_15__.TextModelResolvedOptions({
            tabSize: tabSize,
            indentSize: indentSize,
            insertSpaces: insertSpaces,
            defaultEOL: this._options.defaultEOL,
            trimAutoWhitespace: trimAutoWhitespace,
            bracketPairColorizationOptions,
        });
        if (this._options.equals(newOpts)) {
            return;
        }
        const e = this._options.createChangeEvent(newOpts);
        this._options = newOpts;
        this._bracketPairs.handleDidChangeOptions(e);
        this._decorationProvider.handleDidChangeOptions(e);
        this._onDidChangeOptions.fire(e);
    }
    detectIndentation(defaultInsertSpaces, defaultTabSize) {
        this._assertNotDisposed();
        const guessedIndentation = (0,_indentationGuesser_js__WEBPACK_IMPORTED_MODULE_20__.guessIndentation)(this._buffer, defaultTabSize, defaultInsertSpaces);
        this.updateOptions({
            insertSpaces: guessedIndentation.insertSpaces,
            tabSize: guessedIndentation.tabSize,
            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize
        });
    }
    normalizeIndentation(str) {
        this._assertNotDisposed();
        return (0,_core_indentation_js__WEBPACK_IMPORTED_MODULE_8__.normalizeIndentation)(str, this._options.indentSize, this._options.insertSpaces);
    }
    //#endregion
    //#region Reading
    getVersionId() {
        this._assertNotDisposed();
        return this._versionId;
    }
    mightContainRTL() {
        return this._buffer.mightContainRTL();
    }
    mightContainUnusualLineTerminators() {
        return this._buffer.mightContainUnusualLineTerminators();
    }
    removeUnusualLineTerminators(selections = null) {
        const matches = this.findMatches(_base_common_strings_js__WEBPACK_IMPORTED_MODULE_5__.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);
        this._buffer.resetMightContainUnusualLineTerminators();
        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);
    }
    mightContainNonBasicASCII() {
        return this._buffer.mightContainNonBasicASCII();
    }
    getAlternativeVersionId() {
        this._assertNotDisposed();
        return this._alternativeVersionId;
    }
    getInitialUndoRedoSnapshot() {
        this._assertNotDisposed();
        return this._initialUndoRedoSnapshot;
    }
    getOffsetAt(rawPosition) {
        this._assertNotDisposed();
        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);
        return this._buffer.getOffsetAt(position.lineNumber, position.column);
    }
    getPositionAt(rawOffset) {
        this._assertNotDisposed();
        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));
        return this._buffer.getPositionAt(offset);
    }
    _increaseVersionId() {
        this._versionId = this._versionId + 1;
        this._alternativeVersionId = this._versionId;
    }
    _overwriteVersionId(versionId) {
        this._versionId = versionId;
    }
    _overwriteAlternativeVersionId(newAlternativeVersionId) {
        this._alternativeVersionId = newAlternativeVersionId;
    }
    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {
        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;
    }
    getValue(eol, preserveBOM = false) {
        this._assertNotDisposed();
        if (this.isTooLargeForHeapOperation()) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__.BugIndicatingError('Operation would exceed heap memory limits');
        }
        const fullModelRange = this.getFullModelRange();
        const fullModelValue = this.getValueInRange(fullModelRange, eol);
        if (preserveBOM) {
            return this._buffer.getBOM() + fullModelValue;
        }
        return fullModelValue;
    }
    createSnapshot(preserveBOM = false) {
        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));
    }
    getValueLength(eol, preserveBOM = false) {
        this._assertNotDisposed();
        const fullModelRange = this.getFullModelRange();
        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);
        if (preserveBOM) {
            return this._buffer.getBOM().length + fullModelValue;
        }
        return fullModelValue;
    }
    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {
        this._assertNotDisposed();
        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);
    }
    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {
        this._assertNotDisposed();
        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);
    }
    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {
        this._assertNotDisposed();
        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);
    }
    getLineCount() {
        this._assertNotDisposed();
        return this._buffer.getLineCount();
    }
    getLineContent(lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__.BugIndicatingError('Illegal value for lineNumber');
        }
        return this._buffer.getLineContent(lineNumber);
    }
    getLineLength(lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__.BugIndicatingError('Illegal value for lineNumber');
        }
        return this._buffer.getLineLength(lineNumber);
    }
    getLinesContent() {
        this._assertNotDisposed();
        if (this.isTooLargeForHeapOperation()) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__.BugIndicatingError('Operation would exceed heap memory limits');
        }
        return this._buffer.getLinesContent();
    }
    getEOL() {
        this._assertNotDisposed();
        return this._buffer.getEOL();
    }
    getEndOfLineSequence() {
        this._assertNotDisposed();
        return (this._buffer.getEOL() === '\n'
            ? 0 /* model.EndOfLineSequence.LF */
            : 1 /* model.EndOfLineSequence.CRLF */);
    }
    getLineMinColumn(lineNumber) {
        this._assertNotDisposed();
        return 1;
    }
    getLineMaxColumn(lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__.BugIndicatingError('Illegal value for lineNumber');
        }
        return this._buffer.getLineLength(lineNumber) + 1;
    }
    getLineFirstNonWhitespaceColumn(lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__.BugIndicatingError('Illegal value for lineNumber');
        }
        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);
    }
    getLineLastNonWhitespaceColumn(lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__.BugIndicatingError('Illegal value for lineNumber');
        }
        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);
    }
    /**
     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
     * Will try to not allocate if possible.
     */
    _validateRangeRelaxedNoAllocations(range) {
        const linesCount = this._buffer.getLineCount();
        const initialStartLineNumber = range.startLineNumber;
        const initialStartColumn = range.startColumn;
        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);
        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);
        if (startLineNumber < 1) {
            startLineNumber = 1;
            startColumn = 1;
        }
        else if (startLineNumber > linesCount) {
            startLineNumber = linesCount;
            startColumn = this.getLineMaxColumn(startLineNumber);
        }
        else {
            if (startColumn <= 1) {
                startColumn = 1;
            }
            else {
                const maxColumn = this.getLineMaxColumn(startLineNumber);
                if (startColumn >= maxColumn) {
                    startColumn = maxColumn;
                }
            }
        }
        const initialEndLineNumber = range.endLineNumber;
        const initialEndColumn = range.endColumn;
        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);
        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);
        if (endLineNumber < 1) {
            endLineNumber = 1;
            endColumn = 1;
        }
        else if (endLineNumber > linesCount) {
            endLineNumber = linesCount;
            endColumn = this.getLineMaxColumn(endLineNumber);
        }
        else {
            if (endColumn <= 1) {
                endColumn = 1;
            }
            else {
                const maxColumn = this.getLineMaxColumn(endLineNumber);
                if (endColumn >= maxColumn) {
                    endColumn = maxColumn;
                }
            }
        }
        if (initialStartLineNumber === startLineNumber
            && initialStartColumn === startColumn
            && initialEndLineNumber === endLineNumber
            && initialEndColumn === endColumn
            && range instanceof _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range
            && !(range instanceof _core_selection_js__WEBPACK_IMPORTED_MODULE_11__.Selection)) {
            return range;
        }
        return new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    _isValidPosition(lineNumber, column, validationType) {
        if (typeof lineNumber !== 'number' || typeof column !== 'number') {
            return false;
        }
        if (isNaN(lineNumber) || isNaN(column)) {
            return false;
        }
        if (lineNumber < 1 || column < 1) {
            return false;
        }
        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {
            return false;
        }
        const lineCount = this._buffer.getLineCount();
        if (lineNumber > lineCount) {
            return false;
        }
        if (column === 1) {
            return true;
        }
        const maxColumn = this.getLineMaxColumn(lineNumber);
        if (column > maxColumn) {
            return false;
        }
        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {
            // !!At this point, column > 1
            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
            if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_5__.isHighSurrogate(charCodeBefore)) {
                return false;
            }
        }
        return true;
    }
    _validatePosition(_lineNumber, _column, validationType) {
        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);
        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);
        const lineCount = this._buffer.getLineCount();
        if (lineNumber < 1) {
            return new _core_position_js__WEBPACK_IMPORTED_MODULE_9__.Position(1, 1);
        }
        if (lineNumber > lineCount) {
            return new _core_position_js__WEBPACK_IMPORTED_MODULE_9__.Position(lineCount, this.getLineMaxColumn(lineCount));
        }
        if (column <= 1) {
            return new _core_position_js__WEBPACK_IMPORTED_MODULE_9__.Position(lineNumber, 1);
        }
        const maxColumn = this.getLineMaxColumn(lineNumber);
        if (column >= maxColumn) {
            return new _core_position_js__WEBPACK_IMPORTED_MODULE_9__.Position(lineNumber, maxColumn);
        }
        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {
            // If the position would end up in the middle of a high-low surrogate pair,
            // we move it to before the pair
            // !!At this point, column > 1
            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
            if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_5__.isHighSurrogate(charCodeBefore)) {
                return new _core_position_js__WEBPACK_IMPORTED_MODULE_9__.Position(lineNumber, column - 1);
            }
        }
        return new _core_position_js__WEBPACK_IMPORTED_MODULE_9__.Position(lineNumber, column);
    }
    validatePosition(position) {
        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;
        this._assertNotDisposed();
        // Avoid object allocation and cover most likely case
        if (position instanceof _core_position_js__WEBPACK_IMPORTED_MODULE_9__.Position) {
            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {
                return position;
            }
        }
        return this._validatePosition(position.lineNumber, position.column, validationType);
    }
    _isValidRange(range, validationType) {
        const startLineNumber = range.startLineNumber;
        const startColumn = range.startColumn;
        const endLineNumber = range.endLineNumber;
        const endColumn = range.endColumn;
        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {
            return false;
        }
        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {
            return false;
        }
        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {
            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);
            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);
            const startInsideSurrogatePair = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_5__.isHighSurrogate(charCodeBeforeStart);
            const endInsideSurrogatePair = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_5__.isHighSurrogate(charCodeBeforeEnd);
            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
                return true;
            }
            return false;
        }
        return true;
    }
    validateRange(_range) {
        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;
        this._assertNotDisposed();
        // Avoid object allocation and cover most likely case
        if ((_range instanceof _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range) && !(_range instanceof _core_selection_js__WEBPACK_IMPORTED_MODULE_11__.Selection)) {
            if (this._isValidRange(_range, validationType)) {
                return _range;
            }
        }
        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);
        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);
        const startLineNumber = start.lineNumber;
        const startColumn = start.column;
        const endLineNumber = end.lineNumber;
        const endColumn = end.column;
        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {
            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);
            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);
            const startInsideSurrogatePair = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_5__.isHighSurrogate(charCodeBeforeStart);
            const endInsideSurrogatePair = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_5__.isHighSurrogate(charCodeBeforeEnd);
            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
                return new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(startLineNumber, startColumn, endLineNumber, endColumn);
            }
            if (startLineNumber === endLineNumber && startColumn === endColumn) {
                // do not expand a collapsed range, simply move it to a valid location
                return new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);
            }
            if (startInsideSurrogatePair && endInsideSurrogatePair) {
                // expand range at both ends
                return new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);
            }
            if (startInsideSurrogatePair) {
                // only expand range at the start
                return new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);
            }
            // only expand range at the end
            return new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);
        }
        return new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    modifyPosition(rawPosition, offset) {
        this._assertNotDisposed();
        const candidate = this.getOffsetAt(rawPosition) + offset;
        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));
    }
    getFullModelRange() {
        this._assertNotDisposed();
        const lineCount = this.getLineCount();
        return new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));
    }
    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
    }
    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {
        this._assertNotDisposed();
        let searchRanges = null;
        if (rawSearchScope !== null) {
            if (!Array.isArray(rawSearchScope)) {
                rawSearchScope = [rawSearchScope];
            }
            if (rawSearchScope.every((searchScope) => _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range.isIRange(searchScope))) {
                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));
            }
        }
        if (searchRanges === null) {
            searchRanges = [this.getFullModelRange()];
        }
        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);
        const uniqueSearchRanges = [];
        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {
            if (_core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range.areIntersecting(prev, curr)) {
                return prev.plusRange(curr);
            }
            uniqueSearchRanges.push(prev);
            return curr;
        }));
        let matchMapper;
        if (!isRegex && searchString.indexOf('\n') < 0) {
            // not regex, not multi line
            const searchParams = new _textModelSearch_js__WEBPACK_IMPORTED_MODULE_24__.SearchParams(searchString, isRegex, matchCase, wordSeparators);
            const searchData = searchParams.parseSearchRequest();
            if (!searchData) {
                return [];
            }
            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
        }
        else {
            matchMapper = (searchRange) => _textModelSearch_js__WEBPACK_IMPORTED_MODULE_24__.TextModelSearch.findMatches(this, new _textModelSearch_js__WEBPACK_IMPORTED_MODULE_24__.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);
        }
        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);
    }
    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {
        this._assertNotDisposed();
        const searchStart = this.validatePosition(rawSearchStart);
        if (!isRegex && searchString.indexOf('\n') < 0) {
            const searchParams = new _textModelSearch_js__WEBPACK_IMPORTED_MODULE_24__.SearchParams(searchString, isRegex, matchCase, wordSeparators);
            const searchData = searchParams.parseSearchRequest();
            if (!searchData) {
                return null;
            }
            const lineCount = this.getLineCount();
            let searchRange = new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));
            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
            _textModelSearch_js__WEBPACK_IMPORTED_MODULE_24__.TextModelSearch.findNextMatch(this, new _textModelSearch_js__WEBPACK_IMPORTED_MODULE_24__.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
            if (ret.length > 0) {
                return ret[0];
            }
            searchRange = new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));
            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
            if (ret.length > 0) {
                return ret[0];
            }
            return null;
        }
        return _textModelSearch_js__WEBPACK_IMPORTED_MODULE_24__.TextModelSearch.findNextMatch(this, new _textModelSearch_js__WEBPACK_IMPORTED_MODULE_24__.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
    }
    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {
        this._assertNotDisposed();
        const searchStart = this.validatePosition(rawSearchStart);
        return _textModelSearch_js__WEBPACK_IMPORTED_MODULE_24__.TextModelSearch.findPreviousMatch(this, new _textModelSearch_js__WEBPACK_IMPORTED_MODULE_24__.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
    }
    //#endregion
    //#region Editing
    pushStackElement() {
        this._commandManager.pushStackElement();
    }
    popStackElement() {
        this._commandManager.popStackElement();
    }
    pushEOL(eol) {
        const currentEOL = (this.getEOL() === '\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);
        if (currentEOL === eol) {
            return;
        }
        try {
            this._onDidChangeDecorations.beginDeferredEmit();
            this._eventEmitter.beginDeferredEmit();
            if (this._initialUndoRedoSnapshot === null) {
                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);
            }
            this._commandManager.pushEOL(eol);
        }
        finally {
            this._eventEmitter.endDeferredEmit();
            this._onDidChangeDecorations.endDeferredEmit();
        }
    }
    _validateEditOperation(rawOperation) {
        if (rawOperation instanceof _model_js__WEBPACK_IMPORTED_MODULE_15__.ValidAnnotatedEditOperation) {
            return rawOperation;
        }
        return new _model_js__WEBPACK_IMPORTED_MODULE_15__.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);
    }
    _validateEditOperations(rawOperations) {
        const result = [];
        for (let i = 0, len = rawOperations.length; i < len; i++) {
            result[i] = this._validateEditOperation(rawOperations[i]);
        }
        return result;
    }
    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {
        try {
            this._onDidChangeDecorations.beginDeferredEmit();
            this._eventEmitter.beginDeferredEmit();
            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);
        }
        finally {
            this._eventEmitter.endDeferredEmit();
            this._onDidChangeDecorations.endDeferredEmit();
        }
    }
    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {
        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
            // Go through each saved line number and insert a trim whitespace edit
            // if it is safe to do so (no conflicts with other edits).
            const incomingEdits = editOperations.map((op) => {
                return {
                    range: this.validateRange(op.range),
                    text: op.text
                };
            });
            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor
            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace
            let editsAreNearCursors = true;
            if (beforeCursorState) {
                for (let i = 0, len = beforeCursorState.length; i < len; i++) {
                    const sel = beforeCursorState[i];
                    let foundEditNearSel = false;
                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                        const editRange = incomingEdits[j].range;
                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;
                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;
                        if (!selIsAbove && !selIsBelow) {
                            foundEditNearSel = true;
                            break;
                        }
                    }
                    if (!foundEditNearSel) {
                        editsAreNearCursors = false;
                        break;
                    }
                }
            }
            if (editsAreNearCursors) {
                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {
                    const trimLineNumber = this._trimAutoWhitespaceLines[i];
                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);
                    let allowTrimLine = true;
                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                        const editRange = incomingEdits[j].range;
                        const editText = incomingEdits[j].text;
                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {
                            // `trimLine` is completely outside this edit
                            continue;
                        }
                        // At this point:
                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber
                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn
                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\n') {
                            // This edit inserts a new line (and maybe other text) after `trimLine`
                            continue;
                        }
                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1
                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\n') {
                            // This edit inserts a new line (and maybe other text) before `trimLine`
                            continue;
                        }
                        // Looks like we can't trim this line as it would interfere with an incoming edit
                        allowTrimLine = false;
                        break;
                    }
                    if (allowTrimLine) {
                        const trimRange = new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);
                        editOperations.push(new _model_js__WEBPACK_IMPORTED_MODULE_15__.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));
                    }
                }
            }
            this._trimAutoWhitespaceLines = null;
        }
        if (this._initialUndoRedoSnapshot === null) {
            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);
        }
        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);
    }
    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {
        const edits = changes.map((change) => {
            const rangeStart = this.getPositionAt(change.newPosition);
            const rangeEnd = this.getPositionAt(change.newEnd);
            return {
                range: new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),
                text: change.oldText
            };
        });
        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);
    }
    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {
        const edits = changes.map((change) => {
            const rangeStart = this.getPositionAt(change.oldPosition);
            const rangeEnd = this.getPositionAt(change.oldEnd);
            return {
                range: new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),
                text: change.newText
            };
        });
        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);
    }
    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {
        try {
            this._onDidChangeDecorations.beginDeferredEmit();
            this._eventEmitter.beginDeferredEmit();
            this._isUndoing = isUndoing;
            this._isRedoing = isRedoing;
            this.applyEdits(edits, false);
            this.setEOL(eol);
            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);
        }
        finally {
            this._isUndoing = false;
            this._isRedoing = false;
            this._eventEmitter.endDeferredEmit(resultingSelection);
            this._onDidChangeDecorations.endDeferredEmit();
        }
    }
    applyEdits(rawOperations, computeUndoEdits = false) {
        try {
            this._onDidChangeDecorations.beginDeferredEmit();
            this._eventEmitter.beginDeferredEmit();
            const operations = this._validateEditOperations(rawOperations);
            return this._doApplyEdits(operations, computeUndoEdits);
        }
        finally {
            this._eventEmitter.endDeferredEmit();
            this._onDidChangeDecorations.endDeferredEmit();
        }
    }
    _doApplyEdits(rawOperations, computeUndoEdits) {
        const oldLineCount = this._buffer.getLineCount();
        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);
        const newLineCount = this._buffer.getLineCount();
        const contentChanges = result.changes;
        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;
        if (contentChanges.length !== 0) {
            // We do a first pass to update decorations
            // because we want to read decorations in the second pass
            // where we will emit content change events
            // and we want to read the final decorations
            for (let i = 0, len = contentChanges.length; i < len; i++) {
                const change = contentChanges[i];
                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);
            }
            const rawContentChanges = [];
            this._increaseVersionId();
            let lineCount = oldLineCount;
            for (let i = 0, len = contentChanges.length; i < len; i++) {
                const change = contentChanges[i];
                const [eolCount] = (0,_core_eolCounter_js__WEBPACK_IMPORTED_MODULE_7__.countEOL)(change.text);
                this._onDidChangeDecorations.fire();
                const startLineNumber = change.range.startLineNumber;
                const endLineNumber = change.range.endLineNumber;
                const deletingLinesCnt = endLineNumber - startLineNumber;
                const insertingLinesCnt = eolCount;
                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);
                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;
                const firstEditLineNumber = currentEditStartLineNumber;
                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;
                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new _core_position_js__WEBPACK_IMPORTED_MODULE_9__.Position(firstEditLineNumber, 1)), this.getOffsetAt(new _core_position_js__WEBPACK_IMPORTED_MODULE_9__.Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);
                const injectedTextInEditedRange = _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);
                const injectedTextInEditedRangeQueue = new _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.ArrayQueue(injectedTextInEditedRange);
                for (let j = editingLinesCnt; j >= 0; j--) {
                    const editLineNumber = startLineNumber + j;
                    const currentEditLineNumber = currentEditStartLineNumber + j;
                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);
                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);
                    rawContentChanges.push(new _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));
                }
                if (editingLinesCnt < deletingLinesCnt) {
                    // Must delete some lines
                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;
                    rawContentChanges.push(new _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));
                }
                if (editingLinesCnt < insertingLinesCnt) {
                    const injectedTextInEditedRangeQueue = new _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.ArrayQueue(injectedTextInEditedRange);
                    // Must insert some lines
                    const spliceLineNumber = startLineNumber + editingLinesCnt;
                    const cnt = insertingLinesCnt - editingLinesCnt;
                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;
                    const injectedTexts = [];
                    const newLines = [];
                    for (let i = 0; i < cnt; i++) {
                        const lineNumber = fromLineNumber + i;
                        newLines[i] = this.getLineContent(lineNumber);
                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);
                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);
                    }
                    rawContentChanges.push(new _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));
                }
                lineCount += changeLineCountDelta;
            }
            this._emitContentChangedEvent(new _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {
                changes: contentChanges,
                eol: this._buffer.getEOL(),
                isEolChange: false,
                versionId: this.getVersionId(),
                isUndoing: this._isUndoing,
                isRedoing: this._isRedoing,
                isFlush: false
            });
        }
        return (result.reverseEdits === null ? undefined : result.reverseEdits);
    }
    undo() {
        return this._undoRedoService.undo(this.uri);
    }
    canUndo() {
        return this._undoRedoService.canUndo(this.uri);
    }
    redo() {
        return this._undoRedoService.redo(this.uri);
    }
    canRedo() {
        return this._undoRedoService.canRedo(this.uri);
    }
    //#endregion
    //#region Decorations
    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {
        // This is called before the decoration changed event is fired.
        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {
            return;
        }
        const affectedLines = Array.from(affectedInjectedTextLines);
        const lineChangeEvents = affectedLines.map(lineNumber => new _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));
        this._onDidChangeInjectedText.fire(new _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.ModelInjectedTextChangedEvent(lineChangeEvents));
    }
    changeDecorations(callback, ownerId = 0) {
        this._assertNotDisposed();
        try {
            this._onDidChangeDecorations.beginDeferredEmit();
            return this._changeDecorations(ownerId, callback);
        }
        finally {
            this._onDidChangeDecorations.endDeferredEmit();
        }
    }
    _changeDecorations(ownerId, callback) {
        const changeAccessor = {
            addDecoration: (range, options) => {
                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];
            },
            changeDecoration: (id, newRange) => {
                this._changeDecorationImpl(id, newRange);
            },
            changeDecorationOptions: (id, options) => {
                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));
            },
            removeDecoration: (id) => {
                this._deltaDecorationsImpl(ownerId, [id], []);
            },
            deltaDecorations: (oldDecorations, newDecorations) => {
                if (oldDecorations.length === 0 && newDecorations.length === 0) {
                    // nothing to do
                    return [];
                }
                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
            }
        };
        let result = null;
        try {
            result = callback(changeAccessor);
        }
        catch (e) {
            (0,_base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__.onUnexpectedError)(e);
        }
        // Invalidate change accessor
        changeAccessor.addDecoration = invalidFunc;
        changeAccessor.changeDecoration = invalidFunc;
        changeAccessor.changeDecorationOptions = invalidFunc;
        changeAccessor.removeDecoration = invalidFunc;
        changeAccessor.deltaDecorations = invalidFunc;
        return result;
    }
    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {
        this._assertNotDisposed();
        if (!oldDecorations) {
            oldDecorations = [];
        }
        if (oldDecorations.length === 0 && newDecorations.length === 0) {
            // nothing to do
            return [];
        }
        try {
            this._deltaDecorationCallCnt++;
            if (this._deltaDecorationCallCnt > 1) {
                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);
                (0,_base_common_errors_js__WEBPACK_IMPORTED_MODULE_2__.onUnexpectedError)(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));
            }
            this._onDidChangeDecorations.beginDeferredEmit();
            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
        }
        finally {
            this._onDidChangeDecorations.endDeferredEmit();
            this._deltaDecorationCallCnt--;
        }
    }
    _getTrackedRange(id) {
        return this.getDecorationRange(id);
    }
    _setTrackedRange(id, newRange, newStickiness) {
        const node = (id ? this._decorations[id] : null);
        if (!node) {
            if (!newRange) {
                // node doesn't exist, the request is to delete => nothing to do
                return null;
            }
            // node doesn't exist, the request is to set => add the tracked range
            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];
        }
        if (!newRange) {
            // node exists, the request is to delete => delete node
            this._decorationsTree.delete(node);
            delete this._decorations[node.id];
            return null;
        }
        // node exists, the request is to set => change the tracked range and its options
        const range = this._validateRangeRelaxedNoAllocations(newRange);
        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);
        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
        this._decorationsTree.delete(node);
        node.reset(this.getVersionId(), startOffset, endOffset, range);
        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);
        this._decorationsTree.insert(node);
        return node.id;
    }
    removeAllDecorationsWithOwnerId(ownerId) {
        if (this._isDisposed) {
            return;
        }
        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);
        for (let i = 0, len = nodes.length; i < len; i++) {
            const node = nodes[i];
            this._decorationsTree.delete(node);
            delete this._decorations[node.id];
        }
    }
    getDecorationOptions(decorationId) {
        const node = this._decorations[decorationId];
        if (!node) {
            return null;
        }
        return node.options;
    }
    getDecorationRange(decorationId) {
        const node = this._decorations[decorationId];
        if (!node) {
            return null;
        }
        return this._decorationsTree.getNodeRange(this, node);
    }
    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            return [];
        }
        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);
    }
    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {
        const lineCount = this.getLineCount();
        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));
        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));
        const endColumn = this.getLineMaxColumn(endLineNumber);
        const range = new _core_range_js__WEBPACK_IMPORTED_MODULE_10__.Range(startLineNumber, 1, endLineNumber, endColumn);
        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);
        (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.pushMany)(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));
        return decorations;
    }
    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {
        const validatedRange = this.validateRange(range);
        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);
        (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.pushMany)(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));
        return decorations;
    }
    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {
        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);
    }
    getInjectedTextDecorations(ownerId = 0) {
        return this._decorationsTree.getAllInjectedText(this, ownerId);
    }
    _getInjectedTextInLine(lineNumber) {
        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);
        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);
        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);
        return _textModelEvents_js__WEBPACK_IMPORTED_MODULE_27__.LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);
    }
    getAllDecorations(ownerId = 0, filterOutValidation = false) {
        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);
        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));
        return result;
    }
    getAllMarginDecorations(ownerId = 0) {
        return this._decorationsTree.getAll(this, ownerId, false, false, true);
    }
    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {
        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);
        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);
        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);
    }
    getRangeAt(start, end) {
        return this._buffer.getRangeAt(start, end - start);
    }
    _changeDecorationImpl(decorationId, _range) {
        const node = this._decorations[decorationId];
        if (!node) {
            return;
        }
        if (node.options.after) {
            const oldRange = this.getDecorationRange(decorationId);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);
        }
        if (node.options.before) {
            const oldRange = this.getDecorationRange(decorationId);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);
        }
        const range = this._validateRangeRelaxedNoAllocations(_range);
        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);
        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
        this._decorationsTree.delete(node);
        node.reset(this.getVersionId(), startOffset, endOffset, range);
        this._decorationsTree.insert(node);
        this._onDidChangeDecorations.checkAffectedAndFire(node.options);
        if (node.options.after) {
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);
        }
        if (node.options.before) {
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);
        }
    }
    _changeDecorationOptionsImpl(decorationId, options) {
        const node = this._decorations[decorationId];
        if (!node) {
            return;
        }
        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);
        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);
        this._onDidChangeDecorations.checkAffectedAndFire(node.options);
        this._onDidChangeDecorations.checkAffectedAndFire(options);
        if (node.options.after || options.after) {
            const nodeRange = this._decorationsTree.getNodeRange(this, node);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);
        }
        if (node.options.before || options.before) {
            const nodeRange = this._decorationsTree.getNodeRange(this, node);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);
        }
        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;
        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);
        if (movedInOverviewRuler || changedWhetherInjectedText) {
            this._decorationsTree.delete(node);
            node.setOptions(options);
            this._decorationsTree.insert(node);
        }
        else {
            node.setOptions(options);
        }
    }
    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {
        const versionId = this.getVersionId();
        const oldDecorationsLen = oldDecorationsIds.length;
        let oldDecorationIndex = 0;
        const newDecorationsLen = newDecorations.length;
        let newDecorationIndex = 0;
        this._onDidChangeDecorations.beginDeferredEmit();
        try {
            const result = new Array(newDecorationsLen);
            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {
                let node = null;
                if (oldDecorationIndex < oldDecorationsLen) {
                    // (1) get ourselves an old node
                    do {
                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];
                    } while (!node && oldDecorationIndex < oldDecorationsLen);
                    // (2) remove the node from the tree (if it exists)
                    if (node) {
                        if (node.options.after) {
                            const nodeRange = this._decorationsTree.getNodeRange(this, node);
                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);
                        }
                        if (node.options.before) {
                            const nodeRange = this._decorationsTree.getNodeRange(this, node);
                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);
                        }
                        this._decorationsTree.delete(node);
                        if (!suppressEvents) {
                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);
                        }
                    }
                }
                if (newDecorationIndex < newDecorationsLen) {
                    // (3) create a new node if necessary
                    if (!node) {
                        const internalDecorationId = (++this._lastDecorationId);
                        const decorationId = `${this._instanceId};${internalDecorationId}`;
                        node = new _intervalTree_js__WEBPACK_IMPORTED_MODULE_21__.IntervalNode(decorationId, 0, 0);
                        this._decorations[decorationId] = node;
                    }
                    // (4) initialize node
                    const newDecoration = newDecorations[newDecorationIndex];
                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);
                    const options = _normalizeOptions(newDecoration.options);
                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);
                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
                    node.ownerId = ownerId;
                    node.reset(versionId, startOffset, endOffset, range);
                    node.setOptions(options);
                    if (node.options.after) {
                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);
                    }
                    if (node.options.before) {
                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);
                    }
                    if (!suppressEvents) {
                        this._onDidChangeDecorations.checkAffectedAndFire(options);
                    }
                    this._decorationsTree.insert(node);
                    result[newDecorationIndex] = node.id;
                    newDecorationIndex++;
                }
                else {
                    if (node) {
                        delete this._decorations[node.id];
                    }
                }
            }
            return result;
        }
        finally {
            this._onDidChangeDecorations.endDeferredEmit();
        }
    }
    //#endregion
    //#region Tokenization
    // TODO move them to the tokenization part.
    getLanguageId() {
        return this.tokenization.getLanguageId();
    }
    setLanguage(languageIdOrSelection, source) {
        if (typeof languageIdOrSelection === 'string') {
            this._languageSelectionListener.clear();
            this._setLanguage(languageIdOrSelection, source);
        }
        else {
            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));
            this._setLanguage(languageIdOrSelection.languageId, source);
        }
    }
    _setLanguage(languageId, source) {
        this.tokenization.setLanguageId(languageId, source);
        this._languageService.requestRichLanguageFeatures(languageId);
    }
    getLanguageIdAtPosition(lineNumber, column) {
        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);
    }
    getWordAtPosition(position) {
        return this._tokenizationTextModelPart.getWordAtPosition(position);
    }
    getWordUntilPosition(position) {
        return this._tokenizationTextModelPart.getWordUntilPosition(position);
    }
    //#endregion
    normalizePosition(position, affinity) {
        return position;
    }
    /**
     * Gets the column at which indentation stops at a given line.
     * @internal
    */
    getLineIndentColumn(lineNumber) {
        // Columns start with 1.
        return indentOfLine(this.getLineContent(lineNumber)) + 1;
    }
};
TextModel = TextModel_1 = __decorate([
    __param(4, _platform_undoRedo_common_undoRedo_js__WEBPACK_IMPORTED_MODULE_29__.IUndoRedoService),
    __param(5, _languages_language_js__WEBPACK_IMPORTED_MODULE_13__.ILanguageService),
    __param(6, _languages_languageConfigurationRegistry_js__WEBPACK_IMPORTED_MODULE_14__.ILanguageConfigurationService),
    __param(7, _platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_28__.IInstantiationService)
], TextModel);

function indentOfLine(line) {
    let indent = 0;
    for (const c of line) {
        if (c === ' ' || c === '\t') {
            indent++;
        }
        else {
            break;
        }
    }
    return indent;
}
//#region Decorations
function isNodeInOverviewRuler(node) {
    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);
}
function isOptionsInjectedText(options) {
    return !!options.after || !!options.before;
}
function isNodeInjectedText(node) {
    return !!node.options.after || !!node.options.before;
}
class DecorationsTrees {
    constructor() {
        this._decorationsTree0 = new _intervalTree_js__WEBPACK_IMPORTED_MODULE_21__.IntervalTree();
        this._decorationsTree1 = new _intervalTree_js__WEBPACK_IMPORTED_MODULE_21__.IntervalTree();
        this._injectedTextDecorationsTree = new _intervalTree_js__WEBPACK_IMPORTED_MODULE_21__.IntervalTree();
    }
    ensureAllNodesHaveRanges(host) {
        this.getAll(host, 0, false, false, false);
    }
    _ensureNodesHaveRanges(host, nodes) {
        for (const node of nodes) {
            if (node.range === null) {
                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
            }
        }
        return nodes;
    }
    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {
        const versionId = host.getVersionId();
        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);
        return this._ensureNodesHaveRanges(host, result);
    }
    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
        return r0.concat(r1).concat(r2);
    }
    getInjectedTextInInterval(host, start, end, filterOwnerId) {
        const versionId = host.getVersionId();
        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);
        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());
    }
    getAllInjectedText(host, filterOwnerId) {
        const versionId = host.getVersionId();
        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);
        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());
    }
    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {
        const versionId = host.getVersionId();
        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);
        return this._ensureNodesHaveRanges(host, result);
    }
    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {
        if (overviewRulerOnly) {
            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
        }
        else {
            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
            return r0.concat(r1).concat(r2);
        }
    }
    collectNodesFromOwner(ownerId) {
        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);
        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);
        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);
        return r0.concat(r1).concat(r2);
    }
    collectNodesPostOrder() {
        const r0 = this._decorationsTree0.collectNodesPostOrder();
        const r1 = this._decorationsTree1.collectNodesPostOrder();
        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();
        return r0.concat(r1).concat(r2);
    }
    insert(node) {
        if (isNodeInjectedText(node)) {
            this._injectedTextDecorationsTree.insert(node);
        }
        else if (isNodeInOverviewRuler(node)) {
            this._decorationsTree1.insert(node);
        }
        else {
            this._decorationsTree0.insert(node);
        }
    }
    delete(node) {
        if (isNodeInjectedText(node)) {
            this._injectedTextDecorationsTree.delete(node);
        }
        else if (isNodeInOverviewRuler(node)) {
            this._decorationsTree1.delete(node);
        }
        else {
            this._decorationsTree0.delete(node);
        }
    }
    getNodeRange(host, node) {
        const versionId = host.getVersionId();
        if (node.cachedVersionId !== versionId) {
            this._resolveNode(node, versionId);
        }
        if (node.range === null) {
            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
        }
        return node.range;
    }
    _resolveNode(node, cachedVersionId) {
        if (isNodeInjectedText(node)) {
            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);
        }
        else if (isNodeInOverviewRuler(node)) {
            this._decorationsTree1.resolveNode(node, cachedVersionId);
        }
        else {
            this._decorationsTree0.resolveNode(node, cachedVersionId);
        }
    }
    acceptReplace(offset, length, textLength, forceMoveMarkers) {
        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);
        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);
        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);
    }
}
function cleanClassName(className) {
    return className.replace(/[^a-z0-9\-_]/gi, ' ');
}
class DecorationOptions {
    constructor(options) {
        this.color = options.color || '';
        this.darkColor = options.darkColor || '';
    }
}
class ModelDecorationOverviewRulerOptions extends DecorationOptions {
    constructor(options) {
        super(options);
        this._resolvedColor = null;
        this.position = (typeof options.position === 'number' ? options.position : _model_js__WEBPACK_IMPORTED_MODULE_15__.OverviewRulerLane.Center);
    }
    getColor(theme) {
        if (!this._resolvedColor) {
            if (theme.type !== 'light' && this.darkColor) {
                this._resolvedColor = this._resolveColor(this.darkColor, theme);
            }
            else {
                this._resolvedColor = this._resolveColor(this.color, theme);
            }
        }
        return this._resolvedColor;
    }
    invalidateCachedColor() {
        this._resolvedColor = null;
    }
    _resolveColor(color, theme) {
        if (typeof color === 'string') {
            return color;
        }
        const c = color ? theme.getColor(color.id) : null;
        if (!c) {
            return '';
        }
        return c.toString();
    }
}
class ModelDecorationGlyphMarginOptions {
    constructor(options) {
        this.position = options?.position ?? _model_js__WEBPACK_IMPORTED_MODULE_15__.GlyphMarginLane.Center;
        this.persistLane = options?.persistLane;
    }
}
class ModelDecorationMinimapOptions extends DecorationOptions {
    constructor(options) {
        super(options);
        this.position = options.position;
        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;
        this.sectionHeaderText = options.sectionHeaderText ?? null;
    }
    getColor(theme) {
        if (!this._resolvedColor) {
            if (theme.type !== 'light' && this.darkColor) {
                this._resolvedColor = this._resolveColor(this.darkColor, theme);
            }
            else {
                this._resolvedColor = this._resolveColor(this.color, theme);
            }
        }
        return this._resolvedColor;
    }
    invalidateCachedColor() {
        this._resolvedColor = undefined;
    }
    _resolveColor(color, theme) {
        if (typeof color === 'string') {
            return _base_common_color_js__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(color);
        }
        return theme.getColor(color.id);
    }
}
class ModelDecorationInjectedTextOptions {
    static from(options) {
        if (options instanceof ModelDecorationInjectedTextOptions) {
            return options;
        }
        return new ModelDecorationInjectedTextOptions(options);
    }
    constructor(options) {
        this.content = options.content || '';
        this.inlineClassName = options.inlineClassName || null;
        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;
        this.attachedData = options.attachedData || null;
        this.cursorStops = options.cursorStops || null;
    }
}
class ModelDecorationOptions {
    static register(options) {
        return new ModelDecorationOptions(options);
    }
    static createDynamic(options) {
        return new ModelDecorationOptions(options);
    }
    constructor(options) {
        this.description = options.description;
        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;
        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;
        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;
        this.blockPadding = options.blockPadding ?? null;
        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;
        this.zIndex = options.zIndex || 0;
        this.className = options.className ? cleanClassName(options.className) : null;
        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;
        this.hoverMessage = options.hoverMessage || null;
        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;
        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;
        this.isWholeLine = options.isWholeLine || false;
        this.showIfCollapsed = options.showIfCollapsed || false;
        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;
        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;
        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;
        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;
        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;
        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;
        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;
        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? _base_common_strings_js__WEBPACK_IMPORTED_MODULE_5__.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;
        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;
        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;
        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;
        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;
        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;
        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;
        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;
        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;
        this.hideInCommentTokens = options.hideInCommentTokens ?? false;
        this.hideInStringTokens = options.hideInStringTokens ?? false;
    }
}
ModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });
/**
 * The order carefully matches the values of the enum.
 */
const TRACKED_RANGE_OPTIONS = [
    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),
    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),
    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),
    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),
];
function _normalizeOptions(options) {
    if (options instanceof ModelDecorationOptions) {
        return options;
    }
    return ModelDecorationOptions.createDynamic(options);
}
class DidChangeDecorationsEmitter extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_4__.Disposable {
    constructor(handleBeforeFire) {
        super();
        this.handleBeforeFire = handleBeforeFire;
        this._actual = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_3__.Emitter());
        this.event = this._actual.event;
        this._affectedInjectedTextLines = null;
        this._deferredCnt = 0;
        this._shouldFireDeferred = false;
        this._affectsMinimap = false;
        this._affectsOverviewRuler = false;
        this._affectsGlyphMargin = false;
        this._affectsLineNumber = false;
    }
    beginDeferredEmit() {
        this._deferredCnt++;
    }
    endDeferredEmit() {
        this._deferredCnt--;
        if (this._deferredCnt === 0) {
            if (this._shouldFireDeferred) {
                this.doFire();
            }
            this._affectedInjectedTextLines?.clear();
            this._affectedInjectedTextLines = null;
        }
    }
    recordLineAffectedByInjectedText(lineNumber) {
        if (!this._affectedInjectedTextLines) {
            this._affectedInjectedTextLines = new Set();
        }
        this._affectedInjectedTextLines.add(lineNumber);
    }
    checkAffectedAndFire(options) {
        this._affectsMinimap ||= !!options.minimap?.position;
        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;
        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;
        this._affectsLineNumber ||= !!options.lineNumberClassName;
        this.tryFire();
    }
    fire() {
        this._affectsMinimap = true;
        this._affectsOverviewRuler = true;
        this._affectsGlyphMargin = true;
        this.tryFire();
    }
    tryFire() {
        if (this._deferredCnt === 0) {
            this.doFire();
        }
        else {
            this._shouldFireDeferred = true;
        }
    }
    doFire() {
        this.handleBeforeFire(this._affectedInjectedTextLines);
        const event = {
            affectsMinimap: this._affectsMinimap,
            affectsOverviewRuler: this._affectsOverviewRuler,
            affectsGlyphMargin: this._affectsGlyphMargin,
            affectsLineNumber: this._affectsLineNumber,
        };
        this._shouldFireDeferred = false;
        this._affectsMinimap = false;
        this._affectsOverviewRuler = false;
        this._affectsGlyphMargin = false;
        this._actual.fire(event);
    }
}
//#endregion
class DidChangeContentEmitter extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_4__.Disposable {
    constructor() {
        super();
        /**
         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.
         */
        this._fastEmitter = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_3__.Emitter());
        this.fastEvent = this._fastEmitter.event;
        this._slowEmitter = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_3__.Emitter());
        this.slowEvent = this._slowEmitter.event;
        this._deferredCnt = 0;
        this._deferredEvent = null;
    }
    beginDeferredEmit() {
        this._deferredCnt++;
    }
    endDeferredEmit(resultingSelection = null) {
        this._deferredCnt--;
        if (this._deferredCnt === 0) {
            if (this._deferredEvent !== null) {
                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;
                const e = this._deferredEvent;
                this._deferredEvent = null;
                this._fastEmitter.fire(e);
                this._slowEmitter.fire(e);
            }
        }
    }
    fire(e) {
        if (this._deferredCnt > 0) {
            if (this._deferredEvent) {
                this._deferredEvent = this._deferredEvent.merge(e);
            }
            else {
                this._deferredEvent = e;
            }
            return;
        }
        this._fastEmitter.fire(e);
        this._slowEmitter.fire(e);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js":
/*!********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextModelPart: () => (/* binding */ TextModelPart)
/* harmony export */ });
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class TextModelPart extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_0__.Disposable {
    constructor() {
        super(...arguments);
        this._isDisposed = false;
    }
    dispose() {
        super.dispose();
        this._isDisposed = true;
    }
    assertNotDisposed() {
        if (this._isDisposed) {
            throw new Error('TextModelPart is disposed!');
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultBackgroundTokenizer: () => (/* binding */ DefaultBackgroundTokenizer),
/* harmony export */   RangePriorityQueueImpl: () => (/* binding */ RangePriorityQueueImpl),
/* harmony export */   TokenizationStateStore: () => (/* binding */ TokenizationStateStore),
/* harmony export */   TokenizerWithStateStore: () => (/* binding */ TokenizerWithStateStore),
/* harmony export */   TokenizerWithStateStoreAndTextModel: () => (/* binding */ TokenizerWithStateStoreAndTextModel),
/* harmony export */   TrackingTokenizationStateStore: () => (/* binding */ TrackingTokenizationStateStore)
/* harmony export */ });
/* harmony import */ var _base_common_async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/async.js */ "./node_modules/monaco-editor/esm/vs/base/common/async.js");
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _base_common_platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _base_common_stopwatch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/stopwatch.js */ "./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js");
/* harmony import */ var _core_eolCounter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/eolCounter.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js");
/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/lineRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js");
/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/offsetRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js");
/* harmony import */ var _languages_nullTokenize_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../languages/nullTokenize.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js");
/* harmony import */ var _fixedArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fixedArray.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js");
/* harmony import */ var _tokens_contiguousMultilineTokensBuilder_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tokens/contiguousMultilineTokensBuilder.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js");
/* harmony import */ var _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tokens/lineTokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











class TokenizerWithStateStore {
    constructor(lineCount, tokenizationSupport) {
        this.tokenizationSupport = tokenizationSupport;
        this.initialState = this.tokenizationSupport.getInitialState();
        this.store = new TrackingTokenizationStateStore(lineCount);
    }
    getStartState(lineNumber) {
        return this.store.getStartState(lineNumber, this.initialState);
    }
    getFirstInvalidLine() {
        return this.store.getFirstInvalidLine(this.initialState);
    }
}
class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {
    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {
        super(lineCount, tokenizationSupport);
        this._textModel = _textModel;
        this._languageIdCodec = _languageIdCodec;
    }
    updateTokensUntilLine(builder, lineNumber) {
        const languageId = this._textModel.getLanguageId();
        while (true) {
            const lineToTokenize = this.getFirstInvalidLine();
            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {
                break;
            }
            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);
            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);
            builder.add(lineToTokenize.lineNumber, r.tokens);
            this.store.setEndState(lineToTokenize.lineNumber, r.endState);
        }
    }
    /** assumes state is up to date */
    getTokenTypeIfInsertingCharacter(position, character) {
        // TODO@hediet: use tokenizeLineWithEdit
        const lineStartState = this.getStartState(position.lineNumber);
        if (!lineStartState) {
            return 0 /* StandardTokenType.Other */;
        }
        const languageId = this._textModel.getLanguageId();
        const lineContent = this._textModel.getLineContent(position.lineNumber);
        // Create the text as if `character` was inserted
        const text = (lineContent.substring(0, position.column - 1)
            + character
            + lineContent.substring(position.column - 1));
        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);
        const lineTokens = new _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_10__.LineTokens(r.tokens, text, this._languageIdCodec);
        if (lineTokens.getCount() === 0) {
            return 0 /* StandardTokenType.Other */;
        }
        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        return lineTokens.getStandardTokenType(tokenIndex);
    }
    /** assumes state is up to date */
    tokenizeLineWithEdit(position, length, newText) {
        const lineNumber = position.lineNumber;
        const column = position.column;
        const lineStartState = this.getStartState(lineNumber);
        if (!lineStartState) {
            return null;
        }
        const curLineContent = this._textModel.getLineContent(lineNumber);
        const newLineContent = curLineContent.substring(0, column - 1)
            + newText + curLineContent.substring(column - 1 + length);
        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);
        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);
        const lineTokens = new _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_10__.LineTokens(result.tokens, newLineContent, this._languageIdCodec);
        return lineTokens;
    }
    hasAccurateTokensForLine(lineNumber) {
        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();
        return (lineNumber < firstInvalidLineNumber);
    }
    isCheapToTokenize(lineNumber) {
        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();
        if (lineNumber < firstInvalidLineNumber) {
            return true;
        }
        if (lineNumber === firstInvalidLineNumber
            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {
            return true;
        }
        return false;
    }
    /**
     * The result is not cached.
     */
    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {
        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {
            // nothing to do
            return { heuristicTokens: false };
        }
        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {
            // tokenization has reached the viewport start...
            this.updateTokensUntilLine(builder, endLineNumber);
            return { heuristicTokens: false };
        }
        let state = this.guessStartState(startLineNumber);
        const languageId = this._textModel.getLanguageId();
        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            const text = this._textModel.getLineContent(lineNumber);
            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);
            builder.add(lineNumber, r.tokens);
            state = r.endState;
        }
        return { heuristicTokens: true };
    }
    guessStartState(lineNumber) {
        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);
        const likelyRelevantLines = [];
        let initialState = null;
        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {
            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);
            // Ignore lines full of whitespace
            if (newNonWhitespaceIndex === 0) {
                continue;
            }
            if (newNonWhitespaceIndex < nonWhitespaceColumn) {
                likelyRelevantLines.push(this._textModel.getLineContent(i));
                nonWhitespaceColumn = newNonWhitespaceIndex;
                initialState = this.getStartState(i);
                if (initialState) {
                    break;
                }
            }
        }
        if (!initialState) {
            initialState = this.tokenizationSupport.getInitialState();
        }
        likelyRelevantLines.reverse();
        const languageId = this._textModel.getLanguageId();
        let state = initialState;
        for (const line of likelyRelevantLines) {
            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);
            state = r.endState;
        }
        return state;
    }
}
/**
 * **Invariant:**
 * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,
 * then the recomputed end state for line l will be equal to {@link getEndState}(l).
 */
class TrackingTokenizationStateStore {
    constructor(lineCount) {
        this.lineCount = lineCount;
        this._tokenizationStateStore = new TokenizationStateStore();
        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();
        this._invalidEndStatesLineNumbers.addRange(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(1, lineCount + 1));
    }
    getEndState(lineNumber) {
        return this._tokenizationStateStore.getEndState(lineNumber);
    }
    /**
     * @returns if the end state has changed.
     */
    setEndState(lineNumber, state) {
        if (!state) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError('Cannot set null/undefined state');
        }
        this._invalidEndStatesLineNumbers.delete(lineNumber);
        const r = this._tokenizationStateStore.setEndState(lineNumber, state);
        if (r && lineNumber < this.lineCount) {
            // because the state changed, we cannot trust the next state anymore and have to invalidate it.
            this._invalidEndStatesLineNumbers.addRange(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(lineNumber + 1, lineNumber + 2));
        }
        return r;
    }
    acceptChange(range, newLineCount) {
        this.lineCount += newLineCount - range.length;
        this._tokenizationStateStore.acceptChange(range, newLineCount);
        this._invalidEndStatesLineNumbers.addRangeAndResize(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);
    }
    acceptChanges(changes) {
        for (const c of changes) {
            const [eolCount] = (0,_core_eolCounter_js__WEBPACK_IMPORTED_MODULE_4__.countEOL)(c.text);
            this.acceptChange(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);
        }
    }
    invalidateEndStateRange(range) {
        this._invalidEndStatesLineNumbers.addRange(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(range.startLineNumber, range.endLineNumberExclusive));
    }
    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }
    getFirstInvalidEndStateLineNumberOrMax() {
        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;
    }
    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }
    getStartState(lineNumber, initialState) {
        if (lineNumber === 1) {
            return initialState;
        }
        return this.getEndState(lineNumber - 1);
    }
    getFirstInvalidLine(initialState) {
        const lineNumber = this.getFirstInvalidEndStateLineNumber();
        if (lineNumber === null) {
            return null;
        }
        const startState = this.getStartState(lineNumber, initialState);
        if (!startState) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError('Start state must be defined');
        }
        return { lineNumber, startState };
    }
}
class TokenizationStateStore {
    constructor() {
        this._lineEndStates = new _fixedArray_js__WEBPACK_IMPORTED_MODULE_8__.FixedArray(null);
    }
    getEndState(lineNumber) {
        return this._lineEndStates.get(lineNumber);
    }
    setEndState(lineNumber, state) {
        const oldState = this._lineEndStates.get(lineNumber);
        if (oldState && oldState.equals(state)) {
            return false;
        }
        this._lineEndStates.set(lineNumber, state);
        return true;
    }
    acceptChange(range, newLineCount) {
        let length = range.length;
        if (newLineCount > 0 && length > 0) {
            // Keep the last state, even though it is unrelated.
            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.
            length--;
            newLineCount--;
        }
        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);
    }
}
class RangePriorityQueueImpl {
    constructor() {
        this._ranges = [];
    }
    get min() {
        if (this._ranges.length === 0) {
            return null;
        }
        return this._ranges[0].start;
    }
    delete(value) {
        const idx = this._ranges.findIndex(r => r.contains(value));
        if (idx !== -1) {
            const range = this._ranges[idx];
            if (range.start === value) {
                if (range.endExclusive === value + 1) {
                    this._ranges.splice(idx, 1);
                }
                else {
                    this._ranges[idx] = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(value + 1, range.endExclusive);
                }
            }
            else {
                if (range.endExclusive === value + 1) {
                    this._ranges[idx] = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(range.start, value);
                }
                else {
                    this._ranges.splice(idx, 1, new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(range.start, value), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(value + 1, range.endExclusive));
                }
            }
        }
    }
    addRange(range) {
        _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange.addRange(range, this._ranges);
    }
    addRangeAndResize(range, newLength) {
        let idxFirstMightBeIntersecting = 0;
        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {
            idxFirstMightBeIntersecting++;
        }
        let idxFirstIsAfter = idxFirstMightBeIntersecting;
        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {
            idxFirstIsAfter++;
        }
        const delta = newLength - range.length;
        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {
            this._ranges[i] = this._ranges[i].delta(delta);
        }
        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {
            const newRange = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(range.start, range.start + newLength);
            if (!newRange.isEmpty) {
                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);
            }
        }
        else {
            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);
            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);
            const newRange = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(start, endEx + delta);
            if (!newRange.isEmpty) {
                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);
            }
            else {
                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);
            }
        }
    }
    toString() {
        return this._ranges.map(r => r.toString()).join(' + ');
    }
}
function safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {
    let r = null;
    if (tokenizationSupport) {
        try {
            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());
        }
        catch (e) {
            (0,_base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.onUnexpectedError)(e);
        }
    }
    if (!r) {
        r = (0,_languages_nullTokenize_js__WEBPACK_IMPORTED_MODULE_7__.nullTokenizeEncoded)(languageIdCodec.encodeLanguageId(languageId), state);
    }
    _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_10__.LineTokens.convertToEndOffset(r.tokens, text.length);
    return r;
}
class DefaultBackgroundTokenizer {
    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {
        this._tokenizerWithStateStore = _tokenizerWithStateStore;
        this._backgroundTokenStore = _backgroundTokenStore;
        this._isDisposed = false;
        this._isScheduled = false;
    }
    dispose() {
        this._isDisposed = true;
    }
    handleChanges() {
        this._beginBackgroundTokenization();
    }
    _beginBackgroundTokenization() {
        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {
            return;
        }
        this._isScheduled = true;
        (0,_base_common_async_js__WEBPACK_IMPORTED_MODULE_0__.runWhenGlobalIdle)((deadline) => {
            this._isScheduled = false;
            this._backgroundTokenizeWithDeadline(deadline);
        });
    }
    /**
     * Tokenize until the deadline occurs, but try to yield every 1-2ms.
     */
    _backgroundTokenizeWithDeadline(deadline) {
        // Read the time remaining from the `deadline` immediately because it is unclear
        // if the `deadline` object will be valid after execution leaves this function.
        const endTime = Date.now() + deadline.timeRemaining();
        const execute = () => {
            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {
                // disposed in the meantime or detached or finished
                return;
            }
            this._backgroundTokenizeForAtLeast1ms();
            if (Date.now() < endTime) {
                // There is still time before reaching the deadline, so yield to the browser and then
                // continue execution
                (0,_base_common_platform_js__WEBPACK_IMPORTED_MODULE_2__.setTimeout0)(execute);
            }
            else {
                // The deadline has been reached, so schedule a new idle callback if necessary
                this._beginBackgroundTokenization();
            }
        };
        execute();
    }
    /**
     * Tokenize for at least 1ms.
     */
    _backgroundTokenizeForAtLeast1ms() {
        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();
        const builder = new _tokens_contiguousMultilineTokensBuilder_js__WEBPACK_IMPORTED_MODULE_9__.ContiguousMultilineTokensBuilder();
        const sw = _base_common_stopwatch_js__WEBPACK_IMPORTED_MODULE_3__.StopWatch.create(false);
        do {
            if (sw.elapsed() > 1) {
                // the comparison is intentionally > 1 and not >= 1 to ensure that
                // a full millisecond has elapsed, given how microseconds are rounded
                // to milliseconds
                break;
            }
            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);
            if (tokenizedLineNumber >= lineCount) {
                break;
            }
        } while (this._hasLinesToTokenize());
        this._backgroundTokenStore.setTokens(builder.finalize());
        this.checkFinished();
    }
    _hasLinesToTokenize() {
        if (!this._tokenizerWithStateStore) {
            return false;
        }
        return !this._tokenizerWithStateStore.store.allStatesValid();
    }
    _tokenizeOneInvalidLine(builder) {
        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();
        if (!firstInvalidLine) {
            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;
        }
        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);
        return firstInvalidLine.lineNumber;
    }
    checkFinished() {
        if (this._isDisposed) {
            return;
        }
        if (this._tokenizerWithStateStore.store.allStatesValid()) {
            this._backgroundTokenStore.backgroundTokenizationFinished();
        }
    }
    requestTokens(startLineNumber, endLineNumberExclusive) {
        this._tokenizerWithStateStore.store.invalidateEndStateRange(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(startLineNumber, endLineNumberExclusive));
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TokenizationTextModelPart: () => (/* binding */ TokenizationTextModelPart)
/* harmony export */ });
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _core_eolCounter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/eolCounter.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js");
/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/lineRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/wordHelper.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js");
/* harmony import */ var _languages_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../languages.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages.js");
/* harmony import */ var _languages_language_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../languages/language.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/language.js");
/* harmony import */ var _languages_languageConfigurationRegistry_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../languages/languageConfigurationRegistry.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js");
/* harmony import */ var _textModelPart_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./textModelPart.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js");
/* harmony import */ var _textModelTokens_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./textModelTokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js");
/* harmony import */ var _tokens_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js");
/* harmony import */ var _treeSitterTokens_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./treeSitterTokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js");
/* harmony import */ var _services_treeSitterParserService_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../services/treeSitterParserService.js */ "./node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js");
/* harmony import */ var _tokens_contiguousMultilineTokensBuilder_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../tokens/contiguousMultilineTokensBuilder.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js");
/* harmony import */ var _tokens_contiguousTokensStore_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../tokens/contiguousTokensStore.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js");
/* harmony import */ var _tokens_sparseTokensStore_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../tokens/sparseTokensStore.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TokenizationTextModelPart_1;


















let TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends _textModelPart_js__WEBPACK_IMPORTED_MODULE_10__.TextModelPart {
    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {
        super();
        this._textModel = _textModel;
        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;
        this._languageId = _languageId;
        this._attachedViews = _attachedViews;
        this._languageService = _languageService;
        this._languageConfigurationService = _languageConfigurationService;
        this._treeSitterService = _treeSitterService;
        this._semanticTokens = new _tokens_sparseTokensStore_js__WEBPACK_IMPORTED_MODULE_17__.SparseTokensStore(this._languageService.languageIdCodec);
        this._onDidChangeLanguage = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter());
        this.onDidChangeLanguage = this._onDidChangeLanguage.event;
        this._onDidChangeLanguageConfiguration = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter());
        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;
        this._onDidChangeTokens = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter());
        this.onDidChangeTokens = this._onDidChangeTokens.event;
        this._tokensDisposables = this._register(new _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStore());
        this._register(this._languageConfigurationService.onDidChange(e => {
            if (e.affects(this._languageId)) {
                this._onDidChangeLanguageConfiguration.fire({});
            }
        }));
        // We just look at registry changes to determine whether to use tree sitter.
        // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.
        // Adding a language to the setting will not need a reload, however.
        this._register(_base_common_event_js__WEBPACK_IMPORTED_MODULE_1__.Event.filter(_languages_js__WEBPACK_IMPORTED_MODULE_7__.TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {
            this.createPreferredTokenProvider();
        }));
        this.createPreferredTokenProvider();
    }
    createGrammarTokens() {
        return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));
    }
    createTreeSitterTokens() {
        return this._register(new _treeSitterTokens_js__WEBPACK_IMPORTED_MODULE_13__.TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));
    }
    createTokens(useTreeSitter) {
        const needsReset = this._tokens !== undefined;
        this._tokens?.dispose();
        this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();
        this._tokensDisposables.clear();
        this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {
            this._emitModelTokensChangedEvent(e);
        }));
        this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {
            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();
        }));
        if (needsReset) {
            // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.
            this._tokens.resetTokenization();
        }
    }
    createPreferredTokenProvider() {
        if (_languages_js__WEBPACK_IMPORTED_MODULE_7__.TreeSitterTokenizationRegistry.get(this._languageId)) {
            if (!(this._tokens instanceof _treeSitterTokens_js__WEBPACK_IMPORTED_MODULE_13__.TreeSitterTokens)) {
                this.createTokens(true);
            }
        }
        else {
            if (!(this._tokens instanceof GrammarTokens)) {
                this.createTokens(false);
            }
        }
    }
    handleLanguageConfigurationServiceChange(e) {
        if (e.affects(this._languageId)) {
            this._onDidChangeLanguageConfiguration.fire({});
        }
    }
    handleDidChangeContent(e) {
        if (e.isFlush) {
            this._semanticTokens.flush();
        }
        else if (!e.isEolChange) { // We don't have to do anything on an EOL change
            for (const c of e.changes) {
                const [eolCount, firstLineLength, lastLineLength] = (0,_core_eolCounter_js__WEBPACK_IMPORTED_MODULE_3__.countEOL)(c.text);
                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);
            }
        }
        this._tokens.handleDidChangeContent(e);
    }
    handleDidChangeAttached() {
        this._tokens.handleDidChangeAttached();
    }
    /**
     * Includes grammar and semantic tokens.
     */
    getLineTokens(lineNumber) {
        this.validateLineNumber(lineNumber);
        const syntacticTokens = this._tokens.getLineTokens(lineNumber);
        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);
    }
    _emitModelTokensChangedEvent(e) {
        if (!this._textModel._isDisposing()) {
            this._bracketPairsTextModelPart.handleDidChangeTokens(e);
            this._onDidChangeTokens.fire(e);
        }
    }
    // #region Grammar Tokens
    validateLineNumber(lineNumber) {
        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('Illegal value for lineNumber');
        }
    }
    get hasTokens() {
        return this._tokens.hasTokens;
    }
    resetTokenization() {
        this._tokens.resetTokenization();
    }
    get backgroundTokenizationState() {
        return this._tokens.backgroundTokenizationState;
    }
    forceTokenization(lineNumber) {
        this.validateLineNumber(lineNumber);
        this._tokens.forceTokenization(lineNumber);
    }
    hasAccurateTokensForLine(lineNumber) {
        this.validateLineNumber(lineNumber);
        return this._tokens.hasAccurateTokensForLine(lineNumber);
    }
    isCheapToTokenize(lineNumber) {
        this.validateLineNumber(lineNumber);
        return this._tokens.isCheapToTokenize(lineNumber);
    }
    tokenizeIfCheap(lineNumber) {
        this.validateLineNumber(lineNumber);
        this._tokens.tokenizeIfCheap(lineNumber);
    }
    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {
        return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);
    }
    tokenizeLineWithEdit(position, length, newText) {
        return this._tokens.tokenizeLineWithEdit(position, length, newText);
    }
    // #endregion
    // #region Semantic Tokens
    setSemanticTokens(tokens, isComplete) {
        this._semanticTokens.set(tokens, isComplete);
        this._emitModelTokensChangedEvent({
            semanticTokensApplied: tokens !== null,
            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],
        });
    }
    hasCompleteSemanticTokens() {
        return this._semanticTokens.isComplete();
    }
    hasSomeSemanticTokens() {
        return !this._semanticTokens.isEmpty();
    }
    setPartialSemanticTokens(range, tokens) {
        if (this.hasCompleteSemanticTokens()) {
            return;
        }
        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));
        this._emitModelTokensChangedEvent({
            semanticTokensApplied: true,
            ranges: [
                {
                    fromLineNumber: changedRange.startLineNumber,
                    toLineNumber: changedRange.endLineNumber,
                },
            ],
        });
    }
    // #endregion
    // #region Utility Methods
    getWordAtPosition(_position) {
        this.assertNotDisposed();
        const position = this._textModel.validatePosition(_position);
        const lineContent = this._textModel.getLineContent(position.lineNumber);
        const lineTokens = this.getLineTokens(position.lineNumber);
        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        // (1). First try checking right biased word
        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);
        const rightBiasedWord = (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_6__.getWordAtText)(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);
        // Make sure the result touches the original passed in position
        if (rightBiasedWord &&
            rightBiasedWord.startColumn <= _position.column &&
            _position.column <= rightBiasedWord.endColumn) {
            return rightBiasedWord;
        }
        // (2). Else, if we were at a language boundary, check the left biased word
        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {
            // edge case, where `position` sits between two tokens belonging to two different languages
            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);
            const leftBiasedWord = (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_6__.getWordAtText)(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);
            // Make sure the result touches the original passed in position
            if (leftBiasedWord &&
                leftBiasedWord.startColumn <= _position.column &&
                _position.column <= leftBiasedWord.endColumn) {
                return leftBiasedWord;
            }
        }
        return null;
    }
    getLanguageConfiguration(languageId) {
        return this._languageConfigurationService.getLanguageConfiguration(languageId);
    }
    static _findLanguageBoundaries(lineTokens, tokenIndex) {
        const languageId = lineTokens.getLanguageId(tokenIndex);
        // go left until a different language is hit
        let startOffset = 0;
        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {
            startOffset = lineTokens.getStartOffset(i);
        }
        // go right until a different language is hit
        let endOffset = lineTokens.getLineContent().length;
        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {
            endOffset = lineTokens.getEndOffset(i);
        }
        return [startOffset, endOffset];
    }
    getWordUntilPosition(position) {
        const wordAtPosition = this.getWordAtPosition(position);
        if (!wordAtPosition) {
            return { word: '', startColumn: position.column, endColumn: position.column, };
        }
        return {
            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),
            startColumn: wordAtPosition.startColumn,
            endColumn: position.column,
        };
    }
    // #endregion
    // #region Language Id handling
    getLanguageId() {
        return this._languageId;
    }
    getLanguageIdAtPosition(lineNumber, column) {
        const position = this._textModel.validatePosition(new _core_position_js__WEBPACK_IMPORTED_MODULE_5__.Position(lineNumber, column));
        const lineTokens = this.getLineTokens(position.lineNumber);
        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));
    }
    setLanguageId(languageId, source = 'api') {
        if (this._languageId === languageId) {
            // There's nothing to do
            return;
        }
        const e = {
            oldLanguage: this._languageId,
            newLanguage: languageId,
            source
        };
        this._languageId = languageId;
        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);
        this._tokens.resetTokenization();
        this.createPreferredTokenProvider();
        this._onDidChangeLanguage.fire(e);
        this._onDidChangeLanguageConfiguration.fire({});
    }
};
TokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([
    __param(4, _languages_language_js__WEBPACK_IMPORTED_MODULE_8__.ILanguageService),
    __param(5, _languages_languageConfigurationRegistry_js__WEBPACK_IMPORTED_MODULE_9__.ILanguageConfigurationService),
    __param(6, _services_treeSitterParserService_js__WEBPACK_IMPORTED_MODULE_14__.ITreeSitterParserService)
], TokenizationTextModelPart);

class GrammarTokens extends _tokens_js__WEBPACK_IMPORTED_MODULE_12__.AbstractTokens {
    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {
        super(languageIdCodec, textModel, getLanguageId);
        this._tokenizer = null;
        this._defaultBackgroundTokenizer = null;
        this._backgroundTokenizer = this._register(new _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.MutableDisposable());
        this._tokens = new _tokens_contiguousTokensStore_js__WEBPACK_IMPORTED_MODULE_16__.ContiguousTokensStore(this._languageIdCodec);
        this._debugBackgroundTokenizer = this._register(new _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.MutableDisposable());
        this._attachedViewStates = this._register(new _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.DisposableMap());
        this._register(_languages_js__WEBPACK_IMPORTED_MODULE_7__.TokenizationRegistry.onDidChange((e) => {
            const languageId = this.getLanguageId();
            if (e.changedLanguages.indexOf(languageId) === -1) {
                return;
            }
            this.resetTokenization();
        }));
        this.resetTokenization();
        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {
            if (state) {
                let existing = this._attachedViewStates.get(view);
                if (!existing) {
                    existing = new _tokens_js__WEBPACK_IMPORTED_MODULE_12__.AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));
                    this._attachedViewStates.set(view, existing);
                }
                existing.handleStateChange(state);
            }
            else {
                this._attachedViewStates.deleteAndDispose(view);
            }
        }));
    }
    resetTokenization(fireTokenChangeEvent = true) {
        this._tokens.flush();
        this._debugBackgroundTokens?.flush();
        if (this._debugBackgroundStates) {
            this._debugBackgroundStates = new _textModelTokens_js__WEBPACK_IMPORTED_MODULE_11__.TrackingTokenizationStateStore(this._textModel.getLineCount());
        }
        if (fireTokenChangeEvent) {
            this._onDidChangeTokens.fire({
                semanticTokensApplied: false,
                ranges: [
                    {
                        fromLineNumber: 1,
                        toLineNumber: this._textModel.getLineCount(),
                    },
                ],
            });
        }
        const initializeTokenization = () => {
            if (this._textModel.isTooLargeForTokenization()) {
                return [null, null];
            }
            const tokenizationSupport = _languages_js__WEBPACK_IMPORTED_MODULE_7__.TokenizationRegistry.get(this.getLanguageId());
            if (!tokenizationSupport) {
                return [null, null];
            }
            let initialState;
            try {
                initialState = tokenizationSupport.getInitialState();
            }
            catch (e) {
                (0,_base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(e);
                return [null, null];
            }
            return [tokenizationSupport, initialState];
        };
        const [tokenizationSupport, initialState] = initializeTokenization();
        if (tokenizationSupport && initialState) {
            this._tokenizer = new _textModelTokens_js__WEBPACK_IMPORTED_MODULE_11__.TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);
        }
        else {
            this._tokenizer = null;
        }
        this._backgroundTokenizer.clear();
        this._defaultBackgroundTokenizer = null;
        if (this._tokenizer) {
            const b = {
                setTokens: (tokens) => {
                    this.setTokens(tokens);
                },
                backgroundTokenizationFinished: () => {
                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {
                        // We already did a full tokenization and don't go back to progressing.
                        return;
                    }
                    const newState = 2 /* BackgroundTokenizationState.Completed */;
                    this._backgroundTokenizationState = newState;
                    this._onDidChangeBackgroundTokenizationState.fire();
                },
                setEndState: (lineNumber, state) => {
                    if (!this._tokenizer) {
                        return;
                    }
                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();
                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!
                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {
                        this._tokenizer?.store.setEndState(lineNumber, state);
                    }
                },
            };
            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {
                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);
            }
            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {
                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =
                    new _textModelTokens_js__WEBPACK_IMPORTED_MODULE_11__.DefaultBackgroundTokenizer(this._tokenizer, b);
                this._defaultBackgroundTokenizer.handleChanges();
            }
            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {
                this._debugBackgroundTokens = new _tokens_contiguousTokensStore_js__WEBPACK_IMPORTED_MODULE_16__.ContiguousTokensStore(this._languageIdCodec);
                this._debugBackgroundStates = new _textModelTokens_js__WEBPACK_IMPORTED_MODULE_11__.TrackingTokenizationStateStore(this._textModel.getLineCount());
                this._debugBackgroundTokenizer.clear();
                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {
                    setTokens: (tokens) => {
                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);
                    },
                    backgroundTokenizationFinished() {
                        // NO OP
                    },
                    setEndState: (lineNumber, state) => {
                        this._debugBackgroundStates?.setEndState(lineNumber, state);
                    },
                });
            }
            else {
                this._debugBackgroundTokens = undefined;
                this._debugBackgroundStates = undefined;
                this._debugBackgroundTokenizer.value = undefined;
            }
        }
        this.refreshAllVisibleLineTokens();
    }
    handleDidChangeAttached() {
        this._defaultBackgroundTokenizer?.handleChanges();
    }
    handleDidChangeContent(e) {
        if (e.isFlush) {
            // Don't fire the event, as the view might not have got the text change event yet
            this.resetTokenization(false);
        }
        else if (!e.isEolChange) { // We don't have to do anything on an EOL change
            for (const c of e.changes) {
                const [eolCount, firstLineLength] = (0,_core_eolCounter_js__WEBPACK_IMPORTED_MODULE_3__.countEOL)(c.text);
                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);
                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);
            }
            this._debugBackgroundStates?.acceptChanges(e.changes);
            if (this._tokenizer) {
                this._tokenizer.store.acceptChanges(e.changes);
            }
            this._defaultBackgroundTokenizer?.handleChanges();
        }
    }
    setTokens(tokens) {
        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);
        if (changes.length > 0) {
            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });
        }
        return { changes: changes };
    }
    refreshAllVisibleLineTokens() {
        const ranges = _core_lineRange_js__WEBPACK_IMPORTED_MODULE_4__.LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));
        this.refreshRanges(ranges);
    }
    refreshRanges(ranges) {
        for (const range of ranges) {
            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);
        }
    }
    refreshRange(startLineNumber, endLineNumber) {
        if (!this._tokenizer) {
            return;
        }
        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));
        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);
        const builder = new _tokens_contiguousMultilineTokensBuilder_js__WEBPACK_IMPORTED_MODULE_15__.ContiguousMultilineTokensBuilder();
        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);
        const changedTokens = this.setTokens(builder.finalize());
        if (heuristicTokens) {
            // We overrode tokens with heuristically computed ones.
            // Because old states might get reused (thus stopping invalidation),
            // we have to explicitly request the tokens for the changed ranges again.
            for (const c of changedTokens.changes) {
                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);
            }
        }
        this._defaultBackgroundTokenizer?.checkFinished();
    }
    forceTokenization(lineNumber) {
        const builder = new _tokens_contiguousMultilineTokensBuilder_js__WEBPACK_IMPORTED_MODULE_15__.ContiguousMultilineTokensBuilder();
        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);
        this.setTokens(builder.finalize());
        this._defaultBackgroundTokenizer?.checkFinished();
    }
    hasAccurateTokensForLine(lineNumber) {
        if (!this._tokenizer) {
            return true;
        }
        return this._tokenizer.hasAccurateTokensForLine(lineNumber);
    }
    isCheapToTokenize(lineNumber) {
        if (!this._tokenizer) {
            return true;
        }
        return this._tokenizer.isCheapToTokenize(lineNumber);
    }
    getLineTokens(lineNumber) {
        const lineText = this._textModel.getLineContent(lineNumber);
        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);
        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {
            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {
                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);
                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {
                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);
                }
            }
        }
        return result;
    }
    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {
        if (!this._tokenizer) {
            return 0 /* StandardTokenType.Other */;
        }
        const position = this._textModel.validatePosition(new _core_position_js__WEBPACK_IMPORTED_MODULE_5__.Position(lineNumber, column));
        this.forceTokenization(position.lineNumber);
        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);
    }
    tokenizeLineWithEdit(position, length, newText) {
        if (!this._tokenizer) {
            return null;
        }
        const validatedPosition = this._textModel.validatePosition(position);
        this.forceTokenization(validatedPosition.lineNumber);
        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);
    }
    get hasTokens() {
        return this._tokens.hasTokens;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js":
/*!*************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractTokens: () => (/* binding */ AbstractTokens),
/* harmony export */   AttachedViewHandler: () => (/* binding */ AttachedViewHandler),
/* harmony export */   AttachedViews: () => (/* binding */ AttachedViews)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _base_common_async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/async.js */ "./node_modules/monaco-editor/esm/vs/base/common/async.js");
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/lineRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





/**
 * @internal
 */
class AttachedViews {
    constructor() {
        this._onDidChangeVisibleRanges = new _base_common_event_js__WEBPACK_IMPORTED_MODULE_2__.Emitter();
        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;
        this._views = new Set();
    }
    attachView() {
        const view = new AttachedViewImpl((state) => {
            this._onDidChangeVisibleRanges.fire({ view, state });
        });
        this._views.add(view);
        return view;
    }
    detachView(view) {
        this._views.delete(view);
        this._onDidChangeVisibleRanges.fire({ view, state: undefined });
    }
}
class AttachedViewImpl {
    constructor(handleStateChange) {
        this.handleStateChange = handleStateChange;
    }
    setVisibleLines(visibleLines, stabilized) {
        const visibleLineRanges = visibleLines.map((line) => new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_4__.LineRange(line.startLineNumber, line.endLineNumber + 1));
        this.handleStateChange({ visibleLineRanges, stabilized });
    }
}
class AttachedViewHandler extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_3__.Disposable {
    get lineRanges() { return this._lineRanges; }
    constructor(_refreshTokens) {
        super();
        this._refreshTokens = _refreshTokens;
        this.runner = this._register(new _base_common_async_js__WEBPACK_IMPORTED_MODULE_1__.RunOnceScheduler(() => this.update(), 50));
        this._computedLineRanges = [];
        this._lineRanges = [];
    }
    update() {
        if ((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {
            return;
        }
        this._computedLineRanges = this._lineRanges;
        this._refreshTokens();
    }
    handleStateChange(state) {
        this._lineRanges = state.visibleLineRanges;
        if (state.stabilized) {
            this.runner.cancel();
            this.update();
        }
        else {
            this.runner.schedule();
        }
    }
}
class AbstractTokens extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_3__.Disposable {
    get backgroundTokenizationState() {
        return this._backgroundTokenizationState;
    }
    constructor(_languageIdCodec, _textModel, getLanguageId) {
        super();
        this._languageIdCodec = _languageIdCodec;
        this._textModel = _textModel;
        this.getLanguageId = getLanguageId;
        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;
        this._onDidChangeBackgroundTokenizationState = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_2__.Emitter());
        /** @internal, should not be exposed by the text model! */
        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;
        this._onDidChangeTokens = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_2__.Emitter());
        /** @internal, should not be exposed by the text model! */
        this.onDidChangeTokens = this._onDidChangeTokens.event;
    }
    tokenizeIfCheap(lineNumber) {
        if (this.isCheapToTokenize(lineNumber)) {
            this.forceTokenization(lineNumber);
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TreeSitterTokens: () => (/* binding */ TreeSitterTokens)
/* harmony export */ });
/* harmony import */ var _languages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../languages.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages.js");
/* harmony import */ var _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tokens/lineTokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js");
/* harmony import */ var _tokens_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class TreeSitterTokens extends _tokens_js__WEBPACK_IMPORTED_MODULE_2__.AbstractTokens {
    constructor(_treeSitterService, languageIdCodec, textModel, languageId) {
        super(languageIdCodec, textModel, languageId);
        this._treeSitterService = _treeSitterService;
        this._tokenizationSupport = null;
        this._initialize();
    }
    _initialize() {
        const newLanguage = this.getLanguageId();
        if (!this._tokenizationSupport || this._lastLanguageId !== newLanguage) {
            this._lastLanguageId = newLanguage;
            this._tokenizationSupport = _languages_js__WEBPACK_IMPORTED_MODULE_0__.TreeSitterTokenizationRegistry.get(newLanguage);
        }
    }
    getLineTokens(lineNumber) {
        const content = this._textModel.getLineContent(lineNumber);
        if (this._tokenizationSupport) {
            const rawTokens = this._tokenizationSupport.tokenizeEncoded(lineNumber, this._textModel);
            if (rawTokens) {
                return new _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_1__.LineTokens(rawTokens, content, this._languageIdCodec);
            }
        }
        return _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_1__.LineTokens.createEmpty(content, this._languageIdCodec);
    }
    resetTokenization(fireTokenChangeEvent = true) {
        if (fireTokenChangeEvent) {
            this._onDidChangeTokens.fire({
                semanticTokensApplied: false,
                ranges: [
                    {
                        fromLineNumber: 1,
                        toLineNumber: this._textModel.getLineCount(),
                    },
                ],
            });
        }
        this._initialize();
    }
    handleDidChangeAttached() {
        // TODO @alexr00 implement for background tokenization
    }
    handleDidChangeContent(e) {
        if (e.isFlush) {
            // Don't fire the event, as the view might not have got the text change event yet
            this.resetTokenization(false);
        }
    }
    forceTokenization(lineNumber) {
        // TODO @alexr00 implement
    }
    hasAccurateTokensForLine(lineNumber) {
        // TODO @alexr00 update for background tokenization
        return true;
    }
    isCheapToTokenize(lineNumber) {
        // TODO @alexr00 update for background tokenization
        return true;
    }
    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {
        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value
        return 0 /* StandardTokenType.Other */;
    }
    tokenizeLineWithEdit(position, length, newText) {
        // TODO @alexr00 understand what this is for and implement
        return null;
    }
    get hasTokens() {
        // TODO @alexr00 once we have a token store, implement properly
        const hasTree = this._treeSitterService.getParseResult(this._textModel) !== undefined;
        return hasTree;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/utils.js":
/*!************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/utils.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeIndentLevel: () => (/* binding */ computeIndentLevel)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Returns:
 *  - -1 => the line consists of whitespace
 *  - otherwise => the indent level is returned value
 */
function computeIndentLevel(line, tabSize) {
    let indent = 0;
    let i = 0;
    const len = line.length;
    while (i < len) {
        const chCode = line.charCodeAt(i);
        if (chCode === 32 /* CharCode.Space */) {
            indent++;
        }
        else if (chCode === 9 /* CharCode.Tab */) {
            indent = indent - indent % tabSize + tabSize;
        }
        else {
            break;
        }
        i++;
    }
    if (i === len) {
        return -1; // line only consists of whitespace
    }
    return indent;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultModelSHA1Computer: () => (/* binding */ DefaultModelSHA1Computer),
/* harmony export */   ModelService: () => (/* binding */ ModelService)
/* harmony export */ });
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _base_common_platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _model_textModel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/textModel.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js");
/* harmony import */ var _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/textModelDefaults.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js");
/* harmony import */ var _languages_modesRegistry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../languages/modesRegistry.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js");
/* harmony import */ var _textResourceConfiguration_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./textResourceConfiguration.js */ "./node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js");
/* harmony import */ var _platform_configuration_common_configuration_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../platform/configuration/common/configuration.js */ "./node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js");
/* harmony import */ var _platform_undoRedo_common_undoRedo_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../platform/undoRedo/common/undoRedo.js */ "./node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js");
/* harmony import */ var _base_common_hash_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../base/common/hash.js */ "./node_modules/monaco-editor/esm/vs/base/common/hash.js");
/* harmony import */ var _model_editStack_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../model/editStack.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js");
/* harmony import */ var _base_common_network_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../base/common/network.js */ "./node_modules/monaco-editor/esm/vs/base/common/network.js");
/* harmony import */ var _base_common_objects_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../base/common/objects.js */ "./node_modules/monaco-editor/esm/vs/base/common/objects.js");
/* harmony import */ var _platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../platform/instantiation/common/instantiation.js */ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ModelService_1;














function MODEL_ID(resource) {
    return resource.toString();
}
class ModelData {
    constructor(model, onWillDispose, onDidChangeLanguage) {
        this.model = model;
        this._modelEventListeners = new _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore();
        this.model = model;
        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));
        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));
    }
    dispose() {
        this._modelEventListeners.dispose();
    }
}
const DEFAULT_EOL = (_base_common_platform_js__WEBPACK_IMPORTED_MODULE_2__.isLinux || _base_common_platform_js__WEBPACK_IMPORTED_MODULE_2__.isMacintosh) ? 1 /* DefaultEndOfLine.LF */ : 2 /* DefaultEndOfLine.CRLF */;
class DisposedModelInfo {
    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {
        this.uri = uri;
        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;
        this.time = time;
        this.sharesUndoRedoStack = sharesUndoRedoStack;
        this.heapSize = heapSize;
        this.sha1 = sha1;
        this.versionId = versionId;
        this.alternativeVersionId = alternativeVersionId;
    }
}
let ModelService = class ModelService extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    static { ModelService_1 = this; }
    static { this.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024; }
    constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _instantiationService) {
        super();
        this._configurationService = _configurationService;
        this._resourcePropertiesService = _resourcePropertiesService;
        this._undoRedoService = _undoRedoService;
        this._instantiationService = _instantiationService;
        this._onModelAdded = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter());
        this.onModelAdded = this._onModelAdded.event;
        this._onModelRemoved = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter());
        this.onModelRemoved = this._onModelRemoved.event;
        this._onModelModeChanged = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter());
        this.onModelLanguageChanged = this._onModelModeChanged.event;
        this._modelCreationOptionsByLanguageAndResource = Object.create(null);
        this._models = {};
        this._disposedModels = new Map();
        this._disposedModelsHeapSize = 0;
        this._register(this._configurationService.onDidChangeConfiguration(e => this._updateModelOptions(e)));
        this._updateModelOptions(undefined);
    }
    static _readModelOptions(config, isForSimpleWidget) {
        let tabSize = _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_4__.EDITOR_MODEL_DEFAULTS.tabSize;
        if (config.editor && typeof config.editor.tabSize !== 'undefined') {
            const parsedTabSize = parseInt(config.editor.tabSize, 10);
            if (!isNaN(parsedTabSize)) {
                tabSize = parsedTabSize;
            }
            if (tabSize < 1) {
                tabSize = 1;
            }
        }
        let indentSize = 'tabSize';
        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {
            const parsedIndentSize = parseInt(config.editor.indentSize, 10);
            if (!isNaN(parsedIndentSize)) {
                indentSize = Math.max(parsedIndentSize, 1);
            }
        }
        let insertSpaces = _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_4__.EDITOR_MODEL_DEFAULTS.insertSpaces;
        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {
            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));
        }
        let newDefaultEOL = DEFAULT_EOL;
        const eol = config.eol;
        if (eol === '\r\n') {
            newDefaultEOL = 2 /* DefaultEndOfLine.CRLF */;
        }
        else if (eol === '\n') {
            newDefaultEOL = 1 /* DefaultEndOfLine.LF */;
        }
        let trimAutoWhitespace = _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_4__.EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;
        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {
            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));
        }
        let detectIndentation = _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_4__.EDITOR_MODEL_DEFAULTS.detectIndentation;
        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {
            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));
        }
        let largeFileOptimizations = _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_4__.EDITOR_MODEL_DEFAULTS.largeFileOptimizations;
        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {
            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));
        }
        let bracketPairColorizationOptions = _core_textModelDefaults_js__WEBPACK_IMPORTED_MODULE_4__.EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;
        if (config.editor?.bracketPairColorization && typeof config.editor.bracketPairColorization === 'object') {
            bracketPairColorizationOptions = {
                enabled: !!config.editor.bracketPairColorization.enabled,
                independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType
            };
        }
        return {
            isForSimpleWidget: isForSimpleWidget,
            tabSize: tabSize,
            indentSize: indentSize,
            insertSpaces: insertSpaces,
            detectIndentation: detectIndentation,
            defaultEOL: newDefaultEOL,
            trimAutoWhitespace: trimAutoWhitespace,
            largeFileOptimizations: largeFileOptimizations,
            bracketPairColorizationOptions
        };
    }
    _getEOL(resource, language) {
        if (resource) {
            return this._resourcePropertiesService.getEOL(resource, language);
        }
        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });
        if (eol && typeof eol === 'string' && eol !== 'auto') {
            return eol;
        }
        return _base_common_platform_js__WEBPACK_IMPORTED_MODULE_2__.OS === 3 /* platform.OperatingSystem.Linux */ || _base_common_platform_js__WEBPACK_IMPORTED_MODULE_2__.OS === 2 /* platform.OperatingSystem.Macintosh */ ? '\n' : '\r\n';
    }
    _shouldRestoreUndoStack() {
        const result = this._configurationService.getValue('files.restoreUndoStack');
        if (typeof result === 'boolean') {
            return result;
        }
        return true;
    }
    getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {
        const language = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);
        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];
        if (!creationOptions) {
            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });
            const eol = this._getEOL(resource, language);
            creationOptions = ModelService_1._readModelOptions({ editor, eol }, isForSimpleWidget);
            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;
        }
        return creationOptions;
    }
    _updateModelOptions(e) {
        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;
        this._modelCreationOptionsByLanguageAndResource = Object.create(null);
        // Update options on all models
        const keys = Object.keys(this._models);
        for (let i = 0, len = keys.length; i < len; i++) {
            const modelId = keys[i];
            const modelData = this._models[modelId];
            const language = modelData.model.getLanguageId();
            const uri = modelData.model.uri;
            if (e && !e.affectsConfiguration('editor', { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration('files.eol', { overrideIdentifier: language, resource: uri })) {
                continue; // perf: skip if this model is not affected by configuration change
            }
            const oldOptions = oldOptionsByLanguageAndResource[language + uri];
            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);
            ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);
        }
    }
    static _setModelOptionsForModel(model, newOptions, currentOptions) {
        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {
            model.setEOL(newOptions.defaultEOL === 1 /* DefaultEndOfLine.LF */ ? 0 /* EndOfLineSequence.LF */ : 1 /* EndOfLineSequence.CRLF */);
        }
        if (currentOptions
            && (currentOptions.detectIndentation === newOptions.detectIndentation)
            && (currentOptions.insertSpaces === newOptions.insertSpaces)
            && (currentOptions.tabSize === newOptions.tabSize)
            && (currentOptions.indentSize === newOptions.indentSize)
            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)
            && (0,_base_common_objects_js__WEBPACK_IMPORTED_MODULE_12__.equals)(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {
            // Same indent opts, no need to touch the model
            return;
        }
        if (newOptions.detectIndentation) {
            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);
            model.updateOptions({
                trimAutoWhitespace: newOptions.trimAutoWhitespace,
                bracketColorizationOptions: newOptions.bracketPairColorizationOptions
            });
        }
        else {
            model.updateOptions({
                insertSpaces: newOptions.insertSpaces,
                tabSize: newOptions.tabSize,
                indentSize: newOptions.indentSize,
                trimAutoWhitespace: newOptions.trimAutoWhitespace,
                bracketColorizationOptions: newOptions.bracketPairColorizationOptions
            });
        }
    }
    // --- begin IModelService
    _insertDisposedModel(disposedModelData) {
        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);
        this._disposedModelsHeapSize += disposedModelData.heapSize;
    }
    _removeDisposedModel(resource) {
        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));
        if (disposedModelData) {
            this._disposedModelsHeapSize -= disposedModelData.heapSize;
        }
        this._disposedModels.delete(MODEL_ID(resource));
        return disposedModelData;
    }
    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {
        if (this._disposedModelsHeapSize > maxModelsHeapSize) {
            // we must remove some old undo stack elements to free up some memory
            const disposedModels = [];
            this._disposedModels.forEach(entry => {
                if (!entry.sharesUndoRedoStack) {
                    disposedModels.push(entry);
                }
            });
            disposedModels.sort((a, b) => a.time - b.time);
            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {
                const disposedModel = disposedModels.shift();
                this._removeDisposedModel(disposedModel.uri);
                if (disposedModel.initialUndoRedoSnapshot !== null) {
                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);
                }
            }
        }
    }
    _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {
        // create & save the model
        const options = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);
        const model = this._instantiationService.createInstance(_model_textModel_js__WEBPACK_IMPORTED_MODULE_3__.TextModel, value, languageIdOrSelection, options, resource);
        if (resource && this._disposedModels.has(MODEL_ID(resource))) {
            const disposedModelData = this._removeDisposedModel(resource);
            const elements = this._undoRedoService.getElements(resource);
            const sha1Computer = this._getSHA1Computer();
            const sha1IsEqual = (sha1Computer.canComputeSHA1(model)
                ? sha1Computer.computeSHA1(model) === disposedModelData.sha1
                : false);
            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {
                for (const element of elements.past) {
                    if ((0,_model_editStack_js__WEBPACK_IMPORTED_MODULE_10__.isEditStackElement)(element) && element.matchesResource(resource)) {
                        element.setModel(model);
                    }
                }
                for (const element of elements.future) {
                    if ((0,_model_editStack_js__WEBPACK_IMPORTED_MODULE_10__.isEditStackElement)(element) && element.matchesResource(resource)) {
                        element.setModel(model);
                    }
                }
                this._undoRedoService.setElementsValidFlag(resource, true, (element) => ((0,_model_editStack_js__WEBPACK_IMPORTED_MODULE_10__.isEditStackElement)(element) && element.matchesResource(resource)));
                if (sha1IsEqual) {
                    model._overwriteVersionId(disposedModelData.versionId);
                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);
                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);
                }
            }
            else {
                if (disposedModelData.initialUndoRedoSnapshot !== null) {
                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);
                }
            }
        }
        const modelId = MODEL_ID(model.uri);
        if (this._models[modelId]) {
            // There already exists a model with this id => this is a programmer error
            throw new Error('ModelService: Cannot add model because it already exists!');
        }
        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));
        this._models[modelId] = modelData;
        return modelData;
    }
    createModel(value, languageSelection, resource, isForSimpleWidget = false) {
        let modelData;
        if (languageSelection) {
            modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);
        }
        else {
            modelData = this._createModelData(value, _languages_modesRegistry_js__WEBPACK_IMPORTED_MODULE_5__.PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);
        }
        this._onModelAdded.fire(modelData.model);
        return modelData.model;
    }
    getModels() {
        const ret = [];
        const keys = Object.keys(this._models);
        for (let i = 0, len = keys.length; i < len; i++) {
            const modelId = keys[i];
            ret.push(this._models[modelId].model);
        }
        return ret;
    }
    getModel(resource) {
        const modelId = MODEL_ID(resource);
        const modelData = this._models[modelId];
        if (!modelData) {
            return null;
        }
        return modelData.model;
    }
    // --- end IModelService
    _schemaShouldMaintainUndoRedoElements(resource) {
        return (resource.scheme === _base_common_network_js__WEBPACK_IMPORTED_MODULE_11__.Schemas.file
            || resource.scheme === _base_common_network_js__WEBPACK_IMPORTED_MODULE_11__.Schemas.vscodeRemote
            || resource.scheme === _base_common_network_js__WEBPACK_IMPORTED_MODULE_11__.Schemas.vscodeUserData
            || resource.scheme === _base_common_network_js__WEBPACK_IMPORTED_MODULE_11__.Schemas.vscodeNotebookCell
            || resource.scheme === 'fake-fs' // for tests
        );
    }
    _onWillDispose(model) {
        const modelId = MODEL_ID(model.uri);
        const modelData = this._models[modelId];
        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());
        let maintainUndoRedoStack = false;
        let heapSize = 0;
        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {
            const elements = this._undoRedoService.getElements(model.uri);
            if (elements.past.length > 0 || elements.future.length > 0) {
                for (const element of elements.past) {
                    if ((0,_model_editStack_js__WEBPACK_IMPORTED_MODULE_10__.isEditStackElement)(element) && element.matchesResource(model.uri)) {
                        maintainUndoRedoStack = true;
                        heapSize += element.heapSize(model.uri);
                        element.setModel(model.uri); // remove reference from text buffer instance
                    }
                }
                for (const element of elements.future) {
                    if ((0,_model_editStack_js__WEBPACK_IMPORTED_MODULE_10__.isEditStackElement)(element) && element.matchesResource(model.uri)) {
                        maintainUndoRedoStack = true;
                        heapSize += element.heapSize(model.uri);
                        element.setModel(model.uri); // remove reference from text buffer instance
                    }
                }
            }
        }
        const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;
        const sha1Computer = this._getSHA1Computer();
        if (!maintainUndoRedoStack) {
            if (!sharesUndoRedoStack) {
                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();
                if (initialUndoRedoSnapshot !== null) {
                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);
                }
            }
        }
        else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {
            // the undo stack for this file would never fit in the configured memory or the file is very large, so don't bother with it.
            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();
            if (initialUndoRedoSnapshot !== null) {
                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);
            }
        }
        else {
            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);
            // We only invalidate the elements, but they remain in the undo-redo service.
            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => ((0,_model_editStack_js__WEBPACK_IMPORTED_MODULE_10__.isEditStackElement)(element) && element.matchesResource(model.uri)));
            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));
        }
        delete this._models[modelId];
        modelData.dispose();
        // clean up cache
        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];
        this._onModelRemoved.fire(model);
    }
    _onDidChangeLanguage(model, e) {
        const oldLanguageId = e.oldLanguage;
        const newLanguageId = model.getLanguageId();
        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);
        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);
        ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);
        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });
    }
    _getSHA1Computer() {
        return new DefaultModelSHA1Computer();
    }
};
ModelService = ModelService_1 = __decorate([
    __param(0, _platform_configuration_common_configuration_js__WEBPACK_IMPORTED_MODULE_7__.IConfigurationService),
    __param(1, _textResourceConfiguration_js__WEBPACK_IMPORTED_MODULE_6__.ITextResourcePropertiesService),
    __param(2, _platform_undoRedo_common_undoRedo_js__WEBPACK_IMPORTED_MODULE_8__.IUndoRedoService),
    __param(3, _platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_13__.IInstantiationService)
], ModelService);

class DefaultModelSHA1Computer {
    static { this.MAX_MODEL_SIZE = 10 * 1024 * 1024; } // takes 200ms to compute a sha1 on a 10MB model on a new machine
    canComputeSHA1(model) {
        return (model.getValueLength() <= DefaultModelSHA1Computer.MAX_MODEL_SIZE);
    }
    computeSHA1(model) {
        // compute the sha1
        const shaComputer = new _base_common_hash_js__WEBPACK_IMPORTED_MODULE_9__.StringSHA1();
        const snapshot = model.createSnapshot();
        let text;
        while ((text = snapshot.read())) {
            shaComputer.update(text);
        }
        return shaComputer.digest();
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ITextResourceConfigurationService: () => (/* binding */ ITextResourceConfigurationService),
/* harmony export */   ITextResourcePropertiesService: () => (/* binding */ ITextResourcePropertiesService)
/* harmony export */ });
/* harmony import */ var _platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/instantiation/common/instantiation.js */ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js");

const ITextResourceConfigurationService = (0,_platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_0__.createDecorator)('textResourceConfigurationService');
const ITextResourcePropertiesService = (0,_platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_0__.createDecorator)('textResourcePropertiesService');


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ITreeSitterParserService: () => (/* binding */ ITreeSitterParserService)
/* harmony export */ });
/* harmony import */ var _platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/instantiation/common/instantiation.js */ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js");

const ITreeSitterParserService = (0,_platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_0__.createDecorator)('treeSitterParserService');


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BracketInfo: () => (/* binding */ BracketInfo),
/* harmony export */   BracketPairInfo: () => (/* binding */ BracketPairInfo),
/* harmony export */   BracketPairWithMinIndentationInfo: () => (/* binding */ BracketPairWithMinIndentationInfo)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class BracketInfo {
    constructor(range, 
    /** 0-based level */
    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {
        this.range = range;
        this.nestingLevel = nestingLevel;
        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;
        this.isInvalid = isInvalid;
    }
}
class BracketPairInfo {
    constructor(range, openingBracketRange, closingBracketRange, 
    /** 0-based */
    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {
        this.range = range;
        this.openingBracketRange = openingBracketRange;
        this.closingBracketRange = closingBracketRange;
        this.nestingLevel = nestingLevel;
        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;
        this.bracketPairNode = bracketPairNode;
    }
    get openingBracketInfo() {
        return this.bracketPairNode.openingBracket.bracketInfo;
    }
}
class BracketPairWithMinIndentationInfo extends BracketPairInfo {
    constructor(range, openingBracketRange, closingBracketRange, 
    /**
     * 0-based
    */
    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, 
    /**
     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.
    */
    minVisibleColumnIndentation) {
        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);
        this.minVisibleColumnIndentation = minVisibleColumnIndentation;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalModelContentChangeEvent: () => (/* binding */ InternalModelContentChangeEvent),
/* harmony export */   LineInjectedText: () => (/* binding */ LineInjectedText),
/* harmony export */   ModelInjectedTextChangedEvent: () => (/* binding */ ModelInjectedTextChangedEvent),
/* harmony export */   ModelRawContentChangedEvent: () => (/* binding */ ModelRawContentChangedEvent),
/* harmony export */   ModelRawEOLChanged: () => (/* binding */ ModelRawEOLChanged),
/* harmony export */   ModelRawFlush: () => (/* binding */ ModelRawFlush),
/* harmony export */   ModelRawLineChanged: () => (/* binding */ ModelRawLineChanged),
/* harmony export */   ModelRawLinesDeleted: () => (/* binding */ ModelRawLinesDeleted),
/* harmony export */   ModelRawLinesInserted: () => (/* binding */ ModelRawLinesInserted)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * An event describing that a model has been reset to a new value.
 * @internal
 */
class ModelRawFlush {
    constructor() {
        this.changeType = 1 /* RawContentChangedType.Flush */;
    }
}
/**
 * Represents text injected on a line
 * @internal
 */
class LineInjectedText {
    static applyInjectedText(lineText, injectedTexts) {
        if (!injectedTexts || injectedTexts.length === 0) {
            return lineText;
        }
        let result = '';
        let lastOriginalOffset = 0;
        for (const injectedText of injectedTexts) {
            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);
            lastOriginalOffset = injectedText.column - 1;
            result += injectedText.options.content;
        }
        result += lineText.substring(lastOriginalOffset);
        return result;
    }
    static fromDecorations(decorations) {
        const result = [];
        for (const decoration of decorations) {
            if (decoration.options.before && decoration.options.before.content.length > 0) {
                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));
            }
            if (decoration.options.after && decoration.options.after.content.length > 0) {
                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));
            }
        }
        result.sort((a, b) => {
            if (a.lineNumber === b.lineNumber) {
                if (a.column === b.column) {
                    return a.order - b.order;
                }
                return a.column - b.column;
            }
            return a.lineNumber - b.lineNumber;
        });
        return result;
    }
    constructor(ownerId, lineNumber, column, options, order) {
        this.ownerId = ownerId;
        this.lineNumber = lineNumber;
        this.column = column;
        this.options = options;
        this.order = order;
    }
}
/**
 * An event describing that a line has changed in a model.
 * @internal
 */
class ModelRawLineChanged {
    constructor(lineNumber, detail, injectedText) {
        this.changeType = 2 /* RawContentChangedType.LineChanged */;
        this.lineNumber = lineNumber;
        this.detail = detail;
        this.injectedText = injectedText;
    }
}
/**
 * An event describing that line(s) have been deleted in a model.
 * @internal
 */
class ModelRawLinesDeleted {
    constructor(fromLineNumber, toLineNumber) {
        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;
        this.fromLineNumber = fromLineNumber;
        this.toLineNumber = toLineNumber;
    }
}
/**
 * An event describing that line(s) have been inserted in a model.
 * @internal
 */
class ModelRawLinesInserted {
    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {
        this.changeType = 4 /* RawContentChangedType.LinesInserted */;
        this.injectedTexts = injectedTexts;
        this.fromLineNumber = fromLineNumber;
        this.toLineNumber = toLineNumber;
        this.detail = detail;
    }
}
/**
 * An event describing that a model has had its EOL changed.
 * @internal
 */
class ModelRawEOLChanged {
    constructor() {
        this.changeType = 5 /* RawContentChangedType.EOLChanged */;
    }
}
/**
 * An event describing a change in the text of a model.
 * @internal
 */
class ModelRawContentChangedEvent {
    constructor(changes, versionId, isUndoing, isRedoing) {
        this.changes = changes;
        this.versionId = versionId;
        this.isUndoing = isUndoing;
        this.isRedoing = isRedoing;
        this.resultingSelection = null;
    }
    containsEvent(type) {
        for (let i = 0, len = this.changes.length; i < len; i++) {
            const change = this.changes[i];
            if (change.changeType === type) {
                return true;
            }
        }
        return false;
    }
    static merge(a, b) {
        const changes = [].concat(a.changes).concat(b.changes);
        const versionId = b.versionId;
        const isUndoing = (a.isUndoing || b.isUndoing);
        const isRedoing = (a.isRedoing || b.isRedoing);
        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);
    }
}
/**
 * An event describing a change in injected text.
 * @internal
 */
class ModelInjectedTextChangedEvent {
    constructor(changes) {
        this.changes = changes;
    }
}
/**
 * @internal
 */
class InternalModelContentChangeEvent {
    constructor(rawContentChangedEvent, contentChangedEvent) {
        this.rawContentChangedEvent = rawContentChangedEvent;
        this.contentChangedEvent = contentChangedEvent;
    }
    merge(other) {
        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);
        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);
        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);
    }
    static _mergeChangeEvents(a, b) {
        const changes = [].concat(a.changes).concat(b.changes);
        const eol = b.eol;
        const versionId = b.versionId;
        const isUndoing = (a.isUndoing || b.isUndoing);
        const isRedoing = (a.isRedoing || b.isRedoing);
        const isFlush = (a.isFlush || b.isFlush);
        const isEolChange = a.isEolChange && b.isEolChange; // both must be true to not confuse listeners who skip such edits
        return {
            changes: changes,
            eol: eol,
            isEolChange: isEolChange,
            versionId: versionId,
            isUndoing: isUndoing,
            isRedoing: isRedoing,
            isFlush: isFlush,
        };
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HorizontalGuidesState: () => (/* binding */ HorizontalGuidesState),
/* harmony export */   IndentGuide: () => (/* binding */ IndentGuide),
/* harmony export */   IndentGuideHorizontalLine: () => (/* binding */ IndentGuideHorizontalLine)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var HorizontalGuidesState;
(function (HorizontalGuidesState) {
    HorizontalGuidesState[HorizontalGuidesState["Disabled"] = 0] = "Disabled";
    HorizontalGuidesState[HorizontalGuidesState["EnabledForActive"] = 1] = "EnabledForActive";
    HorizontalGuidesState[HorizontalGuidesState["Enabled"] = 2] = "Enabled";
})(HorizontalGuidesState || (HorizontalGuidesState = {}));
class IndentGuide {
    constructor(visibleColumn, column, className, 
    /**
     * If set, this indent guide is a horizontal guide (no vertical part).
     * It starts at visibleColumn and continues until endColumn.
    */
    horizontalLine, 
    /**
     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.
    */
    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {
        this.visibleColumn = visibleColumn;
        this.column = column;
        this.className = className;
        this.horizontalLine = horizontalLine;
        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;
        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;
        if ((visibleColumn !== -1) === (column !== -1)) {
            throw new Error();
        }
    }
}
class IndentGuideHorizontalLine {
    constructor(top, endColumn) {
        this.top = top;
        this.endColumn = endColumn;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContiguousMultilineTokens: () => (/* binding */ ContiguousMultilineTokens)
/* harmony export */ });
/**
 * Represents contiguous tokens over a contiguous range of lines.
 */
class ContiguousMultilineTokens {
    /**
     * (Inclusive) start line number for these tokens.
     */
    get startLineNumber() {
        return this._startLineNumber;
    }
    /**
     * (Inclusive) end line number for these tokens.
     */
    get endLineNumber() {
        return this._startLineNumber + this._tokens.length - 1;
    }
    constructor(startLineNumber, tokens) {
        this._startLineNumber = startLineNumber;
        this._tokens = tokens;
    }
    /**
     * @see {@link _tokens}
     */
    getLineTokens(lineNumber) {
        return this._tokens[lineNumber - this._startLineNumber];
    }
    appendLineTokens(lineTokens) {
        this._tokens.push(lineTokens);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContiguousMultilineTokensBuilder: () => (/* binding */ ContiguousMultilineTokensBuilder)
/* harmony export */ });
/* harmony import */ var _contiguousMultilineTokens_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contiguousMultilineTokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js");

class ContiguousMultilineTokensBuilder {
    constructor() {
        this._tokens = [];
    }
    add(lineNumber, lineTokens) {
        if (this._tokens.length > 0) {
            const last = this._tokens[this._tokens.length - 1];
            if (last.endLineNumber + 1 === lineNumber) {
                // append
                last.appendLineTokens(lineTokens);
                return;
            }
        }
        this._tokens.push(new _contiguousMultilineTokens_js__WEBPACK_IMPORTED_MODULE_0__.ContiguousMultilineTokens(lineNumber, [lineTokens]));
    }
    finalize() {
        return this._tokens;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContiguousTokensEditing: () => (/* binding */ ContiguousTokensEditing),
/* harmony export */   EMPTY_LINE_TOKENS: () => (/* binding */ EMPTY_LINE_TOKENS),
/* harmony export */   toUint32Array: () => (/* binding */ toUint32Array)
/* harmony export */ });
/* harmony import */ var _lineTokens_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lineTokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;
class ContiguousTokensEditing {
    static deleteBeginning(lineTokens, toChIndex) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
            return lineTokens;
        }
        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);
    }
    static deleteEnding(lineTokens, fromChIndex) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
            return lineTokens;
        }
        const tokens = toUint32Array(lineTokens);
        const lineTextLength = tokens[tokens.length - 2];
        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);
    }
    static delete(lineTokens, fromChIndex, toChIndex) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {
            return lineTokens;
        }
        const tokens = toUint32Array(lineTokens);
        const tokensCount = (tokens.length >>> 1);
        // special case: deleting everything
        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {
            return EMPTY_LINE_TOKENS;
        }
        const fromTokenIndex = _lineTokens_js__WEBPACK_IMPORTED_MODULE_0__.LineTokens.findIndexInTokensArray(tokens, fromChIndex);
        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);
        const fromTokenEndOffset = tokens[fromTokenIndex << 1];
        if (toChIndex < fromTokenEndOffset) {
            // the delete range is inside a single token
            const delta = (toChIndex - fromChIndex);
            for (let i = fromTokenIndex; i < tokensCount; i++) {
                tokens[i << 1] -= delta;
            }
            return lineTokens;
        }
        let dest;
        let lastEnd;
        if (fromTokenStartOffset !== fromChIndex) {
            tokens[fromTokenIndex << 1] = fromChIndex;
            dest = ((fromTokenIndex + 1) << 1);
            lastEnd = fromChIndex;
        }
        else {
            dest = (fromTokenIndex << 1);
            lastEnd = fromTokenStartOffset;
        }
        const delta = (toChIndex - fromChIndex);
        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {
            const tokenEndOffset = tokens[tokenIndex << 1] - delta;
            if (tokenEndOffset > lastEnd) {
                tokens[dest++] = tokenEndOffset;
                tokens[dest++] = tokens[(tokenIndex << 1) + 1];
                lastEnd = tokenEndOffset;
            }
        }
        if (dest === tokens.length) {
            // nothing to trim
            return lineTokens;
        }
        const tmp = new Uint32Array(dest);
        tmp.set(tokens.subarray(0, dest), 0);
        return tmp.buffer;
    }
    static append(lineTokens, _otherTokens) {
        if (_otherTokens === EMPTY_LINE_TOKENS) {
            return lineTokens;
        }
        if (lineTokens === EMPTY_LINE_TOKENS) {
            return _otherTokens;
        }
        if (lineTokens === null) {
            return lineTokens;
        }
        if (_otherTokens === null) {
            // cannot determine combined line length...
            return null;
        }
        const myTokens = toUint32Array(lineTokens);
        const otherTokens = toUint32Array(_otherTokens);
        const otherTokensCount = (otherTokens.length >>> 1);
        const result = new Uint32Array(myTokens.length + otherTokens.length);
        result.set(myTokens, 0);
        let dest = myTokens.length;
        const delta = myTokens[myTokens.length - 2];
        for (let i = 0; i < otherTokensCount; i++) {
            result[dest++] = otherTokens[(i << 1)] + delta;
            result[dest++] = otherTokens[(i << 1) + 1];
        }
        return result.buffer;
    }
    static insert(lineTokens, chIndex, textLength) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
            // nothing to do
            return lineTokens;
        }
        const tokens = toUint32Array(lineTokens);
        const tokensCount = (tokens.length >>> 1);
        let fromTokenIndex = _lineTokens_js__WEBPACK_IMPORTED_MODULE_0__.LineTokens.findIndexInTokensArray(tokens, chIndex);
        if (fromTokenIndex > 0) {
            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];
            if (fromTokenStartOffset === chIndex) {
                fromTokenIndex--;
            }
        }
        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {
            tokens[tokenIndex << 1] += textLength;
        }
        return lineTokens;
    }
}
function toUint32Array(arr) {
    if (arr instanceof Uint32Array) {
        return arr;
    }
    else {
        return new Uint32Array(arr);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContiguousTokensStore: () => (/* binding */ ContiguousTokensStore)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contiguousTokensEditing.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js");
/* harmony import */ var _lineTokens_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lineTokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js");
/* harmony import */ var _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../encodedTokenAttributes.js */ "./node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





/**
 * Represents contiguous tokens in a text model.
 */
class ContiguousTokensStore {
    constructor(languageIdCodec) {
        this._lineTokens = [];
        this._len = 0;
        this._languageIdCodec = languageIdCodec;
    }
    flush() {
        this._lineTokens = [];
        this._len = 0;
    }
    get hasTokens() {
        return this._lineTokens.length > 0;
    }
    getTokens(topLevelLanguageId, lineIndex, lineText) {
        let rawLineTokens = null;
        if (lineIndex < this._len) {
            rawLineTokens = this._lineTokens[lineIndex];
        }
        if (rawLineTokens !== null && rawLineTokens !== _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_LINE_TOKENS) {
            return new _lineTokens_js__WEBPACK_IMPORTED_MODULE_3__.LineTokens((0,_contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.toUint32Array)(rawLineTokens), lineText, this._languageIdCodec);
        }
        const lineTokens = new Uint32Array(2);
        lineTokens[0] = lineText.length;
        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));
        return new _lineTokens_js__WEBPACK_IMPORTED_MODULE_3__.LineTokens(lineTokens, lineText, this._languageIdCodec);
    }
    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {
        const tokens = _tokens ? (0,_contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.toUint32Array)(_tokens) : null;
        if (lineTextLength === 0) {
            let hasDifferentLanguageId = false;
            if (tokens && tokens.length > 1) {
                hasDifferentLanguageId = (_encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_4__.TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);
            }
            if (!hasDifferentLanguageId) {
                return _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_LINE_TOKENS;
            }
        }
        if (!tokens || tokens.length === 0) {
            const tokens = new Uint32Array(2);
            tokens[0] = lineTextLength;
            tokens[1] = getDefaultMetadata(topLevelLanguageId);
            return tokens.buffer;
        }
        // Ensure the last token covers the end of the text
        tokens[tokens.length - 2] = lineTextLength;
        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {
            // Store directly the ArrayBuffer pointer to save an object
            return tokens.buffer;
        }
        return tokens;
    }
    _ensureLine(lineIndex) {
        while (lineIndex >= this._len) {
            this._lineTokens[this._len] = null;
            this._len++;
        }
    }
    _deleteLines(start, deleteCount) {
        if (deleteCount === 0) {
            return;
        }
        if (start + deleteCount > this._len) {
            deleteCount = this._len - start;
        }
        this._lineTokens.splice(start, deleteCount);
        this._len -= deleteCount;
    }
    _insertLines(insertIndex, insertCount) {
        if (insertCount === 0) {
            return;
        }
        const lineTokens = [];
        for (let i = 0; i < insertCount; i++) {
            lineTokens[i] = null;
        }
        this._lineTokens = _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.arrayInsert(this._lineTokens, insertIndex, lineTokens);
        this._len += insertCount;
    }
    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {
        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);
        this._ensureLine(lineIndex);
        const oldTokens = this._lineTokens[lineIndex];
        this._lineTokens[lineIndex] = tokens;
        if (checkEquality) {
            return !ContiguousTokensStore._equals(oldTokens, tokens);
        }
        return false;
    }
    static _equals(_a, _b) {
        if (!_a || !_b) {
            return !_a && !_b;
        }
        const a = (0,_contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.toUint32Array)(_a);
        const b = (0,_contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.toUint32Array)(_b);
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0, len = a.length; i < len; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    //#region Editing
    acceptEdit(range, eolCount, firstLineLength) {
        this._acceptDeleteRange(range);
        this._acceptInsertText(new _core_position_js__WEBPACK_IMPORTED_MODULE_1__.Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);
    }
    _acceptDeleteRange(range) {
        const firstLineIndex = range.startLineNumber - 1;
        if (firstLineIndex >= this._len) {
            return;
        }
        if (range.startLineNumber === range.endLineNumber) {
            if (range.startColumn === range.endColumn) {
                // Nothing to delete
                return;
            }
            this._lineTokens[firstLineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);
            return;
        }
        this._lineTokens[firstLineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);
        const lastLineIndex = range.endLineNumber - 1;
        let lastLineTokens = null;
        if (lastLineIndex < this._len) {
            lastLineTokens = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);
        }
        // Take remaining text on last line and append it to remaining text on first line
        this._lineTokens[firstLineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);
        // Delete middle lines
        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);
    }
    _acceptInsertText(position, eolCount, firstLineLength) {
        if (eolCount === 0 && firstLineLength === 0) {
            // Nothing to insert
            return;
        }
        const lineIndex = position.lineNumber - 1;
        if (lineIndex >= this._len) {
            return;
        }
        if (eolCount === 0) {
            // Inserting text on one line
            this._lineTokens[lineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);
            return;
        }
        this._lineTokens[lineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);
        this._lineTokens[lineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_2__.ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);
        this._insertLines(position.lineNumber, eolCount);
    }
    //#endregion
    setMultilineTokens(tokens, textModel) {
        if (tokens.length === 0) {
            return { changes: [] };
        }
        const ranges = [];
        for (let i = 0, len = tokens.length; i < len; i++) {
            const element = tokens[i];
            let minChangedLineNumber = 0;
            let maxChangedLineNumber = 0;
            let hasChange = false;
            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {
                if (hasChange) {
                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);
                    maxChangedLineNumber = lineNumber;
                }
                else {
                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);
                    if (lineHasChange) {
                        hasChange = true;
                        minChangedLineNumber = lineNumber;
                        maxChangedLineNumber = lineNumber;
                    }
                }
            }
            if (hasChange) {
                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });
            }
        }
        return { changes: ranges };
    }
}
function getDefaultMetadata(topLevelLanguageId) {
    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)
        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)
        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)
        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)
        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)
        // If there is no grammar, we just take a guess and try to match brackets.
        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js":
/*!******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineTokens: () => (/* binding */ LineTokens),
/* harmony export */   getStandardTokenTypeAtPosition: () => (/* binding */ getStandardTokenTypeAtPosition)
/* harmony export */ });
/* harmony import */ var _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../encodedTokenAttributes.js */ "./node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class LineTokens {
    static { this.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)
        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)
        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0; }
    static createEmpty(lineContent, decoder) {
        const defaultMetadata = LineTokens.defaultTokenMetadata;
        const tokens = new Uint32Array(2);
        tokens[0] = lineContent.length;
        tokens[1] = defaultMetadata;
        return new LineTokens(tokens, lineContent, decoder);
    }
    static createFromTextAndMetadata(data, decoder) {
        let offset = 0;
        let fullText = '';
        const tokens = new Array();
        for (const { text, metadata } of data) {
            tokens.push(offset + text.length, metadata);
            offset += text.length;
            fullText += text;
        }
        return new LineTokens(new Uint32Array(tokens), fullText, decoder);
    }
    constructor(tokens, text, decoder) {
        this._lineTokensBrand = undefined;
        this._tokens = tokens;
        this._tokensCount = (this._tokens.length >>> 1);
        this._text = text;
        this.languageIdCodec = decoder;
    }
    equals(other) {
        if (other instanceof LineTokens) {
            return this.slicedEquals(other, 0, this._tokensCount);
        }
        return false;
    }
    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {
        if (this._text !== other._text) {
            return false;
        }
        if (this._tokensCount !== other._tokensCount) {
            return false;
        }
        const from = (sliceFromTokenIndex << 1);
        const to = from + (sliceTokenCount << 1);
        for (let i = from; i < to; i++) {
            if (this._tokens[i] !== other._tokens[i]) {
                return false;
            }
        }
        return true;
    }
    getLineContent() {
        return this._text;
    }
    getCount() {
        return this._tokensCount;
    }
    getStartOffset(tokenIndex) {
        if (tokenIndex > 0) {
            return this._tokens[(tokenIndex - 1) << 1];
        }
        return 0;
    }
    getMetadata(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return metadata;
    }
    getLanguageId(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        const languageId = _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getLanguageId(metadata);
        return this.languageIdCodec.decodeLanguageId(languageId);
    }
    getStandardTokenType(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getTokenType(metadata);
    }
    getForeground(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getForeground(metadata);
    }
    getClassName(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getClassNameFromMetadata(metadata);
    }
    getInlineStyle(tokenIndex, colorMap) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);
    }
    getPresentation(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getPresentationFromMetadata(metadata);
    }
    getEndOffset(tokenIndex) {
        return this._tokens[tokenIndex << 1];
    }
    /**
     * Find the token containing offset `offset`.
     * @param offset The search offset
     * @return The index of the token containing the offset.
     */
    findTokenIndexAtOffset(offset) {
        return LineTokens.findIndexInTokensArray(this._tokens, offset);
    }
    inflate() {
        return this;
    }
    sliceAndInflate(startOffset, endOffset, deltaOffset) {
        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);
    }
    static convertToEndOffset(tokens, lineTextLength) {
        const tokenCount = (tokens.length >>> 1);
        const lastTokenIndex = tokenCount - 1;
        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {
            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];
        }
        tokens[lastTokenIndex << 1] = lineTextLength;
    }
    static findIndexInTokensArray(tokens, desiredIndex) {
        if (tokens.length <= 2) {
            return 0;
        }
        let low = 0;
        let high = (tokens.length >>> 1) - 1;
        while (low < high) {
            const mid = low + Math.floor((high - low) / 2);
            const endOffset = tokens[(mid << 1)];
            if (endOffset === desiredIndex) {
                return mid + 1;
            }
            else if (endOffset < desiredIndex) {
                low = mid + 1;
            }
            else if (endOffset > desiredIndex) {
                high = mid;
            }
        }
        return low;
    }
    /**
     * @pure
     * @param insertTokens Must be sorted by offset.
    */
    withInserted(insertTokens) {
        if (insertTokens.length === 0) {
            return this;
        }
        let nextOriginalTokenIdx = 0;
        let nextInsertTokenIdx = 0;
        let text = '';
        const newTokens = new Array();
        let originalEndOffset = 0;
        while (true) {
            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;
            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;
            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {
                // original token ends before next insert token
                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);
                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];
                newTokens.push(text.length, metadata);
                nextOriginalTokenIdx++;
                originalEndOffset = nextOriginalTokenEndOffset;
            }
            else if (nextInsertToken) {
                if (nextInsertToken.offset > originalEndOffset) {
                    // insert token is in the middle of the next token.
                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);
                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];
                    newTokens.push(text.length, metadata);
                    originalEndOffset = nextInsertToken.offset;
                }
                text += nextInsertToken.text;
                newTokens.push(text.length, nextInsertToken.tokenMetadata);
                nextInsertTokenIdx++;
            }
            else {
                break;
            }
        }
        return new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);
    }
    getTokenText(tokenIndex) {
        const startOffset = this.getStartOffset(tokenIndex);
        const endOffset = this.getEndOffset(tokenIndex);
        const text = this._text.substring(startOffset, endOffset);
        return text;
    }
    forEach(callback) {
        const tokenCount = this.getCount();
        for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {
            callback(tokenIndex);
        }
    }
}
class SliceLineTokens {
    constructor(source, startOffset, endOffset, deltaOffset) {
        this._source = source;
        this._startOffset = startOffset;
        this._endOffset = endOffset;
        this._deltaOffset = deltaOffset;
        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);
        this.languageIdCodec = source.languageIdCodec;
        this._tokensCount = 0;
        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {
            const tokenStartOffset = source.getStartOffset(i);
            if (tokenStartOffset >= endOffset) {
                break;
            }
            this._tokensCount++;
        }
    }
    getMetadata(tokenIndex) {
        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);
    }
    getLanguageId(tokenIndex) {
        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);
    }
    getLineContent() {
        return this._source.getLineContent().substring(this._startOffset, this._endOffset);
    }
    equals(other) {
        if (other instanceof SliceLineTokens) {
            return (this._startOffset === other._startOffset
                && this._endOffset === other._endOffset
                && this._deltaOffset === other._deltaOffset
                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));
        }
        return false;
    }
    getCount() {
        return this._tokensCount;
    }
    getStandardTokenType(tokenIndex) {
        return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);
    }
    getForeground(tokenIndex) {
        return this._source.getForeground(this._firstTokenIndex + tokenIndex);
    }
    getEndOffset(tokenIndex) {
        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);
        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;
    }
    getClassName(tokenIndex) {
        return this._source.getClassName(this._firstTokenIndex + tokenIndex);
    }
    getInlineStyle(tokenIndex, colorMap) {
        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);
    }
    getPresentation(tokenIndex) {
        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);
    }
    findTokenIndexAtOffset(offset) {
        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
    }
    getTokenText(tokenIndex) {
        const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;
        const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);
        const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);
        let text = this._source.getTokenText(adjustedTokenIndex);
        if (tokenStartOffset < this._startOffset) {
            text = text.substring(this._startOffset - tokenStartOffset);
        }
        if (tokenEndOffset > this._endOffset) {
            text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));
        }
        return text;
    }
    forEach(callback) {
        for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {
            callback(tokenIndex);
        }
    }
}
function getStandardTokenTypeAtPosition(model, position) {
    const lineNumber = position.lineNumber;
    if (!model.tokenization.isCheapToTokenize(lineNumber)) {
        return undefined;
    }
    model.tokenization.forceTokenization(lineNumber);
    const lineTokens = model.tokenization.getLineTokens(lineNumber);
    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
    const tokenType = lineTokens.getStandardTokenType(tokenIndex);
    return tokenType;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SparseTokensStore: () => (/* binding */ SparseTokensStore)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _lineTokens_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lineTokens.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * Represents sparse tokens in a text model.
 */
class SparseTokensStore {
    constructor(languageIdCodec) {
        this._pieces = [];
        this._isComplete = false;
        this._languageIdCodec = languageIdCodec;
    }
    flush() {
        this._pieces = [];
        this._isComplete = false;
    }
    isEmpty() {
        return (this._pieces.length === 0);
    }
    set(pieces, isComplete) {
        this._pieces = pieces || [];
        this._isComplete = isComplete;
    }
    setPartial(_range, pieces) {
        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);
        let range = _range;
        if (pieces.length > 0) {
            const _firstRange = pieces[0].getRange();
            const _lastRange = pieces[pieces.length - 1].getRange();
            if (!_firstRange || !_lastRange) {
                return _range;
            }
            range = _range.plusRange(_firstRange).plusRange(_lastRange);
        }
        let insertPosition = null;
        for (let i = 0, len = this._pieces.length; i < len; i++) {
            const piece = this._pieces[i];
            if (piece.endLineNumber < range.startLineNumber) {
                // this piece is before the range
                continue;
            }
            if (piece.startLineNumber > range.endLineNumber) {
                // this piece is after the range, so mark the spot before this piece
                // as a good insertion position and stop looping
                insertPosition = insertPosition || { index: i };
                break;
            }
            // this piece might intersect with the range
            piece.removeTokens(range);
            if (piece.isEmpty()) {
                // remove the piece if it became empty
                this._pieces.splice(i, 1);
                i--;
                len--;
                continue;
            }
            if (piece.endLineNumber < range.startLineNumber) {
                // after removal, this piece is before the range
                continue;
            }
            if (piece.startLineNumber > range.endLineNumber) {
                // after removal, this piece is after the range
                insertPosition = insertPosition || { index: i };
                continue;
            }
            // after removal, this piece contains the range
            const [a, b] = piece.split(range);
            if (a.isEmpty()) {
                // this piece is actually after the range
                insertPosition = insertPosition || { index: i };
                continue;
            }
            if (b.isEmpty()) {
                // this piece is actually before the range
                continue;
            }
            this._pieces.splice(i, 1, a, b);
            i++;
            len++;
            insertPosition = insertPosition || { index: i };
        }
        insertPosition = insertPosition || { index: this._pieces.length };
        if (pieces.length > 0) {
            this._pieces = _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.arrayInsert(this._pieces, insertPosition.index, pieces);
        }
        // console.log(`I HAVE ${this._pieces.length} pieces`);
        // console.log(`${this._pieces.map(p => p.toString()).join('\n')}`);
        return range;
    }
    isComplete() {
        return this._isComplete;
    }
    addSparseTokens(lineNumber, aTokens) {
        if (aTokens.getLineContent().length === 0) {
            // Don't do anything for empty lines
            return aTokens;
        }
        const pieces = this._pieces;
        if (pieces.length === 0) {
            return aTokens;
        }
        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);
        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);
        if (!bTokens) {
            return aTokens;
        }
        const aLen = aTokens.getCount();
        const bLen = bTokens.getCount();
        let aIndex = 0;
        const result = [];
        let resultLen = 0;
        let lastEndOffset = 0;
        const emitToken = (endOffset, metadata) => {
            if (endOffset === lastEndOffset) {
                return;
            }
            lastEndOffset = endOffset;
            result[resultLen++] = endOffset;
            result[resultLen++] = metadata;
        };
        for (let bIndex = 0; bIndex < bLen; bIndex++) {
            const bStartCharacter = bTokens.getStartCharacter(bIndex);
            const bEndCharacter = bTokens.getEndCharacter(bIndex);
            const bMetadata = bTokens.getMetadata(bIndex);
            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)
                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)
                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)
                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)
                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)
                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;
            const aMask = (~bMask) >>> 0;
            // push any token from `a` that is before `b`
            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {
                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));
                aIndex++;
            }
            // push the token from `a` if it intersects the token from `b`
            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {
                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));
            }
            // skip any tokens from `a` that are contained inside `b`
            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {
                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));
                aIndex++;
            }
            if (aIndex < aLen) {
                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));
                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {
                    // `a` ends exactly at the same spot as `b`!
                    aIndex++;
                }
            }
            else {
                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);
                // push the token from `b`
                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));
            }
        }
        // push the remaining tokens from `a`
        while (aIndex < aLen) {
            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));
            aIndex++;
        }
        return new _lineTokens_js__WEBPACK_IMPORTED_MODULE_1__.LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);
    }
    static _findFirstPieceWithLine(pieces, lineNumber) {
        let low = 0;
        let high = pieces.length - 1;
        while (low < high) {
            let mid = low + Math.floor((high - low) / 2);
            if (pieces[mid].endLineNumber < lineNumber) {
                low = mid + 1;
            }
            else if (pieces[mid].startLineNumber > lineNumber) {
                high = mid - 1;
            }
            else {
                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {
                    mid--;
                }
                return mid;
            }
        }
        return low;
    }
    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {
        for (const piece of this._pieces) {
            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SyncDescriptor: () => (/* binding */ SyncDescriptor)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class SyncDescriptor {
    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {
        this.ctor = ctor;
        this.staticArguments = staticArguments;
        this.supportsDelayedInstantiation = supportsDelayedInstantiation;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSingletonServiceDescriptors: () => (/* binding */ getSingletonServiceDescriptors),
/* harmony export */   registerSingleton: () => (/* binding */ registerSingleton)
/* harmony export */ });
/* harmony import */ var _descriptors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./descriptors.js */ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const _registry = [];
function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {
    if (!(ctorOrDescriptor instanceof _descriptors_js__WEBPACK_IMPORTED_MODULE_0__.SyncDescriptor)) {
        ctorOrDescriptor = new _descriptors_js__WEBPACK_IMPORTED_MODULE_0__.SyncDescriptor(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation));
    }
    _registry.push([id, ctorOrDescriptor]);
}
function getSingletonServiceDescriptors() {
    return _registry;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js":
/*!********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IUndoRedoService: () => (/* binding */ IUndoRedoService),
/* harmony export */   ResourceEditStackSnapshot: () => (/* binding */ ResourceEditStackSnapshot),
/* harmony export */   UndoRedoGroup: () => (/* binding */ UndoRedoGroup),
/* harmony export */   UndoRedoSource: () => (/* binding */ UndoRedoSource)
/* harmony export */ });
/* harmony import */ var _instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../instantiation/common/instantiation.js */ "./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const IUndoRedoService = (0,_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_0__.createDecorator)('undoRedoService');
class ResourceEditStackSnapshot {
    constructor(resource, elements) {
        this.resource = resource;
        this.elements = elements;
    }
}
class UndoRedoGroup {
    static { this._ID = 0; }
    constructor() {
        this.id = UndoRedoGroup._ID++;
        this.order = 1;
    }
    nextOrder() {
        if (this.id === 0) {
            return 0;
        }
        return this.order++;
    }
    static { this.None = new UndoRedoGroup(); }
}
class UndoRedoSource {
    static { this._ID = 0; }
    constructor() {
        this.id = UndoRedoSource._ID++;
        this.order = 1;
    }
    nextOrder() {
        if (this.id === 0) {
            return 0;
        }
        return this.order++;
    }
    static { this.None = new UndoRedoSource(); }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19tb2RlbFNlcnZpY2VfanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDaUM7QUFDakM7QUFDQSx5QkFBeUIsMENBQUk7QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5RUFBNEIsZUFBZSxxRUFBd0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFFQUF3QjtBQUNyRDtBQUNBO0FBQ0EsOEJBQThCLHFFQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUVBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQW1CO0FBQy9DO0FBQ0EsNEJBQTRCLGdFQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tFO0FBQ0o7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpRUFBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdDQUF3QyxpRUFBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0VBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQSxxQkFBcUIscURBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscURBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDejlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNrRDtBQUNOO0FBQ0Q7QUFDdUU7QUFDbEM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvREFBUTtBQUNsQztBQUNBLDZCQUE2QixvREFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLG9CQUFvQixvREFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQkFBb0IsSUFBSSxnSUFBZ0k7QUFDek07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCLG9EQUFRO0FBQzdCLDJCQUEyQixvREFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdURBQVE7QUFDdkM7QUFDQSwyQkFBMkIsdURBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0RBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVEQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1REFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxQkFBcUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQUksSUFBSSxTQUFJO0FBQzlCO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0EsZUFBZSxTQUFJLElBQUksU0FBSTtBQUMzQixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNzRTtBQUNoQjtBQUNrRDtBQUNoRDtBQUM4QztBQUMzQztBQUNUO0FBQ0Q7QUFDYTtBQUNmO0FBQ047QUFDUTtBQUNvQjtBQUNUO0FBQ2tDO0FBQ3pEO0FBQ3VEO0FBQ3FDO0FBQ3RGO0FBQ29CO0FBQ0o7QUFDcUI7QUFDRztBQUNjO0FBQzVCO0FBQ007QUFDL0I7QUFDK007QUFDM0o7QUFDZjtBQUMxRTtBQUNQLHdCQUF3QiwyR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ087QUFDUCx3QkFBd0IsMkdBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVEQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsd0NBQXdDLGlFQUFVO0FBQ2xELGFBQWE7QUFDYixhQUFhLDZDQUE2QztBQUMxRCxhQUFhLHFEQUFxRDtBQUNsRSxhQUFhLHFEQUFxRDtBQUNsRSxhQUFhLGdFQUFnRTtBQUM3RSxhQUFhO0FBQ2I7QUFDQSxpQkFBaUIsOEVBQXFCO0FBQ3RDLG9CQUFvQiw4RUFBcUI7QUFDekMsc0JBQXNCLDhFQUFxQjtBQUMzQztBQUNBO0FBQ0EsNEJBQTRCLDhFQUFxQjtBQUNqRCxnQ0FBZ0MsOEVBQXFCO0FBQ3JELHdDQUF3Qyw4RUFBcUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHlFQUFnQjtBQUN2RCx1QkFBdUIsZ0VBQThCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQixnRUFBOEI7QUFDakQ7QUFDQSxnQ0FBZ0M7QUFDaEMsNkNBQTZDO0FBQzdDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkVBQWtCO0FBQ2pDO0FBQ0EscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDBEQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwwREFBTztBQUM3RDtBQUNBLHVEQUF1RCwwREFBTztBQUM5RDtBQUNBLDJEQUEyRCwwREFBTztBQUNsRTtBQUNBLDZEQUE2RCx3RUFBaUI7QUFDOUU7QUFDQSxrQ0FBa0Msc0RBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvREFBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzR0FBeUI7QUFDekUsdURBQXVELHlFQUFtQjtBQUMxRSxzREFBc0QsMklBQXVDO0FBQzdGLG1GQUFtRixxRkFBeUI7QUFDNUc7QUFDQSx3RUFBd0Usa0RBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFFQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscURBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2RkFBbUI7QUFDL0Q7QUFDQTtBQUNBLGlDQUFpQyxpRUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0VBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpRkFBK0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUVBQWU7QUFDakM7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkVBQTJCO0FBQ3JFLGdCQUFnQiwrREFBYTtBQUM3QiwyRUFBMkUsa0RBQUs7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkVBQTJCO0FBQ3JFLGdCQUFnQixvRUFBa0I7QUFDbEMsMkVBQTJFLGtEQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlFQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBFQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDZFQUFnQztBQUN6RTtBQUNBLGdFQUFnRSw0QkFBNEI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzRUFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNFQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0VBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzRUFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzRUFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNFQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0VBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0RBQUs7QUFDckMsa0NBQWtDLDBEQUFTO0FBQzNDO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0VBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFRO0FBQy9CO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVE7QUFDL0I7QUFDQTtBQUNBLHVCQUF1Qix1REFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9FQUF1QjtBQUN2QywyQkFBMkIsdURBQVE7QUFDbkM7QUFDQTtBQUNBLG1CQUFtQix1REFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0VBQXVCO0FBQ3BFLDJDQUEyQyxvRUFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBSyx5QkFBeUIsMERBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0VBQXVCO0FBQ3BFLDJDQUEyQyxvRUFBdUI7QUFDbEU7QUFDQSwyQkFBMkIsa0RBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0RBQUs7QUFDaEM7QUFDQTtBQUNBLHVCQUF1QixrREFBSztBQUM1QjtBQUNBLG1CQUFtQixrREFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrREFBSztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDhEQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlFQUFlLHVCQUF1Qiw4REFBWTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4REFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtEQUFLO0FBQ3ZDO0FBQ0EsWUFBWSxpRUFBZSx5QkFBeUIsOERBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtEQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQWUseUJBQXlCLDhEQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBZSw2QkFBNkIsOERBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUVBQWlDO0FBQ3JFO0FBQ0E7QUFDQSxtQkFBbUIsbUVBQWlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxTQUFTO0FBQ3pFO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsU0FBUztBQUNyRjtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtEQUFLO0FBQ25ELGdEQUFnRCxtRUFBaUM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFLO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0RBQUs7QUFDaEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBLG1DQUFtQyw2REFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0SSx1REFBUSxnREFBZ0QsdURBQVE7QUFDNU0sa0RBQWtELGtFQUFnQjtBQUNsRSwyREFBMkQsOERBQVU7QUFDckUsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUVBQW1CO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNFQUFvQjtBQUNuRTtBQUNBO0FBQ0EsK0RBQStELDhEQUFVO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsdUVBQXFCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw2RUFBMkI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxxRUFBbUI7QUFDeEYsK0NBQStDLCtFQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdDQUFnQztBQUNsRyxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlFQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5RUFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnRUFBZ0U7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQUs7QUFDL0I7QUFDQSxRQUFRLGdFQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0VBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQixFQUFFLHFCQUFxQjtBQUN6RixtQ0FBbUMsMkRBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9GQUFnQjtBQUMvQixlQUFlLHFFQUFnQjtBQUMvQixlQUFlLHVHQUE2QjtBQUM1QyxlQUFlLG1HQUFxQjtBQUNwQztBQUNxQjtBQUNkO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyREFBWTtBQUNqRCxxQ0FBcUMsMkRBQVk7QUFDakQsZ0RBQWdELDJEQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix5REFBdUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw2Q0FBNkMsdURBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxTQUFTO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDhCQUE4QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lEO0FBQ1o7QUFDN0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVEsRUFBRSx5Q0FBeUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDJCQUEyQiwrREFBa0I7QUFDN0M7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3RELDBCQUEwQiwrQ0FBK0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDa0Q7QUFDbEQ7QUFDTztBQUNQLHNDQUFzQywyREFBYztBQUNwRCwrQkFBK0IsMkRBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDOEU7QUFDdkUseUJBQXlCLHVGQUFlO0FBQ3hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2J1ZmZlci5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9jdXJzb3JDb2x1bW5zLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL2luZGVudGF0aW9uLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3N0cmluZ0J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvdGV4dENoYW5nZS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS90ZXh0TW9kZWxEZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbGFuZ3VhZ2VzL2xhbmd1YWdlQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbGFuZ3VhZ2VzL2xhbmd1YWdlQ29uZmlndXJhdGlvblJlZ2lzdHJ5LmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMvbnVsbFRva2VuaXplLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMvc3VwcG9ydHMuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2xhbmd1YWdlcy9zdXBwb3J0cy9jaGFyYWN0ZXJQYWlyLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMvc3VwcG9ydHMvZWxlY3RyaWNDaGFyYWN0ZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2xhbmd1YWdlcy9zdXBwb3J0cy9pbmRlbnRSdWxlcy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbGFuZ3VhZ2VzL3N1cHBvcnRzL2xhbmd1YWdlQnJhY2tldHNDb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMvc3VwcG9ydHMvb25FbnRlci5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbGFuZ3VhZ2VzL3N1cHBvcnRzL3JpY2hFZGl0QnJhY2tldHMuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL2JyYWNrZXRQYWlyc1RleHRNb2RlbFBhcnQvYnJhY2tldFBhaXJzSW1wbC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvYnJhY2tldFBhaXJzVGV4dE1vZGVsUGFydC9icmFja2V0UGFpcnNUcmVlL2FzdC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvYnJhY2tldFBhaXJzVGV4dE1vZGVsUGFydC9icmFja2V0UGFpcnNUcmVlL2JlZm9yZUVkaXRQb3NpdGlvbk1hcHBlci5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvYnJhY2tldFBhaXJzVGV4dE1vZGVsUGFydC9icmFja2V0UGFpcnNUcmVlL2JyYWNrZXRQYWlyc1RyZWUuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL2JyYWNrZXRQYWlyc1RleHRNb2RlbFBhcnQvYnJhY2tldFBhaXJzVHJlZS9icmFja2V0cy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvYnJhY2tldFBhaXJzVGV4dE1vZGVsUGFydC9icmFja2V0UGFpcnNUcmVlL2NvbWJpbmVUZXh0RWRpdEluZm9zLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC9icmFja2V0UGFpcnNUZXh0TW9kZWxQYXJ0L2JyYWNrZXRQYWlyc1RyZWUvY29uY2F0MjNUcmVlcy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvYnJhY2tldFBhaXJzVGV4dE1vZGVsUGFydC9icmFja2V0UGFpcnNUcmVlL2xlbmd0aC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvYnJhY2tldFBhaXJzVGV4dE1vZGVsUGFydC9icmFja2V0UGFpcnNUcmVlL25vZGVSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL2JyYWNrZXRQYWlyc1RleHRNb2RlbFBhcnQvYnJhY2tldFBhaXJzVHJlZS9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL2JyYWNrZXRQYWlyc1RleHRNb2RlbFBhcnQvYnJhY2tldFBhaXJzVHJlZS9zbWFsbEltbXV0YWJsZVNldC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvYnJhY2tldFBhaXJzVGV4dE1vZGVsUGFydC9icmFja2V0UGFpcnNUcmVlL3Rva2VuaXplci5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvYnJhY2tldFBhaXJzVGV4dE1vZGVsUGFydC9jb2xvcml6ZWRCcmFja2V0UGFpcnNEZWNvcmF0aW9uUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL2VkaXRTdGFjay5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvZml4ZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvZ3VpZGVzVGV4dE1vZGVsUGFydC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvaW5kZW50YXRpb25HdWVzc2VyLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC9pbnRlcnZhbFRyZWUuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL3BpZWNlVHJlZVRleHRCdWZmZXIvcGllY2VUcmVlQmFzZS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvcGllY2VUcmVlVGV4dEJ1ZmZlci9waWVjZVRyZWVUZXh0QnVmZmVyLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC9waWVjZVRyZWVUZXh0QnVmZmVyL3BpZWNlVHJlZVRleHRCdWZmZXJCdWlsZGVyLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC9waWVjZVRyZWVUZXh0QnVmZmVyL3JiVHJlZUJhc2UuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL3RleHRNb2RlbC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvdGV4dE1vZGVsUGFydC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvdGV4dE1vZGVsVG9rZW5zLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC90b2tlbml6YXRpb25UZXh0TW9kZWxQYXJ0LmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC90b2tlbnMuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL3RyZWVTaXR0ZXJUb2tlbnMuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL3V0aWxzLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9tb2RlbFNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3RleHRSZXNvdXJjZUNvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3RyZWVTaXR0ZXJQYXJzZXJTZXJ2aWNlLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi90ZXh0TW9kZWxCcmFja2V0UGFpcnMuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3RleHRNb2RlbEV2ZW50cy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vdGV4dE1vZGVsR3VpZGVzLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi90b2tlbnMvY29udGlndW91c011bHRpbGluZVRva2Vucy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vdG9rZW5zL2NvbnRpZ3VvdXNNdWx0aWxpbmVUb2tlbnNCdWlsZGVyLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi90b2tlbnMvY29udGlndW91c1Rva2Vuc0VkaXRpbmcuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3Rva2Vucy9jb250aWd1b3VzVG9rZW5zU3RvcmUuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3Rva2Vucy9saW5lVG9rZW5zLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi90b2tlbnMvc3BhcnNlVG9rZW5zU3RvcmUuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9wbGF0Zm9ybS9pbnN0YW50aWF0aW9uL2NvbW1vbi9kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL3BsYXRmb3JtL2luc3RhbnRpYXRpb24vY29tbW9uL2V4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9wbGF0Zm9ybS91bmRvUmVkby9jb21tb24vdW5kb1JlZG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBMYXp5IH0gZnJvbSAnLi9sYXp5LmpzJztcbmNvbnN0IGhhc0J1ZmZlciA9ICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyk7XG5jb25zdCBpbmRleE9mVGFibGUgPSBuZXcgTGF6eSgoKSA9PiBuZXcgVWludDhBcnJheSgyNTYpKTtcbmxldCB0ZXh0RGVjb2RlcjtcbmV4cG9ydCBjbGFzcyBWU0J1ZmZlciB7XG4gICAgLyoqXG4gICAgICogV2hlbiBydW5uaW5nIGluIGEgbm9kZWpzIGNvbnRleHQsIGlmIGBhY3R1YWxgIGlzIG5vdCBhIG5vZGVqcyBCdWZmZXIsIHRoZSBiYWNraW5nIHN0b3JlIGZvclxuICAgICAqIHRoZSByZXR1cm5lZCBgVlNCdWZmZXJgIGluc3RhbmNlIG1pZ2h0IHVzZSBhIG5vZGVqcyBCdWZmZXIgYWxsb2NhdGVkIGZyb20gbm9kZSdzIEJ1ZmZlciBwb29sLFxuICAgICAqIHdoaWNoIGlzIG5vdCB0cmFuc2ZlcnJhYmxlLlxuICAgICAqL1xuICAgIHN0YXRpYyB3cmFwKGFjdHVhbCkge1xuICAgICAgICBpZiAoaGFzQnVmZmVyICYmICEoQnVmZmVyLmlzQnVmZmVyKGFjdHVhbCkpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjEwLngvZG9jcy9hcGkvYnVmZmVyLmh0bWwjYnVmZmVyX2NsYXNzX21ldGhvZF9idWZmZXJfZnJvbV9hcnJheWJ1ZmZlcl9ieXRlb2Zmc2V0X2xlbmd0aFxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgemVyby1jb3B5IEJ1ZmZlciB3cmFwcGVyIGFyb3VuZCB0aGUgQXJyYXlCdWZmZXIgcG9pbnRlZCB0byBieSB0aGUgVWludDhBcnJheVxuICAgICAgICAgICAgYWN0dWFsID0gQnVmZmVyLmZyb20oYWN0dWFsLmJ1ZmZlciwgYWN0dWFsLmJ5dGVPZmZzZXQsIGFjdHVhbC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZTQnVmZmVyKGFjdHVhbCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmIChoYXNCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0ZXh0RGVjb2Rlcikge1xuICAgICAgICAgICAgICAgIHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkVUludDE2TEUoc291cmNlLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKCgoc291cmNlW29mZnNldCArIDBdIDw8IDApID4+PiAwKSB8XG4gICAgICAgICgoc291cmNlW29mZnNldCArIDFdIDw8IDgpID4+PiAwKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JpdGVVSW50MTZMRShkZXN0aW5hdGlvbiwgdmFsdWUsIG9mZnNldCkge1xuICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDBdID0gKHZhbHVlICYgMGIxMTExMTExMSk7XG4gICAgdmFsdWUgPSB2YWx1ZSA+Pj4gODtcbiAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDBiMTExMTExMTEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVSW50MzJCRShzb3VyY2UsIG9mZnNldCkge1xuICAgIHJldHVybiAoc291cmNlW29mZnNldF0gKiAyICoqIDI0XG4gICAgICAgICsgc291cmNlW29mZnNldCArIDFdICogMiAqKiAxNlxuICAgICAgICArIHNvdXJjZVtvZmZzZXQgKyAyXSAqIDIgKiogOFxuICAgICAgICArIHNvdXJjZVtvZmZzZXQgKyAzXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JpdGVVSW50MzJCRShkZXN0aW5hdGlvbiwgdmFsdWUsIG9mZnNldCkge1xuICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDNdID0gdmFsdWU7XG4gICAgdmFsdWUgPSB2YWx1ZSA+Pj4gODtcbiAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAyXSA9IHZhbHVlO1xuICAgIHZhbHVlID0gdmFsdWUgPj4+IDg7XG4gICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgMV0gPSB2YWx1ZTtcbiAgICB2YWx1ZSA9IHZhbHVlID4+PiA4O1xuICAgIGRlc3RpbmF0aW9uW29mZnNldF0gPSB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkVUludDgoc291cmNlLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gc291cmNlW29mZnNldF07XG59XG5leHBvcnQgZnVuY3Rpb24gd3JpdGVVSW50OChkZXN0aW5hdGlvbiwgdmFsdWUsIG9mZnNldCkge1xuICAgIGRlc3RpbmF0aW9uW29mZnNldF0gPSB2YWx1ZTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcbi8qKlxuICogQSBjb2x1bW4gaW4gYSBwb3NpdGlvbiBpcyB0aGUgZ2FwIGJldHdlZW4gdHdvIGFkamFjZW50IGNoYXJhY3RlcnMuIFRoZSBtZXRob2RzIGhlcmVcbiAqIHdvcmsgd2l0aCBhIGNvbmNlcHQgY2FsbGVkIFwidmlzaWJsZSBjb2x1bW5cIi4gQSB2aXNpYmxlIGNvbHVtbiBpcyBhIHZlcnkgcm91Z2ggYXBwcm94aW1hdGlvblxuICogb2YgdGhlIGhvcml6b250YWwgc2NyZWVuIHBvc2l0aW9uIG9mIGEgY29sdW1uLiBGb3IgZXhhbXBsZSwgdXNpbmcgYSB0YWIgc2l6ZSBvZiA0OlxuICogYGBgdHh0XG4gKiB8PFRBQj58PFRBQj58VHxleHRcbiAqIHwgICAgIHwgICAgIHwgXFwtLS0tIGNvbHVtbiA9IDQsIHZpc2libGUgY29sdW1uID0gOVxuICogfCAgICAgfCAgICAgXFwtLS0tLS0gY29sdW1uID0gMywgdmlzaWJsZSBjb2x1bW4gPSA4XG4gKiB8ICAgICBcXC0tLS0tLS0tLS0tLSBjb2x1bW4gPSAyLCB2aXNpYmxlIGNvbHVtbiA9IDRcbiAqIFxcLS0tLS0tLS0tLS0tLS0tLS0tIGNvbHVtbiA9IDEsIHZpc2libGUgY29sdW1uID0gMFxuICogYGBgXG4gKlxuICogKipOT1RFKio6IFZpc3VhbCBjb2x1bW5zIGRvIG5vdCB3b3JrIHdlbGwgZm9yIFJUTCB0ZXh0IG9yIHZhcmlhYmxlLXdpZHRoIGZvbnRzIG9yIGNoYXJhY3RlcnMuXG4gKlxuICogKipOT1RFKio6IFRoZXNlIG1ldGhvZHMgd29yayBhbmQgbWFrZSBzZW5zZSBib3RoIG9uIHRoZSBtb2RlbCBhbmQgb24gdGhlIHZpZXcgbW9kZWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBDdXJzb3JDb2x1bW5zIHtcbiAgICBzdGF0aWMgX25leHRWaXNpYmxlQ29sdW1uKGNvZGVQb2ludCwgdmlzaWJsZUNvbHVtbiwgdGFiU2l6ZSkge1xuICAgICAgICBpZiAoY29kZVBvaW50ID09PSA5IC8qIENoYXJDb2RlLlRhYiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIEN1cnNvckNvbHVtbnMubmV4dFJlbmRlclRhYlN0b3AodmlzaWJsZUNvbHVtbiwgdGFiU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmluZ3MuaXNGdWxsV2lkdGhDaGFyYWN0ZXIoY29kZVBvaW50KSB8fCBzdHJpbmdzLmlzRW1vamlJbXByZWNpc2UoY29kZVBvaW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2libGVDb2x1bW4gKyAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlQ29sdW1uICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHZpc2libGUgY29sdW1uIGZyb20gYSBjb2x1bW4uXG4gICAgICogQHNlZSB7QGxpbmsgQ3Vyc29yQ29sdW1uc31cbiAgICAgKi9cbiAgICBzdGF0aWMgdmlzaWJsZUNvbHVtbkZyb21Db2x1bW4obGluZUNvbnRlbnQsIGNvbHVtbiwgdGFiU2l6ZSkge1xuICAgICAgICBjb25zdCB0ZXh0TGVuID0gTWF0aC5taW4oY29sdW1uIC0gMSwgbGluZUNvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGxpbmVDb250ZW50LnN1YnN0cmluZygwLCB0ZXh0TGVuKTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBuZXcgc3RyaW5ncy5HcmFwaGVtZUl0ZXJhdG9yKHRleHQpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgd2hpbGUgKCFpdGVyYXRvci5lb2woKSkge1xuICAgICAgICAgICAgY29uc3QgY29kZVBvaW50ID0gc3RyaW5ncy5nZXROZXh0Q29kZVBvaW50KHRleHQsIHRleHRMZW4sIGl0ZXJhdG9yLm9mZnNldCk7XG4gICAgICAgICAgICBpdGVyYXRvci5uZXh0R3JhcGhlbWVMZW5ndGgoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX25leHRWaXNpYmxlQ29sdW1uKGNvZGVQb2ludCwgcmVzdWx0LCB0YWJTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29sdW1uIGZyb20gYSB2aXNpYmxlIGNvbHVtbi5cbiAgICAgKiBAc2VlIHtAbGluayBDdXJzb3JDb2x1bW5zfVxuICAgICAqL1xuICAgIHN0YXRpYyBjb2x1bW5Gcm9tVmlzaWJsZUNvbHVtbihsaW5lQ29udGVudCwgdmlzaWJsZUNvbHVtbiwgdGFiU2l6ZSkge1xuICAgICAgICBpZiAodmlzaWJsZUNvbHVtbiA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lQ29udGVudExlbmd0aCA9IGxpbmVDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBuZXcgc3RyaW5ncy5HcmFwaGVtZUl0ZXJhdG9yKGxpbmVDb250ZW50KTtcbiAgICAgICAgbGV0IGJlZm9yZVZpc2libGVDb2x1bW4gPSAwO1xuICAgICAgICBsZXQgYmVmb3JlQ29sdW1uID0gMTtcbiAgICAgICAgd2hpbGUgKCFpdGVyYXRvci5lb2woKSkge1xuICAgICAgICAgICAgY29uc3QgY29kZVBvaW50ID0gc3RyaW5ncy5nZXROZXh0Q29kZVBvaW50KGxpbmVDb250ZW50LCBsaW5lQ29udGVudExlbmd0aCwgaXRlcmF0b3Iub2Zmc2V0KTtcbiAgICAgICAgICAgIGl0ZXJhdG9yLm5leHRHcmFwaGVtZUxlbmd0aCgpO1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJWaXNpYmxlQ29sdW1uID0gdGhpcy5fbmV4dFZpc2libGVDb2x1bW4oY29kZVBvaW50LCBiZWZvcmVWaXNpYmxlQ29sdW1uLCB0YWJTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGFmdGVyQ29sdW1uID0gaXRlcmF0b3Iub2Zmc2V0ICsgMTtcbiAgICAgICAgICAgIGlmIChhZnRlclZpc2libGVDb2x1bW4gPj0gdmlzaWJsZUNvbHVtbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZURlbHRhID0gdmlzaWJsZUNvbHVtbiAtIGJlZm9yZVZpc2libGVDb2x1bW47XG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJEZWx0YSA9IGFmdGVyVmlzaWJsZUNvbHVtbiAtIHZpc2libGVDb2x1bW47XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyRGVsdGEgPCBiZWZvcmVEZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXJDb2x1bW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlQ29sdW1uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlZm9yZVZpc2libGVDb2x1bW4gPSBhZnRlclZpc2libGVDb2x1bW47XG4gICAgICAgICAgICBiZWZvcmVDb2x1bW4gPSBhZnRlckNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3YWxrZWQgdGhlIGVudGlyZSBzdHJpbmdcbiAgICAgICAgcmV0dXJuIGxpbmVDb250ZW50TGVuZ3RoICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQVRURU5USU9OOiBUaGlzIHdvcmtzIHdpdGggMC1iYXNlZCBjb2x1bW5zIChhcyBvcHBvc2VkIHRvIHRoZSByZWd1bGFyIDEtYmFzZWQgY29sdW1ucylcbiAgICAgKiBAc2VlIHtAbGluayBDdXJzb3JDb2x1bW5zfVxuICAgICAqL1xuICAgIHN0YXRpYyBuZXh0UmVuZGVyVGFiU3RvcCh2aXNpYmxlQ29sdW1uLCB0YWJTaXplKSB7XG4gICAgICAgIHJldHVybiB2aXNpYmxlQ29sdW1uICsgdGFiU2l6ZSAtIHZpc2libGVDb2x1bW4gJSB0YWJTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBVFRFTlRJT046IFRoaXMgd29ya3Mgd2l0aCAwLWJhc2VkIGNvbHVtbnMgKGFzIG9wcG9zZWQgdG8gdGhlIHJlZ3VsYXIgMS1iYXNlZCBjb2x1bW5zKVxuICAgICAqIEBzZWUge0BsaW5rIEN1cnNvckNvbHVtbnN9XG4gICAgICovXG4gICAgc3RhdGljIG5leHRJbmRlbnRUYWJTdG9wKHZpc2libGVDb2x1bW4sIGluZGVudFNpemUpIHtcbiAgICAgICAgcmV0dXJuIHZpc2libGVDb2x1bW4gKyBpbmRlbnRTaXplIC0gdmlzaWJsZUNvbHVtbiAlIGluZGVudFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFUVEVOVElPTjogVGhpcyB3b3JrcyB3aXRoIDAtYmFzZWQgY29sdW1ucyAoYXMgb3Bwb3NlZCB0byB0aGUgcmVndWxhciAxLWJhc2VkIGNvbHVtbnMpXG4gICAgICogQHNlZSB7QGxpbmsgQ3Vyc29yQ29sdW1uc31cbiAgICAgKi9cbiAgICBzdGF0aWMgcHJldlJlbmRlclRhYlN0b3AoY29sdW1uLCB0YWJTaXplKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBjb2x1bW4gLSAxIC0gKGNvbHVtbiAtIDEpICUgdGFiU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFUVEVOVElPTjogVGhpcyB3b3JrcyB3aXRoIDAtYmFzZWQgY29sdW1ucyAoYXMgb3Bwb3NlZCB0byB0aGUgcmVndWxhciAxLWJhc2VkIGNvbHVtbnMpXG4gICAgICogQHNlZSB7QGxpbmsgQ3Vyc29yQ29sdW1uc31cbiAgICAgKi9cbiAgICBzdGF0aWMgcHJldkluZGVudFRhYlN0b3AoY29sdW1uLCBpbmRlbnRTaXplKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBjb2x1bW4gLSAxIC0gKGNvbHVtbiAtIDEpICUgaW5kZW50U2l6ZSk7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyBzdHJpbmdzIGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3N0cmluZ3MuanMnO1xuaW1wb3J0IHsgQ3Vyc29yQ29sdW1ucyB9IGZyb20gJy4vY3Vyc29yQ29sdW1ucy5qcyc7XG5mdW5jdGlvbiBfbm9ybWFsaXplSW5kZW50YXRpb25Gcm9tV2hpdGVzcGFjZShzdHIsIGluZGVudFNpemUsIGluc2VydFNwYWNlcykge1xuICAgIGxldCBzcGFjZXNDbnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KGkpID09PSAnXFx0Jykge1xuICAgICAgICAgICAgc3BhY2VzQ250ID0gQ3Vyc29yQ29sdW1ucy5uZXh0SW5kZW50VGFiU3RvcChzcGFjZXNDbnQsIGluZGVudFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3BhY2VzQ250Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGlmICghaW5zZXJ0U3BhY2VzKSB7XG4gICAgICAgIGNvbnN0IHRhYnNDbnQgPSBNYXRoLmZsb29yKHNwYWNlc0NudCAvIGluZGVudFNpemUpO1xuICAgICAgICBzcGFjZXNDbnQgPSBzcGFjZXNDbnQgJSBpbmRlbnRTaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnNDbnQ7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhY2VzQ250OyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9ICcgJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVJbmRlbnRhdGlvbihzdHIsIGluZGVudFNpemUsIGluc2VydFNwYWNlcykge1xuICAgIGxldCBmaXJzdE5vbldoaXRlc3BhY2VJbmRleCA9IHN0cmluZ3MuZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXgoc3RyKTtcbiAgICBpZiAoZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGZpcnN0Tm9uV2hpdGVzcGFjZUluZGV4ID0gc3RyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIF9ub3JtYWxpemVJbmRlbnRhdGlvbkZyb21XaGl0ZXNwYWNlKHN0ci5zdWJzdHJpbmcoMCwgZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXgpLCBpbmRlbnRTaXplLCBpbnNlcnRTcGFjZXMpICsgc3RyLnN1YnN0cmluZyhmaXJzdE5vbldoaXRlc3BhY2VJbmRleCk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7XG5pbXBvcnQgKiBhcyBwbGF0Zm9ybSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgKiBhcyBidWZmZXIgZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vYnVmZmVyLmpzJztcbmxldCBfdXRmMTZMRV9UZXh0RGVjb2RlcjtcbmZ1bmN0aW9uIGdldFVURjE2TEVfVGV4dERlY29kZXIoKSB7XG4gICAgaWYgKCFfdXRmMTZMRV9UZXh0RGVjb2Rlcikge1xuICAgICAgICBfdXRmMTZMRV9UZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcignVVRGLTE2TEUnKTtcbiAgICB9XG4gICAgcmV0dXJuIF91dGYxNkxFX1RleHREZWNvZGVyO1xufVxubGV0IF91dGYxNkJFX1RleHREZWNvZGVyO1xuZnVuY3Rpb24gZ2V0VVRGMTZCRV9UZXh0RGVjb2RlcigpIHtcbiAgICBpZiAoIV91dGYxNkJFX1RleHREZWNvZGVyKSB7XG4gICAgICAgIF91dGYxNkJFX1RleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCdVVEYtMTZCRScpO1xuICAgIH1cbiAgICByZXR1cm4gX3V0ZjE2QkVfVGV4dERlY29kZXI7XG59XG5sZXQgX3BsYXRmb3JtVGV4dERlY29kZXI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhdGZvcm1UZXh0RGVjb2RlcigpIHtcbiAgICBpZiAoIV9wbGF0Zm9ybVRleHREZWNvZGVyKSB7XG4gICAgICAgIF9wbGF0Zm9ybVRleHREZWNvZGVyID0gcGxhdGZvcm0uaXNMaXR0bGVFbmRpYW4oKSA/IGdldFVURjE2TEVfVGV4dERlY29kZXIoKSA6IGdldFVURjE2QkVfVGV4dERlY29kZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wbGF0Zm9ybVRleHREZWNvZGVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVVURjE2TEUoc291cmNlLCBvZmZzZXQsIGxlbikge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDE2QXJyYXkoc291cmNlLmJ1ZmZlciwgb2Zmc2V0LCBsZW4pO1xuICAgIGlmIChsZW4gPiAwICYmICh2aWV3WzBdID09PSAweEZFRkYgfHwgdmlld1swXSA9PT0gMHhGRkZFKSkge1xuICAgICAgICAvLyBVVEYxNiBzb21ldGltZXMgc3RhcnRzIHdpdGggYSBCT00gaHR0cHM6Ly9kZS53aWtpcGVkaWEub3JnL3dpa2kvQnl0ZV9PcmRlcl9NYXJrXG4gICAgICAgIC8vIEl0IGxvb2tzIGxpa2UgVGV4dERlY29kZXIuZGVjb2RlIHdpbGwgZWF0IHVwIGEgbGVhZGluZyBCT00gKDB4RkVGRiBvciAweEZGRkUpXG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdGhhdCBiZWhhdmlvciBiZWNhdXNlIHdlIGtub3cgdGhlIHN0cmluZyBpcyBVVEYxNkxFIGFuZCB0aGUgQk9NIHNob3VsZCBiZSBtYWludGFpbmVkXG4gICAgICAgIC8vIFNvIHdlIHVzZSB0aGUgbWFudWFsIGRlY29kZXJcbiAgICAgICAgcmV0dXJuIGNvbXBhdERlY29kZVVURjE2TEUoc291cmNlLCBvZmZzZXQsIGxlbik7XG4gICAgfVxuICAgIHJldHVybiBnZXRVVEYxNkxFX1RleHREZWNvZGVyKCkuZGVjb2RlKHZpZXcpO1xufVxuZnVuY3Rpb24gY29tcGF0RGVjb2RlVVRGMTZMRShzb3VyY2UsIG9mZnNldCwgbGVuKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHJlc3VsdExlbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGJ1ZmZlci5yZWFkVUludDE2TEUoc291cmNlLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xufVxuZXhwb3J0IGNsYXNzIFN0cmluZ0J1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHkgfCAwO1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgVWludDE2QXJyYXkodGhpcy5fY2FwYWNpdHkpO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZWRTdHJpbmdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYnVmZmVyTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlZFN0cmluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9idWZmZXJMZW5ndGggPSAwO1xuICAgIH1cbiAgICBidWlsZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBsZXRlZFN0cmluZ3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsdXNoQnVmZmVyKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGxldGVkU3RyaW5ncy5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRCdWZmZXIoKTtcbiAgICB9XG4gICAgX2J1aWxkQnVmZmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fYnVmZmVyTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLl9idWZmZXIuYnVmZmVyLCAwLCB0aGlzLl9idWZmZXJMZW5ndGgpO1xuICAgICAgICByZXR1cm4gZ2V0UGxhdGZvcm1UZXh0RGVjb2RlcigpLmRlY29kZSh2aWV3KTtcbiAgICB9XG4gICAgX2ZsdXNoQnVmZmVyKCkge1xuICAgICAgICBjb25zdCBidWZmZXJTdHJpbmcgPSB0aGlzLl9idWlsZEJ1ZmZlcigpO1xuICAgICAgICB0aGlzLl9idWZmZXJMZW5ndGggPSAwO1xuICAgICAgICBpZiAodGhpcy5fY29tcGxldGVkU3RyaW5ncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkU3RyaW5ncyA9IFtidWZmZXJTdHJpbmddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkU3RyaW5nc1t0aGlzLl9jb21wbGV0ZWRTdHJpbmdzLmxlbmd0aF0gPSBidWZmZXJTdHJpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kIGEgY2hhciBjb2RlICg8Ml4xNilcbiAgICAgKi9cbiAgICBhcHBlbmRDaGFyQ29kZShjaGFyQ29kZSkge1xuICAgICAgICBjb25zdCByZW1haW5pbmdTcGFjZSA9IHRoaXMuX2NhcGFjaXR5IC0gdGhpcy5fYnVmZmVyTGVuZ3RoO1xuICAgICAgICBpZiAocmVtYWluaW5nU3BhY2UgPD0gMSkge1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ1NwYWNlID09PSAwIHx8IHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXNoQnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZmVyW3RoaXMuX2J1ZmZlckxlbmd0aCsrXSA9IGNoYXJDb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYW4gQVNDSUkgY2hhciBjb2RlICg8Ml44KVxuICAgICAqL1xuICAgIGFwcGVuZEFTQ0lJQ2hhckNvZGUoY2hhckNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZlckxlbmd0aCA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIC8vIGJ1ZmZlciBpcyBmdWxsXG4gICAgICAgICAgICB0aGlzLl9mbHVzaEJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlclt0aGlzLl9idWZmZXJMZW5ndGgrK10gPSBjaGFyQ29kZTtcbiAgICB9XG4gICAgYXBwZW5kU3RyaW5nKHN0cikge1xuICAgICAgICBjb25zdCBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fYnVmZmVyTGVuZ3RoICsgc3RyTGVuID49IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgICAgICAgICAvLyBUaGlzIHN0cmluZyBkb2VzIG5vdCBmaXQgaW4gdGhlIHJlbWFpbmluZyBidWZmZXIgc3BhY2VcbiAgICAgICAgICAgIHRoaXMuX2ZsdXNoQnVmZmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRTdHJpbmdzW3RoaXMuX2NvbXBsZXRlZFN0cmluZ3MubGVuZ3RoXSA9IHN0cjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ckxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJbdGhpcy5fYnVmZmVyTGVuZ3RoKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9idWZmZXIuanMnO1xuaW1wb3J0IHsgZGVjb2RlVVRGMTZMRSB9IGZyb20gJy4vc3RyaW5nQnVpbGRlci5qcyc7XG5mdW5jdGlvbiBlc2NhcGVOZXdMaW5lKHN0cikge1xuICAgIHJldHVybiAoc3RyXG4gICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcbiAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKSk7XG59XG5leHBvcnQgY2xhc3MgVGV4dENoYW5nZSB7XG4gICAgZ2V0IG9sZExlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2xkVGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBvbGRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9sZFBvc2l0aW9uICsgdGhpcy5vbGRUZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IG5ld0xlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3VGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBuZXdFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld1Bvc2l0aW9uICsgdGhpcy5uZXdUZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob2xkUG9zaXRpb24sIG9sZFRleHQsIG5ld1Bvc2l0aW9uLCBuZXdUZXh0KSB7XG4gICAgICAgIHRoaXMub2xkUG9zaXRpb24gPSBvbGRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5vbGRUZXh0ID0gb2xkVGV4dDtcbiAgICAgICAgdGhpcy5uZXdQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgICAgICB0aGlzLm5ld1RleHQgPSBuZXdUZXh0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMub2xkVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBgKGluc2VydEAke3RoaXMub2xkUG9zaXRpb259IFwiJHtlc2NhcGVOZXdMaW5lKHRoaXMubmV3VGV4dCl9XCIpYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXdUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAoZGVsZXRlQCR7dGhpcy5vbGRQb3NpdGlvbn0gXCIke2VzY2FwZU5ld0xpbmUodGhpcy5vbGRUZXh0KX1cIilgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgKHJlcGxhY2VAJHt0aGlzLm9sZFBvc2l0aW9ufSBcIiR7ZXNjYXBlTmV3TGluZSh0aGlzLm9sZFRleHQpfVwiIHdpdGggXCIke2VzY2FwZU5ld0xpbmUodGhpcy5uZXdUZXh0KX1cIilgO1xuICAgIH1cbiAgICBzdGF0aWMgX3dyaXRlU3RyaW5nU2l6ZShzdHIpIHtcbiAgICAgICAgcmV0dXJuICg0ICsgMiAqIHN0ci5sZW5ndGgpO1xuICAgIH1cbiAgICBzdGF0aWMgX3dyaXRlU3RyaW5nKGIsIHN0ciwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGIsIGxlbiwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQxNkxFKGIsIHN0ci5jaGFyQ29kZUF0KGkpLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgc3RhdGljIF9yZWFkU3RyaW5nKGIsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKGIsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gZGVjb2RlVVRGMTZMRShiLCBvZmZzZXQsIGxlbik7XG4gICAgfVxuICAgIHdyaXRlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuICgrNCAvLyBvbGRQb3NpdGlvblxuICAgICAgICAgICAgKyA0IC8vIG5ld1Bvc2l0aW9uXG4gICAgICAgICAgICArIFRleHRDaGFuZ2UuX3dyaXRlU3RyaW5nU2l6ZSh0aGlzLm9sZFRleHQpXG4gICAgICAgICAgICArIFRleHRDaGFuZ2UuX3dyaXRlU3RyaW5nU2l6ZSh0aGlzLm5ld1RleHQpKTtcbiAgICB9XG4gICAgd3JpdGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGIsIHRoaXMub2xkUG9zaXRpb24sIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShiLCB0aGlzLm5ld1Bvc2l0aW9uLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgb2Zmc2V0ID0gVGV4dENoYW5nZS5fd3JpdGVTdHJpbmcoYiwgdGhpcy5vbGRUZXh0LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgPSBUZXh0Q2hhbmdlLl93cml0ZVN0cmluZyhiLCB0aGlzLm5ld1RleHQsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIHN0YXRpYyByZWFkKGIsIG9mZnNldCwgZGVzdCkge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUoYiwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gYnVmZmVyLnJlYWRVSW50MzJCRShiLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgY29uc3Qgb2xkVGV4dCA9IFRleHRDaGFuZ2UuX3JlYWRTdHJpbmcoYiwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IFRleHRDaGFuZ2UuX3dyaXRlU3RyaW5nU2l6ZShvbGRUZXh0KTtcbiAgICAgICAgY29uc3QgbmV3VGV4dCA9IFRleHRDaGFuZ2UuX3JlYWRTdHJpbmcoYiwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IFRleHRDaGFuZ2UuX3dyaXRlU3RyaW5nU2l6ZShuZXdUZXh0KTtcbiAgICAgICAgZGVzdC5wdXNoKG5ldyBUZXh0Q2hhbmdlKG9sZFBvc2l0aW9uLCBvbGRUZXh0LCBuZXdQb3NpdGlvbiwgbmV3VGV4dCkpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wcmVzc0NvbnNlY3V0aXZlVGV4dENoYW5nZXMocHJldkVkaXRzLCBjdXJyRWRpdHMpIHtcbiAgICBpZiAocHJldkVkaXRzID09PSBudWxsIHx8IHByZXZFZGl0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGN1cnJFZGl0cztcbiAgICB9XG4gICAgY29uc3QgY29tcHJlc3NvciA9IG5ldyBUZXh0Q2hhbmdlQ29tcHJlc3NvcihwcmV2RWRpdHMsIGN1cnJFZGl0cyk7XG4gICAgcmV0dXJuIGNvbXByZXNzb3IuY29tcHJlc3MoKTtcbn1cbmNsYXNzIFRleHRDaGFuZ2VDb21wcmVzc29yIHtcbiAgICBjb25zdHJ1Y3RvcihwcmV2RWRpdHMsIGN1cnJFZGl0cykge1xuICAgICAgICB0aGlzLl9wcmV2RWRpdHMgPSBwcmV2RWRpdHM7XG4gICAgICAgIHRoaXMuX2N1cnJFZGl0cyA9IGN1cnJFZGl0cztcbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuX3Jlc3VsdExlbiA9IDA7XG4gICAgICAgIHRoaXMuX3ByZXZMZW4gPSB0aGlzLl9wcmV2RWRpdHMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9wcmV2RGVsdGFPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLl9jdXJyTGVuID0gdGhpcy5fY3VyckVkaXRzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fY3VyckRlbHRhT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29tcHJlc3MoKSB7XG4gICAgICAgIGxldCBwcmV2SW5kZXggPSAwO1xuICAgICAgICBsZXQgY3VyckluZGV4ID0gMDtcbiAgICAgICAgbGV0IHByZXZFZGl0ID0gdGhpcy5fZ2V0UHJldihwcmV2SW5kZXgpO1xuICAgICAgICBsZXQgY3VyckVkaXQgPSB0aGlzLl9nZXRDdXJyKGN1cnJJbmRleCk7XG4gICAgICAgIHdoaWxlIChwcmV2SW5kZXggPCB0aGlzLl9wcmV2TGVuIHx8IGN1cnJJbmRleCA8IHRoaXMuX2N1cnJMZW4pIHtcbiAgICAgICAgICAgIGlmIChwcmV2RWRpdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjY2VwdEN1cnIoY3VyckVkaXQpO1xuICAgICAgICAgICAgICAgIGN1cnJFZGl0ID0gdGhpcy5fZ2V0Q3VycigrK2N1cnJJbmRleCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VyckVkaXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY2NlcHRQcmV2KHByZXZFZGl0KTtcbiAgICAgICAgICAgICAgICBwcmV2RWRpdCA9IHRoaXMuX2dldFByZXYoKytwcmV2SW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJFZGl0Lm9sZEVuZCA8PSBwcmV2RWRpdC5uZXdQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjY2VwdEN1cnIoY3VyckVkaXQpO1xuICAgICAgICAgICAgICAgIGN1cnJFZGl0ID0gdGhpcy5fZ2V0Q3VycigrK2N1cnJJbmRleCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkVkaXQubmV3RW5kIDw9IGN1cnJFZGl0Lm9sZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWNjZXB0UHJldihwcmV2RWRpdCk7XG4gICAgICAgICAgICAgICAgcHJldkVkaXQgPSB0aGlzLl9nZXRQcmV2KCsrcHJldkluZGV4KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyRWRpdC5vbGRQb3NpdGlvbiA8IHByZXZFZGl0Lm5ld1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2UxLCBlMl0gPSBUZXh0Q2hhbmdlQ29tcHJlc3Nvci5fc3BsaXRDdXJyKGN1cnJFZGl0LCBwcmV2RWRpdC5uZXdQb3NpdGlvbiAtIGN1cnJFZGl0Lm9sZFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY2NlcHRDdXJyKGUxKTtcbiAgICAgICAgICAgICAgICBjdXJyRWRpdCA9IGUyO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZFZGl0Lm5ld1Bvc2l0aW9uIDwgY3VyckVkaXQub2xkUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZTEsIGUyXSA9IFRleHRDaGFuZ2VDb21wcmVzc29yLl9zcGxpdFByZXYocHJldkVkaXQsIGN1cnJFZGl0Lm9sZFBvc2l0aW9uIC0gcHJldkVkaXQubmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjY2VwdFByZXYoZTEpO1xuICAgICAgICAgICAgICAgIHByZXZFZGl0ID0gZTI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBjdXJyRWRpdC5vbGRQb3NpdGlvbiA9PT0gcHJldkVkaXQubmV3UG9zaXRpb25cbiAgICAgICAgICAgIGxldCBtZXJnZVByZXY7XG4gICAgICAgICAgICBsZXQgbWVyZ2VDdXJyO1xuICAgICAgICAgICAgaWYgKGN1cnJFZGl0Lm9sZEVuZCA9PT0gcHJldkVkaXQubmV3RW5kKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VQcmV2ID0gcHJldkVkaXQ7XG4gICAgICAgICAgICAgICAgbWVyZ2VDdXJyID0gY3VyckVkaXQ7XG4gICAgICAgICAgICAgICAgcHJldkVkaXQgPSB0aGlzLl9nZXRQcmV2KCsrcHJldkluZGV4KTtcbiAgICAgICAgICAgICAgICBjdXJyRWRpdCA9IHRoaXMuX2dldEN1cnIoKytjdXJySW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyckVkaXQub2xkRW5kIDwgcHJldkVkaXQubmV3RW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2UxLCBlMl0gPSBUZXh0Q2hhbmdlQ29tcHJlc3Nvci5fc3BsaXRQcmV2KHByZXZFZGl0LCBjdXJyRWRpdC5vbGRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIG1lcmdlUHJldiA9IGUxO1xuICAgICAgICAgICAgICAgIG1lcmdlQ3VyciA9IGN1cnJFZGl0O1xuICAgICAgICAgICAgICAgIHByZXZFZGl0ID0gZTI7XG4gICAgICAgICAgICAgICAgY3VyckVkaXQgPSB0aGlzLl9nZXRDdXJyKCsrY3VyckluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtlMSwgZTJdID0gVGV4dENoYW5nZUNvbXByZXNzb3IuX3NwbGl0Q3VycihjdXJyRWRpdCwgcHJldkVkaXQubmV3TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBtZXJnZVByZXYgPSBwcmV2RWRpdDtcbiAgICAgICAgICAgICAgICBtZXJnZUN1cnIgPSBlMTtcbiAgICAgICAgICAgICAgICBwcmV2RWRpdCA9IHRoaXMuX2dldFByZXYoKytwcmV2SW5kZXgpO1xuICAgICAgICAgICAgICAgIGN1cnJFZGl0ID0gZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRbdGhpcy5fcmVzdWx0TGVuKytdID0gbmV3IFRleHRDaGFuZ2UobWVyZ2VQcmV2Lm9sZFBvc2l0aW9uLCBtZXJnZVByZXYub2xkVGV4dCwgbWVyZ2VDdXJyLm5ld1Bvc2l0aW9uLCBtZXJnZUN1cnIubmV3VGV4dCk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2RGVsdGFPZmZzZXQgKz0gbWVyZ2VQcmV2Lm5ld0xlbmd0aCAtIG1lcmdlUHJldi5vbGRMZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9jdXJyRGVsdGFPZmZzZXQgKz0gbWVyZ2VDdXJyLm5ld0xlbmd0aCAtIG1lcmdlQ3Vyci5vbGRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVyZ2VkID0gVGV4dENoYW5nZUNvbXByZXNzb3IuX21lcmdlKHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgIGNvbnN0IGNsZWFuZWQgPSBUZXh0Q2hhbmdlQ29tcHJlc3Nvci5fcmVtb3ZlTm9PcHMobWVyZ2VkKTtcbiAgICAgICAgcmV0dXJuIGNsZWFuZWQ7XG4gICAgfVxuICAgIF9hY2NlcHRDdXJyKGN1cnJFZGl0KSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdFt0aGlzLl9yZXN1bHRMZW4rK10gPSBUZXh0Q2hhbmdlQ29tcHJlc3Nvci5fcmViYXNlQ3Vycih0aGlzLl9wcmV2RGVsdGFPZmZzZXQsIGN1cnJFZGl0KTtcbiAgICAgICAgdGhpcy5fY3VyckRlbHRhT2Zmc2V0ICs9IGN1cnJFZGl0Lm5ld0xlbmd0aCAtIGN1cnJFZGl0Lm9sZExlbmd0aDtcbiAgICB9XG4gICAgX2dldEN1cnIoY3VyckluZGV4KSB7XG4gICAgICAgIHJldHVybiAoY3VyckluZGV4IDwgdGhpcy5fY3VyckxlbiA/IHRoaXMuX2N1cnJFZGl0c1tjdXJySW5kZXhdIDogbnVsbCk7XG4gICAgfVxuICAgIF9hY2NlcHRQcmV2KHByZXZFZGl0KSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdFt0aGlzLl9yZXN1bHRMZW4rK10gPSBUZXh0Q2hhbmdlQ29tcHJlc3Nvci5fcmViYXNlUHJldih0aGlzLl9jdXJyRGVsdGFPZmZzZXQsIHByZXZFZGl0KTtcbiAgICAgICAgdGhpcy5fcHJldkRlbHRhT2Zmc2V0ICs9IHByZXZFZGl0Lm5ld0xlbmd0aCAtIHByZXZFZGl0Lm9sZExlbmd0aDtcbiAgICB9XG4gICAgX2dldFByZXYocHJldkluZGV4KSB7XG4gICAgICAgIHJldHVybiAocHJldkluZGV4IDwgdGhpcy5fcHJldkxlbiA/IHRoaXMuX3ByZXZFZGl0c1twcmV2SW5kZXhdIDogbnVsbCk7XG4gICAgfVxuICAgIHN0YXRpYyBfcmViYXNlQ3VycihwcmV2RGVsdGFPZmZzZXQsIGN1cnJFZGl0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dENoYW5nZShjdXJyRWRpdC5vbGRQb3NpdGlvbiAtIHByZXZEZWx0YU9mZnNldCwgY3VyckVkaXQub2xkVGV4dCwgY3VyckVkaXQubmV3UG9zaXRpb24sIGN1cnJFZGl0Lm5ld1RleHQpO1xuICAgIH1cbiAgICBzdGF0aWMgX3JlYmFzZVByZXYoY3VyckRlbHRhT2Zmc2V0LCBwcmV2RWRpdCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRDaGFuZ2UocHJldkVkaXQub2xkUG9zaXRpb24sIHByZXZFZGl0Lm9sZFRleHQsIHByZXZFZGl0Lm5ld1Bvc2l0aW9uICsgY3VyckRlbHRhT2Zmc2V0LCBwcmV2RWRpdC5uZXdUZXh0KTtcbiAgICB9XG4gICAgc3RhdGljIF9zcGxpdFByZXYoZWRpdCwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHByZVRleHQgPSBlZGl0Lm5ld1RleHQuc3Vic3RyKDAsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHBvc3RUZXh0ID0gZWRpdC5uZXdUZXh0LnN1YnN0cihvZmZzZXQpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IFRleHRDaGFuZ2UoZWRpdC5vbGRQb3NpdGlvbiwgZWRpdC5vbGRUZXh0LCBlZGl0Lm5ld1Bvc2l0aW9uLCBwcmVUZXh0KSxcbiAgICAgICAgICAgIG5ldyBUZXh0Q2hhbmdlKGVkaXQub2xkRW5kLCAnJywgZWRpdC5uZXdQb3NpdGlvbiArIG9mZnNldCwgcG9zdFRleHQpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHN0YXRpYyBfc3BsaXRDdXJyKGVkaXQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBwcmVUZXh0ID0gZWRpdC5vbGRUZXh0LnN1YnN0cigwLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBwb3N0VGV4dCA9IGVkaXQub2xkVGV4dC5zdWJzdHIob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBUZXh0Q2hhbmdlKGVkaXQub2xkUG9zaXRpb24sIHByZVRleHQsIGVkaXQubmV3UG9zaXRpb24sIGVkaXQubmV3VGV4dCksXG4gICAgICAgICAgICBuZXcgVGV4dENoYW5nZShlZGl0Lm9sZFBvc2l0aW9uICsgb2Zmc2V0LCBwb3N0VGV4dCwgZWRpdC5uZXdFbmQsICcnKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBzdGF0aWMgX21lcmdlKGVkaXRzKSB7XG4gICAgICAgIGlmIChlZGl0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBlZGl0cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IHJlc3VsdExlbiA9IDA7XG4gICAgICAgIGxldCBwcmV2ID0gZWRpdHNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZWRpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBlZGl0c1tpXTtcbiAgICAgICAgICAgIGlmIChwcmV2Lm9sZEVuZCA9PT0gY3Vyci5vbGRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIE1lcmdlIGludG8gYHByZXZgXG4gICAgICAgICAgICAgICAgcHJldiA9IG5ldyBUZXh0Q2hhbmdlKHByZXYub2xkUG9zaXRpb24sIHByZXYub2xkVGV4dCArIGN1cnIub2xkVGV4dCwgcHJldi5uZXdQb3NpdGlvbiwgcHJldi5uZXdUZXh0ICsgY3Vyci5uZXdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBwcmV2O1xuICAgICAgICAgICAgICAgIHByZXYgPSBjdXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBwcmV2O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgX3JlbW92ZU5vT3BzKGVkaXRzKSB7XG4gICAgICAgIGlmIChlZGl0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBlZGl0cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IHJlc3VsdExlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXQgPSBlZGl0c1tpXTtcbiAgICAgICAgICAgIGlmIChlZGl0Lm9sZFRleHQgPT09IGVkaXQubmV3VGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IGVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBjb25zdCBFRElUT1JfTU9ERUxfREVGQVVMVFMgPSB7XG4gICAgdGFiU2l6ZTogNCxcbiAgICBpbmRlbnRTaXplOiA0LFxuICAgIGluc2VydFNwYWNlczogdHJ1ZSxcbiAgICBkZXRlY3RJbmRlbnRhdGlvbjogdHJ1ZSxcbiAgICB0cmltQXV0b1doaXRlc3BhY2U6IHRydWUsXG4gICAgbGFyZ2VGaWxlT3B0aW1pemF0aW9uczogdHJ1ZSxcbiAgICBicmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnM6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgaW5kZXBlbmRlbnRDb2xvclBvb2xQZXJCcmFja2V0VHlwZTogZmFsc2UsXG4gICAgfSxcbn07XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogRGVzY3JpYmVzIHdoYXQgdG8gZG8gd2l0aCB0aGUgaW5kZW50YXRpb24gd2hlbiBwcmVzc2luZyBFbnRlci5cbiAqL1xuZXhwb3J0IHZhciBJbmRlbnRBY3Rpb247XG4oZnVuY3Rpb24gKEluZGVudEFjdGlvbikge1xuICAgIC8qKlxuICAgICAqIEluc2VydCBuZXcgbGluZSBhbmQgY29weSB0aGUgcHJldmlvdXMgbGluZSdzIGluZGVudGF0aW9uLlxuICAgICAqL1xuICAgIEluZGVudEFjdGlvbltJbmRlbnRBY3Rpb25bXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgbmV3IGxpbmUgYW5kIGluZGVudCBvbmNlIChyZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgbGluZSdzIGluZGVudGF0aW9uKS5cbiAgICAgKi9cbiAgICBJbmRlbnRBY3Rpb25bSW5kZW50QWN0aW9uW1wiSW5kZW50XCJdID0gMV0gPSBcIkluZGVudFwiO1xuICAgIC8qKlxuICAgICAqIEluc2VydCB0d28gbmV3IGxpbmVzOlxuICAgICAqICAtIHRoZSBmaXJzdCBvbmUgaW5kZW50ZWQgd2hpY2ggd2lsbCBob2xkIHRoZSBjdXJzb3JcbiAgICAgKiAgLSB0aGUgc2Vjb25kIG9uZSBhdCB0aGUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbFxuICAgICAqL1xuICAgIEluZGVudEFjdGlvbltJbmRlbnRBY3Rpb25bXCJJbmRlbnRPdXRkZW50XCJdID0gMl0gPSBcIkluZGVudE91dGRlbnRcIjtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgbmV3IGxpbmUgYW5kIG91dGRlbnQgb25jZSAocmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIGxpbmUncyBpbmRlbnRhdGlvbikuXG4gICAgICovXG4gICAgSW5kZW50QWN0aW9uW0luZGVudEFjdGlvbltcIk91dGRlbnRcIl0gPSAzXSA9IFwiT3V0ZGVudFwiO1xufSkoSW5kZW50QWN0aW9uIHx8IChJbmRlbnRBY3Rpb24gPSB7fSkpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFN0YW5kYXJkQXV0b0Nsb3NpbmdQYWlyQ29uZGl0aW9uYWwge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICB0aGlzLl9uZXV0cmFsQ2hhcmFjdGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmV1dHJhbENoYXJhY3RlclNlYXJjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3BlbiA9IHNvdXJjZS5vcGVuO1xuICAgICAgICB0aGlzLmNsb3NlID0gc291cmNlLmNsb3NlO1xuICAgICAgICAvLyBpbml0aWFsbHkgYWxsb3dlZCBpbiBhbGwgdG9rZW5zXG4gICAgICAgIHRoaXMuX2luU3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW5Db21tZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW5SZWdFeCA9IHRydWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZS5ub3RJbikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzb3VyY2Uubm90SW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RJbiA9IHNvdXJjZS5ub3RJbltpXTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vdEluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pblN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5Db21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVnZXgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5SZWdFeCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlzT0soc3RhbmRhcmRUb2tlbikge1xuICAgICAgICBzd2l0Y2ggKHN0YW5kYXJkVG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBTdGFuZGFyZFRva2VuVHlwZS5PdGhlciAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBTdGFuZGFyZFRva2VuVHlwZS5Db21tZW50ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbkNvbW1lbnQ7XG4gICAgICAgICAgICBjYXNlIDIgLyogU3RhbmRhcmRUb2tlblR5cGUuU3RyaW5nICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pblN0cmluZztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTdGFuZGFyZFRva2VuVHlwZS5SZWdFeCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5SZWdFeDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG91bGRBdXRvQ2xvc2UoY29udGV4dCwgY29sdW1uKSB7XG4gICAgICAgIC8vIEFsd2F5cyBjb21wbGV0ZSBvbiBlbXB0eSBsaW5lXG4gICAgICAgIGlmIChjb250ZXh0LmdldFRva2VuQ291bnQoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW5JbmRleCA9IGNvbnRleHQuZmluZFRva2VuSW5kZXhBdE9mZnNldChjb2x1bW4gLSAyKTtcbiAgICAgICAgY29uc3Qgc3RhbmRhcmRUb2tlblR5cGUgPSBjb250ZXh0LmdldFN0YW5kYXJkVG9rZW5UeXBlKHRva2VuSW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc09LKHN0YW5kYXJkVG9rZW5UeXBlKTtcbiAgICB9XG4gICAgX2ZpbmROZXV0cmFsQ2hhcmFjdGVySW5SYW5nZShmcm9tQ2hhckNvZGUsIHRvQ2hhckNvZGUpIHtcbiAgICAgICAgZm9yIChsZXQgY2hhckNvZGUgPSBmcm9tQ2hhckNvZGU7IGNoYXJDb2RlIDw9IHRvQ2hhckNvZGU7IGNoYXJDb2RlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW4uaW5jbHVkZXMoY2hhcmFjdGVyKSAmJiAhdGhpcy5jbG9zZS5pbmNsdWRlcyhjaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJhY3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhIGNoYXJhY3RlciBpbiB0aGUgcmFuZ2UgWzAtOWEtekEtWl0gdGhhdCBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIG9wZW4gb3IgY2xvc2VcbiAgICAgKi9cbiAgICBmaW5kTmV1dHJhbENoYXJhY3RlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9uZXV0cmFsQ2hhcmFjdGVyU2VhcmNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25ldXRyYWxDaGFyYWN0ZXJTZWFyY2hlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX25ldXRyYWxDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXV0cmFsQ2hhcmFjdGVyID0gdGhpcy5fZmluZE5ldXRyYWxDaGFyYWN0ZXJJblJhbmdlKDQ4IC8qIENoYXJDb2RlLkRpZ2l0MCAqLywgNTcgLyogQ2hhckNvZGUuRGlnaXQ5ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fbmV1dHJhbENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX25ldXRyYWxDaGFyYWN0ZXIgPSB0aGlzLl9maW5kTmV1dHJhbENoYXJhY3RlckluUmFuZ2UoOTcgLyogQ2hhckNvZGUuYSAqLywgMTIyIC8qIENoYXJDb2RlLnogKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9uZXV0cmFsQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV1dHJhbENoYXJhY3RlciA9IHRoaXMuX2ZpbmROZXV0cmFsQ2hhcmFjdGVySW5SYW5nZSg2NSAvKiBDaGFyQ29kZS5BICovLCA5MCAvKiBDaGFyQ29kZS5aICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbmV1dHJhbENoYXJhY3RlcjtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQXV0b0Nsb3NpbmdQYWlycyB7XG4gICAgY29uc3RydWN0b3IoYXV0b0Nsb3NpbmdQYWlycykge1xuICAgICAgICB0aGlzLmF1dG9DbG9zaW5nUGFpcnNPcGVuQnlTdGFydCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hdXRvQ2xvc2luZ1BhaXJzT3BlbkJ5RW5kID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmF1dG9DbG9zaW5nUGFpcnNDbG9zZUJ5U3RhcnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYXV0b0Nsb3NpbmdQYWlyc0Nsb3NlQnlFbmQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYXV0b0Nsb3NpbmdQYWlyc0Nsb3NlU2luZ2xlQ2hhciA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIGF1dG9DbG9zaW5nUGFpcnMpIHtcbiAgICAgICAgICAgIGFwcGVuZEVudHJ5KHRoaXMuYXV0b0Nsb3NpbmdQYWlyc09wZW5CeVN0YXJ0LCBwYWlyLm9wZW4uY2hhckF0KDApLCBwYWlyKTtcbiAgICAgICAgICAgIGFwcGVuZEVudHJ5KHRoaXMuYXV0b0Nsb3NpbmdQYWlyc09wZW5CeUVuZCwgcGFpci5vcGVuLmNoYXJBdChwYWlyLm9wZW4ubGVuZ3RoIC0gMSksIHBhaXIpO1xuICAgICAgICAgICAgYXBwZW5kRW50cnkodGhpcy5hdXRvQ2xvc2luZ1BhaXJzQ2xvc2VCeVN0YXJ0LCBwYWlyLmNsb3NlLmNoYXJBdCgwKSwgcGFpcik7XG4gICAgICAgICAgICBhcHBlbmRFbnRyeSh0aGlzLmF1dG9DbG9zaW5nUGFpcnNDbG9zZUJ5RW5kLCBwYWlyLmNsb3NlLmNoYXJBdChwYWlyLmNsb3NlLmxlbmd0aCAtIDEpLCBwYWlyKTtcbiAgICAgICAgICAgIGlmIChwYWlyLmNsb3NlLmxlbmd0aCA9PT0gMSAmJiBwYWlyLm9wZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kRW50cnkodGhpcy5hdXRvQ2xvc2luZ1BhaXJzQ2xvc2VTaW5nbGVDaGFyLCBwYWlyLmNsb3NlLCBwYWlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZEVudHJ5KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgIGlmICh0YXJnZXQuaGFzKGtleSkpIHtcbiAgICAgICAgdGFyZ2V0LmdldChrZXkpLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LnNldChrZXksIFt2YWx1ZV0pO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZXZlbnQuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSwgdG9EaXNwb3NhYmxlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7XG5pbXBvcnQgeyBERUZBVUxUX1dPUkRfUkVHRVhQLCBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uIH0gZnJvbSAnLi4vY29yZS93b3JkSGVscGVyLmpzJztcbmltcG9ydCB7IEF1dG9DbG9zaW5nUGFpcnMgfSBmcm9tICcuL2xhbmd1YWdlQ29uZmlndXJhdGlvbi5qcyc7XG5pbXBvcnQgeyBDaGFyYWN0ZXJQYWlyU3VwcG9ydCB9IGZyb20gJy4vc3VwcG9ydHMvY2hhcmFjdGVyUGFpci5qcyc7XG5pbXBvcnQgeyBCcmFja2V0RWxlY3RyaWNDaGFyYWN0ZXJTdXBwb3J0IH0gZnJvbSAnLi9zdXBwb3J0cy9lbGVjdHJpY0NoYXJhY3Rlci5qcyc7XG5pbXBvcnQgeyBJbmRlbnRSdWxlc1N1cHBvcnQgfSBmcm9tICcuL3N1cHBvcnRzL2luZGVudFJ1bGVzLmpzJztcbmltcG9ydCB7IE9uRW50ZXJTdXBwb3J0IH0gZnJvbSAnLi9zdXBwb3J0cy9vbkVudGVyLmpzJztcbmltcG9ydCB7IFJpY2hFZGl0QnJhY2tldHMgfSBmcm9tICcuL3N1cHBvcnRzL3JpY2hFZGl0QnJhY2tldHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlRGVjb3JhdG9yIH0gZnJvbSAnLi4vLi4vLi4vcGxhdGZvcm0vaW5zdGFudGlhdGlvbi9jb21tb24vaW5zdGFudGlhdGlvbi5qcyc7XG5pbXBvcnQgeyBJQ29uZmlndXJhdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9wbGF0Zm9ybS9jb25maWd1cmF0aW9uL2NvbW1vbi9jb25maWd1cmF0aW9uLmpzJztcbmltcG9ydCB7IElMYW5ndWFnZVNlcnZpY2UgfSBmcm9tICcuL2xhbmd1YWdlLmpzJztcbmltcG9ydCB7IHJlZ2lzdGVyU2luZ2xldG9uIH0gZnJvbSAnLi4vLi4vLi4vcGxhdGZvcm0vaW5zdGFudGlhdGlvbi9jb21tb24vZXh0ZW5zaW9ucy5qcyc7XG5pbXBvcnQgeyBQTEFJTlRFWFRfTEFOR1VBR0VfSUQgfSBmcm9tICcuL21vZGVzUmVnaXN0cnkuanMnO1xuaW1wb3J0IHsgTGFuZ3VhZ2VCcmFja2V0c0NvbmZpZ3VyYXRpb24gfSBmcm9tICcuL3N1cHBvcnRzL2xhbmd1YWdlQnJhY2tldHNDb25maWd1cmF0aW9uLmpzJztcbmV4cG9ydCBjbGFzcyBMYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlQ2hhbmdlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGxhbmd1YWdlSWQpIHtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICB9XG4gICAgYWZmZWN0cyhsYW5ndWFnZUlkKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5sYW5ndWFnZUlkID8gdHJ1ZSA6IHRoaXMubGFuZ3VhZ2VJZCA9PT0gbGFuZ3VhZ2VJZDtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgSUxhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UgPSBjcmVhdGVEZWNvcmF0b3IoJ2xhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UnKTtcbmxldCBMYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY2xhc3MgTGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZSBleHRlbmRzIERpc3Bvc2FibGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBsYW5ndWFnZVNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmxhbmd1YWdlU2VydmljZSA9IGxhbmd1YWdlU2VydmljZTtcbiAgICAgICAgdGhpcy5fcmVnaXN0cnkgPSB0aGlzLl9yZWdpc3RlcihuZXcgTGFuZ3VhZ2VDb25maWd1cmF0aW9uUmVnaXN0cnkoKSk7XG4gICAgICAgIHRoaXMub25EaWRDaGFuZ2VFbWl0dGVyID0gdGhpcy5fcmVnaXN0ZXIobmV3IEVtaXR0ZXIoKSk7XG4gICAgICAgIHRoaXMub25EaWRDaGFuZ2UgPSB0aGlzLm9uRGlkQ2hhbmdlRW1pdHRlci5ldmVudDtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VDb25maWdLZXlzID0gbmV3IFNldChPYmplY3QudmFsdWVzKGN1c3RvbWl6ZWRMYW5ndWFnZUNvbmZpZ0tleXMpKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXIodGhpcy5jb25maWd1cmF0aW9uU2VydmljZS5vbkRpZENoYW5nZUNvbmZpZ3VyYXRpb24oKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbENvbmZpZ0NoYW5nZWQgPSBlLmNoYW5nZS5rZXlzLnNvbWUoKGspID0+IGxhbmd1YWdlQ29uZmlnS2V5cy5oYXMoaykpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxDb25maWdDaGFuZ2VkID0gZS5jaGFuZ2Uub3ZlcnJpZGVzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoW292ZXJyaWRlTGFuZ05hbWUsIGtleXNdKSA9PiBrZXlzLnNvbWUoKGspID0+IGxhbmd1YWdlQ29uZmlnS2V5cy5oYXMoaykpKVxuICAgICAgICAgICAgICAgIC5tYXAoKFtvdmVycmlkZUxhbmdOYW1lXSkgPT4gb3ZlcnJpZGVMYW5nTmFtZSk7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsQ29uZmlnQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlRW1pdHRlci5maXJlKG5ldyBMYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlQ2hhbmdlRXZlbnQodW5kZWZpbmVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxhbmd1YWdlSWQgb2YgbG9jYWxDb25maWdDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhbmd1YWdlU2VydmljZS5pc1JlZ2lzdGVyZWRMYW5ndWFnZUlkKGxhbmd1YWdlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25zLmRlbGV0ZShsYW5ndWFnZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25EaWRDaGFuZ2VFbWl0dGVyLmZpcmUobmV3IExhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2VDaGFuZ2VFdmVudChsYW5ndWFnZUlkKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXIodGhpcy5fcmVnaXN0cnkub25EaWRDaGFuZ2UoKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbnMuZGVsZXRlKGUubGFuZ3VhZ2VJZCk7XG4gICAgICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlRW1pdHRlci5maXJlKG5ldyBMYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlQ2hhbmdlRXZlbnQoZS5sYW5ndWFnZUlkKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIobGFuZ3VhZ2VJZCwgY29uZmlndXJhdGlvbiwgcHJpb3JpdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5LnJlZ2lzdGVyKGxhbmd1YWdlSWQsIGNvbmZpZ3VyYXRpb24sIHByaW9yaXR5KTtcbiAgICB9XG4gICAgZ2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uKGxhbmd1YWdlSWQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY29uZmlndXJhdGlvbnMuZ2V0KGxhbmd1YWdlSWQpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZUNvbmZpZyhsYW5ndWFnZUlkLCB0aGlzLl9yZWdpc3RyeSwgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSwgdGhpcy5sYW5ndWFnZVNlcnZpY2UpO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9ucy5zZXQobGFuZ3VhZ2VJZCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5MYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBJQ29uZmlndXJhdGlvblNlcnZpY2UpLFxuICAgIF9fcGFyYW0oMSwgSUxhbmd1YWdlU2VydmljZSlcbl0sIExhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UpO1xuZXhwb3J0IHsgTGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZSB9O1xuZnVuY3Rpb24gY29tcHV0ZUNvbmZpZyhsYW5ndWFnZUlkLCByZWdpc3RyeSwgY29uZmlndXJhdGlvblNlcnZpY2UsIGxhbmd1YWdlU2VydmljZSkge1xuICAgIGxldCBsYW5ndWFnZUNvbmZpZyA9IHJlZ2lzdHJ5LmdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKTtcbiAgICBpZiAoIWxhbmd1YWdlQ29uZmlnKSB7XG4gICAgICAgIGlmICghbGFuZ3VhZ2VTZXJ2aWNlLmlzUmVnaXN0ZXJlZExhbmd1YWdlSWQobGFuZ3VhZ2VJZCkpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBmb3IgdGhlIG51bGwgbGFuZ3VhZ2UsIHdoaWNoIGNhbiBiZSByZXR1cm5lZCBieSBtb25hcmNoLlxuICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvciwgd2UganVzdCByZXR1cm4gYSBkZWZhdWx0IGNvbmZpZy5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRMYW5ndWFnZUNvbmZpZ3VyYXRpb24obGFuZ3VhZ2VJZCwge30pO1xuICAgICAgICB9XG4gICAgICAgIGxhbmd1YWdlQ29uZmlnID0gbmV3IFJlc29sdmVkTGFuZ3VhZ2VDb25maWd1cmF0aW9uKGxhbmd1YWdlSWQsIHt9KTtcbiAgICB9XG4gICAgY29uc3QgY3VzdG9taXplZENvbmZpZyA9IGdldEN1c3RvbWl6ZWRMYW5ndWFnZUNvbmZpZyhsYW5ndWFnZUNvbmZpZy5sYW5ndWFnZUlkLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgY29uc3QgZGF0YSA9IGNvbWJpbmVMYW5ndWFnZUNvbmZpZ3VyYXRpb25zKFtsYW5ndWFnZUNvbmZpZy51bmRlcmx5aW5nQ29uZmlnLCBjdXN0b21pemVkQ29uZmlnXSk7XG4gICAgY29uc3QgY29uZmlnID0gbmV3IFJlc29sdmVkTGFuZ3VhZ2VDb25maWd1cmF0aW9uKGxhbmd1YWdlQ29uZmlnLmxhbmd1YWdlSWQsIGRhdGEpO1xuICAgIHJldHVybiBjb25maWc7XG59XG5jb25zdCBjdXN0b21pemVkTGFuZ3VhZ2VDb25maWdLZXlzID0ge1xuICAgIGJyYWNrZXRzOiAnZWRpdG9yLmxhbmd1YWdlLmJyYWNrZXRzJyxcbiAgICBjb2xvcml6ZWRCcmFja2V0UGFpcnM6ICdlZGl0b3IubGFuZ3VhZ2UuY29sb3JpemVkQnJhY2tldFBhaXJzJ1xufTtcbmZ1bmN0aW9uIGdldEN1c3RvbWl6ZWRMYW5ndWFnZUNvbmZpZyhsYW5ndWFnZUlkLCBjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgIGNvbnN0IGJyYWNrZXRzID0gY29uZmlndXJhdGlvblNlcnZpY2UuZ2V0VmFsdWUoY3VzdG9taXplZExhbmd1YWdlQ29uZmlnS2V5cy5icmFja2V0cywge1xuICAgICAgICBvdmVycmlkZUlkZW50aWZpZXI6IGxhbmd1YWdlSWQsXG4gICAgfSk7XG4gICAgY29uc3QgY29sb3JpemVkQnJhY2tldFBhaXJzID0gY29uZmlndXJhdGlvblNlcnZpY2UuZ2V0VmFsdWUoY3VzdG9taXplZExhbmd1YWdlQ29uZmlnS2V5cy5jb2xvcml6ZWRCcmFja2V0UGFpcnMsIHtcbiAgICAgICAgb3ZlcnJpZGVJZGVudGlmaWVyOiBsYW5ndWFnZUlkLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJyYWNrZXRzOiB2YWxpZGF0ZUJyYWNrZXRQYWlycyhicmFja2V0cyksXG4gICAgICAgIGNvbG9yaXplZEJyYWNrZXRQYWlyczogdmFsaWRhdGVCcmFja2V0UGFpcnMoY29sb3JpemVkQnJhY2tldFBhaXJzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVCcmFja2V0UGFpcnMoZGF0YSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5tYXAocGFpciA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYWlyKSB8fCBwYWlyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3BhaXJbMF0sIHBhaXJbMV1dO1xuICAgIH0pLmZpbHRlcigocCkgPT4gISFwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRlbnRhdGlvbkF0UG9zaXRpb24obW9kZWwsIGxpbmVOdW1iZXIsIGNvbHVtbikge1xuICAgIGNvbnN0IGxpbmVUZXh0ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcik7XG4gICAgbGV0IGluZGVudGF0aW9uID0gc3RyaW5ncy5nZXRMZWFkaW5nV2hpdGVzcGFjZShsaW5lVGV4dCk7XG4gICAgaWYgKGluZGVudGF0aW9uLmxlbmd0aCA+IGNvbHVtbiAtIDEpIHtcbiAgICAgICAgaW5kZW50YXRpb24gPSBpbmRlbnRhdGlvbi5zdWJzdHJpbmcoMCwgY29sdW1uIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBpbmRlbnRhdGlvbjtcbn1cbmNsYXNzIENvbXBvc2VkTGFuZ3VhZ2VDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihsYW5ndWFnZUlkKSB7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2VJZCA9IGxhbmd1YWdlSWQ7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZW50cmllcyA9IFtdO1xuICAgICAgICB0aGlzLl9vcmRlciA9IDA7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkID0gbnVsbDtcbiAgICB9XG4gICAgcmVnaXN0ZXIoY29uZmlndXJhdGlvbiwgcHJpb3JpdHkpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBuZXcgTGFuZ3VhZ2VDb25maWd1cmF0aW9uQ29udHJpYnV0aW9uKGNvbmZpZ3VyYXRpb24sIHByaW9yaXR5LCArK3RoaXMuX29yZGVyKTtcbiAgICAgICAgdGhpcy5fZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdG9EaXNwb3NhYmxlKCgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbnRyaWVzW2ldID09PSBlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbnRyaWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRSZXNvbHZlZENvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlZCA9IG5ldyBSZXNvbHZlZExhbmd1YWdlQ29uZmlndXJhdGlvbih0aGlzLmxhbmd1YWdlSWQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkO1xuICAgIH1cbiAgICBfcmVzb2x2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbnRyaWVzLnNvcnQoTGFuZ3VhZ2VDb25maWd1cmF0aW9uQ29udHJpYnV0aW9uLmNtcCk7XG4gICAgICAgIHJldHVybiBjb21iaW5lTGFuZ3VhZ2VDb25maWd1cmF0aW9ucyh0aGlzLl9lbnRyaWVzLm1hcChlID0+IGUuY29uZmlndXJhdGlvbikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbWJpbmVMYW5ndWFnZUNvbmZpZ3VyYXRpb25zKGNvbmZpZ3MpIHtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBjb21tZW50czogdW5kZWZpbmVkLFxuICAgICAgICBicmFja2V0czogdW5kZWZpbmVkLFxuICAgICAgICB3b3JkUGF0dGVybjogdW5kZWZpbmVkLFxuICAgICAgICBpbmRlbnRhdGlvblJ1bGVzOiB1bmRlZmluZWQsXG4gICAgICAgIG9uRW50ZXJSdWxlczogdW5kZWZpbmVkLFxuICAgICAgICBhdXRvQ2xvc2luZ1BhaXJzOiB1bmRlZmluZWQsXG4gICAgICAgIHN1cnJvdW5kaW5nUGFpcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgYXV0b0Nsb3NlQmVmb3JlOiB1bmRlZmluZWQsXG4gICAgICAgIGZvbGRpbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgY29sb3JpemVkQnJhY2tldFBhaXJzOiB1bmRlZmluZWQsXG4gICAgICAgIF9fZWxlY3RyaWNDaGFyYWN0ZXJTdXBwb3J0OiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY29tbWVudHM6IGVudHJ5LmNvbW1lbnRzIHx8IHJlc3VsdC5jb21tZW50cyxcbiAgICAgICAgICAgIGJyYWNrZXRzOiBlbnRyeS5icmFja2V0cyB8fCByZXN1bHQuYnJhY2tldHMsXG4gICAgICAgICAgICB3b3JkUGF0dGVybjogZW50cnkud29yZFBhdHRlcm4gfHwgcmVzdWx0LndvcmRQYXR0ZXJuLFxuICAgICAgICAgICAgaW5kZW50YXRpb25SdWxlczogZW50cnkuaW5kZW50YXRpb25SdWxlcyB8fCByZXN1bHQuaW5kZW50YXRpb25SdWxlcyxcbiAgICAgICAgICAgIG9uRW50ZXJSdWxlczogZW50cnkub25FbnRlclJ1bGVzIHx8IHJlc3VsdC5vbkVudGVyUnVsZXMsXG4gICAgICAgICAgICBhdXRvQ2xvc2luZ1BhaXJzOiBlbnRyeS5hdXRvQ2xvc2luZ1BhaXJzIHx8IHJlc3VsdC5hdXRvQ2xvc2luZ1BhaXJzLFxuICAgICAgICAgICAgc3Vycm91bmRpbmdQYWlyczogZW50cnkuc3Vycm91bmRpbmdQYWlycyB8fCByZXN1bHQuc3Vycm91bmRpbmdQYWlycyxcbiAgICAgICAgICAgIGF1dG9DbG9zZUJlZm9yZTogZW50cnkuYXV0b0Nsb3NlQmVmb3JlIHx8IHJlc3VsdC5hdXRvQ2xvc2VCZWZvcmUsXG4gICAgICAgICAgICBmb2xkaW5nOiBlbnRyeS5mb2xkaW5nIHx8IHJlc3VsdC5mb2xkaW5nLFxuICAgICAgICAgICAgY29sb3JpemVkQnJhY2tldFBhaXJzOiBlbnRyeS5jb2xvcml6ZWRCcmFja2V0UGFpcnMgfHwgcmVzdWx0LmNvbG9yaXplZEJyYWNrZXRQYWlycyxcbiAgICAgICAgICAgIF9fZWxlY3RyaWNDaGFyYWN0ZXJTdXBwb3J0OiBlbnRyeS5fX2VsZWN0cmljQ2hhcmFjdGVyU3VwcG9ydCB8fCByZXN1bHQuX19lbGVjdHJpY0NoYXJhY3RlclN1cHBvcnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBMYW5ndWFnZUNvbmZpZ3VyYXRpb25Db250cmlidXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24sIHByaW9yaXR5LCBvcmRlcikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgIHRoaXMub3JkZXIgPSBvcmRlcjtcbiAgICB9XG4gICAgc3RhdGljIGNtcChhLCBiKSB7XG4gICAgICAgIGlmIChhLnByaW9yaXR5ID09PSBiLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAvLyBoaWdoZXIgb3JkZXIgbGFzdFxuICAgICAgICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhpZ2hlciBwcmlvcml0eSBsYXN0XG4gICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTGFuZ3VhZ2VDb25maWd1cmF0aW9uQ2hhbmdlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGxhbmd1YWdlSWQpIHtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTGFuZ3VhZ2VDb25maWd1cmF0aW9uUmVnaXN0cnkgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZW50cmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2UgPSB0aGlzLl9yZWdpc3RlcihuZXcgRW1pdHRlcigpKTtcbiAgICAgICAgdGhpcy5vbkRpZENoYW5nZSA9IHRoaXMuX29uRGlkQ2hhbmdlLmV2ZW50O1xuICAgICAgICB0aGlzLl9yZWdpc3Rlcih0aGlzLnJlZ2lzdGVyKFBMQUlOVEVYVF9MQU5HVUFHRV9JRCwge1xuICAgICAgICAgICAgYnJhY2tldHM6IFtcbiAgICAgICAgICAgICAgICBbJygnLCAnKSddLFxuICAgICAgICAgICAgICAgIFsnWycsICddJ10sXG4gICAgICAgICAgICAgICAgWyd7JywgJ30nXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzdXJyb3VuZGluZ1BhaXJzOiBbXG4gICAgICAgICAgICAgICAgeyBvcGVuOiAneycsIGNsb3NlOiAnfScgfSxcbiAgICAgICAgICAgICAgICB7IG9wZW46ICdbJywgY2xvc2U6ICddJyB9LFxuICAgICAgICAgICAgICAgIHsgb3BlbjogJygnLCBjbG9zZTogJyknIH0sXG4gICAgICAgICAgICAgICAgeyBvcGVuOiAnPCcsIGNsb3NlOiAnPicgfSxcbiAgICAgICAgICAgICAgICB7IG9wZW46ICdcXFwiJywgY2xvc2U6ICdcXFwiJyB9LFxuICAgICAgICAgICAgICAgIHsgb3BlbjogJ1xcJycsIGNsb3NlOiAnXFwnJyB9LFxuICAgICAgICAgICAgICAgIHsgb3BlbjogJ2AnLCBjbG9zZTogJ2AnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgY29sb3JpemVkQnJhY2tldFBhaXJzOiBbXSxcbiAgICAgICAgICAgIGZvbGRpbmc6IHtcbiAgICAgICAgICAgICAgICBvZmZTaWRlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHByaW9yaXR5IFVzZSBhIGhpZ2hlciBudW1iZXIgZm9yIGhpZ2hlciBwcmlvcml0eVxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGxhbmd1YWdlSWQsIGNvbmZpZ3VyYXRpb24sIHByaW9yaXR5ID0gMCkge1xuICAgICAgICBsZXQgZW50cmllcyA9IHRoaXMuX2VudHJpZXMuZ2V0KGxhbmd1YWdlSWQpO1xuICAgICAgICBpZiAoIWVudHJpZXMpIHtcbiAgICAgICAgICAgIGVudHJpZXMgPSBuZXcgQ29tcG9zZWRMYW5ndWFnZUNvbmZpZ3VyYXRpb24obGFuZ3VhZ2VJZCk7XG4gICAgICAgICAgICB0aGlzLl9lbnRyaWVzLnNldChsYW5ndWFnZUlkLCBlbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNwb3NhYmxlID0gZW50cmllcy5yZWdpc3Rlcihjb25maWd1cmF0aW9uLCBwcmlvcml0eSk7XG4gICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlLmZpcmUobmV3IExhbmd1YWdlQ29uZmlndXJhdGlvbkNoYW5nZUV2ZW50KGxhbmd1YWdlSWQpKTtcbiAgICAgICAgcmV0dXJuIHRvRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICAgICAgICBkaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlLmZpcmUobmV3IExhbmd1YWdlQ29uZmlndXJhdGlvbkNoYW5nZUV2ZW50KGxhbmd1YWdlSWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSB0aGlzLl9lbnRyaWVzLmdldChsYW5ndWFnZUlkKTtcbiAgICAgICAgcmV0dXJuIGVudHJpZXM/LmdldFJlc29sdmVkQ29uZmlndXJhdGlvbigpIHx8IG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBJbW11dGFibGUuXG4qL1xuZXhwb3J0IGNsYXNzIFJlc29sdmVkTGFuZ3VhZ2VDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihsYW5ndWFnZUlkLCB1bmRlcmx5aW5nQ29uZmlnKSB7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2VJZCA9IGxhbmd1YWdlSWQ7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NvbmZpZyA9IHVuZGVybHlpbmdDb25maWc7XG4gICAgICAgIHRoaXMuX2JyYWNrZXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZWxlY3RyaWNDaGFyYWN0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9vbkVudGVyU3VwcG9ydCA9XG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDb25maWcuYnJhY2tldHMgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDb25maWcuaW5kZW50YXRpb25SdWxlcyB8fFxuICAgICAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NvbmZpZy5vbkVudGVyUnVsZXNcbiAgICAgICAgICAgICAgICA/IG5ldyBPbkVudGVyU3VwcG9ydCh0aGlzLnVuZGVybHlpbmdDb25maWcpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB0aGlzLmNvbW1lbnRzID0gUmVzb2x2ZWRMYW5ndWFnZUNvbmZpZ3VyYXRpb24uX2hhbmRsZUNvbW1lbnRzKHRoaXMudW5kZXJseWluZ0NvbmZpZyk7XG4gICAgICAgIHRoaXMuY2hhcmFjdGVyUGFpciA9IG5ldyBDaGFyYWN0ZXJQYWlyU3VwcG9ydCh0aGlzLnVuZGVybHlpbmdDb25maWcpO1xuICAgICAgICB0aGlzLndvcmREZWZpbml0aW9uID0gdGhpcy51bmRlcmx5aW5nQ29uZmlnLndvcmRQYXR0ZXJuIHx8IERFRkFVTFRfV09SRF9SRUdFWFA7XG4gICAgICAgIHRoaXMuaW5kZW50YXRpb25SdWxlcyA9IHRoaXMudW5kZXJseWluZ0NvbmZpZy5pbmRlbnRhdGlvblJ1bGVzO1xuICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ29uZmlnLmluZGVudGF0aW9uUnVsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50UnVsZXNTdXBwb3J0ID0gbmV3IEluZGVudFJ1bGVzU3VwcG9ydCh0aGlzLnVuZGVybHlpbmdDb25maWcuaW5kZW50YXRpb25SdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluZGVudFJ1bGVzU3VwcG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2xkaW5nUnVsZXMgPSB0aGlzLnVuZGVybHlpbmdDb25maWcuZm9sZGluZyB8fCB7fTtcbiAgICAgICAgdGhpcy5icmFja2V0c05ldyA9IG5ldyBMYW5ndWFnZUJyYWNrZXRzQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkLCB0aGlzLnVuZGVybHlpbmdDb25maWcpO1xuICAgIH1cbiAgICBnZXRXb3JkRGVmaW5pdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGVuc3VyZVZhbGlkV29yZERlZmluaXRpb24odGhpcy53b3JkRGVmaW5pdGlvbik7XG4gICAgfVxuICAgIGdldCBicmFja2V0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9icmFja2V0cyAmJiB0aGlzLnVuZGVybHlpbmdDb25maWcuYnJhY2tldHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2JyYWNrZXRzID0gbmV3IFJpY2hFZGl0QnJhY2tldHModGhpcy5sYW5ndWFnZUlkLCB0aGlzLnVuZGVybHlpbmdDb25maWcuYnJhY2tldHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9icmFja2V0cztcbiAgICB9XG4gICAgZ2V0IGVsZWN0cmljQ2hhcmFjdGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VsZWN0cmljQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVjdHJpY0NoYXJhY3RlciA9IG5ldyBCcmFja2V0RWxlY3RyaWNDaGFyYWN0ZXJTdXBwb3J0KHRoaXMuYnJhY2tldHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVjdHJpY0NoYXJhY3RlcjtcbiAgICB9XG4gICAgb25FbnRlcihhdXRvSW5kZW50LCBwcmV2aW91c0xpbmVUZXh0LCBiZWZvcmVFbnRlclRleHQsIGFmdGVyRW50ZXJUZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5fb25FbnRlclN1cHBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9vbkVudGVyU3VwcG9ydC5vbkVudGVyKGF1dG9JbmRlbnQsIHByZXZpb3VzTGluZVRleHQsIGJlZm9yZUVudGVyVGV4dCwgYWZ0ZXJFbnRlclRleHQpO1xuICAgIH1cbiAgICBnZXRBdXRvQ2xvc2luZ1BhaXJzKCkge1xuICAgICAgICByZXR1cm4gbmV3IEF1dG9DbG9zaW5nUGFpcnModGhpcy5jaGFyYWN0ZXJQYWlyLmdldEF1dG9DbG9zaW5nUGFpcnMoKSk7XG4gICAgfVxuICAgIGdldEF1dG9DbG9zZUJlZm9yZVNldChmb3JRdW90ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcmFjdGVyUGFpci5nZXRBdXRvQ2xvc2VCZWZvcmVTZXQoZm9yUXVvdGVzKTtcbiAgICB9XG4gICAgZ2V0U3Vycm91bmRpbmdQYWlycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcmFjdGVyUGFpci5nZXRTdXJyb3VuZGluZ1BhaXJzKCk7XG4gICAgfVxuICAgIHN0YXRpYyBfaGFuZGxlQ29tbWVudHMoY29uZikge1xuICAgICAgICBjb25zdCBjb21tZW50UnVsZSA9IGNvbmYuY29tbWVudHM7XG4gICAgICAgIGlmICghY29tbWVudFJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbW1lbnQgY29uZmlndXJhdGlvblxuICAgICAgICBjb25zdCBjb21tZW50cyA9IHt9O1xuICAgICAgICBpZiAoY29tbWVudFJ1bGUubGluZUNvbW1lbnQpIHtcbiAgICAgICAgICAgIGNvbW1lbnRzLmxpbmVDb21tZW50VG9rZW4gPSBjb21tZW50UnVsZS5saW5lQ29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWVudFJ1bGUuYmxvY2tDb21tZW50KSB7XG4gICAgICAgICAgICBjb25zdCBbYmxvY2tTdGFydCwgYmxvY2tFbmRdID0gY29tbWVudFJ1bGUuYmxvY2tDb21tZW50O1xuICAgICAgICAgICAgY29tbWVudHMuYmxvY2tDb21tZW50U3RhcnRUb2tlbiA9IGJsb2NrU3RhcnQ7XG4gICAgICAgICAgICBjb21tZW50cy5ibG9ja0NvbW1lbnRFbmRUb2tlbiA9IGJsb2NrRW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tZW50cztcbiAgICB9XG59XG5yZWdpc3RlclNpbmdsZXRvbihJTGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZSwgTGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZSwgMSAvKiBJbnN0YW50aWF0aW9uVHlwZS5EZWxheWVkICovKTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgVG9rZW4sIFRva2VuaXphdGlvblJlc3VsdCwgRW5jb2RlZFRva2VuaXphdGlvblJlc3VsdCB9IGZyb20gJy4uL2xhbmd1YWdlcy5qcyc7XG5leHBvcnQgY29uc3QgTnVsbFN0YXRlID0gbmV3IGNsYXNzIHtcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMgPT09IG90aGVyKTtcbiAgICB9XG59O1xuZXhwb3J0IGZ1bmN0aW9uIG51bGxUb2tlbml6ZShsYW5ndWFnZUlkLCBzdGF0ZSkge1xuICAgIHJldHVybiBuZXcgVG9rZW5pemF0aW9uUmVzdWx0KFtuZXcgVG9rZW4oMCwgJycsIGxhbmd1YWdlSWQpXSwgc3RhdGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bGxUb2tlbml6ZUVuY29kZWQobGFuZ3VhZ2VJZCwgc3RhdGUpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBuZXcgVWludDMyQXJyYXkoMik7XG4gICAgdG9rZW5zWzBdID0gMDtcbiAgICB0b2tlbnNbMV0gPSAoKGxhbmd1YWdlSWQgPDwgMCAvKiBNZXRhZGF0YUNvbnN0cy5MQU5HVUFHRUlEX09GRlNFVCAqLylcbiAgICAgICAgfCAoMCAvKiBTdGFuZGFyZFRva2VuVHlwZS5PdGhlciAqLyA8PCA4IC8qIE1ldGFkYXRhQ29uc3RzLlRPS0VOX1RZUEVfT0ZGU0VUICovKVxuICAgICAgICB8ICgwIC8qIEZvbnRTdHlsZS5Ob25lICovIDw8IDExIC8qIE1ldGFkYXRhQ29uc3RzLkZPTlRfU1RZTEVfT0ZGU0VUICovKVxuICAgICAgICB8ICgxIC8qIENvbG9ySWQuRGVmYXVsdEZvcmVncm91bmQgKi8gPDwgMTUgLyogTWV0YWRhdGFDb25zdHMuRk9SRUdST1VORF9PRkZTRVQgKi8pXG4gICAgICAgIHwgKDIgLyogQ29sb3JJZC5EZWZhdWx0QmFja2dyb3VuZCAqLyA8PCAyNCAvKiBNZXRhZGF0YUNvbnN0cy5CQUNLR1JPVU5EX09GRlNFVCAqLykpID4+PiAwO1xuICAgIHJldHVybiBuZXcgRW5jb2RlZFRva2VuaXphdGlvblJlc3VsdCh0b2tlbnMsIHN0YXRlID09PSBudWxsID8gTnVsbFN0YXRlIDogc3RhdGUpO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NvcGVkTGluZVRva2Vucyhjb250ZXh0LCBvZmZzZXQpIHtcbiAgICBjb25zdCB0b2tlbkNvdW50ID0gY29udGV4dC5nZXRDb3VudCgpO1xuICAgIGNvbnN0IHRva2VuSW5kZXggPSBjb250ZXh0LmZpbmRUb2tlbkluZGV4QXRPZmZzZXQob2Zmc2V0KTtcbiAgICBjb25zdCBkZXNpcmVkTGFuZ3VhZ2VJZCA9IGNvbnRleHQuZ2V0TGFuZ3VhZ2VJZCh0b2tlbkluZGV4KTtcbiAgICBsZXQgbGFzdFRva2VuSW5kZXggPSB0b2tlbkluZGV4O1xuICAgIHdoaWxlIChsYXN0VG9rZW5JbmRleCArIDEgPCB0b2tlbkNvdW50ICYmIGNvbnRleHQuZ2V0TGFuZ3VhZ2VJZChsYXN0VG9rZW5JbmRleCArIDEpID09PSBkZXNpcmVkTGFuZ3VhZ2VJZCkge1xuICAgICAgICBsYXN0VG9rZW5JbmRleCsrO1xuICAgIH1cbiAgICBsZXQgZmlyc3RUb2tlbkluZGV4ID0gdG9rZW5JbmRleDtcbiAgICB3aGlsZSAoZmlyc3RUb2tlbkluZGV4ID4gMCAmJiBjb250ZXh0LmdldExhbmd1YWdlSWQoZmlyc3RUb2tlbkluZGV4IC0gMSkgPT09IGRlc2lyZWRMYW5ndWFnZUlkKSB7XG4gICAgICAgIGZpcnN0VG9rZW5JbmRleC0tO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNjb3BlZExpbmVUb2tlbnMoY29udGV4dCwgZGVzaXJlZExhbmd1YWdlSWQsIGZpcnN0VG9rZW5JbmRleCwgbGFzdFRva2VuSW5kZXggKyAxLCBjb250ZXh0LmdldFN0YXJ0T2Zmc2V0KGZpcnN0VG9rZW5JbmRleCksIGNvbnRleHQuZ2V0RW5kT2Zmc2V0KGxhc3RUb2tlbkluZGV4KSk7XG59XG5leHBvcnQgY2xhc3MgU2NvcGVkTGluZVRva2VucyB7XG4gICAgY29uc3RydWN0b3IoYWN0dWFsLCBsYW5ndWFnZUlkLCBmaXJzdFRva2VuSW5kZXgsIGxhc3RUb2tlbkluZGV4LCBmaXJzdENoYXJPZmZzZXQsIGxhc3RDaGFyT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX3Njb3BlZExpbmVUb2tlbnNCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fYWN0dWFsID0gYWN0dWFsO1xuICAgICAgICB0aGlzLmxhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl9maXJzdFRva2VuSW5kZXggPSBmaXJzdFRva2VuSW5kZXg7XG4gICAgICAgIHRoaXMuX2xhc3RUb2tlbkluZGV4ID0gbGFzdFRva2VuSW5kZXg7XG4gICAgICAgIHRoaXMuZmlyc3RDaGFyT2Zmc2V0ID0gZmlyc3RDaGFyT2Zmc2V0O1xuICAgICAgICB0aGlzLl9sYXN0Q2hhck9mZnNldCA9IGxhc3RDaGFyT2Zmc2V0O1xuICAgICAgICB0aGlzLmxhbmd1YWdlSWRDb2RlYyA9IGFjdHVhbC5sYW5ndWFnZUlkQ29kZWM7XG4gICAgfVxuICAgIGdldExpbmVDb250ZW50KCkge1xuICAgICAgICBjb25zdCBhY3R1YWxMaW5lQ29udGVudCA9IHRoaXMuX2FjdHVhbC5nZXRMaW5lQ29udGVudCgpO1xuICAgICAgICByZXR1cm4gYWN0dWFsTGluZUNvbnRlbnQuc3Vic3RyaW5nKHRoaXMuZmlyc3RDaGFyT2Zmc2V0LCB0aGlzLl9sYXN0Q2hhck9mZnNldCk7XG4gICAgfVxuICAgIGdldExpbmVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0Q2hhck9mZnNldCAtIHRoaXMuZmlyc3RDaGFyT2Zmc2V0O1xuICAgIH1cbiAgICBnZXRBY3R1YWxMaW5lQ29udGVudEJlZm9yZShvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgYWN0dWFsTGluZUNvbnRlbnQgPSB0aGlzLl9hY3R1YWwuZ2V0TGluZUNvbnRlbnQoKTtcbiAgICAgICAgcmV0dXJuIGFjdHVhbExpbmVDb250ZW50LnN1YnN0cmluZygwLCB0aGlzLmZpcnN0Q2hhck9mZnNldCArIG9mZnNldCk7XG4gICAgfVxuICAgIGdldFRva2VuQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0VG9rZW5JbmRleCAtIHRoaXMuX2ZpcnN0VG9rZW5JbmRleDtcbiAgICB9XG4gICAgZmluZFRva2VuSW5kZXhBdE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdHVhbC5maW5kVG9rZW5JbmRleEF0T2Zmc2V0KG9mZnNldCArIHRoaXMuZmlyc3RDaGFyT2Zmc2V0KSAtIHRoaXMuX2ZpcnN0VG9rZW5JbmRleDtcbiAgICB9XG4gICAgZ2V0U3RhbmRhcmRUb2tlblR5cGUodG9rZW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsLmdldFN0YW5kYXJkVG9rZW5UeXBlKHRva2VuSW5kZXggKyB0aGlzLl9maXJzdFRva2VuSW5kZXgpO1xuICAgIH1cbiAgICB0b0lWaWV3TGluZVRva2VucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdHVhbC5zbGljZUFuZEluZmxhdGUodGhpcy5maXJzdENoYXJPZmZzZXQsIHRoaXMuX2xhc3RDaGFyT2Zmc2V0LCAwKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaWdub3JlQnJhY2tldHNJblRva2VuKHN0YW5kYXJkVG9rZW5UeXBlKSB7XG4gICAgcmV0dXJuIChzdGFuZGFyZFRva2VuVHlwZSAmIDMgLyogSWdub3JlQnJhY2tldHNJblRva2Vucy52YWx1ZSAqLykgIT09IDA7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IFN0YW5kYXJkQXV0b0Nsb3NpbmdQYWlyQ29uZGl0aW9uYWwgfSBmcm9tICcuLi9sYW5ndWFnZUNvbmZpZ3VyYXRpb24uanMnO1xuZXhwb3J0IGNsYXNzIENoYXJhY3RlclBhaXJTdXBwb3J0IHtcbiAgICBzdGF0aWMgeyB0aGlzLkRFRkFVTFRfQVVUT0NMT1NFX0JFRk9SRV9MQU5HVUFHRV9ERUZJTkVEX1FVT1RFUyA9ICc7Oi4sPX1dKT4gXFxuXFx0JzsgfVxuICAgIHN0YXRpYyB7IHRoaXMuREVGQVVMVF9BVVRPQ0xPU0VfQkVGT1JFX0xBTkdVQUdFX0RFRklORURfQlJBQ0tFVFMgPSAnXFwnXCJgOzouLD19XSk+IFxcblxcdCc7IH1cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5hdXRvQ2xvc2luZ1BhaXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRvQ2xvc2luZ1BhaXJzID0gY29uZmlnLmF1dG9DbG9zaW5nUGFpcnMubWFwKGVsID0+IG5ldyBTdGFuZGFyZEF1dG9DbG9zaW5nUGFpckNvbmRpdGlvbmFsKGVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLmJyYWNrZXRzKSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRvQ2xvc2luZ1BhaXJzID0gY29uZmlnLmJyYWNrZXRzLm1hcChiID0+IG5ldyBTdGFuZGFyZEF1dG9DbG9zaW5nUGFpckNvbmRpdGlvbmFsKHsgb3BlbjogYlswXSwgY2xvc2U6IGJbMV0gfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYXV0b0Nsb3NpbmdQYWlycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX19lbGVjdHJpY0NoYXJhY3RlclN1cHBvcnQgJiYgY29uZmlnLl9fZWxlY3RyaWNDaGFyYWN0ZXJTdXBwb3J0LmRvY0NvbW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY0NvbW1lbnQgPSBjb25maWcuX19lbGVjdHJpY0NoYXJhY3RlclN1cHBvcnQuZG9jQ29tbWVudDtcbiAgICAgICAgICAgIC8vIElEb2NDb21tZW50IGlzIGxlZ2FjeSwgb25seSBwYXJ0aWFsbHkgc3VwcG9ydGVkXG4gICAgICAgICAgICB0aGlzLl9hdXRvQ2xvc2luZ1BhaXJzLnB1c2gobmV3IFN0YW5kYXJkQXV0b0Nsb3NpbmdQYWlyQ29uZGl0aW9uYWwoeyBvcGVuOiBkb2NDb21tZW50Lm9wZW4sIGNsb3NlOiBkb2NDb21tZW50LmNsb3NlIHx8ICcnIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdXRvQ2xvc2VCZWZvcmVGb3JRdW90ZXMgPSB0eXBlb2YgY29uZmlnLmF1dG9DbG9zZUJlZm9yZSA9PT0gJ3N0cmluZycgPyBjb25maWcuYXV0b0Nsb3NlQmVmb3JlIDogQ2hhcmFjdGVyUGFpclN1cHBvcnQuREVGQVVMVF9BVVRPQ0xPU0VfQkVGT1JFX0xBTkdVQUdFX0RFRklORURfUVVPVEVTO1xuICAgICAgICB0aGlzLl9hdXRvQ2xvc2VCZWZvcmVGb3JCcmFja2V0cyA9IHR5cGVvZiBjb25maWcuYXV0b0Nsb3NlQmVmb3JlID09PSAnc3RyaW5nJyA/IGNvbmZpZy5hdXRvQ2xvc2VCZWZvcmUgOiBDaGFyYWN0ZXJQYWlyU3VwcG9ydC5ERUZBVUxUX0FVVE9DTE9TRV9CRUZPUkVfTEFOR1VBR0VfREVGSU5FRF9CUkFDS0VUUztcbiAgICAgICAgdGhpcy5fc3Vycm91bmRpbmdQYWlycyA9IGNvbmZpZy5zdXJyb3VuZGluZ1BhaXJzIHx8IHRoaXMuX2F1dG9DbG9zaW5nUGFpcnM7XG4gICAgfVxuICAgIGdldEF1dG9DbG9zaW5nUGFpcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvQ2xvc2luZ1BhaXJzO1xuICAgIH1cbiAgICBnZXRBdXRvQ2xvc2VCZWZvcmVTZXQoZm9yUXVvdGVzKSB7XG4gICAgICAgIHJldHVybiAoZm9yUXVvdGVzID8gdGhpcy5fYXV0b0Nsb3NlQmVmb3JlRm9yUXVvdGVzIDogdGhpcy5fYXV0b0Nsb3NlQmVmb3JlRm9yQnJhY2tldHMpO1xuICAgIH1cbiAgICBnZXRTdXJyb3VuZGluZ1BhaXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3Vycm91bmRpbmdQYWlycztcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGRpc3RpbmN0IH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzLmpzJztcbmltcG9ydCB7IGlnbm9yZUJyYWNrZXRzSW5Ub2tlbiB9IGZyb20gJy4uL3N1cHBvcnRzLmpzJztcbmltcG9ydCB7IEJyYWNrZXRzVXRpbHMgfSBmcm9tICcuL3JpY2hFZGl0QnJhY2tldHMuanMnO1xuZXhwb3J0IGNsYXNzIEJyYWNrZXRFbGVjdHJpY0NoYXJhY3RlclN1cHBvcnQge1xuICAgIGNvbnN0cnVjdG9yKHJpY2hFZGl0QnJhY2tldHMpIHtcbiAgICAgICAgdGhpcy5fcmljaEVkaXRCcmFja2V0cyA9IHJpY2hFZGl0QnJhY2tldHM7XG4gICAgfVxuICAgIGdldEVsZWN0cmljQ2hhcmFjdGVycygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLl9yaWNoRWRpdEJyYWNrZXRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJyYWNrZXQgb2YgdGhpcy5fcmljaEVkaXRCcmFja2V0cy5icmFja2V0cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2xvc2Ugb2YgYnJhY2tldC5jbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q2hhciA9IGNsb3NlLmNoYXJBdChjbG9zZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGFzdENoYXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzdGluY3QocmVzdWx0KTtcbiAgICB9XG4gICAgb25FbGVjdHJpY0NoYXJhY3RlcihjaGFyYWN0ZXIsIGNvbnRleHQsIGNvbHVtbikge1xuICAgICAgICBpZiAoIXRoaXMuX3JpY2hFZGl0QnJhY2tldHMgfHwgdGhpcy5fcmljaEVkaXRCcmFja2V0cy5icmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuSW5kZXggPSBjb250ZXh0LmZpbmRUb2tlbkluZGV4QXRPZmZzZXQoY29sdW1uIC0gMSk7XG4gICAgICAgIGlmIChpZ25vcmVCcmFja2V0c0luVG9rZW4oY29udGV4dC5nZXRTdGFuZGFyZFRva2VuVHlwZSh0b2tlbkluZGV4KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldmVyc2VkQnJhY2tldFJlZ2V4ID0gdGhpcy5fcmljaEVkaXRCcmFja2V0cy5yZXZlcnNlZFJlZ2V4O1xuICAgICAgICBjb25zdCB0ZXh0ID0gY29udGV4dC5nZXRMaW5lQ29udGVudCgpLnN1YnN0cmluZygwLCBjb2x1bW4gLSAxKSArIGNoYXJhY3RlcjtcbiAgICAgICAgY29uc3QgciA9IEJyYWNrZXRzVXRpbHMuZmluZFByZXZCcmFja2V0SW5SYW5nZShyZXZlcnNlZEJyYWNrZXRSZWdleCwgMSwgdGV4dCwgMCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyYWNrZXRUZXh0ID0gdGV4dC5zdWJzdHJpbmcoci5zdGFydENvbHVtbiAtIDEsIHIuZW5kQ29sdW1uIC0gMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgaXNPcGVuID0gdGhpcy5fcmljaEVkaXRCcmFja2V0cy50ZXh0SXNPcGVuQnJhY2tldFticmFja2V0VGV4dF07XG4gICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHRCZWZvcmVCcmFja2V0ID0gY29udGV4dC5nZXRBY3R1YWxMaW5lQ29udGVudEJlZm9yZShyLnN0YXJ0Q29sdW1uIC0gMSk7XG4gICAgICAgIGlmICghL15cXHMqJC8udGVzdCh0ZXh0QmVmb3JlQnJhY2tldCkpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG90aGVyIHRleHQgb24gdGhlIGxpbmUgYmVmb3JlIHRoZSBicmFja2V0XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF0Y2hPcGVuQnJhY2tldDogYnJhY2tldFRleHRcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHJlc2V0R2xvYmFsUmVnZXgocmVnKSB7XG4gICAgaWYgKHJlZy5nbG9iYWwpIHtcbiAgICAgICAgcmVnLmxhc3RJbmRleCA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGNsYXNzIEluZGVudFJ1bGVzU3VwcG9ydCB7XG4gICAgY29uc3RydWN0b3IoaW5kZW50YXRpb25SdWxlcykge1xuICAgICAgICB0aGlzLl9pbmRlbnRhdGlvblJ1bGVzID0gaW5kZW50YXRpb25SdWxlcztcbiAgICB9XG4gICAgc2hvdWxkSW5jcmVhc2UodGV4dCkge1xuICAgICAgICBpZiAodGhpcy5faW5kZW50YXRpb25SdWxlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZGVudGF0aW9uUnVsZXMuaW5jcmVhc2VJbmRlbnRQYXR0ZXJuICYmIHJlc2V0R2xvYmFsUmVnZXgodGhpcy5faW5kZW50YXRpb25SdWxlcy5pbmNyZWFzZUluZGVudFBhdHRlcm4pICYmIHRoaXMuX2luZGVudGF0aW9uUnVsZXMuaW5jcmVhc2VJbmRlbnRQYXR0ZXJuLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmICh0aGlzLl9pbmRlbnRhdGlvblJ1bGVzLmluZGVudE5leHRMaW5lUGF0dGVybiAmJiB0aGlzLl9pbmRlbnRhdGlvblJ1bGVzLmluZGVudE5leHRMaW5lUGF0dGVybi50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAvLyBcdHJldHVybiB0cnVlO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2hvdWxkRGVjcmVhc2UodGV4dCkge1xuICAgICAgICBpZiAodGhpcy5faW5kZW50YXRpb25SdWxlcyAmJiB0aGlzLl9pbmRlbnRhdGlvblJ1bGVzLmRlY3JlYXNlSW5kZW50UGF0dGVybiAmJiByZXNldEdsb2JhbFJlZ2V4KHRoaXMuX2luZGVudGF0aW9uUnVsZXMuZGVjcmVhc2VJbmRlbnRQYXR0ZXJuKSAmJiB0aGlzLl9pbmRlbnRhdGlvblJ1bGVzLmRlY3JlYXNlSW5kZW50UGF0dGVybi50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNob3VsZEluZGVudE5leHRMaW5lKHRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luZGVudGF0aW9uUnVsZXMgJiYgdGhpcy5faW5kZW50YXRpb25SdWxlcy5pbmRlbnROZXh0TGluZVBhdHRlcm4gJiYgcmVzZXRHbG9iYWxSZWdleCh0aGlzLl9pbmRlbnRhdGlvblJ1bGVzLmluZGVudE5leHRMaW5lUGF0dGVybikgJiYgdGhpcy5faW5kZW50YXRpb25SdWxlcy5pbmRlbnROZXh0TGluZVBhdHRlcm4udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzaG91bGRJZ25vcmUodGV4dCkge1xuICAgICAgICAvLyB0aGUgdGV4dCBtYXRjaGVzIGB1bkluZGVudGVkTGluZVBhdHRlcm5gXG4gICAgICAgIGlmICh0aGlzLl9pbmRlbnRhdGlvblJ1bGVzICYmIHRoaXMuX2luZGVudGF0aW9uUnVsZXMudW5JbmRlbnRlZExpbmVQYXR0ZXJuICYmIHJlc2V0R2xvYmFsUmVnZXgodGhpcy5faW5kZW50YXRpb25SdWxlcy51bkluZGVudGVkTGluZVBhdHRlcm4pICYmIHRoaXMuX2luZGVudGF0aW9uUnVsZXMudW5JbmRlbnRlZExpbmVQYXR0ZXJuLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0SW5kZW50TWV0YWRhdGEodGV4dCkge1xuICAgICAgICBsZXQgcmV0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkSW5jcmVhc2UodGV4dCkpIHtcbiAgICAgICAgICAgIHJldCArPSAxIC8qIEluZGVudENvbnN0cy5JTkNSRUFTRV9NQVNLICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3VsZERlY3JlYXNlKHRleHQpKSB7XG4gICAgICAgICAgICByZXQgKz0gMiAvKiBJbmRlbnRDb25zdHMuREVDUkVBU0VfTUFTSyAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG91bGRJbmRlbnROZXh0TGluZSh0ZXh0KSkge1xuICAgICAgICAgICAgcmV0ICs9IDQgLyogSW5kZW50Q29uc3RzLklOREVOVF9ORVhUTElORV9NQVNLICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3VsZElnbm9yZSh0ZXh0KSkge1xuICAgICAgICAgICAgcmV0ICs9IDggLyogSW5kZW50Q29uc3RzLlVOSU5ERU5UX01BU0sgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IENhY2hlZEZ1bmN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vY2FjaGUuanMnO1xuaW1wb3J0IHsgY3JlYXRlQnJhY2tldE9yUmVnRXhwIH0gZnJvbSAnLi9yaWNoRWRpdEJyYWNrZXRzLmpzJztcbi8qKlxuICogQ2FwdHVyZXMgYWxsIGJyYWNrZXQgcmVsYXRlZCBjb25maWd1cmF0aW9ucyBmb3IgYSBzaW5nbGUgbGFuZ3VhZ2UuXG4gKiBJbW11dGFibGUuXG4qL1xuZXhwb3J0IGNsYXNzIExhbmd1YWdlQnJhY2tldHNDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihsYW5ndWFnZUlkLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgY29uc3QgYnJhY2tldFBhaXJzID0gY29uZmlnLmJyYWNrZXRzID8gZmlsdGVyVmFsaWRCcmFja2V0cyhjb25maWcuYnJhY2tldHMpIDogW107XG4gICAgICAgIGNvbnN0IG9wZW5pbmdCcmFja2V0SW5mb3MgPSBuZXcgQ2FjaGVkRnVuY3Rpb24oKGJyYWNrZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NpbmcgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGluZm86IG5ldyBPcGVuaW5nQnJhY2tldEtpbmQodGhpcywgYnJhY2tldCwgY2xvc2luZyksXG4gICAgICAgICAgICAgICAgY2xvc2luZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbG9zaW5nQnJhY2tldEluZm9zID0gbmV3IENhY2hlZEZ1bmN0aW9uKChicmFja2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcGVuaW5nID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgY29uc3Qgb3BlbmluZ0NvbG9yaXplZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5mbzogbmV3IENsb3NpbmdCcmFja2V0S2luZCh0aGlzLCBicmFja2V0LCBvcGVuaW5nLCBvcGVuaW5nQ29sb3JpemVkKSxcbiAgICAgICAgICAgICAgICBvcGVuaW5nLFxuICAgICAgICAgICAgICAgIG9wZW5pbmdDb2xvcml6ZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBbb3BlbiwgY2xvc2VdIG9mIGJyYWNrZXRQYWlycykge1xuICAgICAgICAgICAgY29uc3Qgb3BlbmluZyA9IG9wZW5pbmdCcmFja2V0SW5mb3MuZ2V0KG9wZW4pO1xuICAgICAgICAgICAgY29uc3QgY2xvc2luZyA9IGNsb3NpbmdCcmFja2V0SW5mb3MuZ2V0KGNsb3NlKTtcbiAgICAgICAgICAgIG9wZW5pbmcuY2xvc2luZy5hZGQoY2xvc2luZy5pbmZvKTtcbiAgICAgICAgICAgIGNsb3Npbmcub3BlbmluZy5hZGQob3BlbmluZy5pbmZvKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmVhdCBjb2xvcml6ZWQgYnJhY2tldHMgYXMgYnJhY2tldHMsIGFuZCBtYXJrIHRoZW0gYXMgY29sb3JpemVkLlxuICAgICAgICBjb25zdCBjb2xvcml6ZWRCcmFja2V0UGFpcnMgPSBjb25maWcuY29sb3JpemVkQnJhY2tldFBhaXJzXG4gICAgICAgICAgICA/IGZpbHRlclZhbGlkQnJhY2tldHMoY29uZmlnLmNvbG9yaXplZEJyYWNrZXRQYWlycylcbiAgICAgICAgICAgIC8vIElmIG5vdCBjb25maWd1cmVkOiBUYWtlIGFsbCBicmFja2V0cyBleGNlcHQgYDxgIC4uLiBgPmBcbiAgICAgICAgICAgIC8vIE1hbnkgbGFuZ3VhZ2VzIHNldCA8IC4uLiA+IGFzIGJyYWNrZXQgcGFpciwgZXZlbiB0aG91Z2ggdGhleSBhbHNvIHVzZSBpdCBhcyBjb21wYXJpc29uIG9wZXJhdG9yLlxuICAgICAgICAgICAgLy8gVGhpcyBsZWFkcyB0byBwcm9ibGVtcyB3aGVuIGNvbG9yaXppbmcgdGhpcyBicmFja2V0LCBzbyB3ZSBleGNsdWRlIGl0IGlmIG5vdCBleHBsaWNpdGx5IGNvbmZpZ3VyZWQgb3RoZXJ3aXNlLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUvaXNzdWVzLzEzMjQ3NlxuICAgICAgICAgICAgOiBicmFja2V0UGFpcnMuZmlsdGVyKChwKSA9PiAhKHBbMF0gPT09ICc8JyAmJiBwWzFdID09PSAnPicpKTtcbiAgICAgICAgZm9yIChjb25zdCBbb3BlbiwgY2xvc2VdIG9mIGNvbG9yaXplZEJyYWNrZXRQYWlycykge1xuICAgICAgICAgICAgY29uc3Qgb3BlbmluZyA9IG9wZW5pbmdCcmFja2V0SW5mb3MuZ2V0KG9wZW4pO1xuICAgICAgICAgICAgY29uc3QgY2xvc2luZyA9IGNsb3NpbmdCcmFja2V0SW5mb3MuZ2V0KGNsb3NlKTtcbiAgICAgICAgICAgIG9wZW5pbmcuY2xvc2luZy5hZGQoY2xvc2luZy5pbmZvKTtcbiAgICAgICAgICAgIGNsb3Npbmcub3BlbmluZ0NvbG9yaXplZC5hZGQob3BlbmluZy5pbmZvKTtcbiAgICAgICAgICAgIGNsb3Npbmcub3BlbmluZy5hZGQob3BlbmluZy5pbmZvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcGVuaW5nQnJhY2tldHMgPSBuZXcgTWFwKFsuLi5vcGVuaW5nQnJhY2tldEluZm9zLmNhY2hlZFZhbHVlc10ubWFwKChbaywgdl0pID0+IFtrLCB2LmluZm9dKSk7XG4gICAgICAgIHRoaXMuX2Nsb3NpbmdCcmFja2V0cyA9IG5ldyBNYXAoWy4uLmNsb3NpbmdCcmFja2V0SW5mb3MuY2FjaGVkVmFsdWVzXS5tYXAoKFtrLCB2XSkgPT4gW2ssIHYuaW5mb10pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm8gdHdvIGJyYWNrZXRzIGhhdmUgdGhlIHNhbWUgYnJhY2tldCB0ZXh0LlxuICAgICovXG4gICAgZ2V0IG9wZW5pbmdCcmFja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9vcGVuaW5nQnJhY2tldHMudmFsdWVzKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBObyB0d28gYnJhY2tldHMgaGF2ZSB0aGUgc2FtZSBicmFja2V0IHRleHQuXG4gICAgKi9cbiAgICBnZXQgY2xvc2luZ0JyYWNrZXRzKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuX2Nsb3NpbmdCcmFja2V0cy52YWx1ZXMoKV07XG4gICAgfVxuICAgIGdldE9wZW5pbmdCcmFja2V0SW5mbyhicmFja2V0VGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3BlbmluZ0JyYWNrZXRzLmdldChicmFja2V0VGV4dCk7XG4gICAgfVxuICAgIGdldENsb3NpbmdCcmFja2V0SW5mbyhicmFja2V0VGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2luZ0JyYWNrZXRzLmdldChicmFja2V0VGV4dCk7XG4gICAgfVxuICAgIGdldEJyYWNrZXRJbmZvKGJyYWNrZXRUZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wZW5pbmdCcmFja2V0SW5mbyhicmFja2V0VGV4dCkgfHwgdGhpcy5nZXRDbG9zaW5nQnJhY2tldEluZm8oYnJhY2tldFRleHQpO1xuICAgIH1cbiAgICBnZXRCcmFja2V0UmVnRXhwKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYnJhY2tldHMgPSBBcnJheS5mcm9tKFsuLi50aGlzLl9vcGVuaW5nQnJhY2tldHMua2V5cygpLCAuLi50aGlzLl9jbG9zaW5nQnJhY2tldHMua2V5cygpXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVCcmFja2V0T3JSZWdFeHAoYnJhY2tldHMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbHRlclZhbGlkQnJhY2tldHMoYnJhY2tldFBhaXJzKSB7XG4gICAgcmV0dXJuIGJyYWNrZXRQYWlycy5maWx0ZXIoKFtvcGVuLCBjbG9zZV0pID0+IG9wZW4gIT09ICcnICYmIGNsb3NlICE9PSAnJyk7XG59XG5leHBvcnQgY2xhc3MgQnJhY2tldEtpbmRCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIGJyYWNrZXRUZXh0KSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmJyYWNrZXRUZXh0ID0gYnJhY2tldFRleHQ7XG4gICAgfVxuICAgIGdldCBsYW5ndWFnZUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubGFuZ3VhZ2VJZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT3BlbmluZ0JyYWNrZXRLaW5kIGV4dGVuZHMgQnJhY2tldEtpbmRCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIGJyYWNrZXRUZXh0LCBvcGVuZWRCcmFja2V0cykge1xuICAgICAgICBzdXBlcihjb25maWcsIGJyYWNrZXRUZXh0KTtcbiAgICAgICAgdGhpcy5vcGVuZWRCcmFja2V0cyA9IG9wZW5lZEJyYWNrZXRzO1xuICAgICAgICB0aGlzLmlzT3BlbmluZ0JyYWNrZXQgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDbG9zaW5nQnJhY2tldEtpbmQgZXh0ZW5kcyBCcmFja2V0S2luZEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgYnJhY2tldFRleHQsIFxuICAgIC8qKlxuICAgICAqIE5vbiBlbXB0eSBhcnJheSBvZiBhbGwgb3BlbmluZyBicmFja2V0cyB0aGlzIGJyYWNrZXQgY2xvc2VzLlxuICAgICovXG4gICAgb3BlbmluZ0JyYWNrZXRzLCBvcGVuaW5nQ29sb3JpemVkQnJhY2tldHMpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBicmFja2V0VGV4dCk7XG4gICAgICAgIHRoaXMub3BlbmluZ0JyYWNrZXRzID0gb3BlbmluZ0JyYWNrZXRzO1xuICAgICAgICB0aGlzLm9wZW5pbmdDb2xvcml6ZWRCcmFja2V0cyA9IG9wZW5pbmdDb2xvcml6ZWRCcmFja2V0cztcbiAgICAgICAgdGhpcy5pc09wZW5pbmdCcmFja2V0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIGJyYWNrZXQgY2xvc2VzIHRoZSBnaXZlbiBvdGhlciBicmFja2V0LlxuICAgICAqIElmIHRoZSBicmFja2V0IGluZm9zIGNvbWUgZnJvbSBkaWZmZXJlbnQgY29uZmlndXJhdGlvbnMsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGZhbHNlLlxuICAgICovXG4gICAgY2xvc2VzKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlclsnY29uZmlnJ10gIT09IHRoaXMuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3BlbmluZ0JyYWNrZXRzLmhhcyhvdGhlcik7XG4gICAgfVxuICAgIGNsb3Nlc0NvbG9yaXplZChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXJbJ2NvbmZpZyddICE9PSB0aGlzLmNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW5pbmdDb2xvcml6ZWRCcmFja2V0cy5oYXMob3RoZXIpO1xuICAgIH1cbiAgICBnZXRPcGVuaW5nQnJhY2tldHMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5vcGVuaW5nQnJhY2tldHNdO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgb25VbmV4cGVjdGVkRXJyb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9lcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcbmltcG9ydCB7IEluZGVudEFjdGlvbiB9IGZyb20gJy4uL2xhbmd1YWdlQ29uZmlndXJhdGlvbi5qcyc7XG5leHBvcnQgY2xhc3MgT25FbnRlclN1cHBvcnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMuYnJhY2tldHMgPSBvcHRzLmJyYWNrZXRzIHx8IFtcbiAgICAgICAgICAgIFsnKCcsICcpJ10sXG4gICAgICAgICAgICBbJ3snLCAnfSddLFxuICAgICAgICAgICAgWydbJywgJ10nXVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9icmFja2V0cyA9IFtdO1xuICAgICAgICBvcHRzLmJyYWNrZXRzLmZvckVhY2goKGJyYWNrZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5SZWdFeHAgPSBPbkVudGVyU3VwcG9ydC5fY3JlYXRlT3BlbkJyYWNrZXRSZWdFeHAoYnJhY2tldFswXSk7XG4gICAgICAgICAgICBjb25zdCBjbG9zZVJlZ0V4cCA9IE9uRW50ZXJTdXBwb3J0Ll9jcmVhdGVDbG9zZUJyYWNrZXRSZWdFeHAoYnJhY2tldFsxXSk7XG4gICAgICAgICAgICBpZiAob3BlblJlZ0V4cCAmJiBjbG9zZVJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JyYWNrZXRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcGVuOiBicmFja2V0WzBdLFxuICAgICAgICAgICAgICAgICAgICBvcGVuUmVnRXhwOiBvcGVuUmVnRXhwLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZTogYnJhY2tldFsxXSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VSZWdFeHA6IGNsb3NlUmVnRXhwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmVnRXhwUnVsZXMgPSBvcHRzLm9uRW50ZXJSdWxlcyB8fCBbXTtcbiAgICB9XG4gICAgb25FbnRlcihhdXRvSW5kZW50LCBwcmV2aW91c0xpbmVUZXh0LCBiZWZvcmVFbnRlclRleHQsIGFmdGVyRW50ZXJUZXh0KSB7XG4gICAgICAgIC8vICgxKTogYHJlZ0V4cFJ1bGVzYFxuICAgICAgICBpZiAoYXV0b0luZGVudCA+PSAzIC8qIEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneS5BZHZhbmNlZCAqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX3JlZ0V4cFJ1bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMuX3JlZ0V4cFJ1bGVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ1Jlc3VsdCA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWc6IHJ1bGUuYmVmb3JlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGJlZm9yZUVudGVyVGV4dFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWc6IHJ1bGUuYWZ0ZXJUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYWZ0ZXJFbnRlclRleHRcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnOiBydWxlLnByZXZpb3VzTGluZVRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwcmV2aW91c0xpbmVUZXh0XG4gICAgICAgICAgICAgICAgICAgIH1dLmV2ZXJ5KChvYmopID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmoucmVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYmoucmVnLmxhc3RJbmRleCA9IDA7IC8vIFRvIGRpc2FibGUgdGhlIGVmZmVjdCBvZiB0aGUgXCJnXCIgZmxhZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5yZWcudGVzdChvYmoudGV4dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZS5hY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vICgyKTogU3BlY2lhbCBpbmRlbnQtb3V0ZGVudFxuICAgICAgICBpZiAoYXV0b0luZGVudCA+PSAyIC8qIEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneS5CcmFja2V0cyAqLykge1xuICAgICAgICAgICAgaWYgKGJlZm9yZUVudGVyVGV4dC5sZW5ndGggPiAwICYmIGFmdGVyRW50ZXJUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fYnJhY2tldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldCA9IHRoaXMuX2JyYWNrZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhY2tldC5vcGVuUmVnRXhwLnRlc3QoYmVmb3JlRW50ZXJUZXh0KSAmJiBicmFja2V0LmNsb3NlUmVnRXhwLnRlc3QoYWZ0ZXJFbnRlclRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpbmRlbnRBY3Rpb246IEluZGVudEFjdGlvbi5JbmRlbnRPdXRkZW50IH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gKDQpOiBPcGVuIGJyYWNrZXQgYmFzZWQgbG9naWNcbiAgICAgICAgaWYgKGF1dG9JbmRlbnQgPj0gMiAvKiBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3kuQnJhY2tldHMgKi8pIHtcbiAgICAgICAgICAgIGlmIChiZWZvcmVFbnRlclRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9icmFja2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBicmFja2V0ID0gdGhpcy5fYnJhY2tldHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChicmFja2V0Lm9wZW5SZWdFeHAudGVzdChiZWZvcmVFbnRlclRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpbmRlbnRBY3Rpb246IEluZGVudEFjdGlvbi5JbmRlbnQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGVPcGVuQnJhY2tldFJlZ0V4cChicmFja2V0KSB7XG4gICAgICAgIGxldCBzdHIgPSBzdHJpbmdzLmVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoYnJhY2tldCk7XG4gICAgICAgIGlmICghL1xcQi8udGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgc3RyID0gJ1xcXFxiJyArIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gJ1xcXFxzKiQnO1xuICAgICAgICByZXR1cm4gT25FbnRlclN1cHBvcnQuX3NhZmVSZWdFeHAoc3RyKTtcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGVDbG9zZUJyYWNrZXRSZWdFeHAoYnJhY2tldCkge1xuICAgICAgICBsZXQgc3RyID0gc3RyaW5ncy5lc2NhcGVSZWdFeHBDaGFyYWN0ZXJzKGJyYWNrZXQpO1xuICAgICAgICBpZiAoIS9cXEIvLnRlc3Qoc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkpKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIgKyAnXFxcXGInO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9ICdeXFxcXHMqJyArIHN0cjtcbiAgICAgICAgcmV0dXJuIE9uRW50ZXJTdXBwb3J0Ll9zYWZlUmVnRXhwKHN0cik7XG4gICAgfVxuICAgIHN0YXRpYyBfc2FmZVJlZ0V4cChkZWYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGRlZik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgb25VbmV4cGVjdGVkRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyBzdHJpbmdzIGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL3N0cmluZ3MuanMnO1xuaW1wb3J0ICogYXMgc3RyaW5nQnVpbGRlciBmcm9tICcuLi8uLi9jb3JlL3N0cmluZ0J1aWxkZXIuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi8uLi9jb3JlL3JhbmdlLmpzJztcbi8qKlxuICogUmVwcmVzZW50cyBhIGdyb3VwaW5nIG9mIGNvbGxpZGluZyBicmFja2V0IHBhaXJzLlxuICpcbiAqIE1vc3Qgb2YgdGhlIHRpbWVzIHRoaXMgY29udGFpbnMgYSBzaW5nbGUgYnJhY2tldCBwYWlyLFxuICogYnV0IHNvbWV0aW1lcyB0aGlzIGNvbnRhaW5zIG11bHRpcGxlIGJyYWNrZXQgcGFpcnMgaW4gY2FzZXNcbiAqIHdoZXJlIHRoZSBzYW1lIHN0cmluZyBhcHBlYXJzIGFzIGEgY2xvc2luZyBicmFja2V0IGZvciBtdWx0aXBsZVxuICogYnJhY2tldCBwYWlycywgb3IgdGhlIHNhbWUgc3RyaW5nIGFwcGVhcnMgYW4gb3BlbmluZyBicmFja2V0IGZvclxuICogbXVsdGlwbGUgYnJhY2tldCBwYWlycy5cbiAqXG4gKiBlLmcuIG9mIGEgZ3JvdXAgY29udGFpbmluZyBhIHNpbmdsZSBwYWlyOlxuICogICBvcGVuOiBbJ3snXSwgY2xvc2U6IFsnfSddXG4gKlxuICogZS5nLiBvZiBhIGdyb3VwIGNvbnRhaW5pbmcgbXVsdGlwbGUgcGFpcnM6XG4gKiAgIG9wZW46IFsnaWYnLCAnZm9yJ10sIGNsb3NlOiBbJ2VuZCcsICdlbmQnXVxuICovXG5leHBvcnQgY2xhc3MgUmljaEVkaXRCcmFja2V0IHtcbiAgICBjb25zdHJ1Y3RvcihsYW5ndWFnZUlkLCBpbmRleCwgb3BlbiwgY2xvc2UsIGZvcndhcmRSZWdleCwgcmV2ZXJzZWRSZWdleCkge1xuICAgICAgICB0aGlzLl9yaWNoRWRpdEJyYWNrZXRCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgICAgICB0aGlzLmNsb3NlID0gY2xvc2U7XG4gICAgICAgIHRoaXMuZm9yd2FyZFJlZ2V4ID0gZm9yd2FyZFJlZ2V4O1xuICAgICAgICB0aGlzLnJldmVyc2VkUmVnZXggPSByZXZlcnNlZFJlZ2V4O1xuICAgICAgICB0aGlzLl9vcGVuU2V0ID0gUmljaEVkaXRCcmFja2V0Ll90b1NldCh0aGlzLm9wZW4pO1xuICAgICAgICB0aGlzLl9jbG9zZVNldCA9IFJpY2hFZGl0QnJhY2tldC5fdG9TZXQodGhpcy5jbG9zZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBwcm92aWRlZCBgdGV4dGAgaXMgYW4gb3BlbiBicmFja2V0IGluIHRoaXMgZ3JvdXAuXG4gICAgICovXG4gICAgaXNPcGVuKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wZW5TZXQuaGFzKHRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcHJvdmlkZWQgYHRleHRgIGlzIGEgY2xvc2UgYnJhY2tldCBpbiB0aGlzIGdyb3VwLlxuICAgICAqL1xuICAgIGlzQ2xvc2UodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VTZXQuaGFzKHRleHQpO1xuICAgIH1cbiAgICBzdGF0aWMgX3RvU2V0KGFycikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBhcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbiAqIEdyb3VwcyB0b2dldGhlciBicmFja2V0cyB0aGF0IGhhdmUgZXF1YWwgb3BlbiBvciBjbG9zZSBzZXF1ZW5jZXMuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSBmb2xsb3dpbmcgYnJhY2tldHMgYXJlIGRlZmluZWQ6XG4gKiAgIFsnSUYnLCdFTkQnXVxuICogICBbJ2ZvcicsJ2VuZCddXG4gKiAgIFsneycsJ30nXVxuICpcbiAqIFRoZW4gdGhlIGdyb3VwZWQgYnJhY2tldHMgd291bGQgYmU6XG4gKiAgIHsgb3BlbjogWydpZicsICdmb3InXSwgY2xvc2U6IFsnZW5kJywgJ2VuZCddIH1cbiAqICAgeyBvcGVuOiBbJ3snXSwgY2xvc2U6IFsnfSddIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGdyb3VwRnV6enlCcmFja2V0cyhicmFja2V0cykge1xuICAgIGNvbnN0IE4gPSBicmFja2V0cy5sZW5ndGg7XG4gICAgYnJhY2tldHMgPSBicmFja2V0cy5tYXAoYiA9PiBbYlswXS50b0xvd2VyQ2FzZSgpLCBiWzFdLnRvTG93ZXJDYXNlKCldKTtcbiAgICBjb25zdCBncm91cCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgIGdyb3VwW2ldID0gaTtcbiAgICB9XG4gICAgY29uc3QgYXJlT3ZlcmxhcHBpbmcgPSAoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBbYU9wZW4sIGFDbG9zZV0gPSBhO1xuICAgICAgICBjb25zdCBbYk9wZW4sIGJDbG9zZV0gPSBiO1xuICAgICAgICByZXR1cm4gKGFPcGVuID09PSBiT3BlbiB8fCBhT3BlbiA9PT0gYkNsb3NlIHx8IGFDbG9zZSA9PT0gYk9wZW4gfHwgYUNsb3NlID09PSBiQ2xvc2UpO1xuICAgIH07XG4gICAgY29uc3QgbWVyZ2VHcm91cHMgPSAoZzEsIGcyKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0cgPSBNYXRoLm1pbihnMSwgZzIpO1xuICAgICAgICBjb25zdCBvbGRHID0gTWF0aC5tYXgoZzEsIGcyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChncm91cFtpXSA9PT0gb2xkRykge1xuICAgICAgICAgICAgICAgIGdyb3VwW2ldID0gbmV3RztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gZ3JvdXAgdG9nZXRoZXIgYnJhY2tldHMgdGhhdCBoYXZlIHRoZSBzYW1lIG9wZW4gb3IgdGhlIHNhbWUgY2xvc2Ugc2VxdWVuY2VcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYnJhY2tldHNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IE47IGorKykge1xuICAgICAgICAgICAgY29uc3QgYiA9IGJyYWNrZXRzW2pdO1xuICAgICAgICAgICAgaWYgKGFyZU92ZXJsYXBwaW5nKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VHcm91cHMoZ3JvdXBbaV0sIGdyb3VwW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBnID0gMDsgZyA8IE47IGcrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50T3BlbiA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2xvc2UgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChncm91cFtpXSA9PT0gZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtvcGVuLCBjbG9zZV0gPSBicmFja2V0c1tpXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50T3Blbi5wdXNoKG9wZW4pO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDbG9zZS5wdXNoKGNsb3NlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudE9wZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG9wZW46IGN1cnJlbnRPcGVuLFxuICAgICAgICAgICAgICAgIGNsb3NlOiBjdXJyZW50Q2xvc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY2xhc3MgUmljaEVkaXRCcmFja2V0cyB7XG4gICAgY29uc3RydWN0b3IobGFuZ3VhZ2VJZCwgX2JyYWNrZXRzKSB7XG4gICAgICAgIHRoaXMuX3JpY2hFZGl0QnJhY2tldHNCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgYnJhY2tldHMgPSBncm91cEZ1enp5QnJhY2tldHMoX2JyYWNrZXRzKTtcbiAgICAgICAgdGhpcy5icmFja2V0cyA9IGJyYWNrZXRzLm1hcCgoYiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmljaEVkaXRCcmFja2V0KGxhbmd1YWdlSWQsIGluZGV4LCBiLm9wZW4sIGIuY2xvc2UsIGdldFJlZ2V4Rm9yQnJhY2tldFBhaXIoYi5vcGVuLCBiLmNsb3NlLCBicmFja2V0cywgaW5kZXgpLCBnZXRSZXZlcnNlZFJlZ2V4Rm9yQnJhY2tldFBhaXIoYi5vcGVuLCBiLmNsb3NlLCBicmFja2V0cywgaW5kZXgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZFJlZ2V4ID0gZ2V0UmVnZXhGb3JCcmFja2V0cyh0aGlzLmJyYWNrZXRzKTtcbiAgICAgICAgdGhpcy5yZXZlcnNlZFJlZ2V4ID0gZ2V0UmV2ZXJzZWRSZWdleEZvckJyYWNrZXRzKHRoaXMuYnJhY2tldHMpO1xuICAgICAgICB0aGlzLnRleHRJc0JyYWNrZXQgPSB7fTtcbiAgICAgICAgdGhpcy50ZXh0SXNPcGVuQnJhY2tldCA9IHt9O1xuICAgICAgICB0aGlzLm1heEJyYWNrZXRMZW5ndGggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGJyYWNrZXQgb2YgdGhpcy5icmFja2V0cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcGVuIG9mIGJyYWNrZXQub3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dElzQnJhY2tldFtvcGVuXSA9IGJyYWNrZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0SXNPcGVuQnJhY2tldFtvcGVuXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhCcmFja2V0TGVuZ3RoID0gTWF0aC5tYXgodGhpcy5tYXhCcmFja2V0TGVuZ3RoLCBvcGVuLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNsb3NlIG9mIGJyYWNrZXQuY2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRJc0JyYWNrZXRbY2xvc2VdID0gYnJhY2tldDtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRJc09wZW5CcmFja2V0W2Nsb3NlXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubWF4QnJhY2tldExlbmd0aCA9IE1hdGgubWF4KHRoaXMubWF4QnJhY2tldExlbmd0aCwgY2xvc2UubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RTdXBlcnN0cmluZ3Moc3RyLCBicmFja2V0cywgY3VycmVudEluZGV4LCBkZXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGJyYWNrZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyYWNrZXQgPSBicmFja2V0c1tpXTtcbiAgICAgICAgZm9yIChjb25zdCBvcGVuIG9mIGJyYWNrZXQub3Blbikge1xuICAgICAgICAgICAgaWYgKG9wZW4uaW5kZXhPZihzdHIpID49IDApIHtcbiAgICAgICAgICAgICAgICBkZXN0LnB1c2gob3Blbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjbG9zZSBvZiBicmFja2V0LmNsb3NlKSB7XG4gICAgICAgICAgICBpZiAoY2xvc2UuaW5kZXhPZihzdHIpID49IDApIHtcbiAgICAgICAgICAgICAgICBkZXN0LnB1c2goY2xvc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbGVuZ3RoY21wKGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGFycikge1xuICAgICAgICBpZiAoc2Vlbi5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBzZWVuLmFkZChlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2VhcmNoIGZvcndhcmQgaW4gYSBwaWVjZSBvZiB0ZXh0XG4gKiBmb3IgYSBncm91cCBvZiBicmFja2V0IHBhaXJzLiBCdXQgdGhpcyByZWdleCBtdXN0IGJlIGJ1aWx0IGluIGEgd2F5IGluIHdoaWNoXG4gKiBpdCBpcyBhd2FyZSBvZiB0aGUgb3RoZXIgYnJhY2tldCBwYWlycyBkZWZpbmVkIGZvciB0aGUgbGFuZ3VhZ2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIGEgbGFuZ3VhZ2UgY29udGFpbnMgdGhlIGZvbGxvd2luZyBicmFja2V0IHBhaXJzOlxuICogICBbJ2JlZ2luJywgJ2VuZCddXG4gKiAgIFsnaWYnLCAnZW5kIGlmJ11cbiAqIFRoZSB0d28gYnJhY2tldCBwYWlycyBkbyBub3QgY29sbGlkZSBiZWNhdXNlIG5vIG9wZW4gb3IgY2xvc2UgYnJhY2tldHMgYXJlIGVxdWFsLlxuICogU28gdGhlIGZ1bmN0aW9uIGdldFJlZ2V4Rm9yQnJhY2tldFBhaXIgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIHdpdGhcbiAqIHRoZSBbJ2JlZ2luJ10sIFsnZW5kJ10gZ3JvdXAgY29uc2lzdGluZyBvZiBvbmUgYnJhY2tldCBwYWlyLCBhbmQgb25jZSB3aXRoXG4gKiB0aGUgWydpZiddLCBbJ2VuZCBpZiddIGdyb3VwIGNvbnNpdGluZyBvZiB0aGUgb3RoZXIgYnJhY2tldCBwYWlyLlxuICpcbiAqIEJ1dCB0aGVyZSBjb3VsZCBiZSBhIHNpdHVhdGlvbiB3aGVyZSBhbiBvY2N1cnJlbmNlIG9mICdlbmQgaWYnIGlzIG1pc3Rha2VuXG4gKiBmb3IgYW4gb2NjdXJyZW5jZSBvZiAnZW5kJy5cbiAqXG4gKiBUaGVyZWZvcmUsIGZvciB0aGUgYnJhY2tldCBwYWlyIFsnYmVnaW4nLCAnZW5kJ10sIHRoZSByZWdleCB3aWxsIGFsc29cbiAqIHRhcmdldCAnZW5kIGlmJy4gVGhlIHJlZ2V4IHdpbGwgYmUgc29tZXRoaW5nIGxpa2U6XG4gKiAgIC8oXFxiZW5kIGlmXFxiKXwoXFxiZW5kXFxiKXwoXFxiaWZcXGIpL1xuICpcbiAqIFRoZSByZWdleCBhbHNvIHNlYXJjaGVzIGZvciBcInN1cGVyc3RyaW5nc1wiIChvdGhlciBicmFja2V0cyB0aGF0IG1pZ2h0IGJlIG1pc3Rha2VuIHdpdGggdGhlIGN1cnJlbnQgYnJhY2tldCkuXG4gKlxuICovXG5mdW5jdGlvbiBnZXRSZWdleEZvckJyYWNrZXRQYWlyKG9wZW4sIGNsb3NlLCBicmFja2V0cywgY3VycmVudEluZGV4KSB7XG4gICAgLy8gc2VhcmNoIGluIGFsbCBicmFja2V0cyBmb3Igb3RoZXIgYnJhY2tldHMgdGhhdCBhcmUgYSBzdXBlcnN0cmluZyBvZiB0aGVzZSBicmFja2V0c1xuICAgIGxldCBwaWVjZXMgPSBbXTtcbiAgICBwaWVjZXMgPSBwaWVjZXMuY29uY2F0KG9wZW4pO1xuICAgIHBpZWNlcyA9IHBpZWNlcy5jb25jYXQoY2xvc2UpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwaWVjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29sbGVjdFN1cGVyc3RyaW5ncyhwaWVjZXNbaV0sIGJyYWNrZXRzLCBjdXJyZW50SW5kZXgsIHBpZWNlcyk7XG4gICAgfVxuICAgIHBpZWNlcyA9IHVuaXF1ZShwaWVjZXMpO1xuICAgIHBpZWNlcy5zb3J0KGxlbmd0aGNtcCk7XG4gICAgcGllY2VzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gY3JlYXRlQnJhY2tldE9yUmVnRXhwKHBpZWNlcyk7XG59XG4vKipcbiAqIE1hdGNoaW5nIGEgcmVndWxhciBleHByZXNzaW9uIGluIEpTIGNhbiBvbmx5IGJlIGRvbmUgXCJmb3J3YXJkc1wiLiBTbyBKUyBvZmZlcnMgbmF0aXZlbHkgb25seVxuICogbWV0aG9kcyB0byBmaW5kIHRoZSBmaXJzdCBtYXRjaCBvZiBhIHJlZ2V4IGluIGEgc3RyaW5nLiBCdXQgc29tZXRpbWVzLCBpdCBpcyB1c2VmdWwgdG9cbiAqIGZpbmQgdGhlIGxhc3QgbWF0Y2ggb2YgYSByZWdleCBpbiBhIHN0cmluZy4gRm9yIHN1Y2ggYSBzaXR1YXRpb24sIGEgbmljZSBzb2x1dGlvbiBpcyB0b1xuICogc2ltcGx5IHJldmVyc2UgdGhlIHN0cmluZyBhbmQgdGhlbiBzZWFyY2ggZm9yIGEgcmV2ZXJzZWQgcmVnZXguXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbHNvIGhhcyB0aGUgZmluZSBkZXRhaWxzIG9mIGBnZXRSZWdleEZvckJyYWNrZXRQYWlyYC4gRm9yIHRoZSBzYW1lIGV4YW1wbGVcbiAqIGdpdmVuIGFib3ZlLCB0aGUgcmVnZXggcHJvZHVjZWQgaGVyZSB3b3VsZCBsb29rIGxpa2U6XG4gKiAgIC8oXFxiZmkgZG5lXFxiKXwoXFxiZG5lXFxiKXwoXFxiZmlcXGIpL1xuICovXG5mdW5jdGlvbiBnZXRSZXZlcnNlZFJlZ2V4Rm9yQnJhY2tldFBhaXIob3BlbiwgY2xvc2UsIGJyYWNrZXRzLCBjdXJyZW50SW5kZXgpIHtcbiAgICAvLyBzZWFyY2ggaW4gYWxsIGJyYWNrZXRzIGZvciBvdGhlciBicmFja2V0cyB0aGF0IGFyZSBhIHN1cGVyc3RyaW5nIG9mIHRoZXNlIGJyYWNrZXRzXG4gICAgbGV0IHBpZWNlcyA9IFtdO1xuICAgIHBpZWNlcyA9IHBpZWNlcy5jb25jYXQob3Blbik7XG4gICAgcGllY2VzID0gcGllY2VzLmNvbmNhdChjbG9zZSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBpZWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb2xsZWN0U3VwZXJzdHJpbmdzKHBpZWNlc1tpXSwgYnJhY2tldHMsIGN1cnJlbnRJbmRleCwgcGllY2VzKTtcbiAgICB9XG4gICAgcGllY2VzID0gdW5pcXVlKHBpZWNlcyk7XG4gICAgcGllY2VzLnNvcnQobGVuZ3RoY21wKTtcbiAgICBwaWVjZXMucmV2ZXJzZSgpO1xuICAgIHJldHVybiBjcmVhdGVCcmFja2V0T3JSZWdFeHAocGllY2VzLm1hcCh0b1JldmVyc2VkU3RyaW5nKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCB0YXJnZXRzIGFsbCBicmFja2V0IHBhaXJzLlxuICpcbiAqIGUuZy4gZm9yIHRoZSBicmFja2V0IHBhaXJzOlxuICogIFsneycsJ30nXVxuICogIFsnYmVnaW4sJ2VuZCddXG4gKiAgWydmb3InLCdlbmQnXVxuICogdGhlIHJlZ2V4IHdvdWxkIGxvb2sgbGlrZTpcbiAqICAvKFxceyl8KFxcfSl8KFxcYmJlZ2luXFxiKXwoXFxiZW5kXFxiKXwoXFxiZm9yXFxiKS9cbiAqL1xuZnVuY3Rpb24gZ2V0UmVnZXhGb3JCcmFja2V0cyhicmFja2V0cykge1xuICAgIGxldCBwaWVjZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJyYWNrZXQgb2YgYnJhY2tldHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBvcGVuIG9mIGJyYWNrZXQub3Blbikge1xuICAgICAgICAgICAgcGllY2VzLnB1c2gob3Blbik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjbG9zZSBvZiBicmFja2V0LmNsb3NlKSB7XG4gICAgICAgICAgICBwaWVjZXMucHVzaChjbG9zZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGllY2VzID0gdW5pcXVlKHBpZWNlcyk7XG4gICAgcmV0dXJuIGNyZWF0ZUJyYWNrZXRPclJlZ0V4cChwaWVjZXMpO1xufVxuLyoqXG4gKiBNYXRjaGluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbiBKUyBjYW4gb25seSBiZSBkb25lIFwiZm9yd2FyZHNcIi4gU28gSlMgb2ZmZXJzIG5hdGl2ZWx5IG9ubHlcbiAqIG1ldGhvZHMgdG8gZmluZCB0aGUgZmlyc3QgbWF0Y2ggb2YgYSByZWdleCBpbiBhIHN0cmluZy4gQnV0IHNvbWV0aW1lcywgaXQgaXMgdXNlZnVsIHRvXG4gKiBmaW5kIHRoZSBsYXN0IG1hdGNoIG9mIGEgcmVnZXggaW4gYSBzdHJpbmcuIEZvciBzdWNoIGEgc2l0dWF0aW9uLCBhIG5pY2Ugc29sdXRpb24gaXMgdG9cbiAqIHNpbXBseSByZXZlcnNlIHRoZSBzdHJpbmcgYW5kIHRoZW4gc2VhcmNoIGZvciBhIHJldmVyc2VkIHJlZ2V4LlxuICpcbiAqIGUuZy4gZm9yIHRoZSBicmFja2V0IHBhaXJzOlxuICogIFsneycsJ30nXVxuICogIFsnYmVnaW4sJ2VuZCddXG4gKiAgWydmb3InLCdlbmQnXVxuICogdGhlIHJlZ2V4IHdvdWxkIGxvb2sgbGlrZTpcbiAqICAvKFxceyl8KFxcfSl8KFxcYm5pZ2ViXFxiKXwoXFxiZG5lXFxiKXwoXFxicm9mXFxiKS9cbiAqL1xuZnVuY3Rpb24gZ2V0UmV2ZXJzZWRSZWdleEZvckJyYWNrZXRzKGJyYWNrZXRzKSB7XG4gICAgbGV0IHBpZWNlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgYnJhY2tldCBvZiBicmFja2V0cykge1xuICAgICAgICBmb3IgKGNvbnN0IG9wZW4gb2YgYnJhY2tldC5vcGVuKSB7XG4gICAgICAgICAgICBwaWVjZXMucHVzaChvcGVuKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNsb3NlIG9mIGJyYWNrZXQuY2xvc2UpIHtcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKGNsb3NlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwaWVjZXMgPSB1bmlxdWUocGllY2VzKTtcbiAgICByZXR1cm4gY3JlYXRlQnJhY2tldE9yUmVnRXhwKHBpZWNlcy5tYXAodG9SZXZlcnNlZFN0cmluZykpO1xufVxuZnVuY3Rpb24gcHJlcGFyZUJyYWNrZXRGb3JSZWdFeHAoc3RyKSB7XG4gICAgLy8gVGhpcyBicmFja2V0IHBhaXIgdXNlcyBsZXR0ZXJzIGxpa2UgZS5nLiBcImJlZ2luXCIgLSBcImVuZFwiXG4gICAgY29uc3QgaW5zZXJ0V29yZEJvdW5kYXJpZXMgPSAoL15bXFx3IF0rJC8udGVzdChzdHIpKTtcbiAgICBzdHIgPSBzdHJpbmdzLmVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoc3RyKTtcbiAgICByZXR1cm4gKGluc2VydFdvcmRCb3VuZGFyaWVzID8gYFxcXFxiJHtzdHJ9XFxcXGJgIDogc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCcmFja2V0T3JSZWdFeHAocGllY2VzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVnZXhTdHIgPSBgKCR7cGllY2VzLm1hcChwcmVwYXJlQnJhY2tldEZvclJlZ0V4cCkuam9pbignKXwoJyl9KWA7XG4gICAgcmV0dXJuIHN0cmluZ3MuY3JlYXRlUmVnRXhwKHJlZ2V4U3RyLCB0cnVlLCBvcHRpb25zKTtcbn1cbmNvbnN0IHRvUmV2ZXJzZWRTdHJpbmcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHJldmVyc2Uoc3RyKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIFVpbnQxNkFycmF5IGFuZCB0aGVuIHVzZSBhIFRleHREZWNvZGVyIHRvIGNyZWF0ZSBhIHN0cmluZ1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDE2QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBhcnJbb2Zmc2V0KytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ0J1aWxkZXIuZ2V0UGxhdGZvcm1UZXh0RGVjb2RlcigpLmRlY29kZShhcnIpO1xuICAgIH1cbiAgICBsZXQgbGFzdElucHV0ID0gbnVsbDtcbiAgICBsZXQgbGFzdE91dHB1dCA9IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvUmV2ZXJzZWRTdHJpbmcoc3RyKSB7XG4gICAgICAgIGlmIChsYXN0SW5wdXQgIT09IHN0cikge1xuICAgICAgICAgICAgbGFzdElucHV0ID0gc3RyO1xuICAgICAgICAgICAgbGFzdE91dHB1dCA9IHJldmVyc2UobGFzdElucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdE91dHB1dDtcbiAgICB9O1xufSkoKTtcbmV4cG9ydCBjbGFzcyBCcmFja2V0c1V0aWxzIHtcbiAgICBzdGF0aWMgX2ZpbmRQcmV2QnJhY2tldEluVGV4dChyZXZlcnNlZEJyYWNrZXRSZWdleCwgbGluZU51bWJlciwgcmV2ZXJzZWRUZXh0LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgbSA9IHJldmVyc2VkVGV4dC5tYXRjaChyZXZlcnNlZEJyYWNrZXRSZWdleCk7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hPZmZzZXQgPSByZXZlcnNlZFRleHQubGVuZ3RoIC0gKG0uaW5kZXggfHwgMCk7XG4gICAgICAgIGNvbnN0IG1hdGNoTGVuZ3RoID0gbVswXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFic29sdXRlTWF0Y2hPZmZzZXQgPSBvZmZzZXQgKyBtYXRjaE9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShsaW5lTnVtYmVyLCBhYnNvbHV0ZU1hdGNoT2Zmc2V0IC0gbWF0Y2hMZW5ndGggKyAxLCBsaW5lTnVtYmVyLCBhYnNvbHV0ZU1hdGNoT2Zmc2V0ICsgMSk7XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kUHJldkJyYWNrZXRJblJhbmdlKHJldmVyc2VkQnJhY2tldFJlZ2V4LCBsaW5lTnVtYmVyLCBsaW5lVGV4dCwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgICAgICAvLyBCZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgYmFja3dhcmRzIHJlZ2V4IHNlYXJjaCwgd2Ugc2VhcmNoIGZvcndhcmRzIGluIGEgcmV2ZXJzZWQgc3RyaW5nIHdpdGggYSByZXZlcnNlZCByZWdleCA7KVxuICAgICAgICBjb25zdCByZXZlcnNlZExpbmVUZXh0ID0gdG9SZXZlcnNlZFN0cmluZyhsaW5lVGV4dCk7XG4gICAgICAgIGNvbnN0IHJldmVyc2VkU3Vic3RyID0gcmV2ZXJzZWRMaW5lVGV4dC5zdWJzdHJpbmcobGluZVRleHQubGVuZ3RoIC0gZW5kT2Zmc2V0LCBsaW5lVGV4dC5sZW5ndGggLSBzdGFydE9mZnNldCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kUHJldkJyYWNrZXRJblRleHQocmV2ZXJzZWRCcmFja2V0UmVnZXgsIGxpbmVOdW1iZXIsIHJldmVyc2VkU3Vic3RyLCBzdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kTmV4dEJyYWNrZXRJblRleHQoYnJhY2tldFJlZ2V4LCBsaW5lTnVtYmVyLCB0ZXh0LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgbSA9IHRleHQubWF0Y2goYnJhY2tldFJlZ2V4KTtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaE9mZnNldCA9IG0uaW5kZXggfHwgMDtcbiAgICAgICAgY29uc3QgbWF0Y2hMZW5ndGggPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgaWYgKG1hdGNoTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYnNvbHV0ZU1hdGNoT2Zmc2V0ID0gb2Zmc2V0ICsgbWF0Y2hPZmZzZXQ7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UobGluZU51bWJlciwgYWJzb2x1dGVNYXRjaE9mZnNldCArIDEsIGxpbmVOdW1iZXIsIGFic29sdXRlTWF0Y2hPZmZzZXQgKyAxICsgbWF0Y2hMZW5ndGgpO1xuICAgIH1cbiAgICBzdGF0aWMgZmluZE5leHRCcmFja2V0SW5SYW5nZShicmFja2V0UmVnZXgsIGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHN1YnN0ciA9IGxpbmVUZXh0LnN1YnN0cmluZyhzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZE5leHRCcmFja2V0SW5UZXh0KGJyYWNrZXRSZWdleCwgbGluZU51bWJlciwgc3Vic3RyLCBzdGFydE9mZnNldCk7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBDYWxsYmFja0l0ZXJhYmxlLCBjb21wYXJlQnkgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2V2ZW50LmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGUsIERpc3Bvc2FibGVTdG9yZSwgTXV0YWJsZURpc3Bvc2FibGUgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi8uLi9jb3JlL3JhbmdlLmpzJztcbmltcG9ydCB7IGlnbm9yZUJyYWNrZXRzSW5Ub2tlbiB9IGZyb20gJy4uLy4uL2xhbmd1YWdlcy9zdXBwb3J0cy5qcyc7XG5pbXBvcnQgeyBCcmFja2V0c1V0aWxzIH0gZnJvbSAnLi4vLi4vbGFuZ3VhZ2VzL3N1cHBvcnRzL3JpY2hFZGl0QnJhY2tldHMuanMnO1xuaW1wb3J0IHsgQnJhY2tldFBhaXJzVHJlZSB9IGZyb20gJy4vYnJhY2tldFBhaXJzVHJlZS9icmFja2V0UGFpcnNUcmVlLmpzJztcbmV4cG9ydCBjbGFzcyBCcmFja2V0UGFpcnNUZXh0TW9kZWxQYXJ0IGV4dGVuZHMgRGlzcG9zYWJsZSB7XG4gICAgZ2V0IGNhbkJ1aWxkQVNUKCkge1xuICAgICAgICBjb25zdCBtYXhTdXBwb3J0ZWREb2N1bWVudExlbmd0aCA9IC8qIG1heCBsaW5lcyAqLyA1MF8wMDAgKiAvKiBhdmVyYWdlIGNvbHVtbiBjb3VudCAqLyAxMDA7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRNb2RlbC5nZXRWYWx1ZUxlbmd0aCgpIDw9IG1heFN1cHBvcnRlZERvY3VtZW50TGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0TW9kZWwsIGxhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0TW9kZWwgPSB0ZXh0TW9kZWw7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZSA9IGxhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuYnJhY2tldFBhaXJzVHJlZSA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBNdXRhYmxlRGlzcG9zYWJsZSgpKTtcbiAgICAgICAgdGhpcy5vbkRpZENoYW5nZUVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlID0gdGhpcy5vbkRpZENoYW5nZUVtaXR0ZXIuZXZlbnQ7XG4gICAgICAgIHRoaXMuYnJhY2tldHNSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8jcmVnaW9uIFRleHRNb2RlbCBldmVudHNcbiAgICBoYW5kbGVMYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlQ2hhbmdlKGUpIHtcbiAgICAgICAgaWYgKCFlLmxhbmd1YWdlSWQgfHwgdGhpcy5icmFja2V0UGFpcnNUcmVlLnZhbHVlPy5vYmplY3QuZGlkTGFuZ3VhZ2VDaGFuZ2UoZS5sYW5ndWFnZUlkKSkge1xuICAgICAgICAgICAgdGhpcy5icmFja2V0UGFpcnNUcmVlLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJyYWNrZXRQYWlyc1RyZWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEaWRDaGFuZ2VPcHRpb25zKGUpIHtcbiAgICAgICAgdGhpcy5icmFja2V0UGFpcnNUcmVlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQnJhY2tldFBhaXJzVHJlZSgpO1xuICAgIH1cbiAgICBoYW5kbGVEaWRDaGFuZ2VMYW5ndWFnZShlKSB7XG4gICAgICAgIHRoaXMuYnJhY2tldFBhaXJzVHJlZS5jbGVhcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJyYWNrZXRQYWlyc1RyZWUoKTtcbiAgICB9XG4gICAgaGFuZGxlRGlkQ2hhbmdlQ29udGVudChjaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5icmFja2V0UGFpcnNUcmVlLnZhbHVlPy5vYmplY3QuaGFuZGxlQ29udGVudENoYW5nZWQoY2hhbmdlKTtcbiAgICB9XG4gICAgaGFuZGxlRGlkQ2hhbmdlQmFja2dyb3VuZFRva2VuaXphdGlvblN0YXRlKCkge1xuICAgICAgICB0aGlzLmJyYWNrZXRQYWlyc1RyZWUudmFsdWU/Lm9iamVjdC5oYW5kbGVEaWRDaGFuZ2VCYWNrZ3JvdW5kVG9rZW5pemF0aW9uU3RhdGUoKTtcbiAgICB9XG4gICAgaGFuZGxlRGlkQ2hhbmdlVG9rZW5zKGUpIHtcbiAgICAgICAgdGhpcy5icmFja2V0UGFpcnNUcmVlLnZhbHVlPy5vYmplY3QuaGFuZGxlRGlkQ2hhbmdlVG9rZW5zKGUpO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgICB1cGRhdGVCcmFja2V0UGFpcnNUcmVlKCkge1xuICAgICAgICBpZiAodGhpcy5icmFja2V0c1JlcXVlc3RlZCAmJiB0aGlzLmNhbkJ1aWxkQVNUKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYnJhY2tldFBhaXJzVHJlZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gbmV3IERpc3Bvc2FibGVTdG9yZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnJhY2tldFBhaXJzVHJlZS52YWx1ZSA9IGNyZWF0ZURpc3Bvc2FibGVSZWYoc3RvcmUuYWRkKG5ldyBCcmFja2V0UGFpcnNUcmVlKHRoaXMudGV4dE1vZGVsLCAobGFuZ3VhZ2VJZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlLmdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKTtcbiAgICAgICAgICAgICAgICB9KSksIHN0b3JlKTtcbiAgICAgICAgICAgICAgICBzdG9yZS5hZGQodGhpcy5icmFja2V0UGFpcnNUcmVlLnZhbHVlLm9iamVjdC5vbkRpZENoYW5nZShlID0+IHRoaXMub25EaWRDaGFuZ2VFbWl0dGVyLmZpcmUoZSkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlRW1pdHRlci5maXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5icmFja2V0UGFpcnNUcmVlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icmFja2V0UGFpcnNUcmVlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgLy8gSW1wb3J0YW50OiBEb24ndCBjYWxsIGZpcmUgaWYgdGhlcmUgd2FzIG5vIGNoYW5nZSFcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlRW1pdHRlci5maXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYnJhY2tldCBwYWlycyB0aGF0IGludGVyc2VjdCB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgICogVGhlIHJlc3VsdCBpcyBzb3J0ZWQgYnkgdGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0QnJhY2tldFBhaXJzSW5SYW5nZShyYW5nZSkge1xuICAgICAgICB0aGlzLmJyYWNrZXRzUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVCcmFja2V0UGFpcnNUcmVlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJyYWNrZXRQYWlyc1RyZWUudmFsdWU/Lm9iamVjdC5nZXRCcmFja2V0UGFpcnNJblJhbmdlKHJhbmdlLCBmYWxzZSkgfHwgQ2FsbGJhY2tJdGVyYWJsZS5lbXB0eTtcbiAgICB9XG4gICAgZ2V0QnJhY2tldFBhaXJzSW5SYW5nZVdpdGhNaW5JbmRlbnRhdGlvbihyYW5nZSkge1xuICAgICAgICB0aGlzLmJyYWNrZXRzUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVCcmFja2V0UGFpcnNUcmVlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJyYWNrZXRQYWlyc1RyZWUudmFsdWU/Lm9iamVjdC5nZXRCcmFja2V0UGFpcnNJblJhbmdlKHJhbmdlLCB0cnVlKSB8fCBDYWxsYmFja0l0ZXJhYmxlLmVtcHR5O1xuICAgIH1cbiAgICBnZXRCcmFja2V0c0luUmFuZ2UocmFuZ2UsIG9ubHlDb2xvcml6ZWRCcmFja2V0cyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYnJhY2tldHNSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUJyYWNrZXRQYWlyc1RyZWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJhY2tldFBhaXJzVHJlZS52YWx1ZT8ub2JqZWN0LmdldEJyYWNrZXRzSW5SYW5nZShyYW5nZSwgb25seUNvbG9yaXplZEJyYWNrZXRzKSB8fCBDYWxsYmFja0l0ZXJhYmxlLmVtcHR5O1xuICAgIH1cbiAgICBmaW5kTWF0Y2hpbmdCcmFja2V0VXAoX2JyYWNrZXQsIF9wb3NpdGlvbiwgbWF4RHVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnRleHRNb2RlbC52YWxpZGF0ZVBvc2l0aW9uKF9wb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGxhbmd1YWdlSWQgPSB0aGlzLnRleHRNb2RlbC5nZXRMYW5ndWFnZUlkQXRQb3NpdGlvbihwb3NpdGlvbi5saW5lTnVtYmVyLCBwb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICBpZiAodGhpcy5jYW5CdWlsZEFTVCkge1xuICAgICAgICAgICAgY29uc3QgY2xvc2luZ0JyYWNrZXRJbmZvID0gdGhpcy5sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlXG4gICAgICAgICAgICAgICAgLmdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKVxuICAgICAgICAgICAgICAgIC5icmFja2V0c05ldy5nZXRDbG9zaW5nQnJhY2tldEluZm8oX2JyYWNrZXQpO1xuICAgICAgICAgICAgaWYgKCFjbG9zaW5nQnJhY2tldEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJyYWNrZXRQYWlyID0gdGhpcy5nZXRCcmFja2V0UGFpcnNJblJhbmdlKFJhbmdlLmZyb21Qb3NpdGlvbnMoX3Bvc2l0aW9uLCBfcG9zaXRpb24pKS5maW5kTGFzdCgoYikgPT4gY2xvc2luZ0JyYWNrZXRJbmZvLmNsb3NlcyhiLm9wZW5pbmdCcmFja2V0SW5mbykpO1xuICAgICAgICAgICAgaWYgKGJyYWNrZXRQYWlyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyYWNrZXRQYWlyLm9wZW5pbmdCcmFja2V0UmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIG9sZCBicmFja2V0IG1hdGNoaW5nIGNvZGU6XG4gICAgICAgICAgICBjb25zdCBicmFja2V0ID0gX2JyYWNrZXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGJyYWNrZXRzU3VwcG9ydCA9IHRoaXMubGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZS5nZXRMYW5ndWFnZUNvbmZpZ3VyYXRpb24obGFuZ3VhZ2VJZCkuYnJhY2tldHM7XG4gICAgICAgICAgICBpZiAoIWJyYWNrZXRzU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGJyYWNrZXRzU3VwcG9ydC50ZXh0SXNCcmFja2V0W2JyYWNrZXRdO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyaXBCcmFja2V0U2VhcmNoQ2FuY2VsZWQodGhpcy5fZmluZE1hdGNoaW5nQnJhY2tldFVwKGRhdGEsIHBvc2l0aW9uLCBjcmVhdGVUaW1lQmFzZWRDb250aW51ZUJyYWNrZXRTZWFyY2hQcmVkaWNhdGUobWF4RHVyYXRpb24pKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2hCcmFja2V0KHBvc2l0aW9uLCBtYXhEdXJhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5jYW5CdWlsZEFTVCkge1xuICAgICAgICAgICAgY29uc3QgYnJhY2tldFBhaXIgPSB0aGlzLmdldEJyYWNrZXRQYWlyc0luUmFuZ2UoUmFuZ2UuZnJvbVBvc2l0aW9ucyhwb3NpdGlvbiwgcG9zaXRpb24pKS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uY2xvc2luZ0JyYWNrZXRSYW5nZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgKGl0ZW0ub3BlbmluZ0JyYWNrZXRSYW5nZS5jb250YWluc1Bvc2l0aW9uKHBvc2l0aW9uKSB8fFxuICAgICAgICAgICAgICAgICAgICBpdGVtLmNsb3NpbmdCcmFja2V0UmFuZ2UuY29udGFpbnNQb3NpdGlvbihwb3NpdGlvbikpKS5maW5kTGFzdE1heEJ5KGNvbXBhcmVCeSgoaXRlbSkgPT4gaXRlbS5vcGVuaW5nQnJhY2tldFJhbmdlLmNvbnRhaW5zUG9zaXRpb24ocG9zaXRpb24pXG4gICAgICAgICAgICAgICAgPyBpdGVtLm9wZW5pbmdCcmFja2V0UmFuZ2VcbiAgICAgICAgICAgICAgICA6IGl0ZW0uY2xvc2luZ0JyYWNrZXRSYW5nZSwgUmFuZ2UuY29tcGFyZVJhbmdlc1VzaW5nU3RhcnRzKSk7XG4gICAgICAgICAgICBpZiAoYnJhY2tldFBhaXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2JyYWNrZXRQYWlyLm9wZW5pbmdCcmFja2V0UmFuZ2UsIGJyYWNrZXRQYWlyLmNsb3NpbmdCcmFja2V0UmFuZ2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBvbGQgYnJhY2tldCBtYXRjaGluZyBjb2RlOlxuICAgICAgICAgICAgY29uc3QgY29udGludWVTZWFyY2hQcmVkaWNhdGUgPSBjcmVhdGVUaW1lQmFzZWRDb250aW51ZUJyYWNrZXRTZWFyY2hQcmVkaWNhdGUobWF4RHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hdGNoQnJhY2tldCh0aGlzLnRleHRNb2RlbC52YWxpZGF0ZVBvc2l0aW9uKHBvc2l0aW9uKSwgY29udGludWVTZWFyY2hQcmVkaWNhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lc3RhYmxpc2hCcmFja2V0U2VhcmNoT2Zmc2V0cyhwb3NpdGlvbiwgbGluZVRva2VucywgbW9kZUJyYWNrZXRzLCB0b2tlbkluZGV4KSB7XG4gICAgICAgIGNvbnN0IHRva2VuQ291bnQgPSBsaW5lVG9rZW5zLmdldENvdW50KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMYW5ndWFnZUlkID0gbGluZVRva2Vucy5nZXRMYW5ndWFnZUlkKHRva2VuSW5kZXgpO1xuICAgICAgICAvLyBsaW1pdCBzZWFyY2ggdG8gbm90IGdvIGJlZm9yZSBgbWF4QnJhY2tldExlbmd0aGBcbiAgICAgICAgbGV0IHNlYXJjaFN0YXJ0T2Zmc2V0ID0gTWF0aC5tYXgoMCwgcG9zaXRpb24uY29sdW1uIC0gMSAtIG1vZGVCcmFja2V0cy5tYXhCcmFja2V0TGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRva2VuSW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5FbmRPZmZzZXQgPSBsaW5lVG9rZW5zLmdldEVuZE9mZnNldChpKTtcbiAgICAgICAgICAgIGlmICh0b2tlbkVuZE9mZnNldCA8PSBzZWFyY2hTdGFydE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlnbm9yZUJyYWNrZXRzSW5Ub2tlbihsaW5lVG9rZW5zLmdldFN0YW5kYXJkVG9rZW5UeXBlKGkpKSB8fCBsaW5lVG9rZW5zLmdldExhbmd1YWdlSWQoaSkgIT09IGN1cnJlbnRMYW5ndWFnZUlkKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoU3RhcnRPZmZzZXQgPSB0b2tlbkVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsaW1pdCBzZWFyY2ggdG8gbm90IGdvIGFmdGVyIGBtYXhCcmFja2V0TGVuZ3RoYFxuICAgICAgICBsZXQgc2VhcmNoRW5kT2Zmc2V0ID0gTWF0aC5taW4obGluZVRva2Vucy5nZXRMaW5lQ29udGVudCgpLmxlbmd0aCwgcG9zaXRpb24uY29sdW1uIC0gMSArIG1vZGVCcmFja2V0cy5tYXhCcmFja2V0TGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRva2VuSW5kZXggKyAxOyBpIDwgdG9rZW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlblN0YXJ0T2Zmc2V0ID0gbGluZVRva2Vucy5nZXRTdGFydE9mZnNldChpKTtcbiAgICAgICAgICAgIGlmICh0b2tlblN0YXJ0T2Zmc2V0ID49IHNlYXJjaEVuZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlnbm9yZUJyYWNrZXRzSW5Ub2tlbihsaW5lVG9rZW5zLmdldFN0YW5kYXJkVG9rZW5UeXBlKGkpKSB8fCBsaW5lVG9rZW5zLmdldExhbmd1YWdlSWQoaSkgIT09IGN1cnJlbnRMYW5ndWFnZUlkKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoRW5kT2Zmc2V0ID0gdG9rZW5TdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0IH07XG4gICAgfVxuICAgIF9tYXRjaEJyYWNrZXQocG9zaXRpb24sIGNvbnRpbnVlU2VhcmNoUHJlZGljYXRlKSB7XG4gICAgICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBwb3NpdGlvbi5saW5lTnVtYmVyO1xuICAgICAgICBjb25zdCBsaW5lVG9rZW5zID0gdGhpcy50ZXh0TW9kZWwudG9rZW5pemF0aW9uLmdldExpbmVUb2tlbnMobGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IGxpbmVUZXh0ID0gdGhpcy50ZXh0TW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IHRva2VuSW5kZXggPSBsaW5lVG9rZW5zLmZpbmRUb2tlbkluZGV4QXRPZmZzZXQocG9zaXRpb24uY29sdW1uIC0gMSk7XG4gICAgICAgIGlmICh0b2tlbkluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudE1vZGVCcmFja2V0cyA9IHRoaXMubGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZS5nZXRMYW5ndWFnZUNvbmZpZ3VyYXRpb24obGluZVRva2Vucy5nZXRMYW5ndWFnZUlkKHRva2VuSW5kZXgpKS5icmFja2V0cztcbiAgICAgICAgLy8gY2hlY2sgdGhhdCB0aGUgdG9rZW4gaXMgbm90IHRvIGJlIGlnbm9yZWRcbiAgICAgICAgaWYgKGN1cnJlbnRNb2RlQnJhY2tldHMgJiYgIWlnbm9yZUJyYWNrZXRzSW5Ub2tlbihsaW5lVG9rZW5zLmdldFN0YW5kYXJkVG9rZW5UeXBlKHRva2VuSW5kZXgpKSkge1xuICAgICAgICAgICAgbGV0IHsgc2VhcmNoU3RhcnRPZmZzZXQsIHNlYXJjaEVuZE9mZnNldCB9ID0gdGhpcy5fZXN0YWJsaXNoQnJhY2tldFNlYXJjaE9mZnNldHMocG9zaXRpb24sIGxpbmVUb2tlbnMsIGN1cnJlbnRNb2RlQnJhY2tldHMsIHRva2VuSW5kZXgpO1xuICAgICAgICAgICAgLy8gaXQgbWlnaHQgYmUgdGhlIGNhc2UgdGhhdCBbY3VycmVudFRva2VuU3RhcnQgLT4gY3VycmVudFRva2VuRW5kXSBjb250YWlucyBtdWx0aXBsZSBicmFja2V0c1xuICAgICAgICAgICAgLy8gYGJlc3RSZXN1bHRgIHdpbGwgY29udGFpbiB0aGUgbW9zdCByaWdodC1zaWRlIHJlc3VsdFxuICAgICAgICAgICAgbGV0IGJlc3RSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEJyYWNrZXQgPSBCcmFja2V0c1V0aWxzLmZpbmROZXh0QnJhY2tldEluUmFuZ2UoY3VycmVudE1vZGVCcmFja2V0cy5mb3J3YXJkUmVnZXgsIGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kQnJhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gbW9yZSBicmFja2V0cyBpbiB0aGlzIHRleHRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgd2UgZGlkbid0IGhpdCBhIGJyYWNrZXQgdG9vIGZhciBhd2F5IGZyb20gcG9zaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoZm91bmRCcmFja2V0LnN0YXJ0Q29sdW1uIDw9IHBvc2l0aW9uLmNvbHVtbiAmJiBwb3NpdGlvbi5jb2x1bW4gPD0gZm91bmRCcmFja2V0LmVuZENvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEJyYWNrZXRUZXh0ID0gbGluZVRleHQuc3Vic3RyaW5nKGZvdW5kQnJhY2tldC5zdGFydENvbHVtbiAtIDEsIGZvdW5kQnJhY2tldC5lbmRDb2x1bW4gLSAxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5fbWF0Y2hGb3VuZEJyYWNrZXQoZm91bmRCcmFja2V0LCBjdXJyZW50TW9kZUJyYWNrZXRzLnRleHRJc0JyYWNrZXRbZm91bmRCcmFja2V0VGV4dF0sIGN1cnJlbnRNb2RlQnJhY2tldHMudGV4dElzT3BlbkJyYWNrZXRbZm91bmRCcmFja2V0VGV4dF0sIGNvbnRpbnVlU2VhcmNoUHJlZGljYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgQnJhY2tldFNlYXJjaENhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0UmVzdWx0ID0gcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWFyY2hTdGFydE9mZnNldCA9IGZvdW5kQnJhY2tldC5lbmRDb2x1bW4gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdFJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBwb3NpdGlvbiBpcyBpbiBiZXR3ZWVuIHR3byB0b2tlbnMsIHRyeSBhbHNvIGxvb2tpbmcgaW4gdGhlIHByZXZpb3VzIHRva2VuXG4gICAgICAgIGlmICh0b2tlbkluZGV4ID4gMCAmJiBsaW5lVG9rZW5zLmdldFN0YXJ0T2Zmc2V0KHRva2VuSW5kZXgpID09PSBwb3NpdGlvbi5jb2x1bW4gLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2VG9rZW5JbmRleCA9IHRva2VuSW5kZXggLSAxO1xuICAgICAgICAgICAgY29uc3QgcHJldk1vZGVCcmFja2V0cyA9IHRoaXMubGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZS5nZXRMYW5ndWFnZUNvbmZpZ3VyYXRpb24obGluZVRva2Vucy5nZXRMYW5ndWFnZUlkKHByZXZUb2tlbkluZGV4KSkuYnJhY2tldHM7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IHByZXZpb3VzIHRva2VuIGlzIG5vdCB0byBiZSBpZ25vcmVkXG4gICAgICAgICAgICBpZiAocHJldk1vZGVCcmFja2V0cyAmJiAhaWdub3JlQnJhY2tldHNJblRva2VuKGxpbmVUb2tlbnMuZ2V0U3RhbmRhcmRUb2tlblR5cGUocHJldlRva2VuSW5kZXgpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VhcmNoU3RhcnRPZmZzZXQsIHNlYXJjaEVuZE9mZnNldCB9ID0gdGhpcy5fZXN0YWJsaXNoQnJhY2tldFNlYXJjaE9mZnNldHMocG9zaXRpb24sIGxpbmVUb2tlbnMsIHByZXZNb2RlQnJhY2tldHMsIHByZXZUb2tlbkluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEJyYWNrZXQgPSBCcmFja2V0c1V0aWxzLmZpbmRQcmV2QnJhY2tldEluUmFuZ2UocHJldk1vZGVCcmFja2V0cy5yZXZlcnNlZFJlZ2V4LCBsaW5lTnVtYmVyLCBsaW5lVGV4dCwgc2VhcmNoU3RhcnRPZmZzZXQsIHNlYXJjaEVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCB3ZSBkaWRuJ3QgaGl0IGEgYnJhY2tldCB0b28gZmFyIGF3YXkgZnJvbSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGlmIChmb3VuZEJyYWNrZXQgJiYgZm91bmRCcmFja2V0LnN0YXJ0Q29sdW1uIDw9IHBvc2l0aW9uLmNvbHVtbiAmJiBwb3NpdGlvbi5jb2x1bW4gPD0gZm91bmRCcmFja2V0LmVuZENvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEJyYWNrZXRUZXh0ID0gbGluZVRleHQuc3Vic3RyaW5nKGZvdW5kQnJhY2tldC5zdGFydENvbHVtbiAtIDEsIGZvdW5kQnJhY2tldC5lbmRDb2x1bW4gLSAxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5fbWF0Y2hGb3VuZEJyYWNrZXQoZm91bmRCcmFja2V0LCBwcmV2TW9kZUJyYWNrZXRzLnRleHRJc0JyYWNrZXRbZm91bmRCcmFja2V0VGV4dF0sIHByZXZNb2RlQnJhY2tldHMudGV4dElzT3BlbkJyYWNrZXRbZm91bmRCcmFja2V0VGV4dF0sIGNvbnRpbnVlU2VhcmNoUHJlZGljYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgQnJhY2tldFNlYXJjaENhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX21hdGNoRm91bmRCcmFja2V0KGZvdW5kQnJhY2tldCwgZGF0YSwgaXNPcGVuLCBjb250aW51ZVNlYXJjaFByZWRpY2F0ZSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoZWQgPSAoaXNPcGVuXG4gICAgICAgICAgICA/IHRoaXMuX2ZpbmRNYXRjaGluZ0JyYWNrZXREb3duKGRhdGEsIGZvdW5kQnJhY2tldC5nZXRFbmRQb3NpdGlvbigpLCBjb250aW51ZVNlYXJjaFByZWRpY2F0ZSlcbiAgICAgICAgICAgIDogdGhpcy5fZmluZE1hdGNoaW5nQnJhY2tldFVwKGRhdGEsIGZvdW5kQnJhY2tldC5nZXRTdGFydFBvc2l0aW9uKCksIGNvbnRpbnVlU2VhcmNoUHJlZGljYXRlKSk7XG4gICAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoZWQgaW5zdGFuY2VvZiBCcmFja2V0U2VhcmNoQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZm91bmRCcmFja2V0LCBtYXRjaGVkXTtcbiAgICB9XG4gICAgX2ZpbmRNYXRjaGluZ0JyYWNrZXRVcChicmFja2V0LCBwb3NpdGlvbiwgY29udGludWVTZWFyY2hQcmVkaWNhdGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ19maW5kTWF0Y2hpbmdCcmFja2V0VXA6ICcsICdicmFja2V0OiAnLCBKU09OLnN0cmluZ2lmeShicmFja2V0KSwgJ3N0YXJ0UG9zaXRpb246ICcsIFN0cmluZyhwb3NpdGlvbikpO1xuICAgICAgICBjb25zdCBsYW5ndWFnZUlkID0gYnJhY2tldC5sYW5ndWFnZUlkO1xuICAgICAgICBjb25zdCByZXZlcnNlZEJyYWNrZXRSZWdleCA9IGJyYWNrZXQucmV2ZXJzZWRSZWdleDtcbiAgICAgICAgbGV0IGNvdW50ID0gLTE7XG4gICAgICAgIGxldCB0b3RhbENhbGxDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IHNlYXJjaFByZXZNYXRjaGluZ0JyYWNrZXRJblJhbmdlID0gKGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250aW51ZVNlYXJjaFByZWRpY2F0ZSAmJiAoKyt0b3RhbENhbGxDb3VudCkgJSAxMDAgPT09IDAgJiYgIWNvbnRpbnVlU2VhcmNoUHJlZGljYXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJyYWNrZXRTZWFyY2hDYW5jZWxlZC5JTlNUQU5DRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IEJyYWNrZXRzVXRpbHMuZmluZFByZXZCcmFja2V0SW5SYW5nZShyZXZlcnNlZEJyYWNrZXRSZWdleCwgbGluZU51bWJlciwgbGluZVRleHQsIHNlYXJjaFN0YXJ0T2Zmc2V0LCBzZWFyY2hFbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGl0VGV4dCA9IGxpbmVUZXh0LnN1YnN0cmluZyhyLnN0YXJ0Q29sdW1uIC0gMSwgci5lbmRDb2x1bW4gLSAxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChicmFja2V0LmlzT3BlbihoaXRUZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChicmFja2V0LmlzQ2xvc2UoaGl0VGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWFyY2hFbmRPZmZzZXQgPSByLnN0YXJ0Q29sdW1uIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gcG9zaXRpb24ubGluZU51bWJlcjsgbGluZU51bWJlciA+PSAxOyBsaW5lTnVtYmVyLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVUb2tlbnMgPSB0aGlzLnRleHRNb2RlbC50b2tlbml6YXRpb24uZ2V0TGluZVRva2VucyhsaW5lTnVtYmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuQ291bnQgPSBsaW5lVG9rZW5zLmdldENvdW50KCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lVGV4dCA9IHRoaXMudGV4dE1vZGVsLmdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgbGV0IHRva2VuSW5kZXggPSB0b2tlbkNvdW50IC0gMTtcbiAgICAgICAgICAgIGxldCBzZWFyY2hTdGFydE9mZnNldCA9IGxpbmVUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzZWFyY2hFbmRPZmZzZXQgPSBsaW5lVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGluZU51bWJlciA9PT0gcG9zaXRpb24ubGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHRva2VuSW5kZXggPSBsaW5lVG9rZW5zLmZpbmRUb2tlbkluZGV4QXRPZmZzZXQocG9zaXRpb24uY29sdW1uIC0gMSk7XG4gICAgICAgICAgICAgICAgc2VhcmNoU3RhcnRPZmZzZXQgPSBwb3NpdGlvbi5jb2x1bW4gLSAxO1xuICAgICAgICAgICAgICAgIHNlYXJjaEVuZE9mZnNldCA9IHBvc2l0aW9uLmNvbHVtbiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJldlNlYXJjaEluVG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7IHRva2VuSW5kZXggPj0gMDsgdG9rZW5JbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoSW5Ub2tlbiA9IChsaW5lVG9rZW5zLmdldExhbmd1YWdlSWQodG9rZW5JbmRleCkgPT09IGxhbmd1YWdlSWQgJiYgIWlnbm9yZUJyYWNrZXRzSW5Ub2tlbihsaW5lVG9rZW5zLmdldFN0YW5kYXJkVG9rZW5UeXBlKHRva2VuSW5kZXgpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaEluVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB0b2tlbiBzaG91bGQgYmUgc2VhcmNoZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZTZWFyY2hJblRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgdG9rZW4gc2hvdWxkIGJlIHNlYXJjaGVkLCBzaW1wbHkgZXh0ZW5kIHNlYXJjaFN0YXJ0T2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hTdGFydE9mZnNldCA9IGxpbmVUb2tlbnMuZ2V0U3RhcnRPZmZzZXQodG9rZW5JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgdG9rZW4gc2hvdWxkIG5vdCBiZSBzZWFyY2hlZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoU3RhcnRPZmZzZXQgPSBsaW5lVG9rZW5zLmdldFN0YXJ0T2Zmc2V0KHRva2VuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoRW5kT2Zmc2V0ID0gbGluZVRva2Vucy5nZXRFbmRPZmZzZXQodG9rZW5JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdG9rZW4gc2hvdWxkIG5vdCBiZSBzZWFyY2hlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlNlYXJjaEluVG9rZW4gJiYgc2VhcmNoU3RhcnRPZmZzZXQgIT09IHNlYXJjaEVuZE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHNlYXJjaFByZXZNYXRjaGluZ0JyYWNrZXRJblJhbmdlKGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldlNlYXJjaEluVG9rZW4gPSBzZWFyY2hJblRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZTZWFyY2hJblRva2VuICYmIHNlYXJjaFN0YXJ0T2Zmc2V0ICE9PSBzZWFyY2hFbmRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gc2VhcmNoUHJldk1hdGNoaW5nQnJhY2tldEluUmFuZ2UobGluZU51bWJlciwgbGluZVRleHQsIHNlYXJjaFN0YXJ0T2Zmc2V0LCBzZWFyY2hFbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX2ZpbmRNYXRjaGluZ0JyYWNrZXREb3duKGJyYWNrZXQsIHBvc2l0aW9uLCBjb250aW51ZVNlYXJjaFByZWRpY2F0ZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnX2ZpbmRNYXRjaGluZ0JyYWNrZXREb3duOiAnLCAnYnJhY2tldDogJywgSlNPTi5zdHJpbmdpZnkoYnJhY2tldCksICdzdGFydFBvc2l0aW9uOiAnLCBTdHJpbmcocG9zaXRpb24pKTtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VJZCA9IGJyYWNrZXQubGFuZ3VhZ2VJZDtcbiAgICAgICAgY29uc3QgYnJhY2tldFJlZ2V4ID0gYnJhY2tldC5mb3J3YXJkUmVnZXg7XG4gICAgICAgIGxldCBjb3VudCA9IDE7XG4gICAgICAgIGxldCB0b3RhbENhbGxDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IHNlYXJjaE5leHRNYXRjaGluZ0JyYWNrZXRJblJhbmdlID0gKGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250aW51ZVNlYXJjaFByZWRpY2F0ZSAmJiAoKyt0b3RhbENhbGxDb3VudCkgJSAxMDAgPT09IDAgJiYgIWNvbnRpbnVlU2VhcmNoUHJlZGljYXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJyYWNrZXRTZWFyY2hDYW5jZWxlZC5JTlNUQU5DRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IEJyYWNrZXRzVXRpbHMuZmluZE5leHRCcmFja2V0SW5SYW5nZShicmFja2V0UmVnZXgsIGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhpdFRleHQgPSBsaW5lVGV4dC5zdWJzdHJpbmcoci5zdGFydENvbHVtbiAtIDEsIHIuZW5kQ29sdW1uIC0gMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2tldC5pc09wZW4oaGl0VGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYnJhY2tldC5pc0Nsb3NlKGhpdFRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VhcmNoU3RhcnRPZmZzZXQgPSByLmVuZENvbHVtbiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbGluZUNvdW50ID0gdGhpcy50ZXh0TW9kZWwuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSBwb3NpdGlvbi5saW5lTnVtYmVyOyBsaW5lTnVtYmVyIDw9IGxpbmVDb3VudDsgbGluZU51bWJlcisrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lVG9rZW5zID0gdGhpcy50ZXh0TW9kZWwudG9rZW5pemF0aW9uLmdldExpbmVUb2tlbnMobGluZU51bWJlcik7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvdW50ID0gbGluZVRva2Vucy5nZXRDb3VudCgpO1xuICAgICAgICAgICAgY29uc3QgbGluZVRleHQgPSB0aGlzLnRleHRNb2RlbC5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKTtcbiAgICAgICAgICAgIGxldCB0b2tlbkluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBzZWFyY2hTdGFydE9mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQgc2VhcmNoRW5kT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmIChsaW5lTnVtYmVyID09PSBwb3NpdGlvbi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5JbmRleCA9IGxpbmVUb2tlbnMuZmluZFRva2VuSW5kZXhBdE9mZnNldChwb3NpdGlvbi5jb2x1bW4gLSAxKTtcbiAgICAgICAgICAgICAgICBzZWFyY2hTdGFydE9mZnNldCA9IHBvc2l0aW9uLmNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgc2VhcmNoRW5kT2Zmc2V0ID0gcG9zaXRpb24uY29sdW1uIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcmV2U2VhcmNoSW5Ub2tlbiA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKDsgdG9rZW5JbmRleCA8IHRva2VuQ291bnQ7IHRva2VuSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaEluVG9rZW4gPSAobGluZVRva2Vucy5nZXRMYW5ndWFnZUlkKHRva2VuSW5kZXgpID09PSBsYW5ndWFnZUlkICYmICFpZ25vcmVCcmFja2V0c0luVG9rZW4obGluZVRva2Vucy5nZXRTdGFuZGFyZFRva2VuVHlwZSh0b2tlbkluZGV4KSkpO1xuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hJblRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdG9rZW4gc2hvdWxkIGJlIHNlYXJjaGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2U2VhcmNoSW5Ub2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIHRva2VuIHNob3VsZCBiZSBzZWFyY2hlZCwgc2ltcGx5IGV4dGVuZCBzZWFyY2hFbmRPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaEVuZE9mZnNldCA9IGxpbmVUb2tlbnMuZ2V0RW5kT2Zmc2V0KHRva2VuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIHRva2VuIHNob3VsZCBub3QgYmUgc2VhcmNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFN0YXJ0T2Zmc2V0ID0gbGluZVRva2Vucy5nZXRTdGFydE9mZnNldCh0b2tlbkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaEVuZE9mZnNldCA9IGxpbmVUb2tlbnMuZ2V0RW5kT2Zmc2V0KHRva2VuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHRva2VuIHNob3VsZCBub3QgYmUgc2VhcmNoZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZTZWFyY2hJblRva2VuICYmIHNlYXJjaFN0YXJ0T2Zmc2V0ICE9PSBzZWFyY2hFbmRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBzZWFyY2hOZXh0TWF0Y2hpbmdCcmFja2V0SW5SYW5nZShsaW5lTnVtYmVyLCBsaW5lVGV4dCwgc2VhcmNoU3RhcnRPZmZzZXQsIHNlYXJjaEVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZTZWFyY2hJblRva2VuID0gc2VhcmNoSW5Ub2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2U2VhcmNoSW5Ub2tlbiAmJiBzZWFyY2hTdGFydE9mZnNldCAhPT0gc2VhcmNoRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHNlYXJjaE5leHRNYXRjaGluZ0JyYWNrZXRJblJhbmdlKGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZpbmRQcmV2QnJhY2tldChfcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnRleHRNb2RlbC52YWxpZGF0ZVBvc2l0aW9uKF9wb3NpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmNhbkJ1aWxkQVNUKSB7XG4gICAgICAgICAgICB0aGlzLmJyYWNrZXRzUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQnJhY2tldFBhaXJzVHJlZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnJhY2tldFBhaXJzVHJlZS52YWx1ZT8ub2JqZWN0LmdldEZpcnN0QnJhY2tldEJlZm9yZShwb3NpdGlvbikgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFuZ3VhZ2VJZCA9IG51bGw7XG4gICAgICAgIGxldCBtb2RlQnJhY2tldHMgPSBudWxsO1xuICAgICAgICBsZXQgYnJhY2tldENvbmZpZyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSBwb3NpdGlvbi5saW5lTnVtYmVyOyBsaW5lTnVtYmVyID49IDE7IGxpbmVOdW1iZXItLSkge1xuICAgICAgICAgICAgY29uc3QgbGluZVRva2VucyA9IHRoaXMudGV4dE1vZGVsLnRva2VuaXphdGlvbi5nZXRMaW5lVG9rZW5zKGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5Db3VudCA9IGxpbmVUb2tlbnMuZ2V0Q291bnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVUZXh0ID0gdGhpcy50ZXh0TW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcik7XG4gICAgICAgICAgICBsZXQgdG9rZW5JbmRleCA9IHRva2VuQ291bnQgLSAxO1xuICAgICAgICAgICAgbGV0IHNlYXJjaFN0YXJ0T2Zmc2V0ID0gbGluZVRleHQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHNlYXJjaEVuZE9mZnNldCA9IGxpbmVUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsaW5lTnVtYmVyID09PSBwb3NpdGlvbi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5JbmRleCA9IGxpbmVUb2tlbnMuZmluZFRva2VuSW5kZXhBdE9mZnNldChwb3NpdGlvbi5jb2x1bW4gLSAxKTtcbiAgICAgICAgICAgICAgICBzZWFyY2hTdGFydE9mZnNldCA9IHBvc2l0aW9uLmNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgc2VhcmNoRW5kT2Zmc2V0ID0gcG9zaXRpb24uY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkxhbmd1YWdlSWQgPSBsaW5lVG9rZW5zLmdldExhbmd1YWdlSWQodG9rZW5JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlSWQgIT09IHRva2VuTGFuZ3VhZ2VJZCkge1xuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZUlkID0gdG9rZW5MYW5ndWFnZUlkO1xuICAgICAgICAgICAgICAgICAgICBtb2RlQnJhY2tldHMgPSB0aGlzLmxhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UuZ2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uKGxhbmd1YWdlSWQpLmJyYWNrZXRzO1xuICAgICAgICAgICAgICAgICAgICBicmFja2V0Q29uZmlnID0gdGhpcy5sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlLmdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKS5icmFja2V0c05ldztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJldlNlYXJjaEluVG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7IHRva2VuSW5kZXggPj0gMDsgdG9rZW5JbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5MYW5ndWFnZUlkID0gbGluZVRva2Vucy5nZXRMYW5ndWFnZUlkKHRva2VuSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZUlkICE9PSB0b2tlbkxhbmd1YWdlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFuZ3VhZ2UgaWQgY2hhbmdlIVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZUJyYWNrZXRzICYmIGJyYWNrZXRDb25maWcgJiYgcHJldlNlYXJjaEluVG9rZW4gJiYgc2VhcmNoU3RhcnRPZmZzZXQgIT09IHNlYXJjaEVuZE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IEJyYWNrZXRzVXRpbHMuZmluZFByZXZCcmFja2V0SW5SYW5nZShtb2RlQnJhY2tldHMucmV2ZXJzZWRSZWdleCwgbGluZU51bWJlciwgbGluZVRleHQsIHNlYXJjaFN0YXJ0T2Zmc2V0LCBzZWFyY2hFbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9Gb3VuZEJyYWNrZXQoYnJhY2tldENvbmZpZywgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2U2VhcmNoSW5Ub2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlSWQgPSB0b2tlbkxhbmd1YWdlSWQ7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVCcmFja2V0cyA9IHRoaXMubGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZS5nZXRMYW5ndWFnZUNvbmZpZ3VyYXRpb24obGFuZ3VhZ2VJZCkuYnJhY2tldHM7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNrZXRDb25maWcgPSB0aGlzLmxhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UuZ2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uKGxhbmd1YWdlSWQpLmJyYWNrZXRzTmV3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hJblRva2VuID0gKCEhbW9kZUJyYWNrZXRzICYmICFpZ25vcmVCcmFja2V0c0luVG9rZW4obGluZVRva2Vucy5nZXRTdGFuZGFyZFRva2VuVHlwZSh0b2tlbkluZGV4KSkpO1xuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hJblRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdG9rZW4gc2hvdWxkIGJlIHNlYXJjaGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2U2VhcmNoSW5Ub2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIHRva2VuIHNob3VsZCBiZSBzZWFyY2hlZCwgc2ltcGx5IGV4dGVuZCBzZWFyY2hTdGFydE9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoU3RhcnRPZmZzZXQgPSBsaW5lVG9rZW5zLmdldFN0YXJ0T2Zmc2V0KHRva2VuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIHRva2VuIHNob3VsZCBub3QgYmUgc2VhcmNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFN0YXJ0T2Zmc2V0ID0gbGluZVRva2Vucy5nZXRTdGFydE9mZnNldCh0b2tlbkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaEVuZE9mZnNldCA9IGxpbmVUb2tlbnMuZ2V0RW5kT2Zmc2V0KHRva2VuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHRva2VuIHNob3VsZCBub3QgYmUgc2VhcmNoZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRDb25maWcgJiYgbW9kZUJyYWNrZXRzICYmIHByZXZTZWFyY2hJblRva2VuICYmIHNlYXJjaFN0YXJ0T2Zmc2V0ICE9PSBzZWFyY2hFbmRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBCcmFja2V0c1V0aWxzLmZpbmRQcmV2QnJhY2tldEluUmFuZ2UobW9kZUJyYWNrZXRzLnJldmVyc2VkUmVnZXgsIGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvRm91bmRCcmFja2V0KGJyYWNrZXRDb25maWcsIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZTZWFyY2hJblRva2VuID0gc2VhcmNoSW5Ub2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChicmFja2V0Q29uZmlnICYmIG1vZGVCcmFja2V0cyAmJiBwcmV2U2VhcmNoSW5Ub2tlbiAmJiBzZWFyY2hTdGFydE9mZnNldCAhPT0gc2VhcmNoRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IEJyYWNrZXRzVXRpbHMuZmluZFByZXZCcmFja2V0SW5SYW5nZShtb2RlQnJhY2tldHMucmV2ZXJzZWRSZWdleCwgbGluZU51bWJlciwgbGluZVRleHQsIHNlYXJjaFN0YXJ0T2Zmc2V0LCBzZWFyY2hFbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b0ZvdW5kQnJhY2tldChicmFja2V0Q29uZmlnLCByKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZpbmROZXh0QnJhY2tldChfcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnRleHRNb2RlbC52YWxpZGF0ZVBvc2l0aW9uKF9wb3NpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmNhbkJ1aWxkQVNUKSB7XG4gICAgICAgICAgICB0aGlzLmJyYWNrZXRzUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQnJhY2tldFBhaXJzVHJlZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnJhY2tldFBhaXJzVHJlZS52YWx1ZT8ub2JqZWN0LmdldEZpcnN0QnJhY2tldEFmdGVyKHBvc2l0aW9uKSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMudGV4dE1vZGVsLmdldExpbmVDb3VudCgpO1xuICAgICAgICBsZXQgbGFuZ3VhZ2VJZCA9IG51bGw7XG4gICAgICAgIGxldCBtb2RlQnJhY2tldHMgPSBudWxsO1xuICAgICAgICBsZXQgYnJhY2tldENvbmZpZyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSBwb3NpdGlvbi5saW5lTnVtYmVyOyBsaW5lTnVtYmVyIDw9IGxpbmVDb3VudDsgbGluZU51bWJlcisrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lVG9rZW5zID0gdGhpcy50ZXh0TW9kZWwudG9rZW5pemF0aW9uLmdldExpbmVUb2tlbnMobGluZU51bWJlcik7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvdW50ID0gbGluZVRva2Vucy5nZXRDb3VudCgpO1xuICAgICAgICAgICAgY29uc3QgbGluZVRleHQgPSB0aGlzLnRleHRNb2RlbC5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKTtcbiAgICAgICAgICAgIGxldCB0b2tlbkluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBzZWFyY2hTdGFydE9mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQgc2VhcmNoRW5kT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmIChsaW5lTnVtYmVyID09PSBwb3NpdGlvbi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5JbmRleCA9IGxpbmVUb2tlbnMuZmluZFRva2VuSW5kZXhBdE9mZnNldChwb3NpdGlvbi5jb2x1bW4gLSAxKTtcbiAgICAgICAgICAgICAgICBzZWFyY2hTdGFydE9mZnNldCA9IHBvc2l0aW9uLmNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgc2VhcmNoRW5kT2Zmc2V0ID0gcG9zaXRpb24uY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkxhbmd1YWdlSWQgPSBsaW5lVG9rZW5zLmdldExhbmd1YWdlSWQodG9rZW5JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlSWQgIT09IHRva2VuTGFuZ3VhZ2VJZCkge1xuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZUlkID0gdG9rZW5MYW5ndWFnZUlkO1xuICAgICAgICAgICAgICAgICAgICBtb2RlQnJhY2tldHMgPSB0aGlzLmxhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UuZ2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uKGxhbmd1YWdlSWQpLmJyYWNrZXRzO1xuICAgICAgICAgICAgICAgICAgICBicmFja2V0Q29uZmlnID0gdGhpcy5sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlLmdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKS5icmFja2V0c05ldztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJldlNlYXJjaEluVG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7IHRva2VuSW5kZXggPCB0b2tlbkNvdW50OyB0b2tlbkluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkxhbmd1YWdlSWQgPSBsaW5lVG9rZW5zLmdldExhbmd1YWdlSWQodG9rZW5JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlSWQgIT09IHRva2VuTGFuZ3VhZ2VJZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYW5ndWFnZSBpZCBjaGFuZ2UhXG4gICAgICAgICAgICAgICAgICAgIGlmIChicmFja2V0Q29uZmlnICYmIG1vZGVCcmFja2V0cyAmJiBwcmV2U2VhcmNoSW5Ub2tlbiAmJiBzZWFyY2hTdGFydE9mZnNldCAhPT0gc2VhcmNoRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gQnJhY2tldHNVdGlscy5maW5kTmV4dEJyYWNrZXRJblJhbmdlKG1vZGVCcmFja2V0cy5mb3J3YXJkUmVnZXgsIGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvRm91bmRCcmFja2V0KGJyYWNrZXRDb25maWcsIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlNlYXJjaEluVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZUlkID0gdG9rZW5MYW5ndWFnZUlkO1xuICAgICAgICAgICAgICAgICAgICBtb2RlQnJhY2tldHMgPSB0aGlzLmxhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UuZ2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uKGxhbmd1YWdlSWQpLmJyYWNrZXRzO1xuICAgICAgICAgICAgICAgICAgICBicmFja2V0Q29uZmlnID0gdGhpcy5sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlLmdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKS5icmFja2V0c05ldztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoSW5Ub2tlbiA9ICghIW1vZGVCcmFja2V0cyAmJiAhaWdub3JlQnJhY2tldHNJblRva2VuKGxpbmVUb2tlbnMuZ2V0U3RhbmRhcmRUb2tlblR5cGUodG9rZW5JbmRleCkpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoSW5Ub2tlbikge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHRva2VuIHNob3VsZCBiZSBzZWFyY2hlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlNlYXJjaEluVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyB0b2tlbiBzaG91bGQgYmUgc2VhcmNoZWQsIHNpbXBseSBleHRlbmQgc2VhcmNoRW5kT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hFbmRPZmZzZXQgPSBsaW5lVG9rZW5zLmdldEVuZE9mZnNldCh0b2tlbkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyB0b2tlbiBzaG91bGQgbm90IGJlIHNlYXJjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hTdGFydE9mZnNldCA9IGxpbmVUb2tlbnMuZ2V0U3RhcnRPZmZzZXQodG9rZW5JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hFbmRPZmZzZXQgPSBsaW5lVG9rZW5zLmdldEVuZE9mZnNldCh0b2tlbkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB0b2tlbiBzaG91bGQgbm90IGJlIHNlYXJjaGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChicmFja2V0Q29uZmlnICYmIG1vZGVCcmFja2V0cyAmJiBwcmV2U2VhcmNoSW5Ub2tlbiAmJiBzZWFyY2hTdGFydE9mZnNldCAhPT0gc2VhcmNoRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gQnJhY2tldHNVdGlscy5maW5kTmV4dEJyYWNrZXRJblJhbmdlKG1vZGVCcmFja2V0cy5mb3J3YXJkUmVnZXgsIGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvRm91bmRCcmFja2V0KGJyYWNrZXRDb25maWcsIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZTZWFyY2hJblRva2VuID0gc2VhcmNoSW5Ub2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChicmFja2V0Q29uZmlnICYmIG1vZGVCcmFja2V0cyAmJiBwcmV2U2VhcmNoSW5Ub2tlbiAmJiBzZWFyY2hTdGFydE9mZnNldCAhPT0gc2VhcmNoRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IEJyYWNrZXRzVXRpbHMuZmluZE5leHRCcmFja2V0SW5SYW5nZShtb2RlQnJhY2tldHMuZm9yd2FyZFJlZ2V4LCBsaW5lTnVtYmVyLCBsaW5lVGV4dCwgc2VhcmNoU3RhcnRPZmZzZXQsIHNlYXJjaEVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvRm91bmRCcmFja2V0KGJyYWNrZXRDb25maWcsIHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZmluZEVuY2xvc2luZ0JyYWNrZXRzKF9wb3NpdGlvbiwgbWF4RHVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnRleHRNb2RlbC52YWxpZGF0ZVBvc2l0aW9uKF9wb3NpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmNhbkJ1aWxkQVNUKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IFJhbmdlLmZyb21Qb3NpdGlvbnMocG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3QgYnJhY2tldFBhaXIgPSB0aGlzLmdldEJyYWNrZXRQYWlyc0luUmFuZ2UoUmFuZ2UuZnJvbVBvc2l0aW9ucyhwb3NpdGlvbiwgcG9zaXRpb24pKS5maW5kTGFzdCgoaXRlbSkgPT4gaXRlbS5jbG9zaW5nQnJhY2tldFJhbmdlICE9PSB1bmRlZmluZWQgJiYgaXRlbS5yYW5nZS5zdHJpY3RDb250YWluc1JhbmdlKHJhbmdlKSk7XG4gICAgICAgICAgICBpZiAoYnJhY2tldFBhaXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2JyYWNrZXRQYWlyLm9wZW5pbmdCcmFja2V0UmFuZ2UsIGJyYWNrZXRQYWlyLmNsb3NpbmdCcmFja2V0UmFuZ2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGludWVTZWFyY2hQcmVkaWNhdGUgPSBjcmVhdGVUaW1lQmFzZWRDb250aW51ZUJyYWNrZXRTZWFyY2hQcmVkaWNhdGUobWF4RHVyYXRpb24pO1xuICAgICAgICBjb25zdCBsaW5lQ291bnQgPSB0aGlzLnRleHRNb2RlbC5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgY29uc3Qgc2F2ZWRDb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBjb3VudHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzZXRDb3VudHMgPSAobGFuZ3VhZ2VJZCwgbW9kZUJyYWNrZXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNhdmVkQ291bnRzLmhhcyhsYW5ndWFnZUlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb2RlQnJhY2tldHMgPyBtb2RlQnJhY2tldHMuYnJhY2tldHMubGVuZ3RoIDogMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNhdmVkQ291bnRzLnNldChsYW5ndWFnZUlkLCB0bXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRzID0gc2F2ZWRDb3VudHMuZ2V0KGxhbmd1YWdlSWQpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgdG90YWxDYWxsQ291bnQgPSAwO1xuICAgICAgICBjb25zdCBzZWFyY2hJblJhbmdlID0gKG1vZGVCcmFja2V0cywgbGluZU51bWJlciwgbGluZVRleHQsIHNlYXJjaFN0YXJ0T2Zmc2V0LCBzZWFyY2hFbmRPZmZzZXQpID0+IHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlU2VhcmNoUHJlZGljYXRlICYmICgrK3RvdGFsQ2FsbENvdW50KSAlIDEwMCA9PT0gMCAmJiAhY29udGludWVTZWFyY2hQcmVkaWNhdGUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnJhY2tldFNlYXJjaENhbmNlbGVkLklOU1RBTkNFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByID0gQnJhY2tldHNVdGlscy5maW5kTmV4dEJyYWNrZXRJblJhbmdlKG1vZGVCcmFja2V0cy5mb3J3YXJkUmVnZXgsIGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhpdFRleHQgPSBsaW5lVGV4dC5zdWJzdHJpbmcoci5zdGFydENvbHVtbiAtIDEsIHIuZW5kQ29sdW1uIC0gMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBicmFja2V0ID0gbW9kZUJyYWNrZXRzLnRleHRJc0JyYWNrZXRbaGl0VGV4dF07XG4gICAgICAgICAgICAgICAgaWYgKGJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyYWNrZXQuaXNPcGVuKGhpdFRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudHNbYnJhY2tldC5pbmRleF0rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChicmFja2V0LmlzQ2xvc2UoaGl0VGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50c1ticmFja2V0LmluZGV4XS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudHNbYnJhY2tldC5pbmRleF0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWF0Y2hGb3VuZEJyYWNrZXQociwgYnJhY2tldCwgZmFsc2UsIGNvbnRpbnVlU2VhcmNoUHJlZGljYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWFyY2hTdGFydE9mZnNldCA9IHIuZW5kQ29sdW1uIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgbGFuZ3VhZ2VJZCA9IG51bGw7XG4gICAgICAgIGxldCBtb2RlQnJhY2tldHMgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gcG9zaXRpb24ubGluZU51bWJlcjsgbGluZU51bWJlciA8PSBsaW5lQ291bnQ7IGxpbmVOdW1iZXIrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZVRva2VucyA9IHRoaXMudGV4dE1vZGVsLnRva2VuaXphdGlvbi5nZXRMaW5lVG9rZW5zKGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5Db3VudCA9IGxpbmVUb2tlbnMuZ2V0Q291bnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVUZXh0ID0gdGhpcy50ZXh0TW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcik7XG4gICAgICAgICAgICBsZXQgdG9rZW5JbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgc2VhcmNoU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IHNlYXJjaEVuZE9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAobGluZU51bWJlciA9PT0gcG9zaXRpb24ubGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHRva2VuSW5kZXggPSBsaW5lVG9rZW5zLmZpbmRUb2tlbkluZGV4QXRPZmZzZXQocG9zaXRpb24uY29sdW1uIC0gMSk7XG4gICAgICAgICAgICAgICAgc2VhcmNoU3RhcnRPZmZzZXQgPSBwb3NpdGlvbi5jb2x1bW4gLSAxO1xuICAgICAgICAgICAgICAgIHNlYXJjaEVuZE9mZnNldCA9IHBvc2l0aW9uLmNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5MYW5ndWFnZUlkID0gbGluZVRva2Vucy5nZXRMYW5ndWFnZUlkKHRva2VuSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZUlkICE9PSB0b2tlbkxhbmd1YWdlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VJZCA9IHRva2VuTGFuZ3VhZ2VJZDtcbiAgICAgICAgICAgICAgICAgICAgbW9kZUJyYWNrZXRzID0gdGhpcy5sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlLmdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKS5icmFja2V0cztcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRDb3VudHMobGFuZ3VhZ2VJZCwgbW9kZUJyYWNrZXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJldlNlYXJjaEluVG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7IHRva2VuSW5kZXggPCB0b2tlbkNvdW50OyB0b2tlbkluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkxhbmd1YWdlSWQgPSBsaW5lVG9rZW5zLmdldExhbmd1YWdlSWQodG9rZW5JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlSWQgIT09IHRva2VuTGFuZ3VhZ2VJZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYW5ndWFnZSBpZCBjaGFuZ2UhXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlQnJhY2tldHMgJiYgcHJldlNlYXJjaEluVG9rZW4gJiYgc2VhcmNoU3RhcnRPZmZzZXQgIT09IHNlYXJjaEVuZE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHNlYXJjaEluUmFuZ2UobW9kZUJyYWNrZXRzLCBsaW5lTnVtYmVyLCBsaW5lVGV4dCwgc2VhcmNoU3RhcnRPZmZzZXQsIHNlYXJjaEVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpcEJyYWNrZXRTZWFyY2hDYW5jZWxlZChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTZWFyY2hJblRva2VuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VJZCA9IHRva2VuTGFuZ3VhZ2VJZDtcbiAgICAgICAgICAgICAgICAgICAgbW9kZUJyYWNrZXRzID0gdGhpcy5sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlLmdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKS5icmFja2V0cztcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRDb3VudHMobGFuZ3VhZ2VJZCwgbW9kZUJyYWNrZXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoSW5Ub2tlbiA9ICghIW1vZGVCcmFja2V0cyAmJiAhaWdub3JlQnJhY2tldHNJblRva2VuKGxpbmVUb2tlbnMuZ2V0U3RhbmRhcmRUb2tlblR5cGUodG9rZW5JbmRleCkpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoSW5Ub2tlbikge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHRva2VuIHNob3VsZCBiZSBzZWFyY2hlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlNlYXJjaEluVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyB0b2tlbiBzaG91bGQgYmUgc2VhcmNoZWQsIHNpbXBseSBleHRlbmQgc2VhcmNoRW5kT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hFbmRPZmZzZXQgPSBsaW5lVG9rZW5zLmdldEVuZE9mZnNldCh0b2tlbkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyB0b2tlbiBzaG91bGQgbm90IGJlIHNlYXJjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hTdGFydE9mZnNldCA9IGxpbmVUb2tlbnMuZ2V0U3RhcnRPZmZzZXQodG9rZW5JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hFbmRPZmZzZXQgPSBsaW5lVG9rZW5zLmdldEVuZE9mZnNldCh0b2tlbkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB0b2tlbiBzaG91bGQgbm90IGJlIHNlYXJjaGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlQnJhY2tldHMgJiYgcHJldlNlYXJjaEluVG9rZW4gJiYgc2VhcmNoU3RhcnRPZmZzZXQgIT09IHNlYXJjaEVuZE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHNlYXJjaEluUmFuZ2UobW9kZUJyYWNrZXRzLCBsaW5lTnVtYmVyLCBsaW5lVGV4dCwgc2VhcmNoU3RhcnRPZmZzZXQsIHNlYXJjaEVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpcEJyYWNrZXRTZWFyY2hDYW5jZWxlZChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2U2VhcmNoSW5Ub2tlbiA9IHNlYXJjaEluVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kZUJyYWNrZXRzICYmIHByZXZTZWFyY2hJblRva2VuICYmIHNlYXJjaFN0YXJ0T2Zmc2V0ICE9PSBzZWFyY2hFbmRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gc2VhcmNoSW5SYW5nZShtb2RlQnJhY2tldHMsIGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBzZWFyY2hTdGFydE9mZnNldCwgc2VhcmNoRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaXBCcmFja2V0U2VhcmNoQ2FuY2VsZWQocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfdG9Gb3VuZEJyYWNrZXQoYnJhY2tldENvbmZpZywgcikge1xuICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy50ZXh0TW9kZWwuZ2V0VmFsdWVJblJhbmdlKHIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBicmFja2V0SW5mbyA9IGJyYWNrZXRDb25maWcuZ2V0QnJhY2tldEluZm8odGV4dCk7XG4gICAgICAgIGlmICghYnJhY2tldEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZTogcixcbiAgICAgICAgICAgIGJyYWNrZXRJbmZvXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRGlzcG9zYWJsZVJlZihvYmplY3QsIGRpc3Bvc2FibGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvYmplY3QsXG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IGRpc3Bvc2FibGU/LmRpc3Bvc2UoKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVGltZUJhc2VkQ29udGludWVCcmFja2V0U2VhcmNoUHJlZGljYXRlKG1heER1cmF0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBtYXhEdXJhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDw9IG1heER1cmF0aW9uKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBCcmFja2V0U2VhcmNoQ2FuY2VsZWQge1xuICAgIHN0YXRpYyB7IHRoaXMuSU5TVEFOQ0UgPSBuZXcgQnJhY2tldFNlYXJjaENhbmNlbGVkKCk7IH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fc2VhcmNoQ2FuY2VsZWRCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpcEJyYWNrZXRTZWFyY2hDYW5jZWxlZChyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgQnJhY2tldFNlYXJjaENhbmNlbGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBCdWdJbmRpY2F0aW5nRXJyb3IgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgQ3Vyc29yQ29sdW1ucyB9IGZyb20gJy4uLy4uLy4uL2NvcmUvY3Vyc29yQ29sdW1ucy5qcyc7XG5pbXBvcnQgeyBsZW5ndGhBZGQsIGxlbmd0aEdldExpbmVDb3VudCwgbGVuZ3RoVG9PYmosIGxlbmd0aFplcm8gfSBmcm9tICcuL2xlbmd0aC5qcyc7XG5pbXBvcnQgeyBTbWFsbEltbXV0YWJsZVNldCB9IGZyb20gJy4vc21hbGxJbW11dGFibGVTZXQuanMnO1xuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBmb3IgYWxsIEFTVCBub2Rlcy5cbiovXG5jbGFzcyBCYXNlQXN0Tm9kZSB7XG4gICAgLyoqXG4gICAgICogVGhlIGxlbmd0aCBvZiB0aGUgZW50aXJlIG5vZGUsIHdoaWNoIHNob3VsZCBlcXVhbCB0aGUgc3VtIG9mIGxlbmd0aHMgb2YgYWxsIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBicmFja2V0IHBhaXIgaW5jbHVkaW5nIGl0cyBjaGlsZCAoZS5nLiBgeyAuLi4gfWApLlxuICogTWlnaHQgYmUgdW5jbG9zZWQuXG4gKiBJbW11dGFibGUsIGlmIGFsbCBjaGlsZHJlbiBhcmUgaW1tdXRhYmxlLlxuKi9cbmV4cG9ydCBjbGFzcyBQYWlyQXN0Tm9kZSBleHRlbmRzIEJhc2VBc3ROb2RlIHtcbiAgICBzdGF0aWMgY3JlYXRlKG9wZW5pbmdCcmFja2V0LCBjaGlsZCwgY2xvc2luZ0JyYWNrZXQpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IG9wZW5pbmdCcmFja2V0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBsZW5ndGhBZGQobGVuZ3RoLCBjaGlsZC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9zaW5nQnJhY2tldCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoQWRkKGxlbmd0aCwgY2xvc2luZ0JyYWNrZXQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhaXJBc3ROb2RlKGxlbmd0aCwgb3BlbmluZ0JyYWNrZXQsIGNoaWxkLCBjbG9zaW5nQnJhY2tldCwgY2hpbGQgPyBjaGlsZC5taXNzaW5nT3BlbmluZ0JyYWNrZXRJZHMgOiBTbWFsbEltbXV0YWJsZVNldC5nZXRFbXB0eSgpKTtcbiAgICB9XG4gICAgZ2V0IGtpbmQoKSB7XG4gICAgICAgIHJldHVybiAyIC8qIEFzdE5vZGVLaW5kLlBhaXIgKi87XG4gICAgfVxuICAgIGdldCBsaXN0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgZ2V0Q2hpbGQoaWR4KSB7XG4gICAgICAgIHN3aXRjaCAoaWR4KSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB0aGlzLm9wZW5pbmdCcmFja2V0O1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gdGhpcy5jaGlsZDtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIHRoaXMuY2xvc2luZ0JyYWNrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoaWxkIGluZGV4Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF2b2lkIHVzaW5nIHRoaXMgcHJvcGVydHksIGl0IGFsbG9jYXRlcyBhbiBhcnJheSFcbiAgICAqL1xuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMub3BlbmluZ0JyYWNrZXQpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xvc2luZ0JyYWNrZXQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2xvc2luZ0JyYWNrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgb3BlbmluZ0JyYWNrZXQsIGNoaWxkLCBjbG9zaW5nQnJhY2tldCwgbWlzc2luZ09wZW5pbmdCcmFja2V0SWRzKSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICAgIHRoaXMub3BlbmluZ0JyYWNrZXQgPSBvcGVuaW5nQnJhY2tldDtcbiAgICAgICAgdGhpcy5jaGlsZCA9IGNoaWxkO1xuICAgICAgICB0aGlzLmNsb3NpbmdCcmFja2V0ID0gY2xvc2luZ0JyYWNrZXQ7XG4gICAgICAgIHRoaXMubWlzc2luZ09wZW5pbmdCcmFja2V0SWRzID0gbWlzc2luZ09wZW5pbmdCcmFja2V0SWRzO1xuICAgIH1cbiAgICBjYW5CZVJldXNlZChvcGVuQnJhY2tldElkcykge1xuICAgICAgICBpZiAodGhpcy5jbG9zaW5nQnJhY2tldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVW5jbG9zZWQgcGFpciBhc3Qgbm9kZXMgb25seVxuICAgICAgICAgICAgLy8gZW5kIGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAvLyBvciB3aGVuIGEgcGFyZW50IG5vZGUgaXMgY2xvc2VkLlxuICAgICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBpbXByb3ZlZDpcbiAgICAgICAgICAgIC8vIE9ubHkgcmV0dXJuIGZhbHNlIGlmIHNvbWUgbmV4dCB0b2tlbiBpcyBuZWl0aGVyIFwidW5kZWZpbmVkXCIgbm9yIGEgYnJhY2tldCB0aGF0IGNsb3NlcyBhIHBhcmVudC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BlbkJyYWNrZXRJZHMuaW50ZXJzZWN0cyh0aGlzLm1pc3NpbmdPcGVuaW5nQnJhY2tldElkcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZGVlcENsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaXJBc3ROb2RlKHRoaXMubGVuZ3RoLCB0aGlzLm9wZW5pbmdCcmFja2V0LmRlZXBDbG9uZSgpLCB0aGlzLmNoaWxkICYmIHRoaXMuY2hpbGQuZGVlcENsb25lKCksIHRoaXMuY2xvc2luZ0JyYWNrZXQgJiYgdGhpcy5jbG9zaW5nQnJhY2tldC5kZWVwQ2xvbmUoKSwgdGhpcy5taXNzaW5nT3BlbmluZ0JyYWNrZXRJZHMpO1xuICAgIH1cbiAgICBjb21wdXRlTWluSW5kZW50YXRpb24ob2Zmc2V0LCB0ZXh0TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQgPyB0aGlzLmNoaWxkLmNvbXB1dGVNaW5JbmRlbnRhdGlvbihsZW5ndGhBZGQob2Zmc2V0LCB0aGlzLm9wZW5pbmdCcmFja2V0Lmxlbmd0aCksIHRleHRNb2RlbCkgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTGlzdEFzdE5vZGUgZXh0ZW5kcyBCYXNlQXN0Tm9kZSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyBtb3JlIG1lbW9yeS1lZmZpY2llbnQgbGlzdCBub2RlcyB0aGF0IGNhbiBvbmx5IHN0b3JlIDIgb3IgMyBjaGlsZHJlbi5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUyMyhpdGVtMSwgaXRlbTIsIGl0ZW0zLCBpbW11dGFibGUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gaXRlbTEubGVuZ3RoO1xuICAgICAgICBsZXQgbWlzc2luZ0JyYWNrZXRJZHMgPSBpdGVtMS5taXNzaW5nT3BlbmluZ0JyYWNrZXRJZHM7XG4gICAgICAgIGlmIChpdGVtMS5saXN0SGVpZ2h0ICE9PSBpdGVtMi5saXN0SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCBoZWlnaHRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoQWRkKGxlbmd0aCwgaXRlbTIubGVuZ3RoKTtcbiAgICAgICAgbWlzc2luZ0JyYWNrZXRJZHMgPSBtaXNzaW5nQnJhY2tldElkcy5tZXJnZShpdGVtMi5taXNzaW5nT3BlbmluZ0JyYWNrZXRJZHMpO1xuICAgICAgICBpZiAoaXRlbTMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtMS5saXN0SGVpZ2h0ICE9PSBpdGVtMy5saXN0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QgaGVpZ2h0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoQWRkKGxlbmd0aCwgaXRlbTMubGVuZ3RoKTtcbiAgICAgICAgICAgIG1pc3NpbmdCcmFja2V0SWRzID0gbWlzc2luZ0JyYWNrZXRJZHMubWVyZ2UoaXRlbTMubWlzc2luZ09wZW5pbmdCcmFja2V0SWRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1tdXRhYmxlXG4gICAgICAgICAgICA/IG5ldyBJbW11dGFibGUyM0xpc3RBc3ROb2RlKGxlbmd0aCwgaXRlbTEubGlzdEhlaWdodCArIDEsIGl0ZW0xLCBpdGVtMiwgaXRlbTMsIG1pc3NpbmdCcmFja2V0SWRzKVxuICAgICAgICAgICAgOiBuZXcgVHdvVGhyZWVMaXN0QXN0Tm9kZShsZW5ndGgsIGl0ZW0xLmxpc3RIZWlnaHQgKyAxLCBpdGVtMSwgaXRlbTIsIGl0ZW0zLCBtaXNzaW5nQnJhY2tldElkcyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVBcnJheUxpc3RBc3ROb2RlKGxlbmd0aFplcm8sIDAsIFtdLCBTbWFsbEltbXV0YWJsZVNldC5nZXRFbXB0eSgpKTtcbiAgICB9XG4gICAgZ2V0IGtpbmQoKSB7XG4gICAgICAgIHJldHVybiA0IC8qIEFzdE5vZGVLaW5kLkxpc3QgKi87XG4gICAgfVxuICAgIGdldCBtaXNzaW5nT3BlbmluZ0JyYWNrZXRJZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taXNzaW5nT3BlbmluZ0JyYWNrZXRJZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBMaXN0QXN0Tm9kZS5jcmVhdGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGxpc3RIZWlnaHQsIF9taXNzaW5nT3BlbmluZ0JyYWNrZXRJZHMpIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgICAgdGhpcy5saXN0SGVpZ2h0ID0gbGlzdEhlaWdodDtcbiAgICAgICAgdGhpcy5fbWlzc2luZ09wZW5pbmdCcmFja2V0SWRzID0gX21pc3NpbmdPcGVuaW5nQnJhY2tldElkcztcbiAgICAgICAgdGhpcy5jYWNoZWRNaW5JbmRlbnRhdGlvbiA9IC0xO1xuICAgIH1cbiAgICB0aHJvd0lmSW1tdXRhYmxlKCkge1xuICAgICAgICAvLyBOT09QXG4gICAgfVxuICAgIG1ha2VMYXN0RWxlbWVudE11dGFibGUoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkltbXV0YWJsZSgpO1xuICAgICAgICBjb25zdCBjaGlsZENvdW50ID0gdGhpcy5jaGlsZHJlbkxlbmd0aDtcbiAgICAgICAgaWYgKGNoaWxkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5nZXRDaGlsZChjaGlsZENvdW50IC0gMSk7XG4gICAgICAgIGNvbnN0IG11dGFibGUgPSBsYXN0Q2hpbGQua2luZCA9PT0gNCAvKiBBc3ROb2RlS2luZC5MaXN0ICovID8gbGFzdENoaWxkLnRvTXV0YWJsZSgpIDogbGFzdENoaWxkO1xuICAgICAgICBpZiAobGFzdENoaWxkICE9PSBtdXRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnNldENoaWxkKGNoaWxkQ291bnQgLSAxLCBtdXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXV0YWJsZTtcbiAgICB9XG4gICAgbWFrZUZpcnN0RWxlbWVudE11dGFibGUoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkltbXV0YWJsZSgpO1xuICAgICAgICBjb25zdCBjaGlsZENvdW50ID0gdGhpcy5jaGlsZHJlbkxlbmd0aDtcbiAgICAgICAgaWYgKGNoaWxkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IHRoaXMuZ2V0Q2hpbGQoMCk7XG4gICAgICAgIGNvbnN0IG11dGFibGUgPSBmaXJzdENoaWxkLmtpbmQgPT09IDQgLyogQXN0Tm9kZUtpbmQuTGlzdCAqLyA/IGZpcnN0Q2hpbGQudG9NdXRhYmxlKCkgOiBmaXJzdENoaWxkO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCAhPT0gbXV0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDaGlsZCgwLCBtdXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXV0YWJsZTtcbiAgICB9XG4gICAgY2FuQmVSZXVzZWQob3BlbkJyYWNrZXRJZHMpIHtcbiAgICAgICAgaWYgKG9wZW5CcmFja2V0SWRzLmludGVyc2VjdHModGhpcy5taXNzaW5nT3BlbmluZ0JyYWNrZXRJZHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5MZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIERvbid0IHJldXNlIGVtcHR5IGxpc3RzLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAobGFzdENoaWxkLmtpbmQgPT09IDQgLyogQXN0Tm9kZUtpbmQuTGlzdCAqLykge1xuICAgICAgICAgICAgY29uc3QgbGFzdExlbmd0aCA9IGxhc3RDaGlsZC5jaGlsZHJlbkxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRW1wdHkgbGlzdHMgc2hvdWxkIG5ldmVyIGJlIGNvbnRhaW5lZCBpbiBvdGhlciBsaXN0cy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSBsYXN0Q2hpbGQuZ2V0Q2hpbGQobGFzdExlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0Q2hpbGQuY2FuQmVSZXVzZWQob3BlbkJyYWNrZXRJZHMpO1xuICAgIH1cbiAgICBoYW5kbGVDaGlsZHJlbkNoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkltbXV0YWJsZSgpO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuY2hpbGRyZW5MZW5ndGg7XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmdldENoaWxkKDApLmxlbmd0aDtcbiAgICAgICAgbGV0IHVub3BlbmVkQnJhY2tldHMgPSB0aGlzLmdldENoaWxkKDApLm1pc3NpbmdPcGVuaW5nQnJhY2tldElkcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGQoaSk7XG4gICAgICAgICAgICBsZW5ndGggPSBsZW5ndGhBZGQobGVuZ3RoLCBjaGlsZC5sZW5ndGgpO1xuICAgICAgICAgICAgdW5vcGVuZWRCcmFja2V0cyA9IHVub3BlbmVkQnJhY2tldHMubWVyZ2UoY2hpbGQubWlzc2luZ09wZW5pbmdCcmFja2V0SWRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuX21pc3NpbmdPcGVuaW5nQnJhY2tldElkcyA9IHVub3BlbmVkQnJhY2tldHM7XG4gICAgICAgIHRoaXMuY2FjaGVkTWluSW5kZW50YXRpb24gPSAtMTtcbiAgICB9XG4gICAgY29tcHV0ZU1pbkluZGVudGF0aW9uKG9mZnNldCwgdGV4dE1vZGVsKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZE1pbkluZGVudGF0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkTWluSW5kZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1pbkluZGVudGF0aW9uID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIGxldCBjaGlsZE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5nZXRDaGlsZChpKTtcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIG1pbkluZGVudGF0aW9uID0gTWF0aC5taW4obWluSW5kZW50YXRpb24sIGNoaWxkLmNvbXB1dGVNaW5JbmRlbnRhdGlvbihjaGlsZE9mZnNldCwgdGV4dE1vZGVsKSk7XG4gICAgICAgICAgICAgICAgY2hpbGRPZmZzZXQgPSBsZW5ndGhBZGQoY2hpbGRPZmZzZXQsIGNoaWxkLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZWRNaW5JbmRlbnRhdGlvbiA9IG1pbkluZGVudGF0aW9uO1xuICAgICAgICByZXR1cm4gbWluSW5kZW50YXRpb247XG4gICAgfVxufVxuY2xhc3MgVHdvVGhyZWVMaXN0QXN0Tm9kZSBleHRlbmRzIExpc3RBc3ROb2RlIHtcbiAgICBnZXQgY2hpbGRyZW5MZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtMyAhPT0gbnVsbCA/IDMgOiAyO1xuICAgIH1cbiAgICBnZXRDaGlsZChpZHgpIHtcbiAgICAgICAgc3dpdGNoIChpZHgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHRoaXMuX2l0ZW0xO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gdGhpcy5faXRlbTI7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiB0aGlzLl9pdGVtMztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hpbGQgaW5kZXgnKTtcbiAgICB9XG4gICAgc2V0Q2hpbGQoaWR4LCBub2RlKSB7XG4gICAgICAgIHN3aXRjaCAoaWR4KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbTEgPSBub2RlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtMiA9IG5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW0zID0gbm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoaWxkIGluZGV4Jyk7XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW0zID8gW3RoaXMuX2l0ZW0xLCB0aGlzLl9pdGVtMiwgdGhpcy5faXRlbTNdIDogW3RoaXMuX2l0ZW0xLCB0aGlzLl9pdGVtMl07XG4gICAgfVxuICAgIGdldCBpdGVtMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW0xO1xuICAgIH1cbiAgICBnZXQgaXRlbTIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtMjtcbiAgICB9XG4gICAgZ2V0IGl0ZW0zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbTM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgbGlzdEhlaWdodCwgX2l0ZW0xLCBfaXRlbTIsIF9pdGVtMywgbWlzc2luZ09wZW5pbmdCcmFja2V0SWRzKSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgbGlzdEhlaWdodCwgbWlzc2luZ09wZW5pbmdCcmFja2V0SWRzKTtcbiAgICAgICAgdGhpcy5faXRlbTEgPSBfaXRlbTE7XG4gICAgICAgIHRoaXMuX2l0ZW0yID0gX2l0ZW0yO1xuICAgICAgICB0aGlzLl9pdGVtMyA9IF9pdGVtMztcbiAgICB9XG4gICAgZGVlcENsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFR3b1RocmVlTGlzdEFzdE5vZGUodGhpcy5sZW5ndGgsIHRoaXMubGlzdEhlaWdodCwgdGhpcy5faXRlbTEuZGVlcENsb25lKCksIHRoaXMuX2l0ZW0yLmRlZXBDbG9uZSgpLCB0aGlzLl9pdGVtMyA/IHRoaXMuX2l0ZW0zLmRlZXBDbG9uZSgpIDogbnVsbCwgdGhpcy5taXNzaW5nT3BlbmluZ0JyYWNrZXRJZHMpO1xuICAgIH1cbiAgICBhcHBlbmRDaGlsZE9mU2FtZUhlaWdodChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwZW5kIHRvIGEgZnVsbCAoMiwzKSB0cmVlIG5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93SWZJbW11dGFibGUoKTtcbiAgICAgICAgdGhpcy5faXRlbTMgPSBub2RlO1xuICAgICAgICB0aGlzLmhhbmRsZUNoaWxkcmVuQ2hhbmdlZCgpO1xuICAgIH1cbiAgICB1bmFwcGVuZENoaWxkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2l0ZW0zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZW1vdmUgZnJvbSBhIG5vbi1mdWxsICgyLDMpIHRyZWUgbm9kZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dJZkltbXV0YWJsZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9pdGVtMztcbiAgICAgICAgdGhpcy5faXRlbTMgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZUNoaWxkcmVuQ2hhbmdlZCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwcmVwZW5kQ2hpbGRPZlNhbWVIZWlnaHQobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5faXRlbTMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHByZXBlbmQgdG8gYSBmdWxsICgyLDMpIHRyZWUgbm9kZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dJZkltbXV0YWJsZSgpO1xuICAgICAgICB0aGlzLl9pdGVtMyA9IHRoaXMuX2l0ZW0yO1xuICAgICAgICB0aGlzLl9pdGVtMiA9IHRoaXMuX2l0ZW0xO1xuICAgICAgICB0aGlzLl9pdGVtMSA9IG5vZGU7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRyZW5DaGFuZ2VkKCk7XG4gICAgfVxuICAgIHVucHJlcGVuZENoaWxkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2l0ZW0zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZW1vdmUgZnJvbSBhIG5vbi1mdWxsICgyLDMpIHRyZWUgbm9kZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dJZkltbXV0YWJsZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9pdGVtMTtcbiAgICAgICAgdGhpcy5faXRlbTEgPSB0aGlzLl9pdGVtMjtcbiAgICAgICAgdGhpcy5faXRlbTIgPSB0aGlzLl9pdGVtMztcbiAgICAgICAgdGhpcy5faXRlbTMgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZUNoaWxkcmVuQ2hhbmdlZCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b011dGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8qKlxuICogSW1tdXRhYmxlLCBpZiBhbGwgY2hpbGRyZW4gYXJlIGltbXV0YWJsZS5cbiovXG5jbGFzcyBJbW11dGFibGUyM0xpc3RBc3ROb2RlIGV4dGVuZHMgVHdvVGhyZWVMaXN0QXN0Tm9kZSB7XG4gICAgdG9NdXRhYmxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFR3b1RocmVlTGlzdEFzdE5vZGUodGhpcy5sZW5ndGgsIHRoaXMubGlzdEhlaWdodCwgdGhpcy5pdGVtMSwgdGhpcy5pdGVtMiwgdGhpcy5pdGVtMywgdGhpcy5taXNzaW5nT3BlbmluZ0JyYWNrZXRJZHMpO1xuICAgIH1cbiAgICB0aHJvd0lmSW1tdXRhYmxlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMgaW5zdGFuY2UgaXMgaW1tdXRhYmxlJyk7XG4gICAgfVxufVxuLyoqXG4gKiBGb3IgZGVidWdnaW5nLlxuKi9cbmNsYXNzIEFycmF5TGlzdEFzdE5vZGUgZXh0ZW5kcyBMaXN0QXN0Tm9kZSB7XG4gICAgZ2V0IGNoaWxkcmVuTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgIH1cbiAgICBnZXRDaGlsZChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2lkeF07XG4gICAgfVxuICAgIHNldENoaWxkKGlkeCwgY2hpbGQpIHtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW5baWR4XSA9IGNoaWxkO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBsaXN0SGVpZ2h0LCBfY2hpbGRyZW4sIG1pc3NpbmdPcGVuaW5nQnJhY2tldElkcykge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGxpc3RIZWlnaHQsIG1pc3NpbmdPcGVuaW5nQnJhY2tldElkcyk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gX2NoaWxkcmVuO1xuICAgIH1cbiAgICBkZWVwQ2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbmV3IEFycmF5KHRoaXMuX2NoaWxkcmVuLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldID0gdGhpcy5fY2hpbGRyZW5baV0uZGVlcENsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheUxpc3RBc3ROb2RlKHRoaXMubGVuZ3RoLCB0aGlzLmxpc3RIZWlnaHQsIGNoaWxkcmVuLCB0aGlzLm1pc3NpbmdPcGVuaW5nQnJhY2tldElkcyk7XG4gICAgfVxuICAgIGFwcGVuZENoaWxkT2ZTYW1lSGVpZ2h0KG5vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmSW1tdXRhYmxlKCk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRyZW5DaGFuZ2VkKCk7XG4gICAgfVxuICAgIHVuYXBwZW5kQ2hpbGQoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkltbXV0YWJsZSgpO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fY2hpbGRyZW4ucG9wKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRyZW5DaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBwcmVwZW5kQ2hpbGRPZlNhbWVIZWlnaHQobm9kZSkge1xuICAgICAgICB0aGlzLnRocm93SWZJbW11dGFibGUoKTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4udW5zaGlmdChub2RlKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGlsZHJlbkNoYW5nZWQoKTtcbiAgICB9XG4gICAgdW5wcmVwZW5kQ2hpbGQoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkltbXV0YWJsZSgpO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fY2hpbGRyZW4uc2hpZnQoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGlsZHJlbkNoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIHRvTXV0YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLyoqXG4gKiBJbW11dGFibGUsIGlmIGFsbCBjaGlsZHJlbiBhcmUgaW1tdXRhYmxlLlxuKi9cbmNsYXNzIEltbXV0YWJsZUFycmF5TGlzdEFzdE5vZGUgZXh0ZW5kcyBBcnJheUxpc3RBc3ROb2RlIHtcbiAgICB0b011dGFibGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlMaXN0QXN0Tm9kZSh0aGlzLmxlbmd0aCwgdGhpcy5saXN0SGVpZ2h0LCBbLi4udGhpcy5jaGlsZHJlbl0sIHRoaXMubWlzc2luZ09wZW5pbmdCcmFja2V0SWRzKTtcbiAgICB9XG4gICAgdGhyb3dJZkltbXV0YWJsZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzIGluc3RhbmNlIGlzIGltbXV0YWJsZScpO1xuICAgIH1cbn1cbmNvbnN0IGVtcHR5QXJyYXkgPSBbXTtcbmNsYXNzIEltbXV0YWJsZUxlYWZBc3ROb2RlIGV4dGVuZHMgQmFzZUFzdE5vZGUge1xuICAgIGdldCBsaXN0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZ2V0Q2hpbGQoaWR4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBlbXB0eUFycmF5O1xuICAgIH1cbiAgICBkZWVwQ2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUZXh0QXN0Tm9kZSBleHRlbmRzIEltbXV0YWJsZUxlYWZBc3ROb2RlIHtcbiAgICBnZXQga2luZCgpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogQXN0Tm9kZUtpbmQuVGV4dCAqLztcbiAgICB9XG4gICAgZ2V0IG1pc3NpbmdPcGVuaW5nQnJhY2tldElkcygpIHtcbiAgICAgICAgcmV0dXJuIFNtYWxsSW1tdXRhYmxlU2V0LmdldEVtcHR5KCk7XG4gICAgfVxuICAgIGNhbkJlUmV1c2VkKF9vcGVuZWRCcmFja2V0SWRzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb21wdXRlTWluSW5kZW50YXRpb24ob2Zmc2V0LCB0ZXh0TW9kZWwpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsZW5ndGhUb09iaihvZmZzZXQpO1xuICAgICAgICAvLyBUZXh0IGFzdCBub2RlcyBkb24ndCBoYXZlIHBhcnRpYWwgaW5kZW50YXRpb24gKGVuc3VyZWQgYnkgdGhlIHRva2VuaXplcikuXG4gICAgICAgIC8vIFRodXMsIGlmIHRoaXMgdGV4dCBub2RlIGRvZXMgbm90IHN0YXJ0IGF0IGNvbHVtbiAwLCB0aGUgZmlyc3QgbGluZSBjYW5ub3QgaGF2ZSBhbnkgaW5kZW50YXRpb24gYXQgYWxsLlxuICAgICAgICBjb25zdCBzdGFydExpbmVOdW1iZXIgPSAoc3RhcnQuY29sdW1uQ291bnQgPT09IDAgPyBzdGFydC5saW5lQ291bnQgOiBzdGFydC5saW5lQ291bnQgKyAxKSArIDE7XG4gICAgICAgIGNvbnN0IGVuZExpbmVOdW1iZXIgPSBsZW5ndGhHZXRMaW5lQ291bnQobGVuZ3RoQWRkKG9mZnNldCwgdGhpcy5sZW5ndGgpKSArIDE7XG4gICAgICAgIGxldCByZXN1bHQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgZm9yIChsZXQgbGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjsgbGluZU51bWJlciA8PSBlbmRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Tm9uV3NDb2x1bW4gPSB0ZXh0TW9kZWwuZ2V0TGluZUZpcnN0Tm9uV2hpdGVzcGFjZUNvbHVtbihsaW5lTnVtYmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gdGV4dE1vZGVsLmdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgaWYgKGZpcnN0Tm9uV3NDb2x1bW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVDb2x1bW4gPSBDdXJzb3JDb2x1bW5zLnZpc2libGVDb2x1bW5Gcm9tQ29sdW1uKGxpbmVDb250ZW50LCBmaXJzdE5vbldzQ29sdW1uLCB0ZXh0TW9kZWwuZ2V0T3B0aW9ucygpLnRhYlNpemUpO1xuICAgICAgICAgICAgcmVzdWx0ID0gTWF0aC5taW4ocmVzdWx0LCB2aXNpYmxlQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCcmFja2V0QXN0Tm9kZSBleHRlbmRzIEltbXV0YWJsZUxlYWZBc3ROb2RlIHtcbiAgICBzdGF0aWMgY3JlYXRlKGxlbmd0aCwgYnJhY2tldEluZm8sIGJyYWNrZXRJZHMpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBCcmFja2V0QXN0Tm9kZShsZW5ndGgsIGJyYWNrZXRJbmZvLCBicmFja2V0SWRzKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGdldCBraW5kKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBBc3ROb2RlS2luZC5CcmFja2V0ICovO1xuICAgIH1cbiAgICBnZXQgbWlzc2luZ09wZW5pbmdCcmFja2V0SWRzKCkge1xuICAgICAgICByZXR1cm4gU21hbGxJbW11dGFibGVTZXQuZ2V0RW1wdHkoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBicmFja2V0SW5mbywgXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBvZiBhIG9wZW5pbmcgYnJhY2tldCwgdGhpcyBpcyB0aGUgaWQgb2YgdGhlIG9wZW5pbmcgYnJhY2tldC5cbiAgICAgKiBJbiBjYXNlIG9mIGEgY2xvc2luZyBicmFja2V0LCB0aGlzIGNvbnRhaW5zIHRoZSBpZHMgb2YgYWxsIG9wZW5pbmcgYnJhY2tldHMgaXQgY2FuIGNsb3NlLlxuICAgICovXG4gICAgYnJhY2tldElkcykge1xuICAgICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgICB0aGlzLmJyYWNrZXRJbmZvID0gYnJhY2tldEluZm87XG4gICAgICAgIHRoaXMuYnJhY2tldElkcyA9IGJyYWNrZXRJZHM7XG4gICAgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icmFja2V0SW5mby5icmFja2V0VGV4dDtcbiAgICB9XG4gICAgZ2V0IGxhbmd1YWdlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyYWNrZXRJbmZvLmxhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGNhbkJlUmV1c2VkKF9vcGVuZWRCcmFja2V0SWRzKSB7XG4gICAgICAgIC8vIFRoZXNlIG5vZGVzIGNvdWxkIGJlIHJldXNlZCxcbiAgICAgICAgLy8gYnV0IG5vdCBpbiBhIGdlbmVyYWwgd2F5LlxuICAgICAgICAvLyBUaGVpciBwYXJlbnQgbWF5IGJlIHJldXNlZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb21wdXRlTWluSW5kZW50YXRpb24ob2Zmc2V0LCB0ZXh0TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQnJhY2tldEFzdE5vZGUgZXh0ZW5kcyBJbW11dGFibGVMZWFmQXN0Tm9kZSB7XG4gICAgZ2V0IGtpbmQoKSB7XG4gICAgICAgIHJldHVybiAzIC8qIEFzdE5vZGVLaW5kLlVuZXhwZWN0ZWRDbG9zaW5nQnJhY2tldCAqLztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY2xvc2luZ0JyYWNrZXRzLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgICAgdGhpcy5taXNzaW5nT3BlbmluZ0JyYWNrZXRJZHMgPSBjbG9zaW5nQnJhY2tldHM7XG4gICAgfVxuICAgIGNhbkJlUmV1c2VkKG9wZW5lZEJyYWNrZXRJZHMpIHtcbiAgICAgICAgcmV0dXJuICFvcGVuZWRCcmFja2V0SWRzLmludGVyc2VjdHModGhpcy5taXNzaW5nT3BlbmluZ0JyYWNrZXRJZHMpO1xuICAgIH1cbiAgICBjb21wdXRlTWluSW5kZW50YXRpb24ob2Zmc2V0LCB0ZXh0TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi8uLi8uLi9jb3JlL3JhbmdlLmpzJztcbmltcG9ydCB7IGxlbmd0aEFkZCwgbGVuZ3RoRGlmZk5vbk5lZ2F0aXZlLCBsZW5ndGhMZXNzVGhhbkVxdWFsLCBsZW5ndGhPZlN0cmluZywgbGVuZ3RoVG9PYmosIHBvc2l0aW9uVG9MZW5ndGgsIHRvTGVuZ3RoIH0gZnJvbSAnLi9sZW5ndGguanMnO1xuZXhwb3J0IGNsYXNzIFRleHRFZGl0SW5mbyB7XG4gICAgc3RhdGljIGZyb21Nb2RlbENvbnRlbnRDaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgLy8gTXVzdCBiZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICAgIGNvbnN0IGVkaXRzID0gY2hhbmdlcy5tYXAoYyA9PiB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IFJhbmdlLmxpZnQoYy5yYW5nZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRFZGl0SW5mbyhwb3NpdGlvblRvTGVuZ3RoKHJhbmdlLmdldFN0YXJ0UG9zaXRpb24oKSksIHBvc2l0aW9uVG9MZW5ndGgocmFuZ2UuZ2V0RW5kUG9zaXRpb24oKSksIGxlbmd0aE9mU3RyaW5nKGMudGV4dCkpO1xuICAgICAgICB9KS5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiBlZGl0cztcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgbmV3TGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgdGhpcy5lbmRPZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgIHRoaXMubmV3TGVuZ3RoID0gbmV3TGVuZ3RoO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHtsZW5ndGhUb09iaih0aGlzLnN0YXJ0T2Zmc2V0KX0uLi4ke2xlbmd0aFRvT2JqKHRoaXMuZW5kT2Zmc2V0KX0pIC0+ICR7bGVuZ3RoVG9PYmoodGhpcy5uZXdMZW5ndGgpfWA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJlZm9yZUVkaXRQb3NpdGlvbk1hcHBlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGVkaXRzIE11c3QgYmUgc29ydGVkIGJ5IG9mZnNldCBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlZGl0cykge1xuICAgICAgICB0aGlzLm5leHRFZGl0SWR4ID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YU9sZFRvTmV3TGluZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YU9sZFRvTmV3Q29sdW1uQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmRlbHRhTGluZUlkeEluT2xkID0gLTE7XG4gICAgICAgIHRoaXMuZWRpdHMgPSBlZGl0cy5tYXAoZWRpdCA9PiBUZXh0RWRpdEluZm9DYWNoZS5mcm9tKGVkaXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9mZnNldCBNdXN0IGJlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbGFzdCBvZmZzZXQgdGhpcyBtZXRob2QgaGFzIGJlZW4gY2FsbGVkIHdpdGguXG4gICAgKi9cbiAgICBnZXRPZmZzZXRCZWZvcmVDaGFuZ2Uob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuYWRqdXN0TmV4dEVkaXQob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlQ3VyVG9PbGQob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9mZnNldCBNdXN0IGJlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbGFzdCBvZmZzZXQgdGhpcyBtZXRob2QgaGFzIGJlZW4gY2FsbGVkIHdpdGguXG4gICAgICogUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIGVkaXQgYW55bW9yZS5cbiAgICAqL1xuICAgIGdldERpc3RhbmNlVG9OZXh0Q2hhbmdlKG9mZnNldCkge1xuICAgICAgICB0aGlzLmFkanVzdE5leHRFZGl0KG9mZnNldCk7XG4gICAgICAgIGNvbnN0IG5leHRFZGl0ID0gdGhpcy5lZGl0c1t0aGlzLm5leHRFZGl0SWR4XTtcbiAgICAgICAgY29uc3QgbmV4dENoYW5nZU9mZnNldCA9IG5leHRFZGl0ID8gdGhpcy50cmFuc2xhdGVPbGRUb0N1cihuZXh0RWRpdC5vZmZzZXRPYmopIDogbnVsbDtcbiAgICAgICAgaWYgKG5leHRDaGFuZ2VPZmZzZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGhEaWZmTm9uTmVnYXRpdmUob2Zmc2V0LCBuZXh0Q2hhbmdlT2Zmc2V0KTtcbiAgICB9XG4gICAgdHJhbnNsYXRlT2xkVG9DdXIob2xkT2Zmc2V0T2JqKSB7XG4gICAgICAgIGlmIChvbGRPZmZzZXRPYmoubGluZUNvdW50ID09PSB0aGlzLmRlbHRhTGluZUlkeEluT2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9MZW5ndGgob2xkT2Zmc2V0T2JqLmxpbmVDb3VudCArIHRoaXMuZGVsdGFPbGRUb05ld0xpbmVDb3VudCwgb2xkT2Zmc2V0T2JqLmNvbHVtbkNvdW50ICsgdGhpcy5kZWx0YU9sZFRvTmV3Q29sdW1uQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRvTGVuZ3RoKG9sZE9mZnNldE9iai5saW5lQ291bnQgKyB0aGlzLmRlbHRhT2xkVG9OZXdMaW5lQ291bnQsIG9sZE9mZnNldE9iai5jb2x1bW5Db3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNsYXRlQ3VyVG9PbGQobmV3T2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldE9iaiA9IGxlbmd0aFRvT2JqKG5ld09mZnNldCk7XG4gICAgICAgIGlmIChvZmZzZXRPYmoubGluZUNvdW50IC0gdGhpcy5kZWx0YU9sZFRvTmV3TGluZUNvdW50ID09PSB0aGlzLmRlbHRhTGluZUlkeEluT2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9MZW5ndGgob2Zmc2V0T2JqLmxpbmVDb3VudCAtIHRoaXMuZGVsdGFPbGRUb05ld0xpbmVDb3VudCwgb2Zmc2V0T2JqLmNvbHVtbkNvdW50IC0gdGhpcy5kZWx0YU9sZFRvTmV3Q29sdW1uQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRvTGVuZ3RoKG9mZnNldE9iai5saW5lQ291bnQgLSB0aGlzLmRlbHRhT2xkVG9OZXdMaW5lQ291bnQsIG9mZnNldE9iai5jb2x1bW5Db3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRqdXN0TmV4dEVkaXQob2Zmc2V0KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHRFZGl0SWR4IDwgdGhpcy5lZGl0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRFZGl0ID0gdGhpcy5lZGl0c1t0aGlzLm5leHRFZGl0SWR4XTtcbiAgICAgICAgICAgIC8vIEFmdGVyIGFwcGx5aW5nIHRoZSBlZGl0LCB3aGF0IGlzIGl0cyBlbmQgb2Zmc2V0IChjb25zaWRlcmluZyBhbGwgcHJldmlvdXMgZWRpdHMpP1xuICAgICAgICAgICAgY29uc3QgbmV4dEVkaXRFbmRPZmZzZXRJbkN1ciA9IHRoaXMudHJhbnNsYXRlT2xkVG9DdXIobmV4dEVkaXQuZW5kT2Zmc2V0QWZ0ZXJPYmopO1xuICAgICAgICAgICAgaWYgKGxlbmd0aExlc3NUaGFuRXF1YWwobmV4dEVkaXRFbmRPZmZzZXRJbkN1ciwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBhZnRlciB0aGUgZWRpdCwgc2tpcCBpdFxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEVkaXRJZHgrKztcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0RWRpdEVuZE9mZnNldEluQ3VyT2JqID0gbGVuZ3RoVG9PYmoobmV4dEVkaXRFbmRPZmZzZXRJbkN1cik7XG4gICAgICAgICAgICAgICAgLy8gQmVmb3JlIGFwcGx5aW5nIHRoZSBlZGl0LCB3aGF0IGlzIGl0cyBlbmQgb2Zmc2V0IChjb25zaWRlcmluZyBhbGwgcHJldmlvdXMgZWRpdHMpP1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRFZGl0RW5kT2Zmc2V0QmVmb3JlSW5DdXJPYmogPSBsZW5ndGhUb09iaih0aGlzLnRyYW5zbGF0ZU9sZFRvQ3VyKG5leHRFZGl0LmVuZE9mZnNldEJlZm9yZU9iaikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVEZWx0YSA9IG5leHRFZGl0RW5kT2Zmc2V0SW5DdXJPYmoubGluZUNvdW50IC0gbmV4dEVkaXRFbmRPZmZzZXRCZWZvcmVJbkN1ck9iai5saW5lQ291bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWx0YU9sZFRvTmV3TGluZUNvdW50ICs9IGxpbmVEZWx0YTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0NvbHVtbkRlbHRhID0gdGhpcy5kZWx0YUxpbmVJZHhJbk9sZCA9PT0gbmV4dEVkaXQuZW5kT2Zmc2V0QmVmb3JlT2JqLmxpbmVDb3VudCA/IHRoaXMuZGVsdGFPbGRUb05ld0NvbHVtbkNvdW50IDogMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5EZWx0YSA9IG5leHRFZGl0RW5kT2Zmc2V0SW5DdXJPYmouY29sdW1uQ291bnQgLSBuZXh0RWRpdEVuZE9mZnNldEJlZm9yZUluQ3VyT2JqLmNvbHVtbkNvdW50O1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsdGFPbGRUb05ld0NvbHVtbkNvdW50ID0gcHJldmlvdXNDb2x1bW5EZWx0YSArIGNvbHVtbkRlbHRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsdGFMaW5lSWR4SW5PbGQgPSBuZXh0RWRpdC5lbmRPZmZzZXRCZWZvcmVPYmoubGluZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGluIG9yIGJlZm9yZSB0aGUgZWRpdC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFRleHRFZGl0SW5mb0NhY2hlIHtcbiAgICBzdGF0aWMgZnJvbShlZGl0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEVkaXRJbmZvQ2FjaGUoZWRpdC5zdGFydE9mZnNldCwgZWRpdC5lbmRPZmZzZXQsIGVkaXQubmV3TGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdGV4dExlbmd0aCkge1xuICAgICAgICB0aGlzLmVuZE9mZnNldEJlZm9yZU9iaiA9IGxlbmd0aFRvT2JqKGVuZE9mZnNldCk7XG4gICAgICAgIHRoaXMuZW5kT2Zmc2V0QWZ0ZXJPYmogPSBsZW5ndGhUb09iaihsZW5ndGhBZGQoc3RhcnRPZmZzZXQsIHRleHRMZW5ndGgpKTtcbiAgICAgICAgdGhpcy5vZmZzZXRPYmogPSBsZW5ndGhUb09iaihzdGFydE9mZnNldCk7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vZXZlbnQuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2xpZmVjeWNsZS5qcyc7XG5pbXBvcnQgeyBCcmFja2V0SW5mbywgQnJhY2tldFBhaXJXaXRoTWluSW5kZW50YXRpb25JbmZvIH0gZnJvbSAnLi4vLi4vLi4vdGV4dE1vZGVsQnJhY2tldFBhaXJzLmpzJztcbmltcG9ydCB7IFRleHRFZGl0SW5mbyB9IGZyb20gJy4vYmVmb3JlRWRpdFBvc2l0aW9uTWFwcGVyLmpzJztcbmltcG9ydCB7IExhbmd1YWdlQWdub3N0aWNCcmFja2V0VG9rZW5zIH0gZnJvbSAnLi9icmFja2V0cy5qcyc7XG5pbXBvcnQgeyBsZW5ndGhBZGQsIGxlbmd0aEdyZWF0ZXJUaGFuRXF1YWwsIGxlbmd0aExlc3NUaGFuLCBsZW5ndGhMZXNzVGhhbkVxdWFsLCBsZW5ndGhzVG9SYW5nZSwgbGVuZ3RoWmVybywgcG9zaXRpb25Ub0xlbmd0aCwgdG9MZW5ndGggfSBmcm9tICcuL2xlbmd0aC5qcyc7XG5pbXBvcnQgeyBwYXJzZURvY3VtZW50IH0gZnJvbSAnLi9wYXJzZXIuanMnO1xuaW1wb3J0IHsgRGVuc2VLZXlQcm92aWRlciB9IGZyb20gJy4vc21hbGxJbW11dGFibGVTZXQuanMnO1xuaW1wb3J0IHsgRmFzdFRva2VuaXplciwgVGV4dEJ1ZmZlclRva2VuaXplciB9IGZyb20gJy4vdG9rZW5pemVyLmpzJztcbmltcG9ydCB7IENhbGxiYWNrSXRlcmFibGUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xuaW1wb3J0IHsgY29tYmluZVRleHRFZGl0SW5mb3MgfSBmcm9tICcuL2NvbWJpbmVUZXh0RWRpdEluZm9zLmpzJztcbmV4cG9ydCBjbGFzcyBCcmFja2V0UGFpcnNUcmVlIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG4gICAgZGlkTGFuZ3VhZ2VDaGFuZ2UobGFuZ3VhZ2VJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icmFja2V0cy5kaWRMYW5ndWFnZUNoYW5nZShsYW5ndWFnZUlkKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodGV4dE1vZGVsLCBnZXRMYW5ndWFnZUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0TW9kZWwgPSB0ZXh0TW9kZWw7XG4gICAgICAgIHRoaXMuZ2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uID0gZ2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uO1xuICAgICAgICB0aGlzLmRpZENoYW5nZUVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlbnNlS2V5UHJvdmlkZXIgPSBuZXcgRGVuc2VLZXlQcm92aWRlcigpO1xuICAgICAgICB0aGlzLmJyYWNrZXRzID0gbmV3IExhbmd1YWdlQWdub3N0aWNCcmFja2V0VG9rZW5zKHRoaXMuZGVuc2VLZXlQcm92aWRlciwgdGhpcy5nZXRMYW5ndWFnZUNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlID0gdGhpcy5kaWRDaGFuZ2VFbWl0dGVyLmV2ZW50O1xuICAgICAgICB0aGlzLnF1ZXVlZFRleHRFZGl0c0ZvckluaXRpYWxBc3RXaXRob3V0VG9rZW5zID0gW107XG4gICAgICAgIHRoaXMucXVldWVkVGV4dEVkaXRzID0gW107XG4gICAgICAgIGlmICghdGV4dE1vZGVsLnRva2VuaXphdGlvbi5oYXNUb2tlbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJyYWNrZXRzID0gdGhpcy5icmFja2V0cy5nZXRTaW5nbGVMYW5ndWFnZUJyYWNrZXRUb2tlbnModGhpcy50ZXh0TW9kZWwuZ2V0TGFuZ3VhZ2VJZCgpKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuaXplciA9IG5ldyBGYXN0VG9rZW5pemVyKHRoaXMudGV4dE1vZGVsLmdldFZhbHVlKCksIGJyYWNrZXRzKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbEFzdFdpdGhvdXRUb2tlbnMgPSBwYXJzZURvY3VtZW50KHRva2VuaXplciwgW10sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmFzdFdpdGhUb2tlbnMgPSB0aGlzLmluaXRpYWxBc3RXaXRob3V0VG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHRNb2RlbC50b2tlbml6YXRpb24uYmFja2dyb3VuZFRva2VuaXphdGlvblN0YXRlID09PSAyIC8qIEJhY2tncm91bmRUb2tlbml6YXRpb25TdGF0ZS5Db21wbGV0ZWQgKi8pIHtcbiAgICAgICAgICAgIC8vIFNraXAgdGhlIGluaXRpYWwgYXN0LCBhcyB0aGVyZSBpcyBubyBmbGlja2VyaW5nLlxuICAgICAgICAgICAgLy8gRGlyZWN0bHkgY3JlYXRlIHRoZSB0cmVlIHdpdGggdG9rZW4gaW5mb3JtYXRpb24uXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxBc3RXaXRob3V0VG9rZW5zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5hc3RXaXRoVG9rZW5zID0gdGhpcy5wYXJzZURvY3VtZW50RnJvbVRleHRCdWZmZXIoW10sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgbWlzc2VkIHNvbWUgdG9rZW4gY2hhbmdlcyBhbHJlYWR5LCBzbyB3ZSBjYW5ub3QgdXNlIHRoZSBmYXN0IHRva2VuaXplciArIGRlbHRhIGluY3JlbWVudHNcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbEFzdFdpdGhvdXRUb2tlbnMgPSB0aGlzLnBhcnNlRG9jdW1lbnRGcm9tVGV4dEJ1ZmZlcihbXSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYXN0V2l0aFRva2VucyA9IHRoaXMuaW5pdGlhbEFzdFdpdGhvdXRUb2tlbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8jcmVnaW9uIFRleHRNb2RlbCBldmVudHNcbiAgICBoYW5kbGVEaWRDaGFuZ2VCYWNrZ3JvdW5kVG9rZW5pemF0aW9uU3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRNb2RlbC50b2tlbml6YXRpb24uYmFja2dyb3VuZFRva2VuaXphdGlvblN0YXRlID09PSAyIC8qIEJhY2tncm91bmRUb2tlbml6YXRpb25TdGF0ZS5Db21wbGV0ZWQgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IHdhc1VuZGVmaW5lZCA9IHRoaXMuaW5pdGlhbEFzdFdpdGhvdXRUb2tlbnMgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBpbml0aWFsIHRyZWUgYXMgd2UgY2FuIHVzZSB0aGUgdHJlZSB3aXRoIHRva2VuIGluZm9ybWF0aW9uIG5vdy5cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbEFzdFdpdGhvdXRUb2tlbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIXdhc1VuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlkQ2hhbmdlRW1pdHRlci5maXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRGlkQ2hhbmdlVG9rZW5zKHsgcmFuZ2VzIH0pIHtcbiAgICAgICAgY29uc3QgZWRpdHMgPSByYW5nZXMubWFwKHIgPT4gbmV3IFRleHRFZGl0SW5mbyh0b0xlbmd0aChyLmZyb21MaW5lTnVtYmVyIC0gMSwgMCksIHRvTGVuZ3RoKHIudG9MaW5lTnVtYmVyLCAwKSwgdG9MZW5ndGgoci50b0xpbmVOdW1iZXIgLSByLmZyb21MaW5lTnVtYmVyICsgMSwgMCkpKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFZGl0cyhlZGl0cywgdHJ1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsQXN0V2l0aG91dFRva2Vucykge1xuICAgICAgICAgICAgdGhpcy5kaWRDaGFuZ2VFbWl0dGVyLmZpcmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDb250ZW50Q2hhbmdlZChjaGFuZ2UpIHtcbiAgICAgICAgY29uc3QgZWRpdHMgPSBUZXh0RWRpdEluZm8uZnJvbU1vZGVsQ29udGVudENoYW5nZXMoY2hhbmdlLmNoYW5nZXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUVkaXRzKGVkaXRzLCBmYWxzZSk7XG4gICAgfVxuICAgIGhhbmRsZUVkaXRzKGVkaXRzLCB0b2tlbkNoYW5nZSkge1xuICAgICAgICAvLyBMYXppbHkgcXVldWUgdGhlIGVkaXRzIGFuZCBvbmx5IGFwcGx5IHRoZW0gd2hlbiB0aGUgdHJlZSBpcyBhY2Nlc3NlZC5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tYmluZVRleHRFZGl0SW5mb3ModGhpcy5xdWV1ZWRUZXh0RWRpdHMsIGVkaXRzKTtcbiAgICAgICAgdGhpcy5xdWV1ZWRUZXh0RWRpdHMgPSByZXN1bHQ7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxBc3RXaXRob3V0VG9rZW5zICYmICF0b2tlbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRUZXh0RWRpdHNGb3JJbml0aWFsQXN0V2l0aG91dFRva2VucyA9IGNvbWJpbmVUZXh0RWRpdEluZm9zKHRoaXMucXVldWVkVGV4dEVkaXRzRm9ySW5pdGlhbEFzdFdpdGhvdXRUb2tlbnMsIGVkaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgICBmbHVzaFF1ZXVlKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWRUZXh0RWRpdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hc3RXaXRoVG9rZW5zID0gdGhpcy5wYXJzZURvY3VtZW50RnJvbVRleHRCdWZmZXIodGhpcy5xdWV1ZWRUZXh0RWRpdHMsIHRoaXMuYXN0V2l0aFRva2VucywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRUZXh0RWRpdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWV1ZWRUZXh0RWRpdHNGb3JJbml0aWFsQXN0V2l0aG91dFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsQXN0V2l0aG91dFRva2Vucykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbEFzdFdpdGhvdXRUb2tlbnMgPSB0aGlzLnBhcnNlRG9jdW1lbnRGcm9tVGV4dEJ1ZmZlcih0aGlzLnF1ZXVlZFRleHRFZGl0c0ZvckluaXRpYWxBc3RXaXRob3V0VG9rZW5zLCB0aGlzLmluaXRpYWxBc3RXaXRob3V0VG9rZW5zLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZFRleHRFZGl0c0ZvckluaXRpYWxBc3RXaXRob3V0VG9rZW5zID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1cmUgKG9ubHkgaWYgaXNQdXJlID0gdHJ1ZSlcbiAgICAqL1xuICAgIHBhcnNlRG9jdW1lbnRGcm9tVGV4dEJ1ZmZlcihlZGl0cywgcHJldmlvdXNBc3QsIGltbXV0YWJsZSkge1xuICAgICAgICAvLyBJcyBtdWNoIGZhc3RlciBpZiBgaXNQdXJlID0gZmFsc2VgLlxuICAgICAgICBjb25zdCBpc1B1cmUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNBc3RDbG9uZSA9IGlzUHVyZSA/IHByZXZpb3VzQXN0Py5kZWVwQ2xvbmUoKSA6IHByZXZpb3VzQXN0O1xuICAgICAgICBjb25zdCB0b2tlbml6ZXIgPSBuZXcgVGV4dEJ1ZmZlclRva2VuaXplcih0aGlzLnRleHRNb2RlbCwgdGhpcy5icmFja2V0cyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlRG9jdW1lbnQodG9rZW5pemVyLCBlZGl0cywgcHJldmlvdXNBc3RDbG9uZSwgaW1tdXRhYmxlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0QnJhY2tldHNJblJhbmdlKHJhbmdlLCBvbmx5Q29sb3JpemVkQnJhY2tldHMpIHtcbiAgICAgICAgdGhpcy5mbHVzaFF1ZXVlKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdG9MZW5ndGgocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMSwgcmFuZ2Uuc3RhcnRDb2x1bW4gLSAxKTtcbiAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gdG9MZW5ndGgocmFuZ2UuZW5kTGluZU51bWJlciAtIDEsIHJhbmdlLmVuZENvbHVtbiAtIDEpO1xuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrSXRlcmFibGUoY2IgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuaW5pdGlhbEFzdFdpdGhvdXRUb2tlbnMgfHwgdGhpcy5hc3RXaXRoVG9rZW5zO1xuICAgICAgICAgICAgY29sbGVjdEJyYWNrZXRzKG5vZGUsIGxlbmd0aFplcm8sIG5vZGUubGVuZ3RoLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBjYiwgMCwgMCwgbmV3IE1hcCgpLCBvbmx5Q29sb3JpemVkQnJhY2tldHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QnJhY2tldFBhaXJzSW5SYW5nZShyYW5nZSwgaW5jbHVkZU1pbkluZGVudGF0aW9uKSB7XG4gICAgICAgIHRoaXMuZmx1c2hRdWV1ZSgpO1xuICAgICAgICBjb25zdCBzdGFydExlbmd0aCA9IHBvc2l0aW9uVG9MZW5ndGgocmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbigpKTtcbiAgICAgICAgY29uc3QgZW5kTGVuZ3RoID0gcG9zaXRpb25Ub0xlbmd0aChyYW5nZS5nZXRFbmRQb3NpdGlvbigpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja0l0ZXJhYmxlKGNiID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmluaXRpYWxBc3RXaXRob3V0VG9rZW5zIHx8IHRoaXMuYXN0V2l0aFRva2VucztcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgQ29sbGVjdEJyYWNrZXRQYWlyc0NvbnRleHQoY2IsIGluY2x1ZGVNaW5JbmRlbnRhdGlvbiwgdGhpcy50ZXh0TW9kZWwpO1xuICAgICAgICAgICAgY29sbGVjdEJyYWNrZXRQYWlycyhub2RlLCBsZW5ndGhaZXJvLCBub2RlLmxlbmd0aCwgc3RhcnRMZW5ndGgsIGVuZExlbmd0aCwgY29udGV4dCwgMCwgbmV3IE1hcCgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEZpcnN0QnJhY2tldEFmdGVyKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZmx1c2hRdWV1ZSgpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5pbml0aWFsQXN0V2l0aG91dFRva2VucyB8fCB0aGlzLmFzdFdpdGhUb2tlbnM7XG4gICAgICAgIHJldHVybiBnZXRGaXJzdEJyYWNrZXRBZnRlcihub2RlLCBsZW5ndGhaZXJvLCBub2RlLmxlbmd0aCwgcG9zaXRpb25Ub0xlbmd0aChwb3NpdGlvbikpO1xuICAgIH1cbiAgICBnZXRGaXJzdEJyYWNrZXRCZWZvcmUocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5mbHVzaFF1ZXVlKCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmluaXRpYWxBc3RXaXRob3V0VG9rZW5zIHx8IHRoaXMuYXN0V2l0aFRva2VucztcbiAgICAgICAgcmV0dXJuIGdldEZpcnN0QnJhY2tldEJlZm9yZShub2RlLCBsZW5ndGhaZXJvLCBub2RlLmxlbmd0aCwgcG9zaXRpb25Ub0xlbmd0aChwb3NpdGlvbikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEZpcnN0QnJhY2tldEJlZm9yZShub2RlLCBub2RlT2Zmc2V0U3RhcnQsIG5vZGVPZmZzZXRFbmQsIHBvc2l0aW9uKSB7XG4gICAgaWYgKG5vZGUua2luZCA9PT0gNCAvKiBBc3ROb2RlS2luZC5MaXN0ICovIHx8IG5vZGUua2luZCA9PT0gMiAvKiBBc3ROb2RlS2luZC5QYWlyICovKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBub2RlT2Zmc2V0RW5kID0gbGVuZ3RoQWRkKG5vZGVPZmZzZXRTdGFydCwgY2hpbGQubGVuZ3RoKTtcbiAgICAgICAgICAgIGxlbmd0aHMucHVzaCh7IG5vZGVPZmZzZXRTdGFydCwgbm9kZU9mZnNldEVuZCB9KTtcbiAgICAgICAgICAgIG5vZGVPZmZzZXRTdGFydCA9IG5vZGVPZmZzZXRFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZU9mZnNldFN0YXJ0LCBub2RlT2Zmc2V0RW5kIH0gPSBsZW5ndGhzW2ldO1xuICAgICAgICAgICAgaWYgKGxlbmd0aExlc3NUaGFuKG5vZGVPZmZzZXRTdGFydCwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Rmlyc3RCcmFja2V0QmVmb3JlKG5vZGUuY2hpbGRyZW5baV0sIG5vZGVPZmZzZXRTdGFydCwgbm9kZU9mZnNldEVuZCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUua2luZCA9PT0gMyAvKiBBc3ROb2RlS2luZC5VbmV4cGVjdGVkQ2xvc2luZ0JyYWNrZXQgKi8pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUua2luZCA9PT0gMSAvKiBBc3ROb2RlS2luZC5CcmFja2V0ICovKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gbGVuZ3Roc1RvUmFuZ2Uobm9kZU9mZnNldFN0YXJ0LCBub2RlT2Zmc2V0RW5kKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJyYWNrZXRJbmZvOiBub2RlLmJyYWNrZXRJbmZvLFxuICAgICAgICAgICAgcmFuZ2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRGaXJzdEJyYWNrZXRBZnRlcihub2RlLCBub2RlT2Zmc2V0U3RhcnQsIG5vZGVPZmZzZXRFbmQsIHBvc2l0aW9uKSB7XG4gICAgaWYgKG5vZGUua2luZCA9PT0gNCAvKiBBc3ROb2RlS2luZC5MaXN0ICovIHx8IG5vZGUua2luZCA9PT0gMiAvKiBBc3ROb2RlS2luZC5QYWlyICovKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgbm9kZU9mZnNldEVuZCA9IGxlbmd0aEFkZChub2RlT2Zmc2V0U3RhcnQsIGNoaWxkLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAobGVuZ3RoTGVzc1RoYW4ocG9zaXRpb24sIG5vZGVPZmZzZXRFbmQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Rmlyc3RCcmFja2V0QWZ0ZXIoY2hpbGQsIG5vZGVPZmZzZXRTdGFydCwgbm9kZU9mZnNldEVuZCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlT2Zmc2V0U3RhcnQgPSBub2RlT2Zmc2V0RW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLmtpbmQgPT09IDMgLyogQXN0Tm9kZUtpbmQuVW5leHBlY3RlZENsb3NpbmdCcmFja2V0ICovKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLmtpbmQgPT09IDEgLyogQXN0Tm9kZUtpbmQuQnJhY2tldCAqLykge1xuICAgICAgICBjb25zdCByYW5nZSA9IGxlbmd0aHNUb1JhbmdlKG5vZGVPZmZzZXRTdGFydCwgbm9kZU9mZnNldEVuZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBicmFja2V0SW5mbzogbm9kZS5icmFja2V0SW5mbyxcbiAgICAgICAgICAgIHJhbmdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29sbGVjdEJyYWNrZXRzKG5vZGUsIG5vZGVPZmZzZXRTdGFydCwgbm9kZU9mZnNldEVuZCwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgcHVzaCwgbGV2ZWwsIG5lc3RpbmdMZXZlbE9mRXF1YWxCcmFja2V0VHlwZSwgbGV2ZWxQZXJCcmFja2V0VHlwZSwgb25seUNvbG9yaXplZEJyYWNrZXRzLCBwYXJlbnRQYWlySXNJbmNvbXBsZXRlID0gZmFsc2UpIHtcbiAgICBpZiAobGV2ZWwgPiAyMDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHdoaWxlTG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgNCAvKiBBc3ROb2RlS2luZC5MaXN0ICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDb3VudCA9IG5vZGUuY2hpbGRyZW5MZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmdldENoaWxkKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlT2Zmc2V0RW5kID0gbGVuZ3RoQWRkKG5vZGVPZmZzZXRTdGFydCwgY2hpbGQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aExlc3NUaGFuRXF1YWwobm9kZU9mZnNldFN0YXJ0LCBlbmRPZmZzZXQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhHcmVhdGVyVGhhbkVxdWFsKG5vZGVPZmZzZXRFbmQsIHN0YXJ0T2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRFbmRzQWZ0ZXJFbmQgPSBsZW5ndGhHcmVhdGVyVGhhbkVxdWFsKG5vZGVPZmZzZXRFbmQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRFbmRzQWZ0ZXJFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBjaGlsZCBhZnRlciB0aGlzIGNoaWxkIGluIHRoZSByZXF1ZXN0ZWQgd2luZG93LCBkb24ndCByZWN1cnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHdoaWxlTG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZENvbnRpbnVlID0gY29sbGVjdEJyYWNrZXRzKGNoaWxkLCBub2RlT2Zmc2V0U3RhcnQsIG5vZGVPZmZzZXRFbmQsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHB1c2gsIGxldmVsLCAwLCBsZXZlbFBlckJyYWNrZXRUeXBlLCBvbmx5Q29sb3JpemVkQnJhY2tldHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRDb250aW51ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlT2Zmc2V0U3RhcnQgPSBub2RlT2Zmc2V0RW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMiAvKiBBc3ROb2RlS2luZC5QYWlyICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JpemUgPSAhb25seUNvbG9yaXplZEJyYWNrZXRzIHx8ICFub2RlLmNsb3NpbmdCcmFja2V0IHx8IG5vZGUuY2xvc2luZ0JyYWNrZXQuYnJhY2tldEluZm8uY2xvc2VzQ29sb3JpemVkKG5vZGUub3BlbmluZ0JyYWNrZXQuYnJhY2tldEluZm8pO1xuICAgICAgICAgICAgICAgIGxldCBsZXZlbFBlckJyYWNrZXQgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbFBlckJyYWNrZXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBleGlzdGluZyA9IGxldmVsUGVyQnJhY2tldFR5cGUuZ2V0KG5vZGUub3BlbmluZ0JyYWNrZXQudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxQZXJCcmFja2V0ID0gZXhpc3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvcml6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsUGVyQnJhY2tldFR5cGUuc2V0KG5vZGUub3BlbmluZ0JyYWNrZXQudGV4dCwgZXhpc3RpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ291bnQgPSBub2RlLmNoaWxkcmVuTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRDaGlsZChpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZU9mZnNldEVuZCA9IGxlbmd0aEFkZChub2RlT2Zmc2V0U3RhcnQsIGNoaWxkLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGhMZXNzVGhhbkVxdWFsKG5vZGVPZmZzZXRTdGFydCwgZW5kT2Zmc2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoR3JlYXRlclRoYW5FcXVhbChub2RlT2Zmc2V0RW5kLCBzdGFydE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkRW5kc0FmdGVyRW5kID0gbGVuZ3RoR3JlYXRlclRoYW5FcXVhbChub2RlT2Zmc2V0RW5kLCBlbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkRW5kc0FmdGVyRW5kICYmIGNoaWxkLmtpbmQgIT09IDEgLyogQXN0Tm9kZUtpbmQuQnJhY2tldCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGNoaWxkIGFmdGVyIHRoaXMgY2hpbGQgaW4gdGhlIHJlcXVlc3RlZCB3aW5kb3csIGRvbid0IHJlY3Vyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyB0aGlzIGZvciBicmFja2V0cyBiZWNhdXNlIG9mIHVuY2xvc2VkL3Vub3BlbmVkIGJyYWNrZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvcml6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0aW5nTGV2ZWxPZkVxdWFsQnJhY2tldFR5cGUgPSBsZXZlbFBlckJyYWNrZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGluZ0xldmVsT2ZFcXVhbEJyYWNrZXRUeXBlID0gbGV2ZWxQZXJCcmFja2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSB3aGlsZUxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3JpemUgfHwgY2hpbGQua2luZCAhPT0gMSAvKiBBc3ROb2RlS2luZC5CcmFja2V0ICovIHx8ICFub2RlLmNsb3NpbmdCcmFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkQ29udGludWUgPSBjb2xsZWN0QnJhY2tldHMoY2hpbGQsIG5vZGVPZmZzZXRTdGFydCwgbm9kZU9mZnNldEVuZCwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgcHVzaCwgY29sb3JpemUgPyBsZXZlbCArIDEgOiBsZXZlbCwgY29sb3JpemUgPyBsZXZlbFBlckJyYWNrZXQgKyAxIDogbGV2ZWxQZXJCcmFja2V0LCBsZXZlbFBlckJyYWNrZXRUeXBlLCBvbmx5Q29sb3JpemVkQnJhY2tldHMsICFub2RlLmNsb3NpbmdCcmFja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZENvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZU9mZnNldFN0YXJ0ID0gbm9kZU9mZnNldEVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV2ZWxQZXJCcmFja2V0VHlwZT8uc2V0KG5vZGUub3BlbmluZ0JyYWNrZXQudGV4dCwgbGV2ZWxQZXJCcmFja2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMyAvKiBBc3ROb2RlS2luZC5VbmV4cGVjdGVkQ2xvc2luZ0JyYWNrZXQgKi86IHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGxlbmd0aHNUb1JhbmdlKG5vZGVPZmZzZXRTdGFydCwgbm9kZU9mZnNldEVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1c2gobmV3IEJyYWNrZXRJbmZvKHJhbmdlLCBsZXZlbCAtIDEsIDAsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMSAvKiBBc3ROb2RlS2luZC5CcmFja2V0ICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBsZW5ndGhzVG9SYW5nZShub2RlT2Zmc2V0U3RhcnQsIG5vZGVPZmZzZXRFbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwdXNoKG5ldyBCcmFja2V0SW5mbyhyYW5nZSwgbGV2ZWwgLSAxLCBuZXN0aW5nTGV2ZWxPZkVxdWFsQnJhY2tldFR5cGUgLSAxLCBwYXJlbnRQYWlySXNJbmNvbXBsZXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDAgLyogQXN0Tm9kZUtpbmQuVGV4dCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENvbGxlY3RCcmFja2V0UGFpcnNDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwdXNoLCBpbmNsdWRlTWluSW5kZW50YXRpb24sIHRleHRNb2RlbCkge1xuICAgICAgICB0aGlzLnB1c2ggPSBwdXNoO1xuICAgICAgICB0aGlzLmluY2x1ZGVNaW5JbmRlbnRhdGlvbiA9IGluY2x1ZGVNaW5JbmRlbnRhdGlvbjtcbiAgICAgICAgdGhpcy50ZXh0TW9kZWwgPSB0ZXh0TW9kZWw7XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdEJyYWNrZXRQYWlycyhub2RlLCBub2RlT2Zmc2V0U3RhcnQsIG5vZGVPZmZzZXRFbmQsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIGNvbnRleHQsIGxldmVsLCBsZXZlbFBlckJyYWNrZXRUeXBlKSB7XG4gICAgaWYgKGxldmVsID4gMjAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkQ29udGludWUgPSB0cnVlO1xuICAgIGlmIChub2RlLmtpbmQgPT09IDIgLyogQXN0Tm9kZUtpbmQuUGFpciAqLykge1xuICAgICAgICBsZXQgbGV2ZWxQZXJCcmFja2V0ID0gMDtcbiAgICAgICAgaWYgKGxldmVsUGVyQnJhY2tldFR5cGUpIHtcbiAgICAgICAgICAgIGxldCBleGlzdGluZyA9IGxldmVsUGVyQnJhY2tldFR5cGUuZ2V0KG5vZGUub3BlbmluZ0JyYWNrZXQudGV4dCk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsUGVyQnJhY2tldCA9IGV4aXN0aW5nO1xuICAgICAgICAgICAgZXhpc3RpbmcrKztcbiAgICAgICAgICAgIGxldmVsUGVyQnJhY2tldFR5cGUuc2V0KG5vZGUub3BlbmluZ0JyYWNrZXQudGV4dCwgZXhpc3RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wZW5pbmdCcmFja2V0RW5kID0gbGVuZ3RoQWRkKG5vZGVPZmZzZXRTdGFydCwgbm9kZS5vcGVuaW5nQnJhY2tldC5sZW5ndGgpO1xuICAgICAgICBsZXQgbWluSW5kZW50YXRpb24gPSAtMTtcbiAgICAgICAgaWYgKGNvbnRleHQuaW5jbHVkZU1pbkluZGVudGF0aW9uKSB7XG4gICAgICAgICAgICBtaW5JbmRlbnRhdGlvbiA9IG5vZGUuY29tcHV0ZU1pbkluZGVudGF0aW9uKG5vZGVPZmZzZXRTdGFydCwgY29udGV4dC50ZXh0TW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIHNob3VsZENvbnRpbnVlID0gY29udGV4dC5wdXNoKG5ldyBCcmFja2V0UGFpcldpdGhNaW5JbmRlbnRhdGlvbkluZm8obGVuZ3Roc1RvUmFuZ2Uobm9kZU9mZnNldFN0YXJ0LCBub2RlT2Zmc2V0RW5kKSwgbGVuZ3Roc1RvUmFuZ2Uobm9kZU9mZnNldFN0YXJ0LCBvcGVuaW5nQnJhY2tldEVuZCksIG5vZGUuY2xvc2luZ0JyYWNrZXRcbiAgICAgICAgICAgID8gbGVuZ3Roc1RvUmFuZ2UobGVuZ3RoQWRkKG9wZW5pbmdCcmFja2V0RW5kLCBub2RlLmNoaWxkPy5sZW5ndGggfHwgbGVuZ3RoWmVybyksIG5vZGVPZmZzZXRFbmQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCwgbGV2ZWwsIGxldmVsUGVyQnJhY2tldCwgbm9kZSwgbWluSW5kZW50YXRpb24pKTtcbiAgICAgICAgbm9kZU9mZnNldFN0YXJ0ID0gb3BlbmluZ0JyYWNrZXRFbmQ7XG4gICAgICAgIGlmIChzaG91bGRDb250aW51ZSAmJiBub2RlLmNoaWxkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgICBub2RlT2Zmc2V0RW5kID0gbGVuZ3RoQWRkKG5vZGVPZmZzZXRTdGFydCwgY2hpbGQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChsZW5ndGhMZXNzVGhhbkVxdWFsKG5vZGVPZmZzZXRTdGFydCwgZW5kT2Zmc2V0KSAmJlxuICAgICAgICAgICAgICAgIGxlbmd0aEdyZWF0ZXJUaGFuRXF1YWwobm9kZU9mZnNldEVuZCwgc3RhcnRPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQ29udGludWUgPSBjb2xsZWN0QnJhY2tldFBhaXJzKGNoaWxkLCBub2RlT2Zmc2V0U3RhcnQsIG5vZGVPZmZzZXRFbmQsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIGNvbnRleHQsIGxldmVsICsgMSwgbGV2ZWxQZXJCcmFja2V0VHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRDb250aW51ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldmVsUGVyQnJhY2tldFR5cGU/LnNldChub2RlLm9wZW5pbmdCcmFja2V0LnRleHQsIGxldmVsUGVyQnJhY2tldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY3VyT2Zmc2V0ID0gbm9kZU9mZnNldFN0YXJ0O1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkT2Zmc2V0ID0gY3VyT2Zmc2V0O1xuICAgICAgICAgICAgY3VyT2Zmc2V0ID0gbGVuZ3RoQWRkKGN1ck9mZnNldCwgY2hpbGQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChsZW5ndGhMZXNzVGhhbkVxdWFsKGNoaWxkT2Zmc2V0LCBlbmRPZmZzZXQpICYmXG4gICAgICAgICAgICAgICAgbGVuZ3RoTGVzc1RoYW5FcXVhbChzdGFydE9mZnNldCwgY3VyT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIHNob3VsZENvbnRpbnVlID0gY29sbGVjdEJyYWNrZXRQYWlycyhjaGlsZCwgY2hpbGRPZmZzZXQsIGN1ck9mZnNldCwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgY29udGV4dCwgbGV2ZWwsIGxldmVsUGVyQnJhY2tldFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkQ29udGludWU7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGVzY2FwZVJlZ0V4cENoYXJhY3RlcnMgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcbmltcG9ydCB7IEJyYWNrZXRBc3ROb2RlIH0gZnJvbSAnLi9hc3QuanMnO1xuaW1wb3J0IHsgdG9MZW5ndGggfSBmcm9tICcuL2xlbmd0aC5qcyc7XG5pbXBvcnQgeyBpZGVudGl0eUtleVByb3ZpZGVyLCBTbWFsbEltbXV0YWJsZVNldCB9IGZyb20gJy4vc21hbGxJbW11dGFibGVTZXQuanMnO1xuaW1wb3J0IHsgVG9rZW4gfSBmcm9tICcuL3Rva2VuaXplci5qcyc7XG5leHBvcnQgY2xhc3MgQnJhY2tldFRva2VucyB7XG4gICAgc3RhdGljIGNyZWF0ZUZyb21MYW5ndWFnZShjb25maWd1cmF0aW9uLCBkZW5zZUtleVByb3ZpZGVyKSB7XG4gICAgICAgIGZ1bmN0aW9uIGdldElkKGJyYWNrZXRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVuc2VLZXlQcm92aWRlci5nZXRLZXkoYCR7YnJhY2tldEluZm8ubGFuZ3VhZ2VJZH06Ojoke2JyYWNrZXRJbmZvLmJyYWNrZXRUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBvcGVuaW5nQnJhY2tldCBvZiBjb25maWd1cmF0aW9uLmJyYWNrZXRzTmV3Lm9wZW5pbmdCcmFja2V0cykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdG9MZW5ndGgoMCwgb3BlbmluZ0JyYWNrZXQuYnJhY2tldFRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5pbmdUZXh0SWQgPSBnZXRJZChvcGVuaW5nQnJhY2tldCk7XG4gICAgICAgICAgICBjb25zdCBicmFja2V0SWRzID0gU21hbGxJbW11dGFibGVTZXQuZ2V0RW1wdHkoKS5hZGQob3BlbmluZ1RleHRJZCwgaWRlbnRpdHlLZXlQcm92aWRlcik7XG4gICAgICAgICAgICBtYXAuc2V0KG9wZW5pbmdCcmFja2V0LmJyYWNrZXRUZXh0LCBuZXcgVG9rZW4obGVuZ3RoLCAxIC8qIFRva2VuS2luZC5PcGVuaW5nQnJhY2tldCAqLywgb3BlbmluZ1RleHRJZCwgYnJhY2tldElkcywgQnJhY2tldEFzdE5vZGUuY3JlYXRlKGxlbmd0aCwgb3BlbmluZ0JyYWNrZXQsIGJyYWNrZXRJZHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjbG9zaW5nQnJhY2tldCBvZiBjb25maWd1cmF0aW9uLmJyYWNrZXRzTmV3LmNsb3NpbmdCcmFja2V0cykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdG9MZW5ndGgoMCwgY2xvc2luZ0JyYWNrZXQuYnJhY2tldFRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBicmFja2V0SWRzID0gU21hbGxJbW11dGFibGVTZXQuZ2V0RW1wdHkoKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NpbmdCcmFja2V0cyA9IGNsb3NpbmdCcmFja2V0LmdldE9wZW5pbmdCcmFja2V0cygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBicmFja2V0IG9mIGNsb3NpbmdCcmFja2V0cykge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRJZHMgPSBicmFja2V0SWRzLmFkZChnZXRJZChicmFja2V0KSwgaWRlbnRpdHlLZXlQcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXAuc2V0KGNsb3NpbmdCcmFja2V0LmJyYWNrZXRUZXh0LCBuZXcgVG9rZW4obGVuZ3RoLCAyIC8qIFRva2VuS2luZC5DbG9zaW5nQnJhY2tldCAqLywgZ2V0SWQoY2xvc2luZ0JyYWNrZXRzWzBdKSwgYnJhY2tldElkcywgQnJhY2tldEFzdE5vZGUuY3JlYXRlKGxlbmd0aCwgY2xvc2luZ0JyYWNrZXQsIGJyYWNrZXRJZHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCcmFja2V0VG9rZW5zKG1hcCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5oYXNSZWdFeHAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVnRXhwR2xvYmFsID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0UmVnRXhwU3RyKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbLi4udGhpcy5tYXAua2V5cygpXTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAga2V5cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICByZXR1cm4ga2V5cy5tYXAoayA9PiBwcmVwYXJlQnJhY2tldEZvclJlZ0V4cChrKSkuam9pbignfCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyBzdWNoIHJlZ2V4cCAoYmVjYXVzZSB0aGVyZSBhcmUgbm8gYnJhY2tldHMpLlxuICAgICovXG4gICAgZ2V0IHJlZ0V4cEdsb2JhbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JlZ0V4cCkge1xuICAgICAgICAgICAgY29uc3QgcmVnRXhwU3RyID0gdGhpcy5nZXRSZWdFeHBTdHIoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ0V4cEdsb2JhbCA9IHJlZ0V4cFN0ciA/IG5ldyBSZWdFeHAocmVnRXhwU3RyLCAnZ2knKSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1JlZ0V4cCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ0V4cEdsb2JhbDtcbiAgICB9XG4gICAgZ2V0VG9rZW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldCh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgZmluZENsb3NpbmdUb2tlblRleHQob3BlbmluZ0JyYWNrZXRJZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBbY2xvc2luZ1RleHQsIGluZm9dIG9mIHRoaXMubWFwKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5raW5kID09PSAyIC8qIFRva2VuS2luZC5DbG9zaW5nQnJhY2tldCAqLyAmJiBpbmZvLmJyYWNrZXRJZHMuaW50ZXJzZWN0cyhvcGVuaW5nQnJhY2tldElkcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2luZ1RleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5zaXplID09PSAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVCcmFja2V0Rm9yUmVnRXhwKHN0cikge1xuICAgIGxldCBlc2NhcGVkID0gZXNjYXBlUmVnRXhwQ2hhcmFjdGVycyhzdHIpO1xuICAgIC8vIFRoZXNlIGJyYWNrZXQgcGFpciBkZWxpbWl0ZXJzIHN0YXJ0IG9yIGVuZCB3aXRoIGxldHRlcnNcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUvaXNzdWVzLzEzMjE2MiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L3ZzY29kZS9pc3N1ZXMvMTUwNDQwXG4gICAgaWYgKC9eW1xcdyBdKy8udGVzdChzdHIpKSB7XG4gICAgICAgIGVzY2FwZWQgPSBgXFxcXGIke2VzY2FwZWR9YDtcbiAgICB9XG4gICAgaWYgKC9bXFx3IF0rJC8udGVzdChzdHIpKSB7XG4gICAgICAgIGVzY2FwZWQgPSBgJHtlc2NhcGVkfVxcXFxiYDtcbiAgICB9XG4gICAgcmV0dXJuIGVzY2FwZWQ7XG59XG5leHBvcnQgY2xhc3MgTGFuZ3VhZ2VBZ25vc3RpY0JyYWNrZXRUb2tlbnMge1xuICAgIGNvbnN0cnVjdG9yKGRlbnNlS2V5UHJvdmlkZXIsIGdldExhbmd1YWdlQ29uZmlndXJhdGlvbikge1xuICAgICAgICB0aGlzLmRlbnNlS2V5UHJvdmlkZXIgPSBkZW5zZUtleVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmdldExhbmd1YWdlQ29uZmlndXJhdGlvbiA9IGdldExhbmd1YWdlQ29uZmlndXJhdGlvbjtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUlkVG9CcmFja2V0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBkaWRMYW5ndWFnZUNoYW5nZShsYW5ndWFnZUlkKSB7XG4gICAgICAgIC8vIFJlcG9ydCBhIGNoYW5nZSB3aGVuZXZlciB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbiB1cGRhdGVzLlxuICAgICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZUlkVG9CcmFja2V0VG9rZW5zLmhhcyhsYW5ndWFnZUlkKTtcbiAgICB9XG4gICAgZ2V0U2luZ2xlTGFuZ3VhZ2VCcmFja2V0VG9rZW5zKGxhbmd1YWdlSWQpIHtcbiAgICAgICAgbGV0IHNpbmdsZUxhbmd1YWdlQnJhY2tldFRva2VucyA9IHRoaXMubGFuZ3VhZ2VJZFRvQnJhY2tldFRva2Vucy5nZXQobGFuZ3VhZ2VJZCk7XG4gICAgICAgIGlmICghc2luZ2xlTGFuZ3VhZ2VCcmFja2V0VG9rZW5zKSB7XG4gICAgICAgICAgICBzaW5nbGVMYW5ndWFnZUJyYWNrZXRUb2tlbnMgPSBCcmFja2V0VG9rZW5zLmNyZWF0ZUZyb21MYW5ndWFnZSh0aGlzLmdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKSwgdGhpcy5kZW5zZUtleVByb3ZpZGVyKTtcbiAgICAgICAgICAgIHRoaXMubGFuZ3VhZ2VJZFRvQnJhY2tldFRva2Vucy5zZXQobGFuZ3VhZ2VJZCwgc2luZ2xlTGFuZ3VhZ2VCcmFja2V0VG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luZ2xlTGFuZ3VhZ2VCcmFja2V0VG9rZW5zO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgQXJyYXlRdWV1ZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2FycmF5cy5qcyc7XG5pbXBvcnQgeyBUZXh0RWRpdEluZm8gfSBmcm9tICcuL2JlZm9yZUVkaXRQb3NpdGlvbk1hcHBlci5qcyc7XG5pbXBvcnQgeyBsZW5ndGhBZGQsIGxlbmd0aERpZmZOb25OZWdhdGl2ZSwgbGVuZ3RoRXF1YWxzLCBsZW5ndGhJc1plcm8sIGxlbmd0aFRvT2JqLCBsZW5ndGhaZXJvLCBzdW1MZW5ndGhzIH0gZnJvbSAnLi9sZW5ndGguanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVUZXh0RWRpdEluZm9zKHRleHRFZGl0SW5mb0ZpcnN0LCB0ZXh0RWRpdEluZm9TZWNvbmQpIHtcbiAgICBpZiAodGV4dEVkaXRJbmZvRmlyc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0ZXh0RWRpdEluZm9TZWNvbmQ7XG4gICAgfVxuICAgIGlmICh0ZXh0RWRpdEluZm9TZWNvbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0ZXh0RWRpdEluZm9GaXJzdDtcbiAgICB9XG4gICAgLy8gczA6IFN0YXRlIGJlZm9yZSBhbnkgZWRpdHNcbiAgICBjb25zdCBzMFRvUzFNYXAgPSBuZXcgQXJyYXlRdWV1ZSh0b0xlbmd0aE1hcHBpbmcodGV4dEVkaXRJbmZvRmlyc3QpKTtcbiAgICAvLyBzMTogU3RhdGUgYWZ0ZXIgZmlyc3QgZWRpdCwgYnV0IGJlZm9yZSBzZWNvbmQgZWRpdFxuICAgIGNvbnN0IHMxVG9TMk1hcCA9IHRvTGVuZ3RoTWFwcGluZyh0ZXh0RWRpdEluZm9TZWNvbmQpO1xuICAgIHMxVG9TMk1hcC5wdXNoKHsgbW9kaWZpZWQ6IGZhbHNlLCBsZW5ndGhCZWZvcmU6IHVuZGVmaW5lZCwgbGVuZ3RoQWZ0ZXI6IHVuZGVmaW5lZCB9KTsgLy8gQ29weSBldmVyeXRoaW5nIGZyb20gb2xkIHRvIG5ld1xuICAgIC8vIHMyOiBTdGF0ZSBhZnRlciBib3RoIGVkaXRzXG4gICAgbGV0IGN1ckl0ZW0gPSBzMFRvUzFNYXAuZGVxdWV1ZSgpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzMUxlbmd0aCBVc2UgdW5kZWZpbmVkIGZvciBsZW5ndGggXCJpbmZpbml0eVwiXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmV4dFMwVG9TMU1hcFdpdGhTMUxlbmd0aE9mKHMxTGVuZ3RoKSB7XG4gICAgICAgIGlmIChzMUxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBzMFRvUzFNYXAudGFrZVdoaWxlKHYgPT4gdHJ1ZSkgfHwgW107XG4gICAgICAgICAgICBpZiAoY3VySXRlbSkge1xuICAgICAgICAgICAgICAgIGFyci51bnNoaWZ0KGN1ckl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGN1ckl0ZW0gJiYgIWxlbmd0aElzWmVybyhzMUxlbmd0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpdGVtLCByZW1haW5pbmdJdGVtXSA9IGN1ckl0ZW0uc3BsaXRBdChzMUxlbmd0aCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHMxTGVuZ3RoID0gbGVuZ3RoRGlmZk5vbk5lZ2F0aXZlKGl0ZW0ubGVuZ3RoQWZ0ZXIsIHMxTGVuZ3RoKTtcbiAgICAgICAgICAgIGN1ckl0ZW0gPSByZW1haW5pbmdJdGVtID8/IHMwVG9TMU1hcC5kZXF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsZW5ndGhJc1plcm8oczFMZW5ndGgpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgTGVuZ3RoTWFwcGluZyhmYWxzZSwgczFMZW5ndGgsIHMxTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZnVuY3Rpb24gcHVzaEVkaXQoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgbmV3TGVuZ3RoKSB7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiBsZW5ndGhFcXVhbHMocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5lbmRPZmZzZXQsIHN0YXJ0T2Zmc2V0KSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlc3VsdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gbmV3IFRleHRFZGl0SW5mbyhsYXN0UmVzdWx0LnN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIGxlbmd0aEFkZChsYXN0UmVzdWx0Lm5ld0xlbmd0aCwgbmV3TGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIG5ld0xlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgczBvZmZzZXQgPSBsZW5ndGhaZXJvO1xuICAgIGZvciAoY29uc3QgczFUb1MyIG9mIHMxVG9TMk1hcCkge1xuICAgICAgICBjb25zdCBzMFRvUzFNYXAgPSBuZXh0UzBUb1MxTWFwV2l0aFMxTGVuZ3RoT2YoczFUb1MyLmxlbmd0aEJlZm9yZSk7XG4gICAgICAgIGlmIChzMVRvUzIubW9kaWZpZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHMwTGVuZ3RoID0gc3VtTGVuZ3RocyhzMFRvUzFNYXAsIHMgPT4gcy5sZW5ndGhCZWZvcmUpO1xuICAgICAgICAgICAgY29uc3QgczBFbmRPZmZzZXQgPSBsZW5ndGhBZGQoczBvZmZzZXQsIHMwTGVuZ3RoKTtcbiAgICAgICAgICAgIHB1c2hFZGl0KHMwb2Zmc2V0LCBzMEVuZE9mZnNldCwgczFUb1MyLmxlbmd0aEFmdGVyKTtcbiAgICAgICAgICAgIHMwb2Zmc2V0ID0gczBFbmRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMxIG9mIHMwVG9TMU1hcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMwc3RhcnRPZmZzZXQgPSBzMG9mZnNldDtcbiAgICAgICAgICAgICAgICBzMG9mZnNldCA9IGxlbmd0aEFkZChzMG9mZnNldCwgczEubGVuZ3RoQmVmb3JlKTtcbiAgICAgICAgICAgICAgICBpZiAoczEubW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaEVkaXQoczBzdGFydE9mZnNldCwgczBvZmZzZXQsIHMxLmxlbmd0aEFmdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIExlbmd0aE1hcHBpbmcge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIElmIGZhbHNlLCBsZW5ndGggYmVmb3JlIGFuZCBsZW5ndGggYWZ0ZXIgZXF1YWwuXG4gICAgICovXG4gICAgbW9kaWZpZWQsIGxlbmd0aEJlZm9yZSwgbGVuZ3RoQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5tb2RpZmllZCA9IG1vZGlmaWVkO1xuICAgICAgICB0aGlzLmxlbmd0aEJlZm9yZSA9IGxlbmd0aEJlZm9yZTtcbiAgICAgICAgdGhpcy5sZW5ndGhBZnRlciA9IGxlbmd0aEFmdGVyO1xuICAgIH1cbiAgICBzcGxpdEF0KGxlbmd0aEFmdGVyKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0xlbmd0aEFmdGVyID0gbGVuZ3RoRGlmZk5vbk5lZ2F0aXZlKGxlbmd0aEFmdGVyLCB0aGlzLmxlbmd0aEFmdGVyKTtcbiAgICAgICAgaWYgKGxlbmd0aEVxdWFscyhyZW1haW5pbmdMZW5ndGhBZnRlciwgbGVuZ3RoWmVybykpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcywgdW5kZWZpbmVkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1vZGlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5ldyBMZW5ndGhNYXBwaW5nKHRoaXMubW9kaWZpZWQsIHRoaXMubGVuZ3RoQmVmb3JlLCBsZW5ndGhBZnRlciksXG4gICAgICAgICAgICAgICAgbmV3IExlbmd0aE1hcHBpbmcodGhpcy5tb2RpZmllZCwgbGVuZ3RoWmVybywgcmVtYWluaW5nTGVuZ3RoQWZ0ZXIpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBuZXcgTGVuZ3RoTWFwcGluZyh0aGlzLm1vZGlmaWVkLCBsZW5ndGhBZnRlciwgbGVuZ3RoQWZ0ZXIpLFxuICAgICAgICAgICAgICAgIG5ldyBMZW5ndGhNYXBwaW5nKHRoaXMubW9kaWZpZWQsIHJlbWFpbmluZ0xlbmd0aEFmdGVyLCByZW1haW5pbmdMZW5ndGhBZnRlcilcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm1vZGlmaWVkID8gJ00nIDogJ1UnfToke2xlbmd0aFRvT2JqKHRoaXMubGVuZ3RoQmVmb3JlKX0gLT4gJHtsZW5ndGhUb09iaih0aGlzLmxlbmd0aEFmdGVyKX1gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvTGVuZ3RoTWFwcGluZyh0ZXh0RWRpdEluZm9zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGxhc3RPZmZzZXQgPSBsZW5ndGhaZXJvO1xuICAgIGZvciAoY29uc3QgdGV4dEVkaXRJbmZvIG9mIHRleHRFZGl0SW5mb3MpIHtcbiAgICAgICAgY29uc3Qgc3BhY2VMZW5ndGggPSBsZW5ndGhEaWZmTm9uTmVnYXRpdmUobGFzdE9mZnNldCwgdGV4dEVkaXRJbmZvLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgaWYgKCFsZW5ndGhJc1plcm8oc3BhY2VMZW5ndGgpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgTGVuZ3RoTWFwcGluZyhmYWxzZSwgc3BhY2VMZW5ndGgsIHNwYWNlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoQmVmb3JlID0gbGVuZ3RoRGlmZk5vbk5lZ2F0aXZlKHRleHRFZGl0SW5mby5zdGFydE9mZnNldCwgdGV4dEVkaXRJbmZvLmVuZE9mZnNldCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMZW5ndGhNYXBwaW5nKHRydWUsIGxlbmd0aEJlZm9yZSwgdGV4dEVkaXRJbmZvLm5ld0xlbmd0aCkpO1xuICAgICAgICBsYXN0T2Zmc2V0ID0gdGV4dEVkaXRJbmZvLmVuZE9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgTGlzdEFzdE5vZGUgfSBmcm9tICcuL2FzdC5qcyc7XG4vKipcbiAqIENvbmNhdGVuYXRlcyBhIGxpc3Qgb2YgKDIsMykgQXN0Tm9kZSdzIGludG8gYSBzaW5nbGUgKDIsMykgQXN0Tm9kZS5cbiAqIFRoaXMgbXV0YXRlcyB0aGUgaXRlbXMgb2YgdGhlIGlucHV0IGFycmF5IVxuICogSWYgYWxsIGl0ZW1zIGhhdmUgdGhlIHNhbWUgaGVpZ2h0LCB0aGlzIG1ldGhvZCBoYXMgcnVudGltZSBPKGl0ZW1zLmxlbmd0aCkuXG4gKiBPdGhlcndpc2UsIGl0IGhhcyBydW50aW1lIE8oaXRlbXMubGVuZ3RoICogbWF4KGxvZyhpdGVtcy5sZW5ndGgpLCBpdGVtcy5tYXgoaSA9PiBpLmhlaWdodCkpKS5cbiovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0MjNUcmVlcyhpdGVtcykge1xuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zWzBdO1xuICAgIH1cbiAgICBsZXQgaSA9IDA7XG4gICAgLyoqXG4gICAgICogUmVhZHMgbm9kZXMgb2Ygc2FtZSBoZWlnaHQgYW5kIGNvbmNhdGVuYXRlcyB0aGVtIHRvIGEgc2luZ2xlIG5vZGUuXG4gICAgKi9cbiAgICBmdW5jdGlvbiByZWFkTm9kZSgpIHtcbiAgICAgICAgaWYgKGkgPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydCA9IGk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGl0ZW1zW3N0YXJ0XS5saXN0SGVpZ2h0O1xuICAgICAgICBpKys7XG4gICAgICAgIHdoaWxlIChpIDwgaXRlbXMubGVuZ3RoICYmIGl0ZW1zW2ldLmxpc3RIZWlnaHQgPT09IGhlaWdodCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIC0gc3RhcnQgPj0gMikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdDIzVHJlZXNPZlNhbWVIZWlnaHQoc3RhcnQgPT09IDAgJiYgaSA9PT0gaXRlbXMubGVuZ3RoID8gaXRlbXMgOiBpdGVtcy5zbGljZShzdGFydCwgaSksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtc1tzdGFydF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlIGl0ZW1zIG1pZ2h0IG5vdCBoYXZlIHRoZSBzYW1lIGhlaWdodC5cbiAgICAvLyBXZSBtZXJnZSBhbGwgaXRlbXMgYnkgdXNpbmcgYSBiaW5hcnkgY29uY2F0IG9wZXJhdG9yLlxuICAgIGxldCBmaXJzdCA9IHJlYWROb2RlKCk7IC8vIFRoZXJlIG11c3QgYmUgYSBmaXJzdCBpdGVtXG4gICAgbGV0IHNlY29uZCA9IHJlYWROb2RlKCk7XG4gICAgaWYgKCFzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICBmb3IgKGxldCBpdGVtID0gcmVhZE5vZGUoKTsgaXRlbTsgaXRlbSA9IHJlYWROb2RlKCkpIHtcbiAgICAgICAgLy8gUHJlZmVyIGNvbmNhdGVuYXRpbmcgc21hbGxlciB0cmVlcywgYXMgdGhlIHJ1bnRpbWUgb2YgY29uY2F0IGRlcGVuZHMgb24gdGhlIHRyZWUgaGVpZ2h0LlxuICAgICAgICBpZiAoaGVpZ2h0RGlmZihmaXJzdCwgc2Vjb25kKSA8PSBoZWlnaHREaWZmKHNlY29uZCwgaXRlbSkpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gY29uY2F0KGZpcnN0LCBzZWNvbmQpO1xuICAgICAgICAgICAgc2Vjb25kID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlY29uZCA9IGNvbmNhdChzZWNvbmQsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGNvbmNhdChmaXJzdCwgc2Vjb25kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdDIzVHJlZXNPZlNhbWVIZWlnaHQoaXRlbXMsIGNyZWF0ZUltbXV0YWJsZUxpc3RzID0gZmFsc2UpIHtcbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBpdGVtc1swXTtcbiAgICB9XG4gICAgbGV0IGxlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcbiAgICAvLyBBbGwgdHJlZXMgaGF2ZSBzYW1lIGhlaWdodCwganVzdCBjcmVhdGUgcGFyZW50IG5vZGVzLlxuICAgIHdoaWxlIChsZW5ndGggPiAzKSB7XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGxlbmd0aCA+PiAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBqID0gaSA8PCAxO1xuICAgICAgICAgICAgaXRlbXNbaV0gPSBMaXN0QXN0Tm9kZS5jcmVhdGUyMyhpdGVtc1tqXSwgaXRlbXNbaiArIDFdLCBqICsgMyA9PT0gbGVuZ3RoID8gaXRlbXNbaiArIDJdIDogbnVsbCwgY3JlYXRlSW1tdXRhYmxlTGlzdHMpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IG5ld0xlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIExpc3RBc3ROb2RlLmNyZWF0ZTIzKGl0ZW1zWzBdLCBpdGVtc1sxXSwgbGVuZ3RoID49IDMgPyBpdGVtc1syXSA6IG51bGwsIGNyZWF0ZUltbXV0YWJsZUxpc3RzKTtcbn1cbmZ1bmN0aW9uIGhlaWdodERpZmYobm9kZTEsIG5vZGUyKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKG5vZGUxLmxpc3RIZWlnaHQgLSBub2RlMi5saXN0SGVpZ2h0KTtcbn1cbmZ1bmN0aW9uIGNvbmNhdChub2RlMSwgbm9kZTIpIHtcbiAgICBpZiAobm9kZTEubGlzdEhlaWdodCA9PT0gbm9kZTIubGlzdEhlaWdodCkge1xuICAgICAgICByZXR1cm4gTGlzdEFzdE5vZGUuY3JlYXRlMjMobm9kZTEsIG5vZGUyLCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUxLmxpc3RIZWlnaHQgPiBub2RlMi5saXN0SGVpZ2h0KSB7XG4gICAgICAgIC8vIG5vZGUxIGlzIHRoZSB0cmVlIHdlIHdhbnQgdG8gaW5zZXJ0IGludG9cbiAgICAgICAgcmV0dXJuIGFwcGVuZChub2RlMSwgbm9kZTIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByZXBlbmQobm9kZTIsIG5vZGUxKTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGVuZHMgdGhlIGdpdmVuIG5vZGUgdG8gdGhlIGVuZCBvZiB0aGlzICgyLDMpIHRyZWUuXG4gKiBSZXR1cm5zIHRoZSBuZXcgcm9vdC5cbiovXG5mdW5jdGlvbiBhcHBlbmQobGlzdCwgbm9kZVRvQXBwZW5kKSB7XG4gICAgbGlzdCA9IGxpc3QudG9NdXRhYmxlKCk7XG4gICAgbGV0IGN1ck5vZGUgPSBsaXN0O1xuICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICBsZXQgbm9kZVRvQXBwZW5kT2ZDb3JyZWN0SGVpZ2h0O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIC8vIGFzc2VydCBub2RlVG9JbnNlcnQubGlzdEhlaWdodCA8PSBjdXJOb2RlLmxpc3RIZWlnaHRcbiAgICAgICAgaWYgKG5vZGVUb0FwcGVuZC5saXN0SGVpZ2h0ID09PSBjdXJOb2RlLmxpc3RIZWlnaHQpIHtcbiAgICAgICAgICAgIG5vZGVUb0FwcGVuZE9mQ29ycmVjdEhlaWdodCA9IG5vZGVUb0FwcGVuZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc2VydCAwIDw9IG5vZGVUb0luc2VydC5saXN0SGVpZ2h0IDwgY3VyTm9kZS5saXN0SGVpZ2h0XG4gICAgICAgIGlmIChjdXJOb2RlLmtpbmQgIT09IDQgLyogQXN0Tm9kZUtpbmQuTGlzdCAqLykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50cy5wdXNoKGN1ck5vZGUpO1xuICAgICAgICAvLyBhc3NlcnQgMiA8PSBjdXJOb2RlLmNoaWxkcmVuTGVuZ3RoIDw9IDNcbiAgICAgICAgY3VyTm9kZSA9IGN1ck5vZGUubWFrZUxhc3RFbGVtZW50TXV0YWJsZSgpO1xuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZVRvQXBwZW5kT2ZDb3JyZWN0SGVpZ2h0IS5saXN0SGVpZ2h0ID09PSBjdXJOb2RlLmxpc3RIZWlnaHRcbiAgICBmb3IgKGxldCBpID0gcGFyZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICBpZiAobm9kZVRvQXBwZW5kT2ZDb3JyZWN0SGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBDYW4gd2UgdGFrZSB0aGUgZWxlbWVudD9cbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW5MZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgIC8vIGFzc2VydCBwYXJlbnQuY2hpbGRyZW5MZW5ndGggPT09IDMgJiYgcGFyZW50Lmxpc3RIZWlnaHQgPT09IG5vZGVUb0FwcGVuZE9mQ29ycmVjdEhlaWdodC5saXN0SGVpZ2h0ICsgMVxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc3BsaXQgdG8gbWFpbnRhaW4gKDIsMyktdHJlZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSB0aGlyZCBlbGVtZW50ICsgdGhlIG5ldyBlbGVtZW50IHRvIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICAgICAgbm9kZVRvQXBwZW5kT2ZDb3JyZWN0SGVpZ2h0ID0gTGlzdEFzdE5vZGUuY3JlYXRlMjMocGFyZW50LnVuYXBwZW5kQ2hpbGQoKSwgbm9kZVRvQXBwZW5kT2ZDb3JyZWN0SGVpZ2h0LCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGRPZlNhbWVIZWlnaHQobm9kZVRvQXBwZW5kT2ZDb3JyZWN0SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBub2RlVG9BcHBlbmRPZkNvcnJlY3RIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQuaGFuZGxlQ2hpbGRyZW5DaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGVUb0FwcGVuZE9mQ29ycmVjdEhlaWdodCkge1xuICAgICAgICByZXR1cm4gTGlzdEFzdE5vZGUuY3JlYXRlMjMobGlzdCwgbm9kZVRvQXBwZW5kT2ZDb3JyZWN0SGVpZ2h0LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG59XG4vKipcbiAqIFByZXBlbmRzIHRoZSBnaXZlbiBub2RlIHRvIHRoZSBlbmQgb2YgdGhpcyAoMiwzKSB0cmVlLlxuICogUmV0dXJucyB0aGUgbmV3IHJvb3QuXG4qL1xuZnVuY3Rpb24gcHJlcGVuZChsaXN0LCBub2RlVG9BcHBlbmQpIHtcbiAgICBsaXN0ID0gbGlzdC50b011dGFibGUoKTtcbiAgICBsZXQgY3VyTm9kZSA9IGxpc3Q7XG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgIC8vIGFzc2VydCBub2RlVG9JbnNlcnQubGlzdEhlaWdodCA8PSBjdXJOb2RlLmxpc3RIZWlnaHRcbiAgICB3aGlsZSAobm9kZVRvQXBwZW5kLmxpc3RIZWlnaHQgIT09IGN1ck5vZGUubGlzdEhlaWdodCkge1xuICAgICAgICAvLyBhc3NlcnQgMCA8PSBub2RlVG9JbnNlcnQubGlzdEhlaWdodCA8IGN1ck5vZGUubGlzdEhlaWdodFxuICAgICAgICBpZiAoY3VyTm9kZS5raW5kICE9PSA0IC8qIEFzdE5vZGVLaW5kLkxpc3QgKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudHMucHVzaChjdXJOb2RlKTtcbiAgICAgICAgLy8gYXNzZXJ0IDIgPD0gY3VyTm9kZS5jaGlsZHJlbkZhc3QubGVuZ3RoIDw9IDNcbiAgICAgICAgY3VyTm9kZSA9IGN1ck5vZGUubWFrZUZpcnN0RWxlbWVudE11dGFibGUoKTtcbiAgICB9XG4gICAgbGV0IG5vZGVUb1ByZXBlbmRPZkNvcnJlY3RIZWlnaHQgPSBub2RlVG9BcHBlbmQ7XG4gICAgLy8gYXNzZXJ0IG5vZGVUb0FwcGVuZE9mQ29ycmVjdEhlaWdodCEubGlzdEhlaWdodCA9PT0gY3VyTm9kZS5saXN0SGVpZ2h0XG4gICAgZm9yIChsZXQgaSA9IHBhcmVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gcGFyZW50c1tpXTtcbiAgICAgICAgaWYgKG5vZGVUb1ByZXBlbmRPZkNvcnJlY3RIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIENhbiB3ZSB0YWtlIHRoZSBlbGVtZW50P1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZHJlbkxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0IHBhcmVudC5jaGlsZHJlbkxlbmd0aCA9PT0gMyAmJiBwYXJlbnQubGlzdEhlaWdodCA9PT0gbm9kZVRvQXBwZW5kT2ZDb3JyZWN0SGVpZ2h0Lmxpc3RIZWlnaHQgKyAxXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBzcGxpdCB0byBtYWludGFpbiAoMiwzKS10cmVlIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIHRoaXJkIGVsZW1lbnQgKyB0aGUgbmV3IGVsZW1lbnQgdG8gdGhlIHBhcmVudC5cbiAgICAgICAgICAgICAgICBub2RlVG9QcmVwZW5kT2ZDb3JyZWN0SGVpZ2h0ID0gTGlzdEFzdE5vZGUuY3JlYXRlMjMobm9kZVRvUHJlcGVuZE9mQ29ycmVjdEhlaWdodCwgcGFyZW50LnVucHJlcGVuZENoaWxkKCksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC5wcmVwZW5kQ2hpbGRPZlNhbWVIZWlnaHQobm9kZVRvUHJlcGVuZE9mQ29ycmVjdEhlaWdodCk7XG4gICAgICAgICAgICAgICAgbm9kZVRvUHJlcGVuZE9mQ29ycmVjdEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5oYW5kbGVDaGlsZHJlbkNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZVRvUHJlcGVuZE9mQ29ycmVjdEhlaWdodCkge1xuICAgICAgICByZXR1cm4gTGlzdEFzdE5vZGUuY3JlYXRlMjMobm9kZVRvUHJlcGVuZE9mQ29ycmVjdEhlaWdodCwgbGlzdCwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBzcGxpdExpbmVzIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uLy4uLy4uL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgVGV4dExlbmd0aCB9IGZyb20gJy4uLy4uLy4uL2NvcmUvdGV4dExlbmd0aC5qcyc7XG4vKipcbiAqIFRoZSBlbmQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHN0YXJ0LlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhEaWZmKHN0YXJ0TGluZUNvdW50LCBzdGFydENvbHVtbkNvdW50LCBlbmRMaW5lQ291bnQsIGVuZENvbHVtbkNvdW50KSB7XG4gICAgcmV0dXJuIChzdGFydExpbmVDb3VudCAhPT0gZW5kTGluZUNvdW50KVxuICAgICAgICA/IHRvTGVuZ3RoKGVuZExpbmVDb3VudCAtIHN0YXJ0TGluZUNvdW50LCBlbmRDb2x1bW5Db3VudClcbiAgICAgICAgOiB0b0xlbmd0aCgwLCBlbmRDb2x1bW5Db3VudCAtIHN0YXJ0Q29sdW1uQ291bnQpO1xufVxuZXhwb3J0IGNvbnN0IGxlbmd0aFplcm8gPSAwO1xuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aElzWmVybyhsZW5ndGgpIHtcbiAgICByZXR1cm4gbGVuZ3RoID09PSAwO1xufVxuLypcbiAqIFdlIGhhdmUgNTIgYml0cyBhdmFpbGFibGUgaW4gYSBKUyBudW1iZXIuXG4gKiBXZSB1c2UgdGhlIHVwcGVyIDI2IGJpdHMgdG8gc3RvcmUgdGhlIGxpbmUgYW5kIHRoZSBsb3dlciAyNiBiaXRzIHRvIHN0b3JlIHRoZSBjb2x1bW4uXG4gKi9cbi8vLypcbmNvbnN0IGZhY3RvciA9IDIgKiogMjY7XG4vKi9cbmNvbnN0IGZhY3RvciA9IDEwMDAwMDA7XG4vLyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTGVuZ3RoKGxpbmVDb3VudCwgY29sdW1uQ291bnQpIHtcbiAgICAvLyBsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjICg1MiBiaXRzKVxuICAgIC8vICAgICAgIGxpbmUgY291bnQgKDI2IGJpdHMpICAgIGNvbHVtbiBjb3VudCAoMjYgYml0cylcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBvdmVyZmxvdyAoYWxsIHZhbHVlcy9zdW1zIGJlbG93IDJeMjYgPSA2NzEwODg2NCksXG4gICAgLy8gd2UgaGF2ZSBgdG9MZW5ndGgobG5zMSwgY29sczEpICsgdG9MZW5ndGgobG5zMiwgY29sczIpID0gdG9MZW5ndGgobG5zMSArIGxuczIsIGNvbHMxICsgY29sczIpYC5cbiAgICByZXR1cm4gKGxpbmVDb3VudCAqIGZhY3RvciArIGNvbHVtbkNvdW50KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhUb09iaihsZW5ndGgpIHtcbiAgICBjb25zdCBsID0gbGVuZ3RoO1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IE1hdGguZmxvb3IobCAvIGZhY3Rvcik7XG4gICAgY29uc3QgY29sdW1uQ291bnQgPSBsIC0gbGluZUNvdW50ICogZmFjdG9yO1xuICAgIHJldHVybiBuZXcgVGV4dExlbmd0aChsaW5lQ291bnQsIGNvbHVtbkNvdW50KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhHZXRMaW5lQ291bnQobGVuZ3RoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobGVuZ3RoIC8gZmFjdG9yKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgYW1vdW50IG9mIGNvbHVtbnMgb2YgdGhlIGdpdmVuIGxlbmd0aCwgYXNzdW1pbmcgdGhhdCBpdCBkb2VzIG5vdCBzcGFuIGFueSBsaW5lLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhHZXRDb2x1bW5Db3VudElmWmVyb0xpbmVDb3VudChsZW5ndGgpIHtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aEFkZChsMSwgbDIpIHtcbiAgICBsZXQgciA9IGwxICsgbDI7XG4gICAgaWYgKGwyID49IGZhY3Rvcikge1xuICAgICAgICByID0gciAtIChsMSAlIGZhY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN1bUxlbmd0aHMoaXRlbXMsIGxlbmd0aEZuKSB7XG4gICAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgoYSwgYikgPT4gbGVuZ3RoQWRkKGEsIGxlbmd0aEZuKGIpKSwgbGVuZ3RoWmVybyk7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoRXF1YWxzKGxlbmd0aDEsIGxlbmd0aDIpIHtcbiAgICByZXR1cm4gbGVuZ3RoMSA9PT0gbGVuZ3RoMjtcbn1cbi8qKlxuICogUmV0dXJucyBhIG5vbiBuZWdhdGl2ZSBsZW5ndGggYHJlc3VsdGAgc3VjaCB0aGF0IGBsZW5ndGhBZGQobGVuZ3RoMSwgcmVzdWx0KSA9IGxlbmd0aDJgLCBvciB6ZXJvIGlmIHN1Y2ggbGVuZ3RoIGRvZXMgbm90IGV4aXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoRGlmZk5vbk5lZ2F0aXZlKGxlbmd0aDEsIGxlbmd0aDIpIHtcbiAgICBjb25zdCBsMSA9IGxlbmd0aDE7XG4gICAgY29uc3QgbDIgPSBsZW5ndGgyO1xuICAgIGNvbnN0IGRpZmYgPSBsMiAtIGwxO1xuICAgIGlmIChkaWZmIDw9IDApIHtcbiAgICAgICAgLy8gbGluZS1jb3VudCBvZiBsZW5ndGgxIGlzIGhpZ2hlciB0aGFuIGxpbmUtY291bnQgb2YgbGVuZ3RoMlxuICAgICAgICAvLyBvciB0aGV5IGFyZSBlcXVhbCBhbmQgY29sdW1uLWNvdW50IG9mIGxlbmd0aDEgaXMgaGlnaGVyIHRoYW4gY29sdW1uLWNvdW50IG9mIGxlbmd0aDJcbiAgICAgICAgcmV0dXJuIGxlbmd0aFplcm87XG4gICAgfVxuICAgIGNvbnN0IGxpbmVDb3VudDEgPSBNYXRoLmZsb29yKGwxIC8gZmFjdG9yKTtcbiAgICBjb25zdCBsaW5lQ291bnQyID0gTWF0aC5mbG9vcihsMiAvIGZhY3Rvcik7XG4gICAgY29uc3QgY29sQ291bnQyID0gbDIgLSBsaW5lQ291bnQyICogZmFjdG9yO1xuICAgIGlmIChsaW5lQ291bnQxID09PSBsaW5lQ291bnQyKSB7XG4gICAgICAgIGNvbnN0IGNvbENvdW50MSA9IGwxIC0gbGluZUNvdW50MSAqIGZhY3RvcjtcbiAgICAgICAgcmV0dXJuIHRvTGVuZ3RoKDAsIGNvbENvdW50MiAtIGNvbENvdW50MSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9MZW5ndGgobGluZUNvdW50MiAtIGxpbmVDb3VudDEsIGNvbENvdW50Mik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aExlc3NUaGFuKGxlbmd0aDEsIGxlbmd0aDIpIHtcbiAgICAvLyBGaXJzdCwgY29tcGFyZSBsaW5lIGNvdW50cywgdGhlbiBjb2x1bW4gY291bnRzLlxuICAgIHJldHVybiBsZW5ndGgxIDwgbGVuZ3RoMjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhMZXNzVGhhbkVxdWFsKGxlbmd0aDEsIGxlbmd0aDIpIHtcbiAgICByZXR1cm4gbGVuZ3RoMSA8PSBsZW5ndGgyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aEdyZWF0ZXJUaGFuRXF1YWwobGVuZ3RoMSwgbGVuZ3RoMikge1xuICAgIHJldHVybiBsZW5ndGgxID49IGxlbmd0aDI7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zaXRpb25Ub0xlbmd0aChwb3NpdGlvbikge1xuICAgIHJldHVybiB0b0xlbmd0aChwb3NpdGlvbi5saW5lTnVtYmVyIC0gMSwgcG9zaXRpb24uY29sdW1uIC0gMSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVuZ3Roc1RvUmFuZ2UobGVuZ3RoU3RhcnQsIGxlbmd0aEVuZCkge1xuICAgIGNvbnN0IGwgPSBsZW5ndGhTdGFydDtcbiAgICBjb25zdCBsaW5lQ291bnQgPSBNYXRoLmZsb29yKGwgLyBmYWN0b3IpO1xuICAgIGNvbnN0IGNvbENvdW50ID0gbCAtIGxpbmVDb3VudCAqIGZhY3RvcjtcbiAgICBjb25zdCBsMiA9IGxlbmd0aEVuZDtcbiAgICBjb25zdCBsaW5lQ291bnQyID0gTWF0aC5mbG9vcihsMiAvIGZhY3Rvcik7XG4gICAgY29uc3QgY29sQ291bnQyID0gbDIgLSBsaW5lQ291bnQyICogZmFjdG9yO1xuICAgIHJldHVybiBuZXcgUmFuZ2UobGluZUNvdW50ICsgMSwgY29sQ291bnQgKyAxLCBsaW5lQ291bnQyICsgMSwgY29sQ291bnQyICsgMSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoT2ZTdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgbGluZXMgPSBzcGxpdExpbmVzKHN0cik7XG4gICAgcmV0dXJuIHRvTGVuZ3RoKGxpbmVzLmxlbmd0aCAtIDEsIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGxlbmd0aEFkZCwgbGVuZ3RoWmVybywgbGVuZ3RoTGVzc1RoYW4gfSBmcm9tICcuL2xlbmd0aC5qcyc7XG4vKipcbiAqIEFsbG93cyB0byBlZmZpY2llbnRseSBmaW5kIGEgbG9uZ2VzdCBjaGlsZCBhdCBhIGdpdmVuIG9mZnNldCBpbiBhIGZpeGVkIG5vZGUuXG4gKiBUaGUgcmVxdWVzdGVkIG9mZnNldHMgbXVzdCBpbmNyZWFzZSBtb25vdG9ub3VzbHkuXG4qL1xuZXhwb3J0IGNsYXNzIE5vZGVSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICAgICAgdGhpcy5sYXN0T2Zmc2V0ID0gbGVuZ3RoWmVybztcbiAgICAgICAgdGhpcy5uZXh0Tm9kZXMgPSBbbm9kZV07XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IFtsZW5ndGhaZXJvXTtcbiAgICAgICAgdGhpcy5pZHhzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvbmdlc3Qgbm9kZSBhdCBgb2Zmc2V0YCB0aGF0IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxhc3Qgb2Zmc2V0IHRoaXMgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZCB3aXRoIVxuICAgICovXG4gICAgcmVhZExvbmdlc3ROb2RlQXQob2Zmc2V0LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgaWYgKGxlbmd0aExlc3NUaGFuKG9mZnNldCwgdGhpcy5sYXN0T2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9mZnNldCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgLy8gRmluZCB0aGUgbG9uZ2VzdCBub2RlIG9mIGFsbCB0aG9zZSB0aGF0IGFyZSBjbG9zZXN0IHRvIHRoZSBjdXJyZW50IG9mZnNldC5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1ck5vZGUgPSBsYXN0T3JVbmRlZmluZWQodGhpcy5uZXh0Tm9kZXMpO1xuICAgICAgICAgICAgaWYgKCFjdXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1ck5vZGVPZmZzZXQgPSBsYXN0T3JVbmRlZmluZWQodGhpcy5vZmZzZXRzKTtcbiAgICAgICAgICAgIGlmIChsZW5ndGhMZXNzVGhhbihvZmZzZXQsIGN1ck5vZGVPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG5leHQgYmVzdCBub2RlIGlzIG5vdCBoZXJlIHlldC5cbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVhZGVyIG11c3QgYWR2YW5jZSBiZWZvcmUgYSBjYWNoZWQgbm9kZSBpcyBoaXQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGhMZXNzVGhhbihjdXJOb2RlT2Zmc2V0LCBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlYWRlciBpcyBhaGVhZCBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhBZGQoY3VyTm9kZU9mZnNldCwgY3VyTm9kZS5sZW5ndGgpIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVhZGVyIGlzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0Tm9kZUFmdGVyQ3VycmVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlYWRlciBpcyBzb21ld2hlcmUgaW4gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkSWR4ID0gZ2V0TmV4dENoaWxkSWR4KGN1ck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkSWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR28gdG8gdGhlIGZpcnN0IGNoaWxkIGFuZCByZXBlYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHROb2Rlcy5wdXNoKGN1ck5vZGUuZ2V0Q2hpbGQobmV4dENoaWxkSWR4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucHVzaChjdXJOb2RlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaWR4cy5wdXNoKG5leHRDaGlsZElkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHROb2RlQWZ0ZXJDdXJyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZWFkZXJPZmZzZXRCZWZvcmVDaGFuZ2UgPT09IGN1ck5vZGVPZmZzZXRcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKGN1ck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dE5vZGVBZnRlckN1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1ck5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGRJZHggPSBnZXROZXh0Q2hpbGRJZHgoY3VyTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb2sgZm9yIHNob3J0ZXIgbm9kZVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkSWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gc2hvcnRlciBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0Tm9kZUFmdGVyQ3VycmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgaW50byBmaXJzdCBjaGlsZCAmIHJlcGVhdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dE5vZGVzLnB1c2goY3VyTm9kZS5nZXRDaGlsZChuZXh0Q2hpbGRJZHgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wdXNoKGN1ck5vZGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pZHhzLnB1c2gobmV4dENoaWxkSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOYXZpZ2F0ZXMgdG8gdGhlIGxvbmdlc3Qgbm9kZSB0aGF0IGNvbnRpbnVlcyBhZnRlciB0aGUgY3VycmVudCBub2RlLlxuICAgIG5leHROb2RlQWZ0ZXJDdXJyZW50KCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE9mZnNldCA9IGxhc3RPclVuZGVmaW5lZCh0aGlzLm9mZnNldHMpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBsYXN0T3JVbmRlZmluZWQodGhpcy5uZXh0Tm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5uZXh0Tm9kZXMucG9wKCk7XG4gICAgICAgICAgICB0aGlzLm9mZnNldHMucG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGp1c3QgcG9wcGVkIHRoZSByb290IG5vZGUsIHRoZXJlIGlzIG5vIG5leHQgbm9kZS5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcmVudCBpcyBub3QgdW5kZWZpbmVkLCBiZWNhdXNlIGlkeHMgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBsYXN0T3JVbmRlZmluZWQodGhpcy5uZXh0Tm9kZXMpO1xuICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkSWR4ID0gZ2V0TmV4dENoaWxkSWR4KHBhcmVudCwgdGhpcy5pZHhzW3RoaXMuaWR4cy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICBpZiAobmV4dENoaWxkSWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dE5vZGVzLnB1c2gocGFyZW50LmdldENoaWxkKG5leHRDaGlsZElkeCkpO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wdXNoKGxlbmd0aEFkZChjdXJyZW50T2Zmc2V0LCBjdXJyZW50Tm9kZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeHNbdGhpcy5pZHhzLmxlbmd0aCAtIDFdID0gbmV4dENoaWxkSWR4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHhzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgZnVsbHkgY29uc3VtZWQgdGhlIHBhcmVudC5cbiAgICAgICAgICAgIC8vIEN1cnJlbnQgbm9kZSBpcyBub3cgcGFyZW50LCBzbyBjYWxsIG5leHROb2RlQWZ0ZXJDdXJyZW50IGFnYWluXG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXROZXh0Q2hpbGRJZHgobm9kZSwgY3VySWR4ID0gLTEpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjdXJJZHgrKztcbiAgICAgICAgaWYgKGN1cklkeCA+PSBub2RlLmNoaWxkcmVuTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZ2V0Q2hpbGQoY3VySWR4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cklkeDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGxhc3RPclVuZGVmaW5lZChhcnIpIHtcbiAgICByZXR1cm4gYXJyLmxlbmd0aCA+IDAgPyBhcnJbYXJyLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBJbnZhbGlkQnJhY2tldEFzdE5vZGUsIExpc3RBc3ROb2RlLCBQYWlyQXN0Tm9kZSwgVGV4dEFzdE5vZGUgfSBmcm9tICcuL2FzdC5qcyc7XG5pbXBvcnQgeyBCZWZvcmVFZGl0UG9zaXRpb25NYXBwZXIgfSBmcm9tICcuL2JlZm9yZUVkaXRQb3NpdGlvbk1hcHBlci5qcyc7XG5pbXBvcnQgeyBTbWFsbEltbXV0YWJsZVNldCB9IGZyb20gJy4vc21hbGxJbW11dGFibGVTZXQuanMnO1xuaW1wb3J0IHsgbGVuZ3RoSXNaZXJvLCBsZW5ndGhMZXNzVGhhbiB9IGZyb20gJy4vbGVuZ3RoLmpzJztcbmltcG9ydCB7IGNvbmNhdDIzVHJlZXMsIGNvbmNhdDIzVHJlZXNPZlNhbWVIZWlnaHQgfSBmcm9tICcuL2NvbmNhdDIzVHJlZXMuanMnO1xuaW1wb3J0IHsgTm9kZVJlYWRlciB9IGZyb20gJy4vbm9kZVJlYWRlci5qcyc7XG4vKipcbiAqIE5vbiBpbmNyZW1lbnRhbGx5IGJ1aWx0IEFTVHMgYXJlIGltbXV0YWJsZS5cbiovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEb2N1bWVudCh0b2tlbml6ZXIsIGVkaXRzLCBvbGROb2RlLCBjcmVhdGVJbW11dGFibGVMaXN0cykge1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIodG9rZW5pemVyLCBlZGl0cywgb2xkTm9kZSwgY3JlYXRlSW1tdXRhYmxlTGlzdHMpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2VEb2N1bWVudCgpO1xufVxuLyoqXG4gKiBOb24gaW5jcmVtZW50YWxseSBidWlsdCBBU1RzIGFyZSBpbW11dGFibGUuXG4qL1xuY2xhc3MgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbml6ZXIsIGVkaXRzLCBvbGROb2RlLCBjcmVhdGVJbW11dGFibGVMaXN0cykge1xuICAgICAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICAgICAgdGhpcy5jcmVhdGVJbW11dGFibGVMaXN0cyA9IGNyZWF0ZUltbXV0YWJsZUxpc3RzO1xuICAgICAgICB0aGlzLl9pdGVtc0NvbnN0cnVjdGVkID0gMDtcbiAgICAgICAgdGhpcy5faXRlbXNGcm9tQ2FjaGUgPSAwO1xuICAgICAgICBpZiAob2xkTm9kZSAmJiBjcmVhdGVJbW11dGFibGVMaXN0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbGROb2RlUmVhZGVyID0gb2xkTm9kZSA/IG5ldyBOb2RlUmVhZGVyKG9sZE5vZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBvc2l0aW9uTWFwcGVyID0gbmV3IEJlZm9yZUVkaXRQb3NpdGlvbk1hcHBlcihlZGl0cyk7XG4gICAgfVxuICAgIHBhcnNlRG9jdW1lbnQoKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zQ29uc3RydWN0ZWQgPSAwO1xuICAgICAgICB0aGlzLl9pdGVtc0Zyb21DYWNoZSA9IDA7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlTGlzdChTbWFsbEltbXV0YWJsZVNldC5nZXRFbXB0eSgpLCAwKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IExpc3RBc3ROb2RlLmdldEVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VMaXN0KG9wZW5lZEJyYWNrZXRJZHMsIGxldmVsKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnRyeVJlYWRDaGlsZEZyb21DYWNoZShvcGVuZWRCcmFja2V0SWRzKTtcbiAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW5pemVyLnBlZWsoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuIHx8XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi5raW5kID09PSAyIC8qIFRva2VuS2luZC5DbG9zaW5nQnJhY2tldCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uYnJhY2tldElkcy5pbnRlcnNlY3RzKG9wZW5lZEJyYWNrZXRJZHMpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLnBhcnNlQ2hpbGQob3BlbmVkQnJhY2tldElkcywgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZC5raW5kID09PSA0IC8qIEFzdE5vZGVLaW5kLkxpc3QgKi8gJiYgY2hpbGQuY2hpbGRyZW5MZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1zLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gb2xkTm9kZVJlYWRlciwgYWxsIGl0ZW1zIGFyZSBjcmVhdGVkIGZyb20gc2NyYXRjaCBhbmQgbXVzdCBoYXZlIHRoZSBzYW1lIGhlaWdodC5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5vbGROb2RlUmVhZGVyID8gY29uY2F0MjNUcmVlcyhpdGVtcykgOiBjb25jYXQyM1RyZWVzT2ZTYW1lSGVpZ2h0KGl0ZW1zLCB0aGlzLmNyZWF0ZUltbXV0YWJsZUxpc3RzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5UmVhZENoaWxkRnJvbUNhY2hlKG9wZW5lZEJyYWNrZXRJZHMpIHtcbiAgICAgICAgaWYgKHRoaXMub2xkTm9kZVJlYWRlcikge1xuICAgICAgICAgICAgY29uc3QgbWF4Q2FjaGVhYmxlTGVuZ3RoID0gdGhpcy5wb3NpdGlvbk1hcHBlci5nZXREaXN0YW5jZVRvTmV4dENoYW5nZSh0aGlzLnRva2VuaXplci5vZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1heENhY2hlYWJsZUxlbmd0aCA9PT0gbnVsbCB8fCAhbGVuZ3RoSXNaZXJvKG1heENhY2hlYWJsZUxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWROb2RlID0gdGhpcy5vbGROb2RlUmVhZGVyLnJlYWRMb25nZXN0Tm9kZUF0KHRoaXMucG9zaXRpb25NYXBwZXIuZ2V0T2Zmc2V0QmVmb3JlQ2hhbmdlKHRoaXMudG9rZW5pemVyLm9mZnNldCksIGN1ck5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZWRpdCBjb3VsZCBleHRlbmQgdGhlIGVuZGluZyB0b2tlbiwgdGh1cyB3ZSBjYW5ub3QgcmUtdXNlIG5vZGVzIHRoYXQgdG91Y2ggdGhlIGVkaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGVkaXQgYW55bW9yZSwgd2UgY2FuIHJlLXVzZSB0aGUgbm9kZSBpbiBhbnkgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heENhY2hlYWJsZUxlbmd0aCAhPT0gbnVsbCAmJiAhbGVuZ3RoTGVzc1RoYW4oY3VyTm9kZS5sZW5ndGgsIG1heENhY2hlYWJsZUxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciB0aGUgbm9kZSBjb250YWlucyBlZGl0ZWQgdGV4dCBvciB0b3VjaGVzIGVkaXRlZCB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIGxhdHRlciBjYXNlLCBicmFja2V0cyBtaWdodCBoYXZlIGJlZW4gZXh0ZW5kZWQgKGBlbmRgIC0+IGBlbmRpbmdgKSwgc28gZXZlbiB0b3VjaGluZyBub2RlcyBjYW5ub3QgYmUgcmV1c2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbkJlUmV1c2VkID0gY3VyTm9kZS5jYW5CZVJldXNlZChvcGVuZWRCcmFja2V0SWRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbkJlUmV1c2VkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zRnJvbUNhY2hlKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLnNraXAoY2FjaGVkTm9kZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcGFyc2VDaGlsZChvcGVuZWRCcmFja2V0SWRzLCBsZXZlbCkge1xuICAgICAgICB0aGlzLl9pdGVtc0NvbnN0cnVjdGVkKys7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVhZCgpO1xuICAgICAgICBzd2l0Y2ggKHRva2VuLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBUb2tlbktpbmQuQ2xvc2luZ0JyYWNrZXQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkQnJhY2tldEFzdE5vZGUodG9rZW4uYnJhY2tldElkcywgdG9rZW4ubGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBUb2tlbktpbmQuVGV4dCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4uYXN0Tm9kZTtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBUb2tlbktpbmQuT3BlbmluZ0JyYWNrZXQgKi86IHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPiAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gcHJldmVudCBzdGFjayBvdmVyZmxvd3NcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0QXN0Tm9kZSh0b2tlbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBvcGVuZWRCcmFja2V0SWRzLm1lcmdlKHRva2VuLmJyYWNrZXRJZHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5wYXJzZUxpc3Qoc2V0LCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMudG9rZW5pemVyLnBlZWsoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFRva2VuICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbi5raW5kID09PSAyIC8qIFRva2VuS2luZC5DbG9zaW5nQnJhY2tldCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAobmV4dFRva2VuLmJyYWNrZXRJZCA9PT0gdG9rZW4uYnJhY2tldElkIHx8IG5leHRUb2tlbi5icmFja2V0SWRzLmludGVyc2VjdHModG9rZW4uYnJhY2tldElkcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhaXJBc3ROb2RlLmNyZWF0ZSh0b2tlbi5hc3ROb2RlLCBjaGlsZCwgbmV4dFRva2VuLmFzdE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhaXJBc3ROb2RlLmNyZWF0ZSh0b2tlbi5hc3ROb2RlLCBjaGlsZCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuY29uc3QgZW1wdHlBcnIgPSBbXTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbW11dGFibGUgc2V0IHRoYXQgd29ya3MgYmVzdCBmb3IgYSBzbWFsbCBudW1iZXIgb2YgZWxlbWVudHMgKGxlc3MgdGhhbiAzMikuXG4gKiBJdCB1c2VzIGJpdHMgdG8gZW5jb2RlIGVsZW1lbnQgbWVtYmVyc2hpcCBlZmZpY2llbnRseS5cbiovXG5leHBvcnQgY2xhc3MgU21hbGxJbW11dGFibGVTZXQge1xuICAgIHN0YXRpYyB7IHRoaXMuY2FjaGUgPSBuZXcgQXJyYXkoMTI5KTsgfVxuICAgIHN0YXRpYyBjcmVhdGUoaXRlbXMsIGFkZGl0aW9uYWxJdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMgPD0gMTI4ICYmIGFkZGl0aW9uYWxJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGNyZWF0ZSBhIGNhY2hlIG9mIDEyOD0yXjcgZWxlbWVudHMgdG8gY292ZXIgYWxsIHNldHMgd2l0aCB1cCB0byA3IChkZW5zZSkgZWxlbWVudHMuXG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gU21hbGxJbW11dGFibGVTZXQuY2FjaGVbaXRlbXNdO1xuICAgICAgICAgICAgaWYgKCFjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWQgPSBuZXcgU21hbGxJbW11dGFibGVTZXQoaXRlbXMsIGFkZGl0aW9uYWxJdGVtcyk7XG4gICAgICAgICAgICAgICAgU21hbGxJbW11dGFibGVTZXQuY2FjaGVbaXRlbXNdID0gY2FjaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW1tdXRhYmxlU2V0KGl0ZW1zLCBhZGRpdGlvbmFsSXRlbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLmVtcHR5ID0gU21hbGxJbW11dGFibGVTZXQuY3JlYXRlKDAsIGVtcHR5QXJyKTsgfVxuICAgIHN0YXRpYyBnZXRFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGl0ZW1zLCBhZGRpdGlvbmFsSXRlbXMpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxJdGVtcyA9IGFkZGl0aW9uYWxJdGVtcztcbiAgICB9XG4gICAgYWRkKHZhbHVlLCBrZXlQcm92aWRlcikge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlQcm92aWRlci5nZXRLZXkodmFsdWUpO1xuICAgICAgICBsZXQgaWR4ID0ga2V5ID4+IDU7IC8vIGRpdmlkZWQgYnkgMzJcbiAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gZmFzdCBwYXRoXG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gKDEgPDwga2V5KSB8IHRoaXMuaXRlbXM7XG4gICAgICAgICAgICBpZiAobmV3SXRlbSA9PT0gdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNtYWxsSW1tdXRhYmxlU2V0LmNyZWF0ZShuZXdJdGVtLCB0aGlzLmFkZGl0aW9uYWxJdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWR4LS07XG4gICAgICAgIGNvbnN0IG5ld0l0ZW1zID0gdGhpcy5hZGRpdGlvbmFsSXRlbXMuc2xpY2UoMCk7XG4gICAgICAgIHdoaWxlIChuZXdJdGVtcy5sZW5ndGggPCBpZHgpIHtcbiAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3SXRlbXNbaWR4XSB8PSAxIDw8IChrZXkgJiAzMSk7XG4gICAgICAgIHJldHVybiBTbWFsbEltbXV0YWJsZVNldC5jcmVhdGUodGhpcy5pdGVtcywgbmV3SXRlbXMpO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSB0aGlzLml0ZW1zIHwgb3RoZXIuaXRlbXM7XG4gICAgICAgIGlmICh0aGlzLmFkZGl0aW9uYWxJdGVtcyA9PT0gZW1wdHlBcnIgJiYgb3RoZXIuYWRkaXRpb25hbEl0ZW1zID09PSBlbXB0eUFycikge1xuICAgICAgICAgICAgLy8gZmFzdCBwYXRoXG4gICAgICAgICAgICBpZiAobWVyZ2VkID09PSB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyZ2VkID09PSBvdGhlci5pdGVtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTbWFsbEltbXV0YWJsZVNldC5jcmVhdGUobWVyZ2VkLCBlbXB0eUFycik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBjYW4gYmUgb3B0aW1pemVkLCBidXQgaXQncyBub3QgYSBjb21tb24gY2FzZVxuICAgICAgICBjb25zdCBuZXdJdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHRoaXMuYWRkaXRpb25hbEl0ZW1zLmxlbmd0aCwgb3RoZXIuYWRkaXRpb25hbEl0ZW1zLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbTEgPSB0aGlzLmFkZGl0aW9uYWxJdGVtc1tpXSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgaXRlbTIgPSBvdGhlci5hZGRpdGlvbmFsSXRlbXNbaV0gfHwgMDtcbiAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2goaXRlbTEgfCBpdGVtMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNtYWxsSW1tdXRhYmxlU2V0LmNyZWF0ZShtZXJnZWQsIG5ld0l0ZW1zKTtcbiAgICB9XG4gICAgaW50ZXJzZWN0cyhvdGhlcikge1xuICAgICAgICBpZiAoKHRoaXMuaXRlbXMgJiBvdGhlci5pdGVtcykgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4odGhpcy5hZGRpdGlvbmFsSXRlbXMubGVuZ3RoLCBvdGhlci5hZGRpdGlvbmFsSXRlbXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuYWRkaXRpb25hbEl0ZW1zW2ldICYgb3RoZXIuYWRkaXRpb25hbEl0ZW1zW2ldKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgaWRlbnRpdHlLZXlQcm92aWRlciA9IHtcbiAgICBnZXRLZXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG4vKipcbiAqIEFzc2lnbnMgdmFsdWVzIGEgdW5pcXVlIGluY3JlbWVudGluZyBrZXkuXG4qL1xuZXhwb3J0IGNsYXNzIERlbnNlS2V5UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLml0ZW1zID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXRLZXkodmFsdWUpIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0gdGhpcy5pdGVtcy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhpc3RpbmcgPSB0aGlzLml0ZW1zLnNpemU7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNldCh2YWx1ZSwgZXhpc3RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IE5vdFN1cHBvcnRlZEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vZXJyb3JzLmpzJztcbmltcG9ydCB7IFRva2VuTWV0YWRhdGEgfSBmcm9tICcuLi8uLi8uLi9lbmNvZGVkVG9rZW5BdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IFRleHRBc3ROb2RlIH0gZnJvbSAnLi9hc3QuanMnO1xuaW1wb3J0IHsgbGVuZ3RoQWRkLCBsZW5ndGhEaWZmLCBsZW5ndGhHZXRDb2x1bW5Db3VudElmWmVyb0xpbmVDb3VudCwgbGVuZ3RoVG9PYmosIGxlbmd0aFplcm8sIHRvTGVuZ3RoIH0gZnJvbSAnLi9sZW5ndGguanMnO1xuaW1wb3J0IHsgU21hbGxJbW11dGFibGVTZXQgfSBmcm9tICcuL3NtYWxsSW1tdXRhYmxlU2V0LmpzJztcbmV4cG9ydCBjbGFzcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBraW5kLCBcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIHRva2VuIGlzIGFuIG9wZW5pbmcgYnJhY2tldCwgdGhpcyBpcyB0aGUgaWQgb2YgdGhlIG9wZW5pbmcgYnJhY2tldC5cbiAgICAgKiBJZiB0aGlzIHRva2VuIGlzIGEgY2xvc2luZyBicmFja2V0LCB0aGlzIGlzIHRoZSBpZCBvZiB0aGUgZmlyc3Qgb3BlbmluZyBicmFja2V0IHRoYXQgaXMgY2xvc2VkIGJ5IHRoaXMgYnJhY2tldC5cbiAgICAgKiBPdGhlcndpc2UsIGl0IGlzIC0xLlxuICAgICAqL1xuICAgIGJyYWNrZXRJZCwgXG4gICAgLyoqXG4gICAgICogSWYgdGhpcyB0b2tlbiBpcyBhbiBvcGVuaW5nIGJyYWNrZXQsIHRoaXMganVzdCBjb250YWlucyBgYnJhY2tldElkYC5cbiAgICAgKiBJZiB0aGlzIHRva2VuIGlzIGEgY2xvc2luZyBicmFja2V0LCB0aGlzIGxpc3RzIGFsbCBvcGVuaW5nIGJyYWNrZXQgaWRzLCB0aGF0IGl0IGNsb3Nlcy5cbiAgICAgKiBPdGhlcndpc2UsIGl0IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGJyYWNrZXRJZHMsIGFzdE5vZGUpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgIHRoaXMuYnJhY2tldElkID0gYnJhY2tldElkO1xuICAgICAgICB0aGlzLmJyYWNrZXRJZHMgPSBicmFja2V0SWRzO1xuICAgICAgICB0aGlzLmFzdE5vZGUgPSBhc3ROb2RlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUZXh0QnVmZmVyVG9rZW5pemVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0TW9kZWwsIGJyYWNrZXRUb2tlbnMpIHtcbiAgICAgICAgdGhpcy50ZXh0TW9kZWwgPSB0ZXh0TW9kZWw7XG4gICAgICAgIHRoaXMuYnJhY2tldFRva2VucyA9IGJyYWNrZXRUb2tlbnM7XG4gICAgICAgIHRoaXMucmVhZGVyID0gbmV3IE5vblBlZWthYmxlVGV4dEJ1ZmZlclRva2VuaXplcih0aGlzLnRleHRNb2RlbCwgdGhpcy5icmFja2V0VG9rZW5zKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gbGVuZ3RoWmVybztcbiAgICAgICAgdGhpcy5kaWRQZWVrID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVla2VkID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0QnVmZmVyTGluZUNvdW50ID0gdGV4dE1vZGVsLmdldExpbmVDb3VudCgpO1xuICAgICAgICB0aGlzLnRleHRCdWZmZXJMYXN0TGluZUxlbmd0aCA9IHRleHRNb2RlbC5nZXRMaW5lTGVuZ3RoKHRoaXMudGV4dEJ1ZmZlckxpbmVDb3VudCk7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0b0xlbmd0aCh0aGlzLnRleHRCdWZmZXJMaW5lQ291bnQgLSAxLCB0aGlzLnRleHRCdWZmZXJMYXN0TGluZUxlbmd0aCk7XG4gICAgfVxuICAgIHNraXAobGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlkUGVlayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBsZW5ndGhBZGQodGhpcy5fb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICBjb25zdCBvYmogPSBsZW5ndGhUb09iaih0aGlzLl9vZmZzZXQpO1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRQb3NpdGlvbihvYmoubGluZUNvdW50LCBvYmouY29sdW1uQ291bnQpO1xuICAgIH1cbiAgICByZWFkKCkge1xuICAgICAgICBsZXQgdG9rZW47XG4gICAgICAgIGlmICh0aGlzLnBlZWtlZCkge1xuICAgICAgICAgICAgdGhpcy5kaWRQZWVrID0gZmFsc2U7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMucGVla2VkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnJlYWRlci5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBsZW5ndGhBZGQodGhpcy5fb2Zmc2V0LCB0b2tlbi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpZFBlZWspIHtcbiAgICAgICAgICAgIHRoaXMucGVla2VkID0gdGhpcy5yZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgdGhpcy5kaWRQZWVrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wZWVrZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBEb2VzIG5vdCBzdXBwb3J0IHBlZWsuXG4qL1xuY2xhc3MgTm9uUGVla2FibGVUZXh0QnVmZmVyVG9rZW5pemVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0TW9kZWwsIGJyYWNrZXRUb2tlbnMpIHtcbiAgICAgICAgdGhpcy50ZXh0TW9kZWwgPSB0ZXh0TW9kZWw7XG4gICAgICAgIHRoaXMuYnJhY2tldFRva2VucyA9IGJyYWNrZXRUb2tlbnM7XG4gICAgICAgIHRoaXMubGluZUlkeCA9IDA7XG4gICAgICAgIHRoaXMubGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGluZUNoYXJPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmxpbmVUb2tlbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmxpbmVUb2tlbk9mZnNldCA9IDA7XG4gICAgICAgIC8qKiBNdXN0IGJlIGEgemVybyBsaW5lIHRva2VuLiBUaGUgZW5kIG9mIHRoZSBkb2N1bWVudCBjYW5ub3QgYmUgcGVla2VkLiAqL1xuICAgICAgICB0aGlzLnBlZWtlZFRva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0QnVmZmVyTGluZUNvdW50ID0gdGV4dE1vZGVsLmdldExpbmVDb3VudCgpO1xuICAgICAgICB0aGlzLnRleHRCdWZmZXJMYXN0TGluZUxlbmd0aCA9IHRleHRNb2RlbC5nZXRMaW5lTGVuZ3RoKHRoaXMudGV4dEJ1ZmZlckxpbmVDb3VudCk7XG4gICAgfVxuICAgIHNldFBvc2l0aW9uKGxpbmVJZHgsIGNvbHVtbikge1xuICAgICAgICAvLyBXZSBtdXN0IG5vdCBqdW1wIGludG8gYSB0b2tlbiFcbiAgICAgICAgaWYgKGxpbmVJZHggPT09IHRoaXMubGluZUlkeCkge1xuICAgICAgICAgICAgdGhpcy5saW5lQ2hhck9mZnNldCA9IGNvbHVtbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVUb2tlbk9mZnNldCA9IHRoaXMubGluZUNoYXJPZmZzZXQgPT09IDAgPyAwIDogdGhpcy5saW5lVG9rZW5zLmZpbmRUb2tlbkluZGV4QXRPZmZzZXQodGhpcy5saW5lQ2hhck9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVJZHggPSBsaW5lSWR4O1xuICAgICAgICAgICAgdGhpcy5saW5lQ2hhck9mZnNldCA9IGNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMubGluZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZWVrZWRUb2tlbiA9IG51bGw7XG4gICAgfVxuICAgIHJlYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlZWtlZFRva2VuKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMucGVla2VkVG9rZW47XG4gICAgICAgICAgICB0aGlzLnBlZWtlZFRva2VuID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGluZUNoYXJPZmZzZXQgKz0gbGVuZ3RoR2V0Q29sdW1uQ291bnRJZlplcm9MaW5lQ291bnQodG9rZW4ubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lSWR4ID4gdGhpcy50ZXh0QnVmZmVyTGluZUNvdW50IC0gMSB8fCAodGhpcy5saW5lSWR4ID09PSB0aGlzLnRleHRCdWZmZXJMaW5lQ291bnQgLSAxICYmIHRoaXMubGluZUNoYXJPZmZzZXQgPj0gdGhpcy50ZXh0QnVmZmVyTGFzdExpbmVMZW5ndGgpKSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgYWZ0ZXIgdGhlIGVuZFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5saW5lVG9rZW5zID0gdGhpcy50ZXh0TW9kZWwudG9rZW5pemF0aW9uLmdldExpbmVUb2tlbnModGhpcy5saW5lSWR4ICsgMSk7XG4gICAgICAgICAgICB0aGlzLmxpbmUgPSB0aGlzLmxpbmVUb2tlbnMuZ2V0TGluZUNvbnRlbnQoKTtcbiAgICAgICAgICAgIHRoaXMubGluZVRva2VuT2Zmc2V0ID0gdGhpcy5saW5lQ2hhck9mZnNldCA9PT0gMCA/IDAgOiB0aGlzLmxpbmVUb2tlbnMuZmluZFRva2VuSW5kZXhBdE9mZnNldCh0aGlzLmxpbmVDaGFyT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydExpbmVJZHggPSB0aGlzLmxpbmVJZHg7XG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZUNoYXJPZmZzZXQgPSB0aGlzLmxpbmVDaGFyT2Zmc2V0O1xuICAgICAgICAvLyBsaW1pdHMgdGhlIGxlbmd0aCBvZiB0ZXh0IHRva2Vucy5cbiAgICAgICAgLy8gSWYgdGV4dCB0b2tlbnMgZ2V0IHRvbyBsb25nLCBpbmNyZW1lbnRhbCB1cGRhdGVzIHdpbGwgYmUgc2xvd1xuICAgICAgICBsZXQgbGVuZ3RoSGV1cmlzdGljID0gMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVUb2tlbnMgPSB0aGlzLmxpbmVUb2tlbnM7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvdW50ID0gbGluZVRva2Vucy5nZXRDb3VudCgpO1xuICAgICAgICAgICAgbGV0IHBlZWtlZEJyYWNrZXRUb2tlbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lVG9rZW5PZmZzZXQgPCB0b2tlbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5NZXRhZGF0YSA9IGxpbmVUb2tlbnMuZ2V0TWV0YWRhdGEodGhpcy5saW5lVG9rZW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmxpbmVUb2tlbk9mZnNldCArIDEgPCB0b2tlbkNvdW50ICYmIHRva2VuTWV0YWRhdGEgPT09IGxpbmVUb2tlbnMuZ2V0TWV0YWRhdGEodGhpcy5saW5lVG9rZW5PZmZzZXQgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHRva2VucyB0aGF0IGFyZSBpZGVudGljYWwuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aW1lcywgKGJyYWNrZXQpIGlkZW50aWZpZXJzIGFyZSBzcGxpdCB1cCBpbnRvIG11bHRpcGxlIHRva2Vucy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lVG9rZW5PZmZzZXQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNPdGhlciA9IFRva2VuTWV0YWRhdGEuZ2V0VG9rZW5UeXBlKHRva2VuTWV0YWRhdGEpID09PSAwIC8qIFN0YW5kYXJkVG9rZW5UeXBlLk90aGVyICovO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5zQnJhY2tldFR5cGUgPSBUb2tlbk1ldGFkYXRhLmNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyh0b2tlbk1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBsaW5lVG9rZW5zLmdldEVuZE9mZnNldCh0aGlzLmxpbmVUb2tlbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhlcmUgYSBicmFja2V0IHRva2VuIG5leHQ/IE9ubHkgY29uc3VtZSB0ZXh0LlxuICAgICAgICAgICAgICAgIGlmIChjb250YWluc0JyYWNrZXRUeXBlICYmIGlzT3RoZXIgJiYgdGhpcy5saW5lQ2hhck9mZnNldCA8IGVuZE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZUlkID0gbGluZVRva2Vucy5nZXRMYW5ndWFnZUlkKHRoaXMubGluZVRva2VuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMubGluZS5zdWJzdHJpbmcodGhpcy5saW5lQ2hhck9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldHMgPSB0aGlzLmJyYWNrZXRUb2tlbnMuZ2V0U2luZ2xlTGFuZ3VhZ2VCcmFja2V0VG9rZW5zKGxhbmd1YWdlSWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWdleHAgPSBicmFja2V0cy5yZWdFeHBHbG9iYWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdleHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZWdleHAuZXhlYyh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZWtlZEJyYWNrZXRUb2tlbiA9IGJyYWNrZXRzLmdldFRva2VuKG1hdGNoWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVla2VkQnJhY2tldFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnN1bWUgbGVhZGluZyB0ZXh0IG9mIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVDaGFyT2Zmc2V0ICs9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZW5ndGhIZXVyaXN0aWMgKz0gZW5kT2Zmc2V0IC0gdGhpcy5saW5lQ2hhck9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAocGVla2VkQnJhY2tldFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHNraXAgdGhlIGVudGlyZSB0b2tlbiwgYXMgYSBzaW5nbGUgdG9rZW4gY291bGQgY29udGFpbiBtdWx0aXBsZSBicmFja2V0cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0TGluZUlkeCAhPT0gdGhpcy5saW5lSWR4IHx8IHN0YXJ0TGluZUNoYXJPZmZzZXQgIT09IHRoaXMubGluZUNoYXJPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIHRleHQgYmVmb3JlIHRoZSBicmFja2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlZWtlZFRva2VuID0gcGVla2VkQnJhY2tldFRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25zdW1lIHRoZSBwZWVrZWQgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUNoYXJPZmZzZXQgKz0gbGVuZ3RoR2V0Q29sdW1uQ291bnRJZlplcm9MaW5lQ291bnQocGVla2VkQnJhY2tldFRva2VuLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVla2VkQnJhY2tldFRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBlbnRpcmUgdG9rZW4sIGFzIHRoZSB0b2tlbiBjb250YWlucyBubyBicmFja2V0cyBhdCBhbGwuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVRva2VuT2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUNoYXJPZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZUlkeCA9PT0gdGhpcy50ZXh0QnVmZmVyTGluZUNvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lSWR4Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lVG9rZW5zID0gdGhpcy50ZXh0TW9kZWwudG9rZW5pemF0aW9uLmdldExpbmVUb2tlbnModGhpcy5saW5lSWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lVG9rZW5PZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZSA9IHRoaXMubGluZVRva2Vucy5nZXRMaW5lQ29udGVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZUNoYXJPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGxlbmd0aEhldXJpc3RpYyArPSAzMzsgLy8gbWF4IDEwMDAvMzMgPSAzMCBsaW5lc1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbGltaXRzIHRoZSBhbW91bnQgb2Ygd29yayB0byByZWNvbXB1dGUgbWluLWluZGVudGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEhldXJpc3RpYyA+IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBicmVhayAoYXV0b21hdGljYWxseSkgYXQgdGhlIGVuZCBvZiBsaW5lLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoSGV1cmlzdGljID4gMTUwMCkge1xuICAgICAgICAgICAgICAgIC8vIEV2ZW50dWFsbHkgYnJlYWsgcmVnYXJkbGVzcyBvZiB0aGUgbGluZSBsZW5ndGggc28gdGhhdFxuICAgICAgICAgICAgICAgIC8vIHZlcnkgbG9uZyBsaW5lcyBkbyBub3QgY2F1c2UgYmFkIHBlcmZvcm1hbmNlLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZWZmZWN0aXZlIGxpbWl0cyBtYXggaW5kZW50YXRpb24gdG8gNTAwLCBhc1xuICAgICAgICAgICAgICAgIC8vIGluZGVudGF0aW9uIGlzIG5vdCBjb21wdXRlZCBhY3Jvc3MgbXVsdGlwbGUgdGV4dCBub2Rlcy5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIHRva2VuIGNvbnRhaW5zIHNvbWUgcHJvcGVyIGluZGVudGF0aW9uLCBpdCBhbHNvIGNvbnRhaW5zIFxcbntJTkRFTlRBVElPTit9KD8he0lOREVOVEFUSU9OfSksXG4gICAgICAgIC8vIHVubGVzcyB0aGUgbGluZSBpcyB0b28gbG9uZy5cbiAgICAgICAgLy8gVGh1cywgdGhlIG1pbiBpbmRlbnRhdGlvbiBvZiB0aGUgZG9jdW1lbnQgaXMgdGhlIG1pbmltdW0gbWluIGluZGVudGF0aW9uIG9mIGV2ZXJ5IHRleHQgbm9kZS5cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gbGVuZ3RoRGlmZihzdGFydExpbmVJZHgsIHN0YXJ0TGluZUNoYXJPZmZzZXQsIHRoaXMubGluZUlkeCwgdGhpcy5saW5lQ2hhck9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW4obGVuZ3RoLCAwIC8qIFRva2VuS2luZC5UZXh0ICovLCAtMSwgU21hbGxJbW11dGFibGVTZXQuZ2V0RW1wdHkoKSwgbmV3IFRleHRBc3ROb2RlKGxlbmd0aCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGYXN0VG9rZW5pemVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBicmFja2V0cykge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBsZW5ndGhaZXJvO1xuICAgICAgICB0aGlzLmlkeCA9IDA7XG4gICAgICAgIGNvbnN0IHJlZ0V4cFN0ciA9IGJyYWNrZXRzLmdldFJlZ0V4cFN0cigpO1xuICAgICAgICBjb25zdCByZWdleHAgPSByZWdFeHBTdHIgPyBuZXcgUmVnRXhwKHJlZ0V4cFN0ciArICd8XFxuJywgJ2dpJykgOiBudWxsO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBsZXQgY3VyTGluZUNvdW50ID0gMDtcbiAgICAgICAgbGV0IGxhc3RMaW5lQnJlYWtPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgbGFzdFRva2VuRW5kT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGxhc3RUb2tlbkVuZExpbmUgPSAwO1xuICAgICAgICBjb25zdCBzbWFsbFRleHRUb2tlbnMwTGluZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDYwOyBpKyspIHtcbiAgICAgICAgICAgIHNtYWxsVGV4dFRva2VuczBMaW5lLnB1c2gobmV3IFRva2VuKHRvTGVuZ3RoKDAsIGkpLCAwIC8qIFRva2VuS2luZC5UZXh0ICovLCAtMSwgU21hbGxJbW11dGFibGVTZXQuZ2V0RW1wdHkoKSwgbmV3IFRleHRBc3ROb2RlKHRvTGVuZ3RoKDAsIGkpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNtYWxsVGV4dFRva2VuczFMaW5lID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjA7IGkrKykge1xuICAgICAgICAgICAgc21hbGxUZXh0VG9rZW5zMUxpbmUucHVzaChuZXcgVG9rZW4odG9MZW5ndGgoMSwgaSksIDAgLyogVG9rZW5LaW5kLlRleHQgKi8sIC0xLCBTbWFsbEltbXV0YWJsZVNldC5nZXRFbXB0eSgpLCBuZXcgVGV4dEFzdE5vZGUodG9MZW5ndGgoMSwgaSkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZ2V4cCkge1xuICAgICAgICAgICAgcmVnZXhwLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAvLyBJZiBhIHRva2VuIGNvbnRhaW5zIGluZGVudGF0aW9uLCBpdCBhbHNvIGNvbnRhaW5zIFxcbntJTkRFTlRBVElPTit9KD8he0lOREVOVEFUSU9OfSlcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSByZWdleHAuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJPZmZzZXQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyTGluZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMaW5lQnJlYWtPZmZzZXQgPSBjdXJPZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbkVuZE9mZnNldCAhPT0gY3VyT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuRW5kTGluZSA9PT0gY3VyTGluZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sQ291bnQgPSBjdXJPZmZzZXQgLSBsYXN0VG9rZW5FbmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbENvdW50IDwgc21hbGxUZXh0VG9rZW5zMExpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gc21hbGxUZXh0VG9rZW5zMExpbmVbY29sQ291bnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdG9MZW5ndGgoMCwgY29sQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IG5ldyBUb2tlbihsZW5ndGgsIDAgLyogVG9rZW5LaW5kLlRleHQgKi8sIC0xLCBTbWFsbEltbXV0YWJsZVNldC5nZXRFbXB0eSgpLCBuZXcgVGV4dEFzdE5vZGUobGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZUNvdW50ID0gY3VyTGluZUNvdW50IC0gbGFzdFRva2VuRW5kTGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xDb3VudCA9IGN1ck9mZnNldCAtIGxhc3RMaW5lQnJlYWtPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVDb3VudCA9PT0gMSAmJiBjb2xDb3VudCA8IHNtYWxsVGV4dFRva2VuczFMaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHNtYWxsVGV4dFRva2VuczFMaW5lW2NvbENvdW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHRvTGVuZ3RoKGxpbmVDb3VudCwgY29sQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IG5ldyBUb2tlbihsZW5ndGgsIDAgLyogVG9rZW5LaW5kLlRleHQgKi8sIC0xLCBTbWFsbEltbXV0YWJsZVNldC5nZXRFbXB0eSgpLCBuZXcgVGV4dEFzdE5vZGUobGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIGlzIG1hdGNoZWQgYnkgcmVnZXhwLCBzbyB0aGUgdG9rZW4gbXVzdCBleGlzdFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChicmFja2V0cy5nZXRUb2tlbih2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW5FbmRPZmZzZXQgPSBjdXJPZmZzZXQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbkVuZExpbmUgPSBjdXJMaW5lQ291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRleHQubGVuZ3RoO1xuICAgICAgICBpZiAobGFzdFRva2VuRW5kT2Zmc2V0ICE9PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IChsYXN0VG9rZW5FbmRMaW5lID09PSBjdXJMaW5lQ291bnQpXG4gICAgICAgICAgICAgICAgPyB0b0xlbmd0aCgwLCBvZmZzZXQgLSBsYXN0VG9rZW5FbmRPZmZzZXQpXG4gICAgICAgICAgICAgICAgOiB0b0xlbmd0aChjdXJMaW5lQ291bnQgLSBsYXN0VG9rZW5FbmRMaW5lLCBvZmZzZXQgLSBsYXN0TGluZUJyZWFrT2Zmc2V0KTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ldyBUb2tlbihsZW5ndGgsIDAgLyogVG9rZW5LaW5kLlRleHQgKi8sIC0xLCBTbWFsbEltbXV0YWJsZVNldC5nZXRFbXB0eSgpLCBuZXcgVGV4dEFzdE5vZGUobGVuZ3RoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdG9MZW5ndGgoY3VyTGluZUNvdW50LCBvZmZzZXQgLSBsYXN0TGluZUJyZWFrT2Zmc2V0KTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gICAgfVxuICAgIHJlYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLmlkeCsrXSB8fCBudWxsO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pZHhdIHx8IG51bGw7XG4gICAgfVxuICAgIHNraXAobGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2V2ZW50LmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi8uLi9jb3JlL3JhbmdlLmpzJztcbmltcG9ydCB7IGVkaXRvckJyYWNrZXRIaWdobGlnaHRpbmdGb3JlZ3JvdW5kMSwgZWRpdG9yQnJhY2tldEhpZ2hsaWdodGluZ0ZvcmVncm91bmQyLCBlZGl0b3JCcmFja2V0SGlnaGxpZ2h0aW5nRm9yZWdyb3VuZDMsIGVkaXRvckJyYWNrZXRIaWdobGlnaHRpbmdGb3JlZ3JvdW5kNCwgZWRpdG9yQnJhY2tldEhpZ2hsaWdodGluZ0ZvcmVncm91bmQ1LCBlZGl0b3JCcmFja2V0SGlnaGxpZ2h0aW5nRm9yZWdyb3VuZDYsIGVkaXRvckJyYWNrZXRIaWdobGlnaHRpbmdVbmV4cGVjdGVkQnJhY2tldEZvcmVncm91bmQgfSBmcm9tICcuLi8uLi9jb3JlL2VkaXRvckNvbG9yUmVnaXN0cnkuanMnO1xuaW1wb3J0IHsgcmVnaXN0ZXJUaGVtaW5nUGFydGljaXBhbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9wbGF0Zm9ybS90aGVtZS9jb21tb24vdGhlbWVTZXJ2aWNlLmpzJztcbmV4cG9ydCBjbGFzcyBDb2xvcml6ZWRCcmFja2V0UGFpcnNEZWNvcmF0aW9uUHJvdmlkZXIgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0TW9kZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0TW9kZWwgPSB0ZXh0TW9kZWw7XG4gICAgICAgIHRoaXMuY29sb3JQcm92aWRlciA9IG5ldyBDb2xvclByb3ZpZGVyKCk7XG4gICAgICAgIHRoaXMub25EaWRDaGFuZ2VFbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkRpZENoYW5nZSA9IHRoaXMub25EaWRDaGFuZ2VFbWl0dGVyLmV2ZW50O1xuICAgICAgICB0aGlzLmNvbG9yaXphdGlvbk9wdGlvbnMgPSB0ZXh0TW9kZWwuZ2V0T3B0aW9ucygpLmJyYWNrZXRQYWlyQ29sb3JpemF0aW9uT3B0aW9ucztcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXIodGV4dE1vZGVsLmJyYWNrZXRQYWlycy5vbkRpZENoYW5nZShlID0+IHtcbiAgICAgICAgICAgIHRoaXMub25EaWRDaGFuZ2VFbWl0dGVyLmZpcmUoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyNyZWdpb24gVGV4dE1vZGVsIGV2ZW50c1xuICAgIGhhbmRsZURpZENoYW5nZU9wdGlvbnMoZSkge1xuICAgICAgICB0aGlzLmNvbG9yaXphdGlvbk9wdGlvbnMgPSB0aGlzLnRleHRNb2RlbC5nZXRPcHRpb25zKCkuYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgICBnZXREZWNvcmF0aW9uc0luUmFuZ2UocmFuZ2UsIG93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIG9ubHlNaW5pbWFwRGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKG9ubHlNaW5pbWFwRGVjb3JhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIEJyYWNrZXQgcGFpciBjb2xvcml6YXRpb24gZGVjb3JhdGlvbnMgYXJlIG5vdCByZW5kZXJlZCBpbiB0aGUgbWluaW1hcFxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvd25lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29sb3JpemF0aW9uT3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50ZXh0TW9kZWwuYnJhY2tldFBhaXJzLmdldEJyYWNrZXRzSW5SYW5nZShyYW5nZSwgdHJ1ZSkubWFwKGJyYWNrZXQgPT4gKHtcbiAgICAgICAgICAgIGlkOiBgYnJhY2tldCR7YnJhY2tldC5yYW5nZS50b1N0cmluZygpfS0ke2JyYWNrZXQubmVzdGluZ0xldmVsfWAsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdCcmFja2V0UGFpckNvbG9yaXphdGlvbicsXG4gICAgICAgICAgICAgICAgaW5saW5lQ2xhc3NOYW1lOiB0aGlzLmNvbG9yUHJvdmlkZXIuZ2V0SW5saW5lQ2xhc3NOYW1lKGJyYWNrZXQsIHRoaXMuY29sb3JpemF0aW9uT3B0aW9ucy5pbmRlcGVuZGVudENvbG9yUG9vbFBlckJyYWNrZXRUeXBlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvd25lcklkOiAwLFxuICAgICAgICAgICAgcmFuZ2U6IGJyYWNrZXQucmFuZ2UsXG4gICAgICAgIH0pKS50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldEFsbERlY29yYXRpb25zKG93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24pIHtcbiAgICAgICAgaWYgKG93bmVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb2xvcml6YXRpb25PcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXREZWNvcmF0aW9uc0luUmFuZ2UobmV3IFJhbmdlKDEsIDEsIHRoaXMudGV4dE1vZGVsLmdldExpbmVDb3VudCgpLCAxKSwgb3duZXJJZCwgZmlsdGVyT3V0VmFsaWRhdGlvbik7XG4gICAgfVxufVxuY2xhc3MgQ29sb3JQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZENsb3NpbmdCcmFja2V0Q2xhc3NOYW1lID0gJ3VuZXhwZWN0ZWQtY2xvc2luZy1icmFja2V0JztcbiAgICB9XG4gICAgZ2V0SW5saW5lQ2xhc3NOYW1lKGJyYWNrZXQsIGluZGVwZW5kZW50Q29sb3JQb29sUGVyQnJhY2tldFR5cGUpIHtcbiAgICAgICAgaWYgKGJyYWNrZXQuaXNJbnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkQ2xvc2luZ0JyYWNrZXRDbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5saW5lQ2xhc3NOYW1lT2ZMZXZlbChpbmRlcGVuZGVudENvbG9yUG9vbFBlckJyYWNrZXRUeXBlID8gYnJhY2tldC5uZXN0aW5nTGV2ZWxPZkVxdWFsQnJhY2tldFR5cGUgOiBicmFja2V0Lm5lc3RpbmdMZXZlbCk7XG4gICAgfVxuICAgIGdldElubGluZUNsYXNzTmFtZU9mTGV2ZWwobGV2ZWwpIHtcbiAgICAgICAgLy8gVG8gc3VwcG9ydCBhIGR5bmFtaWMgYW1vdW50IG9mIGNvbG9ycyB1cCB0byA2IGNvbG9ycyxcbiAgICAgICAgLy8gd2UgdXNlIGEgbnVtYmVyIHRoYXQgaXMgYSBsY20gb2YgYWxsIG51bWJlcnMgZnJvbSAxIHRvIDYuXG4gICAgICAgIHJldHVybiBgYnJhY2tldC1oaWdobGlnaHRpbmctJHtsZXZlbCAlIDMwfWA7XG4gICAgfVxufVxucmVnaXN0ZXJUaGVtaW5nUGFydGljaXBhbnQoKHRoZW1lLCBjb2xsZWN0b3IpID0+IHtcbiAgICBjb25zdCBjb2xvcnMgPSBbXG4gICAgICAgIGVkaXRvckJyYWNrZXRIaWdobGlnaHRpbmdGb3JlZ3JvdW5kMSxcbiAgICAgICAgZWRpdG9yQnJhY2tldEhpZ2hsaWdodGluZ0ZvcmVncm91bmQyLFxuICAgICAgICBlZGl0b3JCcmFja2V0SGlnaGxpZ2h0aW5nRm9yZWdyb3VuZDMsXG4gICAgICAgIGVkaXRvckJyYWNrZXRIaWdobGlnaHRpbmdGb3JlZ3JvdW5kNCxcbiAgICAgICAgZWRpdG9yQnJhY2tldEhpZ2hsaWdodGluZ0ZvcmVncm91bmQ1LFxuICAgICAgICBlZGl0b3JCcmFja2V0SGlnaGxpZ2h0aW5nRm9yZWdyb3VuZDZcbiAgICBdO1xuICAgIGNvbnN0IGNvbG9yUHJvdmlkZXIgPSBuZXcgQ29sb3JQcm92aWRlcigpO1xuICAgIGNvbGxlY3Rvci5hZGRSdWxlKGAubW9uYWNvLWVkaXRvciAuJHtjb2xvclByb3ZpZGVyLnVuZXhwZWN0ZWRDbG9zaW5nQnJhY2tldENsYXNzTmFtZX0geyBjb2xvcjogJHt0aGVtZS5nZXRDb2xvcihlZGl0b3JCcmFja2V0SGlnaGxpZ2h0aW5nVW5leHBlY3RlZEJyYWNrZXRGb3JlZ3JvdW5kKX07IH1gKTtcbiAgICBjb25zdCBjb2xvclZhbHVlcyA9IGNvbG9yc1xuICAgICAgICAubWFwKGMgPT4gdGhlbWUuZ2V0Q29sb3IoYykpXG4gICAgICAgIC5maWx0ZXIoKGMpID0+ICEhYylcbiAgICAgICAgLmZpbHRlcihjID0+ICFjLmlzVHJhbnNwYXJlbnQoKSk7XG4gICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IDMwOyBsZXZlbCsrKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gY29sb3JWYWx1ZXNbbGV2ZWwgJSBjb2xvclZhbHVlcy5sZW5ndGhdO1xuICAgICAgICBjb2xsZWN0b3IuYWRkUnVsZShgLm1vbmFjby1lZGl0b3IgLiR7Y29sb3JQcm92aWRlci5nZXRJbmxpbmVDbGFzc05hbWVPZkxldmVsKGxldmVsKX0geyBjb2xvcjogJHtjb2xvcn07IH1gKTtcbiAgICB9XG59KTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgbmxzIGZyb20gJy4uLy4uLy4uL25scy5qcyc7XG5pbXBvcnQgeyBvblVuZXhwZWN0ZWRFcnJvciB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICcuLi9jb3JlL3NlbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xuaW1wb3J0IHsgVGV4dENoYW5nZSwgY29tcHJlc3NDb25zZWN1dGl2ZVRleHRDaGFuZ2VzIH0gZnJvbSAnLi4vY29yZS90ZXh0Q2hhbmdlLmpzJztcbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9idWZmZXIuanMnO1xuaW1wb3J0IHsgYmFzZW5hbWUgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9yZXNvdXJjZXMuanMnO1xuZnVuY3Rpb24gdXJpR2V0Q29tcGFyaXNvbktleShyZXNvdXJjZSkge1xuICAgIHJldHVybiByZXNvdXJjZS50b1N0cmluZygpO1xufVxuZXhwb3J0IGNsYXNzIFNpbmdsZU1vZGVsRWRpdFN0YWNrRGF0YSB7XG4gICAgc3RhdGljIGNyZWF0ZShtb2RlbCwgYmVmb3JlQ3Vyc29yU3RhdGUpIHtcbiAgICAgICAgY29uc3QgYWx0ZXJuYXRpdmVWZXJzaW9uSWQgPSBtb2RlbC5nZXRBbHRlcm5hdGl2ZVZlcnNpb25JZCgpO1xuICAgICAgICBjb25zdCBlb2wgPSBnZXRNb2RlbEVPTChtb2RlbCk7XG4gICAgICAgIHJldHVybiBuZXcgU2luZ2xlTW9kZWxFZGl0U3RhY2tEYXRhKGFsdGVybmF0aXZlVmVyc2lvbklkLCBhbHRlcm5hdGl2ZVZlcnNpb25JZCwgZW9sLCBlb2wsIGJlZm9yZUN1cnNvclN0YXRlLCBiZWZvcmVDdXJzb3JTdGF0ZSwgW10pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihiZWZvcmVWZXJzaW9uSWQsIGFmdGVyVmVyc2lvbklkLCBiZWZvcmVFT0wsIGFmdGVyRU9MLCBiZWZvcmVDdXJzb3JTdGF0ZSwgYWZ0ZXJDdXJzb3JTdGF0ZSwgY2hhbmdlcykge1xuICAgICAgICB0aGlzLmJlZm9yZVZlcnNpb25JZCA9IGJlZm9yZVZlcnNpb25JZDtcbiAgICAgICAgdGhpcy5hZnRlclZlcnNpb25JZCA9IGFmdGVyVmVyc2lvbklkO1xuICAgICAgICB0aGlzLmJlZm9yZUVPTCA9IGJlZm9yZUVPTDtcbiAgICAgICAgdGhpcy5hZnRlckVPTCA9IGFmdGVyRU9MO1xuICAgICAgICB0aGlzLmJlZm9yZUN1cnNvclN0YXRlID0gYmVmb3JlQ3Vyc29yU3RhdGU7XG4gICAgICAgIHRoaXMuYWZ0ZXJDdXJzb3JTdGF0ZSA9IGFmdGVyQ3Vyc29yU3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgfVxuICAgIGFwcGVuZChtb2RlbCwgdGV4dENoYW5nZXMsIGFmdGVyRU9MLCBhZnRlclZlcnNpb25JZCwgYWZ0ZXJDdXJzb3JTdGF0ZSkge1xuICAgICAgICBpZiAodGV4dENoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzID0gY29tcHJlc3NDb25zZWN1dGl2ZVRleHRDaGFuZ2VzKHRoaXMuY2hhbmdlcywgdGV4dENoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWZ0ZXJFT0wgPSBhZnRlckVPTDtcbiAgICAgICAgdGhpcy5hZnRlclZlcnNpb25JZCA9IGFmdGVyVmVyc2lvbklkO1xuICAgICAgICB0aGlzLmFmdGVyQ3Vyc29yU3RhdGUgPSBhZnRlckN1cnNvclN0YXRlO1xuICAgIH1cbiAgICBzdGF0aWMgX3dyaXRlU2VsZWN0aW9uc1NpemUoc2VsZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gNCArIDQgKiA0ICogKHNlbGVjdGlvbnMgPyBzZWxlY3Rpb25zLmxlbmd0aCA6IDApO1xuICAgIH1cbiAgICBzdGF0aWMgX3dyaXRlU2VsZWN0aW9ucyhiLCBzZWxlY3Rpb25zLCBvZmZzZXQpIHtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUoYiwgKHNlbGVjdGlvbnMgPyBzZWxlY3Rpb25zLmxlbmd0aCA6IDApLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShiLCBzZWxlY3Rpb24uc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGIsIHNlbGVjdGlvbi5zZWxlY3Rpb25TdGFydENvbHVtbiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShiLCBzZWxlY3Rpb24ucG9zaXRpb25MaW5lTnVtYmVyLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGIsIHNlbGVjdGlvbi5wb3NpdGlvbkNvbHVtbiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBzdGF0aWMgX3JlYWRTZWxlY3Rpb25zKGIsIG9mZnNldCwgZGVzdCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IGJ1ZmZlci5yZWFkVUludDMyQkUoYiwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyID0gYnVmZmVyLnJlYWRVSW50MzJCRShiLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydENvbHVtbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUoYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25MaW5lTnVtYmVyID0gYnVmZmVyLnJlYWRVSW50MzJCRShiLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbkNvbHVtbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUoYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgZGVzdC5wdXNoKG5ldyBTZWxlY3Rpb24oc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCBzZWxlY3Rpb25TdGFydENvbHVtbiwgcG9zaXRpb25MaW5lTnVtYmVyLCBwb3NpdGlvbkNvbHVtbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgbGV0IG5lY2Vzc2FyeVNpemUgPSAoKzQgLy8gYmVmb3JlVmVyc2lvbklkXG4gICAgICAgICAgICArIDQgLy8gYWZ0ZXJWZXJzaW9uSWRcbiAgICAgICAgICAgICsgMSAvLyBiZWZvcmVFT0xcbiAgICAgICAgICAgICsgMSAvLyBhZnRlckVPTFxuICAgICAgICAgICAgKyBTaW5nbGVNb2RlbEVkaXRTdGFja0RhdGEuX3dyaXRlU2VsZWN0aW9uc1NpemUodGhpcy5iZWZvcmVDdXJzb3JTdGF0ZSlcbiAgICAgICAgICAgICsgU2luZ2xlTW9kZWxFZGl0U3RhY2tEYXRhLl93cml0ZVNlbGVjdGlvbnNTaXplKHRoaXMuYWZ0ZXJDdXJzb3JTdGF0ZSlcbiAgICAgICAgICAgICsgNCAvLyBjaGFuZ2UgY291bnRcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgdGhpcy5jaGFuZ2VzKSB7XG4gICAgICAgICAgICBuZWNlc3NhcnlTaXplICs9IGNoYW5nZS53cml0ZVNpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiID0gbmV3IFVpbnQ4QXJyYXkobmVjZXNzYXJ5U2l6ZSk7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShiLCB0aGlzLmJlZm9yZVZlcnNpb25JZCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGIsIHRoaXMuYWZ0ZXJWZXJzaW9uSWQsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OChiLCB0aGlzLmJlZm9yZUVPTCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KGIsIHRoaXMuYWZ0ZXJFT0wsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICBvZmZzZXQgPSBTaW5nbGVNb2RlbEVkaXRTdGFja0RhdGEuX3dyaXRlU2VsZWN0aW9ucyhiLCB0aGlzLmJlZm9yZUN1cnNvclN0YXRlLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgPSBTaW5nbGVNb2RlbEVkaXRTdGFja0RhdGEuX3dyaXRlU2VsZWN0aW9ucyhiLCB0aGlzLmFmdGVyQ3Vyc29yU3RhdGUsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGIsIHRoaXMuY2hhbmdlcy5sZW5ndGgsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiB0aGlzLmNoYW5nZXMpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGNoYW5nZS53cml0ZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiLmJ1ZmZlcjtcbiAgICB9XG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBiID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IGJlZm9yZVZlcnNpb25JZCA9IGJ1ZmZlci5yZWFkVUludDMyQkUoYiwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIGNvbnN0IGFmdGVyVmVyc2lvbklkID0gYnVmZmVyLnJlYWRVSW50MzJCRShiLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgY29uc3QgYmVmb3JlRU9MID0gYnVmZmVyLnJlYWRVSW50OChiLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgY29uc3QgYWZ0ZXJFT0wgPSBidWZmZXIucmVhZFVJbnQ4KGIsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICBjb25zdCBiZWZvcmVDdXJzb3JTdGF0ZSA9IFtdO1xuICAgICAgICBvZmZzZXQgPSBTaW5nbGVNb2RlbEVkaXRTdGFja0RhdGEuX3JlYWRTZWxlY3Rpb25zKGIsIG9mZnNldCwgYmVmb3JlQ3Vyc29yU3RhdGUpO1xuICAgICAgICBjb25zdCBhZnRlckN1cnNvclN0YXRlID0gW107XG4gICAgICAgIG9mZnNldCA9IFNpbmdsZU1vZGVsRWRpdFN0YWNrRGF0YS5fcmVhZFNlbGVjdGlvbnMoYiwgb2Zmc2V0LCBhZnRlckN1cnNvclN0YXRlKTtcbiAgICAgICAgY29uc3QgY2hhbmdlQ291bnQgPSBidWZmZXIucmVhZFVJbnQzMkJFKGIsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gVGV4dENoYW5nZS5yZWFkKGIsIG9mZnNldCwgY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVNb2RlbEVkaXRTdGFja0RhdGEoYmVmb3JlVmVyc2lvbklkLCBhZnRlclZlcnNpb25JZCwgYmVmb3JlRU9MLCBhZnRlckVPTCwgYmVmb3JlQ3Vyc29yU3RhdGUsIGFmdGVyQ3Vyc29yU3RhdGUsIGNoYW5nZXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTaW5nbGVNb2RlbEVkaXRTdGFja0VsZW1lbnQge1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gMCAvKiBVbmRvUmVkb0VsZW1lbnRUeXBlLlJlc291cmNlICovO1xuICAgIH1cbiAgICBnZXQgcmVzb3VyY2UoKSB7XG4gICAgICAgIGlmIChVUkkuaXNVcmkodGhpcy5tb2RlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnVyaTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGFiZWwsIGNvZGUsIG1vZGVsLCBiZWZvcmVDdXJzb3JTdGF0ZSkge1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5fZGF0YSA9IFNpbmdsZU1vZGVsRWRpdFN0YWNrRGF0YS5jcmVhdGUobW9kZWwsIGJlZm9yZUN1cnNvclN0YXRlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIFNpbmdsZU1vZGVsRWRpdFN0YWNrRGF0YSA/IHRoaXMuX2RhdGEgOiBTaW5nbGVNb2RlbEVkaXRTdGFja0RhdGEuZGVzZXJpYWxpemUodGhpcy5fZGF0YSkpO1xuICAgICAgICByZXR1cm4gZGF0YS5jaGFuZ2VzLm1hcChjaGFuZ2UgPT4gY2hhbmdlLnRvU3RyaW5nKCkpLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIG1hdGNoZXNSZXNvdXJjZShyZXNvdXJjZSkge1xuICAgICAgICBjb25zdCB1cmkgPSAoVVJJLmlzVXJpKHRoaXMubW9kZWwpID8gdGhpcy5tb2RlbCA6IHRoaXMubW9kZWwudXJpKTtcbiAgICAgICAgcmV0dXJuICh1cmkudG9TdHJpbmcoKSA9PT0gcmVzb3VyY2UudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgY2FuQXBwZW5kKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tb2RlbCA9PT0gbW9kZWwgJiYgdGhpcy5fZGF0YSBpbnN0YW5jZW9mIFNpbmdsZU1vZGVsRWRpdFN0YWNrRGF0YSk7XG4gICAgfVxuICAgIGFwcGVuZChtb2RlbCwgdGV4dENoYW5nZXMsIGFmdGVyRU9MLCBhZnRlclZlcnNpb25JZCwgYWZ0ZXJDdXJzb3JTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIFNpbmdsZU1vZGVsRWRpdFN0YWNrRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YS5hcHBlbmQobW9kZWwsIHRleHRDaGFuZ2VzLCBhZnRlckVPTCwgYWZ0ZXJWZXJzaW9uSWQsIGFmdGVyQ3Vyc29yU3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIFNpbmdsZU1vZGVsRWRpdFN0YWNrRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGEuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3BlbigpIHtcbiAgICAgICAgaWYgKCEodGhpcy5fZGF0YSBpbnN0YW5jZW9mIFNpbmdsZU1vZGVsRWRpdFN0YWNrRGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBTaW5nbGVNb2RlbEVkaXRTdGFja0RhdGEuZGVzZXJpYWxpemUodGhpcy5fZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5kbygpIHtcbiAgICAgICAgaWYgKFVSSS5pc1VyaSh0aGlzLm1vZGVsKSkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgaGF2ZSBhIG1vZGVsXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgU2luZ2xlTW9kZWxFZGl0U3RhY2tFbGVtZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBTaW5nbGVNb2RlbEVkaXRTdGFja0RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhLnNlcmlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBTaW5nbGVNb2RlbEVkaXRTdGFja0RhdGEuZGVzZXJpYWxpemUodGhpcy5fZGF0YSk7XG4gICAgICAgIHRoaXMubW9kZWwuX2FwcGx5VW5kbyhkYXRhLmNoYW5nZXMsIGRhdGEuYmVmb3JlRU9MLCBkYXRhLmJlZm9yZVZlcnNpb25JZCwgZGF0YS5iZWZvcmVDdXJzb3JTdGF0ZSk7XG4gICAgfVxuICAgIHJlZG8oKSB7XG4gICAgICAgIGlmIChVUkkuaXNVcmkodGhpcy5tb2RlbCkpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGhhdmUgYSBtb2RlbFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFNpbmdsZU1vZGVsRWRpdFN0YWNrRWxlbWVudGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgU2luZ2xlTW9kZWxFZGl0U3RhY2tEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YS5zZXJpYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gU2luZ2xlTW9kZWxFZGl0U3RhY2tEYXRhLmRlc2VyaWFsaXplKHRoaXMuX2RhdGEpO1xuICAgICAgICB0aGlzLm1vZGVsLl9hcHBseVJlZG8oZGF0YS5jaGFuZ2VzLCBkYXRhLmFmdGVyRU9MLCBkYXRhLmFmdGVyVmVyc2lvbklkLCBkYXRhLmFmdGVyQ3Vyc29yU3RhdGUpO1xuICAgIH1cbiAgICBoZWFwU2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBTaW5nbGVNb2RlbEVkaXRTdGFja0RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhLnNlcmlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJ5dGVMZW5ndGggKyAxNjggLypoZWFwIG92ZXJoZWFkKi87XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE11bHRpTW9kZWxFZGl0U3RhY2tFbGVtZW50IHtcbiAgICBnZXQgcmVzb3VyY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWRpdFN0YWNrRWxlbWVudHNBcnIubWFwKGVkaXRTdGFja0VsZW1lbnQgPT4gZWRpdFN0YWNrRWxlbWVudC5yZXNvdXJjZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxhYmVsLCBjb2RlLCBlZGl0U3RhY2tFbGVtZW50cykge1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IDEgLyogVW5kb1JlZG9FbGVtZW50VHlwZS5Xb3Jrc3BhY2UgKi87XG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX2VkaXRTdGFja0VsZW1lbnRzQXJyID0gZWRpdFN0YWNrRWxlbWVudHMuc2xpY2UoMCk7XG4gICAgICAgIHRoaXMuX2VkaXRTdGFja0VsZW1lbnRzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRTdGFja0VsZW1lbnQgb2YgdGhpcy5fZWRpdFN0YWNrRWxlbWVudHNBcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHVyaUdldENvbXBhcmlzb25LZXkoZWRpdFN0YWNrRWxlbWVudC5yZXNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9lZGl0U3RhY2tFbGVtZW50c01hcC5zZXQoa2V5LCBlZGl0U3RhY2tFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IG51bGw7XG4gICAgfVxuICAgIHByZXBhcmVVbmRvUmVkbygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlbGVnYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUucHJlcGFyZVVuZG9SZWRvKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoZXNSZXNvdXJjZShyZXNvdXJjZSkge1xuICAgICAgICBjb25zdCBrZXkgPSB1cmlHZXRDb21wYXJpc29uS2V5KHJlc291cmNlKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9lZGl0U3RhY2tFbGVtZW50c01hcC5oYXMoa2V5KSk7XG4gICAgfVxuICAgIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHVyaUdldENvbXBhcmlzb25LZXkoVVJJLmlzVXJpKG1vZGVsKSA/IG1vZGVsIDogbW9kZWwudXJpKTtcbiAgICAgICAgaWYgKHRoaXMuX2VkaXRTdGFja0VsZW1lbnRzTWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLl9lZGl0U3RhY2tFbGVtZW50c01hcC5nZXQoa2V5KS5zZXRNb2RlbChtb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuQXBwZW5kKG1vZGVsKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gdXJpR2V0Q29tcGFyaXNvbktleShtb2RlbC51cmkpO1xuICAgICAgICBpZiAodGhpcy5fZWRpdFN0YWNrRWxlbWVudHNNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRTdGFja0VsZW1lbnQgPSB0aGlzLl9lZGl0U3RhY2tFbGVtZW50c01hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBlZGl0U3RhY2tFbGVtZW50LmNhbkFwcGVuZChtb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhcHBlbmQobW9kZWwsIHRleHRDaGFuZ2VzLCBhZnRlckVPTCwgYWZ0ZXJWZXJzaW9uSWQsIGFmdGVyQ3Vyc29yU3RhdGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdXJpR2V0Q29tcGFyaXNvbktleShtb2RlbC51cmkpO1xuICAgICAgICBjb25zdCBlZGl0U3RhY2tFbGVtZW50ID0gdGhpcy5fZWRpdFN0YWNrRWxlbWVudHNNYXAuZ2V0KGtleSk7XG4gICAgICAgIGVkaXRTdGFja0VsZW1lbnQuYXBwZW5kKG1vZGVsLCB0ZXh0Q2hhbmdlcywgYWZ0ZXJFT0wsIGFmdGVyVmVyc2lvbklkLCBhZnRlckN1cnNvclN0YXRlKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xuICAgIH1cbiAgICBvcGVuKCkge1xuICAgICAgICAvLyBjYW5ub3QgcmVvcGVuXG4gICAgfVxuICAgIHVuZG8oKSB7XG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRTdGFja0VsZW1lbnQgb2YgdGhpcy5fZWRpdFN0YWNrRWxlbWVudHNBcnIpIHtcbiAgICAgICAgICAgIGVkaXRTdGFja0VsZW1lbnQudW5kbygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZG8oKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdFN0YWNrRWxlbWVudCBvZiB0aGlzLl9lZGl0U3RhY2tFbGVtZW50c0Fycikge1xuICAgICAgICAgICAgZWRpdFN0YWNrRWxlbWVudC5yZWRvKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGVhcFNpemUocmVzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdXJpR2V0Q29tcGFyaXNvbktleShyZXNvdXJjZSk7XG4gICAgICAgIGlmICh0aGlzLl9lZGl0U3RhY2tFbGVtZW50c01hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZWRpdFN0YWNrRWxlbWVudCA9IHRoaXMuX2VkaXRTdGFja0VsZW1lbnRzTWFwLmdldChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRTdGFja0VsZW1lbnQuaGVhcFNpemUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgc3BsaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lZGl0U3RhY2tFbGVtZW50c0FycjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRTdGFja0VsZW1lbnQgb2YgdGhpcy5fZWRpdFN0YWNrRWxlbWVudHNBcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGAke2Jhc2VuYW1lKGVkaXRTdGFja0VsZW1lbnQucmVzb3VyY2UpfTogJHtlZGl0U3RhY2tFbGVtZW50fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgeyR7cmVzdWx0LmpvaW4oJywgJyl9fWA7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TW9kZWxFT0wobW9kZWwpIHtcbiAgICBjb25zdCBlb2wgPSBtb2RlbC5nZXRFT0woKTtcbiAgICBpZiAoZW9sID09PSAnXFxuJykge1xuICAgICAgICByZXR1cm4gMCAvKiBFbmRPZkxpbmVTZXF1ZW5jZS5MRiAqLztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAxIC8qIEVuZE9mTGluZVNlcXVlbmNlLkNSTEYgKi87XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRWRpdFN0YWNrRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgoZWxlbWVudCBpbnN0YW5jZW9mIFNpbmdsZU1vZGVsRWRpdFN0YWNrRWxlbWVudCkgfHwgKGVsZW1lbnQgaW5zdGFuY2VvZiBNdWx0aU1vZGVsRWRpdFN0YWNrRWxlbWVudCkpO1xufVxuZXhwb3J0IGNsYXNzIEVkaXRTdGFjayB7XG4gICAgY29uc3RydWN0b3IobW9kZWwsIHVuZG9SZWRvU2VydmljZSkge1xuICAgICAgICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLl91bmRvUmVkb1NlcnZpY2UgPSB1bmRvUmVkb1NlcnZpY2U7XG4gICAgfVxuICAgIHB1c2hTdGFja0VsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGxhc3RFbGVtZW50ID0gdGhpcy5fdW5kb1JlZG9TZXJ2aWNlLmdldExhc3RFbGVtZW50KHRoaXMuX21vZGVsLnVyaSk7XG4gICAgICAgIGlmIChpc0VkaXRTdGFja0VsZW1lbnQobGFzdEVsZW1lbnQpKSB7XG4gICAgICAgICAgICBsYXN0RWxlbWVudC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvcFN0YWNrRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSB0aGlzLl91bmRvUmVkb1NlcnZpY2UuZ2V0TGFzdEVsZW1lbnQodGhpcy5fbW9kZWwudXJpKTtcbiAgICAgICAgaWYgKGlzRWRpdFN0YWNrRWxlbWVudChsYXN0RWxlbWVudCkpIHtcbiAgICAgICAgICAgIGxhc3RFbGVtZW50Lm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fdW5kb1JlZG9TZXJ2aWNlLnJlbW92ZUVsZW1lbnRzKHRoaXMuX21vZGVsLnVyaSk7XG4gICAgfVxuICAgIF9nZXRPckNyZWF0ZUVkaXRTdGFja0VsZW1lbnQoYmVmb3JlQ3Vyc29yU3RhdGUsIGdyb3VwKSB7XG4gICAgICAgIGNvbnN0IGxhc3RFbGVtZW50ID0gdGhpcy5fdW5kb1JlZG9TZXJ2aWNlLmdldExhc3RFbGVtZW50KHRoaXMuX21vZGVsLnVyaSk7XG4gICAgICAgIGlmIChpc0VkaXRTdGFja0VsZW1lbnQobGFzdEVsZW1lbnQpICYmIGxhc3RFbGVtZW50LmNhbkFwcGVuZCh0aGlzLl9tb2RlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdFbGVtZW50ID0gbmV3IFNpbmdsZU1vZGVsRWRpdFN0YWNrRWxlbWVudChubHMubG9jYWxpemUoJ2VkaXQnLCBcIlR5cGluZ1wiKSwgJ3VuZG9yZWRvLnRleHRCdWZmZXJFZGl0JywgdGhpcy5fbW9kZWwsIGJlZm9yZUN1cnNvclN0YXRlKTtcbiAgICAgICAgdGhpcy5fdW5kb1JlZG9TZXJ2aWNlLnB1c2hFbGVtZW50KG5ld0VsZW1lbnQsIGdyb3VwKTtcbiAgICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gICAgfVxuICAgIHB1c2hFT0woZW9sKSB7XG4gICAgICAgIGNvbnN0IGVkaXRTdGFja0VsZW1lbnQgPSB0aGlzLl9nZXRPckNyZWF0ZUVkaXRTdGFja0VsZW1lbnQobnVsbCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fbW9kZWwuc2V0RU9MKGVvbCk7XG4gICAgICAgIGVkaXRTdGFja0VsZW1lbnQuYXBwZW5kKHRoaXMuX21vZGVsLCBbXSwgZ2V0TW9kZWxFT0wodGhpcy5fbW9kZWwpLCB0aGlzLl9tb2RlbC5nZXRBbHRlcm5hdGl2ZVZlcnNpb25JZCgpLCBudWxsKTtcbiAgICB9XG4gICAgcHVzaEVkaXRPcGVyYXRpb24oYmVmb3JlQ3Vyc29yU3RhdGUsIGVkaXRPcGVyYXRpb25zLCBjdXJzb3JTdGF0ZUNvbXB1dGVyLCBncm91cCkge1xuICAgICAgICBjb25zdCBlZGl0U3RhY2tFbGVtZW50ID0gdGhpcy5fZ2V0T3JDcmVhdGVFZGl0U3RhY2tFbGVtZW50KGJlZm9yZUN1cnNvclN0YXRlLCBncm91cCk7XG4gICAgICAgIGNvbnN0IGludmVyc2VFZGl0T3BlcmF0aW9ucyA9IHRoaXMuX21vZGVsLmFwcGx5RWRpdHMoZWRpdE9wZXJhdGlvbnMsIHRydWUpO1xuICAgICAgICBjb25zdCBhZnRlckN1cnNvclN0YXRlID0gRWRpdFN0YWNrLl9jb21wdXRlQ3Vyc29yU3RhdGUoY3Vyc29yU3RhdGVDb21wdXRlciwgaW52ZXJzZUVkaXRPcGVyYXRpb25zKTtcbiAgICAgICAgY29uc3QgdGV4dENoYW5nZXMgPSBpbnZlcnNlRWRpdE9wZXJhdGlvbnMubWFwKChvcCwgaW5kZXgpID0+ICh7IGluZGV4OiBpbmRleCwgdGV4dENoYW5nZTogb3AudGV4dENoYW5nZSB9KSk7XG4gICAgICAgIHRleHRDaGFuZ2VzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmIChhLnRleHRDaGFuZ2Uub2xkUG9zaXRpb24gPT09IGIudGV4dENoYW5nZS5vbGRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhLnRleHRDaGFuZ2Uub2xkUG9zaXRpb24gLSBiLnRleHRDaGFuZ2Uub2xkUG9zaXRpb247XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0U3RhY2tFbGVtZW50LmFwcGVuZCh0aGlzLl9tb2RlbCwgdGV4dENoYW5nZXMubWFwKG9wID0+IG9wLnRleHRDaGFuZ2UpLCBnZXRNb2RlbEVPTCh0aGlzLl9tb2RlbCksIHRoaXMuX21vZGVsLmdldEFsdGVybmF0aXZlVmVyc2lvbklkKCksIGFmdGVyQ3Vyc29yU3RhdGUpO1xuICAgICAgICByZXR1cm4gYWZ0ZXJDdXJzb3JTdGF0ZTtcbiAgICB9XG4gICAgc3RhdGljIF9jb21wdXRlQ3Vyc29yU3RhdGUoY3Vyc29yU3RhdGVDb21wdXRlciwgaW52ZXJzZUVkaXRPcGVyYXRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gY3Vyc29yU3RhdGVDb21wdXRlciA/IGN1cnNvclN0YXRlQ29tcHV0ZXIoaW52ZXJzZUVkaXRPcGVyYXRpb25zKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9uVW5leHBlY3RlZEVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGFycmF5SW5zZXJ0IH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzLmpzJztcbi8qKlxuICogQW4gYXJyYXkgdGhhdCBhdm9pZHMgYmVpbmcgc3BhcnNlIGJ5IGFsd2F5c1xuICogZmlsbGluZyB1cCB1bnVzZWQgaW5kaWNlcyB3aXRoIGEgZGVmYXVsdCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpeGVkQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKF9kZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHQgPSBfZGVmYXVsdDtcbiAgICAgICAgdGhpcy5fc3RvcmUgPSBbXTtcbiAgICB9XG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuX3N0b3JlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdDtcbiAgICB9XG4gICAgc2V0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgICB3aGlsZSAoaW5kZXggPj0gdGhpcy5fc3RvcmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9yZVt0aGlzLl9zdG9yZS5sZW5ndGhdID0gdGhpcy5fZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9yZVtpbmRleF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmVwbGFjZShpbmRleCwgb2xkTGVuZ3RoLCBuZXdMZW5ndGgpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX3N0b3JlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGluZGV4LCBuZXdMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld0xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUoaW5kZXgsIG9sZExlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmVmb3JlID0gdGhpcy5fc3RvcmUuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICBjb25zdCBhZnRlciA9IHRoaXMuX3N0b3JlLnNsaWNlKGluZGV4ICsgb2xkTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaW5zZXJ0QXJyID0gYXJyYXlGaWxsKG5ld0xlbmd0aCwgdGhpcy5fZGVmYXVsdCk7XG4gICAgICAgIHRoaXMuX3N0b3JlID0gYmVmb3JlLmNvbmNhdChpbnNlcnRBcnIsIGFmdGVyKTtcbiAgICB9XG4gICAgZGVsZXRlKGRlbGV0ZUluZGV4LCBkZWxldGVDb3VudCkge1xuICAgICAgICBpZiAoZGVsZXRlQ291bnQgPT09IDAgfHwgZGVsZXRlSW5kZXggPj0gdGhpcy5fc3RvcmUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcmUuc3BsaWNlKGRlbGV0ZUluZGV4LCBkZWxldGVDb3VudCk7XG4gICAgfVxuICAgIGluc2VydChpbnNlcnRJbmRleCwgaW5zZXJ0Q291bnQpIHtcbiAgICAgICAgaWYgKGluc2VydENvdW50ID09PSAwIHx8IGluc2VydEluZGV4ID49IHRoaXMuX3N0b3JlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc2VydENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGFycltpXSA9IHRoaXMuX2RlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcmUgPSBhcnJheUluc2VydCh0aGlzLl9zdG9yZSwgaW5zZXJ0SW5kZXgsIGFycik7XG4gICAgfVxufVxuZnVuY3Rpb24gYXJyYXlGaWxsKGxlbmd0aCwgdmFsdWUpIHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBmaW5kTGFzdCB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2FycmF5c0ZpbmQuanMnO1xuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcbmltcG9ydCB7IEN1cnNvckNvbHVtbnMgfSBmcm9tICcuLi9jb3JlL2N1cnNvckNvbHVtbnMuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi9jb3JlL3JhbmdlLmpzJztcbmltcG9ydCB7IFRleHRNb2RlbFBhcnQgfSBmcm9tICcuL3RleHRNb2RlbFBhcnQuanMnO1xuaW1wb3J0IHsgY29tcHV0ZUluZGVudExldmVsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBIb3Jpem9udGFsR3VpZGVzU3RhdGUsIEluZGVudEd1aWRlLCBJbmRlbnRHdWlkZUhvcml6b250YWxMaW5lIH0gZnJvbSAnLi4vdGV4dE1vZGVsR3VpZGVzLmpzJztcbmltcG9ydCB7IEJ1Z0luZGljYXRpbmdFcnJvciB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2Vycm9ycy5qcyc7XG5leHBvcnQgY2xhc3MgR3VpZGVzVGV4dE1vZGVsUGFydCBleHRlbmRzIFRleHRNb2RlbFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKHRleHRNb2RlbCwgbGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRleHRNb2RlbCA9IHRleHRNb2RlbDtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gbGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG4gICAgZ2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uKGxhbmd1YWdlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZS5nZXRMYW5ndWFnZUNvbmZpZ3VyYXRpb24obGFuZ3VhZ2VJZCk7XG4gICAgfVxuICAgIF9jb21wdXRlSW5kZW50TGV2ZWwobGluZUluZGV4KSB7XG4gICAgICAgIHJldHVybiBjb21wdXRlSW5kZW50TGV2ZWwodGhpcy50ZXh0TW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZUluZGV4ICsgMSksIHRoaXMudGV4dE1vZGVsLmdldE9wdGlvbnMoKS50YWJTaXplKTtcbiAgICB9XG4gICAgZ2V0QWN0aXZlSW5kZW50R3VpZGUobGluZU51bWJlciwgbWluTGluZU51bWJlciwgbWF4TGluZU51bWJlcikge1xuICAgICAgICB0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMudGV4dE1vZGVsLmdldExpbmVDb3VudCgpO1xuICAgICAgICBpZiAobGluZU51bWJlciA8IDEgfHwgbGluZU51bWJlciA+IGxpbmVDb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcignSWxsZWdhbCB2YWx1ZSBmb3IgbGluZU51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvbGRpbmdSdWxlcyA9IHRoaXMuZ2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uKHRoaXMudGV4dE1vZGVsLmdldExhbmd1YWdlSWQoKSkuZm9sZGluZ1J1bGVzO1xuICAgICAgICBjb25zdCBvZmZTaWRlID0gQm9vbGVhbihmb2xkaW5nUnVsZXMgJiYgZm9sZGluZ1J1bGVzLm9mZlNpZGUpO1xuICAgICAgICBsZXQgdXBfYWJvdmVDb250ZW50TGluZUluZGV4ID0gLTI7IC8qIC0yIGlzIGEgbWFya2VyIGZvciBub3QgaGF2aW5nIGNvbXB1dGVkIGl0ICovXG4gICAgICAgIGxldCB1cF9hYm92ZUNvbnRlbnRMaW5lSW5kZW50ID0gLTE7XG4gICAgICAgIGxldCB1cF9iZWxvd0NvbnRlbnRMaW5lSW5kZXggPSAtMjsgLyogLTIgaXMgYSBtYXJrZXIgZm9yIG5vdCBoYXZpbmcgY29tcHV0ZWQgaXQgKi9cbiAgICAgICAgbGV0IHVwX2JlbG93Q29udGVudExpbmVJbmRlbnQgPSAtMTtcbiAgICAgICAgY29uc3QgdXBfcmVzb2x2ZUluZGVudHMgPSAobGluZU51bWJlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHVwX2Fib3ZlQ29udGVudExpbmVJbmRleCAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAodXBfYWJvdmVDb250ZW50TGluZUluZGV4ID09PSAtMiB8fFxuICAgICAgICAgICAgICAgICAgICB1cF9hYm92ZUNvbnRlbnRMaW5lSW5kZXggPiBsaW5lTnVtYmVyIC0gMSkpIHtcbiAgICAgICAgICAgICAgICB1cF9hYm92ZUNvbnRlbnRMaW5lSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICB1cF9hYm92ZUNvbnRlbnRMaW5lSW5kZW50ID0gLTE7XG4gICAgICAgICAgICAgICAgLy8gbXVzdCBmaW5kIHByZXZpb3VzIGxpbmUgd2l0aCBjb250ZW50XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbGluZUluZGV4ID0gbGluZU51bWJlciAtIDI7IGxpbmVJbmRleCA+PSAwOyBsaW5lSW5kZXgtLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRlbnQgPSB0aGlzLl9jb21wdXRlSW5kZW50TGV2ZWwobGluZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGVudCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cF9hYm92ZUNvbnRlbnRMaW5lSW5kZXggPSBsaW5lSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cF9hYm92ZUNvbnRlbnRMaW5lSW5kZW50ID0gaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBfYmVsb3dDb250ZW50TGluZUluZGV4ID09PSAtMikge1xuICAgICAgICAgICAgICAgIHVwX2JlbG93Q29udGVudExpbmVJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHVwX2JlbG93Q29udGVudExpbmVJbmRlbnQgPSAtMTtcbiAgICAgICAgICAgICAgICAvLyBtdXN0IGZpbmQgbmV4dCBsaW5lIHdpdGggY29udGVudFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGxpbmVJbmRleCA9IGxpbmVOdW1iZXI7IGxpbmVJbmRleCA8IGxpbmVDb3VudDsgbGluZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZW50ID0gdGhpcy5fY29tcHV0ZUluZGVudExldmVsKGxpbmVJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRlbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBfYmVsb3dDb250ZW50TGluZUluZGV4ID0gbGluZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBfYmVsb3dDb250ZW50TGluZUluZGVudCA9IGluZGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgZG93bl9hYm92ZUNvbnRlbnRMaW5lSW5kZXggPSAtMjsgLyogLTIgaXMgYSBtYXJrZXIgZm9yIG5vdCBoYXZpbmcgY29tcHV0ZWQgaXQgKi9cbiAgICAgICAgbGV0IGRvd25fYWJvdmVDb250ZW50TGluZUluZGVudCA9IC0xO1xuICAgICAgICBsZXQgZG93bl9iZWxvd0NvbnRlbnRMaW5lSW5kZXggPSAtMjsgLyogLTIgaXMgYSBtYXJrZXIgZm9yIG5vdCBoYXZpbmcgY29tcHV0ZWQgaXQgKi9cbiAgICAgICAgbGV0IGRvd25fYmVsb3dDb250ZW50TGluZUluZGVudCA9IC0xO1xuICAgICAgICBjb25zdCBkb3duX3Jlc29sdmVJbmRlbnRzID0gKGxpbmVOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChkb3duX2Fib3ZlQ29udGVudExpbmVJbmRleCA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICBkb3duX2Fib3ZlQ29udGVudExpbmVJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGRvd25fYWJvdmVDb250ZW50TGluZUluZGVudCA9IC0xO1xuICAgICAgICAgICAgICAgIC8vIG11c3QgZmluZCBwcmV2aW91cyBsaW5lIHdpdGggY29udGVudFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGxpbmVJbmRleCA9IGxpbmVOdW1iZXIgLSAyOyBsaW5lSW5kZXggPj0gMDsgbGluZUluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZW50ID0gdGhpcy5fY29tcHV0ZUluZGVudExldmVsKGxpbmVJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRlbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93bl9hYm92ZUNvbnRlbnRMaW5lSW5kZXggPSBsaW5lSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3duX2Fib3ZlQ29udGVudExpbmVJbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb3duX2JlbG93Q29udGVudExpbmVJbmRleCAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAoZG93bl9iZWxvd0NvbnRlbnRMaW5lSW5kZXggPT09IC0yIHx8XG4gICAgICAgICAgICAgICAgICAgIGRvd25fYmVsb3dDb250ZW50TGluZUluZGV4IDwgbGluZU51bWJlciAtIDEpKSB7XG4gICAgICAgICAgICAgICAgZG93bl9iZWxvd0NvbnRlbnRMaW5lSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBkb3duX2JlbG93Q29udGVudExpbmVJbmRlbnQgPSAtMTtcbiAgICAgICAgICAgICAgICAvLyBtdXN0IGZpbmQgbmV4dCBsaW5lIHdpdGggY29udGVudFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGxpbmVJbmRleCA9IGxpbmVOdW1iZXI7IGxpbmVJbmRleCA8IGxpbmVDb3VudDsgbGluZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZW50ID0gdGhpcy5fY29tcHV0ZUluZGVudExldmVsKGxpbmVJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRlbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93bl9iZWxvd0NvbnRlbnRMaW5lSW5kZXggPSBsaW5lSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3duX2JlbG93Q29udGVudExpbmVJbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHN0YXJ0TGluZU51bWJlciA9IDA7XG4gICAgICAgIGxldCBnb1VwID0gdHJ1ZTtcbiAgICAgICAgbGV0IGVuZExpbmVOdW1iZXIgPSAwO1xuICAgICAgICBsZXQgZ29Eb3duID0gdHJ1ZTtcbiAgICAgICAgbGV0IGluZGVudCA9IDA7XG4gICAgICAgIGxldCBpbml0aWFsSW5kZW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgZGlzdGFuY2UgPSAwOyBnb1VwIHx8IGdvRG93bjsgZGlzdGFuY2UrKykge1xuICAgICAgICAgICAgY29uc3QgdXBMaW5lTnVtYmVyID0gbGluZU51bWJlciAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgY29uc3QgZG93bkxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyICsgZGlzdGFuY2U7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAxICYmICh1cExpbmVOdW1iZXIgPCAxIHx8IHVwTGluZU51bWJlciA8IG1pbkxpbmVOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgZ29VcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMSAmJlxuICAgICAgICAgICAgICAgIChkb3duTGluZU51bWJlciA+IGxpbmVDb3VudCB8fCBkb3duTGluZU51bWJlciA+IG1heExpbmVOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgZ29Eb3duID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiA1MDAwMCkge1xuICAgICAgICAgICAgICAgIC8vIHN0b3AgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgIGdvVXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBnb0Rvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB1cExpbmVJbmRlbnRMZXZlbCA9IC0xO1xuICAgICAgICAgICAgaWYgKGdvVXAgJiYgdXBMaW5lTnVtYmVyID49IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21wdXRlIGluZGVudCBsZXZlbCBnb2luZyB1cFxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRlbnQgPSB0aGlzLl9jb21wdXRlSW5kZW50TGV2ZWwodXBMaW5lTnVtYmVyIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRlbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGxpbmUgaGFzIGNvbnRlbnQgKGJlc2lkZXMgd2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBsaW5lJ3MgaW5kZW50XG4gICAgICAgICAgICAgICAgICAgIHVwX2JlbG93Q29udGVudExpbmVJbmRleCA9IHVwTGluZU51bWJlciAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHVwX2JlbG93Q29udGVudExpbmVJbmRlbnQgPSBjdXJyZW50SW5kZW50O1xuICAgICAgICAgICAgICAgICAgICB1cExpbmVJbmRlbnRMZXZlbCA9IE1hdGguY2VpbChjdXJyZW50SW5kZW50IC8gdGhpcy50ZXh0TW9kZWwuZ2V0T3B0aW9ucygpLmluZGVudFNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBfcmVzb2x2ZUluZGVudHModXBMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdXBMaW5lSW5kZW50TGV2ZWwgPSB0aGlzLl9nZXRJbmRlbnRMZXZlbEZvcldoaXRlc3BhY2VMaW5lKG9mZlNpZGUsIHVwX2Fib3ZlQ29udGVudExpbmVJbmRlbnQsIHVwX2JlbG93Q29udGVudExpbmVJbmRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkb3duTGluZUluZGVudExldmVsID0gLTE7XG4gICAgICAgICAgICBpZiAoZ29Eb3duICYmIGRvd25MaW5lTnVtYmVyIDw9IGxpbmVDb3VudCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgaW5kZW50IGxldmVsIGdvaW5nIGRvd25cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50SW5kZW50ID0gdGhpcy5fY29tcHV0ZUluZGVudExldmVsKGRvd25MaW5lTnVtYmVyIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRlbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGxpbmUgaGFzIGNvbnRlbnQgKGJlc2lkZXMgd2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBsaW5lJ3MgaW5kZW50XG4gICAgICAgICAgICAgICAgICAgIGRvd25fYWJvdmVDb250ZW50TGluZUluZGV4ID0gZG93bkxpbmVOdW1iZXIgLSAxO1xuICAgICAgICAgICAgICAgICAgICBkb3duX2Fib3ZlQ29udGVudExpbmVJbmRlbnQgPSBjdXJyZW50SW5kZW50O1xuICAgICAgICAgICAgICAgICAgICBkb3duTGluZUluZGVudExldmVsID0gTWF0aC5jZWlsKGN1cnJlbnRJbmRlbnQgLyB0aGlzLnRleHRNb2RlbC5nZXRPcHRpb25zKCkuaW5kZW50U2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb3duX3Jlc29sdmVJbmRlbnRzKGRvd25MaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZG93bkxpbmVJbmRlbnRMZXZlbCA9IHRoaXMuX2dldEluZGVudExldmVsRm9yV2hpdGVzcGFjZUxpbmUob2ZmU2lkZSwgZG93bl9hYm92ZUNvbnRlbnRMaW5lSW5kZW50LCBkb3duX2JlbG93Q29udGVudExpbmVJbmRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGluaXRpYWxJbmRlbnQgPSB1cExpbmVJbmRlbnRMZXZlbDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChkb3duTGluZU51bWJlciA8PSBsaW5lQ291bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgZG93bkxpbmVJbmRlbnRMZXZlbCA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRlbnQgKyAxID09PSBkb3duTGluZUluZGVudExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGJlZ2lubmluZyBvZiBhIHNjb3BlLCB3ZSBoYXZlIHNwZWNpYWwgaGFuZGxpbmcgaGVyZSwgc2luY2Ugd2Ugd2FudCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hpbGQgc2NvcGUgaW5kZW50IHRvIGJlIGFjdGl2ZSwgbm90IHRoZSBwYXJlbnQgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgZ29VcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBkb3duTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgZW5kTGluZU51bWJlciA9IGRvd25MaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSBkb3duTGluZUluZGVudExldmVsO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVwTGluZU51bWJlciA+PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIHVwTGluZUluZGVudExldmVsID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdXBMaW5lSW5kZW50TGV2ZWwgLSAxID09PSBpbml0aWFsSW5kZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGVuZCBvZiBhIHNjb3BlLCBqdXN0IGxpa2UgYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgZ29Eb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlciA9IHVwTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgZW5kTGluZU51bWJlciA9IHVwTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gdXBMaW5lSW5kZW50TGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGluZGVudCA9IGluaXRpYWxJbmRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGluZGVudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0TGluZU51bWJlciwgZW5kTGluZU51bWJlciwgaW5kZW50IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdvVXApIHtcbiAgICAgICAgICAgICAgICBpZiAodXBMaW5lSW5kZW50TGV2ZWwgPj0gaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlciA9IHVwTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdvVXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ29Eb3duKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvd25MaW5lSW5kZW50TGV2ZWwgPj0gaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBkb3duTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdvRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGFydExpbmVOdW1iZXIsIGVuZExpbmVOdW1iZXIsIGluZGVudCB9O1xuICAgIH1cbiAgICBnZXRMaW5lc0JyYWNrZXRHdWlkZXMoc3RhcnRMaW5lTnVtYmVyLCBlbmRMaW5lTnVtYmVyLCBhY3RpdmVQb3NpdGlvbiwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjsgbGluZU51bWJlciA8PSBlbmRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiByZXF1ZXN0ZWQsIHRoaXMgY291bGQgYmUgbWFkZSBjb25maWd1cmFibGUuXG4gICAgICAgIGNvbnN0IGluY2x1ZGVTaW5nbGVMaW5lUGFpcnMgPSB0cnVlO1xuICAgICAgICBjb25zdCBicmFja2V0UGFpcnMgPSB0aGlzLnRleHRNb2RlbC5icmFja2V0UGFpcnMuZ2V0QnJhY2tldFBhaXJzSW5SYW5nZVdpdGhNaW5JbmRlbnRhdGlvbihuZXcgUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCAxLCBlbmRMaW5lTnVtYmVyLCB0aGlzLnRleHRNb2RlbC5nZXRMaW5lTWF4Q29sdW1uKGVuZExpbmVOdW1iZXIpKSkudG9BcnJheSgpO1xuICAgICAgICBsZXQgYWN0aXZlQnJhY2tldFBhaXJSYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGFjdGl2ZVBvc2l0aW9uICYmIGJyYWNrZXRQYWlycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBicmFja2V0c0NvbnRhaW5pbmdBY3RpdmVQb3NpdGlvbiA9IChzdGFydExpbmVOdW1iZXIgPD0gYWN0aXZlUG9zaXRpb24ubGluZU51bWJlciAmJlxuICAgICAgICAgICAgICAgIGFjdGl2ZVBvc2l0aW9uLmxpbmVOdW1iZXIgPD0gZW5kTGluZU51bWJlclxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcXVlcnkgdGhlIGJyYWNrZXRzIGFnYWluIGlmIHRoZSBjdXJzb3IgaXMgaW4gdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgPyBicmFja2V0UGFpcnNcbiAgICAgICAgICAgICAgICA6IHRoaXMudGV4dE1vZGVsLmJyYWNrZXRQYWlycy5nZXRCcmFja2V0UGFpcnNJblJhbmdlKFJhbmdlLmZyb21Qb3NpdGlvbnMoYWN0aXZlUG9zaXRpb24pKS50b0FycmF5KCkpLmZpbHRlcigoYnApID0+IFJhbmdlLnN0cmljdENvbnRhaW5zUG9zaXRpb24oYnAucmFuZ2UsIGFjdGl2ZVBvc2l0aW9uKSk7XG4gICAgICAgICAgICBhY3RpdmVCcmFja2V0UGFpclJhbmdlID0gZmluZExhc3QoYnJhY2tldHNDb250YWluaW5nQWN0aXZlUG9zaXRpb24sIChpKSA9PiBpbmNsdWRlU2luZ2xlTGluZVBhaXJzIHx8IGkucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICE9PSBpLnJhbmdlLmVuZExpbmVOdW1iZXIpPy5yYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRlcGVuZGVudENvbG9yUG9vbFBlckJyYWNrZXRUeXBlID0gdGhpcy50ZXh0TW9kZWwuZ2V0T3B0aW9ucygpLmJyYWNrZXRQYWlyQ29sb3JpemF0aW9uT3B0aW9ucy5pbmRlcGVuZGVudENvbG9yUG9vbFBlckJyYWNrZXRUeXBlO1xuICAgICAgICBjb25zdCBjb2xvclByb3ZpZGVyID0gbmV3IEJyYWNrZXRQYWlyR3VpZGVzQ2xhc3NOYW1lcygpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgYnJhY2tldFBhaXJzKSB7XG4gICAgICAgICAgICAvKlxuXG5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgLS0tLX1cblxuICAgICAgICAgICAgICAgIF9fX197XG4gICAgICAgICAgICAgICAgfHRlc3RcbiAgICAgICAgICAgICAgICAtLS0tfVxuXG4gICAgICAgICAgICAgICAgcmVuZGVySG9yaXpvbnRhbEVuZExpbmVBdFRoZUJvdHRvbTpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgIHx4fVxuICAgICAgICAgICAgICAgICAgICAtLVxuICAgICAgICAgICAgICAgIHJlbmRlckhvcml6b250YWxFbmRMaW5lQXRUaGVCb3R0b206XG4gICAgICAgICAgICAgICAgX19fX3tcbiAgICAgICAgICAgICAgICB8dGVzdFxuICAgICAgICAgICAgICAgIHwgeCB9XG4gICAgICAgICAgICAgICAgLS0tLVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghcGFpci5jbG9zaW5nQnJhY2tldFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IGFjdGl2ZUJyYWNrZXRQYWlyUmFuZ2UgJiYgcGFpci5yYW5nZS5lcXVhbHNSYW5nZShhY3RpdmVCcmFja2V0UGFpclJhbmdlKTtcbiAgICAgICAgICAgIGlmICghaXNBY3RpdmUgJiYgIW9wdGlvbnMuaW5jbHVkZUluYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjb2xvclByb3ZpZGVyLmdldElubGluZUNsYXNzTmFtZShwYWlyLm5lc3RpbmdMZXZlbCwgcGFpci5uZXN0aW5nTGV2ZWxPZkVxdWFsQnJhY2tldFR5cGUsIGluZGVwZW5kZW50Q29sb3JQb29sUGVyQnJhY2tldFR5cGUpICtcbiAgICAgICAgICAgICAgICAob3B0aW9ucy5oaWdobGlnaHRBY3RpdmUgJiYgaXNBY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgPyAnICcgKyBjb2xvclByb3ZpZGVyLmFjdGl2ZUNsYXNzTmFtZVxuICAgICAgICAgICAgICAgICAgICA6ICcnKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcGFpci5vcGVuaW5nQnJhY2tldFJhbmdlLmdldFN0YXJ0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHBhaXIuY2xvc2luZ0JyYWNrZXRSYW5nZS5nZXRTdGFydFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBob3Jpem9udGFsR3VpZGVzID0gb3B0aW9ucy5ob3Jpem9udGFsR3VpZGVzID09PSBIb3Jpem9udGFsR3VpZGVzU3RhdGUuRW5hYmxlZCB8fCAob3B0aW9ucy5ob3Jpem9udGFsR3VpZGVzID09PSBIb3Jpem9udGFsR3VpZGVzU3RhdGUuRW5hYmxlZEZvckFjdGl2ZSAmJiBpc0FjdGl2ZSk7XG4gICAgICAgICAgICBpZiAocGFpci5yYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHBhaXIucmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlU2luZ2xlTGluZVBhaXJzICYmIGhvcml6b250YWxHdWlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3BhaXIucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gc3RhcnRMaW5lTnVtYmVyXS5wdXNoKG5ldyBJbmRlbnRHdWlkZSgtMSwgcGFpci5vcGVuaW5nQnJhY2tldFJhbmdlLmdldEVuZFBvc2l0aW9uKCkuY29sdW1uLCBjbGFzc05hbWUsIG5ldyBJbmRlbnRHdWlkZUhvcml6b250YWxMaW5lKGZhbHNlLCBlbmQuY29sdW1uKSwgLTEsIC0xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW5kVmlzaWJsZUNvbHVtbiA9IHRoaXMuZ2V0VmlzaWJsZUNvbHVtbkZyb21Qb3NpdGlvbihlbmQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRWaXNpYmxlQ29sdW1uID0gdGhpcy5nZXRWaXNpYmxlQ29sdW1uRnJvbVBvc2l0aW9uKHBhaXIub3BlbmluZ0JyYWNrZXRSYW5nZS5nZXRTdGFydFBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgY29uc3QgZ3VpZGVWaXNpYmxlQ29sdW1uID0gTWF0aC5taW4oc3RhcnRWaXNpYmxlQ29sdW1uLCBlbmRWaXNpYmxlQ29sdW1uLCBwYWlyLm1pblZpc2libGVDb2x1bW5JbmRlbnRhdGlvbiArIDEpO1xuICAgICAgICAgICAgbGV0IHJlbmRlckhvcml6b250YWxFbmRMaW5lQXRUaGVCb3R0b20gPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Tm9uV3NJbmRleCA9IHN0cmluZ3MuZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXgodGhpcy50ZXh0TW9kZWwuZ2V0TGluZUNvbnRlbnQocGFpci5jbG9zaW5nQnJhY2tldFJhbmdlLnN0YXJ0TGluZU51bWJlcikpO1xuICAgICAgICAgICAgY29uc3QgaGFzVGV4dEJlZm9yZUNsb3NpbmdCcmFja2V0ID0gZmlyc3ROb25Xc0luZGV4IDwgcGFpci5jbG9zaW5nQnJhY2tldFJhbmdlLnN0YXJ0Q29sdW1uIC0gMTtcbiAgICAgICAgICAgIGlmIChoYXNUZXh0QmVmb3JlQ2xvc2luZ0JyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJIb3Jpem9udGFsRW5kTGluZUF0VGhlQm90dG9tID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVHdWlkZVN0YXJ0TGluZU51bWJlciA9IE1hdGgubWF4KHN0YXJ0LmxpbmVOdW1iZXIsIHN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlR3VpZGVFbmRMaW5lTnVtYmVyID0gTWF0aC5taW4oZW5kLmxpbmVOdW1iZXIsIGVuZExpbmVOdW1iZXIpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcmVuZGVySG9yaXpvbnRhbEVuZExpbmVBdFRoZUJvdHRvbSA/IDEgOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgbCA9IHZpc2libGVHdWlkZVN0YXJ0TGluZU51bWJlcjsgbCA8IHZpc2libGVHdWlkZUVuZExpbmVOdW1iZXIgKyBvZmZzZXQ7IGwrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtsIC0gc3RhcnRMaW5lTnVtYmVyXS5wdXNoKG5ldyBJbmRlbnRHdWlkZShndWlkZVZpc2libGVDb2x1bW4sIC0xLCBjbGFzc05hbWUsIG51bGwsIGwgPT09IHN0YXJ0LmxpbmVOdW1iZXIgPyBzdGFydC5jb2x1bW4gOiAtMSwgbCA9PT0gZW5kLmxpbmVOdW1iZXIgPyBlbmQuY29sdW1uIDogLTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsR3VpZGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0LmxpbmVOdW1iZXIgPj0gc3RhcnRMaW5lTnVtYmVyICYmIHN0YXJ0VmlzaWJsZUNvbHVtbiA+IGd1aWRlVmlzaWJsZUNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbc3RhcnQubGluZU51bWJlciAtIHN0YXJ0TGluZU51bWJlcl0ucHVzaChuZXcgSW5kZW50R3VpZGUoZ3VpZGVWaXNpYmxlQ29sdW1uLCAtMSwgY2xhc3NOYW1lLCBuZXcgSW5kZW50R3VpZGVIb3Jpem9udGFsTGluZShmYWxzZSwgc3RhcnQuY29sdW1uKSwgLTEsIC0xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmQubGluZU51bWJlciA8PSBlbmRMaW5lTnVtYmVyICYmIGVuZFZpc2libGVDb2x1bW4gPiBndWlkZVZpc2libGVDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2VuZC5saW5lTnVtYmVyIC0gc3RhcnRMaW5lTnVtYmVyXS5wdXNoKG5ldyBJbmRlbnRHdWlkZShndWlkZVZpc2libGVDb2x1bW4sIC0xLCBjbGFzc05hbWUsIG5ldyBJbmRlbnRHdWlkZUhvcml6b250YWxMaW5lKCFyZW5kZXJIb3Jpem9udGFsRW5kTGluZUF0VGhlQm90dG9tLCBlbmQuY29sdW1uKSwgLTEsIC0xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZ3VpZGVzIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgZ3VpZGVzLnNvcnQoKGEsIGIpID0+IGEudmlzaWJsZUNvbHVtbiAtIGIudmlzaWJsZUNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZUNvbHVtbkZyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gKEN1cnNvckNvbHVtbnMudmlzaWJsZUNvbHVtbkZyb21Db2x1bW4odGhpcy50ZXh0TW9kZWwuZ2V0TGluZUNvbnRlbnQocG9zaXRpb24ubGluZU51bWJlciksIHBvc2l0aW9uLmNvbHVtbiwgdGhpcy50ZXh0TW9kZWwuZ2V0T3B0aW9ucygpLnRhYlNpemUpICsgMSk7XG4gICAgfVxuICAgIGdldExpbmVzSW5kZW50R3VpZGVzKHN0YXJ0TGluZU51bWJlciwgZW5kTGluZU51bWJlcikge1xuICAgICAgICB0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMudGV4dE1vZGVsLmdldExpbmVDb3VudCgpO1xuICAgICAgICBpZiAoc3RhcnRMaW5lTnVtYmVyIDwgMSB8fCBzdGFydExpbmVOdW1iZXIgPiBsaW5lQ291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCB2YWx1ZSBmb3Igc3RhcnRMaW5lTnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZExpbmVOdW1iZXIgPCAxIHx8IGVuZExpbmVOdW1iZXIgPiBsaW5lQ291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCB2YWx1ZSBmb3IgZW5kTGluZU51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnRleHRNb2RlbC5nZXRPcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IGZvbGRpbmdSdWxlcyA9IHRoaXMuZ2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uKHRoaXMudGV4dE1vZGVsLmdldExhbmd1YWdlSWQoKSkuZm9sZGluZ1J1bGVzO1xuICAgICAgICBjb25zdCBvZmZTaWRlID0gQm9vbGVhbihmb2xkaW5nUnVsZXMgJiYgZm9sZGluZ1J1bGVzLm9mZlNpZGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoZW5kTGluZU51bWJlciAtIHN0YXJ0TGluZU51bWJlciArIDEpO1xuICAgICAgICBsZXQgYWJvdmVDb250ZW50TGluZUluZGV4ID0gLTI7IC8qIC0yIGlzIGEgbWFya2VyIGZvciBub3QgaGF2aW5nIGNvbXB1dGVkIGl0ICovXG4gICAgICAgIGxldCBhYm92ZUNvbnRlbnRMaW5lSW5kZW50ID0gLTE7XG4gICAgICAgIGxldCBiZWxvd0NvbnRlbnRMaW5lSW5kZXggPSAtMjsgLyogLTIgaXMgYSBtYXJrZXIgZm9yIG5vdCBoYXZpbmcgY29tcHV0ZWQgaXQgKi9cbiAgICAgICAgbGV0IGJlbG93Q29udGVudExpbmVJbmRlbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgbGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjsgbGluZU51bWJlciA8PSBlbmRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdEluZGV4ID0gbGluZU51bWJlciAtIHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRlbnQgPSB0aGlzLl9jb21wdXRlSW5kZW50TGV2ZWwobGluZU51bWJlciAtIDEpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRlbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbGluZSBoYXMgY29udGVudCAoYmVzaWRlcyB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgbGluZSdzIGluZGVudFxuICAgICAgICAgICAgICAgIGFib3ZlQ29udGVudExpbmVJbmRleCA9IGxpbmVOdW1iZXIgLSAxO1xuICAgICAgICAgICAgICAgIGFib3ZlQ29udGVudExpbmVJbmRlbnQgPSBjdXJyZW50SW5kZW50O1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRJbmRleF0gPSBNYXRoLmNlaWwoY3VycmVudEluZGVudCAvIG9wdGlvbnMuaW5kZW50U2l6ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvdmVDb250ZW50TGluZUluZGV4ID09PSAtMikge1xuICAgICAgICAgICAgICAgIGFib3ZlQ29udGVudExpbmVJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGFib3ZlQ29udGVudExpbmVJbmRlbnQgPSAtMTtcbiAgICAgICAgICAgICAgICAvLyBtdXN0IGZpbmQgcHJldmlvdXMgbGluZSB3aXRoIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsaW5lSW5kZXggPSBsaW5lTnVtYmVyIC0gMjsgbGluZUluZGV4ID49IDA7IGxpbmVJbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGVudCA9IHRoaXMuX2NvbXB1dGVJbmRlbnRMZXZlbChsaW5lSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZW50ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3ZlQ29udGVudExpbmVJbmRleCA9IGxpbmVJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3ZlQ29udGVudExpbmVJbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiZWxvd0NvbnRlbnRMaW5lSW5kZXggIT09IC0xICYmXG4gICAgICAgICAgICAgICAgKGJlbG93Q29udGVudExpbmVJbmRleCA9PT0gLTIgfHwgYmVsb3dDb250ZW50TGluZUluZGV4IDwgbGluZU51bWJlciAtIDEpKSB7XG4gICAgICAgICAgICAgICAgYmVsb3dDb250ZW50TGluZUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgYmVsb3dDb250ZW50TGluZUluZGVudCA9IC0xO1xuICAgICAgICAgICAgICAgIC8vIG11c3QgZmluZCBuZXh0IGxpbmUgd2l0aCBjb250ZW50XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbGluZUluZGV4ID0gbGluZU51bWJlcjsgbGluZUluZGV4IDwgbGluZUNvdW50OyBsaW5lSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRlbnQgPSB0aGlzLl9jb21wdXRlSW5kZW50TGV2ZWwobGluZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGVudCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWxvd0NvbnRlbnRMaW5lSW5kZXggPSBsaW5lSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWxvd0NvbnRlbnRMaW5lSW5kZW50ID0gaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0SW5kZXhdID0gdGhpcy5fZ2V0SW5kZW50TGV2ZWxGb3JXaGl0ZXNwYWNlTGluZShvZmZTaWRlLCBhYm92ZUNvbnRlbnRMaW5lSW5kZW50LCBiZWxvd0NvbnRlbnRMaW5lSW5kZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfZ2V0SW5kZW50TGV2ZWxGb3JXaGl0ZXNwYWNlTGluZShvZmZTaWRlLCBhYm92ZUNvbnRlbnRMaW5lSW5kZW50LCBiZWxvd0NvbnRlbnRMaW5lSW5kZW50KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnRleHRNb2RlbC5nZXRPcHRpb25zKCk7XG4gICAgICAgIGlmIChhYm92ZUNvbnRlbnRMaW5lSW5kZW50ID09PSAtMSB8fCBiZWxvd0NvbnRlbnRMaW5lSW5kZW50ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gQXQgdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIGZpbGVcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFib3ZlQ29udGVudExpbmVJbmRlbnQgPCBiZWxvd0NvbnRlbnRMaW5lSW5kZW50KSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgaW5zaWRlIHRoZSByZWdpb24gYWJvdmVcbiAgICAgICAgICAgIHJldHVybiAxICsgTWF0aC5mbG9vcihhYm92ZUNvbnRlbnRMaW5lSW5kZW50IC8gb3B0aW9ucy5pbmRlbnRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhYm92ZUNvbnRlbnRMaW5lSW5kZW50ID09PSBiZWxvd0NvbnRlbnRMaW5lSW5kZW50KSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgaW4gYmV0d2VlbiB0d28gcmVnaW9uc1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChiZWxvd0NvbnRlbnRMaW5lSW5kZW50IC8gb3B0aW9ucy5pbmRlbnRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvZmZTaWRlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2FtZSBsZXZlbCBhcyByZWdpb24gYmVsb3dcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGJlbG93Q29udGVudExpbmVJbmRlbnQgLyBvcHRpb25zLmluZGVudFNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIGluc2lkZSB0aGUgcmVnaW9uIHRoYXQgZW5kcyBiZWxvd1xuICAgICAgICAgICAgICAgIHJldHVybiAxICsgTWF0aC5mbG9vcihiZWxvd0NvbnRlbnRMaW5lSW5kZW50IC8gb3B0aW9ucy5pbmRlbnRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCcmFja2V0UGFpckd1aWRlc0NsYXNzTmFtZXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUNsYXNzTmFtZSA9ICdpbmRlbnQtYWN0aXZlJztcbiAgICB9XG4gICAgZ2V0SW5saW5lQ2xhc3NOYW1lKG5lc3RpbmdMZXZlbCwgbmVzdGluZ0xldmVsT2ZFcXVhbEJyYWNrZXRUeXBlLCBpbmRlcGVuZGVudENvbG9yUG9vbFBlckJyYWNrZXRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldElubGluZUNsYXNzTmFtZU9mTGV2ZWwoaW5kZXBlbmRlbnRDb2xvclBvb2xQZXJCcmFja2V0VHlwZSA/IG5lc3RpbmdMZXZlbE9mRXF1YWxCcmFja2V0VHlwZSA6IG5lc3RpbmdMZXZlbCk7XG4gICAgfVxuICAgIGdldElubGluZUNsYXNzTmFtZU9mTGV2ZWwobGV2ZWwpIHtcbiAgICAgICAgLy8gVG8gc3VwcG9ydCBhIGR5bmFtaWMgYW1vdW50IG9mIGNvbG9ycyB1cCB0byA2IGNvbG9ycyxcbiAgICAgICAgLy8gd2UgdXNlIGEgbnVtYmVyIHRoYXQgaXMgYSBsY20gb2YgYWxsIG51bWJlcnMgZnJvbSAxIHRvIDYuXG4gICAgICAgIHJldHVybiBgYnJhY2tldC1pbmRlbnQtZ3VpZGUgbHZsLSR7bGV2ZWwgJSAzMH1gO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuY2xhc3MgU3BhY2VzRGlmZlJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3BhY2VzRGlmZiA9IDA7XG4gICAgICAgIHRoaXMubG9va3NMaWtlQWxpZ25tZW50ID0gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBkaWZmIGluIHNwYWNlcyBiZXR3ZWVuIHR3byBsaW5lJ3MgaW5kZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIHNwYWNlc0RpZmYoYSwgYUxlbmd0aCwgYiwgYkxlbmd0aCwgcmVzdWx0KSB7XG4gICAgcmVzdWx0LnNwYWNlc0RpZmYgPSAwO1xuICAgIHJlc3VsdC5sb29rc0xpa2VBbGlnbm1lbnQgPSBmYWxzZTtcbiAgICAvLyBUaGlzIGNhbiBnbyBib3RoIHdheXMgKGUuZy4pOlxuICAgIC8vICAtIGE6IFwiXFx0XCJcbiAgICAvLyAgLSBiOiBcIlxcdCAgICBcIlxuICAgIC8vICA9PiBUaGlzIHNob3VsZCBjb3VudCAxIHRhYiBhbmQgNCBzcGFjZXNcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYUxlbmd0aCAmJiBpIDwgYkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFDaGFyQ29kZSA9IGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgY29uc3QgYkNoYXJDb2RlID0gYi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYUNoYXJDb2RlICE9PSBiQ2hhckNvZGUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBhU3BhY2VzQ250ID0gMCwgYVRhYnNDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPCBhTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgYUNoYXJDb2RlID0gYS5jaGFyQ29kZUF0KGopO1xuICAgICAgICBpZiAoYUNoYXJDb2RlID09PSAzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLykge1xuICAgICAgICAgICAgYVNwYWNlc0NudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYVRhYnNDb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBiU3BhY2VzQ250ID0gMCwgYlRhYnNDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPCBiTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgYkNoYXJDb2RlID0gYi5jaGFyQ29kZUF0KGopO1xuICAgICAgICBpZiAoYkNoYXJDb2RlID09PSAzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLykge1xuICAgICAgICAgICAgYlNwYWNlc0NudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYlRhYnNDb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhU3BhY2VzQ250ID4gMCAmJiBhVGFic0NvdW50ID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChiU3BhY2VzQ250ID4gMCAmJiBiVGFic0NvdW50ID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhYnNEaWZmID0gTWF0aC5hYnMoYVRhYnNDb3VudCAtIGJUYWJzQ291bnQpO1xuICAgIGNvbnN0IHNwYWNlc0RpZmYgPSBNYXRoLmFicyhhU3BhY2VzQ250IC0gYlNwYWNlc0NudCk7XG4gICAgaWYgKHRhYnNEaWZmID09PSAwKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbmRlbnRhdGlvbiBkaWZmZXJlbmNlIG1pZ2h0IGJlIGNhdXNlZCBieSBhbGlnbm1lbnQgcmVhc29uc1xuICAgICAgICAvLyBzb21ldGltZSBmb2xrcyBsaWtlIHRvIGFsaWduIHRoZWlyIGNvZGUsIGJ1dCB0aGlzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBhIGhpbnRcbiAgICAgICAgcmVzdWx0LnNwYWNlc0RpZmYgPSBzcGFjZXNEaWZmO1xuICAgICAgICBpZiAoc3BhY2VzRGlmZiA+IDAgJiYgMCA8PSBiU3BhY2VzQ250IC0gMSAmJiBiU3BhY2VzQ250IC0gMSA8IGEubGVuZ3RoICYmIGJTcGFjZXNDbnQgPCBiLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGIuY2hhckNvZGVBdChiU3BhY2VzQ250KSAhPT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8gJiYgYS5jaGFyQ29kZUF0KGJTcGFjZXNDbnQgLSAxKSA9PT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5jaGFyQ29kZUF0KGEubGVuZ3RoIC0gMSkgPT09IDQ0IC8qIENoYXJDb2RlLkNvbW1hICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSBhbiBhbGlnbm1lbnQgZGVzaXJlOiBlLmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGEgPSBiICsgYyxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgZCA9IGIgLSBjO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubG9va3NMaWtlQWxpZ25tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3BhY2VzRGlmZiAlIHRhYnNEaWZmID09PSAwKSB7XG4gICAgICAgIHJlc3VsdC5zcGFjZXNEaWZmID0gc3BhY2VzRGlmZiAvIHRhYnNEaWZmO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGd1ZXNzSW5kZW50YXRpb24oc291cmNlLCBkZWZhdWx0VGFiU2l6ZSwgZGVmYXVsdEluc2VydFNwYWNlcykge1xuICAgIC8vIExvb2sgYXQgbW9zdCBhdCB0aGUgZmlyc3QgMTBrIGxpbmVzXG4gICAgY29uc3QgbGluZXNDb3VudCA9IE1hdGgubWluKHNvdXJjZS5nZXRMaW5lQ291bnQoKSwgMTAwMDApO1xuICAgIGxldCBsaW5lc0luZGVudGVkV2l0aFRhYnNDb3VudCA9IDA7IC8vIG51bWJlciBvZiBsaW5lcyB0aGF0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHRhYiBpbiBpbmRlbnRhdGlvblxuICAgIGxldCBsaW5lc0luZGVudGVkV2l0aFNwYWNlc0NvdW50ID0gMDsgLy8gbnVtYmVyIG9mIGxpbmVzIHRoYXQgY29udGFpbiBvbmx5IHNwYWNlcyBpbiBpbmRlbnRhdGlvblxuICAgIGxldCBwcmV2aW91c0xpbmVUZXh0ID0gJyc7IC8vIGNvbnRlbnQgb2YgbGF0ZXN0IGxpbmUgdGhhdCBjb250YWluZWQgbm9uLXdoaXRlc3BhY2UgY2hhcnNcbiAgICBsZXQgcHJldmlvdXNMaW5lSW5kZW50YXRpb24gPSAwOyAvLyBpbmRleCBhdCB3aGljaCBsYXRlc3QgbGluZSBjb250YWluZWQgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlIGNoYXJcbiAgICBjb25zdCBBTExPV0VEX1RBQl9TSVpFX0dVRVNTRVMgPSBbMiwgNCwgNiwgOCwgMywgNSwgN107IC8vIHByZWZlciBldmVuIGd1ZXNzZXMgZm9yIGB0YWJTaXplYCwgbGltaXQgdG8gWzIsIDhdLlxuICAgIGNvbnN0IE1BWF9BTExPV0VEX1RBQl9TSVpFX0dVRVNTID0gODsgLy8gbWF4KEFMTE9XRURfVEFCX1NJWkVfR1VFU1NFUykgPSA4XG4gICAgY29uc3Qgc3BhY2VzRGlmZkNvdW50ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdOyAvLyBgdGFiU2l6ZWAgc2NvcmVzXG4gICAgY29uc3QgdG1wID0gbmV3IFNwYWNlc0RpZmZSZXN1bHQoKTtcbiAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gMTsgbGluZU51bWJlciA8PSBsaW5lc0NvdW50OyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudExpbmVMZW5ndGggPSBzb3VyY2UuZ2V0TGluZUxlbmd0aChsaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgY3VycmVudExpbmVUZXh0ID0gc291cmNlLmdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpO1xuICAgICAgICAvLyBpZiB0aGUgdGV4dCBidWZmZXIgaXMgY2h1bmsgYmFzZWQsIHNvIGxvbmcgbGluZXMgYXJlIGNvbnMtc3RyaW5nLCB2OCB3aWxsIGZsYXR0ZXJuIHRoZSBzdHJpbmcgd2hlbiB3ZSBjaGVjayBjaGFyQ29kZS5cbiAgICAgICAgLy8gY2hlY2tpbmcgY2hhckNvZGUgb24gY2h1bmtzIGRpcmVjdGx5IGlzIGNoZWFwZXIuXG4gICAgICAgIGNvbnN0IHVzZUN1cnJlbnRMaW5lVGV4dCA9IChjdXJyZW50TGluZUxlbmd0aCA8PSA2NTUzNik7XG4gICAgICAgIGxldCBjdXJyZW50TGluZUhhc0NvbnRlbnQgPSBmYWxzZTsgLy8gZG9lcyBgY3VycmVudExpbmVUZXh0YCBjb250YWluIG5vbi13aGl0ZXNwYWNlIGNoYXJzXG4gICAgICAgIGxldCBjdXJyZW50TGluZUluZGVudGF0aW9uID0gMDsgLy8gaW5kZXggYXQgd2hpY2ggYGN1cnJlbnRMaW5lVGV4dGAgY29udGFpbnMgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlIGNoYXJcbiAgICAgICAgbGV0IGN1cnJlbnRMaW5lU3BhY2VzQ291bnQgPSAwOyAvLyBjb3VudCBvZiBzcGFjZXMgZm91bmQgaW4gYGN1cnJlbnRMaW5lVGV4dGAgaW5kZW50YXRpb25cbiAgICAgICAgbGV0IGN1cnJlbnRMaW5lVGFic0NvdW50ID0gMDsgLy8gY291bnQgb2YgdGFicyBmb3VuZCBpbiBgY3VycmVudExpbmVUZXh0YCBpbmRlbnRhdGlvblxuICAgICAgICBmb3IgKGxldCBqID0gMCwgbGVuSiA9IGN1cnJlbnRMaW5lTGVuZ3RoOyBqIDwgbGVuSjsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyQ29kZSA9ICh1c2VDdXJyZW50TGluZVRleHQgPyBjdXJyZW50TGluZVRleHQuY2hhckNvZGVBdChqKSA6IHNvdXJjZS5nZXRMaW5lQ2hhckNvZGUobGluZU51bWJlciwgaikpO1xuICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09PSA5IC8qIENoYXJDb2RlLlRhYiAqLykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lVGFic0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyQ29kZSA9PT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZVNwYWNlc0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBIaXQgbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyIG9uIHRoaXMgbGluZVxuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lSGFzQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVJbmRlbnRhdGlvbiA9IGo7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIGVtcHR5IG9yIG9ubHkgd2hpdGVzcGFjZSBsaW5lc1xuICAgICAgICBpZiAoIWN1cnJlbnRMaW5lSGFzQ29udGVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lVGFic0NvdW50ID4gMCkge1xuICAgICAgICAgICAgbGluZXNJbmRlbnRlZFdpdGhUYWJzQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50TGluZVNwYWNlc0NvdW50ID4gMSkge1xuICAgICAgICAgICAgbGluZXNJbmRlbnRlZFdpdGhTcGFjZXNDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIHNwYWNlc0RpZmYocHJldmlvdXNMaW5lVGV4dCwgcHJldmlvdXNMaW5lSW5kZW50YXRpb24sIGN1cnJlbnRMaW5lVGV4dCwgY3VycmVudExpbmVJbmRlbnRhdGlvbiwgdG1wKTtcbiAgICAgICAgaWYgKHRtcC5sb29rc0xpa2VBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIC8vIGlmIGRlZmF1bHRJbnNlcnRTcGFjZXMgPT09IHRydWUgJiYgdGhlIHNwYWNlcyBjb3VudCA9PSB0YWJTaXplLCB3ZSBtYXkgd2FudCB0byBjb3VudCBpdCBhcyB2YWxpZCBpbmRlbnRhdGlvblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIC0gaXRlbTFcbiAgICAgICAgICAgIC8vICAgLSBpdGVtMlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBza2lwIHRoaXMgbGluZSBlbnRpcmVseVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGNvbnN0IGEgPSAxLFxuICAgICAgICAgICAgLy8gICAgICAgYiA9IDI7XG4gICAgICAgICAgICBpZiAoIShkZWZhdWx0SW5zZXJ0U3BhY2VzICYmIGRlZmF1bHRUYWJTaXplID09PSB0bXAuc3BhY2VzRGlmZikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U3BhY2VzRGlmZiA9IHRtcC5zcGFjZXNEaWZmO1xuICAgICAgICBpZiAoY3VycmVudFNwYWNlc0RpZmYgPD0gTUFYX0FMTE9XRURfVEFCX1NJWkVfR1VFU1MpIHtcbiAgICAgICAgICAgIHNwYWNlc0RpZmZDb3VudFtjdXJyZW50U3BhY2VzRGlmZl0rKztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0xpbmVUZXh0ID0gY3VycmVudExpbmVUZXh0O1xuICAgICAgICBwcmV2aW91c0xpbmVJbmRlbnRhdGlvbiA9IGN1cnJlbnRMaW5lSW5kZW50YXRpb247XG4gICAgfVxuICAgIGxldCBpbnNlcnRTcGFjZXMgPSBkZWZhdWx0SW5zZXJ0U3BhY2VzO1xuICAgIGlmIChsaW5lc0luZGVudGVkV2l0aFRhYnNDb3VudCAhPT0gbGluZXNJbmRlbnRlZFdpdGhTcGFjZXNDb3VudCkge1xuICAgICAgICBpbnNlcnRTcGFjZXMgPSAobGluZXNJbmRlbnRlZFdpdGhUYWJzQ291bnQgPCBsaW5lc0luZGVudGVkV2l0aFNwYWNlc0NvdW50KTtcbiAgICB9XG4gICAgbGV0IHRhYlNpemUgPSBkZWZhdWx0VGFiU2l6ZTtcbiAgICAvLyBHdWVzcyB0YWJTaXplIG9ubHkgaWYgaW5zZXJ0aW5nIHNwYWNlcy4uLlxuICAgIGlmIChpbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgbGV0IHRhYlNpemVTY29yZSA9IChpbnNlcnRTcGFjZXMgPyAwIDogMC4xICogbGluZXNDb3VudCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwic2NvcmUgdGhyZXNob2xkOiBcIiArIHRhYlNpemVTY29yZSk7XG4gICAgICAgIEFMTE9XRURfVEFCX1NJWkVfR1VFU1NFUy5mb3JFYWNoKChwb3NzaWJsZVRhYlNpemUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlVGFiU2l6ZVNjb3JlID0gc3BhY2VzRGlmZkNvdW50W3Bvc3NpYmxlVGFiU2l6ZV07XG4gICAgICAgICAgICBpZiAocG9zc2libGVUYWJTaXplU2NvcmUgPiB0YWJTaXplU2NvcmUpIHtcbiAgICAgICAgICAgICAgICB0YWJTaXplU2NvcmUgPSBwb3NzaWJsZVRhYlNpemVTY29yZTtcbiAgICAgICAgICAgICAgICB0YWJTaXplID0gcG9zc2libGVUYWJTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTGV0IGEgdGFiU2l6ZSBvZiAyIHdpbiBldmVuIGlmIGl0IGlzIG5vdCB0aGUgbWF4aW11bVxuICAgICAgICAvLyAob25seSBpbiBjYXNlIDQgd2FzIGd1ZXNzZWQpXG4gICAgICAgIGlmICh0YWJTaXplID09PSA0ICYmIHNwYWNlc0RpZmZDb3VudFs0XSA+IDAgJiYgc3BhY2VzRGlmZkNvdW50WzJdID4gMCAmJiBzcGFjZXNEaWZmQ291bnRbMl0gPj0gc3BhY2VzRGlmZkNvdW50WzRdIC8gMikge1xuICAgICAgICAgICAgdGFiU2l6ZSA9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgLy8gY29uc29sZS5sb2coJ2xpbmVzSW5kZW50ZWRXaXRoVGFic0NvdW50OiAnICsgbGluZXNJbmRlbnRlZFdpdGhUYWJzQ291bnQgKyAnLCBsaW5lc0luZGVudGVkV2l0aFNwYWNlc0NvdW50OiAnICsgbGluZXNJbmRlbnRlZFdpdGhTcGFjZXNDb3VudCk7XG4gICAgLy8gY29uc29sZS5sb2coJ3NwYWNlc0RpZmZDb3VudDogJyArIHNwYWNlc0RpZmZDb3VudCk7XG4gICAgLy8gY29uc29sZS5sb2coJ3RhYlNpemU6ICcgKyB0YWJTaXplICsgJywgdGFiU2l6ZVNjb3JlOiAnICsgdGFiU2l6ZVNjb3JlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnNlcnRTcGFjZXM6IGluc2VydFNwYWNlcyxcbiAgICAgICAgdGFiU2l6ZTogdGFiU2l6ZVxuICAgIH07XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlQ29sb3Iobm9kZSkge1xuICAgIHJldHVybiAoKG5vZGUubWV0YWRhdGEgJiAxIC8qIENvbnN0YW50cy5Db2xvck1hc2sgKi8pID4+PiAwIC8qIENvbnN0YW50cy5Db2xvck9mZnNldCAqLyk7XG59XG5mdW5jdGlvbiBzZXROb2RlQ29sb3Iobm9kZSwgY29sb3IpIHtcbiAgICBub2RlLm1ldGFkYXRhID0gKChub2RlLm1ldGFkYXRhICYgMjU0IC8qIENvbnN0YW50cy5Db2xvck1hc2tJbnZlcnNlICovKSB8IChjb2xvciA8PCAwIC8qIENvbnN0YW50cy5Db2xvck9mZnNldCAqLykpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZUlzVmlzaXRlZChub2RlKSB7XG4gICAgcmV0dXJuICgobm9kZS5tZXRhZGF0YSAmIDIgLyogQ29uc3RhbnRzLklzVmlzaXRlZE1hc2sgKi8pID4+PiAxIC8qIENvbnN0YW50cy5Jc1Zpc2l0ZWRPZmZzZXQgKi8pID09PSAxO1xufVxuZnVuY3Rpb24gc2V0Tm9kZUlzVmlzaXRlZChub2RlLCB2YWx1ZSkge1xuICAgIG5vZGUubWV0YWRhdGEgPSAoKG5vZGUubWV0YWRhdGEgJiAyNTMgLyogQ29uc3RhbnRzLklzVmlzaXRlZE1hc2tJbnZlcnNlICovKSB8ICgodmFsdWUgPyAxIDogMCkgPDwgMSAvKiBDb25zdGFudHMuSXNWaXNpdGVkT2Zmc2V0ICovKSk7XG59XG5mdW5jdGlvbiBnZXROb2RlSXNGb3JWYWxpZGF0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gKChub2RlLm1ldGFkYXRhICYgNCAvKiBDb25zdGFudHMuSXNGb3JWYWxpZGF0aW9uTWFzayAqLykgPj4+IDIgLyogQ29uc3RhbnRzLklzRm9yVmFsaWRhdGlvbk9mZnNldCAqLykgPT09IDE7XG59XG5mdW5jdGlvbiBzZXROb2RlSXNGb3JWYWxpZGF0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgbm9kZS5tZXRhZGF0YSA9ICgobm9kZS5tZXRhZGF0YSAmIDI1MSAvKiBDb25zdGFudHMuSXNGb3JWYWxpZGF0aW9uTWFza0ludmVyc2UgKi8pIHwgKCh2YWx1ZSA/IDEgOiAwKSA8PCAyIC8qIENvbnN0YW50cy5Jc0ZvclZhbGlkYXRpb25PZmZzZXQgKi8pKTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVJc0luR2x5cGhNYXJnaW4obm9kZSkge1xuICAgIHJldHVybiAoKG5vZGUubWV0YWRhdGEgJiA2NCAvKiBDb25zdGFudHMuSXNNYXJnaW5NYXNrICovKSA+Pj4gNiAvKiBDb25zdGFudHMuSXNNYXJnaW5PZmZzZXQgKi8pID09PSAxO1xufVxuZnVuY3Rpb24gc2V0Tm9kZUlzSW5HbHlwaE1hcmdpbihub2RlLCB2YWx1ZSkge1xuICAgIG5vZGUubWV0YWRhdGEgPSAoKG5vZGUubWV0YWRhdGEgJiAxOTEgLyogQ29uc3RhbnRzLklzTWFyZ2luTWFza0ludmVyc2UgKi8pIHwgKCh2YWx1ZSA/IDEgOiAwKSA8PCA2IC8qIENvbnN0YW50cy5Jc01hcmdpbk9mZnNldCAqLykpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVN0aWNraW5lc3Mobm9kZSkge1xuICAgIHJldHVybiAoKG5vZGUubWV0YWRhdGEgJiAyNCAvKiBDb25zdGFudHMuU3RpY2tpbmVzc01hc2sgKi8pID4+PiAzIC8qIENvbnN0YW50cy5TdGlja2luZXNzT2Zmc2V0ICovKTtcbn1cbmZ1bmN0aW9uIF9zZXROb2RlU3RpY2tpbmVzcyhub2RlLCBzdGlja2luZXNzKSB7XG4gICAgbm9kZS5tZXRhZGF0YSA9ICgobm9kZS5tZXRhZGF0YSAmIDIzMSAvKiBDb25zdGFudHMuU3RpY2tpbmVzc01hc2tJbnZlcnNlICovKSB8IChzdGlja2luZXNzIDw8IDMgLyogQ29uc3RhbnRzLlN0aWNraW5lc3NPZmZzZXQgKi8pKTtcbn1cbmZ1bmN0aW9uIGdldENvbGxhcHNlT25SZXBsYWNlRWRpdChub2RlKSB7XG4gICAgcmV0dXJuICgobm9kZS5tZXRhZGF0YSAmIDMyIC8qIENvbnN0YW50cy5Db2xsYXBzZU9uUmVwbGFjZUVkaXRNYXNrICovKSA+Pj4gNSAvKiBDb25zdGFudHMuQ29sbGFwc2VPblJlcGxhY2VFZGl0T2Zmc2V0ICovKSA9PT0gMTtcbn1cbmZ1bmN0aW9uIHNldENvbGxhcHNlT25SZXBsYWNlRWRpdChub2RlLCB2YWx1ZSkge1xuICAgIG5vZGUubWV0YWRhdGEgPSAoKG5vZGUubWV0YWRhdGEgJiAyMjMgLyogQ29uc3RhbnRzLkNvbGxhcHNlT25SZXBsYWNlRWRpdE1hc2tJbnZlcnNlICovKSB8ICgodmFsdWUgPyAxIDogMCkgPDwgNSAvKiBDb25zdGFudHMuQ29sbGFwc2VPblJlcGxhY2VFZGl0T2Zmc2V0ICovKSk7XG59XG5leHBvcnQgY2xhc3MgSW50ZXJ2YWxOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gMDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLmxlZnQgPSB0aGlzO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcztcbiAgICAgICAgc2V0Tm9kZUNvbG9yKHRoaXMsIDEgLyogTm9kZUNvbG9yLlJlZCAqLyk7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIC8vIEZPUkNFX09WRVJGTE9XSU5HX1RFU1Q6IHRoaXMuZGVsdGEgPSBzdGFydDtcbiAgICAgICAgdGhpcy5kZWx0YSA9IDA7XG4gICAgICAgIHRoaXMubWF4RW5kID0gZW5kO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMub3duZXJJZCA9IDA7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHNldE5vZGVJc0ZvclZhbGlkYXRpb24odGhpcywgZmFsc2UpO1xuICAgICAgICBzZXROb2RlSXNJbkdseXBoTWFyZ2luKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX3NldE5vZGVTdGlja2luZXNzKHRoaXMsIDEgLyogVHJhY2tlZFJhbmdlU3RpY2tpbmVzcy5OZXZlckdyb3dzV2hlblR5cGluZ0F0RWRnZXMgKi8pO1xuICAgICAgICBzZXRDb2xsYXBzZU9uUmVwbGFjZUVkaXQodGhpcywgZmFsc2UpO1xuICAgICAgICB0aGlzLmNhY2hlZFZlcnNpb25JZCA9IDA7XG4gICAgICAgIHRoaXMuY2FjaGVkQWJzb2x1dGVTdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmNhY2hlZEFic29sdXRlRW5kID0gZW5kO1xuICAgICAgICB0aGlzLnJhbmdlID0gbnVsbDtcbiAgICAgICAgc2V0Tm9kZUlzVmlzaXRlZCh0aGlzLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlc2V0KHZlcnNpb25JZCwgc3RhcnQsIGVuZCwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5tYXhFbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMuY2FjaGVkVmVyc2lvbklkID0gdmVyc2lvbklkO1xuICAgICAgICB0aGlzLmNhY2hlZEFic29sdXRlU3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5jYWNoZWRBYnNvbHV0ZUVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5vcHRpb25zLmNsYXNzTmFtZTtcbiAgICAgICAgc2V0Tm9kZUlzRm9yVmFsaWRhdGlvbih0aGlzLCAoY2xhc3NOYW1lID09PSBcInNxdWlnZ2x5LWVycm9yXCIgLyogQ2xhc3NOYW1lLkVkaXRvckVycm9yRGVjb3JhdGlvbiAqL1xuICAgICAgICAgICAgfHwgY2xhc3NOYW1lID09PSBcInNxdWlnZ2x5LXdhcm5pbmdcIiAvKiBDbGFzc05hbWUuRWRpdG9yV2FybmluZ0RlY29yYXRpb24gKi9cbiAgICAgICAgICAgIHx8IGNsYXNzTmFtZSA9PT0gXCJzcXVpZ2dseS1pbmZvXCIgLyogQ2xhc3NOYW1lLkVkaXRvckluZm9EZWNvcmF0aW9uICovKSk7XG4gICAgICAgIHNldE5vZGVJc0luR2x5cGhNYXJnaW4odGhpcywgdGhpcy5vcHRpb25zLmdseXBoTWFyZ2luQ2xhc3NOYW1lICE9PSBudWxsKTtcbiAgICAgICAgX3NldE5vZGVTdGlja2luZXNzKHRoaXMsIHRoaXMub3B0aW9ucy5zdGlja2luZXNzKTtcbiAgICAgICAgc2V0Q29sbGFwc2VPblJlcGxhY2VFZGl0KHRoaXMsIHRoaXMub3B0aW9ucy5jb2xsYXBzZU9uUmVwbGFjZUVkaXQpO1xuICAgIH1cbiAgICBzZXRDYWNoZWRPZmZzZXRzKGFic29sdXRlU3RhcnQsIGFic29sdXRlRW5kLCBjYWNoZWRWZXJzaW9uSWQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkVmVyc2lvbklkICE9PSBjYWNoZWRWZXJzaW9uSWQpIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVkVmVyc2lvbklkID0gY2FjaGVkVmVyc2lvbklkO1xuICAgICAgICB0aGlzLmNhY2hlZEFic29sdXRlU3RhcnQgPSBhYnNvbHV0ZVN0YXJ0O1xuICAgICAgICB0aGlzLmNhY2hlZEFic29sdXRlRW5kID0gYWJzb2x1dGVFbmQ7XG4gICAgfVxuICAgIGRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgU0VOVElORUwgPSBuZXcgSW50ZXJ2YWxOb2RlKG51bGwsIDAsIDApO1xuU0VOVElORUwucGFyZW50ID0gU0VOVElORUw7XG5TRU5USU5FTC5sZWZ0ID0gU0VOVElORUw7XG5TRU5USU5FTC5yaWdodCA9IFNFTlRJTkVMO1xuc2V0Tm9kZUNvbG9yKFNFTlRJTkVMLCAwIC8qIE5vZGVDb2xvci5CbGFjayAqLyk7XG5leHBvcnQgY2xhc3MgSW50ZXJ2YWxUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yb290ID0gU0VOVElORUw7XG4gICAgICAgIHRoaXMucmVxdWVzdE5vcm1hbGl6ZURlbHRhID0gZmFsc2U7XG4gICAgfVxuICAgIGludGVydmFsU2VhcmNoKHN0YXJ0LCBlbmQsIGZpbHRlck93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIGNhY2hlZFZlcnNpb25JZCwgb25seU1hcmdpbkRlY29yYXRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVydmFsU2VhcmNoKHRoaXMsIHN0YXJ0LCBlbmQsIGZpbHRlck93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIGNhY2hlZFZlcnNpb25JZCwgb25seU1hcmdpbkRlY29yYXRpb25zKTtcbiAgICB9XG4gICAgc2VhcmNoKGZpbHRlck93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIGNhY2hlZFZlcnNpb25JZCwgb25seU1hcmdpbkRlY29yYXRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlYXJjaCh0aGlzLCBmaWx0ZXJPd25lcklkLCBmaWx0ZXJPdXRWYWxpZGF0aW9uLCBjYWNoZWRWZXJzaW9uSWQsIG9ubHlNYXJnaW5EZWNvcmF0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgbm90IHNldCBgY2FjaGVkQWJzb2x1dGVTdGFydGAgbm9yIGBjYWNoZWRBYnNvbHV0ZUVuZGAgb24gdGhlIHJldHVybmVkIG5vZGVzIVxuICAgICAqL1xuICAgIGNvbGxlY3ROb2Rlc0Zyb21Pd25lcihvd25lcklkKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0Tm9kZXNGcm9tT3duZXIodGhpcywgb3duZXJJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgbm90IHNldCBgY2FjaGVkQWJzb2x1dGVTdGFydGAgbm9yIGBjYWNoZWRBYnNvbHV0ZUVuZGAgb24gdGhlIHJldHVybmVkIG5vZGVzIVxuICAgICAqL1xuICAgIGNvbGxlY3ROb2Rlc1Bvc3RPcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3ROb2Rlc1Bvc3RPcmRlcih0aGlzKTtcbiAgICB9XG4gICAgaW5zZXJ0KG5vZGUpIHtcbiAgICAgICAgcmJUcmVlSW5zZXJ0KHRoaXMsIG5vZGUpO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVEZWx0YUlmTmVjZXNzYXJ5KCk7XG4gICAgfVxuICAgIGRlbGV0ZShub2RlKSB7XG4gICAgICAgIHJiVHJlZURlbGV0ZSh0aGlzLCBub2RlKTtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplRGVsdGFJZk5lY2Vzc2FyeSgpO1xuICAgIH1cbiAgICByZXNvbHZlTm9kZShub2RlLCBjYWNoZWRWZXJzaW9uSWQpIHtcbiAgICAgICAgY29uc3QgaW5pdGlhbE5vZGUgPSBub2RlO1xuICAgICAgICBsZXQgZGVsdGEgPSAwO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gdGhpcy5yb290KSB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gbm9kZS5wYXJlbnQucmlnaHQpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSArPSBub2RlLnBhcmVudC5kZWx0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlU3RhcnQgPSBpbml0aWFsTm9kZS5zdGFydCArIGRlbHRhO1xuICAgICAgICBjb25zdCBub2RlRW5kID0gaW5pdGlhbE5vZGUuZW5kICsgZGVsdGE7XG4gICAgICAgIGluaXRpYWxOb2RlLnNldENhY2hlZE9mZnNldHMobm9kZVN0YXJ0LCBub2RlRW5kLCBjYWNoZWRWZXJzaW9uSWQpO1xuICAgIH1cbiAgICBhY2NlcHRSZXBsYWNlKG9mZnNldCwgbGVuZ3RoLCB0ZXh0TGVuZ3RoLCBmb3JjZU1vdmVNYXJrZXJzKSB7XG4gICAgICAgIC8vIE91ciBzdHJhdGVneSBpcyB0byByZW1vdmUgYWxsIGRpcmVjdGx5IGltcGFjdGVkIG5vZGVzLCBhbmQgdGhlbiBhZGQgdGhlbSBiYWNrIHRvIHRoZSB0cmVlLlxuICAgICAgICAvLyAoMSkgY29sbGVjdCBhbGwgbm9kZXMgdGhhdCBhcmUgaW50ZXJzZWN0aW5nIHRoaXMgZWRpdCBhcyBub2RlcyBvZiBpbnRlcmVzdFxuICAgICAgICBjb25zdCBub2Rlc09mSW50ZXJlc3QgPSBzZWFyY2hGb3JFZGl0aW5nKHRoaXMsIG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgLy8gKDIpIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBhcmUgaW50ZXJzZWN0aW5nIHRoaXMgZWRpdFxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbm9kZXNPZkludGVyZXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNPZkludGVyZXN0W2ldO1xuICAgICAgICAgICAgcmJUcmVlRGVsZXRlKHRoaXMsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZURlbHRhSWZOZWNlc3NhcnkoKTtcbiAgICAgICAgLy8gKDMpIGVkaXQgYWxsIHRyZWUgbm9kZXMgZXhjZXB0IHRoZSBub2RlcyBvZiBpbnRlcmVzdFxuICAgICAgICBub092ZXJsYXBSZXBsYWNlKHRoaXMsIG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoLCB0ZXh0TGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplRGVsdGFJZk5lY2Vzc2FyeSgpO1xuICAgICAgICAvLyAoNCkgZWRpdCB0aGUgbm9kZXMgb2YgaW50ZXJlc3QgYW5kIGluc2VydCB0aGVtIGJhY2sgaW4gdGhlIHRyZWVcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGVzT2ZJbnRlcmVzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzT2ZJbnRlcmVzdFtpXTtcbiAgICAgICAgICAgIG5vZGUuc3RhcnQgPSBub2RlLmNhY2hlZEFic29sdXRlU3RhcnQ7XG4gICAgICAgICAgICBub2RlLmVuZCA9IG5vZGUuY2FjaGVkQWJzb2x1dGVFbmQ7XG4gICAgICAgICAgICBub2RlQWNjZXB0RWRpdChub2RlLCBvZmZzZXQsIChvZmZzZXQgKyBsZW5ndGgpLCB0ZXh0TGVuZ3RoLCBmb3JjZU1vdmVNYXJrZXJzKTtcbiAgICAgICAgICAgIG5vZGUubWF4RW5kID0gbm9kZS5lbmQ7XG4gICAgICAgICAgICByYlRyZWVJbnNlcnQodGhpcywgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9ybWFsaXplRGVsdGFJZk5lY2Vzc2FyeSgpO1xuICAgIH1cbiAgICBfbm9ybWFsaXplRGVsdGFJZk5lY2Vzc2FyeSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3ROb3JtYWxpemVEZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdE5vcm1hbGl6ZURlbHRhID0gZmFsc2U7XG4gICAgICAgIG5vcm1hbGl6ZURlbHRhKHRoaXMpO1xuICAgIH1cbn1cbi8vI3JlZ2lvbiBEZWx0YSBOb3JtYWxpemF0aW9uXG5mdW5jdGlvbiBub3JtYWxpemVEZWx0YShUKSB7XG4gICAgbGV0IG5vZGUgPSBULnJvb3Q7XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICB3aGlsZSAobm9kZSAhPT0gU0VOVElORUwpIHtcbiAgICAgICAgaWYgKG5vZGUubGVmdCAhPT0gU0VOVElORUwgJiYgIWdldE5vZGVJc1Zpc2l0ZWQobm9kZS5sZWZ0KSkge1xuICAgICAgICAgICAgLy8gZ28gbGVmdFxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnJpZ2h0ICE9PSBTRU5USU5FTCAmJiAhZ2V0Tm9kZUlzVmlzaXRlZChub2RlLnJpZ2h0KSkge1xuICAgICAgICAgICAgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgIGRlbHRhICs9IG5vZGUuZGVsdGE7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBjdXJyZW50IG5vZGVcbiAgICAgICAgbm9kZS5zdGFydCA9IGRlbHRhICsgbm9kZS5zdGFydDtcbiAgICAgICAgbm9kZS5lbmQgPSBkZWx0YSArIG5vZGUuZW5kO1xuICAgICAgICBub2RlLmRlbHRhID0gMDtcbiAgICAgICAgcmVjb21wdXRlTWF4RW5kKG5vZGUpO1xuICAgICAgICBzZXROb2RlSXNWaXNpdGVkKG5vZGUsIHRydWUpO1xuICAgICAgICAvLyBnb2luZyB1cCBmcm9tIHRoaXMgbm9kZVxuICAgICAgICBzZXROb2RlSXNWaXNpdGVkKG5vZGUubGVmdCwgZmFsc2UpO1xuICAgICAgICBzZXROb2RlSXNWaXNpdGVkKG5vZGUucmlnaHQsIGZhbHNlKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IG5vZGUucGFyZW50LnJpZ2h0KSB7XG4gICAgICAgICAgICBkZWx0YSAtPSBub2RlLnBhcmVudC5kZWx0YTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHNldE5vZGVJc1Zpc2l0ZWQoVC5yb290LCBmYWxzZSk7XG59XG5mdW5jdGlvbiBhZGp1c3RNYXJrZXJCZWZvcmVDb2x1bW4obWFya2VyT2Zmc2V0LCBtYXJrZXJTdGlja1RvUHJldmlvdXNDaGFyYWN0ZXIsIGNoZWNrT2Zmc2V0LCBtb3ZlU2VtYW50aWNzKSB7XG4gICAgaWYgKG1hcmtlck9mZnNldCA8IGNoZWNrT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobWFya2VyT2Zmc2V0ID4gY2hlY2tPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobW92ZVNlbWFudGljcyA9PT0gMSAvKiBNYXJrZXJNb3ZlU2VtYW50aWNzLkZvcmNlTW92ZSAqLykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtb3ZlU2VtYW50aWNzID09PSAyIC8qIE1hcmtlck1vdmVTZW1hbnRpY3MuRm9yY2VTdGF5ICovKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyU3RpY2tUb1ByZXZpb3VzQ2hhcmFjdGVyO1xufVxuLyoqXG4gKiBUaGlzIGlzIGEgbG90IG1vcmUgY29tcGxpY2F0ZWQgdGhhbiBzdHJpY3RseSBuZWNlc3NhcnkgdG8gbWFpbnRhaW4gdGhlIHNhbWUgYmVoYXZpb3VyXG4gKiBhcyB3aGVuIGRlY29yYXRpb25zIHdlcmUgaW1wbGVtZW50ZWQgdXNpbmcgdHdvIG1hcmtlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub2RlQWNjZXB0RWRpdChub2RlLCBzdGFydCwgZW5kLCB0ZXh0TGVuZ3RoLCBmb3JjZU1vdmVNYXJrZXJzKSB7XG4gICAgY29uc3Qgbm9kZVN0aWNraW5lc3MgPSBnZXROb2RlU3RpY2tpbmVzcyhub2RlKTtcbiAgICBjb25zdCBzdGFydFN0aWNrVG9QcmV2aW91c0NoYXJhY3RlciA9IChub2RlU3RpY2tpbmVzcyA9PT0gMCAvKiBUcmFja2VkUmFuZ2VTdGlja2luZXNzLkFsd2F5c0dyb3dzV2hlblR5cGluZ0F0RWRnZXMgKi9cbiAgICAgICAgfHwgbm9kZVN0aWNraW5lc3MgPT09IDIgLyogVHJhY2tlZFJhbmdlU3RpY2tpbmVzcy5Hcm93c09ubHlXaGVuVHlwaW5nQmVmb3JlICovKTtcbiAgICBjb25zdCBlbmRTdGlja1RvUHJldmlvdXNDaGFyYWN0ZXIgPSAobm9kZVN0aWNraW5lc3MgPT09IDEgLyogVHJhY2tlZFJhbmdlU3RpY2tpbmVzcy5OZXZlckdyb3dzV2hlblR5cGluZ0F0RWRnZXMgKi9cbiAgICAgICAgfHwgbm9kZVN0aWNraW5lc3MgPT09IDIgLyogVHJhY2tlZFJhbmdlU3RpY2tpbmVzcy5Hcm93c09ubHlXaGVuVHlwaW5nQmVmb3JlICovKTtcbiAgICBjb25zdCBkZWxldGluZ0NudCA9IChlbmQgLSBzdGFydCk7XG4gICAgY29uc3QgaW5zZXJ0aW5nQ250ID0gdGV4dExlbmd0aDtcbiAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihkZWxldGluZ0NudCwgaW5zZXJ0aW5nQ250KTtcbiAgICBjb25zdCBub2RlU3RhcnQgPSBub2RlLnN0YXJ0O1xuICAgIGxldCBzdGFydERvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBub2RlRW5kID0gbm9kZS5lbmQ7XG4gICAgbGV0IGVuZERvbmUgPSBmYWxzZTtcbiAgICBpZiAoc3RhcnQgPD0gbm9kZVN0YXJ0ICYmIG5vZGVFbmQgPD0gZW5kICYmIGdldENvbGxhcHNlT25SZXBsYWNlRWRpdChub2RlKSkge1xuICAgICAgICAvLyBUaGlzIGVkaXQgZW5jb21wYXNzZXMgdGhlIGVudGlyZSBkZWNvcmF0aW9uIHJhbmdlXG4gICAgICAgIC8vIGFuZCB0aGUgZGVjb3JhdGlvbiBoYXMgYXNrZWQgdG8gYmVjb21lIGNvbGxhcHNlZFxuICAgICAgICBub2RlLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0RG9uZSA9IHRydWU7XG4gICAgICAgIG5vZGUuZW5kID0gc3RhcnQ7XG4gICAgICAgIGVuZERvbmUgPSB0cnVlO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGNvbnN0IG1vdmVTZW1hbnRpY3MgPSBmb3JjZU1vdmVNYXJrZXJzID8gMSAvKiBNYXJrZXJNb3ZlU2VtYW50aWNzLkZvcmNlTW92ZSAqLyA6IChkZWxldGluZ0NudCA+IDAgPyAyIC8qIE1hcmtlck1vdmVTZW1hbnRpY3MuRm9yY2VTdGF5ICovIDogMCAvKiBNYXJrZXJNb3ZlU2VtYW50aWNzLk1hcmtlckRlZmluZWQgKi8pO1xuICAgICAgICBpZiAoIXN0YXJ0RG9uZSAmJiBhZGp1c3RNYXJrZXJCZWZvcmVDb2x1bW4obm9kZVN0YXJ0LCBzdGFydFN0aWNrVG9QcmV2aW91c0NoYXJhY3Rlciwgc3RhcnQsIG1vdmVTZW1hbnRpY3MpKSB7XG4gICAgICAgICAgICBzdGFydERvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5kRG9uZSAmJiBhZGp1c3RNYXJrZXJCZWZvcmVDb2x1bW4obm9kZUVuZCwgZW5kU3RpY2tUb1ByZXZpb3VzQ2hhcmFjdGVyLCBzdGFydCwgbW92ZVNlbWFudGljcykpIHtcbiAgICAgICAgICAgIGVuZERvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21tb25MZW5ndGggPiAwICYmICFmb3JjZU1vdmVNYXJrZXJzKSB7XG4gICAgICAgIGNvbnN0IG1vdmVTZW1hbnRpY3MgPSAoZGVsZXRpbmdDbnQgPiBpbnNlcnRpbmdDbnQgPyAyIC8qIE1hcmtlck1vdmVTZW1hbnRpY3MuRm9yY2VTdGF5ICovIDogMCAvKiBNYXJrZXJNb3ZlU2VtYW50aWNzLk1hcmtlckRlZmluZWQgKi8pO1xuICAgICAgICBpZiAoIXN0YXJ0RG9uZSAmJiBhZGp1c3RNYXJrZXJCZWZvcmVDb2x1bW4obm9kZVN0YXJ0LCBzdGFydFN0aWNrVG9QcmV2aW91c0NoYXJhY3Rlciwgc3RhcnQgKyBjb21tb25MZW5ndGgsIG1vdmVTZW1hbnRpY3MpKSB7XG4gICAgICAgICAgICBzdGFydERvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5kRG9uZSAmJiBhZGp1c3RNYXJrZXJCZWZvcmVDb2x1bW4obm9kZUVuZCwgZW5kU3RpY2tUb1ByZXZpb3VzQ2hhcmFjdGVyLCBzdGFydCArIGNvbW1vbkxlbmd0aCwgbW92ZVNlbWFudGljcykpIHtcbiAgICAgICAgICAgIGVuZERvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgICAgY29uc3QgbW92ZVNlbWFudGljcyA9IGZvcmNlTW92ZU1hcmtlcnMgPyAxIC8qIE1hcmtlck1vdmVTZW1hbnRpY3MuRm9yY2VNb3ZlICovIDogMCAvKiBNYXJrZXJNb3ZlU2VtYW50aWNzLk1hcmtlckRlZmluZWQgKi87XG4gICAgICAgIGlmICghc3RhcnREb25lICYmIGFkanVzdE1hcmtlckJlZm9yZUNvbHVtbihub2RlU3RhcnQsIHN0YXJ0U3RpY2tUb1ByZXZpb3VzQ2hhcmFjdGVyLCBlbmQsIG1vdmVTZW1hbnRpY3MpKSB7XG4gICAgICAgICAgICBub2RlLnN0YXJ0ID0gc3RhcnQgKyBpbnNlcnRpbmdDbnQ7XG4gICAgICAgICAgICBzdGFydERvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5kRG9uZSAmJiBhZGp1c3RNYXJrZXJCZWZvcmVDb2x1bW4obm9kZUVuZCwgZW5kU3RpY2tUb1ByZXZpb3VzQ2hhcmFjdGVyLCBlbmQsIG1vdmVTZW1hbnRpY3MpKSB7XG4gICAgICAgICAgICBub2RlLmVuZCA9IHN0YXJ0ICsgaW5zZXJ0aW5nQ250O1xuICAgICAgICAgICAgZW5kRG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluaXNoXG4gICAgY29uc3QgZGVsdGFDb2x1bW4gPSAoaW5zZXJ0aW5nQ250IC0gZGVsZXRpbmdDbnQpO1xuICAgIGlmICghc3RhcnREb25lKSB7XG4gICAgICAgIG5vZGUuc3RhcnQgPSBNYXRoLm1heCgwLCBub2RlU3RhcnQgKyBkZWx0YUNvbHVtbik7XG4gICAgfVxuICAgIGlmICghZW5kRG9uZSkge1xuICAgICAgICBub2RlLmVuZCA9IE1hdGgubWF4KDAsIG5vZGVFbmQgKyBkZWx0YUNvbHVtbik7XG4gICAgfVxuICAgIGlmIChub2RlLnN0YXJ0ID4gbm9kZS5lbmQpIHtcbiAgICAgICAgbm9kZS5lbmQgPSBub2RlLnN0YXJ0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlYXJjaEZvckVkaXRpbmcoVCwgc3RhcnQsIGVuZCkge1xuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVydmFsX3RyZWUjQXVnbWVudGVkX3RyZWVcbiAgICAvLyBOb3csIGl0IGlzIGtub3duIHRoYXQgdHdvIGludGVydmFscyBBIGFuZCBCIG92ZXJsYXAgb25seSB3aGVuIGJvdGhcbiAgICAvLyBBLmxvdyA8PSBCLmhpZ2ggYW5kIEEuaGlnaCA+PSBCLmxvdy4gV2hlbiBzZWFyY2hpbmcgdGhlIHRyZWVzIGZvclxuICAgIC8vIG5vZGVzIG92ZXJsYXBwaW5nIHdpdGggYSBnaXZlbiBpbnRlcnZhbCwgeW91IGNhbiBpbW1lZGlhdGVseSBza2lwOlxuICAgIC8vICBhKSBhbGwgbm9kZXMgdG8gdGhlIHJpZ2h0IG9mIG5vZGVzIHdob3NlIGxvdyB2YWx1ZSBpcyBwYXN0IHRoZSBlbmQgb2YgdGhlIGdpdmVuIGludGVydmFsLlxuICAgIC8vICBiKSBhbGwgbm9kZXMgdGhhdCBoYXZlIHRoZWlyIG1heGltdW0gJ2hpZ2gnIHZhbHVlIGJlbG93IHRoZSBzdGFydCBvZiB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gICAgbGV0IG5vZGUgPSBULnJvb3Q7XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICBsZXQgbm9kZU1heEVuZCA9IDA7XG4gICAgbGV0IG5vZGVTdGFydCA9IDA7XG4gICAgbGV0IG5vZGVFbmQgPSAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCByZXN1bHRMZW4gPSAwO1xuICAgIHdoaWxlIChub2RlICE9PSBTRU5USU5FTCkge1xuICAgICAgICBpZiAoZ2V0Tm9kZUlzVmlzaXRlZChub2RlKSkge1xuICAgICAgICAgICAgLy8gZ29pbmcgdXAgZnJvbSB0aGlzIG5vZGVcbiAgICAgICAgICAgIHNldE5vZGVJc1Zpc2l0ZWQobm9kZS5sZWZ0LCBmYWxzZSk7XG4gICAgICAgICAgICBzZXROb2RlSXNWaXNpdGVkKG5vZGUucmlnaHQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBub2RlLnBhcmVudC5yaWdodCkge1xuICAgICAgICAgICAgICAgIGRlbHRhIC09IG5vZGUucGFyZW50LmRlbHRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFnZXROb2RlSXNWaXNpdGVkKG5vZGUubGVmdCkpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUgc2VlaW5nIHRoaXMgbm9kZVxuICAgICAgICAgICAgbm9kZU1heEVuZCA9IGRlbHRhICsgbm9kZS5tYXhFbmQ7XG4gICAgICAgICAgICBpZiAobm9kZU1heEVuZCA8IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gY292ZXIgY2FzZSBiKSBmcm9tIGFib3ZlXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCB0byBzZWFyY2ggdGhpcyBub2RlIG9yIGl0cyBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHNldE5vZGVJc1Zpc2l0ZWQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5sZWZ0ICE9PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgICAgIC8vIGdvIGxlZnRcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBjdXJyZW50IG5vZGVcbiAgICAgICAgbm9kZVN0YXJ0ID0gZGVsdGEgKyBub2RlLnN0YXJ0O1xuICAgICAgICBpZiAobm9kZVN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAvLyBjb3ZlciBjYXNlIGEpIGZyb20gYWJvdmVcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gc2VhcmNoIHRoaXMgbm9kZSBvciBpdHMgcmlnaHQgc3VidHJlZVxuICAgICAgICAgICAgc2V0Tm9kZUlzVmlzaXRlZChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVFbmQgPSBkZWx0YSArIG5vZGUuZW5kO1xuICAgICAgICBpZiAobm9kZUVuZCA+PSBzdGFydCkge1xuICAgICAgICAgICAgbm9kZS5zZXRDYWNoZWRPZmZzZXRzKG5vZGVTdGFydCwgbm9kZUVuZCwgMCk7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0TGVuKytdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBzZXROb2RlSXNWaXNpdGVkKG5vZGUsIHRydWUpO1xuICAgICAgICBpZiAobm9kZS5yaWdodCAhPT0gU0VOVElORUwgJiYgIWdldE5vZGVJc1Zpc2l0ZWQobm9kZS5yaWdodCkpIHtcbiAgICAgICAgICAgIC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICBkZWx0YSArPSBub2RlLmRlbHRhO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXROb2RlSXNWaXNpdGVkKFQucm9vdCwgZmFsc2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub092ZXJsYXBSZXBsYWNlKFQsIHN0YXJ0LCBlbmQsIHRleHRMZW5ndGgpIHtcbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcnZhbF90cmVlI0F1Z21lbnRlZF90cmVlXG4gICAgLy8gTm93LCBpdCBpcyBrbm93biB0aGF0IHR3byBpbnRlcnZhbHMgQSBhbmQgQiBvdmVybGFwIG9ubHkgd2hlbiBib3RoXG4gICAgLy8gQS5sb3cgPD0gQi5oaWdoIGFuZCBBLmhpZ2ggPj0gQi5sb3cuIFdoZW4gc2VhcmNoaW5nIHRoZSB0cmVlcyBmb3JcbiAgICAvLyBub2RlcyBvdmVybGFwcGluZyB3aXRoIGEgZ2l2ZW4gaW50ZXJ2YWwsIHlvdSBjYW4gaW1tZWRpYXRlbHkgc2tpcDpcbiAgICAvLyAgYSkgYWxsIG5vZGVzIHRvIHRoZSByaWdodCBvZiBub2RlcyB3aG9zZSBsb3cgdmFsdWUgaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBnaXZlbiBpbnRlcnZhbC5cbiAgICAvLyAgYikgYWxsIG5vZGVzIHRoYXQgaGF2ZSB0aGVpciBtYXhpbXVtICdoaWdoJyB2YWx1ZSBiZWxvdyB0aGUgc3RhcnQgb2YgdGhlIGdpdmVuIGludGVydmFsLlxuICAgIGxldCBub2RlID0gVC5yb290O1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgbGV0IG5vZGVNYXhFbmQgPSAwO1xuICAgIGxldCBub2RlU3RhcnQgPSAwO1xuICAgIGNvbnN0IGVkaXREZWx0YSA9ICh0ZXh0TGVuZ3RoIC0gKGVuZCAtIHN0YXJ0KSk7XG4gICAgd2hpbGUgKG5vZGUgIT09IFNFTlRJTkVMKSB7XG4gICAgICAgIGlmIChnZXROb2RlSXNWaXNpdGVkKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBnb2luZyB1cCBmcm9tIHRoaXMgbm9kZVxuICAgICAgICAgICAgc2V0Tm9kZUlzVmlzaXRlZChub2RlLmxlZnQsIGZhbHNlKTtcbiAgICAgICAgICAgIHNldE5vZGVJc1Zpc2l0ZWQobm9kZS5yaWdodCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IG5vZGUucGFyZW50LnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgLT0gbm9kZS5wYXJlbnQuZGVsdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNvbXB1dGVNYXhFbmQobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdldE5vZGVJc1Zpc2l0ZWQobm9kZS5sZWZ0KSkge1xuICAgICAgICAgICAgLy8gZmlyc3QgdGltZSBzZWVpbmcgdGhpcyBub2RlXG4gICAgICAgICAgICBub2RlTWF4RW5kID0gZGVsdGEgKyBub2RlLm1heEVuZDtcbiAgICAgICAgICAgIGlmIChub2RlTWF4RW5kIDwgc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBjb3ZlciBjYXNlIGIpIGZyb20gYWJvdmVcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIHRvIHNlYXJjaCB0aGlzIG5vZGUgb3IgaXRzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgc2V0Tm9kZUlzVmlzaXRlZChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmxlZnQgIT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICAgICAgLy8gZ28gbGVmdFxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGN1cnJlbnQgbm9kZVxuICAgICAgICBub2RlU3RhcnQgPSBkZWx0YSArIG5vZGUuc3RhcnQ7XG4gICAgICAgIGlmIChub2RlU3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgIG5vZGUuc3RhcnQgKz0gZWRpdERlbHRhO1xuICAgICAgICAgICAgbm9kZS5lbmQgKz0gZWRpdERlbHRhO1xuICAgICAgICAgICAgbm9kZS5kZWx0YSArPSBlZGl0RGVsdGE7XG4gICAgICAgICAgICBpZiAobm9kZS5kZWx0YSA8IC0xMDczNzQxODI0IC8qIENvbnN0YW50cy5NSU5fU0FGRV9ERUxUQSAqLyB8fCBub2RlLmRlbHRhID4gMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUFYX1NBRkVfREVMVEEgKi8pIHtcbiAgICAgICAgICAgICAgICBULnJlcXVlc3ROb3JtYWxpemVEZWx0YSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb3ZlciBjYXNlIGEpIGZyb20gYWJvdmVcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gc2VhcmNoIHRoaXMgbm9kZSBvciBpdHMgcmlnaHQgc3VidHJlZVxuICAgICAgICAgICAgc2V0Tm9kZUlzVmlzaXRlZChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNldE5vZGVJc1Zpc2l0ZWQobm9kZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChub2RlLnJpZ2h0ICE9PSBTRU5USU5FTCAmJiAhZ2V0Tm9kZUlzVmlzaXRlZChub2RlLnJpZ2h0KSkge1xuICAgICAgICAgICAgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgIGRlbHRhICs9IG5vZGUuZGVsdGE7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldE5vZGVJc1Zpc2l0ZWQoVC5yb290LCBmYWxzZSk7XG59XG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBTZWFyY2hpbmdcbmZ1bmN0aW9uIGNvbGxlY3ROb2Rlc0Zyb21Pd25lcihULCBvd25lcklkKSB7XG4gICAgbGV0IG5vZGUgPSBULnJvb3Q7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHJlc3VsdExlbiA9IDA7XG4gICAgd2hpbGUgKG5vZGUgIT09IFNFTlRJTkVMKSB7XG4gICAgICAgIGlmIChnZXROb2RlSXNWaXNpdGVkKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBnb2luZyB1cCBmcm9tIHRoaXMgbm9kZVxuICAgICAgICAgICAgc2V0Tm9kZUlzVmlzaXRlZChub2RlLmxlZnQsIGZhbHNlKTtcbiAgICAgICAgICAgIHNldE5vZGVJc1Zpc2l0ZWQobm9kZS5yaWdodCwgZmFsc2UpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubGVmdCAhPT0gU0VOVElORUwgJiYgIWdldE5vZGVJc1Zpc2l0ZWQobm9kZS5sZWZ0KSkge1xuICAgICAgICAgICAgLy8gZ28gbGVmdFxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBjdXJyZW50IG5vZGVcbiAgICAgICAgaWYgKG5vZGUub3duZXJJZCA9PT0gb3duZXJJZCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Tm9kZUlzVmlzaXRlZChub2RlLCB0cnVlKTtcbiAgICAgICAgaWYgKG5vZGUucmlnaHQgIT09IFNFTlRJTkVMICYmICFnZXROb2RlSXNWaXNpdGVkKG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAvLyBnbyByaWdodFxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXROb2RlSXNWaXNpdGVkKFQucm9vdCwgZmFsc2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb2xsZWN0Tm9kZXNQb3N0T3JkZXIoVCkge1xuICAgIGxldCBub2RlID0gVC5yb290O1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCByZXN1bHRMZW4gPSAwO1xuICAgIHdoaWxlIChub2RlICE9PSBTRU5USU5FTCkge1xuICAgICAgICBpZiAoZ2V0Tm9kZUlzVmlzaXRlZChub2RlKSkge1xuICAgICAgICAgICAgLy8gZ29pbmcgdXAgZnJvbSB0aGlzIG5vZGVcbiAgICAgICAgICAgIHNldE5vZGVJc1Zpc2l0ZWQobm9kZS5sZWZ0LCBmYWxzZSk7XG4gICAgICAgICAgICBzZXROb2RlSXNWaXNpdGVkKG5vZGUucmlnaHQsIGZhbHNlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmxlZnQgIT09IFNFTlRJTkVMICYmICFnZXROb2RlSXNWaXNpdGVkKG5vZGUubGVmdCkpIHtcbiAgICAgICAgICAgIC8vIGdvIGxlZnRcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5yaWdodCAhPT0gU0VOVElORUwgJiYgIWdldE5vZGVJc1Zpc2l0ZWQobm9kZS5yaWdodCkpIHtcbiAgICAgICAgICAgIC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBjdXJyZW50IG5vZGVcbiAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5vZGU7XG4gICAgICAgIHNldE5vZGVJc1Zpc2l0ZWQobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHNldE5vZGVJc1Zpc2l0ZWQoVC5yb290LCBmYWxzZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNlYXJjaChULCBmaWx0ZXJPd25lcklkLCBmaWx0ZXJPdXRWYWxpZGF0aW9uLCBjYWNoZWRWZXJzaW9uSWQsIG9ubHlNYXJnaW5EZWNvcmF0aW9ucykge1xuICAgIGxldCBub2RlID0gVC5yb290O1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgbGV0IG5vZGVTdGFydCA9IDA7XG4gICAgbGV0IG5vZGVFbmQgPSAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCByZXN1bHRMZW4gPSAwO1xuICAgIHdoaWxlIChub2RlICE9PSBTRU5USU5FTCkge1xuICAgICAgICBpZiAoZ2V0Tm9kZUlzVmlzaXRlZChub2RlKSkge1xuICAgICAgICAgICAgLy8gZ29pbmcgdXAgZnJvbSB0aGlzIG5vZGVcbiAgICAgICAgICAgIHNldE5vZGVJc1Zpc2l0ZWQobm9kZS5sZWZ0LCBmYWxzZSk7XG4gICAgICAgICAgICBzZXROb2RlSXNWaXNpdGVkKG5vZGUucmlnaHQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBub2RlLnBhcmVudC5yaWdodCkge1xuICAgICAgICAgICAgICAgIGRlbHRhIC09IG5vZGUucGFyZW50LmRlbHRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubGVmdCAhPT0gU0VOVElORUwgJiYgIWdldE5vZGVJc1Zpc2l0ZWQobm9kZS5sZWZ0KSkge1xuICAgICAgICAgICAgLy8gZ28gbGVmdFxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBjdXJyZW50IG5vZGVcbiAgICAgICAgbm9kZVN0YXJ0ID0gZGVsdGEgKyBub2RlLnN0YXJ0O1xuICAgICAgICBub2RlRW5kID0gZGVsdGEgKyBub2RlLmVuZDtcbiAgICAgICAgbm9kZS5zZXRDYWNoZWRPZmZzZXRzKG5vZGVTdGFydCwgbm9kZUVuZCwgY2FjaGVkVmVyc2lvbklkKTtcbiAgICAgICAgbGV0IGluY2x1ZGUgPSB0cnVlO1xuICAgICAgICBpZiAoZmlsdGVyT3duZXJJZCAmJiBub2RlLm93bmVySWQgJiYgbm9kZS5vd25lcklkICE9PSBmaWx0ZXJPd25lcklkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlck91dFZhbGlkYXRpb24gJiYgZ2V0Tm9kZUlzRm9yVmFsaWRhdGlvbihub2RlKSkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmx5TWFyZ2luRGVjb3JhdGlvbnMgJiYgIWdldE5vZGVJc0luR2x5cGhNYXJnaW4obm9kZSkpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Tm9kZUlzVmlzaXRlZChub2RlLCB0cnVlKTtcbiAgICAgICAgaWYgKG5vZGUucmlnaHQgIT09IFNFTlRJTkVMICYmICFnZXROb2RlSXNWaXNpdGVkKG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAvLyBnbyByaWdodFxuICAgICAgICAgICAgZGVsdGEgKz0gbm9kZS5kZWx0YTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Tm9kZUlzVmlzaXRlZChULnJvb3QsIGZhbHNlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxTZWFyY2goVCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxFbmQsIGZpbHRlck93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIGNhY2hlZFZlcnNpb25JZCwgb25seU1hcmdpbkRlY29yYXRpb25zKSB7XG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJ2YWxfdHJlZSNBdWdtZW50ZWRfdHJlZVxuICAgIC8vIE5vdywgaXQgaXMga25vd24gdGhhdCB0d28gaW50ZXJ2YWxzIEEgYW5kIEIgb3ZlcmxhcCBvbmx5IHdoZW4gYm90aFxuICAgIC8vIEEubG93IDw9IEIuaGlnaCBhbmQgQS5oaWdoID49IEIubG93LiBXaGVuIHNlYXJjaGluZyB0aGUgdHJlZXMgZm9yXG4gICAgLy8gbm9kZXMgb3ZlcmxhcHBpbmcgd2l0aCBhIGdpdmVuIGludGVydmFsLCB5b3UgY2FuIGltbWVkaWF0ZWx5IHNraXA6XG4gICAgLy8gIGEpIGFsbCBub2RlcyB0byB0aGUgcmlnaHQgb2Ygbm9kZXMgd2hvc2UgbG93IHZhbHVlIGlzIHBhc3QgdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gICAgLy8gIGIpIGFsbCBub2RlcyB0aGF0IGhhdmUgdGhlaXIgbWF4aW11bSAnaGlnaCcgdmFsdWUgYmVsb3cgdGhlIHN0YXJ0IG9mIHRoZSBnaXZlbiBpbnRlcnZhbC5cbiAgICBsZXQgbm9kZSA9IFQucm9vdDtcbiAgICBsZXQgZGVsdGEgPSAwO1xuICAgIGxldCBub2RlTWF4RW5kID0gMDtcbiAgICBsZXQgbm9kZVN0YXJ0ID0gMDtcbiAgICBsZXQgbm9kZUVuZCA9IDA7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHJlc3VsdExlbiA9IDA7XG4gICAgd2hpbGUgKG5vZGUgIT09IFNFTlRJTkVMKSB7XG4gICAgICAgIGlmIChnZXROb2RlSXNWaXNpdGVkKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBnb2luZyB1cCBmcm9tIHRoaXMgbm9kZVxuICAgICAgICAgICAgc2V0Tm9kZUlzVmlzaXRlZChub2RlLmxlZnQsIGZhbHNlKTtcbiAgICAgICAgICAgIHNldE5vZGVJc1Zpc2l0ZWQobm9kZS5yaWdodCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IG5vZGUucGFyZW50LnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgLT0gbm9kZS5wYXJlbnQuZGVsdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdldE5vZGVJc1Zpc2l0ZWQobm9kZS5sZWZ0KSkge1xuICAgICAgICAgICAgLy8gZmlyc3QgdGltZSBzZWVpbmcgdGhpcyBub2RlXG4gICAgICAgICAgICBub2RlTWF4RW5kID0gZGVsdGEgKyBub2RlLm1heEVuZDtcbiAgICAgICAgICAgIGlmIChub2RlTWF4RW5kIDwgaW50ZXJ2YWxTdGFydCkge1xuICAgICAgICAgICAgICAgIC8vIGNvdmVyIGNhc2UgYikgZnJvbSBhYm92ZVxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gc2VhcmNoIHRoaXMgbm9kZSBvciBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBzZXROb2RlSXNWaXNpdGVkKG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUubGVmdCAhPT0gU0VOVElORUwpIHtcbiAgICAgICAgICAgICAgICAvLyBnbyBsZWZ0XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgY3VycmVudCBub2RlXG4gICAgICAgIG5vZGVTdGFydCA9IGRlbHRhICsgbm9kZS5zdGFydDtcbiAgICAgICAgaWYgKG5vZGVTdGFydCA+IGludGVydmFsRW5kKSB7XG4gICAgICAgICAgICAvLyBjb3ZlciBjYXNlIGEpIGZyb20gYWJvdmVcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gc2VhcmNoIHRoaXMgbm9kZSBvciBpdHMgcmlnaHQgc3VidHJlZVxuICAgICAgICAgICAgc2V0Tm9kZUlzVmlzaXRlZChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVFbmQgPSBkZWx0YSArIG5vZGUuZW5kO1xuICAgICAgICBpZiAobm9kZUVuZCA+PSBpbnRlcnZhbFN0YXJ0KSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBvdmVybGFwXG4gICAgICAgICAgICBub2RlLnNldENhY2hlZE9mZnNldHMobm9kZVN0YXJ0LCBub2RlRW5kLCBjYWNoZWRWZXJzaW9uSWQpO1xuICAgICAgICAgICAgbGV0IGluY2x1ZGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGZpbHRlck93bmVySWQgJiYgbm9kZS5vd25lcklkICYmIG5vZGUub3duZXJJZCAhPT0gZmlsdGVyT3duZXJJZCkge1xuICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXJPdXRWYWxpZGF0aW9uICYmIGdldE5vZGVJc0ZvclZhbGlkYXRpb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25seU1hcmdpbkRlY29yYXRpb25zICYmICFnZXROb2RlSXNJbkdseXBoTWFyZ2luKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0TGVuKytdID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXROb2RlSXNWaXNpdGVkKG5vZGUsIHRydWUpO1xuICAgICAgICBpZiAobm9kZS5yaWdodCAhPT0gU0VOVElORUwgJiYgIWdldE5vZGVJc1Zpc2l0ZWQobm9kZS5yaWdodCkpIHtcbiAgICAgICAgICAgIC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICBkZWx0YSArPSBub2RlLmRlbHRhO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXROb2RlSXNWaXNpdGVkKFQucm9vdCwgZmFsc2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBJbnNlcnRpb25cbmZ1bmN0aW9uIHJiVHJlZUluc2VydChULCBuZXdOb2RlKSB7XG4gICAgaWYgKFQucm9vdCA9PT0gU0VOVElORUwpIHtcbiAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSBTRU5USU5FTDtcbiAgICAgICAgbmV3Tm9kZS5sZWZ0ID0gU0VOVElORUw7XG4gICAgICAgIG5ld05vZGUucmlnaHQgPSBTRU5USU5FTDtcbiAgICAgICAgc2V0Tm9kZUNvbG9yKG5ld05vZGUsIDAgLyogTm9kZUNvbG9yLkJsYWNrICovKTtcbiAgICAgICAgVC5yb290ID0gbmV3Tm9kZTtcbiAgICAgICAgcmV0dXJuIFQucm9vdDtcbiAgICB9XG4gICAgdHJlZUluc2VydChULCBuZXdOb2RlKTtcbiAgICByZWNvbXB1dGVNYXhFbmRXYWxrVG9Sb290KG5ld05vZGUucGFyZW50KTtcbiAgICAvLyByZXBhaXIgdHJlZVxuICAgIGxldCB4ID0gbmV3Tm9kZTtcbiAgICB3aGlsZSAoeCAhPT0gVC5yb290ICYmIGdldE5vZGVDb2xvcih4LnBhcmVudCkgPT09IDEgLyogTm9kZUNvbG9yLlJlZCAqLykge1xuICAgICAgICBpZiAoeC5wYXJlbnQgPT09IHgucGFyZW50LnBhcmVudC5sZWZ0KSB7XG4gICAgICAgICAgICBjb25zdCB5ID0geC5wYXJlbnQucGFyZW50LnJpZ2h0O1xuICAgICAgICAgICAgaWYgKGdldE5vZGVDb2xvcih5KSA9PT0gMSAvKiBOb2RlQ29sb3IuUmVkICovKSB7XG4gICAgICAgICAgICAgICAgc2V0Tm9kZUNvbG9yKHgucGFyZW50LCAwIC8qIE5vZGVDb2xvci5CbGFjayAqLyk7XG4gICAgICAgICAgICAgICAgc2V0Tm9kZUNvbG9yKHksIDAgLyogTm9kZUNvbG9yLkJsYWNrICovKTtcbiAgICAgICAgICAgICAgICBzZXROb2RlQ29sb3IoeC5wYXJlbnQucGFyZW50LCAxIC8qIE5vZGVDb2xvci5SZWQgKi8pO1xuICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0geC5wYXJlbnQucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Um90YXRlKFQsIHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXROb2RlQ29sb3IoeC5wYXJlbnQsIDAgLyogTm9kZUNvbG9yLkJsYWNrICovKTtcbiAgICAgICAgICAgICAgICBzZXROb2RlQ29sb3IoeC5wYXJlbnQucGFyZW50LCAxIC8qIE5vZGVDb2xvci5SZWQgKi8pO1xuICAgICAgICAgICAgICAgIHJpZ2h0Um90YXRlKFQsIHgucGFyZW50LnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB5ID0geC5wYXJlbnQucGFyZW50LmxlZnQ7XG4gICAgICAgICAgICBpZiAoZ2V0Tm9kZUNvbG9yKHkpID09PSAxIC8qIE5vZGVDb2xvci5SZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBzZXROb2RlQ29sb3IoeC5wYXJlbnQsIDAgLyogTm9kZUNvbG9yLkJsYWNrICovKTtcbiAgICAgICAgICAgICAgICBzZXROb2RlQ29sb3IoeSwgMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pO1xuICAgICAgICAgICAgICAgIHNldE5vZGVDb2xvcih4LnBhcmVudC5wYXJlbnQsIDEgLyogTm9kZUNvbG9yLlJlZCAqLyk7XG4gICAgICAgICAgICAgICAgeCA9IHgucGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSB4LnBhcmVudC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRSb3RhdGUoVCwgeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldE5vZGVDb2xvcih4LnBhcmVudCwgMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pO1xuICAgICAgICAgICAgICAgIHNldE5vZGVDb2xvcih4LnBhcmVudC5wYXJlbnQsIDEgLyogTm9kZUNvbG9yLlJlZCAqLyk7XG4gICAgICAgICAgICAgICAgbGVmdFJvdGF0ZShULCB4LnBhcmVudC5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldE5vZGVDb2xvcihULnJvb3QsIDAgLyogTm9kZUNvbG9yLkJsYWNrICovKTtcbiAgICByZXR1cm4gbmV3Tm9kZTtcbn1cbmZ1bmN0aW9uIHRyZWVJbnNlcnQoVCwgeikge1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgbGV0IHggPSBULnJvb3Q7XG4gICAgY29uc3QgekFic29sdXRlU3RhcnQgPSB6LnN0YXJ0O1xuICAgIGNvbnN0IHpBYnNvbHV0ZUVuZCA9IHouZW5kO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IGludGVydmFsQ29tcGFyZSh6QWJzb2x1dGVTdGFydCwgekFic29sdXRlRW5kLCB4LnN0YXJ0ICsgZGVsdGEsIHguZW5kICsgZGVsdGEpO1xuICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgLy8gdGhpcyBub2RlIHNob3VsZCBiZSBpbnNlcnRlZCB0byB0aGUgbGVmdFxuICAgICAgICAgICAgLy8gPT4gaXQgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSBub2RlJ3MgZGVsdGFcbiAgICAgICAgICAgIGlmICh4LmxlZnQgPT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICAgICAgei5zdGFydCAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB6LmVuZCAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB6Lm1heEVuZCAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB4LmxlZnQgPSB6O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IHgubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICAvLyA9PiBpdCBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIG5vZGUncyBkZWx0YVxuICAgICAgICAgICAgaWYgKHgucmlnaHQgPT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICAgICAgei5zdGFydCAtPSAoZGVsdGEgKyB4LmRlbHRhKTtcbiAgICAgICAgICAgICAgICB6LmVuZCAtPSAoZGVsdGEgKyB4LmRlbHRhKTtcbiAgICAgICAgICAgICAgICB6Lm1heEVuZCAtPSAoZGVsdGEgKyB4LmRlbHRhKTtcbiAgICAgICAgICAgICAgICB4LnJpZ2h0ID0gejtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbHRhICs9IHguZGVsdGE7XG4gICAgICAgICAgICAgICAgeCA9IHgucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgei5wYXJlbnQgPSB4O1xuICAgIHoubGVmdCA9IFNFTlRJTkVMO1xuICAgIHoucmlnaHQgPSBTRU5USU5FTDtcbiAgICBzZXROb2RlQ29sb3IoeiwgMSAvKiBOb2RlQ29sb3IuUmVkICovKTtcbn1cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIERlbGV0aW9uXG5mdW5jdGlvbiByYlRyZWVEZWxldGUoVCwgeikge1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuICAgIC8vIFJCLURFTEVURSBleGNlcHQgd2UgZG9uJ3Qgc3dhcCB6IGFuZCB5IGluIGNhc2UgYylcbiAgICAvLyBpLmUuIHdlIGFsd2F5cyBkZWxldGUgd2hhdCdzIHBvaW50ZWQgYXQgYnkgei5cbiAgICBpZiAoei5sZWZ0ID09PSBTRU5USU5FTCkge1xuICAgICAgICB4ID0gei5yaWdodDtcbiAgICAgICAgeSA9IHo7XG4gICAgICAgIC8vIHgncyBkZWx0YSBpcyBubyBsb25nZXIgaW5mbHVlbmNlZCBieSB6J3MgZGVsdGFcbiAgICAgICAgeC5kZWx0YSArPSB6LmRlbHRhO1xuICAgICAgICBpZiAoeC5kZWx0YSA8IC0xMDczNzQxODI0IC8qIENvbnN0YW50cy5NSU5fU0FGRV9ERUxUQSAqLyB8fCB4LmRlbHRhID4gMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUFYX1NBRkVfREVMVEEgKi8pIHtcbiAgICAgICAgICAgIFQucmVxdWVzdE5vcm1hbGl6ZURlbHRhID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB4LnN0YXJ0ICs9IHouZGVsdGE7XG4gICAgICAgIHguZW5kICs9IHouZGVsdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHoucmlnaHQgPT09IFNFTlRJTkVMKSB7XG4gICAgICAgIHggPSB6LmxlZnQ7XG4gICAgICAgIHkgPSB6O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeSA9IGxlZnRlc3Qoei5yaWdodCk7XG4gICAgICAgIHggPSB5LnJpZ2h0O1xuICAgICAgICAvLyB5J3MgZGVsdGEgaXMgbm8gbG9uZ2VyIGluZmx1ZW5jZWQgYnkgeidzIGRlbHRhLFxuICAgICAgICAvLyBidXQgd2UgZG9uJ3Qgd2FudCB0byB3YWxrIHRoZSBlbnRpcmUgcmlnaHQtaGFuZC1zaWRlIHN1YnRyZWUgb2YgeC5cbiAgICAgICAgLy8gd2UgdGhlcmVmb3JlIG1haW50YWluIHoncyBkZWx0YSBpbiB5LCBhbmQgYWRqdXN0IG9ubHkgeFxuICAgICAgICB4LnN0YXJ0ICs9IHkuZGVsdGE7XG4gICAgICAgIHguZW5kICs9IHkuZGVsdGE7XG4gICAgICAgIHguZGVsdGEgKz0geS5kZWx0YTtcbiAgICAgICAgaWYgKHguZGVsdGEgPCAtMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUlOX1NBRkVfREVMVEEgKi8gfHwgeC5kZWx0YSA+IDEwNzM3NDE4MjQgLyogQ29uc3RhbnRzLk1BWF9TQUZFX0RFTFRBICovKSB7XG4gICAgICAgICAgICBULnJlcXVlc3ROb3JtYWxpemVEZWx0YSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgeS5zdGFydCArPSB6LmRlbHRhO1xuICAgICAgICB5LmVuZCArPSB6LmRlbHRhO1xuICAgICAgICB5LmRlbHRhID0gei5kZWx0YTtcbiAgICAgICAgaWYgKHkuZGVsdGEgPCAtMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUlOX1NBRkVfREVMVEEgKi8gfHwgeS5kZWx0YSA+IDEwNzM3NDE4MjQgLyogQ29uc3RhbnRzLk1BWF9TQUZFX0RFTFRBICovKSB7XG4gICAgICAgICAgICBULnJlcXVlc3ROb3JtYWxpemVEZWx0YSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHkgPT09IFQucm9vdCkge1xuICAgICAgICBULnJvb3QgPSB4O1xuICAgICAgICBzZXROb2RlQ29sb3IoeCwgMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pO1xuICAgICAgICB6LmRldGFjaCgpO1xuICAgICAgICByZXNldFNlbnRpbmVsKCk7XG4gICAgICAgIHJlY29tcHV0ZU1heEVuZCh4KTtcbiAgICAgICAgVC5yb290LnBhcmVudCA9IFNFTlRJTkVMO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHlXYXNSZWQgPSAoZ2V0Tm9kZUNvbG9yKHkpID09PSAxIC8qIE5vZGVDb2xvci5SZWQgKi8pO1xuICAgIGlmICh5ID09PSB5LnBhcmVudC5sZWZ0KSB7XG4gICAgICAgIHkucGFyZW50LmxlZnQgPSB4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeS5wYXJlbnQucmlnaHQgPSB4O1xuICAgIH1cbiAgICBpZiAoeSA9PT0geikge1xuICAgICAgICB4LnBhcmVudCA9IHkucGFyZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHkucGFyZW50ID09PSB6KSB7XG4gICAgICAgICAgICB4LnBhcmVudCA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4LnBhcmVudCA9IHkucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHkubGVmdCA9IHoubGVmdDtcbiAgICAgICAgeS5yaWdodCA9IHoucmlnaHQ7XG4gICAgICAgIHkucGFyZW50ID0gei5wYXJlbnQ7XG4gICAgICAgIHNldE5vZGVDb2xvcih5LCBnZXROb2RlQ29sb3IoeikpO1xuICAgICAgICBpZiAoeiA9PT0gVC5yb290KSB7XG4gICAgICAgICAgICBULnJvb3QgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHogPT09IHoucGFyZW50LmxlZnQpIHtcbiAgICAgICAgICAgICAgICB6LnBhcmVudC5sZWZ0ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHoucGFyZW50LnJpZ2h0ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoeS5sZWZ0ICE9PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgeS5sZWZ0LnBhcmVudCA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkucmlnaHQgIT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICB5LnJpZ2h0LnBhcmVudCA9IHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgei5kZXRhY2goKTtcbiAgICBpZiAoeVdhc1JlZCkge1xuICAgICAgICByZWNvbXB1dGVNYXhFbmRXYWxrVG9Sb290KHgucGFyZW50KTtcbiAgICAgICAgaWYgKHkgIT09IHopIHtcbiAgICAgICAgICAgIHJlY29tcHV0ZU1heEVuZFdhbGtUb1Jvb3QoeSk7XG4gICAgICAgICAgICByZWNvbXB1dGVNYXhFbmRXYWxrVG9Sb290KHkucGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXNldFNlbnRpbmVsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVjb21wdXRlTWF4RW5kV2Fsa1RvUm9vdCh4KTtcbiAgICByZWNvbXB1dGVNYXhFbmRXYWxrVG9Sb290KHgucGFyZW50KTtcbiAgICBpZiAoeSAhPT0geikge1xuICAgICAgICByZWNvbXB1dGVNYXhFbmRXYWxrVG9Sb290KHkpO1xuICAgICAgICByZWNvbXB1dGVNYXhFbmRXYWxrVG9Sb290KHkucGFyZW50KTtcbiAgICB9XG4gICAgLy8gUkItREVMRVRFLUZJWFVQXG4gICAgbGV0IHc7XG4gICAgd2hpbGUgKHggIT09IFQucm9vdCAmJiBnZXROb2RlQ29sb3IoeCkgPT09IDAgLyogTm9kZUNvbG9yLkJsYWNrICovKSB7XG4gICAgICAgIGlmICh4ID09PSB4LnBhcmVudC5sZWZ0KSB7XG4gICAgICAgICAgICB3ID0geC5wYXJlbnQucmlnaHQ7XG4gICAgICAgICAgICBpZiAoZ2V0Tm9kZUNvbG9yKHcpID09PSAxIC8qIE5vZGVDb2xvci5SZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBzZXROb2RlQ29sb3IodywgMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pO1xuICAgICAgICAgICAgICAgIHNldE5vZGVDb2xvcih4LnBhcmVudCwgMSAvKiBOb2RlQ29sb3IuUmVkICovKTtcbiAgICAgICAgICAgICAgICBsZWZ0Um90YXRlKFQsIHgucGFyZW50KTtcbiAgICAgICAgICAgICAgICB3ID0geC5wYXJlbnQucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0Tm9kZUNvbG9yKHcubGVmdCkgPT09IDAgLyogTm9kZUNvbG9yLkJsYWNrICovICYmIGdldE5vZGVDb2xvcih3LnJpZ2h0KSA9PT0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pIHtcbiAgICAgICAgICAgICAgICBzZXROb2RlQ29sb3IodywgMSAvKiBOb2RlQ29sb3IuUmVkICovKTtcbiAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Tm9kZUNvbG9yKHcucmlnaHQpID09PSAwIC8qIE5vZGVDb2xvci5CbGFjayAqLykge1xuICAgICAgICAgICAgICAgICAgICBzZXROb2RlQ29sb3Iody5sZWZ0LCAwIC8qIE5vZGVDb2xvci5CbGFjayAqLyk7XG4gICAgICAgICAgICAgICAgICAgIHNldE5vZGVDb2xvcih3LCAxIC8qIE5vZGVDb2xvci5SZWQgKi8pO1xuICAgICAgICAgICAgICAgICAgICByaWdodFJvdGF0ZShULCB3KTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHgucGFyZW50LnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXROb2RlQ29sb3IodywgZ2V0Tm9kZUNvbG9yKHgucGFyZW50KSk7XG4gICAgICAgICAgICAgICAgc2V0Tm9kZUNvbG9yKHgucGFyZW50LCAwIC8qIE5vZGVDb2xvci5CbGFjayAqLyk7XG4gICAgICAgICAgICAgICAgc2V0Tm9kZUNvbG9yKHcucmlnaHQsIDAgLyogTm9kZUNvbG9yLkJsYWNrICovKTtcbiAgICAgICAgICAgICAgICBsZWZ0Um90YXRlKFQsIHgucGFyZW50KTtcbiAgICAgICAgICAgICAgICB4ID0gVC5yb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdyA9IHgucGFyZW50LmxlZnQ7XG4gICAgICAgICAgICBpZiAoZ2V0Tm9kZUNvbG9yKHcpID09PSAxIC8qIE5vZGVDb2xvci5SZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBzZXROb2RlQ29sb3IodywgMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pO1xuICAgICAgICAgICAgICAgIHNldE5vZGVDb2xvcih4LnBhcmVudCwgMSAvKiBOb2RlQ29sb3IuUmVkICovKTtcbiAgICAgICAgICAgICAgICByaWdodFJvdGF0ZShULCB4LnBhcmVudCk7XG4gICAgICAgICAgICAgICAgdyA9IHgucGFyZW50LmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0Tm9kZUNvbG9yKHcubGVmdCkgPT09IDAgLyogTm9kZUNvbG9yLkJsYWNrICovICYmIGdldE5vZGVDb2xvcih3LnJpZ2h0KSA9PT0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pIHtcbiAgICAgICAgICAgICAgICBzZXROb2RlQ29sb3IodywgMSAvKiBOb2RlQ29sb3IuUmVkICovKTtcbiAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Tm9kZUNvbG9yKHcubGVmdCkgPT09IDAgLyogTm9kZUNvbG9yLkJsYWNrICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldE5vZGVDb2xvcih3LnJpZ2h0LCAwIC8qIE5vZGVDb2xvci5CbGFjayAqLyk7XG4gICAgICAgICAgICAgICAgICAgIHNldE5vZGVDb2xvcih3LCAxIC8qIE5vZGVDb2xvci5SZWQgKi8pO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Um90YXRlKFQsIHcpO1xuICAgICAgICAgICAgICAgICAgICB3ID0geC5wYXJlbnQubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0Tm9kZUNvbG9yKHcsIGdldE5vZGVDb2xvcih4LnBhcmVudCkpO1xuICAgICAgICAgICAgICAgIHNldE5vZGVDb2xvcih4LnBhcmVudCwgMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pO1xuICAgICAgICAgICAgICAgIHNldE5vZGVDb2xvcih3LmxlZnQsIDAgLyogTm9kZUNvbG9yLkJsYWNrICovKTtcbiAgICAgICAgICAgICAgICByaWdodFJvdGF0ZShULCB4LnBhcmVudCk7XG4gICAgICAgICAgICAgICAgeCA9IFQucm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXROb2RlQ29sb3IoeCwgMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pO1xuICAgIHJlc2V0U2VudGluZWwoKTtcbn1cbmZ1bmN0aW9uIGxlZnRlc3Qobm9kZSkge1xuICAgIHdoaWxlIChub2RlLmxlZnQgIT09IFNFTlRJTkVMKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVzZXRTZW50aW5lbCgpIHtcbiAgICBTRU5USU5FTC5wYXJlbnQgPSBTRU5USU5FTDtcbiAgICBTRU5USU5FTC5kZWx0YSA9IDA7IC8vIG9wdGlvbmFsXG4gICAgU0VOVElORUwuc3RhcnQgPSAwOyAvLyBvcHRpb25hbFxuICAgIFNFTlRJTkVMLmVuZCA9IDA7IC8vIG9wdGlvbmFsXG59XG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBSb3RhdGlvbnNcbmZ1bmN0aW9uIGxlZnRSb3RhdGUoVCwgeCkge1xuICAgIGNvbnN0IHkgPSB4LnJpZ2h0OyAvLyBzZXQgeS5cbiAgICB5LmRlbHRhICs9IHguZGVsdGE7IC8vIHkncyBkZWx0YSBpcyBubyBsb25nZXIgaW5mbHVlbmNlZCBieSB4J3MgZGVsdGFcbiAgICBpZiAoeS5kZWx0YSA8IC0xMDczNzQxODI0IC8qIENvbnN0YW50cy5NSU5fU0FGRV9ERUxUQSAqLyB8fCB5LmRlbHRhID4gMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUFYX1NBRkVfREVMVEEgKi8pIHtcbiAgICAgICAgVC5yZXF1ZXN0Tm9ybWFsaXplRGVsdGEgPSB0cnVlO1xuICAgIH1cbiAgICB5LnN0YXJ0ICs9IHguZGVsdGE7XG4gICAgeS5lbmQgKz0geC5kZWx0YTtcbiAgICB4LnJpZ2h0ID0geS5sZWZ0OyAvLyB0dXJuIHkncyBsZWZ0IHN1YnRyZWUgaW50byB4J3MgcmlnaHQgc3VidHJlZS5cbiAgICBpZiAoeS5sZWZ0ICE9PSBTRU5USU5FTCkge1xuICAgICAgICB5LmxlZnQucGFyZW50ID0geDtcbiAgICB9XG4gICAgeS5wYXJlbnQgPSB4LnBhcmVudDsgLy8gbGluayB4J3MgcGFyZW50IHRvIHkuXG4gICAgaWYgKHgucGFyZW50ID09PSBTRU5USU5FTCkge1xuICAgICAgICBULnJvb3QgPSB5O1xuICAgIH1cbiAgICBlbHNlIGlmICh4ID09PSB4LnBhcmVudC5sZWZ0KSB7XG4gICAgICAgIHgucGFyZW50LmxlZnQgPSB5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeC5wYXJlbnQucmlnaHQgPSB5O1xuICAgIH1cbiAgICB5LmxlZnQgPSB4OyAvLyBwdXQgeCBvbiB5J3MgbGVmdC5cbiAgICB4LnBhcmVudCA9IHk7XG4gICAgcmVjb21wdXRlTWF4RW5kKHgpO1xuICAgIHJlY29tcHV0ZU1heEVuZCh5KTtcbn1cbmZ1bmN0aW9uIHJpZ2h0Um90YXRlKFQsIHkpIHtcbiAgICBjb25zdCB4ID0geS5sZWZ0O1xuICAgIHkuZGVsdGEgLT0geC5kZWx0YTtcbiAgICBpZiAoeS5kZWx0YSA8IC0xMDczNzQxODI0IC8qIENvbnN0YW50cy5NSU5fU0FGRV9ERUxUQSAqLyB8fCB5LmRlbHRhID4gMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUFYX1NBRkVfREVMVEEgKi8pIHtcbiAgICAgICAgVC5yZXF1ZXN0Tm9ybWFsaXplRGVsdGEgPSB0cnVlO1xuICAgIH1cbiAgICB5LnN0YXJ0IC09IHguZGVsdGE7XG4gICAgeS5lbmQgLT0geC5kZWx0YTtcbiAgICB5LmxlZnQgPSB4LnJpZ2h0O1xuICAgIGlmICh4LnJpZ2h0ICE9PSBTRU5USU5FTCkge1xuICAgICAgICB4LnJpZ2h0LnBhcmVudCA9IHk7XG4gICAgfVxuICAgIHgucGFyZW50ID0geS5wYXJlbnQ7XG4gICAgaWYgKHkucGFyZW50ID09PSBTRU5USU5FTCkge1xuICAgICAgICBULnJvb3QgPSB4O1xuICAgIH1cbiAgICBlbHNlIGlmICh5ID09PSB5LnBhcmVudC5yaWdodCkge1xuICAgICAgICB5LnBhcmVudC5yaWdodCA9IHg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB5LnBhcmVudC5sZWZ0ID0geDtcbiAgICB9XG4gICAgeC5yaWdodCA9IHk7XG4gICAgeS5wYXJlbnQgPSB4O1xuICAgIHJlY29tcHV0ZU1heEVuZCh5KTtcbiAgICByZWNvbXB1dGVNYXhFbmQoeCk7XG59XG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBtYXggZW5kIGNvbXB1dGF0aW9uXG5mdW5jdGlvbiBjb21wdXRlTWF4RW5kKG5vZGUpIHtcbiAgICBsZXQgbWF4RW5kID0gbm9kZS5lbmQ7XG4gICAgaWYgKG5vZGUubGVmdCAhPT0gU0VOVElORUwpIHtcbiAgICAgICAgY29uc3QgbGVmdE1heEVuZCA9IG5vZGUubGVmdC5tYXhFbmQ7XG4gICAgICAgIGlmIChsZWZ0TWF4RW5kID4gbWF4RW5kKSB7XG4gICAgICAgICAgICBtYXhFbmQgPSBsZWZ0TWF4RW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLnJpZ2h0ICE9PSBTRU5USU5FTCkge1xuICAgICAgICBjb25zdCByaWdodE1heEVuZCA9IG5vZGUucmlnaHQubWF4RW5kICsgbm9kZS5kZWx0YTtcbiAgICAgICAgaWYgKHJpZ2h0TWF4RW5kID4gbWF4RW5kKSB7XG4gICAgICAgICAgICBtYXhFbmQgPSByaWdodE1heEVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4RW5kO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlY29tcHV0ZU1heEVuZChub2RlKSB7XG4gICAgbm9kZS5tYXhFbmQgPSBjb21wdXRlTWF4RW5kKG5vZGUpO1xufVxuZnVuY3Rpb24gcmVjb21wdXRlTWF4RW5kV2Fsa1RvUm9vdChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUgIT09IFNFTlRJTkVMKSB7XG4gICAgICAgIGNvbnN0IG1heEVuZCA9IGNvbXB1dGVNYXhFbmQobm9kZSk7XG4gICAgICAgIGlmIChub2RlLm1heEVuZCA9PT0gbWF4RW5kKSB7XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIGdvIGZ1cnRoZXJcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm1heEVuZCA9IG1heEVuZDtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbn1cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHV0aWxzXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJ2YWxDb21wYXJlKGFTdGFydCwgYUVuZCwgYlN0YXJ0LCBiRW5kKSB7XG4gICAgaWYgKGFTdGFydCA9PT0gYlN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBhRW5kIC0gYkVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGFTdGFydCAtIGJTdGFydDtcbn1cbi8vI2VuZHJlZ2lvblxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4uLy4uL2NvcmUvcG9zaXRpb24uanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi8uLi9jb3JlL3JhbmdlLmpzJztcbmltcG9ydCB7IEZpbmRNYXRjaCB9IGZyb20gJy4uLy4uL21vZGVsLmpzJztcbmltcG9ydCB7IFNFTlRJTkVMLCBUcmVlTm9kZSwgZml4SW5zZXJ0LCBsZWZ0ZXN0LCByYkRlbGV0ZSwgcmlnaHR0ZXN0LCB1cGRhdGVUcmVlTWV0YWRhdGEgfSBmcm9tICcuL3JiVHJlZUJhc2UuanMnO1xuaW1wb3J0IHsgU2VhcmNoZXIsIGNyZWF0ZUZpbmRNYXRjaCwgaXNWYWxpZE1hdGNoIH0gZnJvbSAnLi4vdGV4dE1vZGVsU2VhcmNoLmpzJztcbi8vIGNvbnN0IGxmUmVnZXggPSBuZXcgUmVnRXhwKC9cXHJcXG58XFxyfFxcbi9nKTtcbmNvbnN0IEF2ZXJhZ2VCdWZmZXJTaXplID0gNjU1MzU7XG5mdW5jdGlvbiBjcmVhdGVVaW50QXJyYXkoYXJyKSB7XG4gICAgbGV0IHI7XG4gICAgaWYgKGFyclthcnIubGVuZ3RoIC0gMV0gPCA2NTUzNikge1xuICAgICAgICByID0gbmV3IFVpbnQxNkFycmF5KGFyci5sZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgciA9IG5ldyBVaW50MzJBcnJheShhcnIubGVuZ3RoKTtcbiAgICB9XG4gICAgci5zZXQoYXJyLCAwKTtcbiAgICByZXR1cm4gcjtcbn1cbmNsYXNzIExpbmVTdGFydHMge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVTdGFydHMsIGNyLCBsZiwgY3JsZiwgaXNCYXNpY0FTQ0lJKSB7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0cyA9IGxpbmVTdGFydHM7XG4gICAgICAgIHRoaXMuY3IgPSBjcjtcbiAgICAgICAgdGhpcy5sZiA9IGxmO1xuICAgICAgICB0aGlzLmNybGYgPSBjcmxmO1xuICAgICAgICB0aGlzLmlzQmFzaWNBU0NJSSA9IGlzQmFzaWNBU0NJSTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGluZVN0YXJ0c0Zhc3Qoc3RyLCByZWFkb25seSA9IHRydWUpIHtcbiAgICBjb25zdCByID0gWzBdO1xuICAgIGxldCByTGVuZ3RoID0gMTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNociA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hyID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLykge1xuICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuICYmIHN0ci5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBcXHJcXG4uLi4gY2FzZVxuICAgICAgICAgICAgICAgIHJbckxlbmd0aCsrXSA9IGkgKyAyO1xuICAgICAgICAgICAgICAgIGkrKzsgLy8gc2tpcCBcXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFxcci4uLiBjYXNlXG4gICAgICAgICAgICAgICAgcltyTGVuZ3RoKytdID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hyID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgcltyTGVuZ3RoKytdID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlYWRvbmx5KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVVaW50QXJyYXkocik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGluZVN0YXJ0cyhyLCBzdHIpIHtcbiAgICByLmxlbmd0aCA9IDA7XG4gICAgclswXSA9IDA7XG4gICAgbGV0IHJMZW5ndGggPSAxO1xuICAgIGxldCBjciA9IDAsIGxmID0gMCwgY3JsZiA9IDA7XG4gICAgbGV0IGlzQmFzaWNBU0NJSSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNociA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8pIHtcbiAgICAgICAgICAgIGlmIChpICsgMSA8IGxlbiAmJiBzdHIuY2hhckNvZGVBdChpICsgMSkgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XG4gICAgICAgICAgICAgICAgLy8gXFxyXFxuLi4uIGNhc2VcbiAgICAgICAgICAgICAgICBjcmxmKys7XG4gICAgICAgICAgICAgICAgcltyTGVuZ3RoKytdID0gaSArIDI7XG4gICAgICAgICAgICAgICAgaSsrOyAvLyBza2lwIFxcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3IrKztcbiAgICAgICAgICAgICAgICAvLyBcXHIuLi4gY2FzZVxuICAgICAgICAgICAgICAgIHJbckxlbmd0aCsrXSA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNociA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgIGxmKys7XG4gICAgICAgICAgICByW3JMZW5ndGgrK10gPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0Jhc2ljQVNDSUkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hyICE9PSA5IC8qIENoYXJDb2RlLlRhYiAqLyAmJiAoY2hyIDwgMzIgfHwgY2hyID4gMTI2KSkge1xuICAgICAgICAgICAgICAgICAgICBpc0Jhc2ljQVNDSUkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IExpbmVTdGFydHMoY3JlYXRlVWludEFycmF5KHIpLCBjciwgbGYsIGNybGYsIGlzQmFzaWNBU0NJSSk7XG4gICAgci5sZW5ndGggPSAwO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY2xhc3MgUGllY2Uge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlckluZGV4LCBzdGFydCwgZW5kLCBsaW5lRmVlZENudCwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVySW5kZXggPSBidWZmZXJJbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5saW5lRmVlZENudCA9IGxpbmVGZWVkQ250O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3RyaW5nQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGxpbmVTdGFydHMpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0cyA9IGxpbmVTdGFydHM7XG4gICAgfVxufVxuLyoqXG4gKiBSZWFkb25seSBzbmFwc2hvdCBmb3IgcGllY2UgdHJlZS5cbiAqIEluIGEgcmVhbCBtdWx0aXBsZSB0aHJlYWQgZW52aXJvbm1lbnQsIHRvIG1ha2Ugc25hcHNob3QgcmVhZGluZyBhbHdheXMgd29yayBjb3JyZWN0bHksIHdlIG5lZWQgdG9cbiAqIDEuIE1ha2UgVHJlZU5vZGUucGllY2UgaW1tdXRhYmxlLCB0aGVuIHJlYWRpbmcgYW5kIHdyaXRpbmcgY2FuIHJ1biBpbiBwYXJhbGxlbC5cbiAqIDIuIFRyZWVOb2RlL0J1ZmZlcnMgbm9ybWFsaXphdGlvbiBzaG91bGQgbm90IGhhcHBlbiBkdXJpbmcgc25hcHNob3QgcmVhZGluZy5cbiAqL1xuY2xhc3MgUGllY2VUcmVlU25hcHNob3Qge1xuICAgIGNvbnN0cnVjdG9yKHRyZWUsIEJPTSkge1xuICAgICAgICB0aGlzLl9waWVjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMuX0JPTSA9IEJPTTtcbiAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICBpZiAodHJlZS5yb290ICE9PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgdHJlZS5pdGVyYXRlKHRyZWUucm9vdCwgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BpZWNlcy5wdXNoKG5vZGUucGllY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9waWVjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9CT007XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5kZXggPiB0aGlzLl9waWVjZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fQk9NICsgdGhpcy5fdHJlZS5nZXRQaWVjZUNvbnRlbnQodGhpcy5fcGllY2VzW3RoaXMuX2luZGV4KytdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZS5nZXRQaWVjZUNvbnRlbnQodGhpcy5fcGllY2VzW3RoaXMuX2luZGV4KytdKTtcbiAgICB9XG59XG5jbGFzcyBQaWVjZVRyZWVTZWFyY2hDYWNoZSB7XG4gICAgY29uc3RydWN0b3IobGltaXQpIHtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBbXTtcbiAgICB9XG4gICAgZ2V0KG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fY2FjaGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVQb3MgPSB0aGlzLl9jYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChub2RlUG9zLm5vZGVTdGFydE9mZnNldCA8PSBvZmZzZXQgJiYgbm9kZVBvcy5ub2RlU3RhcnRPZmZzZXQgKyBub2RlUG9zLm5vZGUucGllY2UubGVuZ3RoID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlUG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQyKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2NhY2hlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlUG9zID0gdGhpcy5fY2FjaGVbaV07XG4gICAgICAgICAgICBpZiAobm9kZVBvcy5ub2RlU3RhcnRMaW5lTnVtYmVyICYmIG5vZGVQb3Mubm9kZVN0YXJ0TGluZU51bWJlciA8IGxpbmVOdW1iZXIgJiYgbm9kZVBvcy5ub2RlU3RhcnRMaW5lTnVtYmVyICsgbm9kZVBvcy5ub2RlLnBpZWNlLmxpbmVGZWVkQ250ID49IGxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2V0KG5vZGVQb3NpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGUubGVuZ3RoID49IHRoaXMuX2xpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhY2hlLnB1c2gobm9kZVBvc2l0aW9uKTtcbiAgICB9XG4gICAgdmFsaWRhdGUob2Zmc2V0KSB7XG4gICAgICAgIGxldCBoYXNJbnZhbGlkVmFsID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHRtcCA9IHRoaXMuX2NhY2hlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZVBvcyA9IHRtcFtpXTtcbiAgICAgICAgICAgIGlmIChub2RlUG9zLm5vZGUucGFyZW50ID09PSBudWxsIHx8IG5vZGVQb3Mubm9kZVN0YXJ0T2Zmc2V0ID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRtcFtpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaGFzSW52YWxpZFZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0ludmFsaWRWYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FyciA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0bXApIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3QXJyLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gbmV3QXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFBpZWNlVHJlZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNodW5rcywgZW9sLCBlb2xOb3JtYWxpemVkKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlKGNodW5rcywgZW9sLCBlb2xOb3JtYWxpemVkKTtcbiAgICB9XG4gICAgY3JlYXRlKGNodW5rcywgZW9sLCBlb2xOb3JtYWxpemVkKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnMgPSBbXG4gICAgICAgICAgICBuZXcgU3RyaW5nQnVmZmVyKCcnLCBbMF0pXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xhc3RDaGFuZ2VCdWZmZXJQb3MgPSB7IGxpbmU6IDAsIGNvbHVtbjogMCB9O1xuICAgICAgICB0aGlzLnJvb3QgPSBTRU5USU5FTDtcbiAgICAgICAgdGhpcy5fbGluZUNudCA9IDE7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX0VPTCA9IGVvbDtcbiAgICAgICAgdGhpcy5fRU9MTGVuZ3RoID0gZW9sLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fRU9MTm9ybWFsaXplZCA9IGVvbE5vcm1hbGl6ZWQ7XG4gICAgICAgIGxldCBsYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjaHVua3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaHVua3NbaV0uYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNodW5rc1tpXS5saW5lU3RhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1tpXS5saW5lU3RhcnRzID0gY3JlYXRlTGluZVN0YXJ0c0Zhc3QoY2h1bmtzW2ldLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gbmV3IFBpZWNlKGkgKyAxLCB7IGxpbmU6IDAsIGNvbHVtbjogMCB9LCB7IGxpbmU6IGNodW5rc1tpXS5saW5lU3RhcnRzLmxlbmd0aCAtIDEsIGNvbHVtbjogY2h1bmtzW2ldLmJ1ZmZlci5sZW5ndGggLSBjaHVua3NbaV0ubGluZVN0YXJ0c1tjaHVua3NbaV0ubGluZVN0YXJ0cy5sZW5ndGggLSAxXSB9LCBjaHVua3NbaV0ubGluZVN0YXJ0cy5sZW5ndGggLSAxLCBjaHVua3NbaV0uYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rc1tpXSk7XG4gICAgICAgICAgICAgICAgbGFzdE5vZGUgPSB0aGlzLnJiSW5zZXJ0UmlnaHQobGFzdE5vZGUsIHBpZWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZWFyY2hDYWNoZSA9IG5ldyBQaWVjZVRyZWVTZWFyY2hDYWNoZSgxKTtcbiAgICAgICAgdGhpcy5fbGFzdFZpc2l0ZWRMaW5lID0geyBsaW5lTnVtYmVyOiAwLCB2YWx1ZTogJycgfTtcbiAgICAgICAgdGhpcy5jb21wdXRlQnVmZmVyTWV0YWRhdGEoKTtcbiAgICB9XG4gICAgbm9ybWFsaXplRU9MKGVvbCkge1xuICAgICAgICBjb25zdCBhdmVyYWdlQnVmZmVyU2l6ZSA9IEF2ZXJhZ2VCdWZmZXJTaXplO1xuICAgICAgICBjb25zdCBtaW4gPSBhdmVyYWdlQnVmZmVyU2l6ZSAtIE1hdGguZmxvb3IoYXZlcmFnZUJ1ZmZlclNpemUgLyAzKTtcbiAgICAgICAgY29uc3QgbWF4ID0gbWluICogMjtcbiAgICAgICAgbGV0IHRlbXBDaHVuayA9ICcnO1xuICAgICAgICBsZXQgdGVtcENodW5rTGVuID0gMDtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuaXRlcmF0ZSh0aGlzLnJvb3QsIG5vZGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RyID0gdGhpcy5nZXROb2RlQ29udGVudChub2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGVtcENodW5rTGVuIDw9IG1pbiB8fCB0ZW1wQ2h1bmtMZW4gKyBsZW4gPCBtYXgpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ2h1bmsgKz0gc3RyO1xuICAgICAgICAgICAgICAgIHRlbXBDaHVua0xlbiArPSBsZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmbHVzaCBhbnl3YXlzXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGVtcENodW5rLnJlcGxhY2UoL1xcclxcbnxcXHJ8XFxuL2csIGVvbCk7XG4gICAgICAgICAgICBjaHVua3MucHVzaChuZXcgU3RyaW5nQnVmZmVyKHRleHQsIGNyZWF0ZUxpbmVTdGFydHNGYXN0KHRleHQpKSk7XG4gICAgICAgICAgICB0ZW1wQ2h1bmsgPSBzdHI7XG4gICAgICAgICAgICB0ZW1wQ2h1bmtMZW4gPSBsZW47XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0ZW1wQ2h1bmtMZW4gPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGVtcENodW5rLnJlcGxhY2UoL1xcclxcbnxcXHJ8XFxuL2csIGVvbCk7XG4gICAgICAgICAgICBjaHVua3MucHVzaChuZXcgU3RyaW5nQnVmZmVyKHRleHQsIGNyZWF0ZUxpbmVTdGFydHNGYXN0KHRleHQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGUoY2h1bmtzLCBlb2wsIHRydWUpO1xuICAgIH1cbiAgICAvLyAjcmVnaW9uIEJ1ZmZlciBBUElcbiAgICBnZXRFT0woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9FT0w7XG4gICAgfVxuICAgIHNldEVPTChuZXdFT0wpIHtcbiAgICAgICAgdGhpcy5fRU9MID0gbmV3RU9MO1xuICAgICAgICB0aGlzLl9FT0xMZW5ndGggPSB0aGlzLl9FT0wubGVuZ3RoO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUVPTChuZXdFT0wpO1xuICAgIH1cbiAgICBjcmVhdGVTbmFwc2hvdChCT00pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQaWVjZVRyZWVTbmFwc2hvdCh0aGlzLCBCT00pO1xuICAgIH1cbiAgICBnZXRPZmZzZXRBdChsaW5lTnVtYmVyLCBjb2x1bW4pIHtcbiAgICAgICAgbGV0IGxlZnRMZW4gPSAwOyAvLyBpbm9yZGVyXG4gICAgICAgIGxldCB4ID0gdGhpcy5yb290O1xuICAgICAgICB3aGlsZSAoeCAhPT0gU0VOVElORUwpIHtcbiAgICAgICAgICAgIGlmICh4LmxlZnQgIT09IFNFTlRJTkVMICYmIHgubGZfbGVmdCArIDEgPj0gbGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHggPSB4LmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4LmxmX2xlZnQgKyB4LnBpZWNlLmxpbmVGZWVkQ250ICsgMSA+PSBsaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgbGVmdExlbiArPSB4LnNpemVfbGVmdDtcbiAgICAgICAgICAgICAgICAvLyBsaW5lTnVtYmVyID49IDJcbiAgICAgICAgICAgICAgICBjb25zdCBhY2N1bXVhbHRlZFZhbEluQ3VycmVudEluZGV4ID0gdGhpcy5nZXRBY2N1bXVsYXRlZFZhbHVlKHgsIGxpbmVOdW1iZXIgLSB4LmxmX2xlZnQgLSAyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdExlbiArPSBhY2N1bXVhbHRlZFZhbEluQ3VycmVudEluZGV4ICsgY29sdW1uIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIgLT0geC5sZl9sZWZ0ICsgeC5waWVjZS5saW5lRmVlZENudDtcbiAgICAgICAgICAgICAgICBsZWZ0TGVuICs9IHguc2l6ZV9sZWZ0ICsgeC5waWVjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgeCA9IHgucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnRMZW47XG4gICAgfVxuICAgIGdldFBvc2l0aW9uQXQob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGguZmxvb3Iob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IHggPSB0aGlzLnJvb3Q7XG4gICAgICAgIGxldCBsZkNudCA9IDA7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB3aGlsZSAoeCAhPT0gU0VOVElORUwpIHtcbiAgICAgICAgICAgIGlmICh4LnNpemVfbGVmdCAhPT0gMCAmJiB4LnNpemVfbGVmdCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB4ID0geC5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeC5zaXplX2xlZnQgKyB4LnBpZWNlLmxlbmd0aCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSB0aGlzLmdldEluZGV4T2YoeCwgb2Zmc2V0IC0geC5zaXplX2xlZnQpO1xuICAgICAgICAgICAgICAgIGxmQ250ICs9IHgubGZfbGVmdCArIG91dC5pbmRleDtcbiAgICAgICAgICAgICAgICBpZiAob3V0LmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVTdGFydE9mZnNldCA9IHRoaXMuZ2V0T2Zmc2V0QXQobGZDbnQgKyAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gb3JpZ2luYWxPZmZzZXQgLSBsaW5lU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obGZDbnQgKyAxLCBjb2x1bW4gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihsZkNudCArIDEsIG91dC5yZW1haW5kZXIgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCAtPSB4LnNpemVfbGVmdCArIHgucGllY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxmQ250ICs9IHgubGZfbGVmdCArIHgucGllY2UubGluZUZlZWRDbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHgucmlnaHQgPT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxhc3Qgbm9kZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lU3RhcnRPZmZzZXQgPSB0aGlzLmdldE9mZnNldEF0KGxmQ250ICsgMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IG9yaWdpbmFsT2Zmc2V0IC0gb2Zmc2V0IC0gbGluZVN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxmQ250ICsgMSwgY29sdW1uICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ID0geC5yaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbigxLCAxKTtcbiAgICB9XG4gICAgZ2V0VmFsdWVJblJhbmdlKHJhbmdlLCBlb2wpIHtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlciAmJiByYW5nZS5zdGFydENvbHVtbiA9PT0gcmFuZ2UuZW5kQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHRoaXMubm9kZUF0MihyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uKTtcbiAgICAgICAgY29uc3QgZW5kUG9zaXRpb24gPSB0aGlzLm5vZGVBdDIocmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlSW5SYW5nZTIoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgICBpZiAoZW9sKSB7XG4gICAgICAgICAgICBpZiAoZW9sICE9PSB0aGlzLl9FT0wgfHwgIXRoaXMuX0VPTE5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXFxyXFxufFxccnxcXG4vZywgZW9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlb2wgPT09IHRoaXMuZ2V0RU9MKCkgJiYgdGhpcy5fRU9MTm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGlmIChlb2wgPT09ICdcXHJcXG4nKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXHJcXG58XFxyfFxcbi9nLCBlb2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0VmFsdWVJblJhbmdlMihzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xuICAgICAgICBpZiAoc3RhcnRQb3NpdGlvbi5ub2RlID09PSBlbmRQb3NpdGlvbi5ub2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gc3RhcnRQb3NpdGlvbi5ub2RlO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fYnVmZmVyc1tub2RlLnBpZWNlLmJ1ZmZlckluZGV4XS5idWZmZXI7XG4gICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0SW5CdWZmZXIobm9kZS5waWVjZS5idWZmZXJJbmRleCwgbm9kZS5waWVjZS5zdGFydCk7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnN1YnN0cmluZyhzdGFydE9mZnNldCArIHN0YXJ0UG9zaXRpb24ucmVtYWluZGVyLCBzdGFydE9mZnNldCArIGVuZFBvc2l0aW9uLnJlbWFpbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHggPSBzdGFydFBvc2l0aW9uLm5vZGU7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcnNbeC5waWVjZS5idWZmZXJJbmRleF0uYnVmZmVyO1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0SW5CdWZmZXIoeC5waWVjZS5idWZmZXJJbmRleCwgeC5waWVjZS5zdGFydCk7XG4gICAgICAgIGxldCByZXQgPSBidWZmZXIuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0ICsgc3RhcnRQb3NpdGlvbi5yZW1haW5kZXIsIHN0YXJ0T2Zmc2V0ICsgeC5waWVjZS5sZW5ndGgpO1xuICAgICAgICB4ID0geC5uZXh0KCk7XG4gICAgICAgIHdoaWxlICh4ICE9PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fYnVmZmVyc1t4LnBpZWNlLmJ1ZmZlckluZGV4XS5idWZmZXI7XG4gICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0SW5CdWZmZXIoeC5waWVjZS5idWZmZXJJbmRleCwgeC5waWVjZS5zdGFydCk7XG4gICAgICAgICAgICBpZiAoeCA9PT0gZW5kUG9zaXRpb24ubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldCArPSBidWZmZXIuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCBzdGFydE9mZnNldCArIGVuZFBvc2l0aW9uLnJlbWFpbmRlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgKz0gYnVmZmVyLnN1YnN0cihzdGFydE9mZnNldCwgeC5waWVjZS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCA9IHgubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGdldExpbmVzQ29udGVudCgpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICAgICAgbGV0IGxpbmVzTGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRMaW5lID0gJyc7XG4gICAgICAgIGxldCBkYW5nbGluZ0NSID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXRlcmF0ZSh0aGlzLnJvb3QsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IG5vZGUucGllY2U7XG4gICAgICAgICAgICBsZXQgcGllY2VMZW5ndGggPSBwaWVjZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocGllY2VMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcnNbcGllY2UuYnVmZmVySW5kZXhdLmJ1ZmZlcjtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVTdGFydHMgPSB0aGlzLl9idWZmZXJzW3BpZWNlLmJ1ZmZlckluZGV4XS5saW5lU3RhcnRzO1xuICAgICAgICAgICAgY29uc3QgcGllY2VTdGFydExpbmUgPSBwaWVjZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgY29uc3QgcGllY2VFbmRMaW5lID0gcGllY2UuZW5kLmxpbmU7XG4gICAgICAgICAgICBsZXQgcGllY2VTdGFydE9mZnNldCA9IGxpbmVTdGFydHNbcGllY2VTdGFydExpbmVdICsgcGllY2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgaWYgKGRhbmdsaW5nQ1IpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmNoYXJDb2RlQXQocGllY2VTdGFydE9mZnNldCkgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXRlbmQgdGhlIFxcbiB3YXMgaW4gdGhlIHByZXZpb3VzIHBpZWNlLi5cbiAgICAgICAgICAgICAgICAgICAgcGllY2VTdGFydE9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICBwaWVjZUxlbmd0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lc1tsaW5lc0xlbmd0aCsrXSA9IGN1cnJlbnRMaW5lO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgZGFuZ2xpbmdDUiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChwaWVjZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGllY2VTdGFydExpbmUgPT09IHBpZWNlRW5kTGluZSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgcGllY2UgaGFzIG5vIG5ldyBsaW5lc1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fRU9MTm9ybWFsaXplZCAmJiBidWZmZXIuY2hhckNvZGVBdChwaWVjZVN0YXJ0T2Zmc2V0ICsgcGllY2VMZW5ndGggLSAxKSA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZGFuZ2xpbmdDUiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lICs9IGJ1ZmZlci5zdWJzdHIocGllY2VTdGFydE9mZnNldCwgcGllY2VMZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lICs9IGJ1ZmZlci5zdWJzdHIocGllY2VTdGFydE9mZnNldCwgcGllY2VMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgdGV4dCBiZWZvcmUgdGhlIGZpcnN0IGxpbmUgc3RhcnQgaW4gdGhpcyBwaWVjZVxuICAgICAgICAgICAgY3VycmVudExpbmUgKz0gKHRoaXMuX0VPTE5vcm1hbGl6ZWRcbiAgICAgICAgICAgICAgICA/IGJ1ZmZlci5zdWJzdHJpbmcocGllY2VTdGFydE9mZnNldCwgTWF0aC5tYXgocGllY2VTdGFydE9mZnNldCwgbGluZVN0YXJ0c1twaWVjZVN0YXJ0TGluZSArIDFdIC0gdGhpcy5fRU9MTGVuZ3RoKSlcbiAgICAgICAgICAgICAgICA6IGJ1ZmZlci5zdWJzdHJpbmcocGllY2VTdGFydE9mZnNldCwgbGluZVN0YXJ0c1twaWVjZVN0YXJ0TGluZSArIDFdKS5yZXBsYWNlKC8oXFxyXFxufFxccnxcXG4pJC8sICcnKSk7XG4gICAgICAgICAgICBsaW5lc1tsaW5lc0xlbmd0aCsrXSA9IGN1cnJlbnRMaW5lO1xuICAgICAgICAgICAgZm9yIChsZXQgbGluZSA9IHBpZWNlU3RhcnRMaW5lICsgMTsgbGluZSA8IHBpZWNlRW5kTGluZTsgbGluZSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmUgPSAodGhpcy5fRU9MTm9ybWFsaXplZFxuICAgICAgICAgICAgICAgICAgICA/IGJ1ZmZlci5zdWJzdHJpbmcobGluZVN0YXJ0c1tsaW5lXSwgbGluZVN0YXJ0c1tsaW5lICsgMV0gLSB0aGlzLl9FT0xMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIDogYnVmZmVyLnN1YnN0cmluZyhsaW5lU3RhcnRzW2xpbmVdLCBsaW5lU3RhcnRzW2xpbmUgKyAxXSkucmVwbGFjZSgvKFxcclxcbnxcXHJ8XFxuKSQvLCAnJykpO1xuICAgICAgICAgICAgICAgIGxpbmVzW2xpbmVzTGVuZ3RoKytdID0gY3VycmVudExpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX0VPTE5vcm1hbGl6ZWQgJiYgYnVmZmVyLmNoYXJDb2RlQXQobGluZVN0YXJ0c1twaWVjZUVuZExpbmVdICsgcGllY2UuZW5kLmNvbHVtbiAtIDEpID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLykge1xuICAgICAgICAgICAgICAgIGRhbmdsaW5nQ1IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwaWVjZS5lbmQuY29sdW1uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsYXN0IGxpbmUgZW5kZWQgd2l0aCBhIFxcciwgbGV0J3MgdW5kbyB0aGUgcHVzaCwgaXQgd2lsbCBiZSBwdXNoZWQgYnkgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgbGluZXNMZW5ndGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gYnVmZmVyLnN1YnN0cihsaW5lU3RhcnRzW3BpZWNlRW5kTGluZV0sIHBpZWNlLmVuZC5jb2x1bW4gLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZSA9IGJ1ZmZlci5zdWJzdHIobGluZVN0YXJ0c1twaWVjZUVuZExpbmVdLCBwaWVjZS5lbmQuY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRhbmdsaW5nQ1IpIHtcbiAgICAgICAgICAgIGxpbmVzW2xpbmVzTGVuZ3RoKytdID0gY3VycmVudExpbmU7XG4gICAgICAgICAgICBjdXJyZW50TGluZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVzW2xpbmVzTGVuZ3RoKytdID0gY3VycmVudExpbmU7XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgZ2V0TGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgIH1cbiAgICBnZXRMaW5lQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lQ250O1xuICAgIH1cbiAgICBnZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0VmlzaXRlZExpbmUubGluZU51bWJlciA9PT0gbGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RWaXNpdGVkTGluZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0VmlzaXRlZExpbmUubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgIGlmIChsaW5lTnVtYmVyID09PSB0aGlzLl9saW5lQ250KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VmlzaXRlZExpbmUudmFsdWUgPSB0aGlzLmdldExpbmVSYXdDb250ZW50KGxpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX0VPTE5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RWaXNpdGVkTGluZS52YWx1ZSA9IHRoaXMuZ2V0TGluZVJhd0NvbnRlbnQobGluZU51bWJlciwgdGhpcy5fRU9MTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RWaXNpdGVkTGluZS52YWx1ZSA9IHRoaXMuZ2V0TGluZVJhd0NvbnRlbnQobGluZU51bWJlcikucmVwbGFjZSgvKFxcclxcbnxcXHJ8XFxuKSQvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RWaXNpdGVkTGluZS52YWx1ZTtcbiAgICB9XG4gICAgX2dldENoYXJDb2RlKG5vZGVQb3MpIHtcbiAgICAgICAgaWYgKG5vZGVQb3MucmVtYWluZGVyID09PSBub2RlUG9zLm5vZGUucGllY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyB0aGUgY2hhciB3ZSB3YW50IHRvIGZldGNoIGlzIGF0IHRoZSBoZWFkIG9mIG5leHQgbm9kZS5cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nTm9kZSA9IG5vZGVQb3Mubm9kZS5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoaW5nTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fYnVmZmVyc1ttYXRjaGluZ05vZGUucGllY2UuYnVmZmVySW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldEluQnVmZmVyKG1hdGNoaW5nTm9kZS5waWVjZS5idWZmZXJJbmRleCwgbWF0Y2hpbmdOb2RlLnBpZWNlLnN0YXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuYnVmZmVyLmNoYXJDb2RlQXQoc3RhcnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fYnVmZmVyc1tub2RlUG9zLm5vZGUucGllY2UuYnVmZmVySW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldEluQnVmZmVyKG5vZGVQb3Mubm9kZS5waWVjZS5idWZmZXJJbmRleCwgbm9kZVBvcy5ub2RlLnBpZWNlLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgbm9kZVBvcy5yZW1haW5kZXI7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLmJ1ZmZlci5jaGFyQ29kZUF0KHRhcmdldE9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TGluZUNoYXJDb2RlKGxpbmVOdW1iZXIsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG5vZGVQb3MgPSB0aGlzLm5vZGVBdDIobGluZU51bWJlciwgaW5kZXggKyAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENoYXJDb2RlKG5vZGVQb3MpO1xuICAgIH1cbiAgICBnZXRMaW5lTGVuZ3RoKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgaWYgKGxpbmVOdW1iZXIgPT09IHRoaXMuZ2V0TGluZUNvdW50KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXRBdChsaW5lTnVtYmVyLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExlbmd0aCgpIC0gc3RhcnRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2Zmc2V0QXQobGluZU51bWJlciArIDEsIDEpIC0gdGhpcy5nZXRPZmZzZXRBdChsaW5lTnVtYmVyLCAxKSAtIHRoaXMuX0VPTExlbmd0aDtcbiAgICB9XG4gICAgZmluZE1hdGNoZXNJbk5vZGUobm9kZSwgc2VhcmNoZXIsIHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIHN0YXJ0Q3Vyc29yLCBlbmRDdXJzb3IsIHNlYXJjaERhdGEsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50LCByZXN1bHRMZW4sIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9idWZmZXJzW25vZGUucGllY2UuYnVmZmVySW5kZXhdO1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldEluQnVmZmVyID0gdGhpcy5vZmZzZXRJbkJ1ZmZlcihub2RlLnBpZWNlLmJ1ZmZlckluZGV4LCBub2RlLnBpZWNlLnN0YXJ0KTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLm9mZnNldEluQnVmZmVyKG5vZGUucGllY2UuYnVmZmVySW5kZXgsIHN0YXJ0Q3Vyc29yKTtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5vZmZzZXRJbkJ1ZmZlcihub2RlLnBpZWNlLmJ1ZmZlckluZGV4LCBlbmRDdXJzb3IpO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgLy8gUmVzZXQgcmVnZXggdG8gc2VhcmNoIGZyb20gdGhlIGJlZ2lubmluZ1xuICAgICAgICBjb25zdCByZXQgPSB7IGxpbmU6IDAsIGNvbHVtbjogMCB9O1xuICAgICAgICBsZXQgc2VhcmNoVGV4dDtcbiAgICAgICAgbGV0IG9mZnNldEluQnVmZmVyO1xuICAgICAgICBpZiAoc2VhcmNoZXIuX3dvcmRTZXBhcmF0b3JzKSB7XG4gICAgICAgICAgICBzZWFyY2hUZXh0ID0gYnVmZmVyLmJ1ZmZlci5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICBvZmZzZXRJbkJ1ZmZlciA9IChvZmZzZXQpID0+IG9mZnNldCArIHN0YXJ0O1xuICAgICAgICAgICAgc2VhcmNoZXIucmVzZXQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWFyY2hUZXh0ID0gYnVmZmVyLmJ1ZmZlcjtcbiAgICAgICAgICAgIG9mZnNldEluQnVmZmVyID0gKG9mZnNldCkgPT4gb2Zmc2V0O1xuICAgICAgICAgICAgc2VhcmNoZXIucmVzZXQoc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG0gPSBzZWFyY2hlci5uZXh0KHNlYXJjaFRleHQpO1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0SW5CdWZmZXIobS5pbmRleCkgPj0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRMZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25JbkJ1ZmZlcihub2RlLCBvZmZzZXRJbkJ1ZmZlcihtLmluZGV4KSAtIHN0YXJ0T2Zmc2V0SW5CdWZmZXIsIHJldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUZlZWRDbnQgPSB0aGlzLmdldExpbmVGZWVkQ250KG5vZGUucGllY2UuYnVmZmVySW5kZXgsIHN0YXJ0Q3Vyc29yLCByZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldFN0YXJ0Q29sdW1uID0gcmV0LmxpbmUgPT09IHN0YXJ0Q3Vyc29yLmxpbmUgPyByZXQuY29sdW1uIC0gc3RhcnRDdXJzb3IuY29sdW1uICsgc3RhcnRDb2x1bW4gOiByZXQuY29sdW1uICsgMTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRFbmRDb2x1bW4gPSByZXRTdGFydENvbHVtbiArIG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBjcmVhdGVGaW5kTWF0Y2gobmV3IFJhbmdlKHN0YXJ0TGluZU51bWJlciArIGxpbmVGZWVkQ250LCByZXRTdGFydENvbHVtbiwgc3RhcnRMaW5lTnVtYmVyICsgbGluZUZlZWRDbnQsIHJldEVuZENvbHVtbiksIG0sIGNhcHR1cmVNYXRjaGVzKTtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0SW5CdWZmZXIobS5pbmRleCkgKyBtWzBdLmxlbmd0aCA+PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdExlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdExlbiA+PSBsaW1pdFJlc3VsdENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRMZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChtKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdExlbjtcbiAgICB9XG4gICAgZmluZE1hdGNoZXNMaW5lQnlMaW5lKHNlYXJjaFJhbmdlLCBzZWFyY2hEYXRhLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IHJlc3VsdExlbiA9IDA7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gbmV3IFNlYXJjaGVyKHNlYXJjaERhdGEud29yZFNlcGFyYXRvcnMsIHNlYXJjaERhdGEucmVnZXgpO1xuICAgICAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMubm9kZUF0MihzZWFyY2hSYW5nZS5zdGFydExpbmVOdW1iZXIsIHNlYXJjaFJhbmdlLnN0YXJ0Q29sdW1uKTtcbiAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmRQb3NpdGlvbiA9IHRoaXMubm9kZUF0MihzZWFyY2hSYW5nZS5lbmRMaW5lTnVtYmVyLCBzZWFyY2hSYW5nZS5lbmRDb2x1bW4pO1xuICAgICAgICBpZiAoZW5kUG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5CdWZmZXIoc3RhcnRQb3NpdGlvbi5ub2RlLCBzdGFydFBvc2l0aW9uLnJlbWFpbmRlcik7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMucG9zaXRpb25JbkJ1ZmZlcihlbmRQb3NpdGlvbi5ub2RlLCBlbmRQb3NpdGlvbi5yZW1haW5kZXIpO1xuICAgICAgICBpZiAoc3RhcnRQb3NpdGlvbi5ub2RlID09PSBlbmRQb3NpdGlvbi5ub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRNYXRjaGVzSW5Ob2RlKHN0YXJ0UG9zaXRpb24ubm9kZSwgc2VhcmNoZXIsIHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlciwgc2VhcmNoUmFuZ2Uuc3RhcnRDb2x1bW4sIHN0YXJ0LCBlbmQsIHNlYXJjaERhdGEsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50LCByZXN1bHRMZW4sIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydExpbmVOdW1iZXIgPSBzZWFyY2hSYW5nZS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGxldCBjdXJyZW50Tm9kZSA9IHN0YXJ0UG9zaXRpb24ubm9kZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBlbmRQb3NpdGlvbi5ub2RlKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lQnJlYWtDbnQgPSB0aGlzLmdldExpbmVGZWVkQ250KGN1cnJlbnROb2RlLnBpZWNlLmJ1ZmZlckluZGV4LCBzdGFydCwgY3VycmVudE5vZGUucGllY2UuZW5kKTtcbiAgICAgICAgICAgIGlmIChsaW5lQnJlYWtDbnQgPj0gMSkge1xuICAgICAgICAgICAgICAgIC8vIGxhc3QgbGluZSBicmVhayBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVTdGFydHMgPSB0aGlzLl9idWZmZXJzW2N1cnJlbnROb2RlLnBpZWNlLmJ1ZmZlckluZGV4XS5saW5lU3RhcnRzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0SW5CdWZmZXIgPSB0aGlzLm9mZnNldEluQnVmZmVyKGN1cnJlbnROb2RlLnBpZWNlLmJ1ZmZlckluZGV4LCBjdXJyZW50Tm9kZS5waWVjZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dExpbmVTdGFydE9mZnNldCA9IGxpbmVTdGFydHNbc3RhcnQubGluZSArIGxpbmVCcmVha0NudF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRDb2x1bW4gPSBzdGFydExpbmVOdW1iZXIgPT09IHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlciA/IHNlYXJjaFJhbmdlLnN0YXJ0Q29sdW1uIDogMTtcbiAgICAgICAgICAgICAgICByZXN1bHRMZW4gPSB0aGlzLmZpbmRNYXRjaGVzSW5Ob2RlKGN1cnJlbnROb2RlLCBzZWFyY2hlciwgc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgc3RhcnQsIHRoaXMucG9zaXRpb25JbkJ1ZmZlcihjdXJyZW50Tm9kZSwgbmV4dExpbmVTdGFydE9mZnNldCAtIHN0YXJ0T2Zmc2V0SW5CdWZmZXIpLCBzZWFyY2hEYXRhLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCwgcmVzdWx0TGVuLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRMZW4gPj0gbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgKz0gbGluZUJyZWFrQ250O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhcnRDb2x1bW4gPSBzdGFydExpbmVOdW1iZXIgPT09IHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlciA/IHNlYXJjaFJhbmdlLnN0YXJ0Q29sdW1uIC0gMSA6IDA7XG4gICAgICAgICAgICAvLyBzZWFyY2ggZm9yIHRoZSByZW1haW5pbmcgY29udGVudFxuICAgICAgICAgICAgaWYgKHN0YXJ0TGluZU51bWJlciA9PT0gc2VhcmNoUmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLmdldExpbmVDb250ZW50KHN0YXJ0TGluZU51bWJlcikuc3Vic3RyaW5nKHN0YXJ0Q29sdW1uLCBzZWFyY2hSYW5nZS5lbmRDb2x1bW4gLSAxKTtcbiAgICAgICAgICAgICAgICByZXN1bHRMZW4gPSB0aGlzLl9maW5kTWF0Y2hlc0luTGluZShzZWFyY2hEYXRhLCBzZWFyY2hlciwgdGV4dCwgc2VhcmNoUmFuZ2UuZW5kTGluZU51bWJlciwgc3RhcnRDb2x1bW4sIHJlc3VsdExlbiwgcmVzdWx0LCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdExlbiA9IHRoaXMuX2ZpbmRNYXRjaGVzSW5MaW5lKHNlYXJjaERhdGEsIHNlYXJjaGVyLCB0aGlzLmdldExpbmVDb250ZW50KHN0YXJ0TGluZU51bWJlcikuc3Vic3RyKHN0YXJ0Q29sdW1uKSwgc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgcmVzdWx0TGVuLCByZXN1bHQsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRMZW4gPj0gbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIrKztcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSB0aGlzLm5vZGVBdDIoc3RhcnRMaW5lTnVtYmVyLCAxKTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gc3RhcnRQb3NpdGlvbi5ub2RlO1xuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5CdWZmZXIoc3RhcnRQb3NpdGlvbi5ub2RlLCBzdGFydFBvc2l0aW9uLnJlbWFpbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0TGluZU51bWJlciA9PT0gc2VhcmNoUmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRDb2x1bW4gPSBzdGFydExpbmVOdW1iZXIgPT09IHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlciA/IHNlYXJjaFJhbmdlLnN0YXJ0Q29sdW1uIC0gMSA6IDA7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXRMaW5lQ29udGVudChzdGFydExpbmVOdW1iZXIpLnN1YnN0cmluZyhzdGFydENvbHVtbiwgc2VhcmNoUmFuZ2UuZW5kQ29sdW1uIC0gMSk7XG4gICAgICAgICAgICByZXN1bHRMZW4gPSB0aGlzLl9maW5kTWF0Y2hlc0luTGluZShzZWFyY2hEYXRhLCBzZWFyY2hlciwgdGV4dCwgc2VhcmNoUmFuZ2UuZW5kTGluZU51bWJlciwgc3RhcnRDb2x1bW4sIHJlc3VsdExlbiwgcmVzdWx0LCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29sdW1uID0gc3RhcnRMaW5lTnVtYmVyID09PSBzZWFyY2hSYW5nZS5zdGFydExpbmVOdW1iZXIgPyBzZWFyY2hSYW5nZS5zdGFydENvbHVtbiA6IDE7XG4gICAgICAgIHJlc3VsdExlbiA9IHRoaXMuZmluZE1hdGNoZXNJbk5vZGUoZW5kUG9zaXRpb24ubm9kZSwgc2VhcmNoZXIsIHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIHN0YXJ0LCBlbmQsIHNlYXJjaERhdGEsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50LCByZXN1bHRMZW4sIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9maW5kTWF0Y2hlc0luTGluZShzZWFyY2hEYXRhLCBzZWFyY2hlciwgdGV4dCwgbGluZU51bWJlciwgZGVsdGFPZmZzZXQsIHJlc3VsdExlbiwgcmVzdWx0LCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICBjb25zdCB3b3JkU2VwYXJhdG9ycyA9IHNlYXJjaERhdGEud29yZFNlcGFyYXRvcnM7XG4gICAgICAgIGlmICghY2FwdHVyZU1hdGNoZXMgJiYgc2VhcmNoRGF0YS5zaW1wbGVTZWFyY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFN0cmluZyA9IHNlYXJjaERhdGEuc2ltcGxlU2VhcmNoO1xuICAgICAgICAgICAgY29uc3Qgc2VhcmNoU3RyaW5nTGVuID0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBsYXN0TWF0Y2hJbmRleCA9IC1zZWFyY2hTdHJpbmdMZW47XG4gICAgICAgICAgICB3aGlsZSAoKGxhc3RNYXRjaEluZGV4ID0gdGV4dC5pbmRleE9mKHNlYXJjaFN0cmluZywgbGFzdE1hdGNoSW5kZXggKyBzZWFyY2hTdHJpbmdMZW4pKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmRTZXBhcmF0b3JzIHx8IGlzVmFsaWRNYXRjaCh3b3JkU2VwYXJhdG9ycywgdGV4dCwgdGV4dExlbmd0aCwgbGFzdE1hdGNoSW5kZXgsIHNlYXJjaFN0cmluZ0xlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBGaW5kTWF0Y2gobmV3IFJhbmdlKGxpbmVOdW1iZXIsIGxhc3RNYXRjaEluZGV4ICsgMSArIGRlbHRhT2Zmc2V0LCBsaW5lTnVtYmVyLCBsYXN0TWF0Y2hJbmRleCArIDEgKyBzZWFyY2hTdHJpbmdMZW4gKyBkZWx0YU9mZnNldCksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0TGVuID49IGxpbWl0UmVzdWx0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRMZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0TGVuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtO1xuICAgICAgICAvLyBSZXNldCByZWdleCB0byBzZWFyY2ggZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgICAgIHNlYXJjaGVyLnJlc2V0KDApO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBtID0gc2VhcmNoZXIubmV4dCh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IGNyZWF0ZUZpbmRNYXRjaChuZXcgUmFuZ2UobGluZU51bWJlciwgbS5pbmRleCArIDEgKyBkZWx0YU9mZnNldCwgbGluZU51bWJlciwgbS5pbmRleCArIDEgKyBtWzBdLmxlbmd0aCArIGRlbHRhT2Zmc2V0KSwgbSwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRMZW4gPj0gbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0TGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobSk7XG4gICAgICAgIHJldHVybiByZXN1bHRMZW47XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIFBpZWNlIFRhYmxlXG4gICAgaW5zZXJ0KG9mZnNldCwgdmFsdWUsIGVvbE5vcm1hbGl6ZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9FT0xOb3JtYWxpemVkID0gdGhpcy5fRU9MTm9ybWFsaXplZCAmJiBlb2xOb3JtYWxpemVkO1xuICAgICAgICB0aGlzLl9sYXN0VmlzaXRlZExpbmUubGluZU51bWJlciA9IDA7XG4gICAgICAgIHRoaXMuX2xhc3RWaXNpdGVkTGluZS52YWx1ZSA9ICcnO1xuICAgICAgICBpZiAodGhpcy5yb290ICE9PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlLCByZW1haW5kZXIsIG5vZGVTdGFydE9mZnNldCB9ID0gdGhpcy5ub2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gbm9kZS5waWVjZTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckluZGV4ID0gcGllY2UuYnVmZmVySW5kZXg7XG4gICAgICAgICAgICBjb25zdCBpbnNlcnRQb3NJbkJ1ZmZlciA9IHRoaXMucG9zaXRpb25JbkJ1ZmZlcihub2RlLCByZW1haW5kZXIpO1xuICAgICAgICAgICAgaWYgKG5vZGUucGllY2UuYnVmZmVySW5kZXggPT09IDAgJiZcbiAgICAgICAgICAgICAgICBwaWVjZS5lbmQubGluZSA9PT0gdGhpcy5fbGFzdENoYW5nZUJ1ZmZlclBvcy5saW5lICYmXG4gICAgICAgICAgICAgICAgcGllY2UuZW5kLmNvbHVtbiA9PT0gdGhpcy5fbGFzdENoYW5nZUJ1ZmZlclBvcy5jb2x1bW4gJiZcbiAgICAgICAgICAgICAgICAobm9kZVN0YXJ0T2Zmc2V0ICsgcGllY2UubGVuZ3RoID09PSBvZmZzZXQpICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoIDwgQXZlcmFnZUJ1ZmZlclNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VkIGJ1ZmZlclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9Ob2RlKG5vZGUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVCdWZmZXJNZXRhZGF0YSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlU3RhcnRPZmZzZXQgPT09IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0Q29udGVudFRvTm9kZUxlZnQodmFsdWUsIG5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlYXJjaENhY2hlLnZhbGlkYXRlKG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlU3RhcnRPZmZzZXQgKyBub2RlLnBpZWNlLmxlbmd0aCA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBpbnNlcnRpbmcgaW50byB0aGUgbWlkZGxlIG9mIGEgbm9kZS5cbiAgICAgICAgICAgICAgICBjb25zdCBub2Rlc1RvRGVsID0gW107XG4gICAgICAgICAgICAgICAgbGV0IG5ld1JpZ2h0UGllY2UgPSBuZXcgUGllY2UocGllY2UuYnVmZmVySW5kZXgsIGluc2VydFBvc0luQnVmZmVyLCBwaWVjZS5lbmQsIHRoaXMuZ2V0TGluZUZlZWRDbnQocGllY2UuYnVmZmVySW5kZXgsIGluc2VydFBvc0luQnVmZmVyLCBwaWVjZS5lbmQpLCB0aGlzLm9mZnNldEluQnVmZmVyKGJ1ZmZlckluZGV4LCBwaWVjZS5lbmQpIC0gdGhpcy5vZmZzZXRJbkJ1ZmZlcihidWZmZXJJbmRleCwgaW5zZXJ0UG9zSW5CdWZmZXIpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRDaGVja0NSTEYoKSAmJiB0aGlzLmVuZFdpdGhDUih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZE9mUmlnaHQgPSB0aGlzLm5vZGVDaGFyQ29kZUF0KG5vZGUsIHJlbWFpbmRlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkT2ZSaWdodCA9PT0gMTAgLyoqIFxcbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U3RhcnQgPSB7IGxpbmU6IG5ld1JpZ2h0UGllY2Uuc3RhcnQubGluZSArIDEsIGNvbHVtbjogMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmlnaHRQaWVjZSA9IG5ldyBQaWVjZShuZXdSaWdodFBpZWNlLmJ1ZmZlckluZGV4LCBuZXdTdGFydCwgbmV3UmlnaHRQaWVjZS5lbmQsIHRoaXMuZ2V0TGluZUZlZWRDbnQobmV3UmlnaHRQaWVjZS5idWZmZXJJbmRleCwgbmV3U3RhcnQsIG5ld1JpZ2h0UGllY2UuZW5kKSwgbmV3UmlnaHRQaWVjZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJldXNlIG5vZGUgZm9yIGNvbnRlbnQgYmVmb3JlIGluc2VydGlvbiBwb2ludC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRDaGVja0NSTEYoKSAmJiB0aGlzLnN0YXJ0V2l0aExGKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWlsT2ZMZWZ0ID0gdGhpcy5ub2RlQ2hhckNvZGVBdChub2RlLCByZW1haW5kZXIgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhaWxPZkxlZnQgPT09IDEzIC8qKiBcXHIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUG9zID0gdGhpcy5wb3NpdGlvbkluQnVmZmVyKG5vZGUsIHJlbWFpbmRlciAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVOb2RlVGFpbChub2RlLCBwcmV2aW91c1Bvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdcXHInICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5waWVjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1RvRGVsLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZU5vZGVUYWlsKG5vZGUsIGluc2VydFBvc0luQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVOb2RlVGFpbChub2RlLCBpbnNlcnRQb3NJbkJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BpZWNlcyA9IHRoaXMuY3JlYXRlTmV3UGllY2VzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3UmlnaHRQaWVjZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmJJbnNlcnRSaWdodChub2RlLCBuZXdSaWdodFBpZWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRtcE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbmV3UGllY2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcE5vZGUgPSB0aGlzLnJiSW5zZXJ0UmlnaHQodG1wTm9kZSwgbmV3UGllY2VzW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVOb2Rlcyhub2Rlc1RvRGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0Q29udGVudFRvTm9kZVJpZ2h0KHZhbHVlLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluc2VydCBuZXcgbm9kZVxuICAgICAgICAgICAgY29uc3QgcGllY2VzID0gdGhpcy5jcmVhdGVOZXdQaWVjZXModmFsdWUpO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJiSW5zZXJ0TGVmdChudWxsLCBwaWVjZXNbMF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCBwaWVjZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5yYkluc2VydFJpZ2h0KG5vZGUsIHBpZWNlc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbywgdGhpcyBpcyB0b28gYnJ1dGFsLiBUb3RhbCBsaW5lIGZlZWQgY291bnQgc2hvdWxkIGJlIHVwZGF0ZWQgdGhlIHNhbWUgd2F5IGFzIGxmX2xlZnQuXG4gICAgICAgIHRoaXMuY29tcHV0ZUJ1ZmZlck1ldGFkYXRhKCk7XG4gICAgfVxuICAgIGRlbGV0ZShvZmZzZXQsIGNudCkge1xuICAgICAgICB0aGlzLl9sYXN0VmlzaXRlZExpbmUubGluZU51bWJlciA9IDA7XG4gICAgICAgIHRoaXMuX2xhc3RWaXNpdGVkTGluZS52YWx1ZSA9ICcnO1xuICAgICAgICBpZiAoY250IDw9IDAgfHwgdGhpcy5yb290ID09PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLm5vZGVBdChvZmZzZXQpO1xuICAgICAgICBjb25zdCBlbmRQb3NpdGlvbiA9IHRoaXMubm9kZUF0KG9mZnNldCArIGNudCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IHN0YXJ0UG9zaXRpb24ubm9kZTtcbiAgICAgICAgY29uc3QgZW5kTm9kZSA9IGVuZFBvc2l0aW9uLm5vZGU7XG4gICAgICAgIGlmIChzdGFydE5vZGUgPT09IGVuZE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3BsaXRQb3NJbkJ1ZmZlciA9IHRoaXMucG9zaXRpb25JbkJ1ZmZlcihzdGFydE5vZGUsIHN0YXJ0UG9zaXRpb24ucmVtYWluZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZFNwbGl0UG9zSW5CdWZmZXIgPSB0aGlzLnBvc2l0aW9uSW5CdWZmZXIoc3RhcnROb2RlLCBlbmRQb3NpdGlvbi5yZW1haW5kZXIpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24ubm9kZVN0YXJ0T2Zmc2V0ID09PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY250ID09PSBzdGFydE5vZGUucGllY2UubGVuZ3RoKSB7IC8vIGRlbGV0ZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBzdGFydE5vZGUubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByYkRlbGV0ZSh0aGlzLCBzdGFydE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ1JMRldpdGhQcmV2Tm9kZShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlQnVmZmVyTWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZU5vZGVIZWFkKHN0YXJ0Tm9kZSwgZW5kU3BsaXRQb3NJbkJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VhcmNoQ2FjaGUudmFsaWRhdGUob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ1JMRldpdGhQcmV2Tm9kZShzdGFydE5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJ1ZmZlck1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24ubm9kZVN0YXJ0T2Zmc2V0ICsgc3RhcnROb2RlLnBpZWNlLmxlbmd0aCA9PT0gb2Zmc2V0ICsgY250KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVOb2RlVGFpbChzdGFydE5vZGUsIHN0YXJ0U3BsaXRQb3NJbkJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNSTEZXaXRoTmV4dE5vZGUoc3RhcnROb2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVCdWZmZXJNZXRhZGF0YSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlbGV0ZSBjb250ZW50IGluIHRoZSBtaWRkbGUsIHRoaXMgbm9kZSB3aWxsIGJlIHNwbGl0dGVkIHRvIG5vZGVzXG4gICAgICAgICAgICB0aGlzLnNocmlua05vZGUoc3RhcnROb2RlLCBzdGFydFNwbGl0UG9zSW5CdWZmZXIsIGVuZFNwbGl0UG9zSW5CdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlQnVmZmVyTWV0YWRhdGEoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2Rlc1RvRGVsID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BsaXRQb3NJbkJ1ZmZlciA9IHRoaXMucG9zaXRpb25JbkJ1ZmZlcihzdGFydE5vZGUsIHN0YXJ0UG9zaXRpb24ucmVtYWluZGVyKTtcbiAgICAgICAgdGhpcy5kZWxldGVOb2RlVGFpbChzdGFydE5vZGUsIHN0YXJ0U3BsaXRQb3NJbkJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX3NlYXJjaENhY2hlLnZhbGlkYXRlKG9mZnNldCk7XG4gICAgICAgIGlmIChzdGFydE5vZGUucGllY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBub2Rlc1RvRGVsLnB1c2goc3RhcnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgbGFzdCB0b3VjaGVkIG5vZGVcbiAgICAgICAgY29uc3QgZW5kU3BsaXRQb3NJbkJ1ZmZlciA9IHRoaXMucG9zaXRpb25JbkJ1ZmZlcihlbmROb2RlLCBlbmRQb3NpdGlvbi5yZW1haW5kZXIpO1xuICAgICAgICB0aGlzLmRlbGV0ZU5vZGVIZWFkKGVuZE5vZGUsIGVuZFNwbGl0UG9zSW5CdWZmZXIpO1xuICAgICAgICBpZiAoZW5kTm9kZS5waWVjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5vZGVzVG9EZWwucHVzaChlbmROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWxldGUgbm9kZXMgaW4gYmV0d2VlblxuICAgICAgICBjb25zdCBzZWNvbmROb2RlID0gc3RhcnROb2RlLm5leHQoKTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNlY29uZE5vZGU7IG5vZGUgIT09IFNFTlRJTkVMICYmIG5vZGUgIT09IGVuZE5vZGU7IG5vZGUgPSBub2RlLm5leHQoKSkge1xuICAgICAgICAgICAgbm9kZXNUb0RlbC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXYgPSBzdGFydE5vZGUucGllY2UubGVuZ3RoID09PSAwID8gc3RhcnROb2RlLnByZXYoKSA6IHN0YXJ0Tm9kZTtcbiAgICAgICAgdGhpcy5kZWxldGVOb2Rlcyhub2Rlc1RvRGVsKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNSTEZXaXRoTmV4dE5vZGUocHJldik7XG4gICAgICAgIHRoaXMuY29tcHV0ZUJ1ZmZlck1ldGFkYXRhKCk7XG4gICAgfVxuICAgIGluc2VydENvbnRlbnRUb05vZGVMZWZ0KHZhbHVlLCBub2RlKSB7XG4gICAgICAgIC8vIHdlIGFyZSBpbnNlcnRpbmcgY29udGVudCB0byB0aGUgYmVnaW5uaW5nIG9mIG5vZGVcbiAgICAgICAgY29uc3Qgbm9kZXNUb0RlbCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRDaGVja0NSTEYoKSAmJiB0aGlzLmVuZFdpdGhDUih2YWx1ZSkgJiYgdGhpcy5zdGFydFdpdGhMRihub2RlKSkge1xuICAgICAgICAgICAgLy8gbW92ZSBgXFxuYCB0byBuZXcgbm9kZS5cbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gbm9kZS5waWVjZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXJ0ID0geyBsaW5lOiBwaWVjZS5zdGFydC5saW5lICsgMSwgY29sdW1uOiAwIH07XG4gICAgICAgICAgICBjb25zdCBuUGllY2UgPSBuZXcgUGllY2UocGllY2UuYnVmZmVySW5kZXgsIG5ld1N0YXJ0LCBwaWVjZS5lbmQsIHRoaXMuZ2V0TGluZUZlZWRDbnQocGllY2UuYnVmZmVySW5kZXgsIG5ld1N0YXJ0LCBwaWVjZS5lbmQpLCBwaWVjZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIG5vZGUucGllY2UgPSBuUGllY2U7XG4gICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIHVwZGF0ZVRyZWVNZXRhZGF0YSh0aGlzLCBub2RlLCAtMSwgLTEpO1xuICAgICAgICAgICAgaWYgKG5vZGUucGllY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNUb0RlbC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1BpZWNlcyA9IHRoaXMuY3JlYXRlTmV3UGllY2VzKHZhbHVlKTtcbiAgICAgICAgbGV0IG5ld05vZGUgPSB0aGlzLnJiSW5zZXJ0TGVmdChub2RlLCBuZXdQaWVjZXNbbmV3UGllY2VzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgZm9yIChsZXQgayA9IG5ld1BpZWNlcy5sZW5ndGggLSAyOyBrID49IDA7IGstLSkge1xuICAgICAgICAgICAgbmV3Tm9kZSA9IHRoaXMucmJJbnNlcnRMZWZ0KG5ld05vZGUsIG5ld1BpZWNlc1trXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZUNSTEZXaXRoUHJldk5vZGUobmV3Tm9kZSk7XG4gICAgICAgIHRoaXMuZGVsZXRlTm9kZXMobm9kZXNUb0RlbCk7XG4gICAgfVxuICAgIGluc2VydENvbnRlbnRUb05vZGVSaWdodCh2YWx1ZSwgbm9kZSkge1xuICAgICAgICAvLyB3ZSBhcmUgaW5zZXJ0aW5nIHRvIHRoZSByaWdodCBvZiB0aGlzIG5vZGUuXG4gICAgICAgIGlmICh0aGlzLmFkanVzdENhcnJpYWdlUmV0dXJuRnJvbU5leHQodmFsdWUsIG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBtb3ZlIFxcbiB0byB0aGUgbmV3IG5vZGUuXG4gICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdQaWVjZXMgPSB0aGlzLmNyZWF0ZU5ld1BpZWNlcyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSB0aGlzLnJiSW5zZXJ0UmlnaHQobm9kZSwgbmV3UGllY2VzWzBdKTtcbiAgICAgICAgbGV0IHRtcE5vZGUgPSBuZXdOb2RlO1xuICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IG5ld1BpZWNlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdG1wTm9kZSA9IHRoaXMucmJJbnNlcnRSaWdodCh0bXBOb2RlLCBuZXdQaWVjZXNba10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWRhdGVDUkxGV2l0aFByZXZOb2RlKG5ld05vZGUpO1xuICAgIH1cbiAgICBwb3NpdGlvbkluQnVmZmVyKG5vZGUsIHJlbWFpbmRlciwgcmV0KSB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gbm9kZS5waWVjZTtcbiAgICAgICAgY29uc3QgYnVmZmVySW5kZXggPSBub2RlLnBpZWNlLmJ1ZmZlckluZGV4O1xuICAgICAgICBjb25zdCBsaW5lU3RhcnRzID0gdGhpcy5fYnVmZmVyc1tidWZmZXJJbmRleF0ubGluZVN0YXJ0cztcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBsaW5lU3RhcnRzW3BpZWNlLnN0YXJ0LmxpbmVdICsgcGllY2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydE9mZnNldCArIHJlbWFpbmRlcjtcbiAgICAgICAgLy8gYmluYXJ5IHNlYXJjaCBvZmZzZXQgYmV0d2VlbiBzdGFydE9mZnNldCBhbmQgZW5kT2Zmc2V0XG4gICAgICAgIGxldCBsb3cgPSBwaWVjZS5zdGFydC5saW5lO1xuICAgICAgICBsZXQgaGlnaCA9IHBpZWNlLmVuZC5saW5lO1xuICAgICAgICBsZXQgbWlkID0gMDtcbiAgICAgICAgbGV0IG1pZFN0b3AgPSAwO1xuICAgICAgICBsZXQgbWlkU3RhcnQgPSAwO1xuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgICAgICAgIG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgLyAyKSB8IDA7XG4gICAgICAgICAgICBtaWRTdGFydCA9IGxpbmVTdGFydHNbbWlkXTtcbiAgICAgICAgICAgIGlmIChtaWQgPT09IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pZFN0b3AgPSBsaW5lU3RhcnRzW21pZCArIDFdO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IG1pZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvZmZzZXQgPj0gbWlkU3RvcCkge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICByZXQubGluZSA9IG1pZDtcbiAgICAgICAgICAgIHJldC5jb2x1bW4gPSBvZmZzZXQgLSBtaWRTdGFydDtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lOiBtaWQsXG4gICAgICAgICAgICBjb2x1bW46IG9mZnNldCAtIG1pZFN0YXJ0XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldExpbmVGZWVkQ250KGJ1ZmZlckluZGV4LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgc3RhcnQ6IGFiY1xccnxcXG4sIG9yIGFiY3xcXHIsIG9yIGFiY3xcXG4sIG9yIGFiY3xcXHJcXG4gZG9lc24ndCBjaGFuZ2UgdGhlIGZhY3QgdGhhdCwgdGhlcmUgaXMgb25lIGxpbmUgYnJlYWsgYWZ0ZXIgc3RhcnQuXG4gICAgICAgIC8vIG5vdyBsZXQncyB0YWtlIGNhcmUgb2YgZW5kOiBhYmNcXHJ8XFxuLCBpZiBlbmQgaXMgaW4gYmV0d2VlbiBcXHIgYW5kIFxcbiwgd2UgbmVlZCB0byBhZGQgbGluZSBmZWVkIGNvdW50IGJ5IDFcbiAgICAgICAgaWYgKGVuZC5jb2x1bW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBlbmQubGluZSAtIHN0YXJ0LmxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZVN0YXJ0cyA9IHRoaXMuX2J1ZmZlcnNbYnVmZmVySW5kZXhdLmxpbmVTdGFydHM7XG4gICAgICAgIGlmIChlbmQubGluZSA9PT0gbGluZVN0YXJ0cy5sZW5ndGggLSAxKSB7IC8vIGl0IG1lYW5zLCB0aGVyZSBpcyBubyBcXG4gYWZ0ZXIgZW5kLCBvdGhlcndpc2UsIHRoZXJlIHdpbGwgYmUgb25lIG1vcmUgbGluZVN0YXJ0LlxuICAgICAgICAgICAgcmV0dXJuIGVuZC5saW5lIC0gc3RhcnQubGluZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0TGluZVN0YXJ0T2Zmc2V0ID0gbGluZVN0YXJ0c1tlbmQubGluZSArIDFdO1xuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBsaW5lU3RhcnRzW2VuZC5saW5lXSArIGVuZC5jb2x1bW47XG4gICAgICAgIGlmIChuZXh0TGluZVN0YXJ0T2Zmc2V0ID4gZW5kT2Zmc2V0ICsgMSkgeyAvLyB0aGVyZSBhcmUgbW9yZSB0aGFuIDEgY2hhcmFjdGVyIGFmdGVyIGVuZCwgd2hpY2ggbWVhbnMgaXQgY2FuJ3QgYmUgXFxuXG4gICAgICAgICAgICByZXR1cm4gZW5kLmxpbmUgLSBzdGFydC5saW5lO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZE9mZnNldCArIDEgPT09IG5leHRMaW5lU3RhcnRPZmZzZXRcbiAgICAgICAgLy8gY2hhcmFjdGVyIGF0IGVuZE9mZnNldCBpcyBcXG4sIHNvIHdlIGNoZWNrIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGZpcnN0XG4gICAgICAgIC8vIGlmIGNoYXJhY3RlciBhdCBlbmRPZmZzZXQgaXMgXFxyLCBlbmQuY29sdW1uIGlzIDAgYW5kIHdlIGNhbid0IGdldCBoZXJlLlxuICAgICAgICBjb25zdCBwcmV2aW91c0NoYXJPZmZzZXQgPSBlbmRPZmZzZXQgLSAxOyAvLyBlbmQuY29sdW1uID4gMCBzbyBpdCdzIG9rYXkuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcnNbYnVmZmVySW5kZXhdLmJ1ZmZlcjtcbiAgICAgICAgaWYgKGJ1ZmZlci5jaGFyQ29kZUF0KHByZXZpb3VzQ2hhck9mZnNldCkgPT09IDEzKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kLmxpbmUgLSBzdGFydC5saW5lICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbmQubGluZSAtIHN0YXJ0LmxpbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2Zmc2V0SW5CdWZmZXIoYnVmZmVySW5kZXgsIGN1cnNvcikge1xuICAgICAgICBjb25zdCBsaW5lU3RhcnRzID0gdGhpcy5fYnVmZmVyc1tidWZmZXJJbmRleF0ubGluZVN0YXJ0cztcbiAgICAgICAgcmV0dXJuIGxpbmVTdGFydHNbY3Vyc29yLmxpbmVdICsgY3Vyc29yLmNvbHVtbjtcbiAgICB9XG4gICAgZGVsZXRlTm9kZXMobm9kZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmJEZWxldGUodGhpcywgbm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZU5ld1BpZWNlcyh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IEF2ZXJhZ2VCdWZmZXJTaXplKSB7XG4gICAgICAgICAgICAvLyB0aGUgY29udGVudCBpcyBsYXJnZSwgb3BlcmF0aW9ucyBsaWtlIHN1YnN0cmluZywgY2hhckNvZGUgYmVjb21lcyBzbG93XG4gICAgICAgICAgICAvLyBzbyBoZXJlIHdlIHNwbGl0IGl0IGludG8gc21hbGxlciBjaHVua3MsIGp1c3QgbGlrZSB3aGF0IHdlIGRpZCBmb3IgQ1IvTEYgbm9ybWFsaXphdGlvblxuICAgICAgICAgICAgY29uc3QgbmV3UGllY2VzID0gW107XG4gICAgICAgICAgICB3aGlsZSAodGV4dC5sZW5ndGggPiBBdmVyYWdlQnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyID0gdGV4dC5jaGFyQ29kZUF0KEF2ZXJhZ2VCdWZmZXJTaXplIC0gMSk7XG4gICAgICAgICAgICAgICAgbGV0IHNwbGl0VGV4dDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdENoYXIgPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovIHx8IChsYXN0Q2hhciA+PSAweEQ4MDAgJiYgbGFzdENoYXIgPD0gMHhEQkZGKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYXN0IGNoYXJhY3RlciBpcyBcXHIgb3IgYSBoaWdoIHN1cnJvZ2F0ZSA9PiBrZWVwIGl0IGJhY2tcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRUZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgQXZlcmFnZUJ1ZmZlclNpemUgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKEF2ZXJhZ2VCdWZmZXJTaXplIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBBdmVyYWdlQnVmZmVyU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhBdmVyYWdlQnVmZmVyU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVTdGFydHMgPSBjcmVhdGVMaW5lU3RhcnRzRmFzdChzcGxpdFRleHQpO1xuICAgICAgICAgICAgICAgIG5ld1BpZWNlcy5wdXNoKG5ldyBQaWVjZSh0aGlzLl9idWZmZXJzLmxlbmd0aCwgLyogYnVmZmVyIGluZGV4ICovIHsgbGluZTogMCwgY29sdW1uOiAwIH0sIHsgbGluZTogbGluZVN0YXJ0cy5sZW5ndGggLSAxLCBjb2x1bW46IHNwbGl0VGV4dC5sZW5ndGggLSBsaW5lU3RhcnRzW2xpbmVTdGFydHMubGVuZ3RoIC0gMV0gfSwgbGluZVN0YXJ0cy5sZW5ndGggLSAxLCBzcGxpdFRleHQubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVycy5wdXNoKG5ldyBTdHJpbmdCdWZmZXIoc3BsaXRUZXh0LCBsaW5lU3RhcnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaW5lU3RhcnRzID0gY3JlYXRlTGluZVN0YXJ0c0Zhc3QodGV4dCk7XG4gICAgICAgICAgICBuZXdQaWVjZXMucHVzaChuZXcgUGllY2UodGhpcy5fYnVmZmVycy5sZW5ndGgsIC8qIGJ1ZmZlciBpbmRleCAqLyB7IGxpbmU6IDAsIGNvbHVtbjogMCB9LCB7IGxpbmU6IGxpbmVTdGFydHMubGVuZ3RoIC0gMSwgY29sdW1uOiB0ZXh0Lmxlbmd0aCAtIGxpbmVTdGFydHNbbGluZVN0YXJ0cy5sZW5ndGggLSAxXSB9LCBsaW5lU3RhcnRzLmxlbmd0aCAtIDEsIHRleHQubGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJzLnB1c2gobmV3IFN0cmluZ0J1ZmZlcih0ZXh0LCBsaW5lU3RhcnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3UGllY2VzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydE9mZnNldCA9IHRoaXMuX2J1ZmZlcnNbMF0uYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbGluZVN0YXJ0cyA9IGNyZWF0ZUxpbmVTdGFydHNGYXN0KHRleHQsIGZhbHNlKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5fbGFzdENoYW5nZUJ1ZmZlclBvcztcbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcnNbMF0ubGluZVN0YXJ0c1t0aGlzLl9idWZmZXJzWzBdLmxpbmVTdGFydHMubGVuZ3RoIC0gMV0gPT09IHN0YXJ0T2Zmc2V0XG4gICAgICAgICAgICAmJiBzdGFydE9mZnNldCAhPT0gMFxuICAgICAgICAgICAgJiYgdGhpcy5zdGFydFdpdGhMRih0ZXh0KVxuICAgICAgICAgICAgJiYgdGhpcy5lbmRXaXRoQ1IodGhpcy5fYnVmZmVyc1swXS5idWZmZXIpIC8vIHRvZG8sIHdlIGNhbiBjaGVjayB0aGlzLl9sYXN0Q2hhbmdlQnVmZmVyUG9zJ3MgY29sdW1uIGFzIGl0J3MgdGhlIGxhc3Qgb25lXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdENoYW5nZUJ1ZmZlclBvcyA9IHsgbGluZTogdGhpcy5fbGFzdENoYW5nZUJ1ZmZlclBvcy5saW5lLCBjb2x1bW46IHRoaXMuX2xhc3RDaGFuZ2VCdWZmZXJQb3MuY29sdW1uICsgMSB9O1xuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9sYXN0Q2hhbmdlQnVmZmVyUG9zO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lU3RhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0c1tpXSArPSBzdGFydE9mZnNldCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJzWzBdLmxpbmVTdGFydHMgPSB0aGlzLl9idWZmZXJzWzBdLmxpbmVTdGFydHMuY29uY2F0KGxpbmVTdGFydHMuc2xpY2UoMSkpO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyc1swXS5idWZmZXIgKz0gJ18nICsgdGV4dDtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVTdGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0c1tpXSArPSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJzWzBdLmxpbmVTdGFydHMgPSB0aGlzLl9idWZmZXJzWzBdLmxpbmVTdGFydHMuY29uY2F0KGxpbmVTdGFydHMuc2xpY2UoMSkpO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyc1swXS5idWZmZXIgKz0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSB0aGlzLl9idWZmZXJzWzBdLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5fYnVmZmVyc1swXS5saW5lU3RhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGVuZENvbHVtbiA9IGVuZE9mZnNldCAtIHRoaXMuX2J1ZmZlcnNbMF0ubGluZVN0YXJ0c1tlbmRJbmRleF07XG4gICAgICAgIGNvbnN0IGVuZFBvcyA9IHsgbGluZTogZW5kSW5kZXgsIGNvbHVtbjogZW5kQ29sdW1uIH07XG4gICAgICAgIGNvbnN0IG5ld1BpZWNlID0gbmV3IFBpZWNlKDAsIC8qKiB0b2RvQHBlbmcgKi8gc3RhcnQsIGVuZFBvcywgdGhpcy5nZXRMaW5lRmVlZENudCgwLCBzdGFydCwgZW5kUG9zKSwgZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICB0aGlzLl9sYXN0Q2hhbmdlQnVmZmVyUG9zID0gZW5kUG9zO1xuICAgICAgICByZXR1cm4gW25ld1BpZWNlXTtcbiAgICB9XG4gICAgZ2V0TGluZVJhd0NvbnRlbnQobGluZU51bWJlciwgZW5kT2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMucm9vdDtcbiAgICAgICAgbGV0IHJldCA9ICcnO1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX3NlYXJjaENhY2hlLmdldDIobGluZU51bWJlcik7XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgeCA9IGNhY2hlLm5vZGU7XG4gICAgICAgICAgICBjb25zdCBwcmV2QWNjdW11bGF0ZWRWYWx1ZSA9IHRoaXMuZ2V0QWNjdW11bGF0ZWRWYWx1ZSh4LCBsaW5lTnVtYmVyIC0gY2FjaGUubm9kZVN0YXJ0TGluZU51bWJlciAtIDEpO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fYnVmZmVyc1t4LnBpZWNlLmJ1ZmZlckluZGV4XS5idWZmZXI7XG4gICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0SW5CdWZmZXIoeC5waWVjZS5idWZmZXJJbmRleCwgeC5waWVjZS5zdGFydCk7XG4gICAgICAgICAgICBpZiAoY2FjaGUubm9kZVN0YXJ0TGluZU51bWJlciArIHgucGllY2UubGluZUZlZWRDbnQgPT09IGxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBidWZmZXIuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0ICsgcHJldkFjY3VtdWxhdGVkVmFsdWUsIHN0YXJ0T2Zmc2V0ICsgeC5waWVjZS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRWYWx1ZSA9IHRoaXMuZ2V0QWNjdW11bGF0ZWRWYWx1ZSh4LCBsaW5lTnVtYmVyIC0gY2FjaGUubm9kZVN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5zdWJzdHJpbmcoc3RhcnRPZmZzZXQgKyBwcmV2QWNjdW11bGF0ZWRWYWx1ZSwgc3RhcnRPZmZzZXQgKyBhY2N1bXVsYXRlZFZhbHVlIC0gZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgICAgIHdoaWxlICh4ICE9PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgICAgIGlmICh4LmxlZnQgIT09IFNFTlRJTkVMICYmIHgubGZfbGVmdCA+PSBsaW5lTnVtYmVyIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0geC5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4LmxmX2xlZnQgKyB4LnBpZWNlLmxpbmVGZWVkQ250ID4gbGluZU51bWJlciAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkFjY3VtdWxhdGVkVmFsdWUgPSB0aGlzLmdldEFjY3VtdWxhdGVkVmFsdWUoeCwgbGluZU51bWJlciAtIHgubGZfbGVmdCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2N1bXVsYXRlZFZhbHVlID0gdGhpcy5nZXRBY2N1bXVsYXRlZFZhbHVlKHgsIGxpbmVOdW1iZXIgLSB4LmxmX2xlZnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fYnVmZmVyc1t4LnBpZWNlLmJ1ZmZlckluZGV4XS5idWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXRJbkJ1ZmZlcih4LnBpZWNlLmJ1ZmZlckluZGV4LCB4LnBpZWNlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVN0YXJ0T2Zmc2V0ICs9IHguc2l6ZV9sZWZ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWFyY2hDYWNoZS5zZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVTdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVTdGFydExpbmVOdW1iZXI6IG9yaWdpbmFsTGluZU51bWJlciAtIChsaW5lTnVtYmVyIC0gMSAtIHgubGZfbGVmdClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0ICsgcHJldkFjY3VtdWxhdGVkVmFsdWUsIHN0YXJ0T2Zmc2V0ICsgYWNjdW11bGF0ZWRWYWx1ZSAtIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgubGZfbGVmdCArIHgucGllY2UubGluZUZlZWRDbnQgPT09IGxpbmVOdW1iZXIgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZBY2N1bXVsYXRlZFZhbHVlID0gdGhpcy5nZXRBY2N1bXVsYXRlZFZhbHVlKHgsIGxpbmVOdW1iZXIgLSB4LmxmX2xlZnQgLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fYnVmZmVyc1t4LnBpZWNlLmJ1ZmZlckluZGV4XS5idWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXRJbkJ1ZmZlcih4LnBpZWNlLmJ1ZmZlckluZGV4LCB4LnBpZWNlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gYnVmZmVyLnN1YnN0cmluZyhzdGFydE9mZnNldCArIHByZXZBY2N1bXVsYXRlZFZhbHVlLCBzdGFydE9mZnNldCArIHgucGllY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyIC09IHgubGZfbGVmdCArIHgucGllY2UubGluZUZlZWRDbnQ7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVTdGFydE9mZnNldCArPSB4LnNpemVfbGVmdCArIHgucGllY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB4ID0geC5yaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VhcmNoIGluIG9yZGVyLCB0byBmaW5kIHRoZSBub2RlIGNvbnRhaW5zIGVuZCBjb2x1bW5cbiAgICAgICAgeCA9IHgubmV4dCgpO1xuICAgICAgICB3aGlsZSAoeCAhPT0gU0VOVElORUwpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcnNbeC5waWVjZS5idWZmZXJJbmRleF0uYnVmZmVyO1xuICAgICAgICAgICAgaWYgKHgucGllY2UubGluZUZlZWRDbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRWYWx1ZSA9IHRoaXMuZ2V0QWNjdW11bGF0ZWRWYWx1ZSh4LCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0SW5CdWZmZXIoeC5waWVjZS5idWZmZXJJbmRleCwgeC5waWVjZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0ICs9IGJ1ZmZlci5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIHN0YXJ0T2Zmc2V0ICsgYWNjdW11bGF0ZWRWYWx1ZSAtIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXRJbkJ1ZmZlcih4LnBpZWNlLmJ1ZmZlckluZGV4LCB4LnBpZWNlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXQgKz0gYnVmZmVyLnN1YnN0cihzdGFydE9mZnNldCwgeC5waWVjZS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCA9IHgubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGNvbXB1dGVCdWZmZXJNZXRhZGF0YSgpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLnJvb3Q7XG4gICAgICAgIGxldCBsZkNudCA9IDE7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICB3aGlsZSAoeCAhPT0gU0VOVElORUwpIHtcbiAgICAgICAgICAgIGxmQ250ICs9IHgubGZfbGVmdCArIHgucGllY2UubGluZUZlZWRDbnQ7XG4gICAgICAgICAgICBsZW4gKz0geC5zaXplX2xlZnQgKyB4LnBpZWNlLmxlbmd0aDtcbiAgICAgICAgICAgIHggPSB4LnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpbmVDbnQgPSBsZkNudDtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgICAgICB0aGlzLl9zZWFyY2hDYWNoZS52YWxpZGF0ZSh0aGlzLl9sZW5ndGgpO1xuICAgIH1cbiAgICAvLyAjcmVnaW9uIG5vZGUgb3BlcmF0aW9uc1xuICAgIGdldEluZGV4T2Yobm9kZSwgYWNjdW11bGF0ZWRWYWx1ZSkge1xuICAgICAgICBjb25zdCBwaWVjZSA9IG5vZGUucGllY2U7XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMucG9zaXRpb25JbkJ1ZmZlcihub2RlLCBhY2N1bXVsYXRlZFZhbHVlKTtcbiAgICAgICAgY29uc3QgbGluZUNudCA9IHBvcy5saW5lIC0gcGllY2Uuc3RhcnQubGluZTtcbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0SW5CdWZmZXIocGllY2UuYnVmZmVySW5kZXgsIHBpZWNlLmVuZCkgLSB0aGlzLm9mZnNldEluQnVmZmVyKHBpZWNlLmJ1ZmZlckluZGV4LCBwaWVjZS5zdGFydCkgPT09IGFjY3VtdWxhdGVkVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBjaGVja2luZyB0aGUgZW5kIG9mIHRoaXMgbm9kZSwgc28gYSBDUkxGIGNoZWNrIGlzIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIGNvbnN0IHJlYWxMaW5lQ250ID0gdGhpcy5nZXRMaW5lRmVlZENudChub2RlLnBpZWNlLmJ1ZmZlckluZGV4LCBwaWVjZS5zdGFydCwgcG9zKTtcbiAgICAgICAgICAgIGlmIChyZWFsTGluZUNudCAhPT0gbGluZUNudCkge1xuICAgICAgICAgICAgICAgIC8vIGFoYSB5ZXMsIENSTEZcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpbmRleDogcmVhbExpbmVDbnQsIHJlbWFpbmRlcjogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGluZGV4OiBsaW5lQ250LCByZW1haW5kZXI6IHBvcy5jb2x1bW4gfTtcbiAgICB9XG4gICAgZ2V0QWNjdW11bGF0ZWRWYWx1ZShub2RlLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaWVjZSA9IG5vZGUucGllY2U7XG4gICAgICAgIGNvbnN0IGxpbmVTdGFydHMgPSB0aGlzLl9idWZmZXJzW3BpZWNlLmJ1ZmZlckluZGV4XS5saW5lU3RhcnRzO1xuICAgICAgICBjb25zdCBleHBlY3RlZExpbmVTdGFydEluZGV4ID0gcGllY2Uuc3RhcnQubGluZSArIGluZGV4ICsgMTtcbiAgICAgICAgaWYgKGV4cGVjdGVkTGluZVN0YXJ0SW5kZXggPiBwaWVjZS5lbmQubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVTdGFydHNbcGllY2UuZW5kLmxpbmVdICsgcGllY2UuZW5kLmNvbHVtbiAtIGxpbmVTdGFydHNbcGllY2Uuc3RhcnQubGluZV0gLSBwaWVjZS5zdGFydC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZVN0YXJ0c1tleHBlY3RlZExpbmVTdGFydEluZGV4XSAtIGxpbmVTdGFydHNbcGllY2Uuc3RhcnQubGluZV0gLSBwaWVjZS5zdGFydC5jb2x1bW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlTm9kZVRhaWwobm9kZSwgcG9zKSB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gbm9kZS5waWVjZTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxMRkNudCA9IHBpZWNlLmxpbmVGZWVkQ250O1xuICAgICAgICBjb25zdCBvcmlnaW5hbEVuZE9mZnNldCA9IHRoaXMub2Zmc2V0SW5CdWZmZXIocGllY2UuYnVmZmVySW5kZXgsIHBpZWNlLmVuZCk7XG4gICAgICAgIGNvbnN0IG5ld0VuZCA9IHBvcztcbiAgICAgICAgY29uc3QgbmV3RW5kT2Zmc2V0ID0gdGhpcy5vZmZzZXRJbkJ1ZmZlcihwaWVjZS5idWZmZXJJbmRleCwgbmV3RW5kKTtcbiAgICAgICAgY29uc3QgbmV3TGluZUZlZWRDbnQgPSB0aGlzLmdldExpbmVGZWVkQ250KHBpZWNlLmJ1ZmZlckluZGV4LCBwaWVjZS5zdGFydCwgbmV3RW5kKTtcbiAgICAgICAgY29uc3QgbGZfZGVsdGEgPSBuZXdMaW5lRmVlZENudCAtIG9yaWdpbmFsTEZDbnQ7XG4gICAgICAgIGNvbnN0IHNpemVfZGVsdGEgPSBuZXdFbmRPZmZzZXQgLSBvcmlnaW5hbEVuZE9mZnNldDtcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gcGllY2UubGVuZ3RoICsgc2l6ZV9kZWx0YTtcbiAgICAgICAgbm9kZS5waWVjZSA9IG5ldyBQaWVjZShwaWVjZS5idWZmZXJJbmRleCwgcGllY2Uuc3RhcnQsIG5ld0VuZCwgbmV3TGluZUZlZWRDbnQsIG5ld0xlbmd0aCk7XG4gICAgICAgIHVwZGF0ZVRyZWVNZXRhZGF0YSh0aGlzLCBub2RlLCBzaXplX2RlbHRhLCBsZl9kZWx0YSk7XG4gICAgfVxuICAgIGRlbGV0ZU5vZGVIZWFkKG5vZGUsIHBvcykge1xuICAgICAgICBjb25zdCBwaWVjZSA9IG5vZGUucGllY2U7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTEZDbnQgPSBwaWVjZS5saW5lRmVlZENudDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0SW5CdWZmZXIocGllY2UuYnVmZmVySW5kZXgsIHBpZWNlLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgbmV3U3RhcnQgPSBwb3M7XG4gICAgICAgIGNvbnN0IG5ld0xpbmVGZWVkQ250ID0gdGhpcy5nZXRMaW5lRmVlZENudChwaWVjZS5idWZmZXJJbmRleCwgbmV3U3RhcnQsIHBpZWNlLmVuZCk7XG4gICAgICAgIGNvbnN0IG5ld1N0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXRJbkJ1ZmZlcihwaWVjZS5idWZmZXJJbmRleCwgbmV3U3RhcnQpO1xuICAgICAgICBjb25zdCBsZl9kZWx0YSA9IG5ld0xpbmVGZWVkQ250IC0gb3JpZ2luYWxMRkNudDtcbiAgICAgICAgY29uc3Qgc2l6ZV9kZWx0YSA9IG9yaWdpbmFsU3RhcnRPZmZzZXQgLSBuZXdTdGFydE9mZnNldDtcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gcGllY2UubGVuZ3RoICsgc2l6ZV9kZWx0YTtcbiAgICAgICAgbm9kZS5waWVjZSA9IG5ldyBQaWVjZShwaWVjZS5idWZmZXJJbmRleCwgbmV3U3RhcnQsIHBpZWNlLmVuZCwgbmV3TGluZUZlZWRDbnQsIG5ld0xlbmd0aCk7XG4gICAgICAgIHVwZGF0ZVRyZWVNZXRhZGF0YSh0aGlzLCBub2RlLCBzaXplX2RlbHRhLCBsZl9kZWx0YSk7XG4gICAgfVxuICAgIHNocmlua05vZGUobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBjb25zdCBwaWVjZSA9IG5vZGUucGllY2U7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhcnRQb3MgPSBwaWVjZS5zdGFydDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFbmRQb3MgPSBwaWVjZS5lbmQ7XG4gICAgICAgIC8vIG9sZCBwaWVjZSwgb3JpZ2luYWxTdGFydFBvcywgc3RhcnRcbiAgICAgICAgY29uc3Qgb2xkTGVuZ3RoID0gcGllY2UubGVuZ3RoO1xuICAgICAgICBjb25zdCBvbGRMRkNudCA9IHBpZWNlLmxpbmVGZWVkQ250O1xuICAgICAgICBjb25zdCBuZXdFbmQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgbmV3TGluZUZlZWRDbnQgPSB0aGlzLmdldExpbmVGZWVkQ250KHBpZWNlLmJ1ZmZlckluZGV4LCBwaWVjZS5zdGFydCwgbmV3RW5kKTtcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gdGhpcy5vZmZzZXRJbkJ1ZmZlcihwaWVjZS5idWZmZXJJbmRleCwgc3RhcnQpIC0gdGhpcy5vZmZzZXRJbkJ1ZmZlcihwaWVjZS5idWZmZXJJbmRleCwgb3JpZ2luYWxTdGFydFBvcyk7XG4gICAgICAgIG5vZGUucGllY2UgPSBuZXcgUGllY2UocGllY2UuYnVmZmVySW5kZXgsIHBpZWNlLnN0YXJ0LCBuZXdFbmQsIG5ld0xpbmVGZWVkQ250LCBuZXdMZW5ndGgpO1xuICAgICAgICB1cGRhdGVUcmVlTWV0YWRhdGEodGhpcywgbm9kZSwgbmV3TGVuZ3RoIC0gb2xkTGVuZ3RoLCBuZXdMaW5lRmVlZENudCAtIG9sZExGQ250KTtcbiAgICAgICAgLy8gbmV3IHJpZ2h0IHBpZWNlLCBlbmQsIG9yaWdpbmFsRW5kUG9zXG4gICAgICAgIGNvbnN0IG5ld1BpZWNlID0gbmV3IFBpZWNlKHBpZWNlLmJ1ZmZlckluZGV4LCBlbmQsIG9yaWdpbmFsRW5kUG9zLCB0aGlzLmdldExpbmVGZWVkQ250KHBpZWNlLmJ1ZmZlckluZGV4LCBlbmQsIG9yaWdpbmFsRW5kUG9zKSwgdGhpcy5vZmZzZXRJbkJ1ZmZlcihwaWVjZS5idWZmZXJJbmRleCwgb3JpZ2luYWxFbmRQb3MpIC0gdGhpcy5vZmZzZXRJbkJ1ZmZlcihwaWVjZS5idWZmZXJJbmRleCwgZW5kKSk7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSB0aGlzLnJiSW5zZXJ0UmlnaHQobm9kZSwgbmV3UGllY2UpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlQ1JMRldpdGhQcmV2Tm9kZShuZXdOb2RlKTtcbiAgICB9XG4gICAgYXBwZW5kVG9Ob2RlKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFkanVzdENhcnJpYWdlUmV0dXJuRnJvbU5leHQodmFsdWUsIG5vZGUpKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoaXRDUkxGID0gdGhpcy5zaG91bGRDaGVja0NSTEYoKSAmJiB0aGlzLnN0YXJ0V2l0aExGKHZhbHVlKSAmJiB0aGlzLmVuZFdpdGhDUihub2RlKTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLl9idWZmZXJzWzBdLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0uYnVmZmVyICs9IHZhbHVlO1xuICAgICAgICBjb25zdCBsaW5lU3RhcnRzID0gY3JlYXRlTGluZVN0YXJ0c0Zhc3QodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lU3RhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lU3RhcnRzW2ldICs9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaXRDUkxGKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2U3RhcnRPZmZzZXQgPSB0aGlzLl9idWZmZXJzWzBdLmxpbmVTdGFydHNbdGhpcy5fYnVmZmVyc1swXS5saW5lU3RhcnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyc1swXS5saW5lU3RhcnRzLnBvcCgpO1xuICAgICAgICAgICAgLy8gX2xhc3RDaGFuZ2VCdWZmZXJQb3MgaXMgYWxyZWFkeSB3cm9uZ1xuICAgICAgICAgICAgdGhpcy5fbGFzdENoYW5nZUJ1ZmZlclBvcyA9IHsgbGluZTogdGhpcy5fbGFzdENoYW5nZUJ1ZmZlclBvcy5saW5lIC0gMSwgY29sdW1uOiBzdGFydE9mZnNldCAtIHByZXZTdGFydE9mZnNldCB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0ubGluZVN0YXJ0cyA9IHRoaXMuX2J1ZmZlcnNbMF0ubGluZVN0YXJ0cy5jb25jYXQobGluZVN0YXJ0cy5zbGljZSgxKSk7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5fYnVmZmVyc1swXS5saW5lU3RhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGVuZENvbHVtbiA9IHRoaXMuX2J1ZmZlcnNbMF0uYnVmZmVyLmxlbmd0aCAtIHRoaXMuX2J1ZmZlcnNbMF0ubGluZVN0YXJ0c1tlbmRJbmRleF07XG4gICAgICAgIGNvbnN0IG5ld0VuZCA9IHsgbGluZTogZW5kSW5kZXgsIGNvbHVtbjogZW5kQ29sdW1uIH07XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IG5vZGUucGllY2UubGVuZ3RoICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICBjb25zdCBvbGRMaW5lRmVlZENudCA9IG5vZGUucGllY2UubGluZUZlZWRDbnQ7XG4gICAgICAgIGNvbnN0IG5ld0xpbmVGZWVkQ250ID0gdGhpcy5nZXRMaW5lRmVlZENudCgwLCBub2RlLnBpZWNlLnN0YXJ0LCBuZXdFbmQpO1xuICAgICAgICBjb25zdCBsZl9kZWx0YSA9IG5ld0xpbmVGZWVkQ250IC0gb2xkTGluZUZlZWRDbnQ7XG4gICAgICAgIG5vZGUucGllY2UgPSBuZXcgUGllY2Uobm9kZS5waWVjZS5idWZmZXJJbmRleCwgbm9kZS5waWVjZS5zdGFydCwgbmV3RW5kLCBuZXdMaW5lRmVlZENudCwgbmV3TGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fbGFzdENoYW5nZUJ1ZmZlclBvcyA9IG5ld0VuZDtcbiAgICAgICAgdXBkYXRlVHJlZU1ldGFkYXRhKHRoaXMsIG5vZGUsIHZhbHVlLmxlbmd0aCwgbGZfZGVsdGEpO1xuICAgIH1cbiAgICBub2RlQXQob2Zmc2V0KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy5yb290O1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX3NlYXJjaENhY2hlLmdldChvZmZzZXQpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm9kZTogY2FjaGUubm9kZSxcbiAgICAgICAgICAgICAgICBub2RlU3RhcnRPZmZzZXQ6IGNhY2hlLm5vZGVTdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICByZW1haW5kZXI6IG9mZnNldCAtIGNhY2hlLm5vZGVTdGFydE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZVN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgd2hpbGUgKHggIT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICBpZiAoeC5zaXplX2xlZnQgPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB4ID0geC5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeC5zaXplX2xlZnQgKyB4LnBpZWNlLmxlbmd0aCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBub2RlU3RhcnRPZmZzZXQgKz0geC5zaXplX2xlZnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICAgICAgICAgICAgICBub2RlOiB4LFxuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXI6IG9mZnNldCAtIHguc2l6ZV9sZWZ0LFxuICAgICAgICAgICAgICAgICAgICBub2RlU3RhcnRPZmZzZXRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlYXJjaENhY2hlLnNldChyZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgLT0geC5zaXplX2xlZnQgKyB4LnBpZWNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBub2RlU3RhcnRPZmZzZXQgKz0geC5zaXplX2xlZnQgKyB4LnBpZWNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB4ID0geC5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbm9kZUF0MihsaW5lTnVtYmVyLCBjb2x1bW4pIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLnJvb3Q7XG4gICAgICAgIGxldCBub2RlU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICB3aGlsZSAoeCAhPT0gU0VOVElORUwpIHtcbiAgICAgICAgICAgIGlmICh4LmxlZnQgIT09IFNFTlRJTkVMICYmIHgubGZfbGVmdCA+PSBsaW5lTnVtYmVyIC0gMSkge1xuICAgICAgICAgICAgICAgIHggPSB4LmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4LmxmX2xlZnQgKyB4LnBpZWNlLmxpbmVGZWVkQ250ID4gbGluZU51bWJlciAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2QWNjdW11YWx0ZWRWYWx1ZSA9IHRoaXMuZ2V0QWNjdW11bGF0ZWRWYWx1ZSh4LCBsaW5lTnVtYmVyIC0geC5sZl9sZWZ0IC0gMik7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRWYWx1ZSA9IHRoaXMuZ2V0QWNjdW11bGF0ZWRWYWx1ZSh4LCBsaW5lTnVtYmVyIC0geC5sZl9sZWZ0IC0gMSk7XG4gICAgICAgICAgICAgICAgbm9kZVN0YXJ0T2Zmc2V0ICs9IHguc2l6ZV9sZWZ0O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHgsXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcjogTWF0aC5taW4ocHJldkFjY3VtdWFsdGVkVmFsdWUgKyBjb2x1bW4gLSAxLCBhY2N1bXVsYXRlZFZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVN0YXJ0T2Zmc2V0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHgubGZfbGVmdCArIHgucGllY2UubGluZUZlZWRDbnQgPT09IGxpbmVOdW1iZXIgLSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkFjY3VtdWFsdGVkVmFsdWUgPSB0aGlzLmdldEFjY3VtdWxhdGVkVmFsdWUoeCwgbGluZU51bWJlciAtIHgubGZfbGVmdCAtIDIpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2QWNjdW11YWx0ZWRWYWx1ZSArIGNvbHVtbiAtIDEgPD0geC5waWVjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXI6IHByZXZBY2N1bXVhbHRlZFZhbHVlICsgY29sdW1uIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVTdGFydE9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uIC09IHgucGllY2UubGVuZ3RoIC0gcHJldkFjY3VtdWFsdGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIgLT0geC5sZl9sZWZ0ICsgeC5waWVjZS5saW5lRmVlZENudDtcbiAgICAgICAgICAgICAgICBub2RlU3RhcnRPZmZzZXQgKz0geC5zaXplX2xlZnQgKyB4LnBpZWNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB4ID0geC5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZWFyY2ggaW4gb3JkZXIsIHRvIGZpbmQgdGhlIG5vZGUgY29udGFpbnMgcG9zaXRpb24uY29sdW1uXG4gICAgICAgIHggPSB4Lm5leHQoKTtcbiAgICAgICAgd2hpbGUgKHggIT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICBpZiAoeC5waWVjZS5saW5lRmVlZENudCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2N1bXVsYXRlZFZhbHVlID0gdGhpcy5nZXRBY2N1bXVsYXRlZFZhbHVlKHgsIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVTdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0T2ZOb2RlKHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHgsXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcjogTWF0aC5taW4oY29sdW1uIC0gMSwgYWNjdW11bGF0ZWRWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIG5vZGVTdGFydE9mZnNldFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoeC5waWVjZS5sZW5ndGggPj0gY29sdW1uIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlU3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldE9mTm9kZSh4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXI6IGNvbHVtbiAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlU3RhcnRPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiAtPSB4LnBpZWNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0geC5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5vZGVDaGFyQ29kZUF0KG5vZGUsIG9mZnNldCkge1xuICAgICAgICBpZiAobm9kZS5waWVjZS5saW5lRmVlZENudCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9idWZmZXJzW25vZGUucGllY2UuYnVmZmVySW5kZXhdO1xuICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSB0aGlzLm9mZnNldEluQnVmZmVyKG5vZGUucGllY2UuYnVmZmVySW5kZXgsIG5vZGUucGllY2Uuc3RhcnQpICsgb2Zmc2V0O1xuICAgICAgICByZXR1cm4gYnVmZmVyLmJ1ZmZlci5jaGFyQ29kZUF0KG5ld09mZnNldCk7XG4gICAgfVxuICAgIG9mZnNldE9mTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvcyA9IG5vZGUuc2l6ZV9sZWZ0O1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gdGhpcy5yb290KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQucmlnaHQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbm9kZS5wYXJlbnQuc2l6ZV9sZWZ0ICsgbm9kZS5wYXJlbnQucGllY2UubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIENSTEZcbiAgICBzaG91bGRDaGVja0NSTEYoKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMuX0VPTE5vcm1hbGl6ZWQgJiYgdGhpcy5fRU9MID09PSAnXFxuJyk7XG4gICAgfVxuICAgIHN0YXJ0V2l0aExGKHZhbCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuY2hhckNvZGVBdCgwKSA9PT0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gU0VOVElORUwgfHwgdmFsLnBpZWNlLmxpbmVGZWVkQ250ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGllY2UgPSB2YWwucGllY2U7XG4gICAgICAgIGNvbnN0IGxpbmVTdGFydHMgPSB0aGlzLl9idWZmZXJzW3BpZWNlLmJ1ZmZlckluZGV4XS5saW5lU3RhcnRzO1xuICAgICAgICBjb25zdCBsaW5lID0gcGllY2Uuc3RhcnQubGluZTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBsaW5lU3RhcnRzW2xpbmVdICsgcGllY2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICBpZiAobGluZSA9PT0gbGluZVN0YXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAvLyBsYXN0IGxpbmUsIHNvIHRoZXJlIGlzIG5vIGxpbmUgZmVlZCBhdCB0aGUgZW5kIG9mIHRoaXMgbGluZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRMaW5lT2Zmc2V0ID0gbGluZVN0YXJ0c1tsaW5lICsgMV07XG4gICAgICAgIGlmIChuZXh0TGluZU9mZnNldCA+IHN0YXJ0T2Zmc2V0ICsgMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXJzW3BpZWNlLmJ1ZmZlckluZGV4XS5idWZmZXIuY2hhckNvZGVBdChzdGFydE9mZnNldCkgPT09IDEwO1xuICAgIH1cbiAgICBlbmRXaXRoQ1IodmFsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5jaGFyQ29kZUF0KHZhbC5sZW5ndGggLSAxKSA9PT0gMTM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gU0VOVElORUwgfHwgdmFsLnBpZWNlLmxpbmVGZWVkQ250ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZUNoYXJDb2RlQXQodmFsLCB2YWwucGllY2UubGVuZ3RoIC0gMSkgPT09IDEzO1xuICAgIH1cbiAgICB2YWxpZGF0ZUNSTEZXaXRoUHJldk5vZGUobmV4dE5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ2hlY2tDUkxGKCkgJiYgdGhpcy5zdGFydFdpdGhMRihuZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXh0Tm9kZS5wcmV2KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmRXaXRoQ1Iobm9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpeENSTEYobm9kZSwgbmV4dE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlQ1JMRldpdGhOZXh0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZENoZWNrQ1JMRigpICYmIHRoaXMuZW5kV2l0aENSKG5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGUubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRXaXRoTEYobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXhDUkxGKG5vZGUsIG5leHROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXhDUkxGKHByZXYsIG5leHQpIHtcbiAgICAgICAgY29uc3Qgbm9kZXNUb0RlbCA9IFtdO1xuICAgICAgICAvLyB1cGRhdGUgbm9kZVxuICAgICAgICBjb25zdCBsaW5lU3RhcnRzID0gdGhpcy5fYnVmZmVyc1twcmV2LnBpZWNlLmJ1ZmZlckluZGV4XS5saW5lU3RhcnRzO1xuICAgICAgICBsZXQgbmV3RW5kO1xuICAgICAgICBpZiAocHJldi5waWVjZS5lbmQuY29sdW1uID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpdCBtZWFucywgbGFzdCBsaW5lIGVuZHMgd2l0aCBcXHIsIG5vdCBcXHJcXG5cbiAgICAgICAgICAgIG5ld0VuZCA9IHsgbGluZTogcHJldi5waWVjZS5lbmQubGluZSAtIDEsIGNvbHVtbjogbGluZVN0YXJ0c1twcmV2LnBpZWNlLmVuZC5saW5lXSAtIGxpbmVTdGFydHNbcHJldi5waWVjZS5lbmQubGluZSAtIDFdIC0gMSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gXFxyXFxuXG4gICAgICAgICAgICBuZXdFbmQgPSB7IGxpbmU6IHByZXYucGllY2UuZW5kLmxpbmUsIGNvbHVtbjogcHJldi5waWVjZS5lbmQuY29sdW1uIC0gMSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZOZXdMZW5ndGggPSBwcmV2LnBpZWNlLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IHByZXZOZXdMRkNudCA9IHByZXYucGllY2UubGluZUZlZWRDbnQgLSAxO1xuICAgICAgICBwcmV2LnBpZWNlID0gbmV3IFBpZWNlKHByZXYucGllY2UuYnVmZmVySW5kZXgsIHByZXYucGllY2Uuc3RhcnQsIG5ld0VuZCwgcHJldk5ld0xGQ250LCBwcmV2TmV3TGVuZ3RoKTtcbiAgICAgICAgdXBkYXRlVHJlZU1ldGFkYXRhKHRoaXMsIHByZXYsIC0xLCAtMSk7XG4gICAgICAgIGlmIChwcmV2LnBpZWNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbm9kZXNUb0RlbC5wdXNoKHByZXYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBuZXh0Tm9kZVxuICAgICAgICBjb25zdCBuZXdTdGFydCA9IHsgbGluZTogbmV4dC5waWVjZS5zdGFydC5saW5lICsgMSwgY29sdW1uOiAwIH07XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IG5leHQucGllY2UubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgbmV3TGluZUZlZWRDbnQgPSB0aGlzLmdldExpbmVGZWVkQ250KG5leHQucGllY2UuYnVmZmVySW5kZXgsIG5ld1N0YXJ0LCBuZXh0LnBpZWNlLmVuZCk7XG4gICAgICAgIG5leHQucGllY2UgPSBuZXcgUGllY2UobmV4dC5waWVjZS5idWZmZXJJbmRleCwgbmV3U3RhcnQsIG5leHQucGllY2UuZW5kLCBuZXdMaW5lRmVlZENudCwgbmV3TGVuZ3RoKTtcbiAgICAgICAgdXBkYXRlVHJlZU1ldGFkYXRhKHRoaXMsIG5leHQsIC0xLCAtMSk7XG4gICAgICAgIGlmIChuZXh0LnBpZWNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbm9kZXNUb0RlbC5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgcGllY2Ugd2hpY2ggY29udGFpbnMgXFxyXFxuXG4gICAgICAgIGNvbnN0IHBpZWNlcyA9IHRoaXMuY3JlYXRlTmV3UGllY2VzKCdcXHJcXG4nKTtcbiAgICAgICAgdGhpcy5yYkluc2VydFJpZ2h0KHByZXYsIHBpZWNlc1swXSk7XG4gICAgICAgIC8vIGRlbGV0ZSBlbXB0eSBub2Rlc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzVG9EZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJiRGVsZXRlKHRoaXMsIG5vZGVzVG9EZWxbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkanVzdENhcnJpYWdlUmV0dXJuRnJvbU5leHQodmFsdWUsIG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ2hlY2tDUkxGKCkgJiYgdGhpcy5lbmRXaXRoQ1IodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGUubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRXaXRoTEYobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBgXFxuYCBmb3J3YXJkXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgaWYgKG5leHROb2RlLnBpZWNlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByYkRlbGV0ZSh0aGlzLCBuZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaWVjZSA9IG5leHROb2RlLnBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTdGFydCA9IHsgbGluZTogcGllY2Uuc3RhcnQubGluZSArIDEsIGNvbHVtbjogMCB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdMZW5ndGggPSBwaWVjZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lRmVlZENudCA9IHRoaXMuZ2V0TGluZUZlZWRDbnQocGllY2UuYnVmZmVySW5kZXgsIG5ld1N0YXJ0LCBwaWVjZS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZS5waWVjZSA9IG5ldyBQaWVjZShwaWVjZS5idWZmZXJJbmRleCwgbmV3U3RhcnQsIHBpZWNlLmVuZCwgbmV3TGluZUZlZWRDbnQsIG5ld0xlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRyZWVNZXRhZGF0YSh0aGlzLCBuZXh0Tm9kZSwgLTEsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8vICNyZWdpb24gVHJlZSBvcGVyYXRpb25zXG4gICAgaXRlcmF0ZShub2RlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAobm9kZSA9PT0gU0VOVElORUwpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhTRU5USU5FTCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdFJldCA9IHRoaXMuaXRlcmF0ZShub2RlLmxlZnQsIGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKCFsZWZ0UmV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdFJldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobm9kZSkgJiYgdGhpcy5pdGVyYXRlKG5vZGUucmlnaHQsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZ2V0Tm9kZUNvbnRlbnQobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PT0gU0VOVElORUwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9idWZmZXJzW25vZGUucGllY2UuYnVmZmVySW5kZXhdO1xuICAgICAgICBjb25zdCBwaWVjZSA9IG5vZGUucGllY2U7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXRJbkJ1ZmZlcihwaWVjZS5idWZmZXJJbmRleCwgcGllY2Uuc3RhcnQpO1xuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSB0aGlzLm9mZnNldEluQnVmZmVyKHBpZWNlLmJ1ZmZlckluZGV4LCBwaWVjZS5lbmQpO1xuICAgICAgICBjb25zdCBjdXJyZW50Q29udGVudCA9IGJ1ZmZlci5idWZmZXIuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICByZXR1cm4gY3VycmVudENvbnRlbnQ7XG4gICAgfVxuICAgIGdldFBpZWNlQ29udGVudChwaWVjZSkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9idWZmZXJzW3BpZWNlLmJ1ZmZlckluZGV4XTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldEluQnVmZmVyKHBpZWNlLmJ1ZmZlckluZGV4LCBwaWVjZS5zdGFydCk7XG4gICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMub2Zmc2V0SW5CdWZmZXIocGllY2UuYnVmZmVySW5kZXgsIHBpZWNlLmVuZCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb250ZW50ID0gYnVmZmVyLmJ1ZmZlci5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50Q29udGVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICAgICBub2RlICAgICAgICAgICAgICBub2RlXG4gICAgICogICAgIC8gIFxcICAgICAgICAgICAgICAvICBcXFxuICAgICAqICAgIGEgICBiICAgIDwtLS0tICAgYSAgICBiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgelxuICAgICAqL1xuICAgIHJiSW5zZXJ0UmlnaHQobm9kZSwgcCkge1xuICAgICAgICBjb25zdCB6ID0gbmV3IFRyZWVOb2RlKHAsIDEgLyogTm9kZUNvbG9yLlJlZCAqLyk7XG4gICAgICAgIHoubGVmdCA9IFNFTlRJTkVMO1xuICAgICAgICB6LnJpZ2h0ID0gU0VOVElORUw7XG4gICAgICAgIHoucGFyZW50ID0gU0VOVElORUw7XG4gICAgICAgIHouc2l6ZV9sZWZ0ID0gMDtcbiAgICAgICAgei5sZl9sZWZ0ID0gMDtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMucm9vdDtcbiAgICAgICAgaWYgKHggPT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB6O1xuICAgICAgICAgICAgei5jb2xvciA9IDAgLyogTm9kZUNvbG9yLkJsYWNrICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucmlnaHQgPT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICBub2RlLnJpZ2h0ID0gejtcbiAgICAgICAgICAgIHoucGFyZW50ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gbGVmdGVzdChub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgIG5leHROb2RlLmxlZnQgPSB6O1xuICAgICAgICAgICAgei5wYXJlbnQgPSBuZXh0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBmaXhJbnNlcnQodGhpcywgeik7XG4gICAgICAgIHJldHVybiB6O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgICAgIG5vZGUgICAgICAgICAgICAgIG5vZGVcbiAgICAgKiAgICAgLyAgXFwgICAgICAgICAgICAgIC8gIFxcXG4gICAgICogICAgYSAgIGIgICAgIC0tLS0+ICAgYSAgICBiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICB6XG4gICAgICovXG4gICAgcmJJbnNlcnRMZWZ0KG5vZGUsIHApIHtcbiAgICAgICAgY29uc3QgeiA9IG5ldyBUcmVlTm9kZShwLCAxIC8qIE5vZGVDb2xvci5SZWQgKi8pO1xuICAgICAgICB6LmxlZnQgPSBTRU5USU5FTDtcbiAgICAgICAgei5yaWdodCA9IFNFTlRJTkVMO1xuICAgICAgICB6LnBhcmVudCA9IFNFTlRJTkVMO1xuICAgICAgICB6LnNpemVfbGVmdCA9IDA7XG4gICAgICAgIHoubGZfbGVmdCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB6O1xuICAgICAgICAgICAgei5jb2xvciA9IDAgLyogTm9kZUNvbG9yLkJsYWNrICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubGVmdCA9PT0gU0VOVElORUwpIHtcbiAgICAgICAgICAgIG5vZGUubGVmdCA9IHo7XG4gICAgICAgICAgICB6LnBhcmVudCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2Tm9kZSA9IHJpZ2h0dGVzdChub2RlLmxlZnQpOyAvLyBhXG4gICAgICAgICAgICBwcmV2Tm9kZS5yaWdodCA9IHo7XG4gICAgICAgICAgICB6LnBhcmVudCA9IHByZXZOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGZpeEluc2VydCh0aGlzLCB6KTtcbiAgICAgICAgcmV0dXJuIHo7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vZXZlbnQuanMnO1xuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9yYW5nZS5qcyc7XG5pbXBvcnQgeyBBcHBseUVkaXRzUmVzdWx0IH0gZnJvbSAnLi4vLi4vbW9kZWwuanMnO1xuaW1wb3J0IHsgUGllY2VUcmVlQmFzZSB9IGZyb20gJy4vcGllY2VUcmVlQmFzZS5qcyc7XG5pbXBvcnQgeyBjb3VudEVPTCB9IGZyb20gJy4uLy4uL2NvcmUvZW9sQ291bnRlci5qcyc7XG5pbXBvcnQgeyBUZXh0Q2hhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS90ZXh0Q2hhbmdlLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9saWZlY3ljbGUuanMnO1xuZXhwb3J0IGNsYXNzIFBpZWNlVHJlZVRleHRCdWZmZXIgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihjaHVua3MsIEJPTSwgZW9sLCBjb250YWluc1JUTCwgY29udGFpbnNVbnVzdWFsTGluZVRlcm1pbmF0b3JzLCBpc0Jhc2ljQVNDSUksIGVvbE5vcm1hbGl6ZWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VDb250ZW50ID0gdGhpcy5fcmVnaXN0ZXIobmV3IEVtaXR0ZXIoKSk7XG4gICAgICAgIHRoaXMuX0JPTSA9IEJPTTtcbiAgICAgICAgdGhpcy5fbWlnaHRDb250YWluTm9uQmFzaWNBU0NJSSA9ICFpc0Jhc2ljQVNDSUk7XG4gICAgICAgIHRoaXMuX21pZ2h0Q29udGFpblJUTCA9IGNvbnRhaW5zUlRMO1xuICAgICAgICB0aGlzLl9taWdodENvbnRhaW5VbnVzdWFsTGluZVRlcm1pbmF0b3JzID0gY29udGFpbnNVbnVzdWFsTGluZVRlcm1pbmF0b3JzO1xuICAgICAgICB0aGlzLl9waWVjZVRyZWUgPSBuZXcgUGllY2VUcmVlQmFzZShjaHVua3MsIGVvbCwgZW9sTm9ybWFsaXplZCk7XG4gICAgfVxuICAgIG1pZ2h0Q29udGFpblJUTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pZ2h0Q29udGFpblJUTDtcbiAgICB9XG4gICAgbWlnaHRDb250YWluVW51c3VhbExpbmVUZXJtaW5hdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pZ2h0Q29udGFpblVudXN1YWxMaW5lVGVybWluYXRvcnM7XG4gICAgfVxuICAgIHJlc2V0TWlnaHRDb250YWluVW51c3VhbExpbmVUZXJtaW5hdG9ycygpIHtcbiAgICAgICAgdGhpcy5fbWlnaHRDb250YWluVW51c3VhbExpbmVUZXJtaW5hdG9ycyA9IGZhbHNlO1xuICAgIH1cbiAgICBtaWdodENvbnRhaW5Ob25CYXNpY0FTQ0lJKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWlnaHRDb250YWluTm9uQmFzaWNBU0NJSTtcbiAgICB9XG4gICAgZ2V0Qk9NKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fQk9NO1xuICAgIH1cbiAgICBnZXRFT0woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waWVjZVRyZWUuZ2V0RU9MKCk7XG4gICAgfVxuICAgIGNyZWF0ZVNuYXBzaG90KHByZXNlcnZlQk9NKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waWVjZVRyZWUuY3JlYXRlU25hcHNob3QocHJlc2VydmVCT00gPyB0aGlzLl9CT00gOiAnJyk7XG4gICAgfVxuICAgIGdldE9mZnNldEF0KGxpbmVOdW1iZXIsIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGllY2VUcmVlLmdldE9mZnNldEF0KGxpbmVOdW1iZXIsIGNvbHVtbik7XG4gICAgfVxuICAgIGdldFBvc2l0aW9uQXQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waWVjZVRyZWUuZ2V0UG9zaXRpb25BdChvZmZzZXQpO1xuICAgIH1cbiAgICBnZXRSYW5nZUF0KHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uQXQoc3RhcnQpO1xuICAgICAgICBjb25zdCBlbmRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb25BdChlbmQpO1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0UG9zaXRpb24ubGluZU51bWJlciwgc3RhcnRQb3NpdGlvbi5jb2x1bW4sIGVuZFBvc2l0aW9uLmxpbmVOdW1iZXIsIGVuZFBvc2l0aW9uLmNvbHVtbik7XG4gICAgfVxuICAgIGdldFZhbHVlSW5SYW5nZShyYW5nZSwgZW9sID0gMCAvKiBFbmRPZkxpbmVQcmVmZXJlbmNlLlRleHREZWZpbmVkICovKSB7XG4gICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lRW5kaW5nID0gdGhpcy5fZ2V0RW5kT2ZMaW5lKGVvbCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9waWVjZVRyZWUuZ2V0VmFsdWVJblJhbmdlKHJhbmdlLCBsaW5lRW5kaW5nKTtcbiAgICB9XG4gICAgZ2V0VmFsdWVMZW5ndGhJblJhbmdlKHJhbmdlLCBlb2wgPSAwIC8qIEVuZE9mTGluZVByZWZlcmVuY2UuVGV4dERlZmluZWQgKi8pIHtcbiAgICAgICAgaWYgKHJhbmdlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIChyYW5nZS5lbmRDb2x1bW4gLSByYW5nZS5zdGFydENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLmdldE9mZnNldEF0KHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4pO1xuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSB0aGlzLmdldE9mZnNldEF0KHJhbmdlLmVuZExpbmVOdW1iZXIsIHJhbmdlLmVuZENvbHVtbik7XG4gICAgICAgIC8vIG9mZnNldHMgdXNlIHRoZSB0ZXh0IEVPTCwgc28gd2UgbmVlZCB0byBjb21wZW5zYXRlIGZvciBsZW5ndGggZGlmZmVyZW5jZXNcbiAgICAgICAgLy8gaWYgdGhlIHJlcXVlc3RlZCBFT0wgZG9lc24ndCBtYXRjaCB0aGUgdGV4dCBFT0xcbiAgICAgICAgbGV0IGVvbE9mZnNldENvbXBlbnNhdGlvbiA9IDA7XG4gICAgICAgIGNvbnN0IGRlc2lyZWRFT0wgPSB0aGlzLl9nZXRFbmRPZkxpbmUoZW9sKTtcbiAgICAgICAgY29uc3QgYWN0dWFsRU9MID0gdGhpcy5nZXRFT0woKTtcbiAgICAgICAgaWYgKGRlc2lyZWRFT0wubGVuZ3RoICE9PSBhY3R1YWxFT0wubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGRlc2lyZWRFT0wubGVuZ3RoIC0gYWN0dWFsRU9MLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGVvbENvdW50ID0gcmFuZ2UuZW5kTGluZU51bWJlciAtIHJhbmdlLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIGVvbE9mZnNldENvbXBlbnNhdGlvbiA9IGRlbHRhICogZW9sQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0ICsgZW9sT2Zmc2V0Q29tcGVuc2F0aW9uO1xuICAgIH1cbiAgICBnZXRDaGFyYWN0ZXJDb3VudEluUmFuZ2UocmFuZ2UsIGVvbCA9IDAgLyogRW5kT2ZMaW5lUHJlZmVyZW5jZS5UZXh0RGVmaW5lZCAqLykge1xuICAgICAgICBpZiAodGhpcy5fbWlnaHRDb250YWluTm9uQmFzaWNBU0NJSSkge1xuICAgICAgICAgICAgLy8gd2UgbXVzdCBjb3VudCBieSBpdGVyYXRpbmdcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICAgICAgY29uc3QgZnJvbUxpbmVOdW1iZXIgPSByYW5nZS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICBjb25zdCB0b0xpbmVOdW1iZXIgPSByYW5nZS5lbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgZm9yIChsZXQgbGluZU51bWJlciA9IGZyb21MaW5lTnVtYmVyOyBsaW5lTnVtYmVyIDw9IHRvTGluZU51bWJlcjsgbGluZU51bWJlcisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSB0aGlzLmdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb21PZmZzZXQgPSAobGluZU51bWJlciA9PT0gZnJvbUxpbmVOdW1iZXIgPyByYW5nZS5zdGFydENvbHVtbiAtIDEgOiAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b09mZnNldCA9IChsaW5lTnVtYmVyID09PSB0b0xpbmVOdW1iZXIgPyByYW5nZS5lbmRDb2x1bW4gLSAxIDogbGluZUNvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSBmcm9tT2Zmc2V0OyBvZmZzZXQgPCB0b09mZnNldDsgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGxpbmVDb250ZW50LmNoYXJDb2RlQXQob2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLl9nZXRFbmRPZkxpbmUoZW9sKS5sZW5ndGggKiAodG9MaW5lTnVtYmVyIC0gZnJvbUxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUxlbmd0aEluUmFuZ2UocmFuZ2UsIGVvbCk7XG4gICAgfVxuICAgIGdldExlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpZWNlVHJlZS5nZXRMZW5ndGgoKTtcbiAgICB9XG4gICAgZ2V0TGluZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGllY2VUcmVlLmdldExpbmVDb3VudCgpO1xuICAgIH1cbiAgICBnZXRMaW5lc0NvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waWVjZVRyZWUuZ2V0TGluZXNDb250ZW50KCk7XG4gICAgfVxuICAgIGdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpZWNlVHJlZS5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKTtcbiAgICB9XG4gICAgZ2V0TGluZUNoYXJDb2RlKGxpbmVOdW1iZXIsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waWVjZVRyZWUuZ2V0TGluZUNoYXJDb2RlKGxpbmVOdW1iZXIsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0TGluZUxlbmd0aChsaW5lTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waWVjZVRyZWUuZ2V0TGluZUxlbmd0aChsaW5lTnVtYmVyKTtcbiAgICB9XG4gICAgZ2V0TGluZUZpcnN0Tm9uV2hpdGVzcGFjZUNvbHVtbihsaW5lTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0cmluZ3MuZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXgodGhpcy5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgMTtcbiAgICB9XG4gICAgZ2V0TGluZUxhc3ROb25XaGl0ZXNwYWNlQ29sdW1uKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RyaW5ncy5sYXN0Tm9uV2hpdGVzcGFjZUluZGV4KHRoaXMuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcikpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIDI7XG4gICAgfVxuICAgIF9nZXRFbmRPZkxpbmUoZW9sKSB7XG4gICAgICAgIHN3aXRjaCAoZW9sKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogRW5kT2ZMaW5lUHJlZmVyZW5jZS5MRiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcbic7XG4gICAgICAgICAgICBjYXNlIDIgLyogRW5kT2ZMaW5lUHJlZmVyZW5jZS5DUkxGICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFxyXFxuJztcbiAgICAgICAgICAgIGNhc2UgMCAvKiBFbmRPZkxpbmVQcmVmZXJlbmNlLlRleHREZWZpbmVkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEVPTCgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gRU9MIHByZWZlcmVuY2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFT0wobmV3RU9MKSB7XG4gICAgICAgIHRoaXMuX3BpZWNlVHJlZS5zZXRFT0wobmV3RU9MKTtcbiAgICB9XG4gICAgYXBwbHlFZGl0cyhyYXdPcGVyYXRpb25zLCByZWNvcmRUcmltQXV0b1doaXRlc3BhY2UsIGNvbXB1dGVVbmRvRWRpdHMpIHtcbiAgICAgICAgbGV0IG1pZ2h0Q29udGFpblJUTCA9IHRoaXMuX21pZ2h0Q29udGFpblJUTDtcbiAgICAgICAgbGV0IG1pZ2h0Q29udGFpblVudXN1YWxMaW5lVGVybWluYXRvcnMgPSB0aGlzLl9taWdodENvbnRhaW5VbnVzdWFsTGluZVRlcm1pbmF0b3JzO1xuICAgICAgICBsZXQgbWlnaHRDb250YWluTm9uQmFzaWNBU0NJSSA9IHRoaXMuX21pZ2h0Q29udGFpbk5vbkJhc2ljQVNDSUk7XG4gICAgICAgIGxldCBjYW5SZWR1Y2VPcGVyYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgbGV0IG9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdPcGVyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvcCA9IHJhd09wZXJhdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAoY2FuUmVkdWNlT3BlcmF0aW9ucyAmJiBvcC5faXNUcmFja2VkKSB7XG4gICAgICAgICAgICAgICAgY2FuUmVkdWNlT3BlcmF0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVkUmFuZ2UgPSBvcC5yYW5nZTtcbiAgICAgICAgICAgIGlmIChvcC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRNaWdodENvbnRhaW5Ob25CYXNpY0FTQ0lJID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW1pZ2h0Q29udGFpbk5vbkJhc2ljQVNDSUkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE1pZ2h0Q29udGFpbk5vbkJhc2ljQVNDSUkgPSAhc3RyaW5ncy5pc0Jhc2ljQVNDSUkob3AudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG1pZ2h0Q29udGFpbk5vbkJhc2ljQVNDSUkgPSB0ZXh0TWlnaHRDb250YWluTm9uQmFzaWNBU0NJSTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtaWdodENvbnRhaW5SVEwgJiYgdGV4dE1pZ2h0Q29udGFpbk5vbkJhc2ljQVNDSUkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5ldyBpbnNlcnRlZCB0ZXh0IGNvbnRhaW5zIFJUTFxuICAgICAgICAgICAgICAgICAgICBtaWdodENvbnRhaW5SVEwgPSBzdHJpbmdzLmNvbnRhaW5zUlRMKG9wLnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW1pZ2h0Q29udGFpblVudXN1YWxMaW5lVGVybWluYXRvcnMgJiYgdGV4dE1pZ2h0Q29udGFpbk5vbkJhc2ljQVNDSUkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5ldyBpbnNlcnRlZCB0ZXh0IGNvbnRhaW5zIHVudXN1YWwgbGluZSB0ZXJtaW5hdG9yc1xuICAgICAgICAgICAgICAgICAgICBtaWdodENvbnRhaW5VbnVzdWFsTGluZVRlcm1pbmF0b3JzID0gc3RyaW5ncy5jb250YWluc1VudXN1YWxMaW5lVGVybWluYXRvcnMob3AudGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbGlkVGV4dCA9ICcnO1xuICAgICAgICAgICAgbGV0IGVvbENvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBmaXJzdExpbmVMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGV0IGxhc3RMaW5lTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmIChvcC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ckVPTDtcbiAgICAgICAgICAgICAgICBbZW9sQ291bnQsIGZpcnN0TGluZUxlbmd0aCwgbGFzdExpbmVMZW5ndGgsIHN0ckVPTF0gPSBjb3VudEVPTChvcC50ZXh0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJFT0wgPSB0aGlzLmdldEVPTCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkU3RyRU9MID0gKGJ1ZmZlckVPTCA9PT0gJ1xcclxcbicgPyAyIC8qIFN0cmluZ0VPTC5DUkxGICovIDogMSAvKiBTdHJpbmdFT0wuTEYgKi8pO1xuICAgICAgICAgICAgICAgIGlmIChzdHJFT0wgPT09IDAgLyogU3RyaW5nRU9MLlVua25vd24gKi8gfHwgc3RyRU9MID09PSBleHBlY3RlZFN0ckVPTCkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZFRleHQgPSBvcC50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRUZXh0ID0gb3AudGV4dC5yZXBsYWNlKC9cXHJcXG58XFxyfFxcbi9nLCBidWZmZXJFT0wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZXJhdGlvbnNbaV0gPSB7XG4gICAgICAgICAgICAgICAgc29ydEluZGV4OiBpLFxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IG9wLmlkZW50aWZpZXIgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogdmFsaWRhdGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgcmFuZ2VPZmZzZXQ6IHRoaXMuZ2V0T2Zmc2V0QXQodmFsaWRhdGVkUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCB2YWxpZGF0ZWRSYW5nZS5zdGFydENvbHVtbiksXG4gICAgICAgICAgICAgICAgcmFuZ2VMZW5ndGg6IHRoaXMuZ2V0VmFsdWVMZW5ndGhJblJhbmdlKHZhbGlkYXRlZFJhbmdlKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiB2YWxpZFRleHQsXG4gICAgICAgICAgICAgICAgZW9sQ291bnQ6IGVvbENvdW50LFxuICAgICAgICAgICAgICAgIGZpcnN0TGluZUxlbmd0aDogZmlyc3RMaW5lTGVuZ3RoLFxuICAgICAgICAgICAgICAgIGxhc3RMaW5lTGVuZ3RoOiBsYXN0TGluZUxlbmd0aCxcbiAgICAgICAgICAgICAgICBmb3JjZU1vdmVNYXJrZXJzOiBCb29sZWFuKG9wLmZvcmNlTW92ZU1hcmtlcnMpLFxuICAgICAgICAgICAgICAgIGlzQXV0b1doaXRlc3BhY2VFZGl0OiBvcC5pc0F1dG9XaGl0ZXNwYWNlRWRpdCB8fCBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0IG9wZXJhdGlvbnMgYXNjZW5kaW5nXG4gICAgICAgIG9wZXJhdGlvbnMuc29ydChQaWVjZVRyZWVUZXh0QnVmZmVyLl9zb3J0T3BzQXNjZW5kaW5nKTtcbiAgICAgICAgbGV0IGhhc1RvdWNoaW5nUmFuZ2VzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb3VudCA9IG9wZXJhdGlvbnMubGVuZ3RoIC0gMTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlRW5kID0gb3BlcmF0aW9uc1tpXS5yYW5nZS5nZXRFbmRQb3NpdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgbmV4dFJhbmdlU3RhcnQgPSBvcGVyYXRpb25zW2kgKyAxXS5yYW5nZS5nZXRTdGFydFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpZiAobmV4dFJhbmdlU3RhcnQuaXNCZWZvcmVPckVxdWFsKHJhbmdlRW5kKSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0UmFuZ2VTdGFydC5pc0JlZm9yZShyYW5nZUVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcmxhcHBpbmcgcmFuZ2VzXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3ZlcmxhcHBpbmcgcmFuZ2VzIGFyZSBub3QgYWxsb3dlZCEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFzVG91Y2hpbmdSYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5SZWR1Y2VPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICBvcGVyYXRpb25zID0gdGhpcy5fcmVkdWNlT3BlcmF0aW9ucyhvcGVyYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWx0YSBlbmNvZGUgb3BlcmF0aW9uc1xuICAgICAgICBjb25zdCByZXZlcnNlUmFuZ2VzID0gKGNvbXB1dGVVbmRvRWRpdHMgfHwgcmVjb3JkVHJpbUF1dG9XaGl0ZXNwYWNlID8gUGllY2VUcmVlVGV4dEJ1ZmZlci5fZ2V0SW52ZXJzZUVkaXRSYW5nZXMob3BlcmF0aW9ucykgOiBbXSk7XG4gICAgICAgIGNvbnN0IG5ld1RyaW1BdXRvV2hpdGVzcGFjZUNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgaWYgKHJlY29yZFRyaW1BdXRvV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcGVyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3AgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2VSYW5nZSA9IHJldmVyc2VSYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG9wLmlzQXV0b1doaXRlc3BhY2VFZGl0ICYmIG9wLnJhbmdlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgYWxyZWFkeSB0aGUgZnV0dXJlIGxpbmUgbnVtYmVycyB0aGF0IG1pZ2h0IGJlIGF1dG8gd2hpdGVzcGFjZSByZW1vdmFsIGNhbmRpZGF0ZXMgb24gbmV4dCBlZGl0XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSByZXZlcnNlUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyIDw9IHJldmVyc2VSYW5nZS5lbmRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TGluZUNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lTnVtYmVyID09PSByZXZlcnNlUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVDb250ZW50ID0gdGhpcy5nZXRMaW5lQ29udGVudChvcC5yYW5nZS5zdGFydExpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdzLmZpcnN0Tm9uV2hpdGVzcGFjZUluZGV4KGN1cnJlbnRMaW5lQ29udGVudCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RyaW1BdXRvV2hpdGVzcGFjZUNhbmRpZGF0ZXMucHVzaCh7IGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsIG9sZENvbnRlbnQ6IGN1cnJlbnRMaW5lQ29udGVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV2ZXJzZU9wZXJhdGlvbnMgPSBudWxsO1xuICAgICAgICBpZiAoY29tcHV0ZVVuZG9FZGl0cykge1xuICAgICAgICAgICAgbGV0IHJldmVyc2VSYW5nZURlbHRhT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHJldmVyc2VPcGVyYXRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wZXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcCA9IG9wZXJhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmV2ZXJzZVJhbmdlID0gcmV2ZXJzZVJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJUZXh0ID0gdGhpcy5nZXRWYWx1ZUluUmFuZ2Uob3AucmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2VSYW5nZU9mZnNldCA9IG9wLnJhbmdlT2Zmc2V0ICsgcmV2ZXJzZVJhbmdlRGVsdGFPZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZVJhbmdlRGVsdGFPZmZzZXQgKz0gKG9wLnRleHQubGVuZ3RoIC0gYnVmZmVyVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldmVyc2VPcGVyYXRpb25zW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICBzb3J0SW5kZXg6IG9wLnNvcnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogb3AuaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJldmVyc2VSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogYnVmZmVyVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dENoYW5nZTogbmV3IFRleHRDaGFuZ2Uob3AucmFuZ2VPZmZzZXQsIGJ1ZmZlclRleHQsIHJldmVyc2VSYW5nZU9mZnNldCwgb3AudGV4dClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FuIG9ubHkgc29ydCByZXZlcnNlIG9wZXJhdGlvbnMgd2hlbiB0aGUgb3JkZXIgaXMgbm90IHNpZ25pZmljYW50XG4gICAgICAgICAgICBpZiAoIWhhc1RvdWNoaW5nUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZU9wZXJhdGlvbnMuc29ydCgoYSwgYikgPT4gYS5zb3J0SW5kZXggLSBiLnNvcnRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWlnaHRDb250YWluUlRMID0gbWlnaHRDb250YWluUlRMO1xuICAgICAgICB0aGlzLl9taWdodENvbnRhaW5VbnVzdWFsTGluZVRlcm1pbmF0b3JzID0gbWlnaHRDb250YWluVW51c3VhbExpbmVUZXJtaW5hdG9ycztcbiAgICAgICAgdGhpcy5fbWlnaHRDb250YWluTm9uQmFzaWNBU0NJSSA9IG1pZ2h0Q29udGFpbk5vbkJhc2ljQVNDSUk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRDaGFuZ2VzID0gdGhpcy5fZG9BcHBseUVkaXRzKG9wZXJhdGlvbnMpO1xuICAgICAgICBsZXQgdHJpbUF1dG9XaGl0ZXNwYWNlTGluZU51bWJlcnMgPSBudWxsO1xuICAgICAgICBpZiAocmVjb3JkVHJpbUF1dG9XaGl0ZXNwYWNlICYmIG5ld1RyaW1BdXRvV2hpdGVzcGFjZUNhbmRpZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gc29ydCBsaW5lIG51bWJlcnMgYXV0byB3aGl0ZXNwYWNlIHJlbW92YWwgY2FuZGlkYXRlcyBmb3IgbmV4dCBlZGl0IGRlc2NlbmRpbmdcbiAgICAgICAgICAgIG5ld1RyaW1BdXRvV2hpdGVzcGFjZUNhbmRpZGF0ZXMuc29ydCgoYSwgYikgPT4gYi5saW5lTnVtYmVyIC0gYS5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgIHRyaW1BdXRvV2hpdGVzcGFjZUxpbmVOdW1iZXJzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbmV3VHJpbUF1dG9XaGl0ZXNwYWNlQ2FuZGlkYXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBuZXdUcmltQXV0b1doaXRlc3BhY2VDYW5kaWRhdGVzW2ldLmxpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwICYmIG5ld1RyaW1BdXRvV2hpdGVzcGFjZUNhbmRpZGF0ZXNbaSAtIDFdLmxpbmVOdW1iZXIgPT09IGxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGhhdmUgdGhlIHNhbWUgbGluZSBudW1iZXIgdHdpY2VcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZDb250ZW50ID0gbmV3VHJpbUF1dG9XaGl0ZXNwYWNlQ2FuZGlkYXRlc1tpXS5vbGRDb250ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gdGhpcy5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZUNvbnRlbnQubGVuZ3RoID09PSAwIHx8IGxpbmVDb250ZW50ID09PSBwcmV2Q29udGVudCB8fCBzdHJpbmdzLmZpcnN0Tm9uV2hpdGVzcGFjZUluZGV4KGxpbmVDb250ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyaW1BdXRvV2hpdGVzcGFjZUxpbmVOdW1iZXJzLnB1c2gobGluZU51bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VDb250ZW50LmZpcmUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBcHBseUVkaXRzUmVzdWx0KHJldmVyc2VPcGVyYXRpb25zLCBjb250ZW50Q2hhbmdlcywgdHJpbUF1dG9XaGl0ZXNwYWNlTGluZU51bWJlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gb3BlcmF0aW9ucyBzdWNoIHRoYXQgdGhleSByZXByZXNlbnQgdGhlIHNhbWUgbG9naWMgZWRpdCxcbiAgICAgKiBidXQgdGhhdCB0aGV5IGFsc28gZG8gbm90IGNhdXNlIE9PTSBjcmFzaGVzLlxuICAgICAqL1xuICAgIF9yZWR1Y2VPcGVyYXRpb25zKG9wZXJhdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbnMubGVuZ3RoIDwgMTAwMCkge1xuICAgICAgICAgICAgLy8gV2Uga25vdyBmcm9tIGVtcGlyaWNhbCB0ZXN0aW5nIHRoYXQgYSB0aG91c2FuZCBlZGl0cyB3b3JrIGZpbmUgcmVnYXJkbGVzcyBvZiB0aGVpciBzaGFwZS5cbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IG9uZSBwb2ludCwgZHVlIHRvIGhvdyBldmVudHMgYXJlIGVtaXR0ZWQgYW5kIGhvdyBlYWNoIG9wZXJhdGlvbiBpcyBoYW5kbGVkLFxuICAgICAgICAvLyBzb21lIG9wZXJhdGlvbnMgY2FuIHRyaWdnZXIgYSBoaWdoIGFtb3VudCBvZiB0ZW1wb3Jhcnkgc3RyaW5nIGFsbG9jYXRpb25zLFxuICAgICAgICAvLyB0aGF0IHdpbGwgaW1tZWRpYXRlbHkgZ2V0IGVkaXRlZCBhZ2Fpbi5cbiAgICAgICAgLy8gZS5nLiBhIGZvcm1hdHRlciBpbnNlcnRpbmcgcmlkaWN1bG91cyBhbW1vdW50cyBvZiBcXG4gb24gYSBtb2RlbCB3aXRoIGEgc2luZ2xlIGxpbmVcbiAgICAgICAgLy8gVGhlcmVmb3JlLCB0aGUgc3RyYXRlZ3kgaXMgdG8gY29sbGFwc2UgYWxsIHRoZSBvcGVyYXRpb25zIGludG8gYSBodWdlIHNpbmdsZSBlZGl0IG9wZXJhdGlvblxuICAgICAgICByZXR1cm4gW3RoaXMuX3RvU2luZ2xlRWRpdE9wZXJhdGlvbihvcGVyYXRpb25zKV07XG4gICAgfVxuICAgIF90b1NpbmdsZUVkaXRPcGVyYXRpb24ob3BlcmF0aW9ucykge1xuICAgICAgICBsZXQgZm9yY2VNb3ZlTWFya2VycyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBmaXJzdEVkaXRSYW5nZSA9IG9wZXJhdGlvbnNbMF0ucmFuZ2U7XG4gICAgICAgIGNvbnN0IGxhc3RFZGl0UmFuZ2UgPSBvcGVyYXRpb25zW29wZXJhdGlvbnMubGVuZ3RoIC0gMV0ucmFuZ2U7XG4gICAgICAgIGNvbnN0IGVudGlyZUVkaXRSYW5nZSA9IG5ldyBSYW5nZShmaXJzdEVkaXRSYW5nZS5zdGFydExpbmVOdW1iZXIsIGZpcnN0RWRpdFJhbmdlLnN0YXJ0Q29sdW1uLCBsYXN0RWRpdFJhbmdlLmVuZExpbmVOdW1iZXIsIGxhc3RFZGl0UmFuZ2UuZW5kQ29sdW1uKTtcbiAgICAgICAgbGV0IGxhc3RFbmRMaW5lTnVtYmVyID0gZmlyc3RFZGl0UmFuZ2Uuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICBsZXQgbGFzdEVuZENvbHVtbiA9IGZpcnN0RWRpdFJhbmdlLnN0YXJ0Q29sdW1uO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9wZXJhdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbaV07XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IG9wZXJhdGlvbi5yYW5nZTtcbiAgICAgICAgICAgIGZvcmNlTW92ZU1hcmtlcnMgPSBmb3JjZU1vdmVNYXJrZXJzIHx8IG9wZXJhdGlvbi5mb3JjZU1vdmVNYXJrZXJzO1xuICAgICAgICAgICAgLy8gKDEpIC0tIFB1c2ggb2xkIHRleHRcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2V0VmFsdWVJblJhbmdlKG5ldyBSYW5nZShsYXN0RW5kTGluZU51bWJlciwgbGFzdEVuZENvbHVtbiwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5zdGFydENvbHVtbikpKTtcbiAgICAgICAgICAgIC8vICgyKSAtLSBQdXNoIG5ldyB0ZXh0XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9wZXJhdGlvbi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RFbmRMaW5lTnVtYmVyID0gcmFuZ2UuZW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgIGxhc3RFbmRDb2x1bW4gPSByYW5nZS5lbmRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IHJlc3VsdC5qb2luKCcnKTtcbiAgICAgICAgY29uc3QgW2VvbENvdW50LCBmaXJzdExpbmVMZW5ndGgsIGxhc3RMaW5lTGVuZ3RoXSA9IGNvdW50RU9MKHRleHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc29ydEluZGV4OiAwLFxuICAgICAgICAgICAgaWRlbnRpZmllcjogb3BlcmF0aW9uc1swXS5pZGVudGlmaWVyLFxuICAgICAgICAgICAgcmFuZ2U6IGVudGlyZUVkaXRSYW5nZSxcbiAgICAgICAgICAgIHJhbmdlT2Zmc2V0OiB0aGlzLmdldE9mZnNldEF0KGVudGlyZUVkaXRSYW5nZS5zdGFydExpbmVOdW1iZXIsIGVudGlyZUVkaXRSYW5nZS5zdGFydENvbHVtbiksXG4gICAgICAgICAgICByYW5nZUxlbmd0aDogdGhpcy5nZXRWYWx1ZUxlbmd0aEluUmFuZ2UoZW50aXJlRWRpdFJhbmdlLCAwIC8qIEVuZE9mTGluZVByZWZlcmVuY2UuVGV4dERlZmluZWQgKi8pLFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIGVvbENvdW50OiBlb2xDb3VudCxcbiAgICAgICAgICAgIGZpcnN0TGluZUxlbmd0aDogZmlyc3RMaW5lTGVuZ3RoLFxuICAgICAgICAgICAgbGFzdExpbmVMZW5ndGg6IGxhc3RMaW5lTGVuZ3RoLFxuICAgICAgICAgICAgZm9yY2VNb3ZlTWFya2VyczogZm9yY2VNb3ZlTWFya2VycyxcbiAgICAgICAgICAgIGlzQXV0b1doaXRlc3BhY2VFZGl0OiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBfZG9BcHBseUVkaXRzKG9wZXJhdGlvbnMpIHtcbiAgICAgICAgb3BlcmF0aW9ucy5zb3J0KFBpZWNlVHJlZVRleHRCdWZmZXIuX3NvcnRPcHNEZXNjZW5kaW5nKTtcbiAgICAgICAgY29uc3QgY29udGVudENoYW5nZXMgPSBbXTtcbiAgICAgICAgLy8gb3BlcmF0aW9ucyBhcmUgZnJvbSBib3R0b20gdG8gdG9wXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BlcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb3AgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRMaW5lTnVtYmVyID0gb3AucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRDb2x1bW4gPSBvcC5yYW5nZS5zdGFydENvbHVtbjtcbiAgICAgICAgICAgIGNvbnN0IGVuZExpbmVOdW1iZXIgPSBvcC5yYW5nZS5lbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgY29uc3QgZW5kQ29sdW1uID0gb3AucmFuZ2UuZW5kQ29sdW1uO1xuICAgICAgICAgICAgaWYgKHN0YXJ0TGluZU51bWJlciA9PT0gZW5kTGluZU51bWJlciAmJiBzdGFydENvbHVtbiA9PT0gZW5kQ29sdW1uICYmIG9wLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLl9waWVjZVRyZWUuZGVsZXRlKG9wLnJhbmdlT2Zmc2V0LCBvcC5yYW5nZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGllY2VUcmVlLmluc2VydChvcC5yYW5nZU9mZnNldCwgb3AudGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGlvblxuICAgICAgICAgICAgICAgIHRoaXMuX3BpZWNlVHJlZS5kZWxldGUob3AucmFuZ2VPZmZzZXQsIG9wLnJhbmdlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDaGFuZ2VSYW5nZSA9IG5ldyBSYW5nZShzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pO1xuICAgICAgICAgICAgY29udGVudENoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IGNvbnRlbnRDaGFuZ2VSYW5nZSxcbiAgICAgICAgICAgICAgICByYW5nZUxlbmd0aDogb3AucmFuZ2VMZW5ndGgsXG4gICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgICByYW5nZU9mZnNldDogb3AucmFuZ2VPZmZzZXQsXG4gICAgICAgICAgICAgICAgZm9yY2VNb3ZlTWFya2Vyczogb3AuZm9yY2VNb3ZlTWFya2Vyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnRDaGFuZ2VzO1xuICAgIH1cbiAgICBmaW5kTWF0Y2hlc0xpbmVCeUxpbmUoc2VhcmNoUmFuZ2UsIHNlYXJjaERhdGEsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waWVjZVRyZWUuZmluZE1hdGNoZXNMaW5lQnlMaW5lKHNlYXJjaFJhbmdlLCBzZWFyY2hEYXRhLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc3VtZXMgYG9wZXJhdGlvbnNgIGFyZSB2YWxpZGF0ZWQgYW5kIHNvcnRlZCBhc2NlbmRpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgX2dldEludmVyc2VFZGl0UmFuZ2VzKG9wZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBwcmV2T3BFbmRMaW5lTnVtYmVyID0gMDtcbiAgICAgICAgbGV0IHByZXZPcEVuZENvbHVtbiA9IDA7XG4gICAgICAgIGxldCBwcmV2T3AgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb3BlcmF0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb3AgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgICAgbGV0IHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIGxldCBzdGFydENvbHVtbjtcbiAgICAgICAgICAgIGlmIChwcmV2T3ApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldk9wLnJhbmdlLmVuZExpbmVOdW1iZXIgPT09IG9wLnJhbmdlLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBwcmV2T3BFbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbiA9IHByZXZPcEVuZENvbHVtbiArIChvcC5yYW5nZS5zdGFydENvbHVtbiAtIHByZXZPcC5yYW5nZS5lbmRDb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gcHJldk9wRW5kTGluZU51bWJlciArIChvcC5yYW5nZS5zdGFydExpbmVOdW1iZXIgLSBwcmV2T3AucmFuZ2UuZW5kTGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gb3AucmFuZ2Uuc3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gb3AucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gb3AucmFuZ2Uuc3RhcnRDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0UmFuZ2U7XG4gICAgICAgICAgICBpZiAob3AudGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiBpbnNlcnRzIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IG9wLmVvbENvdW50ICsgMTtcbiAgICAgICAgICAgICAgICBpZiAobGluZUNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBsaW5lIGluc2VydFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRSYW5nZSA9IG5ldyBSYW5nZShzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uICsgb3AuZmlyc3RMaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG11bHRpIGxpbmUgaW5zZXJ0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIHN0YXJ0TGluZU51bWJlciArIGxpbmVDb3VudCAtIDEsIG9wLmxhc3RMaW5lTGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm90aGluZyB0byBpbnNlcnRcbiAgICAgICAgICAgICAgICByZXN1bHRSYW5nZSA9IG5ldyBSYW5nZShzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZPcEVuZExpbmVOdW1iZXIgPSByZXN1bHRSYW5nZS5lbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgcHJldk9wRW5kQ29sdW1uID0gcmVzdWx0UmFuZ2UuZW5kQ29sdW1uO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVzdWx0UmFuZ2UpO1xuICAgICAgICAgICAgcHJldk9wID0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIF9zb3J0T3BzQXNjZW5kaW5nKGEsIGIpIHtcbiAgICAgICAgY29uc3QgciA9IFJhbmdlLmNvbXBhcmVSYW5nZXNVc2luZ0VuZHMoYS5yYW5nZSwgYi5yYW5nZSk7XG4gICAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zb3J0SW5kZXggLSBiLnNvcnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgc3RhdGljIF9zb3J0T3BzRGVzY2VuZGluZyhhLCBiKSB7XG4gICAgICAgIGNvbnN0IHIgPSBSYW5nZS5jb21wYXJlUmFuZ2VzVXNpbmdFbmRzKGEucmFuZ2UsIGIucmFuZ2UpO1xuICAgICAgICBpZiAociA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGIuc29ydEluZGV4IC0gYS5zb3J0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC1yO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcbmltcG9ydCB7IFN0cmluZ0J1ZmZlciwgY3JlYXRlTGluZVN0YXJ0cywgY3JlYXRlTGluZVN0YXJ0c0Zhc3QgfSBmcm9tICcuL3BpZWNlVHJlZUJhc2UuanMnO1xuaW1wb3J0IHsgUGllY2VUcmVlVGV4dEJ1ZmZlciB9IGZyb20gJy4vcGllY2VUcmVlVGV4dEJ1ZmZlci5qcyc7XG5jbGFzcyBQaWVjZVRyZWVUZXh0QnVmZmVyRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoX2NodW5rcywgX2JvbSwgX2NyLCBfbGYsIF9jcmxmLCBfY29udGFpbnNSVEwsIF9jb250YWluc1VudXN1YWxMaW5lVGVybWluYXRvcnMsIF9pc0Jhc2ljQVNDSUksIF9ub3JtYWxpemVFT0wpIHtcbiAgICAgICAgdGhpcy5fY2h1bmtzID0gX2NodW5rcztcbiAgICAgICAgdGhpcy5fYm9tID0gX2JvbTtcbiAgICAgICAgdGhpcy5fY3IgPSBfY3I7XG4gICAgICAgIHRoaXMuX2xmID0gX2xmO1xuICAgICAgICB0aGlzLl9jcmxmID0gX2NybGY7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5zUlRMID0gX2NvbnRhaW5zUlRMO1xuICAgICAgICB0aGlzLl9jb250YWluc1VudXN1YWxMaW5lVGVybWluYXRvcnMgPSBfY29udGFpbnNVbnVzdWFsTGluZVRlcm1pbmF0b3JzO1xuICAgICAgICB0aGlzLl9pc0Jhc2ljQVNDSUkgPSBfaXNCYXNpY0FTQ0lJO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVFT0wgPSBfbm9ybWFsaXplRU9MO1xuICAgIH1cbiAgICBfZ2V0RU9MKGRlZmF1bHRFT0wpIHtcbiAgICAgICAgY29uc3QgdG90YWxFT0xDb3VudCA9IHRoaXMuX2NyICsgdGhpcy5fbGYgKyB0aGlzLl9jcmxmO1xuICAgICAgICBjb25zdCB0b3RhbENSQ291bnQgPSB0aGlzLl9jciArIHRoaXMuX2NybGY7XG4gICAgICAgIGlmICh0b3RhbEVPTENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGVtcHR5IGZpbGUgb3IgYSBmaWxlIHdpdGggcHJlY2lzZWx5IG9uZSBsaW5lXG4gICAgICAgICAgICByZXR1cm4gKGRlZmF1bHRFT0wgPT09IDEgLyogRGVmYXVsdEVuZE9mTGluZS5MRiAqLyA/ICdcXG4nIDogJ1xcclxcbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3RhbENSQ291bnQgPiB0b3RhbEVPTENvdW50IC8gMikge1xuICAgICAgICAgICAgLy8gTW9yZSB0aGFuIGhhbGYgb2YgdGhlIGZpbGUgY29udGFpbnMgXFxyXFxuIGVuZGluZyBsaW5lc1xuICAgICAgICAgICAgcmV0dXJuICdcXHJcXG4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IGxlYXN0IG9uZSBsaW5lIG1vcmUgZW5kcyBpbiBcXG5cbiAgICAgICAgcmV0dXJuICdcXG4nO1xuICAgIH1cbiAgICBjcmVhdGUoZGVmYXVsdEVPTCkge1xuICAgICAgICBjb25zdCBlb2wgPSB0aGlzLl9nZXRFT0woZGVmYXVsdEVPTCk7XG4gICAgICAgIGNvbnN0IGNodW5rcyA9IHRoaXMuX2NodW5rcztcbiAgICAgICAgaWYgKHRoaXMuX25vcm1hbGl6ZUVPTCAmJlxuICAgICAgICAgICAgKChlb2wgPT09ICdcXHJcXG4nICYmICh0aGlzLl9jciA+IDAgfHwgdGhpcy5fbGYgPiAwKSlcbiAgICAgICAgICAgICAgICB8fCAoZW9sID09PSAnXFxuJyAmJiAodGhpcy5fY3IgPiAwIHx8IHRoaXMuX2NybGYgPiAwKSkpKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgcGllY2VzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2h1bmtzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyID0gY2h1bmtzW2ldLmJ1ZmZlci5yZXBsYWNlKC9cXHJcXG58XFxyfFxcbi9nLCBlb2wpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVTdGFydCA9IGNyZWF0ZUxpbmVTdGFydHNGYXN0KHN0cik7XG4gICAgICAgICAgICAgICAgY2h1bmtzW2ldID0gbmV3IFN0cmluZ0J1ZmZlcihzdHIsIG5ld0xpbmVTdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dEJ1ZmZlciA9IG5ldyBQaWVjZVRyZWVUZXh0QnVmZmVyKGNodW5rcywgdGhpcy5fYm9tLCBlb2wsIHRoaXMuX2NvbnRhaW5zUlRMLCB0aGlzLl9jb250YWluc1VudXN1YWxMaW5lVGVybWluYXRvcnMsIHRoaXMuX2lzQmFzaWNBU0NJSSwgdGhpcy5fbm9ybWFsaXplRU9MKTtcbiAgICAgICAgcmV0dXJuIHsgdGV4dEJ1ZmZlcjogdGV4dEJ1ZmZlciwgZGlzcG9zYWJsZTogdGV4dEJ1ZmZlciB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQaWVjZVRyZWVUZXh0QnVmZmVyQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuQk9NID0gJyc7XG4gICAgICAgIHRoaXMuX2hhc1ByZXZpb3VzQ2hhciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcmV2aW91c0NoYXIgPSAwO1xuICAgICAgICB0aGlzLl90bXBMaW5lU3RhcnRzID0gW107XG4gICAgICAgIHRoaXMuY3IgPSAwO1xuICAgICAgICB0aGlzLmxmID0gMDtcbiAgICAgICAgdGhpcy5jcmxmID0gMDtcbiAgICAgICAgdGhpcy5jb250YWluc1JUTCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRhaW5zVW51c3VhbExpbmVUZXJtaW5hdG9ycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQmFzaWNBU0NJSSA9IHRydWU7XG4gICAgfVxuICAgIGFjY2VwdENodW5rKGNodW5rKSB7XG4gICAgICAgIGlmIChjaHVuay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc3RyaW5ncy5zdGFydHNXaXRoVVRGOEJPTShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkJPTSA9IHN0cmluZ3MuVVRGOF9CT01fQ0hBUkFDVEVSO1xuICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc3Vic3RyKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RDaGFyID0gY2h1bmsuY2hhckNvZGVBdChjaHVuay5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGxhc3RDaGFyID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLyB8fCAobGFzdENoYXIgPj0gMHhEODAwICYmIGxhc3RDaGFyIDw9IDB4REJGRikpIHtcbiAgICAgICAgICAgIC8vIGxhc3QgY2hhcmFjdGVyIGlzIFxcciBvciBhIGhpZ2ggc3Vycm9nYXRlID0+IGtlZXAgaXQgYmFja1xuICAgICAgICAgICAgdGhpcy5fYWNjZXB0Q2h1bmsxKGNodW5rLnN1YnN0cigwLCBjaHVuay5sZW5ndGggLSAxKSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5faGFzUHJldmlvdXNDaGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzQ2hhciA9IGxhc3RDaGFyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWNjZXB0Q2h1bmsxKGNodW5rLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9oYXNQcmV2aW91c0NoYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzQ2hhciA9IGxhc3RDaGFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hY2NlcHRDaHVuazEoY2h1bmssIGFsbG93RW1wdHlTdHJpbmdzKSB7XG4gICAgICAgIGlmICghYWxsb3dFbXB0eVN0cmluZ3MgJiYgY2h1bmsubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2hhc1ByZXZpb3VzQ2hhcikge1xuICAgICAgICAgICAgdGhpcy5fYWNjZXB0Q2h1bmsyKFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5fcHJldmlvdXNDaGFyKSArIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY2VwdENodW5rMihjaHVuayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FjY2VwdENodW5rMihjaHVuaykge1xuICAgICAgICBjb25zdCBsaW5lU3RhcnRzID0gY3JlYXRlTGluZVN0YXJ0cyh0aGlzLl90bXBMaW5lU3RhcnRzLCBjaHVuayk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFN0cmluZ0J1ZmZlcihjaHVuaywgbGluZVN0YXJ0cy5saW5lU3RhcnRzKSk7XG4gICAgICAgIHRoaXMuY3IgKz0gbGluZVN0YXJ0cy5jcjtcbiAgICAgICAgdGhpcy5sZiArPSBsaW5lU3RhcnRzLmxmO1xuICAgICAgICB0aGlzLmNybGYgKz0gbGluZVN0YXJ0cy5jcmxmO1xuICAgICAgICBpZiAoIWxpbmVTdGFydHMuaXNCYXNpY0FTQ0lJKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNodW5rIGNvbnRhaW5zIG5vbiBiYXNpYyBBU0NJSSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICB0aGlzLmlzQmFzaWNBU0NJSSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5zUlRMKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluc1JUTCA9IHN0cmluZ3MuY29udGFpbnNSVEwoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5zVW51c3VhbExpbmVUZXJtaW5hdG9ycykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbnNVbnVzdWFsTGluZVRlcm1pbmF0b3JzID0gc3RyaW5ncy5jb250YWluc1VudXN1YWxMaW5lVGVybWluYXRvcnMoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmlzaChub3JtYWxpemVFT0wgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2ZpbmlzaCgpO1xuICAgICAgICByZXR1cm4gbmV3IFBpZWNlVHJlZVRleHRCdWZmZXJGYWN0b3J5KHRoaXMuY2h1bmtzLCB0aGlzLkJPTSwgdGhpcy5jciwgdGhpcy5sZiwgdGhpcy5jcmxmLCB0aGlzLmNvbnRhaW5zUlRMLCB0aGlzLmNvbnRhaW5zVW51c3VhbExpbmVUZXJtaW5hdG9ycywgdGhpcy5pc0Jhc2ljQVNDSUksIG5vcm1hbGl6ZUVPTCk7XG4gICAgfVxuICAgIF9maW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY2VwdENodW5rMSgnJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2hhc1ByZXZpb3VzQ2hhcikge1xuICAgICAgICAgICAgdGhpcy5faGFzUHJldmlvdXNDaGFyID0gZmFsc2U7XG4gICAgICAgICAgICAvLyByZWNyZWF0ZSBsYXN0IGNodW5rXG4gICAgICAgICAgICBjb25zdCBsYXN0Q2h1bmsgPSB0aGlzLmNodW5rc1t0aGlzLmNodW5rcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxhc3RDaHVuay5idWZmZXIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLl9wcmV2aW91c0NoYXIpO1xuICAgICAgICAgICAgY29uc3QgbmV3TGluZVN0YXJ0cyA9IGNyZWF0ZUxpbmVTdGFydHNGYXN0KGxhc3RDaHVuay5idWZmZXIpO1xuICAgICAgICAgICAgbGFzdENodW5rLmxpbmVTdGFydHMgPSBuZXdMaW5lU3RhcnRzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzQ2hhciA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBjbGFzcyBUcmVlTm9kZSB7XG4gICAgY29uc3RydWN0b3IocGllY2UsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMucGllY2UgPSBwaWVjZTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLnNpemVfbGVmdCA9IDA7XG4gICAgICAgIHRoaXMubGZfbGVmdCA9IDA7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5sZWZ0ID0gdGhpcztcbiAgICAgICAgdGhpcy5yaWdodCA9IHRoaXM7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnRlc3QodGhpcy5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgICAgICB3aGlsZSAobm9kZS5wYXJlbnQgIT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQubGVmdCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnBhcmVudCA9PT0gU0VOVElORUwpIHtcbiAgICAgICAgICAgIHJldHVybiBTRU5USU5FTDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmV2KCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0dGVzdCh0aGlzLmxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gdGhpcztcbiAgICAgICAgd2hpbGUgKG5vZGUucGFyZW50ICE9PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50LnJpZ2h0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50ID09PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgcmV0dXJuIFNFTlRJTkVMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgU0VOVElORUwgPSBuZXcgVHJlZU5vZGUobnVsbCwgMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pO1xuU0VOVElORUwucGFyZW50ID0gU0VOVElORUw7XG5TRU5USU5FTC5sZWZ0ID0gU0VOVElORUw7XG5TRU5USU5FTC5yaWdodCA9IFNFTlRJTkVMO1xuU0VOVElORUwuY29sb3IgPSAwIC8qIE5vZGVDb2xvci5CbGFjayAqLztcbmV4cG9ydCBmdW5jdGlvbiBsZWZ0ZXN0KG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5sZWZ0ICE9PSBTRU5USU5FTCkge1xuICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByaWdodHRlc3Qobm9kZSkge1xuICAgIHdoaWxlIChub2RlLnJpZ2h0ICE9PSBTRU5USU5FTCkge1xuICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTaXplKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gU0VOVElORUwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnNpemVfbGVmdCArIG5vZGUucGllY2UubGVuZ3RoICsgY2FsY3VsYXRlU2l6ZShub2RlLnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxGKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gU0VOVElORUwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmxmX2xlZnQgKyBub2RlLnBpZWNlLmxpbmVGZWVkQ250ICsgY2FsY3VsYXRlTEYobm9kZS5yaWdodCk7XG59XG5mdW5jdGlvbiByZXNldFNlbnRpbmVsKCkge1xuICAgIFNFTlRJTkVMLnBhcmVudCA9IFNFTlRJTkVMO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxlZnRSb3RhdGUodHJlZSwgeCkge1xuICAgIGNvbnN0IHkgPSB4LnJpZ2h0O1xuICAgIC8vIGZpeCBzaXplX2xlZnRcbiAgICB5LnNpemVfbGVmdCArPSB4LnNpemVfbGVmdCArICh4LnBpZWNlID8geC5waWVjZS5sZW5ndGggOiAwKTtcbiAgICB5LmxmX2xlZnQgKz0geC5sZl9sZWZ0ICsgKHgucGllY2UgPyB4LnBpZWNlLmxpbmVGZWVkQ250IDogMCk7XG4gICAgeC5yaWdodCA9IHkubGVmdDtcbiAgICBpZiAoeS5sZWZ0ICE9PSBTRU5USU5FTCkge1xuICAgICAgICB5LmxlZnQucGFyZW50ID0geDtcbiAgICB9XG4gICAgeS5wYXJlbnQgPSB4LnBhcmVudDtcbiAgICBpZiAoeC5wYXJlbnQgPT09IFNFTlRJTkVMKSB7XG4gICAgICAgIHRyZWUucm9vdCA9IHk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHgucGFyZW50LmxlZnQgPT09IHgpIHtcbiAgICAgICAgeC5wYXJlbnQubGVmdCA9IHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB4LnBhcmVudC5yaWdodCA9IHk7XG4gICAgfVxuICAgIHkubGVmdCA9IHg7XG4gICAgeC5wYXJlbnQgPSB5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJpZ2h0Um90YXRlKHRyZWUsIHkpIHtcbiAgICBjb25zdCB4ID0geS5sZWZ0O1xuICAgIHkubGVmdCA9IHgucmlnaHQ7XG4gICAgaWYgKHgucmlnaHQgIT09IFNFTlRJTkVMKSB7XG4gICAgICAgIHgucmlnaHQucGFyZW50ID0geTtcbiAgICB9XG4gICAgeC5wYXJlbnQgPSB5LnBhcmVudDtcbiAgICAvLyBmaXggc2l6ZV9sZWZ0XG4gICAgeS5zaXplX2xlZnQgLT0geC5zaXplX2xlZnQgKyAoeC5waWVjZSA/IHgucGllY2UubGVuZ3RoIDogMCk7XG4gICAgeS5sZl9sZWZ0IC09IHgubGZfbGVmdCArICh4LnBpZWNlID8geC5waWVjZS5saW5lRmVlZENudCA6IDApO1xuICAgIGlmICh5LnBhcmVudCA9PT0gU0VOVElORUwpIHtcbiAgICAgICAgdHJlZS5yb290ID0geDtcbiAgICB9XG4gICAgZWxzZSBpZiAoeSA9PT0geS5wYXJlbnQucmlnaHQpIHtcbiAgICAgICAgeS5wYXJlbnQucmlnaHQgPSB4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeS5wYXJlbnQubGVmdCA9IHg7XG4gICAgfVxuICAgIHgucmlnaHQgPSB5O1xuICAgIHkucGFyZW50ID0geDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYkRlbGV0ZSh0cmVlLCB6KSB7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgaWYgKHoubGVmdCA9PT0gU0VOVElORUwpIHtcbiAgICAgICAgeSA9IHo7XG4gICAgICAgIHggPSB5LnJpZ2h0O1xuICAgIH1cbiAgICBlbHNlIGlmICh6LnJpZ2h0ID09PSBTRU5USU5FTCkge1xuICAgICAgICB5ID0gejtcbiAgICAgICAgeCA9IHkubGVmdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHkgPSBsZWZ0ZXN0KHoucmlnaHQpO1xuICAgICAgICB4ID0geS5yaWdodDtcbiAgICB9XG4gICAgaWYgKHkgPT09IHRyZWUucm9vdCkge1xuICAgICAgICB0cmVlLnJvb3QgPSB4O1xuICAgICAgICAvLyBpZiB4IGlzIG51bGwsIHdlIGFyZSByZW1vdmluZyB0aGUgb25seSBub2RlXG4gICAgICAgIHguY29sb3IgPSAwIC8qIE5vZGVDb2xvci5CbGFjayAqLztcbiAgICAgICAgei5kZXRhY2goKTtcbiAgICAgICAgcmVzZXRTZW50aW5lbCgpO1xuICAgICAgICB0cmVlLnJvb3QucGFyZW50ID0gU0VOVElORUw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeVdhc1JlZCA9ICh5LmNvbG9yID09PSAxIC8qIE5vZGVDb2xvci5SZWQgKi8pO1xuICAgIGlmICh5ID09PSB5LnBhcmVudC5sZWZ0KSB7XG4gICAgICAgIHkucGFyZW50LmxlZnQgPSB4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeS5wYXJlbnQucmlnaHQgPSB4O1xuICAgIH1cbiAgICBpZiAoeSA9PT0geikge1xuICAgICAgICB4LnBhcmVudCA9IHkucGFyZW50O1xuICAgICAgICByZWNvbXB1dGVUcmVlTWV0YWRhdGEodHJlZSwgeCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoeS5wYXJlbnQgPT09IHopIHtcbiAgICAgICAgICAgIHgucGFyZW50ID0geTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHgucGFyZW50ID0geS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXMgd2UgbWFrZSBjaGFuZ2VzIHRvIHgncyBoaWVyYXJjaHksIHVwZGF0ZSBzaXplX2xlZnQgb2Ygc3VidHJlZSBmaXJzdFxuICAgICAgICByZWNvbXB1dGVUcmVlTWV0YWRhdGEodHJlZSwgeCk7XG4gICAgICAgIHkubGVmdCA9IHoubGVmdDtcbiAgICAgICAgeS5yaWdodCA9IHoucmlnaHQ7XG4gICAgICAgIHkucGFyZW50ID0gei5wYXJlbnQ7XG4gICAgICAgIHkuY29sb3IgPSB6LmNvbG9yO1xuICAgICAgICBpZiAoeiA9PT0gdHJlZS5yb290KSB7XG4gICAgICAgICAgICB0cmVlLnJvb3QgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHogPT09IHoucGFyZW50LmxlZnQpIHtcbiAgICAgICAgICAgICAgICB6LnBhcmVudC5sZWZ0ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHoucGFyZW50LnJpZ2h0ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoeS5sZWZ0ICE9PSBTRU5USU5FTCkge1xuICAgICAgICAgICAgeS5sZWZ0LnBhcmVudCA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkucmlnaHQgIT09IFNFTlRJTkVMKSB7XG4gICAgICAgICAgICB5LnJpZ2h0LnBhcmVudCA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIG1ldGFkYXRhXG4gICAgICAgIC8vIHdlIHJlcGxhY2UgeiB3aXRoIHksIHNvIGluIHRoaXMgc3ViIHRyZWUsIHRoZSBsZW5ndGggY2hhbmdlIGlzIHouaXRlbS5sZW5ndGhcbiAgICAgICAgeS5zaXplX2xlZnQgPSB6LnNpemVfbGVmdDtcbiAgICAgICAgeS5sZl9sZWZ0ID0gei5sZl9sZWZ0O1xuICAgICAgICByZWNvbXB1dGVUcmVlTWV0YWRhdGEodHJlZSwgeSk7XG4gICAgfVxuICAgIHouZGV0YWNoKCk7XG4gICAgaWYgKHgucGFyZW50LmxlZnQgPT09IHgpIHtcbiAgICAgICAgY29uc3QgbmV3U2l6ZUxlZnQgPSBjYWxjdWxhdGVTaXplKHgpO1xuICAgICAgICBjb25zdCBuZXdMRkxlZnQgPSBjYWxjdWxhdGVMRih4KTtcbiAgICAgICAgaWYgKG5ld1NpemVMZWZ0ICE9PSB4LnBhcmVudC5zaXplX2xlZnQgfHwgbmV3TEZMZWZ0ICE9PSB4LnBhcmVudC5sZl9sZWZ0KSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IG5ld1NpemVMZWZ0IC0geC5wYXJlbnQuc2l6ZV9sZWZ0O1xuICAgICAgICAgICAgY29uc3QgbGZfZGVsdGEgPSBuZXdMRkxlZnQgLSB4LnBhcmVudC5sZl9sZWZ0O1xuICAgICAgICAgICAgeC5wYXJlbnQuc2l6ZV9sZWZ0ID0gbmV3U2l6ZUxlZnQ7XG4gICAgICAgICAgICB4LnBhcmVudC5sZl9sZWZ0ID0gbmV3TEZMZWZ0O1xuICAgICAgICAgICAgdXBkYXRlVHJlZU1ldGFkYXRhKHRyZWUsIHgucGFyZW50LCBkZWx0YSwgbGZfZGVsdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlY29tcHV0ZVRyZWVNZXRhZGF0YSh0cmVlLCB4LnBhcmVudCk7XG4gICAgaWYgKHlXYXNSZWQpIHtcbiAgICAgICAgcmVzZXRTZW50aW5lbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJCLURFTEVURS1GSVhVUFxuICAgIGxldCB3O1xuICAgIHdoaWxlICh4ICE9PSB0cmVlLnJvb3QgJiYgeC5jb2xvciA9PT0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pIHtcbiAgICAgICAgaWYgKHggPT09IHgucGFyZW50LmxlZnQpIHtcbiAgICAgICAgICAgIHcgPSB4LnBhcmVudC5yaWdodDtcbiAgICAgICAgICAgIGlmICh3LmNvbG9yID09PSAxIC8qIE5vZGVDb2xvci5SZWQgKi8pIHtcbiAgICAgICAgICAgICAgICB3LmNvbG9yID0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi87XG4gICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSAxIC8qIE5vZGVDb2xvci5SZWQgKi87XG4gICAgICAgICAgICAgICAgbGVmdFJvdGF0ZSh0cmVlLCB4LnBhcmVudCk7XG4gICAgICAgICAgICAgICAgdyA9IHgucGFyZW50LnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHcubGVmdC5jb2xvciA9PT0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8gJiYgdy5yaWdodC5jb2xvciA9PT0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pIHtcbiAgICAgICAgICAgICAgICB3LmNvbG9yID0gMSAvKiBOb2RlQ29sb3IuUmVkICovO1xuICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh3LnJpZ2h0LmNvbG9yID09PSAwIC8qIE5vZGVDb2xvci5CbGFjayAqLykge1xuICAgICAgICAgICAgICAgICAgICB3LmxlZnQuY29sb3IgPSAwIC8qIE5vZGVDb2xvci5CbGFjayAqLztcbiAgICAgICAgICAgICAgICAgICAgdy5jb2xvciA9IDEgLyogTm9kZUNvbG9yLlJlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRSb3RhdGUodHJlZSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIHcgPSB4LnBhcmVudC5yaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdy5jb2xvciA9IHgucGFyZW50LmNvbG9yO1xuICAgICAgICAgICAgICAgIHgucGFyZW50LmNvbG9yID0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi87XG4gICAgICAgICAgICAgICAgdy5yaWdodC5jb2xvciA9IDAgLyogTm9kZUNvbG9yLkJsYWNrICovO1xuICAgICAgICAgICAgICAgIGxlZnRSb3RhdGUodHJlZSwgeC5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIHggPSB0cmVlLnJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3ID0geC5wYXJlbnQubGVmdDtcbiAgICAgICAgICAgIGlmICh3LmNvbG9yID09PSAxIC8qIE5vZGVDb2xvci5SZWQgKi8pIHtcbiAgICAgICAgICAgICAgICB3LmNvbG9yID0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi87XG4gICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSAxIC8qIE5vZGVDb2xvci5SZWQgKi87XG4gICAgICAgICAgICAgICAgcmlnaHRSb3RhdGUodHJlZSwgeC5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIHcgPSB4LnBhcmVudC5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHcubGVmdC5jb2xvciA9PT0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8gJiYgdy5yaWdodC5jb2xvciA9PT0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi8pIHtcbiAgICAgICAgICAgICAgICB3LmNvbG9yID0gMSAvKiBOb2RlQ29sb3IuUmVkICovO1xuICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh3LmxlZnQuY29sb3IgPT09IDAgLyogTm9kZUNvbG9yLkJsYWNrICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHcucmlnaHQuY29sb3IgPSAwIC8qIE5vZGVDb2xvci5CbGFjayAqLztcbiAgICAgICAgICAgICAgICAgICAgdy5jb2xvciA9IDEgLyogTm9kZUNvbG9yLlJlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgbGVmdFJvdGF0ZSh0cmVlLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHgucGFyZW50LmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHcuY29sb3IgPSB4LnBhcmVudC5jb2xvcjtcbiAgICAgICAgICAgICAgICB4LnBhcmVudC5jb2xvciA9IDAgLyogTm9kZUNvbG9yLkJsYWNrICovO1xuICAgICAgICAgICAgICAgIHcubGVmdC5jb2xvciA9IDAgLyogTm9kZUNvbG9yLkJsYWNrICovO1xuICAgICAgICAgICAgICAgIHJpZ2h0Um90YXRlKHRyZWUsIHgucGFyZW50KTtcbiAgICAgICAgICAgICAgICB4ID0gdHJlZS5yb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHguY29sb3IgPSAwIC8qIE5vZGVDb2xvci5CbGFjayAqLztcbiAgICByZXNldFNlbnRpbmVsKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZml4SW5zZXJ0KHRyZWUsIHgpIHtcbiAgICByZWNvbXB1dGVUcmVlTWV0YWRhdGEodHJlZSwgeCk7XG4gICAgd2hpbGUgKHggIT09IHRyZWUucm9vdCAmJiB4LnBhcmVudC5jb2xvciA9PT0gMSAvKiBOb2RlQ29sb3IuUmVkICovKSB7XG4gICAgICAgIGlmICh4LnBhcmVudCA9PT0geC5wYXJlbnQucGFyZW50LmxlZnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB4LnBhcmVudC5wYXJlbnQucmlnaHQ7XG4gICAgICAgICAgICBpZiAoeS5jb2xvciA9PT0gMSAvKiBOb2RlQ29sb3IuUmVkICovKSB7XG4gICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSAwIC8qIE5vZGVDb2xvci5CbGFjayAqLztcbiAgICAgICAgICAgICAgICB5LmNvbG9yID0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi87XG4gICAgICAgICAgICAgICAgeC5wYXJlbnQucGFyZW50LmNvbG9yID0gMSAvKiBOb2RlQ29sb3IuUmVkICovO1xuICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0geC5wYXJlbnQucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Um90YXRlKHRyZWUsIHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4LnBhcmVudC5jb2xvciA9IDAgLyogTm9kZUNvbG9yLkJsYWNrICovO1xuICAgICAgICAgICAgICAgIHgucGFyZW50LnBhcmVudC5jb2xvciA9IDEgLyogTm9kZUNvbG9yLlJlZCAqLztcbiAgICAgICAgICAgICAgICByaWdodFJvdGF0ZSh0cmVlLCB4LnBhcmVudC5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeSA9IHgucGFyZW50LnBhcmVudC5sZWZ0O1xuICAgICAgICAgICAgaWYgKHkuY29sb3IgPT09IDEgLyogTm9kZUNvbG9yLlJlZCAqLykge1xuICAgICAgICAgICAgICAgIHgucGFyZW50LmNvbG9yID0gMCAvKiBOb2RlQ29sb3IuQmxhY2sgKi87XG4gICAgICAgICAgICAgICAgeS5jb2xvciA9IDAgLyogTm9kZUNvbG9yLkJsYWNrICovO1xuICAgICAgICAgICAgICAgIHgucGFyZW50LnBhcmVudC5jb2xvciA9IDEgLyogTm9kZUNvbG9yLlJlZCAqLztcbiAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IHgucGFyZW50LmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICByaWdodFJvdGF0ZSh0cmVlLCB4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSAwIC8qIE5vZGVDb2xvci5CbGFjayAqLztcbiAgICAgICAgICAgICAgICB4LnBhcmVudC5wYXJlbnQuY29sb3IgPSAxIC8qIE5vZGVDb2xvci5SZWQgKi87XG4gICAgICAgICAgICAgICAgbGVmdFJvdGF0ZSh0cmVlLCB4LnBhcmVudC5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyZWUucm9vdC5jb2xvciA9IDAgLyogTm9kZUNvbG9yLkJsYWNrICovO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVRyZWVNZXRhZGF0YSh0cmVlLCB4LCBkZWx0YSwgbGluZUZlZWRDbnREZWx0YSkge1xuICAgIC8vIG5vZGUgbGVuZ3RoIGNoYW5nZSBvciBsaW5lIGZlZWQgY291bnQgY2hhbmdlXG4gICAgd2hpbGUgKHggIT09IHRyZWUucm9vdCAmJiB4ICE9PSBTRU5USU5FTCkge1xuICAgICAgICBpZiAoeC5wYXJlbnQubGVmdCA9PT0geCkge1xuICAgICAgICAgICAgeC5wYXJlbnQuc2l6ZV9sZWZ0ICs9IGRlbHRhO1xuICAgICAgICAgICAgeC5wYXJlbnQubGZfbGVmdCArPSBsaW5lRmVlZENudERlbHRhO1xuICAgICAgICB9XG4gICAgICAgIHggPSB4LnBhcmVudDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjb21wdXRlVHJlZU1ldGFkYXRhKHRyZWUsIHgpIHtcbiAgICBsZXQgZGVsdGEgPSAwO1xuICAgIGxldCBsZl9kZWx0YSA9IDA7XG4gICAgaWYgKHggPT09IHRyZWUucm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGdvIHVwd2FyZHMgdGlsbCB0aGUgbm9kZSB3aG9zZSBsZWZ0IHN1YnRyZWUgaXMgY2hhbmdlZC5cbiAgICB3aGlsZSAoeCAhPT0gdHJlZS5yb290ICYmIHggPT09IHgucGFyZW50LnJpZ2h0KSB7XG4gICAgICAgIHggPSB4LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKHggPT09IHRyZWUucm9vdCkge1xuICAgICAgICAvLyB3ZWxsLCBpdCBtZWFucyB3ZSBhZGQgYSBub2RlIHRvIHRoZSBlbmQgKGlub3JkZXIpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8geCBpcyB0aGUgbm9kZSB3aG9zZSByaWdodCBzdWJ0cmVlIGlzIGNoYW5nZWQuXG4gICAgeCA9IHgucGFyZW50O1xuICAgIGRlbHRhID0gY2FsY3VsYXRlU2l6ZSh4LmxlZnQpIC0geC5zaXplX2xlZnQ7XG4gICAgbGZfZGVsdGEgPSBjYWxjdWxhdGVMRih4LmxlZnQpIC0geC5sZl9sZWZ0O1xuICAgIHguc2l6ZV9sZWZ0ICs9IGRlbHRhO1xuICAgIHgubGZfbGVmdCArPSBsZl9kZWx0YTtcbiAgICAvLyBnbyB1cHdhcmRzIHRpbGwgcm9vdC4gTyhsb2dOKVxuICAgIHdoaWxlICh4ICE9PSB0cmVlLnJvb3QgJiYgKGRlbHRhICE9PSAwIHx8IGxmX2RlbHRhICE9PSAwKSkge1xuICAgICAgICBpZiAoeC5wYXJlbnQubGVmdCA9PT0geCkge1xuICAgICAgICAgICAgeC5wYXJlbnQuc2l6ZV9sZWZ0ICs9IGRlbHRhO1xuICAgICAgICAgICAgeC5wYXJlbnQubGZfbGVmdCArPSBsZl9kZWx0YTtcbiAgICAgICAgfVxuICAgICAgICB4ID0geC5wYXJlbnQ7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbnZhciBUZXh0TW9kZWxfMTtcbmltcG9ydCB7IEFycmF5UXVldWUsIHB1c2hNYW55IH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzLmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vY29sb3IuanMnO1xuaW1wb3J0IHsgQnVnSW5kaWNhdGluZ0Vycm9yLCBpbGxlZ2FsQXJndW1lbnQsIG9uVW5leHBlY3RlZEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZXJyb3JzLmpzJztcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9ldmVudC5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlLCBNdXRhYmxlRGlzcG9zYWJsZSwgY29tYmluZWREaXNwb3NhYmxlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7XG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xuaW1wb3J0IHsgY291bnRFT0wgfSBmcm9tICcuLi9jb3JlL2VvbENvdW50ZXIuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplSW5kZW50YXRpb24gfSBmcm9tICcuLi9jb3JlL2luZGVudGF0aW9uLmpzJztcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgU2VsZWN0aW9uIH0gZnJvbSAnLi4vY29yZS9zZWxlY3Rpb24uanMnO1xuaW1wb3J0IHsgRURJVE9SX01PREVMX0RFRkFVTFRTIH0gZnJvbSAnLi4vY29yZS90ZXh0TW9kZWxEZWZhdWx0cy5qcyc7XG5pbXBvcnQgeyBJTGFuZ3VhZ2VTZXJ2aWNlIH0gZnJvbSAnLi4vbGFuZ3VhZ2VzL2xhbmd1YWdlLmpzJztcbmltcG9ydCB7IElMYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vbGFuZ3VhZ2VzL2xhbmd1YWdlQ29uZmlndXJhdGlvblJlZ2lzdHJ5LmpzJztcbmltcG9ydCAqIGFzIG1vZGVsIGZyb20gJy4uL21vZGVsLmpzJztcbmltcG9ydCB7IEJyYWNrZXRQYWlyc1RleHRNb2RlbFBhcnQgfSBmcm9tICcuL2JyYWNrZXRQYWlyc1RleHRNb2RlbFBhcnQvYnJhY2tldFBhaXJzSW1wbC5qcyc7XG5pbXBvcnQgeyBDb2xvcml6ZWRCcmFja2V0UGFpcnNEZWNvcmF0aW9uUHJvdmlkZXIgfSBmcm9tICcuL2JyYWNrZXRQYWlyc1RleHRNb2RlbFBhcnQvY29sb3JpemVkQnJhY2tldFBhaXJzRGVjb3JhdGlvblByb3ZpZGVyLmpzJztcbmltcG9ydCB7IEVkaXRTdGFjayB9IGZyb20gJy4vZWRpdFN0YWNrLmpzJztcbmltcG9ydCB7IEd1aWRlc1RleHRNb2RlbFBhcnQgfSBmcm9tICcuL2d1aWRlc1RleHRNb2RlbFBhcnQuanMnO1xuaW1wb3J0IHsgZ3Vlc3NJbmRlbnRhdGlvbiB9IGZyb20gJy4vaW5kZW50YXRpb25HdWVzc2VyLmpzJztcbmltcG9ydCB7IEludGVydmFsTm9kZSwgSW50ZXJ2YWxUcmVlLCByZWNvbXB1dGVNYXhFbmQgfSBmcm9tICcuL2ludGVydmFsVHJlZS5qcyc7XG5pbXBvcnQgeyBQaWVjZVRyZWVUZXh0QnVmZmVyIH0gZnJvbSAnLi9waWVjZVRyZWVUZXh0QnVmZmVyL3BpZWNlVHJlZVRleHRCdWZmZXIuanMnO1xuaW1wb3J0IHsgUGllY2VUcmVlVGV4dEJ1ZmZlckJ1aWxkZXIgfSBmcm9tICcuL3BpZWNlVHJlZVRleHRCdWZmZXIvcGllY2VUcmVlVGV4dEJ1ZmZlckJ1aWxkZXIuanMnO1xuaW1wb3J0IHsgU2VhcmNoUGFyYW1zLCBUZXh0TW9kZWxTZWFyY2ggfSBmcm9tICcuL3RleHRNb2RlbFNlYXJjaC5qcyc7XG5pbXBvcnQgeyBUb2tlbml6YXRpb25UZXh0TW9kZWxQYXJ0IH0gZnJvbSAnLi90b2tlbml6YXRpb25UZXh0TW9kZWxQYXJ0LmpzJztcbmltcG9ydCB7IEF0dGFjaGVkVmlld3MgfSBmcm9tICcuL3Rva2Vucy5qcyc7XG5pbXBvcnQgeyBJbnRlcm5hbE1vZGVsQ29udGVudENoYW5nZUV2ZW50LCBMaW5lSW5qZWN0ZWRUZXh0LCBNb2RlbEluamVjdGVkVGV4dENoYW5nZWRFdmVudCwgTW9kZWxSYXdDb250ZW50Q2hhbmdlZEV2ZW50LCBNb2RlbFJhd0VPTENoYW5nZWQsIE1vZGVsUmF3Rmx1c2gsIE1vZGVsUmF3TGluZUNoYW5nZWQsIE1vZGVsUmF3TGluZXNEZWxldGVkLCBNb2RlbFJhd0xpbmVzSW5zZXJ0ZWQgfSBmcm9tICcuLi90ZXh0TW9kZWxFdmVudHMuanMnO1xuaW1wb3J0IHsgSUluc3RhbnRpYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vcGxhdGZvcm0vaW5zdGFudGlhdGlvbi9jb21tb24vaW5zdGFudGlhdGlvbi5qcyc7XG5pbXBvcnQgeyBJVW5kb1JlZG9TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vcGxhdGZvcm0vdW5kb1JlZG8vY29tbW9uL3VuZG9SZWRvLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUZXh0QnVmZmVyRmFjdG9yeSh0ZXh0KSB7XG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBQaWVjZVRyZWVUZXh0QnVmZmVyQnVpbGRlcigpO1xuICAgIGJ1aWxkZXIuYWNjZXB0Q2h1bmsodGV4dCk7XG4gICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGV4dEJ1ZmZlckZhY3RvcnlGcm9tU25hcHNob3Qoc25hcHNob3QpIHtcbiAgICBjb25zdCBidWlsZGVyID0gbmV3IFBpZWNlVHJlZVRleHRCdWZmZXJCdWlsZGVyKCk7XG4gICAgbGV0IGNodW5rO1xuICAgIHdoaWxlICh0eXBlb2YgKGNodW5rID0gc25hcHNob3QucmVhZCgpKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVpbGRlci5hY2NlcHRDaHVuayhjaHVuayk7XG4gICAgfVxuICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRleHRCdWZmZXIodmFsdWUsIGRlZmF1bHRFT0wpIHtcbiAgICBsZXQgZmFjdG9yeTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBmYWN0b3J5ID0gY3JlYXRlVGV4dEJ1ZmZlckZhY3RvcnkodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtb2RlbC5pc0lUZXh0U25hcHNob3QodmFsdWUpKSB7XG4gICAgICAgIGZhY3RvcnkgPSBjcmVhdGVUZXh0QnVmZmVyRmFjdG9yeUZyb21TbmFwc2hvdCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmYWN0b3J5ID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZShkZWZhdWx0RU9MKTtcbn1cbmxldCBNT0RFTF9JRCA9IDA7XG5jb25zdCBMSU1JVF9GSU5EX0NPVU5UID0gOTk5O1xuY29uc3QgTE9OR19MSU5FX0JPVU5EQVJZID0gMTAwMDA7XG5jbGFzcyBUZXh0TW9kZWxTbmFwc2hvdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5fZW9zID0gZmFsc2U7XG4gICAgfVxuICAgIHJlYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgcmVzdWx0Q250ID0gMDtcbiAgICAgICAgbGV0IHJlc3VsdExlbmd0aCA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHRoaXMuX3NvdXJjZS5yZWFkKCk7XG4gICAgICAgICAgICBpZiAodG1wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmVhbVxuICAgICAgICAgICAgICAgIHRoaXMuX2VvcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdENudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRtcC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdENudCsrXSA9IHRtcDtcbiAgICAgICAgICAgICAgICByZXN1bHRMZW5ndGggKz0gdG1wLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHRMZW5ndGggPj0gNjQgKiAxMDI0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxufVxuY29uc3QgaW52YWxpZEZ1bmMgPSAoKSA9PiB7IHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGFuZ2UgYWNjZXNzb3JgKTsgfTtcbmxldCBUZXh0TW9kZWwgPSBjbGFzcyBUZXh0TW9kZWwgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgICBzdGF0aWMgeyBUZXh0TW9kZWxfMSA9IHRoaXM7IH1cbiAgICBzdGF0aWMgeyB0aGlzLl9NT0RFTF9TWU5DX0xJTUlUID0gNTAgKiAxMDI0ICogMTAyNDsgfSAvLyA1MCBNQiwgIC8vIHVzZWQgaW4gdGVzdHNcbiAgICBzdGF0aWMgeyB0aGlzLkxBUkdFX0ZJTEVfU0laRV9USFJFU0hPTEQgPSAyMCAqIDEwMjQgKiAxMDI0OyB9IC8vIDIwIE1CO1xuICAgIHN0YXRpYyB7IHRoaXMuTEFSR0VfRklMRV9MSU5FX0NPVU5UX1RIUkVTSE9MRCA9IDMwMCAqIDEwMDA7IH0gLy8gMzAwSyBsaW5lc1xuICAgIHN0YXRpYyB7IHRoaXMuTEFSR0VfRklMRV9IRUFQX09QRVJBVElPTl9USFJFU0hPTEQgPSAyNTYgKiAxMDI0ICogMTAyNDsgfSAvLyAyNTZNIGNoYXJhY3RlcnMsIHVzdWFsbHkgfj4gNTEyTUIgbWVtb3J5IHVzYWdlXG4gICAgc3RhdGljIHsgdGhpcy5ERUZBVUxUX0NSRUFUSU9OX09QVElPTlMgPSB7XG4gICAgICAgIGlzRm9yU2ltcGxlV2lkZ2V0OiBmYWxzZSxcbiAgICAgICAgdGFiU2l6ZTogRURJVE9SX01PREVMX0RFRkFVTFRTLnRhYlNpemUsXG4gICAgICAgIGluZGVudFNpemU6IEVESVRPUl9NT0RFTF9ERUZBVUxUUy5pbmRlbnRTaXplLFxuICAgICAgICBpbnNlcnRTcGFjZXM6IEVESVRPUl9NT0RFTF9ERUZBVUxUUy5pbnNlcnRTcGFjZXMsXG4gICAgICAgIGRldGVjdEluZGVudGF0aW9uOiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdEVPTDogMSAvKiBtb2RlbC5EZWZhdWx0RW5kT2ZMaW5lLkxGICovLFxuICAgICAgICB0cmltQXV0b1doaXRlc3BhY2U6IEVESVRPUl9NT0RFTF9ERUZBVUxUUy50cmltQXV0b1doaXRlc3BhY2UsXG4gICAgICAgIGxhcmdlRmlsZU9wdGltaXphdGlvbnM6IEVESVRPUl9NT0RFTF9ERUZBVUxUUy5sYXJnZUZpbGVPcHRpbWl6YXRpb25zLFxuICAgICAgICBicmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnM6IEVESVRPUl9NT0RFTF9ERUZBVUxUUy5icmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnMsXG4gICAgfTsgfVxuICAgIHN0YXRpYyByZXNvbHZlT3B0aW9ucyh0ZXh0QnVmZmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmRldGVjdEluZGVudGF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBndWVzc2VkSW5kZW50YXRpb24gPSBndWVzc0luZGVudGF0aW9uKHRleHRCdWZmZXIsIG9wdGlvbnMudGFiU2l6ZSwgb3B0aW9ucy5pbnNlcnRTcGFjZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBtb2RlbC5UZXh0TW9kZWxSZXNvbHZlZE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIHRhYlNpemU6IGd1ZXNzZWRJbmRlbnRhdGlvbi50YWJTaXplLFxuICAgICAgICAgICAgICAgIGluZGVudFNpemU6ICd0YWJTaXplJywgLy8gVE9ET0BBbGV4OiBndWVzcyBpbmRlbnRTaXplIGluZGVwZW5kZW50IG9mIHRhYlNpemVcbiAgICAgICAgICAgICAgICBpbnNlcnRTcGFjZXM6IGd1ZXNzZWRJbmRlbnRhdGlvbi5pbnNlcnRTcGFjZXMsXG4gICAgICAgICAgICAgICAgdHJpbUF1dG9XaGl0ZXNwYWNlOiBvcHRpb25zLnRyaW1BdXRvV2hpdGVzcGFjZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0RU9MOiBvcHRpb25zLmRlZmF1bHRFT0wsXG4gICAgICAgICAgICAgICAgYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zOiBvcHRpb25zLmJyYWNrZXRQYWlyQ29sb3JpemF0aW9uT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgbW9kZWwuVGV4dE1vZGVsUmVzb2x2ZWRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXQgb25EaWRDaGFuZ2VMYW5ndWFnZSgpIHsgcmV0dXJuIHRoaXMuX3Rva2VuaXphdGlvblRleHRNb2RlbFBhcnQub25EaWRDaGFuZ2VMYW5ndWFnZTsgfVxuICAgIGdldCBvbkRpZENoYW5nZUxhbmd1YWdlQ29uZmlndXJhdGlvbigpIHsgcmV0dXJuIHRoaXMuX3Rva2VuaXphdGlvblRleHRNb2RlbFBhcnQub25EaWRDaGFuZ2VMYW5ndWFnZUNvbmZpZ3VyYXRpb247IH1cbiAgICBnZXQgb25EaWRDaGFuZ2VUb2tlbnMoKSB7IHJldHVybiB0aGlzLl90b2tlbml6YXRpb25UZXh0TW9kZWxQYXJ0Lm9uRGlkQ2hhbmdlVG9rZW5zOyB9XG4gICAgb25EaWRDaGFuZ2VDb250ZW50KGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudEVtaXR0ZXIuc2xvd0V2ZW50KChlKSA9PiBsaXN0ZW5lcihlLmNvbnRlbnRDaGFuZ2VkRXZlbnQpKTtcbiAgICB9XG4gICAgb25EaWRDaGFuZ2VDb250ZW50T3JJbmplY3RlZFRleHQobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkRGlzcG9zYWJsZSh0aGlzLl9ldmVudEVtaXR0ZXIuZmFzdEV2ZW50KGUgPT4gbGlzdGVuZXIoZSkpLCB0aGlzLl9vbkRpZENoYW5nZUluamVjdGVkVGV4dC5ldmVudChlID0+IGxpc3RlbmVyKGUpKSk7XG4gICAgfVxuICAgIF9pc0Rpc3Bvc2luZygpIHsgcmV0dXJuIHRoaXMuX19pc0Rpc3Bvc2luZzsgfVxuICAgIGdldCB0b2tlbml6YXRpb24oKSB7IHJldHVybiB0aGlzLl90b2tlbml6YXRpb25UZXh0TW9kZWxQYXJ0OyB9XG4gICAgZ2V0IGJyYWNrZXRQYWlycygpIHsgcmV0dXJuIHRoaXMuX2JyYWNrZXRQYWlyczsgfVxuICAgIGdldCBndWlkZXMoKSB7IHJldHVybiB0aGlzLl9ndWlkZXNUZXh0TW9kZWxQYXJ0OyB9XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBsYW5ndWFnZUlkT3JTZWxlY3Rpb24sIGNyZWF0aW9uT3B0aW9ucywgYXNzb2NpYXRlZFJlc291cmNlID0gbnVsbCwgX3VuZG9SZWRvU2VydmljZSwgX2xhbmd1YWdlU2VydmljZSwgX2xhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UsIGluc3RhbnRpYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3VuZG9SZWRvU2VydmljZSA9IF91bmRvUmVkb1NlcnZpY2U7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlU2VydmljZSA9IF9sYW5ndWFnZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UgPSBfbGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0aW9uU2VydmljZSA9IGluc3RhbnRpYXRpb25TZXJ2aWNlO1xuICAgICAgICAvLyNyZWdpb24gRXZlbnRzXG4gICAgICAgIHRoaXMuX29uV2lsbERpc3Bvc2UgPSB0aGlzLl9yZWdpc3RlcihuZXcgRW1pdHRlcigpKTtcbiAgICAgICAgdGhpcy5vbldpbGxEaXNwb3NlID0gdGhpcy5fb25XaWxsRGlzcG9zZS5ldmVudDtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucyA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBEaWRDaGFuZ2VEZWNvcmF0aW9uc0VtaXR0ZXIoYWZmZWN0ZWRJbmplY3RlZFRleHRMaW5lcyA9PiB0aGlzLmhhbmRsZUJlZm9yZUZpcmVEZWNvcmF0aW9uc0NoYW5nZWRFdmVudChhZmZlY3RlZEluamVjdGVkVGV4dExpbmVzKSkpO1xuICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlRGVjb3JhdGlvbnMgPSB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLmV2ZW50O1xuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZU9wdGlvbnMgPSB0aGlzLl9yZWdpc3RlcihuZXcgRW1pdHRlcigpKTtcbiAgICAgICAgdGhpcy5vbkRpZENoYW5nZU9wdGlvbnMgPSB0aGlzLl9vbkRpZENoYW5nZU9wdGlvbnMuZXZlbnQ7XG4gICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlQXR0YWNoZWQgPSB0aGlzLl9yZWdpc3RlcihuZXcgRW1pdHRlcigpKTtcbiAgICAgICAgdGhpcy5vbkRpZENoYW5nZUF0dGFjaGVkID0gdGhpcy5fb25EaWRDaGFuZ2VBdHRhY2hlZC5ldmVudDtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VJbmplY3RlZFRleHQgPSB0aGlzLl9yZWdpc3RlcihuZXcgRW1pdHRlcigpKTtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyID0gdGhpcy5fcmVnaXN0ZXIobmV3IERpZENoYW5nZUNvbnRlbnRFbWl0dGVyKCkpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZVNlbGVjdGlvbkxpc3RlbmVyID0gdGhpcy5fcmVnaXN0ZXIobmV3IE11dGFibGVEaXNwb3NhYmxlKCkpO1xuICAgICAgICB0aGlzLl9kZWx0YURlY29yYXRpb25DYWxsQ250ID0gMDtcbiAgICAgICAgdGhpcy5fYXR0YWNoZWRWaWV3cyA9IG5ldyBBdHRhY2hlZFZpZXdzKCk7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IHVuaXF1ZSBtb2RlbCBpZFxuICAgICAgICBNT0RFTF9JRCsrO1xuICAgICAgICB0aGlzLmlkID0gJyRtb2RlbCcgKyBNT0RFTF9JRDtcbiAgICAgICAgdGhpcy5pc0ZvclNpbXBsZVdpZGdldCA9IGNyZWF0aW9uT3B0aW9ucy5pc0ZvclNpbXBsZVdpZGdldDtcbiAgICAgICAgaWYgKHR5cGVvZiBhc3NvY2lhdGVkUmVzb3VyY2UgPT09ICd1bmRlZmluZWQnIHx8IGFzc29jaWF0ZWRSZXNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fYXNzb2NpYXRlZFJlc291cmNlID0gVVJJLnBhcnNlKCdpbm1lbW9yeTovL21vZGVsLycgKyBNT0RFTF9JRCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hc3NvY2lhdGVkUmVzb3VyY2UgPSBhc3NvY2lhdGVkUmVzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRFZGl0b3JDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IHsgdGV4dEJ1ZmZlciwgZGlzcG9zYWJsZSB9ID0gY3JlYXRlVGV4dEJ1ZmZlcihzb3VyY2UsIGNyZWF0aW9uT3B0aW9ucy5kZWZhdWx0RU9MKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gdGV4dEJ1ZmZlcjtcbiAgICAgICAgdGhpcy5fYnVmZmVyRGlzcG9zYWJsZSA9IGRpc3Bvc2FibGU7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBUZXh0TW9kZWxfMS5yZXNvbHZlT3B0aW9ucyh0aGlzLl9idWZmZXIsIGNyZWF0aW9uT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGxhbmd1YWdlSWQgPSAodHlwZW9mIGxhbmd1YWdlSWRPclNlbGVjdGlvbiA9PT0gJ3N0cmluZycgPyBsYW5ndWFnZUlkT3JTZWxlY3Rpb24gOiBsYW5ndWFnZUlkT3JTZWxlY3Rpb24ubGFuZ3VhZ2VJZCk7XG4gICAgICAgIGlmICh0eXBlb2YgbGFuZ3VhZ2VJZE9yU2VsZWN0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fbGFuZ3VhZ2VTZWxlY3Rpb25MaXN0ZW5lci52YWx1ZSA9IGxhbmd1YWdlSWRPclNlbGVjdGlvbi5vbkRpZENoYW5nZSgoKSA9PiB0aGlzLl9zZXRMYW5ndWFnZShsYW5ndWFnZUlkT3JTZWxlY3Rpb24ubGFuZ3VhZ2VJZCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JyYWNrZXRQYWlycyA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBCcmFja2V0UGFpcnNUZXh0TW9kZWxQYXJ0KHRoaXMsIHRoaXMuX2xhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UpKTtcbiAgICAgICAgdGhpcy5fZ3VpZGVzVGV4dE1vZGVsUGFydCA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBHdWlkZXNUZXh0TW9kZWxQYXJ0KHRoaXMsIHRoaXMuX2xhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UpKTtcbiAgICAgICAgdGhpcy5fZGVjb3JhdGlvblByb3ZpZGVyID0gdGhpcy5fcmVnaXN0ZXIobmV3IENvbG9yaXplZEJyYWNrZXRQYWlyc0RlY29yYXRpb25Qcm92aWRlcih0aGlzKSk7XG4gICAgICAgIHRoaXMuX3Rva2VuaXphdGlvblRleHRNb2RlbFBhcnQgPSB0aGlzLmluc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKFRva2VuaXphdGlvblRleHRNb2RlbFBhcnQsIHRoaXMsIHRoaXMuX2JyYWNrZXRQYWlycywgbGFuZ3VhZ2VJZCwgdGhpcy5fYXR0YWNoZWRWaWV3cyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlckxpbmVDb3VudCA9IHRoaXMuX2J1ZmZlci5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyVGV4dExlbmd0aCA9IHRoaXMuX2J1ZmZlci5nZXRWYWx1ZUxlbmd0aEluUmFuZ2UobmV3IFJhbmdlKDEsIDEsIGJ1ZmZlckxpbmVDb3VudCwgdGhpcy5fYnVmZmVyLmdldExpbmVMZW5ndGgoYnVmZmVyTGluZUNvdW50KSArIDEpLCAwIC8qIG1vZGVsLkVuZE9mTGluZVByZWZlcmVuY2UuVGV4dERlZmluZWQgKi8pO1xuICAgICAgICAvLyAhISEgTWFrZSBhIGRlY2lzaW9uIGluIHRoZSBjdG9yIGFuZCBwZXJtYW5lbnRseSByZXNwZWN0IHRoaXMgZGVjaXNpb24gISEhXG4gICAgICAgIC8vIElmIGEgbW9kZWwgaXMgdG9vIGxhcmdlIGF0IGNvbnN0cnVjdGlvbiB0aW1lLCBpdCB3aWxsIG5ldmVyIGdldCB0b2tlbml6ZWQsXG4gICAgICAgIC8vIHVuZGVyIG5vIGNpcmN1bXN0YW5jZXMuXG4gICAgICAgIGlmIChjcmVhdGlvbk9wdGlvbnMubGFyZ2VGaWxlT3B0aW1pemF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5faXNUb29MYXJnZUZvclRva2VuaXphdGlvbiA9ICgoYnVmZmVyVGV4dExlbmd0aCA+IFRleHRNb2RlbF8xLkxBUkdFX0ZJTEVfU0laRV9USFJFU0hPTEQpXG4gICAgICAgICAgICAgICAgfHwgKGJ1ZmZlckxpbmVDb3VudCA+IFRleHRNb2RlbF8xLkxBUkdFX0ZJTEVfTElORV9DT1VOVF9USFJFU0hPTEQpKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVG9vTGFyZ2VGb3JIZWFwT3BlcmF0aW9uID0gYnVmZmVyVGV4dExlbmd0aCA+IFRleHRNb2RlbF8xLkxBUkdFX0ZJTEVfSEVBUF9PUEVSQVRJT05fVEhSRVNIT0xEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNUb29MYXJnZUZvclRva2VuaXphdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNUb29MYXJnZUZvckhlYXBPcGVyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1Rvb0xhcmdlRm9yU3luY2luZyA9IChidWZmZXJUZXh0TGVuZ3RoID4gVGV4dE1vZGVsXzEuX01PREVMX1NZTkNfTElNSVQpO1xuICAgICAgICB0aGlzLl92ZXJzaW9uSWQgPSAxO1xuICAgICAgICB0aGlzLl9hbHRlcm5hdGl2ZVZlcnNpb25JZCA9IDE7XG4gICAgICAgIHRoaXMuX2luaXRpYWxVbmRvUmVkb1NuYXBzaG90ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9faXNEaXNwb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VJZCA9IHN0cmluZ3Muc2luZ2xlTGV0dGVySGFzaChNT0RFTF9JRCk7XG4gICAgICAgIHRoaXMuX2xhc3REZWNvcmF0aW9uSWQgPSAwO1xuICAgICAgICB0aGlzLl9kZWNvcmF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2RlY29yYXRpb25zVHJlZSA9IG5ldyBEZWNvcmF0aW9uc1RyZWVzKCk7XG4gICAgICAgIHRoaXMuX2NvbW1hbmRNYW5hZ2VyID0gbmV3IEVkaXRTdGFjayh0aGlzLCB0aGlzLl91bmRvUmVkb1NlcnZpY2UpO1xuICAgICAgICB0aGlzLl9pc1VuZG9pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZWRvaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyaW1BdXRvV2hpdGVzcGFjZUxpbmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXIodGhpcy5fZGVjb3JhdGlvblByb3ZpZGVyLm9uRGlkQ2hhbmdlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlRGVjb3JhdGlvbnMuYmVnaW5EZWZlcnJlZEVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlRGVjb3JhdGlvbnMuZmlyZSgpO1xuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5lbmREZWZlcnJlZEVtaXQoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZVNlcnZpY2UucmVxdWVzdFJpY2hMYW5ndWFnZUZlYXR1cmVzKGxhbmd1YWdlSWQpO1xuICAgICAgICB0aGlzLl9yZWdpc3Rlcih0aGlzLl9sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlLm9uRGlkQ2hhbmdlKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYnJhY2tldFBhaXJzLmhhbmRsZUxhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2VDaGFuZ2UoZSk7XG4gICAgICAgICAgICB0aGlzLl90b2tlbml6YXRpb25UZXh0TW9kZWxQYXJ0LmhhbmRsZUxhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2VDaGFuZ2UoZSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5fX2lzRGlzcG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb25XaWxsRGlzcG9zZS5maXJlKCk7XG4gICAgICAgIHRoaXMuX3Rva2VuaXphdGlvblRleHRNb2RlbFBhcnQuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9idWZmZXJEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fX2lzRGlzcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIE1hbnVhbGx5IHJlbGVhc2UgcmVmZXJlbmNlIHRvIHByZXZpb3VzIHRleHQgYnVmZmVyIHRvIGF2b2lkIGxhcmdlIGxlYWtzXG4gICAgICAgIC8vIGluIGNhc2Ugc29tZW9uZSBsZWFrcyBhIFRleHRNb2RlbCByZWZlcmVuY2VcbiAgICAgICAgY29uc3QgZW1wdHlEaXNwb3NlZFRleHRCdWZmZXIgPSBuZXcgUGllY2VUcmVlVGV4dEJ1ZmZlcihbXSwgJycsICdcXG4nLCBmYWxzZSwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICBlbXB0eURpc3Bvc2VkVGV4dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IGVtcHR5RGlzcG9zZWRUZXh0QnVmZmVyO1xuICAgICAgICB0aGlzLl9idWZmZXJEaXNwb3NhYmxlID0gRGlzcG9zYWJsZS5Ob25lO1xuICAgIH1cbiAgICBfYXNzZXJ0Tm90RGlzcG9zZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKCdNb2RlbCBpcyBkaXNwb3NlZCEnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW1pdENvbnRlbnRDaGFuZ2VkRXZlbnQocmF3Q2hhbmdlLCBjaGFuZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX19pc0Rpc3Bvc2luZykge1xuICAgICAgICAgICAgLy8gRG8gbm90IGNvbmZ1c2UgbGlzdGVuZXJzIGJ5IGVtaXR0aW5nIGFueSBldmVudCBhZnRlciBkaXNwb3NpbmdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90b2tlbml6YXRpb25UZXh0TW9kZWxQYXJ0LmhhbmRsZURpZENoYW5nZUNvbnRlbnQoY2hhbmdlKTtcbiAgICAgICAgdGhpcy5fYnJhY2tldFBhaXJzLmhhbmRsZURpZENoYW5nZUNvbnRlbnQoY2hhbmdlKTtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmZpcmUobmV3IEludGVybmFsTW9kZWxDb250ZW50Q2hhbmdlRXZlbnQocmF3Q2hhbmdlLCBjaGFuZ2UpKTtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWxBcmd1bWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdGV4dEJ1ZmZlciwgZGlzcG9zYWJsZSB9ID0gY3JlYXRlVGV4dEJ1ZmZlcih2YWx1ZSwgdGhpcy5fb3B0aW9ucy5kZWZhdWx0RU9MKTtcbiAgICAgICAgdGhpcy5fc2V0VmFsdWVGcm9tVGV4dEJ1ZmZlcih0ZXh0QnVmZmVyLCBkaXNwb3NhYmxlKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNvbnRlbnRDaGFuZ2VkMihyYW5nZSwgcmFuZ2VPZmZzZXQsIHJhbmdlTGVuZ3RoLCB0ZXh0LCBpc1VuZG9pbmcsIGlzUmVkb2luZywgaXNGbHVzaCwgaXNFb2xDaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VPZmZzZXQ6IHJhbmdlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICByYW5nZUxlbmd0aDogcmFuZ2VMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBlb2w6IHRoaXMuX2J1ZmZlci5nZXRFT0woKSxcbiAgICAgICAgICAgIGlzRW9sQ2hhbmdlOiBpc0VvbENoYW5nZSxcbiAgICAgICAgICAgIHZlcnNpb25JZDogdGhpcy5nZXRWZXJzaW9uSWQoKSxcbiAgICAgICAgICAgIGlzVW5kb2luZzogaXNVbmRvaW5nLFxuICAgICAgICAgICAgaXNSZWRvaW5nOiBpc1JlZG9pbmcsXG4gICAgICAgICAgICBpc0ZsdXNoOiBpc0ZsdXNoXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9zZXRWYWx1ZUZyb21UZXh0QnVmZmVyKHRleHRCdWZmZXIsIHRleHRCdWZmZXJEaXNwb3NhYmxlKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgICAgIGNvbnN0IG9sZEZ1bGxNb2RlbFJhbmdlID0gdGhpcy5nZXRGdWxsTW9kZWxSYW5nZSgpO1xuICAgICAgICBjb25zdCBvbGRNb2RlbFZhbHVlTGVuZ3RoID0gdGhpcy5nZXRWYWx1ZUxlbmd0aEluUmFuZ2Uob2xkRnVsbE1vZGVsUmFuZ2UpO1xuICAgICAgICBjb25zdCBlbmRMaW5lTnVtYmVyID0gdGhpcy5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgY29uc3QgZW5kQ29sdW1uID0gdGhpcy5nZXRMaW5lTWF4Q29sdW1uKGVuZExpbmVOdW1iZXIpO1xuICAgICAgICB0aGlzLl9idWZmZXIgPSB0ZXh0QnVmZmVyO1xuICAgICAgICB0aGlzLl9idWZmZXJEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyRGlzcG9zYWJsZSA9IHRleHRCdWZmZXJEaXNwb3NhYmxlO1xuICAgICAgICB0aGlzLl9pbmNyZWFzZVZlcnNpb25JZCgpO1xuICAgICAgICAvLyBEZXN0cm95IGFsbCBteSBkZWNvcmF0aW9uc1xuICAgICAgICB0aGlzLl9kZWNvcmF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2RlY29yYXRpb25zVHJlZSA9IG5ldyBEZWNvcmF0aW9uc1RyZWVzKCk7XG4gICAgICAgIC8vIERlc3Ryb3kgbXkgZWRpdCBoaXN0b3J5IGFuZCBzZXR0aW5nc1xuICAgICAgICB0aGlzLl9jb21tYW5kTWFuYWdlci5jbGVhcigpO1xuICAgICAgICB0aGlzLl90cmltQXV0b1doaXRlc3BhY2VMaW5lcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2VtaXRDb250ZW50Q2hhbmdlZEV2ZW50KG5ldyBNb2RlbFJhd0NvbnRlbnRDaGFuZ2VkRXZlbnQoW1xuICAgICAgICAgICAgbmV3IE1vZGVsUmF3Rmx1c2goKVxuICAgICAgICBdLCB0aGlzLl92ZXJzaW9uSWQsIGZhbHNlLCBmYWxzZSksIHRoaXMuX2NyZWF0ZUNvbnRlbnRDaGFuZ2VkMihuZXcgUmFuZ2UoMSwgMSwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKSwgMCwgb2xkTW9kZWxWYWx1ZUxlbmd0aCwgdGhpcy5nZXRWYWx1ZSgpLCBmYWxzZSwgZmFsc2UsIHRydWUsIGZhbHNlKSk7XG4gICAgfVxuICAgIHNldEVPTChlb2wpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgY29uc3QgbmV3RU9MID0gKGVvbCA9PT0gMSAvKiBtb2RlbC5FbmRPZkxpbmVTZXF1ZW5jZS5DUkxGICovID8gJ1xcclxcbicgOiAnXFxuJyk7XG4gICAgICAgIGlmICh0aGlzLl9idWZmZXIuZ2V0RU9MKCkgPT09IG5ld0VPTCkge1xuICAgICAgICAgICAgLy8gTm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZEZ1bGxNb2RlbFJhbmdlID0gdGhpcy5nZXRGdWxsTW9kZWxSYW5nZSgpO1xuICAgICAgICBjb25zdCBvbGRNb2RlbFZhbHVlTGVuZ3RoID0gdGhpcy5nZXRWYWx1ZUxlbmd0aEluUmFuZ2Uob2xkRnVsbE1vZGVsUmFuZ2UpO1xuICAgICAgICBjb25zdCBlbmRMaW5lTnVtYmVyID0gdGhpcy5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgY29uc3QgZW5kQ29sdW1uID0gdGhpcy5nZXRMaW5lTWF4Q29sdW1uKGVuZExpbmVOdW1iZXIpO1xuICAgICAgICB0aGlzLl9vbkJlZm9yZUVPTENoYW5nZSgpO1xuICAgICAgICB0aGlzLl9idWZmZXIuc2V0RU9MKG5ld0VPTCk7XG4gICAgICAgIHRoaXMuX2luY3JlYXNlVmVyc2lvbklkKCk7XG4gICAgICAgIHRoaXMuX29uQWZ0ZXJFT0xDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5fZW1pdENvbnRlbnRDaGFuZ2VkRXZlbnQobmV3IE1vZGVsUmF3Q29udGVudENoYW5nZWRFdmVudChbXG4gICAgICAgICAgICBuZXcgTW9kZWxSYXdFT0xDaGFuZ2VkKClcbiAgICAgICAgXSwgdGhpcy5fdmVyc2lvbklkLCBmYWxzZSwgZmFsc2UpLCB0aGlzLl9jcmVhdGVDb250ZW50Q2hhbmdlZDIobmV3IFJhbmdlKDEsIDEsIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbiksIDAsIG9sZE1vZGVsVmFsdWVMZW5ndGgsIHRoaXMuZ2V0VmFsdWUoKSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgdHJ1ZSkpO1xuICAgIH1cbiAgICBfb25CZWZvcmVFT0xDaGFuZ2UoKSB7XG4gICAgICAgIC8vIEVuc3VyZSBhbGwgZGVjb3JhdGlvbnMgZ2V0IHRoZWlyIGByYW5nZWAgc2V0LlxuICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUuZW5zdXJlQWxsTm9kZXNIYXZlUmFuZ2VzKHRoaXMpO1xuICAgIH1cbiAgICBfb25BZnRlckVPTENoYW5nZSgpIHtcbiAgICAgICAgLy8gVHJhbnNmb3JtIGJhY2sgYHJhbmdlYCB0byBvZmZzZXRzXG4gICAgICAgIGNvbnN0IHZlcnNpb25JZCA9IHRoaXMuZ2V0VmVyc2lvbklkKCk7XG4gICAgICAgIGNvbnN0IGFsbERlY29yYXRpb25zID0gdGhpcy5fZGVjb3JhdGlvbnNUcmVlLmNvbGxlY3ROb2Rlc1Bvc3RPcmRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYWxsRGVjb3JhdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBhbGxEZWNvcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gbm9kZS5yYW5nZTsgLy8gdGhlIHJhbmdlIGlzIGRlZmluZWQgZHVlIHRvIGBfb25CZWZvcmVFT0xDaGFuZ2VgXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IG5vZGUuY2FjaGVkQWJzb2x1dGVTdGFydCAtIG5vZGUuc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMuX2J1ZmZlci5nZXRPZmZzZXRBdChyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMuX2J1ZmZlci5nZXRPZmZzZXRBdChyYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4pO1xuICAgICAgICAgICAgbm9kZS5jYWNoZWRBYnNvbHV0ZVN0YXJ0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICBub2RlLmNhY2hlZEFic29sdXRlRW5kID0gZW5kT2Zmc2V0O1xuICAgICAgICAgICAgbm9kZS5jYWNoZWRWZXJzaW9uSWQgPSB2ZXJzaW9uSWQ7XG4gICAgICAgICAgICBub2RlLnN0YXJ0ID0gc3RhcnRPZmZzZXQgLSBkZWx0YTtcbiAgICAgICAgICAgIG5vZGUuZW5kID0gZW5kT2Zmc2V0IC0gZGVsdGE7XG4gICAgICAgICAgICByZWNvbXB1dGVNYXhFbmQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25CZWZvcmVBdHRhY2hlZCgpIHtcbiAgICAgICAgdGhpcy5fYXR0YWNoZWRFZGl0b3JDb3VudCsrO1xuICAgICAgICBpZiAodGhpcy5fYXR0YWNoZWRFZGl0b3JDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fdG9rZW5pemF0aW9uVGV4dE1vZGVsUGFydC5oYW5kbGVEaWRDaGFuZ2VBdHRhY2hlZCgpO1xuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VBdHRhY2hlZC5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFjaGVkVmlld3MuYXR0YWNoVmlldygpO1xuICAgIH1cbiAgICBvbkJlZm9yZURldGFjaGVkKHZpZXcpIHtcbiAgICAgICAgdGhpcy5fYXR0YWNoZWRFZGl0b3JDb3VudC0tO1xuICAgICAgICBpZiAodGhpcy5fYXR0YWNoZWRFZGl0b3JDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fdG9rZW5pemF0aW9uVGV4dE1vZGVsUGFydC5oYW5kbGVEaWRDaGFuZ2VBdHRhY2hlZCgpO1xuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VBdHRhY2hlZC5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRWaWV3cy5kZXRhY2hWaWV3KHZpZXcpO1xuICAgIH1cbiAgICBpc0F0dGFjaGVkVG9FZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2hlZEVkaXRvckNvdW50ID4gMDtcbiAgICB9XG4gICAgZ2V0QXR0YWNoZWRFZGl0b3JDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFjaGVkRWRpdG9yQ291bnQ7XG4gICAgfVxuICAgIGlzVG9vTGFyZ2VGb3JTeW5jaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNUb29MYXJnZUZvclN5bmNpbmc7XG4gICAgfVxuICAgIGlzVG9vTGFyZ2VGb3JUb2tlbml6YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1Rvb0xhcmdlRm9yVG9rZW5pemF0aW9uO1xuICAgIH1cbiAgICBpc1Rvb0xhcmdlRm9ySGVhcE9wZXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVG9vTGFyZ2VGb3JIZWFwT3BlcmF0aW9uO1xuICAgIH1cbiAgICBpc0Rpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXNwb3NlZDtcbiAgICB9XG4gICAgaXNEb21pbmF0ZWRCeUxvbmdMaW5lcygpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNUb29MYXJnZUZvclRva2VuaXphdGlvbigpKSB7XG4gICAgICAgICAgICAvLyBDYW5ub3Qgd29yZCB3cmFwIGh1Z2UgZmlsZXMgYW55d2F5cywgc28gaXQgZG9lc24ndCByZWFsbHkgbWF0dGVyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNtYWxsTGluZUNoYXJDb3VudCA9IDA7XG4gICAgICAgIGxldCBsb25nTGluZUNoYXJDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMuX2J1ZmZlci5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgZm9yIChsZXQgbGluZU51bWJlciA9IDE7IGxpbmVOdW1iZXIgPD0gbGluZUNvdW50OyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSB0aGlzLl9idWZmZXIuZ2V0TGluZUxlbmd0aChsaW5lTnVtYmVyKTtcbiAgICAgICAgICAgIGlmIChsaW5lTGVuZ3RoID49IExPTkdfTElORV9CT1VOREFSWSkge1xuICAgICAgICAgICAgICAgIGxvbmdMaW5lQ2hhckNvdW50ICs9IGxpbmVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzbWFsbExpbmVDaGFyQ291bnQgKz0gbGluZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGxvbmdMaW5lQ2hhckNvdW50ID4gc21hbGxMaW5lQ2hhckNvdW50KTtcbiAgICB9XG4gICAgZ2V0IHVyaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc29jaWF0ZWRSZXNvdXJjZTtcbiAgICB9XG4gICAgLy8jcmVnaW9uIE9wdGlvbnNcbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0Rm9ybWF0dGluZ09wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWJTaXplOiB0aGlzLl9vcHRpb25zLmluZGVudFNpemUsXG4gICAgICAgICAgICBpbnNlcnRTcGFjZXM6IHRoaXMuX29wdGlvbnMuaW5zZXJ0U3BhY2VzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZU9wdGlvbnMoX25ld09wdHMpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgY29uc3QgdGFiU2l6ZSA9ICh0eXBlb2YgX25ld09wdHMudGFiU2l6ZSAhPT0gJ3VuZGVmaW5lZCcpID8gX25ld09wdHMudGFiU2l6ZSA6IHRoaXMuX29wdGlvbnMudGFiU2l6ZTtcbiAgICAgICAgY29uc3QgaW5kZW50U2l6ZSA9ICh0eXBlb2YgX25ld09wdHMuaW5kZW50U2l6ZSAhPT0gJ3VuZGVmaW5lZCcpID8gX25ld09wdHMuaW5kZW50U2l6ZSA6IHRoaXMuX29wdGlvbnMub3JpZ2luYWxJbmRlbnRTaXplO1xuICAgICAgICBjb25zdCBpbnNlcnRTcGFjZXMgPSAodHlwZW9mIF9uZXdPcHRzLmluc2VydFNwYWNlcyAhPT0gJ3VuZGVmaW5lZCcpID8gX25ld09wdHMuaW5zZXJ0U3BhY2VzIDogdGhpcy5fb3B0aW9ucy5pbnNlcnRTcGFjZXM7XG4gICAgICAgIGNvbnN0IHRyaW1BdXRvV2hpdGVzcGFjZSA9ICh0eXBlb2YgX25ld09wdHMudHJpbUF1dG9XaGl0ZXNwYWNlICE9PSAndW5kZWZpbmVkJykgPyBfbmV3T3B0cy50cmltQXV0b1doaXRlc3BhY2UgOiB0aGlzLl9vcHRpb25zLnRyaW1BdXRvV2hpdGVzcGFjZTtcbiAgICAgICAgY29uc3QgYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zID0gKHR5cGVvZiBfbmV3T3B0cy5icmFja2V0Q29sb3JpemF0aW9uT3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpID8gX25ld09wdHMuYnJhY2tldENvbG9yaXphdGlvbk9wdGlvbnMgOiB0aGlzLl9vcHRpb25zLmJyYWNrZXRQYWlyQ29sb3JpemF0aW9uT3B0aW9ucztcbiAgICAgICAgY29uc3QgbmV3T3B0cyA9IG5ldyBtb2RlbC5UZXh0TW9kZWxSZXNvbHZlZE9wdGlvbnMoe1xuICAgICAgICAgICAgdGFiU2l6ZTogdGFiU2l6ZSxcbiAgICAgICAgICAgIGluZGVudFNpemU6IGluZGVudFNpemUsXG4gICAgICAgICAgICBpbnNlcnRTcGFjZXM6IGluc2VydFNwYWNlcyxcbiAgICAgICAgICAgIGRlZmF1bHRFT0w6IHRoaXMuX29wdGlvbnMuZGVmYXVsdEVPTCxcbiAgICAgICAgICAgIHRyaW1BdXRvV2hpdGVzcGFjZTogdHJpbUF1dG9XaGl0ZXNwYWNlLFxuICAgICAgICAgICAgYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZXF1YWxzKG5ld09wdHMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZSA9IHRoaXMuX29wdGlvbnMuY3JlYXRlQ2hhbmdlRXZlbnQobmV3T3B0cyk7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBuZXdPcHRzO1xuICAgICAgICB0aGlzLl9icmFja2V0UGFpcnMuaGFuZGxlRGlkQ2hhbmdlT3B0aW9ucyhlKTtcbiAgICAgICAgdGhpcy5fZGVjb3JhdGlvblByb3ZpZGVyLmhhbmRsZURpZENoYW5nZU9wdGlvbnMoZSk7XG4gICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlT3B0aW9ucy5maXJlKGUpO1xuICAgIH1cbiAgICBkZXRlY3RJbmRlbnRhdGlvbihkZWZhdWx0SW5zZXJ0U3BhY2VzLCBkZWZhdWx0VGFiU2l6ZSkge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICBjb25zdCBndWVzc2VkSW5kZW50YXRpb24gPSBndWVzc0luZGVudGF0aW9uKHRoaXMuX2J1ZmZlciwgZGVmYXVsdFRhYlNpemUsIGRlZmF1bHRJbnNlcnRTcGFjZXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgaW5zZXJ0U3BhY2VzOiBndWVzc2VkSW5kZW50YXRpb24uaW5zZXJ0U3BhY2VzLFxuICAgICAgICAgICAgdGFiU2l6ZTogZ3Vlc3NlZEluZGVudGF0aW9uLnRhYlNpemUsXG4gICAgICAgICAgICBpbmRlbnRTaXplOiBndWVzc2VkSW5kZW50YXRpb24udGFiU2l6ZSwgLy8gVE9ET0BBbGV4OiBndWVzcyBpbmRlbnRTaXplIGluZGVwZW5kZW50IG9mIHRhYlNpemVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZUluZGVudGF0aW9uKHN0cikge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplSW5kZW50YXRpb24oc3RyLCB0aGlzLl9vcHRpb25zLmluZGVudFNpemUsIHRoaXMuX29wdGlvbnMuaW5zZXJ0U3BhY2VzKTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gICAgLy8jcmVnaW9uIFJlYWRpbmdcbiAgICBnZXRWZXJzaW9uSWQoKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uSWQ7XG4gICAgfVxuICAgIG1pZ2h0Q29udGFpblJUTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5taWdodENvbnRhaW5SVEwoKTtcbiAgICB9XG4gICAgbWlnaHRDb250YWluVW51c3VhbExpbmVUZXJtaW5hdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5taWdodENvbnRhaW5VbnVzdWFsTGluZVRlcm1pbmF0b3JzKCk7XG4gICAgfVxuICAgIHJlbW92ZVVudXN1YWxMaW5lVGVybWluYXRvcnMoc2VsZWN0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuZmluZE1hdGNoZXMoc3RyaW5ncy5VTlVTVUFMX0xJTkVfVEVSTUlOQVRPUlMuc291cmNlLCBmYWxzZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIGZhbHNlLCAxMDczNzQxODI0IC8qIENvbnN0YW50cy5NQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyLnJlc2V0TWlnaHRDb250YWluVW51c3VhbExpbmVUZXJtaW5hdG9ycygpO1xuICAgICAgICB0aGlzLnB1c2hFZGl0T3BlcmF0aW9ucyhzZWxlY3Rpb25zLCBtYXRjaGVzLm1hcChtID0+ICh7IHJhbmdlOiBtLnJhbmdlLCB0ZXh0OiBudWxsIH0pKSwgKCkgPT4gbnVsbCk7XG4gICAgfVxuICAgIG1pZ2h0Q29udGFpbk5vbkJhc2ljQVNDSUkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIubWlnaHRDb250YWluTm9uQmFzaWNBU0NJSSgpO1xuICAgIH1cbiAgICBnZXRBbHRlcm5hdGl2ZVZlcnNpb25JZCgpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsdGVybmF0aXZlVmVyc2lvbklkO1xuICAgIH1cbiAgICBnZXRJbml0aWFsVW5kb1JlZG9TbmFwc2hvdCgpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxVbmRvUmVkb1NuYXBzaG90O1xuICAgIH1cbiAgICBnZXRPZmZzZXRBdChyYXdQb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX3ZhbGlkYXRlUG9zaXRpb24ocmF3UG9zaXRpb24ubGluZU51bWJlciwgcmF3UG9zaXRpb24uY29sdW1uLCAwIC8qIFN0cmluZ09mZnNldFZhbGlkYXRpb25UeXBlLlJlbGF4ZWQgKi8pO1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldE9mZnNldEF0KHBvc2l0aW9uLmxpbmVOdW1iZXIsIHBvc2l0aW9uLmNvbHVtbik7XG4gICAgfVxuICAgIGdldFBvc2l0aW9uQXQocmF3T2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IChNYXRoLm1pbih0aGlzLl9idWZmZXIuZ2V0TGVuZ3RoKCksIE1hdGgubWF4KDAsIHJhd09mZnNldCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5nZXRQb3NpdGlvbkF0KG9mZnNldCk7XG4gICAgfVxuICAgIF9pbmNyZWFzZVZlcnNpb25JZCgpIHtcbiAgICAgICAgdGhpcy5fdmVyc2lvbklkID0gdGhpcy5fdmVyc2lvbklkICsgMTtcbiAgICAgICAgdGhpcy5fYWx0ZXJuYXRpdmVWZXJzaW9uSWQgPSB0aGlzLl92ZXJzaW9uSWQ7XG4gICAgfVxuICAgIF9vdmVyd3JpdGVWZXJzaW9uSWQodmVyc2lvbklkKSB7XG4gICAgICAgIHRoaXMuX3ZlcnNpb25JZCA9IHZlcnNpb25JZDtcbiAgICB9XG4gICAgX292ZXJ3cml0ZUFsdGVybmF0aXZlVmVyc2lvbklkKG5ld0FsdGVybmF0aXZlVmVyc2lvbklkKSB7XG4gICAgICAgIHRoaXMuX2FsdGVybmF0aXZlVmVyc2lvbklkID0gbmV3QWx0ZXJuYXRpdmVWZXJzaW9uSWQ7XG4gICAgfVxuICAgIF9vdmVyd3JpdGVJbml0aWFsVW5kb1JlZG9TbmFwc2hvdChuZXdJbml0aWFsVW5kb1JlZG9TbmFwc2hvdCkge1xuICAgICAgICB0aGlzLl9pbml0aWFsVW5kb1JlZG9TbmFwc2hvdCA9IG5ld0luaXRpYWxVbmRvUmVkb1NuYXBzaG90O1xuICAgIH1cbiAgICBnZXRWYWx1ZShlb2wsIHByZXNlcnZlQk9NID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNUb29MYXJnZUZvckhlYXBPcGVyYXRpb24oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcignT3BlcmF0aW9uIHdvdWxkIGV4Y2VlZCBoZWFwIG1lbW9yeSBsaW1pdHMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdWxsTW9kZWxSYW5nZSA9IHRoaXMuZ2V0RnVsbE1vZGVsUmFuZ2UoKTtcbiAgICAgICAgY29uc3QgZnVsbE1vZGVsVmFsdWUgPSB0aGlzLmdldFZhbHVlSW5SYW5nZShmdWxsTW9kZWxSYW5nZSwgZW9sKTtcbiAgICAgICAgaWYgKHByZXNlcnZlQk9NKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldEJPTSgpICsgZnVsbE1vZGVsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bGxNb2RlbFZhbHVlO1xuICAgIH1cbiAgICBjcmVhdGVTbmFwc2hvdChwcmVzZXJ2ZUJPTSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE1vZGVsU25hcHNob3QodGhpcy5fYnVmZmVyLmNyZWF0ZVNuYXBzaG90KHByZXNlcnZlQk9NKSk7XG4gICAgfVxuICAgIGdldFZhbHVlTGVuZ3RoKGVvbCwgcHJlc2VydmVCT00gPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICBjb25zdCBmdWxsTW9kZWxSYW5nZSA9IHRoaXMuZ2V0RnVsbE1vZGVsUmFuZ2UoKTtcbiAgICAgICAgY29uc3QgZnVsbE1vZGVsVmFsdWUgPSB0aGlzLmdldFZhbHVlTGVuZ3RoSW5SYW5nZShmdWxsTW9kZWxSYW5nZSwgZW9sKTtcbiAgICAgICAgaWYgKHByZXNlcnZlQk9NKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldEJPTSgpLmxlbmd0aCArIGZ1bGxNb2RlbFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsTW9kZWxWYWx1ZTtcbiAgICB9XG4gICAgZ2V0VmFsdWVJblJhbmdlKHJhd1JhbmdlLCBlb2wgPSAwIC8qIG1vZGVsLkVuZE9mTGluZVByZWZlcmVuY2UuVGV4dERlZmluZWQgKi8pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5nZXRWYWx1ZUluUmFuZ2UodGhpcy52YWxpZGF0ZVJhbmdlKHJhd1JhbmdlKSwgZW9sKTtcbiAgICB9XG4gICAgZ2V0VmFsdWVMZW5ndGhJblJhbmdlKHJhd1JhbmdlLCBlb2wgPSAwIC8qIG1vZGVsLkVuZE9mTGluZVByZWZlcmVuY2UuVGV4dERlZmluZWQgKi8pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5nZXRWYWx1ZUxlbmd0aEluUmFuZ2UodGhpcy52YWxpZGF0ZVJhbmdlKHJhd1JhbmdlKSwgZW9sKTtcbiAgICB9XG4gICAgZ2V0Q2hhcmFjdGVyQ291bnRJblJhbmdlKHJhd1JhbmdlLCBlb2wgPSAwIC8qIG1vZGVsLkVuZE9mTGluZVByZWZlcmVuY2UuVGV4dERlZmluZWQgKi8pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5nZXRDaGFyYWN0ZXJDb3VudEluUmFuZ2UodGhpcy52YWxpZGF0ZVJhbmdlKHJhd1JhbmdlKSwgZW9sKTtcbiAgICB9XG4gICAgZ2V0TGluZUNvdW50KCkge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldExpbmVDb3VudCgpO1xuICAgIH1cbiAgICBnZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgICAgIGlmIChsaW5lTnVtYmVyIDwgMSB8fCBsaW5lTnVtYmVyID4gdGhpcy5nZXRMaW5lQ291bnQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcignSWxsZWdhbCB2YWx1ZSBmb3IgbGluZU51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcik7XG4gICAgfVxuICAgIGdldExpbmVMZW5ndGgobGluZU51bWJlcikge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICBpZiAobGluZU51bWJlciA8IDEgfHwgbGluZU51bWJlciA+IHRoaXMuZ2V0TGluZUNvdW50KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ0lsbGVnYWwgdmFsdWUgZm9yIGxpbmVOdW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldExpbmVMZW5ndGgobGluZU51bWJlcik7XG4gICAgfVxuICAgIGdldExpbmVzQ29udGVudCgpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNUb29MYXJnZUZvckhlYXBPcGVyYXRpb24oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcignT3BlcmF0aW9uIHdvdWxkIGV4Y2VlZCBoZWFwIG1lbW9yeSBsaW1pdHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldExpbmVzQ29udGVudCgpO1xuICAgIH1cbiAgICBnZXRFT0woKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuZ2V0RU9MKCk7XG4gICAgfVxuICAgIGdldEVuZE9mTGluZVNlcXVlbmNlKCkge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2J1ZmZlci5nZXRFT0woKSA9PT0gJ1xcbidcbiAgICAgICAgICAgID8gMCAvKiBtb2RlbC5FbmRPZkxpbmVTZXF1ZW5jZS5MRiAqL1xuICAgICAgICAgICAgOiAxIC8qIG1vZGVsLkVuZE9mTGluZVNlcXVlbmNlLkNSTEYgKi8pO1xuICAgIH1cbiAgICBnZXRMaW5lTWluQ29sdW1uKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGdldExpbmVNYXhDb2x1bW4obGluZU51bWJlcikge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICBpZiAobGluZU51bWJlciA8IDEgfHwgbGluZU51bWJlciA+IHRoaXMuZ2V0TGluZUNvdW50KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ0lsbGVnYWwgdmFsdWUgZm9yIGxpbmVOdW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldExpbmVMZW5ndGgobGluZU51bWJlcikgKyAxO1xuICAgIH1cbiAgICBnZXRMaW5lRmlyc3ROb25XaGl0ZXNwYWNlQ29sdW1uKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKGxpbmVOdW1iZXIgPCAxIHx8IGxpbmVOdW1iZXIgPiB0aGlzLmdldExpbmVDb3VudCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKCdJbGxlZ2FsIHZhbHVlIGZvciBsaW5lTnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5nZXRMaW5lRmlyc3ROb25XaGl0ZXNwYWNlQ29sdW1uKGxpbmVOdW1iZXIpO1xuICAgIH1cbiAgICBnZXRMaW5lTGFzdE5vbldoaXRlc3BhY2VDb2x1bW4obGluZU51bWJlcikge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICBpZiAobGluZU51bWJlciA8IDEgfHwgbGluZU51bWJlciA+IHRoaXMuZ2V0TGluZUNvdW50KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ0lsbGVnYWwgdmFsdWUgZm9yIGxpbmVOdW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldExpbmVMYXN0Tm9uV2hpdGVzcGFjZUNvbHVtbihsaW5lTnVtYmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGByYW5nZWAgaXMgd2l0aGluIGJ1ZmZlciBib3VuZHMsIGJ1dCBhbGxvd3MgaXQgdG8gc2l0IGluIGJldHdlZW4gc3Vycm9nYXRlIHBhaXJzLCBldGMuXG4gICAgICogV2lsbCB0cnkgdG8gbm90IGFsbG9jYXRlIGlmIHBvc3NpYmxlLlxuICAgICAqL1xuICAgIF92YWxpZGF0ZVJhbmdlUmVsYXhlZE5vQWxsb2NhdGlvbnMocmFuZ2UpIHtcbiAgICAgICAgY29uc3QgbGluZXNDb3VudCA9IHRoaXMuX2J1ZmZlci5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbFN0YXJ0TGluZU51bWJlciA9IHJhbmdlLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgY29uc3QgaW5pdGlhbFN0YXJ0Q29sdW1uID0gcmFuZ2Uuc3RhcnRDb2x1bW47XG4gICAgICAgIGxldCBzdGFydExpbmVOdW1iZXIgPSBNYXRoLmZsb29yKCh0eXBlb2YgaW5pdGlhbFN0YXJ0TGluZU51bWJlciA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGluaXRpYWxTdGFydExpbmVOdW1iZXIpKSA/IGluaXRpYWxTdGFydExpbmVOdW1iZXIgOiAxKTtcbiAgICAgICAgbGV0IHN0YXJ0Q29sdW1uID0gTWF0aC5mbG9vcigodHlwZW9mIGluaXRpYWxTdGFydENvbHVtbiA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGluaXRpYWxTdGFydENvbHVtbikpID8gaW5pdGlhbFN0YXJ0Q29sdW1uIDogMSk7XG4gICAgICAgIGlmIChzdGFydExpbmVOdW1iZXIgPCAxKSB7XG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSAxO1xuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0TGluZU51bWJlciA+IGxpbmVzQ291bnQpIHtcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlciA9IGxpbmVzQ291bnQ7XG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IHRoaXMuZ2V0TGluZU1heENvbHVtbihzdGFydExpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXJ0Q29sdW1uIDw9IDEpIHtcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhDb2x1bW4gPSB0aGlzLmdldExpbmVNYXhDb2x1bW4oc3RhcnRMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb2x1bW4gPj0gbWF4Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gbWF4Q29sdW1uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0aWFsRW5kTGluZU51bWJlciA9IHJhbmdlLmVuZExpbmVOdW1iZXI7XG4gICAgICAgIGNvbnN0IGluaXRpYWxFbmRDb2x1bW4gPSByYW5nZS5lbmRDb2x1bW47XG4gICAgICAgIGxldCBlbmRMaW5lTnVtYmVyID0gTWF0aC5mbG9vcigodHlwZW9mIGluaXRpYWxFbmRMaW5lTnVtYmVyID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oaW5pdGlhbEVuZExpbmVOdW1iZXIpKSA/IGluaXRpYWxFbmRMaW5lTnVtYmVyIDogMSk7XG4gICAgICAgIGxldCBlbmRDb2x1bW4gPSBNYXRoLmZsb29yKCh0eXBlb2YgaW5pdGlhbEVuZENvbHVtbiA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGluaXRpYWxFbmRDb2x1bW4pKSA/IGluaXRpYWxFbmRDb2x1bW4gOiAxKTtcbiAgICAgICAgaWYgKGVuZExpbmVOdW1iZXIgPCAxKSB7XG4gICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gMTtcbiAgICAgICAgICAgIGVuZENvbHVtbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5kTGluZU51bWJlciA+IGxpbmVzQ291bnQpIHtcbiAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBsaW5lc0NvdW50O1xuICAgICAgICAgICAgZW5kQ29sdW1uID0gdGhpcy5nZXRMaW5lTWF4Q29sdW1uKGVuZExpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVuZENvbHVtbiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heENvbHVtbiA9IHRoaXMuZ2V0TGluZU1heENvbHVtbihlbmRMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQ29sdW1uID49IG1heENvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICBlbmRDb2x1bW4gPSBtYXhDb2x1bW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsU3RhcnRMaW5lTnVtYmVyID09PSBzdGFydExpbmVOdW1iZXJcbiAgICAgICAgICAgICYmIGluaXRpYWxTdGFydENvbHVtbiA9PT0gc3RhcnRDb2x1bW5cbiAgICAgICAgICAgICYmIGluaXRpYWxFbmRMaW5lTnVtYmVyID09PSBlbmRMaW5lTnVtYmVyXG4gICAgICAgICAgICAmJiBpbml0aWFsRW5kQ29sdW1uID09PSBlbmRDb2x1bW5cbiAgICAgICAgICAgICYmIHJhbmdlIGluc3RhbmNlb2YgUmFuZ2VcbiAgICAgICAgICAgICYmICEocmFuZ2UgaW5zdGFuY2VvZiBTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pO1xuICAgIH1cbiAgICBfaXNWYWxpZFBvc2l0aW9uKGxpbmVOdW1iZXIsIGNvbHVtbiwgdmFsaWRhdGlvblR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaW5lTnVtYmVyICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29sdW1uICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTihsaW5lTnVtYmVyKSB8fCBpc05hTihjb2x1bW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVOdW1iZXIgPCAxIHx8IGNvbHVtbiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGxpbmVOdW1iZXIgfCAwKSAhPT0gbGluZU51bWJlciB8fCAoY29sdW1uIHwgMCkgIT09IGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMuX2J1ZmZlci5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgaWYgKGxpbmVOdW1iZXIgPiBsaW5lQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhDb2x1bW4gPSB0aGlzLmdldExpbmVNYXhDb2x1bW4obGluZU51bWJlcik7XG4gICAgICAgIGlmIChjb2x1bW4gPiBtYXhDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRhdGlvblR5cGUgPT09IDEgLyogU3RyaW5nT2Zmc2V0VmFsaWRhdGlvblR5cGUuU3Vycm9nYXRlUGFpcnMgKi8pIHtcbiAgICAgICAgICAgIC8vICEhQXQgdGhpcyBwb2ludCwgY29sdW1uID4gMVxuICAgICAgICAgICAgY29uc3QgY2hhckNvZGVCZWZvcmUgPSB0aGlzLl9idWZmZXIuZ2V0TGluZUNoYXJDb2RlKGxpbmVOdW1iZXIsIGNvbHVtbiAtIDIpO1xuICAgICAgICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlQmVmb3JlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX3ZhbGlkYXRlUG9zaXRpb24oX2xpbmVOdW1iZXIsIF9jb2x1bW4sIHZhbGlkYXRpb25UeXBlKSB7XG4gICAgICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBNYXRoLmZsb29yKCh0eXBlb2YgX2xpbmVOdW1iZXIgPT09ICdudW1iZXInICYmICFpc05hTihfbGluZU51bWJlcikpID8gX2xpbmVOdW1iZXIgOiAxKTtcbiAgICAgICAgY29uc3QgY29sdW1uID0gTWF0aC5mbG9vcigodHlwZW9mIF9jb2x1bW4gPT09ICdudW1iZXInICYmICFpc05hTihfY29sdW1uKSkgPyBfY29sdW1uIDogMSk7XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMuX2J1ZmZlci5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgaWYgKGxpbmVOdW1iZXIgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lTnVtYmVyID4gbGluZUNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmVDb3VudCwgdGhpcy5nZXRMaW5lTWF4Q29sdW1uKGxpbmVDb3VudCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4gPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lTnVtYmVyLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhDb2x1bW4gPSB0aGlzLmdldExpbmVNYXhDb2x1bW4obGluZU51bWJlcik7XG4gICAgICAgIGlmIChjb2x1bW4gPj0gbWF4Q29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmVOdW1iZXIsIG1heENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkYXRpb25UeXBlID09PSAxIC8qIFN0cmluZ09mZnNldFZhbGlkYXRpb25UeXBlLlN1cnJvZ2F0ZVBhaXJzICovKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcG9zaXRpb24gd291bGQgZW5kIHVwIGluIHRoZSBtaWRkbGUgb2YgYSBoaWdoLWxvdyBzdXJyb2dhdGUgcGFpcixcbiAgICAgICAgICAgIC8vIHdlIG1vdmUgaXQgdG8gYmVmb3JlIHRoZSBwYWlyXG4gICAgICAgICAgICAvLyAhIUF0IHRoaXMgcG9pbnQsIGNvbHVtbiA+IDFcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlQmVmb3JlID0gdGhpcy5fYnVmZmVyLmdldExpbmVDaGFyQ29kZShsaW5lTnVtYmVyLCBjb2x1bW4gLSAyKTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdzLmlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZUJlZm9yZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmVOdW1iZXIsIGNvbHVtbiAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obGluZU51bWJlciwgY29sdW1uKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uVHlwZSA9IDEgLyogU3RyaW5nT2Zmc2V0VmFsaWRhdGlvblR5cGUuU3Vycm9nYXRlUGFpcnMgKi87XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgICAgIC8vIEF2b2lkIG9iamVjdCBhbGxvY2F0aW9uIGFuZCBjb3ZlciBtb3N0IGxpa2VseSBjYXNlXG4gICAgICAgIGlmIChwb3NpdGlvbiBpbnN0YW5jZW9mIFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZFBvc2l0aW9uKHBvc2l0aW9uLmxpbmVOdW1iZXIsIHBvc2l0aW9uLmNvbHVtbiwgdmFsaWRhdGlvblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZVBvc2l0aW9uKHBvc2l0aW9uLmxpbmVOdW1iZXIsIHBvc2l0aW9uLmNvbHVtbiwgdmFsaWRhdGlvblR5cGUpO1xuICAgIH1cbiAgICBfaXNWYWxpZFJhbmdlKHJhbmdlLCB2YWxpZGF0aW9uVHlwZSkge1xuICAgICAgICBjb25zdCBzdGFydExpbmVOdW1iZXIgPSByYW5nZS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29sdW1uID0gcmFuZ2Uuc3RhcnRDb2x1bW47XG4gICAgICAgIGNvbnN0IGVuZExpbmVOdW1iZXIgPSByYW5nZS5lbmRMaW5lTnVtYmVyO1xuICAgICAgICBjb25zdCBlbmRDb2x1bW4gPSByYW5nZS5lbmRDb2x1bW47XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZFBvc2l0aW9uKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIDAgLyogU3RyaW5nT2Zmc2V0VmFsaWRhdGlvblR5cGUuUmVsYXhlZCAqLykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRQb3NpdGlvbihlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4sIDAgLyogU3RyaW5nT2Zmc2V0VmFsaWRhdGlvblR5cGUuUmVsYXhlZCAqLykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRhdGlvblR5cGUgPT09IDEgLyogU3RyaW5nT2Zmc2V0VmFsaWRhdGlvblR5cGUuU3Vycm9nYXRlUGFpcnMgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlQmVmb3JlU3RhcnQgPSAoc3RhcnRDb2x1bW4gPiAxID8gdGhpcy5fYnVmZmVyLmdldExpbmVDaGFyQ29kZShzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uIC0gMikgOiAwKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlQmVmb3JlRW5kID0gKGVuZENvbHVtbiA+IDEgJiYgZW5kQ29sdW1uIDw9IHRoaXMuX2J1ZmZlci5nZXRMaW5lTGVuZ3RoKGVuZExpbmVOdW1iZXIpID8gdGhpcy5fYnVmZmVyLmdldExpbmVDaGFyQ29kZShlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4gLSAyKSA6IDApO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRJbnNpZGVTdXJyb2dhdGVQYWlyID0gc3RyaW5ncy5pc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGVCZWZvcmVTdGFydCk7XG4gICAgICAgICAgICBjb25zdCBlbmRJbnNpZGVTdXJyb2dhdGVQYWlyID0gc3RyaW5ncy5pc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGVCZWZvcmVFbmQpO1xuICAgICAgICAgICAgaWYgKCFzdGFydEluc2lkZVN1cnJvZ2F0ZVBhaXIgJiYgIWVuZEluc2lkZVN1cnJvZ2F0ZVBhaXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFsaWRhdGVSYW5nZShfcmFuZ2UpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblR5cGUgPSAxIC8qIFN0cmluZ09mZnNldFZhbGlkYXRpb25UeXBlLlN1cnJvZ2F0ZVBhaXJzICovO1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICAvLyBBdm9pZCBvYmplY3QgYWxsb2NhdGlvbiBhbmQgY292ZXIgbW9zdCBsaWtlbHkgY2FzZVxuICAgICAgICBpZiAoKF9yYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSAmJiAhKF9yYW5nZSBpbnN0YW5jZW9mIFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkUmFuZ2UoX3JhbmdlLCB2YWxpZGF0aW9uVHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbihfcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCBfcmFuZ2Uuc3RhcnRDb2x1bW4sIDAgLyogU3RyaW5nT2Zmc2V0VmFsaWRhdGlvblR5cGUuUmVsYXhlZCAqLyk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3ZhbGlkYXRlUG9zaXRpb24oX3JhbmdlLmVuZExpbmVOdW1iZXIsIF9yYW5nZS5lbmRDb2x1bW4sIDAgLyogU3RyaW5nT2Zmc2V0VmFsaWRhdGlvblR5cGUuUmVsYXhlZCAqLyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZU51bWJlciA9IHN0YXJ0LmxpbmVOdW1iZXI7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29sdW1uID0gc3RhcnQuY29sdW1uO1xuICAgICAgICBjb25zdCBlbmRMaW5lTnVtYmVyID0gZW5kLmxpbmVOdW1iZXI7XG4gICAgICAgIGNvbnN0IGVuZENvbHVtbiA9IGVuZC5jb2x1bW47XG4gICAgICAgIGlmICh2YWxpZGF0aW9uVHlwZSA9PT0gMSAvKiBTdHJpbmdPZmZzZXRWYWxpZGF0aW9uVHlwZS5TdXJyb2dhdGVQYWlycyAqLykge1xuICAgICAgICAgICAgY29uc3QgY2hhckNvZGVCZWZvcmVTdGFydCA9IChzdGFydENvbHVtbiA+IDEgPyB0aGlzLl9idWZmZXIuZ2V0TGluZUNoYXJDb2RlKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4gLSAyKSA6IDApO1xuICAgICAgICAgICAgY29uc3QgY2hhckNvZGVCZWZvcmVFbmQgPSAoZW5kQ29sdW1uID4gMSAmJiBlbmRDb2x1bW4gPD0gdGhpcy5fYnVmZmVyLmdldExpbmVMZW5ndGgoZW5kTGluZU51bWJlcikgPyB0aGlzLl9idWZmZXIuZ2V0TGluZUNoYXJDb2RlKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbiAtIDIpIDogMCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydEluc2lkZVN1cnJvZ2F0ZVBhaXIgPSBzdHJpbmdzLmlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZUJlZm9yZVN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZEluc2lkZVN1cnJvZ2F0ZVBhaXIgPSBzdHJpbmdzLmlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZUJlZm9yZUVuZCk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5zaWRlU3Vycm9nYXRlUGFpciAmJiAhZW5kSW5zaWRlU3Vycm9nYXRlUGFpcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydExpbmVOdW1iZXIgPT09IGVuZExpbmVOdW1iZXIgJiYgc3RhcnRDb2x1bW4gPT09IGVuZENvbHVtbikge1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBleHBhbmQgYSBjb2xsYXBzZWQgcmFuZ2UsIHNpbXBseSBtb3ZlIGl0IHRvIGEgdmFsaWQgbG9jYXRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4gLSAxLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4gLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEluc2lkZVN1cnJvZ2F0ZVBhaXIgJiYgZW5kSW5zaWRlU3Vycm9nYXRlUGFpcikge1xuICAgICAgICAgICAgICAgIC8vIGV4cGFuZCByYW5nZSBhdCBib3RoIGVuZHNcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4gLSAxLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4gKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEluc2lkZVN1cnJvZ2F0ZVBhaXIpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGV4cGFuZCByYW5nZSBhdCB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4gLSAxLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb25seSBleHBhbmQgcmFuZ2UgYXQgdGhlIGVuZFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4gKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XG4gICAgfVxuICAgIG1vZGlmeVBvc2l0aW9uKHJhd1Bvc2l0aW9uLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdGhpcy5nZXRPZmZzZXRBdChyYXdQb3NpdGlvbikgKyBvZmZzZXQ7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBvc2l0aW9uQXQoTWF0aC5taW4odGhpcy5fYnVmZmVyLmdldExlbmd0aCgpLCBNYXRoLm1heCgwLCBjYW5kaWRhdGUpKSk7XG4gICAgfVxuICAgIGdldEZ1bGxNb2RlbFJhbmdlKCkge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICBjb25zdCBsaW5lQ291bnQgPSB0aGlzLmdldExpbmVDb3VudCgpO1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKDEsIDEsIGxpbmVDb3VudCwgdGhpcy5nZXRMaW5lTWF4Q29sdW1uKGxpbmVDb3VudCkpO1xuICAgIH1cbiAgICBmaW5kTWF0Y2hlc0xpbmVCeUxpbmUoc2VhcmNoUmFuZ2UsIHNlYXJjaERhdGEsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuZmluZE1hdGNoZXNMaW5lQnlMaW5lKHNlYXJjaFJhbmdlLCBzZWFyY2hEYXRhLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XG4gICAgfVxuICAgIGZpbmRNYXRjaGVzKHNlYXJjaFN0cmluZywgcmF3U2VhcmNoU2NvcGUsIGlzUmVnZXgsIG1hdGNoQ2FzZSwgd29yZFNlcGFyYXRvcnMsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50ID0gTElNSVRfRklORF9DT1VOVCkge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICBsZXQgc2VhcmNoUmFuZ2VzID0gbnVsbDtcbiAgICAgICAgaWYgKHJhd1NlYXJjaFNjb3BlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmF3U2VhcmNoU2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgcmF3U2VhcmNoU2NvcGUgPSBbcmF3U2VhcmNoU2NvcGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJhd1NlYXJjaFNjb3BlLmV2ZXJ5KChzZWFyY2hTY29wZSkgPT4gUmFuZ2UuaXNJUmFuZ2Uoc2VhcmNoU2NvcGUpKSkge1xuICAgICAgICAgICAgICAgIHNlYXJjaFJhbmdlcyA9IHJhd1NlYXJjaFNjb3BlLm1hcCgoc2VhcmNoU2NvcGUpID0+IHRoaXMudmFsaWRhdGVSYW5nZShzZWFyY2hTY29wZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2hSYW5nZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHNlYXJjaFJhbmdlcyA9IFt0aGlzLmdldEZ1bGxNb2RlbFJhbmdlKCldO1xuICAgICAgICB9XG4gICAgICAgIHNlYXJjaFJhbmdlcyA9IHNlYXJjaFJhbmdlcy5zb3J0KChkMSwgZDIpID0+IGQxLnN0YXJ0TGluZU51bWJlciAtIGQyLnN0YXJ0TGluZU51bWJlciB8fCBkMS5zdGFydENvbHVtbiAtIGQyLnN0YXJ0Q29sdW1uKTtcbiAgICAgICAgY29uc3QgdW5pcXVlU2VhcmNoUmFuZ2VzID0gW107XG4gICAgICAgIHVuaXF1ZVNlYXJjaFJhbmdlcy5wdXNoKHNlYXJjaFJhbmdlcy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICAgICAgICAgIGlmIChSYW5nZS5hcmVJbnRlcnNlY3RpbmcocHJldiwgY3VycikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5wbHVzUmFuZ2UoY3Vycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmlxdWVTZWFyY2hSYW5nZXMucHVzaChwcmV2KTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyO1xuICAgICAgICB9KSk7XG4gICAgICAgIGxldCBtYXRjaE1hcHBlcjtcbiAgICAgICAgaWYgKCFpc1JlZ2V4ICYmIHNlYXJjaFN0cmluZy5pbmRleE9mKCdcXG4nKSA8IDApIHtcbiAgICAgICAgICAgIC8vIG5vdCByZWdleCwgbm90IG11bHRpIGxpbmVcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXMoc2VhcmNoU3RyaW5nLCBpc1JlZ2V4LCBtYXRjaENhc2UsIHdvcmRTZXBhcmF0b3JzKTtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBzZWFyY2hQYXJhbXMucGFyc2VTZWFyY2hSZXF1ZXN0KCk7XG4gICAgICAgICAgICBpZiAoIXNlYXJjaERhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaE1hcHBlciA9IChzZWFyY2hSYW5nZSkgPT4gdGhpcy5maW5kTWF0Y2hlc0xpbmVCeUxpbmUoc2VhcmNoUmFuZ2UsIHNlYXJjaERhdGEsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoTWFwcGVyID0gKHNlYXJjaFJhbmdlKSA9PiBUZXh0TW9kZWxTZWFyY2guZmluZE1hdGNoZXModGhpcywgbmV3IFNlYXJjaFBhcmFtcyhzZWFyY2hTdHJpbmcsIGlzUmVnZXgsIG1hdGNoQ2FzZSwgd29yZFNlcGFyYXRvcnMpLCBzZWFyY2hSYW5nZSwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmlxdWVTZWFyY2hSYW5nZXMubWFwKG1hdGNoTWFwcGVyKS5yZWR1Y2UoKGFyciwgbWF0Y2hlcykgPT4gYXJyLmNvbmNhdChtYXRjaGVzKSwgW10pO1xuICAgIH1cbiAgICBmaW5kTmV4dE1hdGNoKHNlYXJjaFN0cmluZywgcmF3U2VhcmNoU3RhcnQsIGlzUmVnZXgsIG1hdGNoQ2FzZSwgd29yZFNlcGFyYXRvcnMsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgICAgIGNvbnN0IHNlYXJjaFN0YXJ0ID0gdGhpcy52YWxpZGF0ZVBvc2l0aW9uKHJhd1NlYXJjaFN0YXJ0KTtcbiAgICAgICAgaWYgKCFpc1JlZ2V4ICYmIHNlYXJjaFN0cmluZy5pbmRleE9mKCdcXG4nKSA8IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXMoc2VhcmNoU3RyaW5nLCBpc1JlZ2V4LCBtYXRjaENhc2UsIHdvcmRTZXBhcmF0b3JzKTtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBzZWFyY2hQYXJhbXMucGFyc2VTZWFyY2hSZXF1ZXN0KCk7XG4gICAgICAgICAgICBpZiAoIXNlYXJjaERhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgICAgICBsZXQgc2VhcmNoUmFuZ2UgPSBuZXcgUmFuZ2Uoc2VhcmNoU3RhcnQubGluZU51bWJlciwgc2VhcmNoU3RhcnQuY29sdW1uLCBsaW5lQ291bnQsIHRoaXMuZ2V0TGluZU1heENvbHVtbihsaW5lQ291bnQpKTtcbiAgICAgICAgICAgIGxldCByZXQgPSB0aGlzLmZpbmRNYXRjaGVzTGluZUJ5TGluZShzZWFyY2hSYW5nZSwgc2VhcmNoRGF0YSwgY2FwdHVyZU1hdGNoZXMsIDEpO1xuICAgICAgICAgICAgVGV4dE1vZGVsU2VhcmNoLmZpbmROZXh0TWF0Y2godGhpcywgbmV3IFNlYXJjaFBhcmFtcyhzZWFyY2hTdHJpbmcsIGlzUmVnZXgsIG1hdGNoQ2FzZSwgd29yZFNlcGFyYXRvcnMpLCBzZWFyY2hTdGFydCwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICAgICAgaWYgKHJldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlYXJjaFJhbmdlID0gbmV3IFJhbmdlKDEsIDEsIHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXIsIHRoaXMuZ2V0TGluZU1heENvbHVtbihzZWFyY2hTdGFydC5saW5lTnVtYmVyKSk7XG4gICAgICAgICAgICByZXQgPSB0aGlzLmZpbmRNYXRjaGVzTGluZUJ5TGluZShzZWFyY2hSYW5nZSwgc2VhcmNoRGF0YSwgY2FwdHVyZU1hdGNoZXMsIDEpO1xuICAgICAgICAgICAgaWYgKHJldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUZXh0TW9kZWxTZWFyY2guZmluZE5leHRNYXRjaCh0aGlzLCBuZXcgU2VhcmNoUGFyYW1zKHNlYXJjaFN0cmluZywgaXNSZWdleCwgbWF0Y2hDYXNlLCB3b3JkU2VwYXJhdG9ycyksIHNlYXJjaFN0YXJ0LCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgfVxuICAgIGZpbmRQcmV2aW91c01hdGNoKHNlYXJjaFN0cmluZywgcmF3U2VhcmNoU3RhcnQsIGlzUmVnZXgsIG1hdGNoQ2FzZSwgd29yZFNlcGFyYXRvcnMsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgICAgIGNvbnN0IHNlYXJjaFN0YXJ0ID0gdGhpcy52YWxpZGF0ZVBvc2l0aW9uKHJhd1NlYXJjaFN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIFRleHRNb2RlbFNlYXJjaC5maW5kUHJldmlvdXNNYXRjaCh0aGlzLCBuZXcgU2VhcmNoUGFyYW1zKHNlYXJjaFN0cmluZywgaXNSZWdleCwgbWF0Y2hDYXNlLCB3b3JkU2VwYXJhdG9ycyksIHNlYXJjaFN0YXJ0LCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICAgIC8vI3JlZ2lvbiBFZGl0aW5nXG4gICAgcHVzaFN0YWNrRWxlbWVudCgpIHtcbiAgICAgICAgdGhpcy5fY29tbWFuZE1hbmFnZXIucHVzaFN0YWNrRWxlbWVudCgpO1xuICAgIH1cbiAgICBwb3BTdGFja0VsZW1lbnQoKSB7XG4gICAgICAgIHRoaXMuX2NvbW1hbmRNYW5hZ2VyLnBvcFN0YWNrRWxlbWVudCgpO1xuICAgIH1cbiAgICBwdXNoRU9MKGVvbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50RU9MID0gKHRoaXMuZ2V0RU9MKCkgPT09ICdcXG4nID8gMCAvKiBtb2RlbC5FbmRPZkxpbmVTZXF1ZW5jZS5MRiAqLyA6IDEgLyogbW9kZWwuRW5kT2ZMaW5lU2VxdWVuY2UuQ1JMRiAqLyk7XG4gICAgICAgIGlmIChjdXJyZW50RU9MID09PSBlb2wpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5iZWdpbkRlZmVycmVkRW1pdCgpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmJlZ2luRGVmZXJyZWRFbWl0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5pdGlhbFVuZG9SZWRvU25hcHNob3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsVW5kb1JlZG9TbmFwc2hvdCA9IHRoaXMuX3VuZG9SZWRvU2VydmljZS5jcmVhdGVTbmFwc2hvdCh0aGlzLnVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jb21tYW5kTWFuYWdlci5wdXNoRU9MKGVvbCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZW5kRGVmZXJyZWRFbWl0KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLmVuZERlZmVycmVkRW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF92YWxpZGF0ZUVkaXRPcGVyYXRpb24ocmF3T3BlcmF0aW9uKSB7XG4gICAgICAgIGlmIChyYXdPcGVyYXRpb24gaW5zdGFuY2VvZiBtb2RlbC5WYWxpZEFubm90YXRlZEVkaXRPcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiByYXdPcGVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBtb2RlbC5WYWxpZEFubm90YXRlZEVkaXRPcGVyYXRpb24ocmF3T3BlcmF0aW9uLmlkZW50aWZpZXIgfHwgbnVsbCwgdGhpcy52YWxpZGF0ZVJhbmdlKHJhd09wZXJhdGlvbi5yYW5nZSksIHJhd09wZXJhdGlvbi50ZXh0LCByYXdPcGVyYXRpb24uZm9yY2VNb3ZlTWFya2VycyB8fCBmYWxzZSwgcmF3T3BlcmF0aW9uLmlzQXV0b1doaXRlc3BhY2VFZGl0IHx8IGZhbHNlLCByYXdPcGVyYXRpb24uX2lzVHJhY2tlZCB8fCBmYWxzZSk7XG4gICAgfVxuICAgIF92YWxpZGF0ZUVkaXRPcGVyYXRpb25zKHJhd09wZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSByYXdPcGVyYXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLl92YWxpZGF0ZUVkaXRPcGVyYXRpb24ocmF3T3BlcmF0aW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcHVzaEVkaXRPcGVyYXRpb25zKGJlZm9yZUN1cnNvclN0YXRlLCBlZGl0T3BlcmF0aW9ucywgY3Vyc29yU3RhdGVDb21wdXRlciwgZ3JvdXApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlRGVjb3JhdGlvbnMuYmVnaW5EZWZlcnJlZEVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5iZWdpbkRlZmVycmVkRW1pdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hFZGl0T3BlcmF0aW9ucyhiZWZvcmVDdXJzb3JTdGF0ZSwgdGhpcy5fdmFsaWRhdGVFZGl0T3BlcmF0aW9ucyhlZGl0T3BlcmF0aW9ucyksIGN1cnNvclN0YXRlQ29tcHV0ZXIsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5lbmREZWZlcnJlZEVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlRGVjb3JhdGlvbnMuZW5kRGVmZXJyZWRFbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3B1c2hFZGl0T3BlcmF0aW9ucyhiZWZvcmVDdXJzb3JTdGF0ZSwgZWRpdE9wZXJhdGlvbnMsIGN1cnNvclN0YXRlQ29tcHV0ZXIsIGdyb3VwKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnRyaW1BdXRvV2hpdGVzcGFjZSAmJiB0aGlzLl90cmltQXV0b1doaXRlc3BhY2VMaW5lcykge1xuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBlYWNoIHNhdmVkIGxpbmUgbnVtYmVyIGFuZCBpbnNlcnQgYSB0cmltIHdoaXRlc3BhY2UgZWRpdFxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgc2FmZSB0byBkbyBzbyAobm8gY29uZmxpY3RzIHdpdGggb3RoZXIgZWRpdHMpLlxuICAgICAgICAgICAgY29uc3QgaW5jb21pbmdFZGl0cyA9IGVkaXRPcGVyYXRpb25zLm1hcCgob3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByYW5nZTogdGhpcy52YWxpZGF0ZVJhbmdlKG9wLnJhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcywgYXV0by1mb3JtYXR0ZXJzIGNoYW5nZSByYW5nZXMgYXV0b21hdGljYWxseSB3aGljaCBjYW4gY2F1c2UgdW5kZXNpcmVkIGF1dG8gd2hpdGVzcGFjZSB0cmltbWluZyBuZWFyIHRoZSBjdXJzb3JcbiAgICAgICAgICAgIC8vIFdlJ2xsIHVzZSB0aGUgZm9sbG93aW5nIGhldXJpc3RpYzogaWYgdGhlIGVkaXRzIG9jY3VyIG5lYXIgdGhlIGN1cnNvciwgdGhlbiBpdCdzIG9rIHRvIHRyaW0gYXV0byB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBsZXQgZWRpdHNBcmVOZWFyQ3Vyc29ycyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoYmVmb3JlQ3Vyc29yU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYmVmb3JlQ3Vyc29yU3RhdGUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gYmVmb3JlQ3Vyc29yU3RhdGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZEVkaXROZWFyU2VsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBsZW5KID0gaW5jb21pbmdFZGl0cy5sZW5ndGg7IGogPCBsZW5KOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRSYW5nZSA9IGluY29taW5nRWRpdHNbal0ucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxJc0Fib3ZlID0gZWRpdFJhbmdlLnN0YXJ0TGluZU51bWJlciA+IHNlbC5lbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsSXNCZWxvdyA9IHNlbC5zdGFydExpbmVOdW1iZXIgPiBlZGl0UmFuZ2UuZW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsSXNBYm92ZSAmJiAhc2VsSXNCZWxvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRWRpdE5lYXJTZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRFZGl0TmVhclNlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdHNBcmVOZWFyQ3Vyc29ycyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWRpdHNBcmVOZWFyQ3Vyc29ycykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl90cmltQXV0b1doaXRlc3BhY2VMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltTGluZU51bWJlciA9IHRoaXMuX3RyaW1BdXRvV2hpdGVzcGFjZUxpbmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhMaW5lQ29sdW1uID0gdGhpcy5nZXRMaW5lTWF4Q29sdW1uKHRyaW1MaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsbG93VHJpbUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbGVuSiA9IGluY29taW5nRWRpdHMubGVuZ3RoOyBqIDwgbGVuSjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGl0UmFuZ2UgPSBpbmNvbWluZ0VkaXRzW2pdLnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRpdFRleHQgPSBpbmNvbWluZ0VkaXRzW2pdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJpbUxpbmVOdW1iZXIgPCBlZGl0UmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIHx8IHRyaW1MaW5lTnVtYmVyID4gZWRpdFJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgdHJpbUxpbmVgIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSB0aGlzIGVkaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGVkaXRSYW5nZS5zdGFydExpbmVOdW1iZXIgPD0gdHJpbUxpbmUgPD0gZWRpdFJhbmdlLmVuZExpbmVOdW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmltTGluZU51bWJlciA9PT0gZWRpdFJhbmdlLnN0YXJ0TGluZU51bWJlciAmJiBlZGl0UmFuZ2Uuc3RhcnRDb2x1bW4gPT09IG1heExpbmVDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBlZGl0UmFuZ2UuaXNFbXB0eSgpICYmIGVkaXRUZXh0ICYmIGVkaXRUZXh0Lmxlbmd0aCA+IDAgJiYgZWRpdFRleHQuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZWRpdCBpbnNlcnRzIGEgbmV3IGxpbmUgKGFuZCBtYXliZSBvdGhlciB0ZXh0KSBhZnRlciBgdHJpbUxpbmVgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJpbUxpbmVOdW1iZXIgPT09IGVkaXRSYW5nZS5zdGFydExpbmVOdW1iZXIgJiYgZWRpdFJhbmdlLnN0YXJ0Q29sdW1uID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgZWRpdFJhbmdlLmlzRW1wdHkoKSAmJiBlZGl0VGV4dCAmJiBlZGl0VGV4dC5sZW5ndGggPiAwICYmIGVkaXRUZXh0LmNoYXJBdChlZGl0VGV4dC5sZW5ndGggLSAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGVkaXQgaW5zZXJ0cyBhIG5ldyBsaW5lIChhbmQgbWF5YmUgb3RoZXIgdGV4dCkgYmVmb3JlIGB0cmltTGluZWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb2tzIGxpa2Ugd2UgY2FuJ3QgdHJpbSB0aGlzIGxpbmUgYXMgaXQgd291bGQgaW50ZXJmZXJlIHdpdGggYW4gaW5jb21pbmcgZWRpdFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dUcmltTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG93VHJpbUxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1SYW5nZSA9IG5ldyBSYW5nZSh0cmltTGluZU51bWJlciwgMSwgdHJpbUxpbmVOdW1iZXIsIG1heExpbmVDb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdE9wZXJhdGlvbnMucHVzaChuZXcgbW9kZWwuVmFsaWRBbm5vdGF0ZWRFZGl0T3BlcmF0aW9uKG51bGwsIHRyaW1SYW5nZSwgbnVsbCwgZmFsc2UsIGZhbHNlLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdHJpbUF1dG9XaGl0ZXNwYWNlTGluZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsVW5kb1JlZG9TbmFwc2hvdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbFVuZG9SZWRvU25hcHNob3QgPSB0aGlzLl91bmRvUmVkb1NlcnZpY2UuY3JlYXRlU25hcHNob3QodGhpcy51cmkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21tYW5kTWFuYWdlci5wdXNoRWRpdE9wZXJhdGlvbihiZWZvcmVDdXJzb3JTdGF0ZSwgZWRpdE9wZXJhdGlvbnMsIGN1cnNvclN0YXRlQ29tcHV0ZXIsIGdyb3VwKTtcbiAgICB9XG4gICAgX2FwcGx5VW5kbyhjaGFuZ2VzLCBlb2wsIHJlc3VsdGluZ0FsdGVybmF0aXZlVmVyc2lvbklkLCByZXN1bHRpbmdTZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZWRpdHMgPSBjaGFuZ2VzLm1hcCgoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYW5nZVN0YXJ0ID0gdGhpcy5nZXRQb3NpdGlvbkF0KGNoYW5nZS5uZXdQb3NpdGlvbik7XG4gICAgICAgICAgICBjb25zdCByYW5nZUVuZCA9IHRoaXMuZ2V0UG9zaXRpb25BdChjaGFuZ2UubmV3RW5kKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IG5ldyBSYW5nZShyYW5nZVN0YXJ0LmxpbmVOdW1iZXIsIHJhbmdlU3RhcnQuY29sdW1uLCByYW5nZUVuZC5saW5lTnVtYmVyLCByYW5nZUVuZC5jb2x1bW4pLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNoYW5nZS5vbGRUZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYXBwbHlVbmRvUmVkb0VkaXRzKGVkaXRzLCBlb2wsIHRydWUsIGZhbHNlLCByZXN1bHRpbmdBbHRlcm5hdGl2ZVZlcnNpb25JZCwgcmVzdWx0aW5nU2VsZWN0aW9uKTtcbiAgICB9XG4gICAgX2FwcGx5UmVkbyhjaGFuZ2VzLCBlb2wsIHJlc3VsdGluZ0FsdGVybmF0aXZlVmVyc2lvbklkLCByZXN1bHRpbmdTZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZWRpdHMgPSBjaGFuZ2VzLm1hcCgoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYW5nZVN0YXJ0ID0gdGhpcy5nZXRQb3NpdGlvbkF0KGNoYW5nZS5vbGRQb3NpdGlvbik7XG4gICAgICAgICAgICBjb25zdCByYW5nZUVuZCA9IHRoaXMuZ2V0UG9zaXRpb25BdChjaGFuZ2Uub2xkRW5kKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IG5ldyBSYW5nZShyYW5nZVN0YXJ0LmxpbmVOdW1iZXIsIHJhbmdlU3RhcnQuY29sdW1uLCByYW5nZUVuZC5saW5lTnVtYmVyLCByYW5nZUVuZC5jb2x1bW4pLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNoYW5nZS5uZXdUZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYXBwbHlVbmRvUmVkb0VkaXRzKGVkaXRzLCBlb2wsIGZhbHNlLCB0cnVlLCByZXN1bHRpbmdBbHRlcm5hdGl2ZVZlcnNpb25JZCwgcmVzdWx0aW5nU2VsZWN0aW9uKTtcbiAgICB9XG4gICAgX2FwcGx5VW5kb1JlZG9FZGl0cyhlZGl0cywgZW9sLCBpc1VuZG9pbmcsIGlzUmVkb2luZywgcmVzdWx0aW5nQWx0ZXJuYXRpdmVWZXJzaW9uSWQsIHJlc3VsdGluZ1NlbGVjdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5iZWdpbkRlZmVycmVkRW1pdCgpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmJlZ2luRGVmZXJyZWRFbWl0KCk7XG4gICAgICAgICAgICB0aGlzLl9pc1VuZG9pbmcgPSBpc1VuZG9pbmc7XG4gICAgICAgICAgICB0aGlzLl9pc1JlZG9pbmcgPSBpc1JlZG9pbmc7XG4gICAgICAgICAgICB0aGlzLmFwcGx5RWRpdHMoZWRpdHMsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RU9MKGVvbCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVyd3JpdGVBbHRlcm5hdGl2ZVZlcnNpb25JZChyZXN1bHRpbmdBbHRlcm5hdGl2ZVZlcnNpb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9pc1VuZG9pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVkb2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmVuZERlZmVycmVkRW1pdChyZXN1bHRpbmdTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5lbmREZWZlcnJlZEVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseUVkaXRzKHJhd09wZXJhdGlvbnMsIGNvbXB1dGVVbmRvRWRpdHMgPSBmYWxzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5iZWdpbkRlZmVycmVkRW1pdCgpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmJlZ2luRGVmZXJyZWRFbWl0KCk7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb25zID0gdGhpcy5fdmFsaWRhdGVFZGl0T3BlcmF0aW9ucyhyYXdPcGVyYXRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb0FwcGx5RWRpdHMob3BlcmF0aW9ucywgY29tcHV0ZVVuZG9FZGl0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZW5kRGVmZXJyZWRFbWl0KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLmVuZERlZmVycmVkRW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9kb0FwcGx5RWRpdHMocmF3T3BlcmF0aW9ucywgY29tcHV0ZVVuZG9FZGl0cykge1xuICAgICAgICBjb25zdCBvbGRMaW5lQ291bnQgPSB0aGlzLl9idWZmZXIuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2J1ZmZlci5hcHBseUVkaXRzKHJhd09wZXJhdGlvbnMsIHRoaXMuX29wdGlvbnMudHJpbUF1dG9XaGl0ZXNwYWNlLCBjb21wdXRlVW5kb0VkaXRzKTtcbiAgICAgICAgY29uc3QgbmV3TGluZUNvdW50ID0gdGhpcy5fYnVmZmVyLmdldExpbmVDb3VudCgpO1xuICAgICAgICBjb25zdCBjb250ZW50Q2hhbmdlcyA9IHJlc3VsdC5jaGFuZ2VzO1xuICAgICAgICB0aGlzLl90cmltQXV0b1doaXRlc3BhY2VMaW5lcyA9IHJlc3VsdC50cmltQXV0b1doaXRlc3BhY2VMaW5lTnVtYmVycztcbiAgICAgICAgaWYgKGNvbnRlbnRDaGFuZ2VzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gV2UgZG8gYSBmaXJzdCBwYXNzIHRvIHVwZGF0ZSBkZWNvcmF0aW9uc1xuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSB3YW50IHRvIHJlYWQgZGVjb3JhdGlvbnMgaW4gdGhlIHNlY29uZCBwYXNzXG4gICAgICAgICAgICAvLyB3aGVyZSB3ZSB3aWxsIGVtaXQgY29udGVudCBjaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICAvLyBhbmQgd2Ugd2FudCB0byByZWFkIHRoZSBmaW5hbCBkZWNvcmF0aW9uc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNvbnRlbnRDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gY29udGVudENoYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVjb3JhdGlvbnNUcmVlLmFjY2VwdFJlcGxhY2UoY2hhbmdlLnJhbmdlT2Zmc2V0LCBjaGFuZ2UucmFuZ2VMZW5ndGgsIGNoYW5nZS50ZXh0Lmxlbmd0aCwgY2hhbmdlLmZvcmNlTW92ZU1hcmtlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3Q29udGVudENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2luY3JlYXNlVmVyc2lvbklkKCk7XG4gICAgICAgICAgICBsZXQgbGluZUNvdW50ID0gb2xkTGluZUNvdW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNvbnRlbnRDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gY29udGVudENoYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgW2VvbENvdW50XSA9IGNvdW50RU9MKGNoYW5nZS50ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLmZpcmUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydExpbmVOdW1iZXIgPSBjaGFuZ2UucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZExpbmVOdW1iZXIgPSBjaGFuZ2UucmFuZ2UuZW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxldGluZ0xpbmVzQ250ID0gZW5kTGluZU51bWJlciAtIHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRpbmdMaW5lc0NudCA9IGVvbENvdW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRpbmdMaW5lc0NudCA9IE1hdGgubWluKGRlbGV0aW5nTGluZXNDbnQsIGluc2VydGluZ0xpbmVzQ250KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VMaW5lQ291bnREZWx0YSA9IChpbnNlcnRpbmdMaW5lc0NudCAtIGRlbGV0aW5nTGluZXNDbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFZGl0U3RhcnRMaW5lTnVtYmVyID0gbmV3TGluZUNvdW50IC0gbGluZUNvdW50IC0gY2hhbmdlTGluZUNvdW50RGVsdGEgKyBzdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RFZGl0TGluZU51bWJlciA9IGN1cnJlbnRFZGl0U3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJbnNlcnRlZExpbmVOdW1iZXIgPSBjdXJyZW50RWRpdFN0YXJ0TGluZU51bWJlciArIGluc2VydGluZ0xpbmVzQ250O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29yYXRpb25zV2l0aEluamVjdGVkVGV4dEluRWRpdGVkUmFuZ2UgPSB0aGlzLl9kZWNvcmF0aW9uc1RyZWUuZ2V0SW5qZWN0ZWRUZXh0SW5JbnRlcnZhbCh0aGlzLCB0aGlzLmdldE9mZnNldEF0KG5ldyBQb3NpdGlvbihmaXJzdEVkaXRMaW5lTnVtYmVyLCAxKSksIHRoaXMuZ2V0T2Zmc2V0QXQobmV3IFBvc2l0aW9uKGxhc3RJbnNlcnRlZExpbmVOdW1iZXIsIHRoaXMuZ2V0TGluZU1heENvbHVtbihsYXN0SW5zZXJ0ZWRMaW5lTnVtYmVyKSkpLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmplY3RlZFRleHRJbkVkaXRlZFJhbmdlID0gTGluZUluamVjdGVkVGV4dC5mcm9tRGVjb3JhdGlvbnMoZGVjb3JhdGlvbnNXaXRoSW5qZWN0ZWRUZXh0SW5FZGl0ZWRSYW5nZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5qZWN0ZWRUZXh0SW5FZGl0ZWRSYW5nZVF1ZXVlID0gbmV3IEFycmF5UXVldWUoaW5qZWN0ZWRUZXh0SW5FZGl0ZWRSYW5nZSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGVkaXRpbmdMaW5lc0NudDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRpdExpbmVOdW1iZXIgPSBzdGFydExpbmVOdW1iZXIgKyBqO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RWRpdExpbmVOdW1iZXIgPSBjdXJyZW50RWRpdFN0YXJ0TGluZU51bWJlciArIGo7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkVGV4dEluRWRpdGVkUmFuZ2VRdWV1ZS50YWtlRnJvbUVuZFdoaWxlKHIgPT4gci5saW5lTnVtYmVyID4gY3VycmVudEVkaXRMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbnNJbkN1cnJlbnRMaW5lID0gaW5qZWN0ZWRUZXh0SW5FZGl0ZWRSYW5nZVF1ZXVlLnRha2VGcm9tRW5kV2hpbGUociA9PiByLmxpbmVOdW1iZXIgPT09IGN1cnJlbnRFZGl0TGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIHJhd0NvbnRlbnRDaGFuZ2VzLnB1c2gobmV3IE1vZGVsUmF3TGluZUNoYW5nZWQoZWRpdExpbmVOdW1iZXIsIHRoaXMuZ2V0TGluZUNvbnRlbnQoY3VycmVudEVkaXRMaW5lTnVtYmVyKSwgZGVjb3JhdGlvbnNJbkN1cnJlbnRMaW5lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlZGl0aW5nTGluZXNDbnQgPCBkZWxldGluZ0xpbmVzQ250KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11c3QgZGVsZXRlIHNvbWUgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaWNlU3RhcnRMaW5lTnVtYmVyID0gc3RhcnRMaW5lTnVtYmVyICsgZWRpdGluZ0xpbmVzQ250O1xuICAgICAgICAgICAgICAgICAgICByYXdDb250ZW50Q2hhbmdlcy5wdXNoKG5ldyBNb2RlbFJhd0xpbmVzRGVsZXRlZChzcGxpY2VTdGFydExpbmVOdW1iZXIgKyAxLCBlbmRMaW5lTnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlZGl0aW5nTGluZXNDbnQgPCBpbnNlcnRpbmdMaW5lc0NudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmplY3RlZFRleHRJbkVkaXRlZFJhbmdlUXVldWUgPSBuZXcgQXJyYXlRdWV1ZShpbmplY3RlZFRleHRJbkVkaXRlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBpbnNlcnQgc29tZSBsaW5lc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGxpY2VMaW5lTnVtYmVyID0gc3RhcnRMaW5lTnVtYmVyICsgZWRpdGluZ0xpbmVzQ250O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbnQgPSBpbnNlcnRpbmdMaW5lc0NudCAtIGVkaXRpbmdMaW5lc0NudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJvbUxpbmVOdW1iZXIgPSBuZXdMaW5lQ291bnQgLSBsaW5lQ291bnQgLSBjbnQgKyBzcGxpY2VMaW5lTnVtYmVyICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5qZWN0ZWRUZXh0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lTnVtYmVyID0gZnJvbUxpbmVOdW1iZXIgKyBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGluZXNbaV0gPSB0aGlzLmdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRUZXh0SW5FZGl0ZWRSYW5nZVF1ZXVlLnRha2VXaGlsZShyID0+IHIubGluZU51bWJlciA8IGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRUZXh0c1tpXSA9IGluamVjdGVkVGV4dEluRWRpdGVkUmFuZ2VRdWV1ZS50YWtlV2hpbGUociA9PiByLmxpbmVOdW1iZXIgPT09IGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJhd0NvbnRlbnRDaGFuZ2VzLnB1c2gobmV3IE1vZGVsUmF3TGluZXNJbnNlcnRlZChzcGxpY2VMaW5lTnVtYmVyICsgMSwgc3RhcnRMaW5lTnVtYmVyICsgaW5zZXJ0aW5nTGluZXNDbnQsIG5ld0xpbmVzLCBpbmplY3RlZFRleHRzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmVDb3VudCArPSBjaGFuZ2VMaW5lQ291bnREZWx0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2VtaXRDb250ZW50Q2hhbmdlZEV2ZW50KG5ldyBNb2RlbFJhd0NvbnRlbnRDaGFuZ2VkRXZlbnQocmF3Q29udGVudENoYW5nZXMsIHRoaXMuZ2V0VmVyc2lvbklkKCksIHRoaXMuX2lzVW5kb2luZywgdGhpcy5faXNSZWRvaW5nKSwge1xuICAgICAgICAgICAgICAgIGNoYW5nZXM6IGNvbnRlbnRDaGFuZ2VzLFxuICAgICAgICAgICAgICAgIGVvbDogdGhpcy5fYnVmZmVyLmdldEVPTCgpLFxuICAgICAgICAgICAgICAgIGlzRW9sQ2hhbmdlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uSWQ6IHRoaXMuZ2V0VmVyc2lvbklkKCksXG4gICAgICAgICAgICAgICAgaXNVbmRvaW5nOiB0aGlzLl9pc1VuZG9pbmcsXG4gICAgICAgICAgICAgICAgaXNSZWRvaW5nOiB0aGlzLl9pc1JlZG9pbmcsXG4gICAgICAgICAgICAgICAgaXNGbHVzaDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocmVzdWx0LnJldmVyc2VFZGl0cyA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJlc3VsdC5yZXZlcnNlRWRpdHMpO1xuICAgIH1cbiAgICB1bmRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5kb1JlZG9TZXJ2aWNlLnVuZG8odGhpcy51cmkpO1xuICAgIH1cbiAgICBjYW5VbmRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5kb1JlZG9TZXJ2aWNlLmNhblVuZG8odGhpcy51cmkpO1xuICAgIH1cbiAgICByZWRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5kb1JlZG9TZXJ2aWNlLnJlZG8odGhpcy51cmkpO1xuICAgIH1cbiAgICBjYW5SZWRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5kb1JlZG9TZXJ2aWNlLmNhblJlZG8odGhpcy51cmkpO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgICAvLyNyZWdpb24gRGVjb3JhdGlvbnNcbiAgICBoYW5kbGVCZWZvcmVGaXJlRGVjb3JhdGlvbnNDaGFuZ2VkRXZlbnQoYWZmZWN0ZWRJbmplY3RlZFRleHRMaW5lcykge1xuICAgICAgICAvLyBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGRlY29yYXRpb24gY2hhbmdlZCBldmVudCBpcyBmaXJlZC5cbiAgICAgICAgaWYgKGFmZmVjdGVkSW5qZWN0ZWRUZXh0TGluZXMgPT09IG51bGwgfHwgYWZmZWN0ZWRJbmplY3RlZFRleHRMaW5lcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWZmZWN0ZWRMaW5lcyA9IEFycmF5LmZyb20oYWZmZWN0ZWRJbmplY3RlZFRleHRMaW5lcyk7XG4gICAgICAgIGNvbnN0IGxpbmVDaGFuZ2VFdmVudHMgPSBhZmZlY3RlZExpbmVzLm1hcChsaW5lTnVtYmVyID0+IG5ldyBNb2RlbFJhd0xpbmVDaGFuZ2VkKGxpbmVOdW1iZXIsIHRoaXMuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlciksIHRoaXMuX2dldEluamVjdGVkVGV4dEluTGluZShsaW5lTnVtYmVyKSkpO1xuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZUluamVjdGVkVGV4dC5maXJlKG5ldyBNb2RlbEluamVjdGVkVGV4dENoYW5nZWRFdmVudChsaW5lQ2hhbmdlRXZlbnRzKSk7XG4gICAgfVxuICAgIGNoYW5nZURlY29yYXRpb25zKGNhbGxiYWNrLCBvd25lcklkID0gMCkge1xuICAgICAgICB0aGlzLl9hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5iZWdpbkRlZmVycmVkRW1pdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZURlY29yYXRpb25zKG93bmVySWQsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlRGVjb3JhdGlvbnMuZW5kRGVmZXJyZWRFbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NoYW5nZURlY29yYXRpb25zKG93bmVySWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZUFjY2Vzc29yID0ge1xuICAgICAgICAgICAgYWRkRGVjb3JhdGlvbjogKHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbHRhRGVjb3JhdGlvbnNJbXBsKG93bmVySWQsIFtdLCBbeyByYW5nZTogcmFuZ2UsIG9wdGlvbnM6IG9wdGlvbnMgfV0pWzBdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYW5nZURlY29yYXRpb246IChpZCwgbmV3UmFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZWNvcmF0aW9uSW1wbChpZCwgbmV3UmFuZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYW5nZURlY29yYXRpb25PcHRpb25zOiAoaWQsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZWNvcmF0aW9uT3B0aW9uc0ltcGwoaWQsIF9ub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVEZWNvcmF0aW9uOiAoaWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWx0YURlY29yYXRpb25zSW1wbChvd25lcklkLCBbaWRdLCBbXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsdGFEZWNvcmF0aW9uczogKG9sZERlY29yYXRpb25zLCBuZXdEZWNvcmF0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvbGREZWNvcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgbmV3RGVjb3JhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsdGFEZWNvcmF0aW9uc0ltcGwob3duZXJJZCwgb2xkRGVjb3JhdGlvbnMsIG5ld0RlY29yYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayhjaGFuZ2VBY2Nlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9uVW5leHBlY3RlZEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEludmFsaWRhdGUgY2hhbmdlIGFjY2Vzc29yXG4gICAgICAgIGNoYW5nZUFjY2Vzc29yLmFkZERlY29yYXRpb24gPSBpbnZhbGlkRnVuYztcbiAgICAgICAgY2hhbmdlQWNjZXNzb3IuY2hhbmdlRGVjb3JhdGlvbiA9IGludmFsaWRGdW5jO1xuICAgICAgICBjaGFuZ2VBY2Nlc3Nvci5jaGFuZ2VEZWNvcmF0aW9uT3B0aW9ucyA9IGludmFsaWRGdW5jO1xuICAgICAgICBjaGFuZ2VBY2Nlc3Nvci5yZW1vdmVEZWNvcmF0aW9uID0gaW52YWxpZEZ1bmM7XG4gICAgICAgIGNoYW5nZUFjY2Vzc29yLmRlbHRhRGVjb3JhdGlvbnMgPSBpbnZhbGlkRnVuYztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZGVsdGFEZWNvcmF0aW9ucyhvbGREZWNvcmF0aW9ucywgbmV3RGVjb3JhdGlvbnMsIG93bmVySWQgPSAwKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgICAgIGlmICghb2xkRGVjb3JhdGlvbnMpIHtcbiAgICAgICAgICAgIG9sZERlY29yYXRpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZERlY29yYXRpb25zLmxlbmd0aCA9PT0gMCAmJiBuZXdEZWNvcmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fZGVsdGFEZWNvcmF0aW9uQ2FsbENudCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RlbHRhRGVjb3JhdGlvbkNhbGxDbnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZva2luZyBkZWx0YURlY29yYXRpb25zIHJlY3Vyc2l2ZWx5IGNvdWxkIGxlYWQgdG8gbGVha2luZyBkZWNvcmF0aW9ucy5gKTtcbiAgICAgICAgICAgICAgICBvblVuZXhwZWN0ZWRFcnJvcihuZXcgRXJyb3IoYEludm9raW5nIGRlbHRhRGVjb3JhdGlvbnMgcmVjdXJzaXZlbHkgY291bGQgbGVhZCB0byBsZWFraW5nIGRlY29yYXRpb25zLmApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlRGVjb3JhdGlvbnMuYmVnaW5EZWZlcnJlZEVtaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWx0YURlY29yYXRpb25zSW1wbChvd25lcklkLCBvbGREZWNvcmF0aW9ucywgbmV3RGVjb3JhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5lbmREZWZlcnJlZEVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2RlbHRhRGVjb3JhdGlvbkNhbGxDbnQtLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0VHJhY2tlZFJhbmdlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlY29yYXRpb25SYW5nZShpZCk7XG4gICAgfVxuICAgIF9zZXRUcmFja2VkUmFuZ2UoaWQsIG5ld1JhbmdlLCBuZXdTdGlja2luZXNzKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSAoaWQgPyB0aGlzLl9kZWNvcmF0aW9uc1tpZF0gOiBudWxsKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBpZiAoIW5ld1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9kZSBkb2Vzbid0IGV4aXN0LCB0aGUgcmVxdWVzdCBpcyB0byBkZWxldGUgPT4gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm9kZSBkb2Vzbid0IGV4aXN0LCB0aGUgcmVxdWVzdCBpcyB0byBzZXQgPT4gYWRkIHRoZSB0cmFja2VkIHJhbmdlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsdGFEZWNvcmF0aW9uc0ltcGwoMCwgW10sIFt7IHJhbmdlOiBuZXdSYW5nZSwgb3B0aW9uczogVFJBQ0tFRF9SQU5HRV9PUFRJT05TW25ld1N0aWNraW5lc3NdIH1dLCB0cnVlKVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1JhbmdlKSB7XG4gICAgICAgICAgICAvLyBub2RlIGV4aXN0cywgdGhlIHJlcXVlc3QgaXMgdG8gZGVsZXRlID0+IGRlbGV0ZSBub2RlXG4gICAgICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2RlY29yYXRpb25zW25vZGUuaWRdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm9kZSBleGlzdHMsIHRoZSByZXF1ZXN0IGlzIHRvIHNldCA9PiBjaGFuZ2UgdGhlIHRyYWNrZWQgcmFuZ2UgYW5kIGl0cyBvcHRpb25zXG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5fdmFsaWRhdGVSYW5nZVJlbGF4ZWROb0FsbG9jYXRpb25zKG5ld1JhbmdlKTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLl9idWZmZXIuZ2V0T2Zmc2V0QXQocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5zdGFydENvbHVtbik7XG4gICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMuX2J1ZmZlci5nZXRPZmZzZXRBdChyYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4pO1xuICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUuZGVsZXRlKG5vZGUpO1xuICAgICAgICBub2RlLnJlc2V0KHRoaXMuZ2V0VmVyc2lvbklkKCksIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHJhbmdlKTtcbiAgICAgICAgbm9kZS5zZXRPcHRpb25zKFRSQUNLRURfUkFOR0VfT1BUSU9OU1tuZXdTdGlja2luZXNzXSk7XG4gICAgICAgIHRoaXMuX2RlY29yYXRpb25zVHJlZS5pbnNlcnQobm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlLmlkO1xuICAgIH1cbiAgICByZW1vdmVBbGxEZWNvcmF0aW9uc1dpdGhPd25lcklkKG93bmVySWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMuX2RlY29yYXRpb25zVHJlZS5jb2xsZWN0Tm9kZXNGcm9tT3duZXIob3duZXJJZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgdGhpcy5fZGVjb3JhdGlvbnNUcmVlLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9kZWNvcmF0aW9uc1tub2RlLmlkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREZWNvcmF0aW9uT3B0aW9ucyhkZWNvcmF0aW9uSWQpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2RlY29yYXRpb25zW2RlY29yYXRpb25JZF07XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUub3B0aW9ucztcbiAgICB9XG4gICAgZ2V0RGVjb3JhdGlvblJhbmdlKGRlY29yYXRpb25JZCkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZGVjb3JhdGlvbnNbZGVjb3JhdGlvbklkXTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb3JhdGlvbnNUcmVlLmdldE5vZGVSYW5nZSh0aGlzLCBub2RlKTtcbiAgICB9XG4gICAgZ2V0TGluZURlY29yYXRpb25zKGxpbmVOdW1iZXIsIG93bmVySWQgPSAwLCBmaWx0ZXJPdXRWYWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGxpbmVOdW1iZXIgPCAxIHx8IGxpbmVOdW1iZXIgPiB0aGlzLmdldExpbmVDb3VudCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZXNEZWNvcmF0aW9ucyhsaW5lTnVtYmVyLCBsaW5lTnVtYmVyLCBvd25lcklkLCBmaWx0ZXJPdXRWYWxpZGF0aW9uKTtcbiAgICB9XG4gICAgZ2V0TGluZXNEZWNvcmF0aW9ucyhfc3RhcnRMaW5lTnVtYmVyLCBfZW5kTGluZU51bWJlciwgb3duZXJJZCA9IDAsIGZpbHRlck91dFZhbGlkYXRpb24gPSBmYWxzZSwgb25seU1hcmdpbkRlY29yYXRpb25zID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgbGluZUNvdW50ID0gdGhpcy5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lTnVtYmVyID0gTWF0aC5taW4obGluZUNvdW50LCBNYXRoLm1heCgxLCBfc3RhcnRMaW5lTnVtYmVyKSk7XG4gICAgICAgIGNvbnN0IGVuZExpbmVOdW1iZXIgPSBNYXRoLm1pbihsaW5lQ291bnQsIE1hdGgubWF4KDEsIF9lbmRMaW5lTnVtYmVyKSk7XG4gICAgICAgIGNvbnN0IGVuZENvbHVtbiA9IHRoaXMuZ2V0TGluZU1heENvbHVtbihlbmRMaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCAxLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pO1xuICAgICAgICBjb25zdCBkZWNvcmF0aW9ucyA9IHRoaXMuX2dldERlY29yYXRpb25zSW5SYW5nZShyYW5nZSwgb3duZXJJZCwgZmlsdGVyT3V0VmFsaWRhdGlvbiwgb25seU1hcmdpbkRlY29yYXRpb25zKTtcbiAgICAgICAgcHVzaE1hbnkoZGVjb3JhdGlvbnMsIHRoaXMuX2RlY29yYXRpb25Qcm92aWRlci5nZXREZWNvcmF0aW9uc0luUmFuZ2UocmFuZ2UsIG93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24pKTtcbiAgICAgICAgcmV0dXJuIGRlY29yYXRpb25zO1xuICAgIH1cbiAgICBnZXREZWNvcmF0aW9uc0luUmFuZ2UocmFuZ2UsIG93bmVySWQgPSAwLCBmaWx0ZXJPdXRWYWxpZGF0aW9uID0gZmFsc2UsIG9ubHlNaW5pbWFwRGVjb3JhdGlvbnMgPSBmYWxzZSwgb25seU1hcmdpbkRlY29yYXRpb25zID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkUmFuZ2UgPSB0aGlzLnZhbGlkYXRlUmFuZ2UocmFuZ2UpO1xuICAgICAgICBjb25zdCBkZWNvcmF0aW9ucyA9IHRoaXMuX2dldERlY29yYXRpb25zSW5SYW5nZSh2YWxpZGF0ZWRSYW5nZSwgb3duZXJJZCwgZmlsdGVyT3V0VmFsaWRhdGlvbiwgb25seU1hcmdpbkRlY29yYXRpb25zKTtcbiAgICAgICAgcHVzaE1hbnkoZGVjb3JhdGlvbnMsIHRoaXMuX2RlY29yYXRpb25Qcm92aWRlci5nZXREZWNvcmF0aW9uc0luUmFuZ2UodmFsaWRhdGVkUmFuZ2UsIG93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIG9ubHlNaW5pbWFwRGVjb3JhdGlvbnMpKTtcbiAgICAgICAgcmV0dXJuIGRlY29yYXRpb25zO1xuICAgIH1cbiAgICBnZXRPdmVydmlld1J1bGVyRGVjb3JhdGlvbnMob3duZXJJZCA9IDAsIGZpbHRlck91dFZhbGlkYXRpb24gPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb3JhdGlvbnNUcmVlLmdldEFsbCh0aGlzLCBvd25lcklkLCBmaWx0ZXJPdXRWYWxpZGF0aW9uLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICAgIGdldEluamVjdGVkVGV4dERlY29yYXRpb25zKG93bmVySWQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvcmF0aW9uc1RyZWUuZ2V0QWxsSW5qZWN0ZWRUZXh0KHRoaXMsIG93bmVySWQpO1xuICAgIH1cbiAgICBfZ2V0SW5qZWN0ZWRUZXh0SW5MaW5lKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLl9idWZmZXIuZ2V0T2Zmc2V0QXQobGluZU51bWJlciwgMSk7XG4gICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgdGhpcy5fYnVmZmVyLmdldExpbmVMZW5ndGgobGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlY29yYXRpb25zVHJlZS5nZXRJbmplY3RlZFRleHRJbkludGVydmFsKHRoaXMsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIDApO1xuICAgICAgICByZXR1cm4gTGluZUluamVjdGVkVGV4dC5mcm9tRGVjb3JhdGlvbnMocmVzdWx0KS5maWx0ZXIodCA9PiB0LmxpbmVOdW1iZXIgPT09IGxpbmVOdW1iZXIpO1xuICAgIH1cbiAgICBnZXRBbGxEZWNvcmF0aW9ucyhvd25lcklkID0gMCwgZmlsdGVyT3V0VmFsaWRhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9kZWNvcmF0aW9uc1RyZWUuZ2V0QWxsKHRoaXMsIG93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5fZGVjb3JhdGlvblByb3ZpZGVyLmdldEFsbERlY29yYXRpb25zKG93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0QWxsTWFyZ2luRGVjb3JhdGlvbnMob3duZXJJZCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29yYXRpb25zVHJlZS5nZXRBbGwodGhpcywgb3duZXJJZCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgX2dldERlY29yYXRpb25zSW5SYW5nZShmaWx0ZXJSYW5nZSwgZmlsdGVyT3duZXJJZCwgZmlsdGVyT3V0VmFsaWRhdGlvbiwgb25seU1hcmdpbkRlY29yYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5fYnVmZmVyLmdldE9mZnNldEF0KGZpbHRlclJhbmdlLnN0YXJ0TGluZU51bWJlciwgZmlsdGVyUmFuZ2Uuc3RhcnRDb2x1bW4pO1xuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSB0aGlzLl9idWZmZXIuZ2V0T2Zmc2V0QXQoZmlsdGVyUmFuZ2UuZW5kTGluZU51bWJlciwgZmlsdGVyUmFuZ2UuZW5kQ29sdW1uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29yYXRpb25zVHJlZS5nZXRBbGxJbkludGVydmFsKHRoaXMsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIGZpbHRlck93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIG9ubHlNYXJnaW5EZWNvcmF0aW9ucyk7XG4gICAgfVxuICAgIGdldFJhbmdlQXQoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldFJhbmdlQXQoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgICB9XG4gICAgX2NoYW5nZURlY29yYXRpb25JbXBsKGRlY29yYXRpb25JZCwgX3JhbmdlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9kZWNvcmF0aW9uc1tkZWNvcmF0aW9uSWRdO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5vcHRpb25zLmFmdGVyKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRSYW5nZSA9IHRoaXMuZ2V0RGVjb3JhdGlvblJhbmdlKGRlY29yYXRpb25JZCk7XG4gICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLnJlY29yZExpbmVBZmZlY3RlZEJ5SW5qZWN0ZWRUZXh0KG9sZFJhbmdlLmVuZExpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm9wdGlvbnMuYmVmb3JlKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRSYW5nZSA9IHRoaXMuZ2V0RGVjb3JhdGlvblJhbmdlKGRlY29yYXRpb25JZCk7XG4gICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLnJlY29yZExpbmVBZmZlY3RlZEJ5SW5qZWN0ZWRUZXh0KG9sZFJhbmdlLnN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLl92YWxpZGF0ZVJhbmdlUmVsYXhlZE5vQWxsb2NhdGlvbnMoX3JhbmdlKTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLl9idWZmZXIuZ2V0T2Zmc2V0QXQocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5zdGFydENvbHVtbik7XG4gICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMuX2J1ZmZlci5nZXRPZmZzZXRBdChyYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4pO1xuICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUuZGVsZXRlKG5vZGUpO1xuICAgICAgICBub2RlLnJlc2V0KHRoaXMuZ2V0VmVyc2lvbklkKCksIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHJhbmdlKTtcbiAgICAgICAgdGhpcy5fZGVjb3JhdGlvbnNUcmVlLmluc2VydChub2RlKTtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5jaGVja0FmZmVjdGVkQW5kRmlyZShub2RlLm9wdGlvbnMpO1xuICAgICAgICBpZiAobm9kZS5vcHRpb25zLmFmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLnJlY29yZExpbmVBZmZlY3RlZEJ5SW5qZWN0ZWRUZXh0KHJhbmdlLmVuZExpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm9wdGlvbnMuYmVmb3JlKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLnJlY29yZExpbmVBZmZlY3RlZEJ5SW5qZWN0ZWRUZXh0KHJhbmdlLnN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NoYW5nZURlY29yYXRpb25PcHRpb25zSW1wbChkZWNvcmF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2RlY29yYXRpb25zW2RlY29yYXRpb25JZF07XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVXYXNJbk92ZXJ2aWV3UnVsZXIgPSAobm9kZS5vcHRpb25zLm92ZXJ2aWV3UnVsZXIgJiYgbm9kZS5vcHRpb25zLm92ZXJ2aWV3UnVsZXIuY29sb3IgPyB0cnVlIDogZmFsc2UpO1xuICAgICAgICBjb25zdCBub2RlSXNJbk92ZXJ2aWV3UnVsZXIgPSAob3B0aW9ucy5vdmVydmlld1J1bGVyICYmIG9wdGlvbnMub3ZlcnZpZXdSdWxlci5jb2xvciA/IHRydWUgOiBmYWxzZSk7XG4gICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlRGVjb3JhdGlvbnMuY2hlY2tBZmZlY3RlZEFuZEZpcmUobm9kZS5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5jaGVja0FmZmVjdGVkQW5kRmlyZShvcHRpb25zKTtcbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5hZnRlciB8fCBvcHRpb25zLmFmdGVyKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlUmFuZ2UgPSB0aGlzLl9kZWNvcmF0aW9uc1RyZWUuZ2V0Tm9kZVJhbmdlKHRoaXMsIG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5yZWNvcmRMaW5lQWZmZWN0ZWRCeUluamVjdGVkVGV4dChub2RlUmFuZ2UuZW5kTGluZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5iZWZvcmUgfHwgb3B0aW9ucy5iZWZvcmUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVSYW5nZSA9IHRoaXMuX2RlY29yYXRpb25zVHJlZS5nZXROb2RlUmFuZ2UodGhpcywgbm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLnJlY29yZExpbmVBZmZlY3RlZEJ5SW5qZWN0ZWRUZXh0KG5vZGVSYW5nZS5zdGFydExpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vdmVkSW5PdmVydmlld1J1bGVyID0gbm9kZVdhc0luT3ZlcnZpZXdSdWxlciAhPT0gbm9kZUlzSW5PdmVydmlld1J1bGVyO1xuICAgICAgICBjb25zdCBjaGFuZ2VkV2hldGhlckluamVjdGVkVGV4dCA9IGlzT3B0aW9uc0luamVjdGVkVGV4dChvcHRpb25zKSAhPT0gaXNOb2RlSW5qZWN0ZWRUZXh0KG5vZGUpO1xuICAgICAgICBpZiAobW92ZWRJbk92ZXJ2aWV3UnVsZXIgfHwgY2hhbmdlZFdoZXRoZXJJbmplY3RlZFRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlY29yYXRpb25zVHJlZS5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICBub2RlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUuaW5zZXJ0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9kZWx0YURlY29yYXRpb25zSW1wbChvd25lcklkLCBvbGREZWNvcmF0aW9uc0lkcywgbmV3RGVjb3JhdGlvbnMsIHN1cHByZXNzRXZlbnRzID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbklkID0gdGhpcy5nZXRWZXJzaW9uSWQoKTtcbiAgICAgICAgY29uc3Qgb2xkRGVjb3JhdGlvbnNMZW4gPSBvbGREZWNvcmF0aW9uc0lkcy5sZW5ndGg7XG4gICAgICAgIGxldCBvbGREZWNvcmF0aW9uSW5kZXggPSAwO1xuICAgICAgICBjb25zdCBuZXdEZWNvcmF0aW9uc0xlbiA9IG5ld0RlY29yYXRpb25zLmxlbmd0aDtcbiAgICAgICAgbGV0IG5ld0RlY29yYXRpb25JbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlRGVjb3JhdGlvbnMuYmVnaW5EZWZlcnJlZEVtaXQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShuZXdEZWNvcmF0aW9uc0xlbik7XG4gICAgICAgICAgICB3aGlsZSAob2xkRGVjb3JhdGlvbkluZGV4IDwgb2xkRGVjb3JhdGlvbnNMZW4gfHwgbmV3RGVjb3JhdGlvbkluZGV4IDwgbmV3RGVjb3JhdGlvbnNMZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG9sZERlY29yYXRpb25JbmRleCA8IG9sZERlY29yYXRpb25zTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICgxKSBnZXQgb3Vyc2VsdmVzIGFuIG9sZCBub2RlXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLl9kZWNvcmF0aW9uc1tvbGREZWNvcmF0aW9uc0lkc1tvbGREZWNvcmF0aW9uSW5kZXgrK11dO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICghbm9kZSAmJiBvbGREZWNvcmF0aW9uSW5kZXggPCBvbGREZWNvcmF0aW9uc0xlbik7XG4gICAgICAgICAgICAgICAgICAgIC8vICgyKSByZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgdHJlZSAoaWYgaXQgZXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5hZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVSYW5nZSA9IHRoaXMuX2RlY29yYXRpb25zVHJlZS5nZXROb2RlUmFuZ2UodGhpcywgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5yZWNvcmRMaW5lQWZmZWN0ZWRCeUluamVjdGVkVGV4dChub2RlUmFuZ2UuZW5kTGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vcHRpb25zLmJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVSYW5nZSA9IHRoaXMuX2RlY29yYXRpb25zVHJlZS5nZXROb2RlUmFuZ2UodGhpcywgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5yZWNvcmRMaW5lQWZmZWN0ZWRCeUluamVjdGVkVGV4dChub2RlUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlY29yYXRpb25zVHJlZS5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5jaGVja0FmZmVjdGVkQW5kRmlyZShub2RlLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdEZWNvcmF0aW9uSW5kZXggPCBuZXdEZWNvcmF0aW9uc0xlbikge1xuICAgICAgICAgICAgICAgICAgICAvLyAoMykgY3JlYXRlIGEgbmV3IG5vZGUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxEZWNvcmF0aW9uSWQgPSAoKyt0aGlzLl9sYXN0RGVjb3JhdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY29yYXRpb25JZCA9IGAke3RoaXMuX2luc3RhbmNlSWR9OyR7aW50ZXJuYWxEZWNvcmF0aW9uSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgSW50ZXJ2YWxOb2RlKGRlY29yYXRpb25JZCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1tkZWNvcmF0aW9uSWRdID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAoNCkgaW5pdGlhbGl6ZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RlY29yYXRpb24gPSBuZXdEZWNvcmF0aW9uc1tuZXdEZWNvcmF0aW9uSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuX3ZhbGlkYXRlUmFuZ2VSZWxheGVkTm9BbGxvY2F0aW9ucyhuZXdEZWNvcmF0aW9uLnJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IF9ub3JtYWxpemVPcHRpb25zKG5ld0RlY29yYXRpb24ub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5fYnVmZmVyLmdldE9mZnNldEF0KHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSB0aGlzLl9idWZmZXIuZ2V0T2Zmc2V0QXQocmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vd25lcklkID0gb3duZXJJZDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZXNldCh2ZXJzaW9uSWQsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vcHRpb25zLmFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLnJlY29yZExpbmVBZmZlY3RlZEJ5SW5qZWN0ZWRUZXh0KHJhbmdlLmVuZExpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm9wdGlvbnMuYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLnJlY29yZExpbmVBZmZlY3RlZEJ5SW5qZWN0ZWRUZXh0KHJhbmdlLnN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VEZWNvcmF0aW9ucy5jaGVja0FmZmVjdGVkQW5kRmlyZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUuaW5zZXJ0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbmV3RGVjb3JhdGlvbkluZGV4XSA9IG5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RlY29yYXRpb25JbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9kZWNvcmF0aW9uc1tub2RlLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZURlY29yYXRpb25zLmVuZERlZmVycmVkRW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICAgIC8vI3JlZ2lvbiBUb2tlbml6YXRpb25cbiAgICAvLyBUT0RPIG1vdmUgdGhlbSB0byB0aGUgdG9rZW5pemF0aW9uIHBhcnQuXG4gICAgZ2V0TGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5pemF0aW9uLmdldExhbmd1YWdlSWQoKTtcbiAgICB9XG4gICAgc2V0TGFuZ3VhZ2UobGFuZ3VhZ2VJZE9yU2VsZWN0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsYW5ndWFnZUlkT3JTZWxlY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9sYW5ndWFnZVNlbGVjdGlvbkxpc3RlbmVyLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRMYW5ndWFnZShsYW5ndWFnZUlkT3JTZWxlY3Rpb24sIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sYW5ndWFnZVNlbGVjdGlvbkxpc3RlbmVyLnZhbHVlID0gbGFuZ3VhZ2VJZE9yU2VsZWN0aW9uLm9uRGlkQ2hhbmdlKCgpID0+IHRoaXMuX3NldExhbmd1YWdlKGxhbmd1YWdlSWRPclNlbGVjdGlvbi5sYW5ndWFnZUlkLCBzb3VyY2UpKTtcbiAgICAgICAgICAgIHRoaXMuX3NldExhbmd1YWdlKGxhbmd1YWdlSWRPclNlbGVjdGlvbi5sYW5ndWFnZUlkLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zZXRMYW5ndWFnZShsYW5ndWFnZUlkLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy50b2tlbml6YXRpb24uc2V0TGFuZ3VhZ2VJZChsYW5ndWFnZUlkLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZVNlcnZpY2UucmVxdWVzdFJpY2hMYW5ndWFnZUZlYXR1cmVzKGxhbmd1YWdlSWQpO1xuICAgIH1cbiAgICBnZXRMYW5ndWFnZUlkQXRQb3NpdGlvbihsaW5lTnVtYmVyLCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5pemF0aW9uLmdldExhbmd1YWdlSWRBdFBvc2l0aW9uKGxpbmVOdW1iZXIsIGNvbHVtbik7XG4gICAgfVxuICAgIGdldFdvcmRBdFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbml6YXRpb25UZXh0TW9kZWxQYXJ0LmdldFdvcmRBdFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgZ2V0V29yZFVudGlsUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuaXphdGlvblRleHRNb2RlbFBhcnQuZ2V0V29yZFVudGlsUG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgICBub3JtYWxpemVQb3NpdGlvbihwb3NpdGlvbiwgYWZmaW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gYXQgd2hpY2ggaW5kZW50YXRpb24gc3RvcHMgYXQgYSBnaXZlbiBsaW5lLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0TGluZUluZGVudENvbHVtbihsaW5lTnVtYmVyKSB7XG4gICAgICAgIC8vIENvbHVtbnMgc3RhcnQgd2l0aCAxLlxuICAgICAgICByZXR1cm4gaW5kZW50T2ZMaW5lKHRoaXMuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcikpICsgMTtcbiAgICB9XG59O1xuVGV4dE1vZGVsID0gVGV4dE1vZGVsXzEgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDQsIElVbmRvUmVkb1NlcnZpY2UpLFxuICAgIF9fcGFyYW0oNSwgSUxhbmd1YWdlU2VydmljZSksXG4gICAgX19wYXJhbSg2LCBJTGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZSksXG4gICAgX19wYXJhbSg3LCBJSW5zdGFudGlhdGlvblNlcnZpY2UpXG5dLCBUZXh0TW9kZWwpO1xuZXhwb3J0IHsgVGV4dE1vZGVsIH07XG5leHBvcnQgZnVuY3Rpb24gaW5kZW50T2ZMaW5lKGxpbmUpIHtcbiAgICBsZXQgaW5kZW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGMgb2YgbGluZSkge1xuICAgICAgICBpZiAoYyA9PT0gJyAnIHx8IGMgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRlbnQ7XG59XG4vLyNyZWdpb24gRGVjb3JhdGlvbnNcbmZ1bmN0aW9uIGlzTm9kZUluT3ZlcnZpZXdSdWxlcihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLm9wdGlvbnMub3ZlcnZpZXdSdWxlciAmJiBub2RlLm9wdGlvbnMub3ZlcnZpZXdSdWxlci5jb2xvciA/IHRydWUgOiBmYWxzZSk7XG59XG5mdW5jdGlvbiBpc09wdGlvbnNJbmplY3RlZFRleHQob3B0aW9ucykge1xuICAgIHJldHVybiAhIW9wdGlvbnMuYWZ0ZXIgfHwgISFvcHRpb25zLmJlZm9yZTtcbn1cbmZ1bmN0aW9uIGlzTm9kZUluamVjdGVkVGV4dChub2RlKSB7XG4gICAgcmV0dXJuICEhbm9kZS5vcHRpb25zLmFmdGVyIHx8ICEhbm9kZS5vcHRpb25zLmJlZm9yZTtcbn1cbmNsYXNzIERlY29yYXRpb25zVHJlZXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUwID0gbmV3IEludGVydmFsVHJlZSgpO1xuICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUxID0gbmV3IEludGVydmFsVHJlZSgpO1xuICAgICAgICB0aGlzLl9pbmplY3RlZFRleHREZWNvcmF0aW9uc1RyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XG4gICAgfVxuICAgIGVuc3VyZUFsbE5vZGVzSGF2ZVJhbmdlcyhob3N0KSB7XG4gICAgICAgIHRoaXMuZ2V0QWxsKGhvc3QsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICBfZW5zdXJlTm9kZXNIYXZlUmFuZ2VzKGhvc3QsIG5vZGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUucmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJhbmdlID0gaG9zdC5nZXRSYW5nZUF0KG5vZGUuY2FjaGVkQWJzb2x1dGVTdGFydCwgbm9kZS5jYWNoZWRBYnNvbHV0ZUVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBnZXRBbGxJbkludGVydmFsKGhvc3QsIHN0YXJ0LCBlbmQsIGZpbHRlck93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIG9ubHlNYXJnaW5EZWNvcmF0aW9ucykge1xuICAgICAgICBjb25zdCB2ZXJzaW9uSWQgPSBob3N0LmdldFZlcnNpb25JZCgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9pbnRlcnZhbFNlYXJjaChzdGFydCwgZW5kLCBmaWx0ZXJPd25lcklkLCBmaWx0ZXJPdXRWYWxpZGF0aW9uLCB2ZXJzaW9uSWQsIG9ubHlNYXJnaW5EZWNvcmF0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnN1cmVOb2Rlc0hhdmVSYW5nZXMoaG9zdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgX2ludGVydmFsU2VhcmNoKHN0YXJ0LCBlbmQsIGZpbHRlck93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIGNhY2hlZFZlcnNpb25JZCwgb25seU1hcmdpbkRlY29yYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHIwID0gdGhpcy5fZGVjb3JhdGlvbnNUcmVlMC5pbnRlcnZhbFNlYXJjaChzdGFydCwgZW5kLCBmaWx0ZXJPd25lcklkLCBmaWx0ZXJPdXRWYWxpZGF0aW9uLCBjYWNoZWRWZXJzaW9uSWQsIG9ubHlNYXJnaW5EZWNvcmF0aW9ucyk7XG4gICAgICAgIGNvbnN0IHIxID0gdGhpcy5fZGVjb3JhdGlvbnNUcmVlMS5pbnRlcnZhbFNlYXJjaChzdGFydCwgZW5kLCBmaWx0ZXJPd25lcklkLCBmaWx0ZXJPdXRWYWxpZGF0aW9uLCBjYWNoZWRWZXJzaW9uSWQsIG9ubHlNYXJnaW5EZWNvcmF0aW9ucyk7XG4gICAgICAgIGNvbnN0IHIyID0gdGhpcy5faW5qZWN0ZWRUZXh0RGVjb3JhdGlvbnNUcmVlLmludGVydmFsU2VhcmNoKHN0YXJ0LCBlbmQsIGZpbHRlck93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIGNhY2hlZFZlcnNpb25JZCwgb25seU1hcmdpbkRlY29yYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHIwLmNvbmNhdChyMSkuY29uY2F0KHIyKTtcbiAgICB9XG4gICAgZ2V0SW5qZWN0ZWRUZXh0SW5JbnRlcnZhbChob3N0LCBzdGFydCwgZW5kLCBmaWx0ZXJPd25lcklkKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb25JZCA9IGhvc3QuZ2V0VmVyc2lvbklkKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2luamVjdGVkVGV4dERlY29yYXRpb25zVHJlZS5pbnRlcnZhbFNlYXJjaChzdGFydCwgZW5kLCBmaWx0ZXJPd25lcklkLCBmYWxzZSwgdmVyc2lvbklkLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnN1cmVOb2Rlc0hhdmVSYW5nZXMoaG9zdCwgcmVzdWx0KS5maWx0ZXIoKGkpID0+IGkub3B0aW9ucy5zaG93SWZDb2xsYXBzZWQgfHwgIWkucmFuZ2UuaXNFbXB0eSgpKTtcbiAgICB9XG4gICAgZ2V0QWxsSW5qZWN0ZWRUZXh0KGhvc3QsIGZpbHRlck93bmVySWQpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbklkID0gaG9zdC5nZXRWZXJzaW9uSWQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faW5qZWN0ZWRUZXh0RGVjb3JhdGlvbnNUcmVlLnNlYXJjaChmaWx0ZXJPd25lcklkLCBmYWxzZSwgdmVyc2lvbklkLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnN1cmVOb2Rlc0hhdmVSYW5nZXMoaG9zdCwgcmVzdWx0KS5maWx0ZXIoKGkpID0+IGkub3B0aW9ucy5zaG93SWZDb2xsYXBzZWQgfHwgIWkucmFuZ2UuaXNFbXB0eSgpKTtcbiAgICB9XG4gICAgZ2V0QWxsKGhvc3QsIGZpbHRlck93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIG92ZXJ2aWV3UnVsZXJPbmx5LCBvbmx5TWFyZ2luRGVjb3JhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbklkID0gaG9zdC5nZXRWZXJzaW9uSWQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fc2VhcmNoKGZpbHRlck93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIG92ZXJ2aWV3UnVsZXJPbmx5LCB2ZXJzaW9uSWQsIG9ubHlNYXJnaW5EZWNvcmF0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnN1cmVOb2Rlc0hhdmVSYW5nZXMoaG9zdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgX3NlYXJjaChmaWx0ZXJPd25lcklkLCBmaWx0ZXJPdXRWYWxpZGF0aW9uLCBvdmVydmlld1J1bGVyT25seSwgY2FjaGVkVmVyc2lvbklkLCBvbmx5TWFyZ2luRGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKG92ZXJ2aWV3UnVsZXJPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjb3JhdGlvbnNUcmVlMS5zZWFyY2goZmlsdGVyT3duZXJJZCwgZmlsdGVyT3V0VmFsaWRhdGlvbiwgY2FjaGVkVmVyc2lvbklkLCBvbmx5TWFyZ2luRGVjb3JhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcjAgPSB0aGlzLl9kZWNvcmF0aW9uc1RyZWUwLnNlYXJjaChmaWx0ZXJPd25lcklkLCBmaWx0ZXJPdXRWYWxpZGF0aW9uLCBjYWNoZWRWZXJzaW9uSWQsIG9ubHlNYXJnaW5EZWNvcmF0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCByMSA9IHRoaXMuX2RlY29yYXRpb25zVHJlZTEuc2VhcmNoKGZpbHRlck93bmVySWQsIGZpbHRlck91dFZhbGlkYXRpb24sIGNhY2hlZFZlcnNpb25JZCwgb25seU1hcmdpbkRlY29yYXRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHIyID0gdGhpcy5faW5qZWN0ZWRUZXh0RGVjb3JhdGlvbnNUcmVlLnNlYXJjaChmaWx0ZXJPd25lcklkLCBmaWx0ZXJPdXRWYWxpZGF0aW9uLCBjYWNoZWRWZXJzaW9uSWQsIG9ubHlNYXJnaW5EZWNvcmF0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gcjAuY29uY2F0KHIxKS5jb25jYXQocjIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxlY3ROb2Rlc0Zyb21Pd25lcihvd25lcklkKSB7XG4gICAgICAgIGNvbnN0IHIwID0gdGhpcy5fZGVjb3JhdGlvbnNUcmVlMC5jb2xsZWN0Tm9kZXNGcm9tT3duZXIob3duZXJJZCk7XG4gICAgICAgIGNvbnN0IHIxID0gdGhpcy5fZGVjb3JhdGlvbnNUcmVlMS5jb2xsZWN0Tm9kZXNGcm9tT3duZXIob3duZXJJZCk7XG4gICAgICAgIGNvbnN0IHIyID0gdGhpcy5faW5qZWN0ZWRUZXh0RGVjb3JhdGlvbnNUcmVlLmNvbGxlY3ROb2Rlc0Zyb21Pd25lcihvd25lcklkKTtcbiAgICAgICAgcmV0dXJuIHIwLmNvbmNhdChyMSkuY29uY2F0KHIyKTtcbiAgICB9XG4gICAgY29sbGVjdE5vZGVzUG9zdE9yZGVyKCkge1xuICAgICAgICBjb25zdCByMCA9IHRoaXMuX2RlY29yYXRpb25zVHJlZTAuY29sbGVjdE5vZGVzUG9zdE9yZGVyKCk7XG4gICAgICAgIGNvbnN0IHIxID0gdGhpcy5fZGVjb3JhdGlvbnNUcmVlMS5jb2xsZWN0Tm9kZXNQb3N0T3JkZXIoKTtcbiAgICAgICAgY29uc3QgcjIgPSB0aGlzLl9pbmplY3RlZFRleHREZWNvcmF0aW9uc1RyZWUuY29sbGVjdE5vZGVzUG9zdE9yZGVyKCk7XG4gICAgICAgIHJldHVybiByMC5jb25jYXQocjEpLmNvbmNhdChyMik7XG4gICAgfVxuICAgIGluc2VydChub2RlKSB7XG4gICAgICAgIGlmIChpc05vZGVJbmplY3RlZFRleHQobm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2luamVjdGVkVGV4dERlY29yYXRpb25zVHJlZS5pbnNlcnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOb2RlSW5PdmVydmlld1J1bGVyKG5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUxLmluc2VydChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RlY29yYXRpb25zVHJlZTAuaW5zZXJ0KG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZShub2RlKSB7XG4gICAgICAgIGlmIChpc05vZGVJbmplY3RlZFRleHQobm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2luamVjdGVkVGV4dERlY29yYXRpb25zVHJlZS5kZWxldGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOb2RlSW5PdmVydmlld1J1bGVyKG5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUxLmRlbGV0ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RlY29yYXRpb25zVHJlZTAuZGVsZXRlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5vZGVSYW5nZShob3N0LCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb25JZCA9IGhvc3QuZ2V0VmVyc2lvbklkKCk7XG4gICAgICAgIGlmIChub2RlLmNhY2hlZFZlcnNpb25JZCAhPT0gdmVyc2lvbklkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlTm9kZShub2RlLCB2ZXJzaW9uSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLnJhbmdlID0gaG9zdC5nZXRSYW5nZUF0KG5vZGUuY2FjaGVkQWJzb2x1dGVTdGFydCwgbm9kZS5jYWNoZWRBYnNvbHV0ZUVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUucmFuZ2U7XG4gICAgfVxuICAgIF9yZXNvbHZlTm9kZShub2RlLCBjYWNoZWRWZXJzaW9uSWQpIHtcbiAgICAgICAgaWYgKGlzTm9kZUluamVjdGVkVGV4dChub2RlKSkge1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0ZWRUZXh0RGVjb3JhdGlvbnNUcmVlLnJlc29sdmVOb2RlKG5vZGUsIGNhY2hlZFZlcnNpb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOb2RlSW5PdmVydmlld1J1bGVyKG5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUxLnJlc29sdmVOb2RlKG5vZGUsIGNhY2hlZFZlcnNpb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUwLnJlc29sdmVOb2RlKG5vZGUsIGNhY2hlZFZlcnNpb25JZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWNjZXB0UmVwbGFjZShvZmZzZXQsIGxlbmd0aCwgdGV4dExlbmd0aCwgZm9yY2VNb3ZlTWFya2Vycykge1xuICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUwLmFjY2VwdFJlcGxhY2Uob2Zmc2V0LCBsZW5ndGgsIHRleHRMZW5ndGgsIGZvcmNlTW92ZU1hcmtlcnMpO1xuICAgICAgICB0aGlzLl9kZWNvcmF0aW9uc1RyZWUxLmFjY2VwdFJlcGxhY2Uob2Zmc2V0LCBsZW5ndGgsIHRleHRMZW5ndGgsIGZvcmNlTW92ZU1hcmtlcnMpO1xuICAgICAgICB0aGlzLl9pbmplY3RlZFRleHREZWNvcmF0aW9uc1RyZWUuYWNjZXB0UmVwbGFjZShvZmZzZXQsIGxlbmd0aCwgdGV4dExlbmd0aCwgZm9yY2VNb3ZlTWFya2Vycyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xlYW5DbGFzc05hbWUoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIGNsYXNzTmFtZS5yZXBsYWNlKC9bXmEtejAtOVxcLV9dL2dpLCAnICcpO1xufVxuY2xhc3MgRGVjb3JhdGlvbk9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3IgfHwgJyc7XG4gICAgICAgIHRoaXMuZGFya0NvbG9yID0gb3B0aW9ucy5kYXJrQ29sb3IgfHwgJyc7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1vZGVsRGVjb3JhdGlvbk92ZXJ2aWV3UnVsZXJPcHRpb25zIGV4dGVuZHMgRGVjb3JhdGlvbk9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkQ29sb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gKHR5cGVvZiBvcHRpb25zLnBvc2l0aW9uID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucG9zaXRpb24gOiBtb2RlbC5PdmVydmlld1J1bGVyTGFuZS5DZW50ZXIpO1xuICAgIH1cbiAgICBnZXRDb2xvcih0aGVtZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc29sdmVkQ29sb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGVtZS50eXBlICE9PSAnbGlnaHQnICYmIHRoaXMuZGFya0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRDb2xvciA9IHRoaXMuX3Jlc29sdmVDb2xvcih0aGlzLmRhcmtDb2xvciwgdGhlbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRDb2xvciA9IHRoaXMuX3Jlc29sdmVDb2xvcih0aGlzLmNvbG9yLCB0aGVtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkQ29sb3I7XG4gICAgfVxuICAgIGludmFsaWRhdGVDYWNoZWRDb2xvcigpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWRDb2xvciA9IG51bGw7XG4gICAgfVxuICAgIF9yZXNvbHZlQ29sb3IoY29sb3IsIHRoZW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IGNvbG9yID8gdGhlbWUuZ2V0Q29sb3IoY29sb3IuaWQpIDogbnVsbDtcbiAgICAgICAgaWYgKCFjKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGMudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTW9kZWxEZWNvcmF0aW9uR2x5cGhNYXJnaW5PcHRpb25zIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBvcHRpb25zPy5wb3NpdGlvbiA/PyBtb2RlbC5HbHlwaE1hcmdpbkxhbmUuQ2VudGVyO1xuICAgICAgICB0aGlzLnBlcnNpc3RMYW5lID0gb3B0aW9ucz8ucGVyc2lzdExhbmU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1vZGVsRGVjb3JhdGlvbk1pbmltYXBPcHRpb25zIGV4dGVuZHMgRGVjb3JhdGlvbk9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLnNlY3Rpb25IZWFkZXJTdHlsZSA9IG9wdGlvbnMuc2VjdGlvbkhlYWRlclN0eWxlID8/IG51bGw7XG4gICAgICAgIHRoaXMuc2VjdGlvbkhlYWRlclRleHQgPSBvcHRpb25zLnNlY3Rpb25IZWFkZXJUZXh0ID8/IG51bGw7XG4gICAgfVxuICAgIGdldENvbG9yKHRoZW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzb2x2ZWRDb2xvcikge1xuICAgICAgICAgICAgaWYgKHRoZW1lLnR5cGUgIT09ICdsaWdodCcgJiYgdGhpcy5kYXJrQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlZENvbG9yID0gdGhpcy5fcmVzb2x2ZUNvbG9yKHRoaXMuZGFya0NvbG9yLCB0aGVtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlZENvbG9yID0gdGhpcy5fcmVzb2x2ZUNvbG9yKHRoaXMuY29sb3IsIHRoZW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRDb2xvcjtcbiAgICB9XG4gICAgaW52YWxpZGF0ZUNhY2hlZENvbG9yKCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlZENvbG9yID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfcmVzb2x2ZUNvbG9yKGNvbG9yLCB0aGVtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVtZS5nZXRDb2xvcihjb2xvci5pZCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1vZGVsRGVjb3JhdGlvbkluamVjdGVkVGV4dE9wdGlvbnMge1xuICAgIHN0YXRpYyBmcm9tKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBNb2RlbERlY29yYXRpb25JbmplY3RlZFRleHRPcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1vZGVsRGVjb3JhdGlvbkluamVjdGVkVGV4dE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gb3B0aW9ucy5jb250ZW50IHx8ICcnO1xuICAgICAgICB0aGlzLmlubGluZUNsYXNzTmFtZSA9IG9wdGlvbnMuaW5saW5lQ2xhc3NOYW1lIHx8IG51bGw7XG4gICAgICAgIHRoaXMuaW5saW5lQ2xhc3NOYW1lQWZmZWN0c0xldHRlclNwYWNpbmcgPSBvcHRpb25zLmlubGluZUNsYXNzTmFtZUFmZmVjdHNMZXR0ZXJTcGFjaW5nIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmF0dGFjaGVkRGF0YSA9IG9wdGlvbnMuYXR0YWNoZWREYXRhIHx8IG51bGw7XG4gICAgICAgIHRoaXMuY3Vyc29yU3RvcHMgPSBvcHRpb25zLmN1cnNvclN0b3BzIHx8IG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1vZGVsRGVjb3JhdGlvbk9wdGlvbnMge1xuICAgIHN0YXRpYyByZWdpc3RlcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9kZWxEZWNvcmF0aW9uT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUR5bmFtaWMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1vZGVsRGVjb3JhdGlvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuYmxvY2tDbGFzc05hbWUgPSBvcHRpb25zLmJsb2NrQ2xhc3NOYW1lID8gY2xlYW5DbGFzc05hbWUob3B0aW9ucy5ibG9ja0NsYXNzTmFtZSkgOiBudWxsO1xuICAgICAgICB0aGlzLmJsb2NrRG9lc05vdENvbGxhcHNlID0gb3B0aW9ucy5ibG9ja0RvZXNOb3RDb2xsYXBzZSA/PyBudWxsO1xuICAgICAgICB0aGlzLmJsb2NrSXNBZnRlckVuZCA9IG9wdGlvbnMuYmxvY2tJc0FmdGVyRW5kID8/IG51bGw7XG4gICAgICAgIHRoaXMuYmxvY2tQYWRkaW5nID0gb3B0aW9ucy5ibG9ja1BhZGRpbmcgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5zdGlja2luZXNzID0gb3B0aW9ucy5zdGlja2luZXNzIHx8IDAgLyogbW9kZWwuVHJhY2tlZFJhbmdlU3RpY2tpbmVzcy5BbHdheXNHcm93c1doZW5UeXBpbmdBdEVkZ2VzICovO1xuICAgICAgICB0aGlzLnpJbmRleCA9IG9wdGlvbnMuekluZGV4IHx8IDA7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gb3B0aW9ucy5jbGFzc05hbWUgPyBjbGVhbkNsYXNzTmFtZShvcHRpb25zLmNsYXNzTmFtZSkgOiBudWxsO1xuICAgICAgICB0aGlzLnNob3VsZEZpbGxMaW5lT25MaW5lQnJlYWsgPSBvcHRpb25zLnNob3VsZEZpbGxMaW5lT25MaW5lQnJlYWsgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5ob3Zlck1lc3NhZ2UgPSBvcHRpb25zLmhvdmVyTWVzc2FnZSB8fCBudWxsO1xuICAgICAgICB0aGlzLmdseXBoTWFyZ2luSG92ZXJNZXNzYWdlID0gb3B0aW9ucy5nbHlwaE1hcmdpbkhvdmVyTWVzc2FnZSB8fCBudWxsO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXJIb3Zlck1lc3NhZ2UgPSBvcHRpb25zLmxpbmVOdW1iZXJIb3Zlck1lc3NhZ2UgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5pc1dob2xlTGluZSA9IG9wdGlvbnMuaXNXaG9sZUxpbmUgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvd0lmQ29sbGFwc2VkID0gb3B0aW9ucy5zaG93SWZDb2xsYXBzZWQgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuY29sbGFwc2VPblJlcGxhY2VFZGl0ID0gb3B0aW9ucy5jb2xsYXBzZU9uUmVwbGFjZUVkaXQgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMub3ZlcnZpZXdSdWxlciA9IG9wdGlvbnMub3ZlcnZpZXdSdWxlciA/IG5ldyBNb2RlbERlY29yYXRpb25PdmVydmlld1J1bGVyT3B0aW9ucyhvcHRpb25zLm92ZXJ2aWV3UnVsZXIpIDogbnVsbDtcbiAgICAgICAgdGhpcy5taW5pbWFwID0gb3B0aW9ucy5taW5pbWFwID8gbmV3IE1vZGVsRGVjb3JhdGlvbk1pbmltYXBPcHRpb25zKG9wdGlvbnMubWluaW1hcCkgOiBudWxsO1xuICAgICAgICB0aGlzLmdseXBoTWFyZ2luID0gb3B0aW9ucy5nbHlwaE1hcmdpbkNsYXNzTmFtZSA/IG5ldyBNb2RlbERlY29yYXRpb25HbHlwaE1hcmdpbk9wdGlvbnMob3B0aW9ucy5nbHlwaE1hcmdpbikgOiBudWxsO1xuICAgICAgICB0aGlzLmdseXBoTWFyZ2luQ2xhc3NOYW1lID0gb3B0aW9ucy5nbHlwaE1hcmdpbkNsYXNzTmFtZSA/IGNsZWFuQ2xhc3NOYW1lKG9wdGlvbnMuZ2x5cGhNYXJnaW5DbGFzc05hbWUpIDogbnVsbDtcbiAgICAgICAgdGhpcy5saW5lc0RlY29yYXRpb25zQ2xhc3NOYW1lID0gb3B0aW9ucy5saW5lc0RlY29yYXRpb25zQ2xhc3NOYW1lID8gY2xlYW5DbGFzc05hbWUob3B0aW9ucy5saW5lc0RlY29yYXRpb25zQ2xhc3NOYW1lKSA6IG51bGw7XG4gICAgICAgIHRoaXMubGluZU51bWJlckNsYXNzTmFtZSA9IG9wdGlvbnMubGluZU51bWJlckNsYXNzTmFtZSA/IGNsZWFuQ2xhc3NOYW1lKG9wdGlvbnMubGluZU51bWJlckNsYXNzTmFtZSkgOiBudWxsO1xuICAgICAgICB0aGlzLmxpbmVzRGVjb3JhdGlvbnNUb29sdGlwID0gb3B0aW9ucy5saW5lc0RlY29yYXRpb25zVG9vbHRpcCA/IHN0cmluZ3MuaHRtbEF0dHJpYnV0ZUVuY29kZVZhbHVlKG9wdGlvbnMubGluZXNEZWNvcmF0aW9uc1Rvb2x0aXApIDogbnVsbDtcbiAgICAgICAgdGhpcy5maXJzdExpbmVEZWNvcmF0aW9uQ2xhc3NOYW1lID0gb3B0aW9ucy5maXJzdExpbmVEZWNvcmF0aW9uQ2xhc3NOYW1lID8gY2xlYW5DbGFzc05hbWUob3B0aW9ucy5maXJzdExpbmVEZWNvcmF0aW9uQ2xhc3NOYW1lKSA6IG51bGw7XG4gICAgICAgIHRoaXMubWFyZ2luQ2xhc3NOYW1lID0gb3B0aW9ucy5tYXJnaW5DbGFzc05hbWUgPyBjbGVhbkNsYXNzTmFtZShvcHRpb25zLm1hcmdpbkNsYXNzTmFtZSkgOiBudWxsO1xuICAgICAgICB0aGlzLmlubGluZUNsYXNzTmFtZSA9IG9wdGlvbnMuaW5saW5lQ2xhc3NOYW1lID8gY2xlYW5DbGFzc05hbWUob3B0aW9ucy5pbmxpbmVDbGFzc05hbWUpIDogbnVsbDtcbiAgICAgICAgdGhpcy5pbmxpbmVDbGFzc05hbWVBZmZlY3RzTGV0dGVyU3BhY2luZyA9IG9wdGlvbnMuaW5saW5lQ2xhc3NOYW1lQWZmZWN0c0xldHRlclNwYWNpbmcgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuYmVmb3JlQ29udGVudENsYXNzTmFtZSA9IG9wdGlvbnMuYmVmb3JlQ29udGVudENsYXNzTmFtZSA/IGNsZWFuQ2xhc3NOYW1lKG9wdGlvbnMuYmVmb3JlQ29udGVudENsYXNzTmFtZSkgOiBudWxsO1xuICAgICAgICB0aGlzLmFmdGVyQ29udGVudENsYXNzTmFtZSA9IG9wdGlvbnMuYWZ0ZXJDb250ZW50Q2xhc3NOYW1lID8gY2xlYW5DbGFzc05hbWUob3B0aW9ucy5hZnRlckNvbnRlbnRDbGFzc05hbWUpIDogbnVsbDtcbiAgICAgICAgdGhpcy5hZnRlciA9IG9wdGlvbnMuYWZ0ZXIgPyBNb2RlbERlY29yYXRpb25JbmplY3RlZFRleHRPcHRpb25zLmZyb20ob3B0aW9ucy5hZnRlcikgOiBudWxsO1xuICAgICAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlID8gTW9kZWxEZWNvcmF0aW9uSW5qZWN0ZWRUZXh0T3B0aW9ucy5mcm9tKG9wdGlvbnMuYmVmb3JlKSA6IG51bGw7XG4gICAgICAgIHRoaXMuaGlkZUluQ29tbWVudFRva2VucyA9IG9wdGlvbnMuaGlkZUluQ29tbWVudFRva2VucyA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRlSW5TdHJpbmdUb2tlbnMgPSBvcHRpb25zLmhpZGVJblN0cmluZ1Rva2VucyA/PyBmYWxzZTtcbiAgICB9XG59XG5Nb2RlbERlY29yYXRpb25PcHRpb25zLkVNUFRZID0gTW9kZWxEZWNvcmF0aW9uT3B0aW9ucy5yZWdpc3Rlcih7IGRlc2NyaXB0aW9uOiAnZW1wdHknIH0pO1xuLyoqXG4gKiBUaGUgb3JkZXIgY2FyZWZ1bGx5IG1hdGNoZXMgdGhlIHZhbHVlcyBvZiB0aGUgZW51bS5cbiAqL1xuY29uc3QgVFJBQ0tFRF9SQU5HRV9PUFRJT05TID0gW1xuICAgIE1vZGVsRGVjb3JhdGlvbk9wdGlvbnMucmVnaXN0ZXIoeyBkZXNjcmlwdGlvbjogJ3RyYWNrZWQtcmFuZ2UtYWx3YXlzLWdyb3dzLXdoZW4tdHlwaW5nLWF0LWVkZ2VzJywgc3RpY2tpbmVzczogMCAvKiBtb2RlbC5UcmFja2VkUmFuZ2VTdGlja2luZXNzLkFsd2F5c0dyb3dzV2hlblR5cGluZ0F0RWRnZXMgKi8gfSksXG4gICAgTW9kZWxEZWNvcmF0aW9uT3B0aW9ucy5yZWdpc3Rlcih7IGRlc2NyaXB0aW9uOiAndHJhY2tlZC1yYW5nZS1uZXZlci1ncm93cy13aGVuLXR5cGluZy1hdC1lZGdlcycsIHN0aWNraW5lc3M6IDEgLyogbW9kZWwuVHJhY2tlZFJhbmdlU3RpY2tpbmVzcy5OZXZlckdyb3dzV2hlblR5cGluZ0F0RWRnZXMgKi8gfSksXG4gICAgTW9kZWxEZWNvcmF0aW9uT3B0aW9ucy5yZWdpc3Rlcih7IGRlc2NyaXB0aW9uOiAndHJhY2tlZC1yYW5nZS1ncm93cy1vbmx5LXdoZW4tdHlwaW5nLWJlZm9yZScsIHN0aWNraW5lc3M6IDIgLyogbW9kZWwuVHJhY2tlZFJhbmdlU3RpY2tpbmVzcy5Hcm93c09ubHlXaGVuVHlwaW5nQmVmb3JlICovIH0pLFxuICAgIE1vZGVsRGVjb3JhdGlvbk9wdGlvbnMucmVnaXN0ZXIoeyBkZXNjcmlwdGlvbjogJ3RyYWNrZWQtcmFuZ2UtZ3Jvd3Mtb25seS13aGVuLXR5cGluZy1hZnRlcicsIHN0aWNraW5lc3M6IDMgLyogbW9kZWwuVHJhY2tlZFJhbmdlU3RpY2tpbmVzcy5Hcm93c09ubHlXaGVuVHlwaW5nQWZ0ZXIgKi8gfSksXG5dO1xuZnVuY3Rpb24gX25vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgTW9kZWxEZWNvcmF0aW9uT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIE1vZGVsRGVjb3JhdGlvbk9wdGlvbnMuY3JlYXRlRHluYW1pYyhvcHRpb25zKTtcbn1cbmNsYXNzIERpZENoYW5nZURlY29yYXRpb25zRW1pdHRlciBleHRlbmRzIERpc3Bvc2FibGUge1xuICAgIGNvbnN0cnVjdG9yKGhhbmRsZUJlZm9yZUZpcmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVCZWZvcmVGaXJlID0gaGFuZGxlQmVmb3JlRmlyZTtcbiAgICAgICAgdGhpcy5fYWN0dWFsID0gdGhpcy5fcmVnaXN0ZXIobmV3IEVtaXR0ZXIoKSk7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0aGlzLl9hY3R1YWwuZXZlbnQ7XG4gICAgICAgIHRoaXMuX2FmZmVjdGVkSW5qZWN0ZWRUZXh0TGluZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWZlcnJlZENudCA9IDA7XG4gICAgICAgIHRoaXMuX3Nob3VsZEZpcmVEZWZlcnJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hZmZlY3RzTWluaW1hcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hZmZlY3RzT3ZlcnZpZXdSdWxlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hZmZlY3RzR2x5cGhNYXJnaW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWZmZWN0c0xpbmVOdW1iZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgYmVnaW5EZWZlcnJlZEVtaXQoKSB7XG4gICAgICAgIHRoaXMuX2RlZmVycmVkQ250Kys7XG4gICAgfVxuICAgIGVuZERlZmVycmVkRW1pdCgpIHtcbiAgICAgICAgdGhpcy5fZGVmZXJyZWRDbnQtLTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZmVycmVkQ250ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkRmlyZURlZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0ZpcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FmZmVjdGVkSW5qZWN0ZWRUZXh0TGluZXM/LmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl9hZmZlY3RlZEluamVjdGVkVGV4dExpbmVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWNvcmRMaW5lQWZmZWN0ZWRCeUluamVjdGVkVGV4dChsaW5lTnVtYmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYWZmZWN0ZWRJbmplY3RlZFRleHRMaW5lcykge1xuICAgICAgICAgICAgdGhpcy5fYWZmZWN0ZWRJbmplY3RlZFRleHRMaW5lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZmZlY3RlZEluamVjdGVkVGV4dExpbmVzLmFkZChsaW5lTnVtYmVyKTtcbiAgICB9XG4gICAgY2hlY2tBZmZlY3RlZEFuZEZpcmUob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9hZmZlY3RzTWluaW1hcCB8fD0gISFvcHRpb25zLm1pbmltYXA/LnBvc2l0aW9uO1xuICAgICAgICB0aGlzLl9hZmZlY3RzT3ZlcnZpZXdSdWxlciB8fD0gISFvcHRpb25zLm92ZXJ2aWV3UnVsZXI/LmNvbG9yO1xuICAgICAgICB0aGlzLl9hZmZlY3RzR2x5cGhNYXJnaW4gfHw9ICEhb3B0aW9ucy5nbHlwaE1hcmdpbkNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5fYWZmZWN0c0xpbmVOdW1iZXIgfHw9ICEhb3B0aW9ucy5saW5lTnVtYmVyQ2xhc3NOYW1lO1xuICAgICAgICB0aGlzLnRyeUZpcmUoKTtcbiAgICB9XG4gICAgZmlyZSgpIHtcbiAgICAgICAgdGhpcy5fYWZmZWN0c01pbmltYXAgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hZmZlY3RzT3ZlcnZpZXdSdWxlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2FmZmVjdHNHbHlwaE1hcmdpbiA9IHRydWU7XG4gICAgICAgIHRoaXMudHJ5RmlyZSgpO1xuICAgIH1cbiAgICB0cnlGaXJlKCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmZXJyZWRDbnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZG9GaXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zaG91bGRGaXJlRGVmZXJyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvRmlyZSgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVCZWZvcmVGaXJlKHRoaXMuX2FmZmVjdGVkSW5qZWN0ZWRUZXh0TGluZXMpO1xuICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgIGFmZmVjdHNNaW5pbWFwOiB0aGlzLl9hZmZlY3RzTWluaW1hcCxcbiAgICAgICAgICAgIGFmZmVjdHNPdmVydmlld1J1bGVyOiB0aGlzLl9hZmZlY3RzT3ZlcnZpZXdSdWxlcixcbiAgICAgICAgICAgIGFmZmVjdHNHbHlwaE1hcmdpbjogdGhpcy5fYWZmZWN0c0dseXBoTWFyZ2luLFxuICAgICAgICAgICAgYWZmZWN0c0xpbmVOdW1iZXI6IHRoaXMuX2FmZmVjdHNMaW5lTnVtYmVyLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zaG91bGRGaXJlRGVmZXJyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWZmZWN0c01pbmltYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWZmZWN0c092ZXJ2aWV3UnVsZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWZmZWN0c0dseXBoTWFyZ2luID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FjdHVhbC5maXJlKGV2ZW50KTtcbiAgICB9XG59XG4vLyNlbmRyZWdpb25cbmNsYXNzIERpZENoYW5nZUNvbnRlbnRFbWl0dGVyIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3RoIGBmYXN0RXZlbnRgIGFuZCBgc2xvd0V2ZW50YCB3b3JrIHRoZSBzYW1lIHdheSBhbmQgY29udGFpbiB0aGUgc2FtZSBldmVudHMsIGJ1dCBmaXJzdCB3ZSBpbnZva2UgYGZhc3RFdmVudGAgYW5kIHRoZW4gYHNsb3dFdmVudGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9mYXN0RW1pdHRlciA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBFbWl0dGVyKCkpO1xuICAgICAgICB0aGlzLmZhc3RFdmVudCA9IHRoaXMuX2Zhc3RFbWl0dGVyLmV2ZW50O1xuICAgICAgICB0aGlzLl9zbG93RW1pdHRlciA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBFbWl0dGVyKCkpO1xuICAgICAgICB0aGlzLnNsb3dFdmVudCA9IHRoaXMuX3Nsb3dFbWl0dGVyLmV2ZW50O1xuICAgICAgICB0aGlzLl9kZWZlcnJlZENudCA9IDA7XG4gICAgICAgIHRoaXMuX2RlZmVycmVkRXZlbnQgPSBudWxsO1xuICAgIH1cbiAgICBiZWdpbkRlZmVycmVkRW1pdCgpIHtcbiAgICAgICAgdGhpcy5fZGVmZXJyZWRDbnQrKztcbiAgICB9XG4gICAgZW5kRGVmZXJyZWRFbWl0KHJlc3VsdGluZ1NlbGVjdGlvbiA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZGVmZXJyZWRDbnQtLTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZmVycmVkQ250ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmZXJyZWRFdmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmVycmVkRXZlbnQucmF3Q29udGVudENoYW5nZWRFdmVudC5yZXN1bHRpbmdTZWxlY3Rpb24gPSByZXN1bHRpbmdTZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMuX2RlZmVycmVkRXZlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmZXJyZWRFdmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmFzdEVtaXR0ZXIuZmlyZShlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zbG93RW1pdHRlci5maXJlKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpcmUoZSkge1xuICAgICAgICBpZiAodGhpcy5fZGVmZXJyZWRDbnQgPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmZXJyZWRFdmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmVycmVkRXZlbnQgPSB0aGlzLl9kZWZlcnJlZEV2ZW50Lm1lcmdlKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmZXJyZWRFdmVudCA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmFzdEVtaXR0ZXIuZmlyZShlKTtcbiAgICAgICAgdGhpcy5fc2xvd0VtaXR0ZXIuZmlyZShlKTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9saWZlY3ljbGUuanMnO1xuZXhwb3J0IGNsYXNzIFRleHRNb2RlbFBhcnQgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICBhc3NlcnROb3REaXNwb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dE1vZGVsUGFydCBpcyBkaXNwb3NlZCEnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgcnVuV2hlbkdsb2JhbElkbGUgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9hc3luYy5qcyc7XG5pbXBvcnQgeyBCdWdJbmRpY2F0aW5nRXJyb3IsIG9uVW5leHBlY3RlZEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZXJyb3JzLmpzJztcbmltcG9ydCB7IHNldFRpbWVvdXQwIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vcGxhdGZvcm0uanMnO1xuaW1wb3J0IHsgU3RvcFdhdGNoIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RvcHdhdGNoLmpzJztcbmltcG9ydCB7IGNvdW50RU9MIH0gZnJvbSAnLi4vY29yZS9lb2xDb3VudGVyLmpzJztcbmltcG9ydCB7IExpbmVSYW5nZSB9IGZyb20gJy4uL2NvcmUvbGluZVJhbmdlLmpzJztcbmltcG9ydCB7IE9mZnNldFJhbmdlIH0gZnJvbSAnLi4vY29yZS9vZmZzZXRSYW5nZS5qcyc7XG5pbXBvcnQgeyBudWxsVG9rZW5pemVFbmNvZGVkIH0gZnJvbSAnLi4vbGFuZ3VhZ2VzL251bGxUb2tlbml6ZS5qcyc7XG5pbXBvcnQgeyBGaXhlZEFycmF5IH0gZnJvbSAnLi9maXhlZEFycmF5LmpzJztcbmltcG9ydCB7IENvbnRpZ3VvdXNNdWx0aWxpbmVUb2tlbnNCdWlsZGVyIH0gZnJvbSAnLi4vdG9rZW5zL2NvbnRpZ3VvdXNNdWx0aWxpbmVUb2tlbnNCdWlsZGVyLmpzJztcbmltcG9ydCB7IExpbmVUb2tlbnMgfSBmcm9tICcuLi90b2tlbnMvbGluZVRva2Vucy5qcyc7XG5leHBvcnQgY2xhc3MgVG9rZW5pemVyV2l0aFN0YXRlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVDb3VudCwgdG9rZW5pemF0aW9uU3VwcG9ydCkge1xuICAgICAgICB0aGlzLnRva2VuaXphdGlvblN1cHBvcnQgPSB0b2tlbml6YXRpb25TdXBwb3J0O1xuICAgICAgICB0aGlzLmluaXRpYWxTdGF0ZSA9IHRoaXMudG9rZW5pemF0aW9uU3VwcG9ydC5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBUcmFja2luZ1Rva2VuaXphdGlvblN0YXRlU3RvcmUobGluZUNvdW50KTtcbiAgICB9XG4gICAgZ2V0U3RhcnRTdGF0ZShsaW5lTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXJ0U3RhdGUobGluZU51bWJlciwgdGhpcy5pbml0aWFsU3RhdGUpO1xuICAgIH1cbiAgICBnZXRGaXJzdEludmFsaWRMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRGaXJzdEludmFsaWRMaW5lKHRoaXMuaW5pdGlhbFN0YXRlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVG9rZW5pemVyV2l0aFN0YXRlU3RvcmVBbmRUZXh0TW9kZWwgZXh0ZW5kcyBUb2tlbml6ZXJXaXRoU3RhdGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IobGluZUNvdW50LCB0b2tlbml6YXRpb25TdXBwb3J0LCBfdGV4dE1vZGVsLCBfbGFuZ3VhZ2VJZENvZGVjKSB7XG4gICAgICAgIHN1cGVyKGxpbmVDb3VudCwgdG9rZW5pemF0aW9uU3VwcG9ydCk7XG4gICAgICAgIHRoaXMuX3RleHRNb2RlbCA9IF90ZXh0TW9kZWw7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWRDb2RlYyA9IF9sYW5ndWFnZUlkQ29kZWM7XG4gICAgfVxuICAgIHVwZGF0ZVRva2Vuc1VudGlsTGluZShidWlsZGVyLCBsaW5lTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGxhbmd1YWdlSWQgPSB0aGlzLl90ZXh0TW9kZWwuZ2V0TGFuZ3VhZ2VJZCgpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbGluZVRvVG9rZW5pemUgPSB0aGlzLmdldEZpcnN0SW52YWxpZExpbmUoKTtcbiAgICAgICAgICAgIGlmICghbGluZVRvVG9rZW5pemUgfHwgbGluZVRvVG9rZW5pemUubGluZU51bWJlciA+IGxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLl90ZXh0TW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZVRvVG9rZW5pemUubGluZU51bWJlcik7XG4gICAgICAgICAgICBjb25zdCByID0gc2FmZVRva2VuaXplKHRoaXMuX2xhbmd1YWdlSWRDb2RlYywgbGFuZ3VhZ2VJZCwgdGhpcy50b2tlbml6YXRpb25TdXBwb3J0LCB0ZXh0LCB0cnVlLCBsaW5lVG9Ub2tlbml6ZS5zdGFydFN0YXRlKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGxpbmVUb1Rva2VuaXplLmxpbmVOdW1iZXIsIHIudG9rZW5zKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuc2V0RW5kU3RhdGUobGluZVRvVG9rZW5pemUubGluZU51bWJlciwgci5lbmRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGFzc3VtZXMgc3RhdGUgaXMgdXAgdG8gZGF0ZSAqL1xuICAgIGdldFRva2VuVHlwZUlmSW5zZXJ0aW5nQ2hhcmFjdGVyKHBvc2l0aW9uLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgLy8gVE9ET0BoZWRpZXQ6IHVzZSB0b2tlbml6ZUxpbmVXaXRoRWRpdFxuICAgICAgICBjb25zdCBsaW5lU3RhcnRTdGF0ZSA9IHRoaXMuZ2V0U3RhcnRTdGF0ZShwb3NpdGlvbi5saW5lTnVtYmVyKTtcbiAgICAgICAgaWYgKCFsaW5lU3RhcnRTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogU3RhbmRhcmRUb2tlblR5cGUuT3RoZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VJZCA9IHRoaXMuX3RleHRNb2RlbC5nZXRMYW5ndWFnZUlkKCk7XG4gICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gdGhpcy5fdGV4dE1vZGVsLmdldExpbmVDb250ZW50KHBvc2l0aW9uLmxpbmVOdW1iZXIpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIHRleHQgYXMgaWYgYGNoYXJhY3RlcmAgd2FzIGluc2VydGVkXG4gICAgICAgIGNvbnN0IHRleHQgPSAobGluZUNvbnRlbnQuc3Vic3RyaW5nKDAsIHBvc2l0aW9uLmNvbHVtbiAtIDEpXG4gICAgICAgICAgICArIGNoYXJhY3RlclxuICAgICAgICAgICAgKyBsaW5lQ29udGVudC5zdWJzdHJpbmcocG9zaXRpb24uY29sdW1uIC0gMSkpO1xuICAgICAgICBjb25zdCByID0gc2FmZVRva2VuaXplKHRoaXMuX2xhbmd1YWdlSWRDb2RlYywgbGFuZ3VhZ2VJZCwgdGhpcy50b2tlbml6YXRpb25TdXBwb3J0LCB0ZXh0LCB0cnVlLCBsaW5lU3RhcnRTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGxpbmVUb2tlbnMgPSBuZXcgTGluZVRva2VucyhyLnRva2VucywgdGV4dCwgdGhpcy5fbGFuZ3VhZ2VJZENvZGVjKTtcbiAgICAgICAgaWYgKGxpbmVUb2tlbnMuZ2V0Q291bnQoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogU3RhbmRhcmRUb2tlblR5cGUuT3RoZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW5JbmRleCA9IGxpbmVUb2tlbnMuZmluZFRva2VuSW5kZXhBdE9mZnNldChwb3NpdGlvbi5jb2x1bW4gLSAxKTtcbiAgICAgICAgcmV0dXJuIGxpbmVUb2tlbnMuZ2V0U3RhbmRhcmRUb2tlblR5cGUodG9rZW5JbmRleCk7XG4gICAgfVxuICAgIC8qKiBhc3N1bWVzIHN0YXRlIGlzIHVwIHRvIGRhdGUgKi9cbiAgICB0b2tlbml6ZUxpbmVXaXRoRWRpdChwb3NpdGlvbiwgbGVuZ3RoLCBuZXdUZXh0KSB7XG4gICAgICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBwb3NpdGlvbi5saW5lTnVtYmVyO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBwb3NpdGlvbi5jb2x1bW47XG4gICAgICAgIGNvbnN0IGxpbmVTdGFydFN0YXRlID0gdGhpcy5nZXRTdGFydFN0YXRlKGxpbmVOdW1iZXIpO1xuICAgICAgICBpZiAoIWxpbmVTdGFydFN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJMaW5lQ29udGVudCA9IHRoaXMuX3RleHRNb2RlbC5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgbmV3TGluZUNvbnRlbnQgPSBjdXJMaW5lQ29udGVudC5zdWJzdHJpbmcoMCwgY29sdW1uIC0gMSlcbiAgICAgICAgICAgICsgbmV3VGV4dCArIGN1ckxpbmVDb250ZW50LnN1YnN0cmluZyhjb2x1bW4gLSAxICsgbGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VJZCA9IHRoaXMuX3RleHRNb2RlbC5nZXRMYW5ndWFnZUlkQXRQb3NpdGlvbihsaW5lTnVtYmVyLCAwKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2FmZVRva2VuaXplKHRoaXMuX2xhbmd1YWdlSWRDb2RlYywgbGFuZ3VhZ2VJZCwgdGhpcy50b2tlbml6YXRpb25TdXBwb3J0LCBuZXdMaW5lQ29udGVudCwgdHJ1ZSwgbGluZVN0YXJ0U3RhdGUpO1xuICAgICAgICBjb25zdCBsaW5lVG9rZW5zID0gbmV3IExpbmVUb2tlbnMocmVzdWx0LnRva2VucywgbmV3TGluZUNvbnRlbnQsIHRoaXMuX2xhbmd1YWdlSWRDb2RlYyk7XG4gICAgICAgIHJldHVybiBsaW5lVG9rZW5zO1xuICAgIH1cbiAgICBoYXNBY2N1cmF0ZVRva2Vuc0ZvckxpbmUobGluZU51bWJlcikge1xuICAgICAgICBjb25zdCBmaXJzdEludmFsaWRMaW5lTnVtYmVyID0gdGhpcy5zdG9yZS5nZXRGaXJzdEludmFsaWRFbmRTdGF0ZUxpbmVOdW1iZXJPck1heCgpO1xuICAgICAgICByZXR1cm4gKGxpbmVOdW1iZXIgPCBmaXJzdEludmFsaWRMaW5lTnVtYmVyKTtcbiAgICB9XG4gICAgaXNDaGVhcFRvVG9rZW5pemUobGluZU51bWJlcikge1xuICAgICAgICBjb25zdCBmaXJzdEludmFsaWRMaW5lTnVtYmVyID0gdGhpcy5zdG9yZS5nZXRGaXJzdEludmFsaWRFbmRTdGF0ZUxpbmVOdW1iZXJPck1heCgpO1xuICAgICAgICBpZiAobGluZU51bWJlciA8IGZpcnN0SW52YWxpZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lTnVtYmVyID09PSBmaXJzdEludmFsaWRMaW5lTnVtYmVyXG4gICAgICAgICAgICAmJiB0aGlzLl90ZXh0TW9kZWwuZ2V0TGluZUxlbmd0aChsaW5lTnVtYmVyKSA8IDIwNDggLyogQ29uc3RhbnRzLkNIRUFQX1RPS0VOSVpBVElPTl9MRU5HVEhfTElNSVQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdCBpcyBub3QgY2FjaGVkLlxuICAgICAqL1xuICAgIHRva2VuaXplSGV1cmlzdGljYWxseShidWlsZGVyLCBzdGFydExpbmVOdW1iZXIsIGVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgaWYgKGVuZExpbmVOdW1iZXIgPD0gdGhpcy5zdG9yZS5nZXRGaXJzdEludmFsaWRFbmRTdGF0ZUxpbmVOdW1iZXJPck1heCgpKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm4geyBoZXVyaXN0aWNUb2tlbnM6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0TGluZU51bWJlciA8PSB0aGlzLnN0b3JlLmdldEZpcnN0SW52YWxpZEVuZFN0YXRlTGluZU51bWJlck9yTWF4KCkpIHtcbiAgICAgICAgICAgIC8vIHRva2VuaXphdGlvbiBoYXMgcmVhY2hlZCB0aGUgdmlld3BvcnQgc3RhcnQuLi5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9rZW5zVW50aWxMaW5lKGJ1aWxkZXIsIGVuZExpbmVOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgaGV1cmlzdGljVG9rZW5zOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ3Vlc3NTdGFydFN0YXRlKHN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IGxhbmd1YWdlSWQgPSB0aGlzLl90ZXh0TW9kZWwuZ2V0TGFuZ3VhZ2VJZCgpO1xuICAgICAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gc3RhcnRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyIDw9IGVuZExpbmVOdW1iZXI7IGxpbmVOdW1iZXIrKykge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMuX3RleHRNb2RlbC5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBzYWZlVG9rZW5pemUodGhpcy5fbGFuZ3VhZ2VJZENvZGVjLCBsYW5ndWFnZUlkLCB0aGlzLnRva2VuaXphdGlvblN1cHBvcnQsIHRleHQsIHRydWUsIHN0YXRlKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGxpbmVOdW1iZXIsIHIudG9rZW5zKTtcbiAgICAgICAgICAgIHN0YXRlID0gci5lbmRTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBoZXVyaXN0aWNUb2tlbnM6IHRydWUgfTtcbiAgICB9XG4gICAgZ3Vlc3NTdGFydFN0YXRlKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgbGV0IG5vbldoaXRlc3BhY2VDb2x1bW4gPSB0aGlzLl90ZXh0TW9kZWwuZ2V0TGluZUZpcnN0Tm9uV2hpdGVzcGFjZUNvbHVtbihsaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgbGlrZWx5UmVsZXZhbnRMaW5lcyA9IFtdO1xuICAgICAgICBsZXQgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxpbmVOdW1iZXIgLSAxOyBub25XaGl0ZXNwYWNlQ29sdW1uID4gMSAmJiBpID49IDE7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgbmV3Tm9uV2hpdGVzcGFjZUluZGV4ID0gdGhpcy5fdGV4dE1vZGVsLmdldExpbmVGaXJzdE5vbldoaXRlc3BhY2VDb2x1bW4oaSk7XG4gICAgICAgICAgICAvLyBJZ25vcmUgbGluZXMgZnVsbCBvZiB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBpZiAobmV3Tm9uV2hpdGVzcGFjZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3Tm9uV2hpdGVzcGFjZUluZGV4IDwgbm9uV2hpdGVzcGFjZUNvbHVtbikge1xuICAgICAgICAgICAgICAgIGxpa2VseVJlbGV2YW50TGluZXMucHVzaCh0aGlzLl90ZXh0TW9kZWwuZ2V0TGluZUNvbnRlbnQoaSkpO1xuICAgICAgICAgICAgICAgIG5vbldoaXRlc3BhY2VDb2x1bW4gPSBuZXdOb25XaGl0ZXNwYWNlSW5kZXg7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRTdGFydFN0YXRlKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgICAgICBpbml0aWFsU3RhdGUgPSB0aGlzLnRva2VuaXphdGlvblN1cHBvcnQuZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGlrZWx5UmVsZXZhbnRMaW5lcy5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IGxhbmd1YWdlSWQgPSB0aGlzLl90ZXh0TW9kZWwuZ2V0TGFuZ3VhZ2VJZCgpO1xuICAgICAgICBsZXQgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaWtlbHlSZWxldmFudExpbmVzKSB7XG4gICAgICAgICAgICBjb25zdCByID0gc2FmZVRva2VuaXplKHRoaXMuX2xhbmd1YWdlSWRDb2RlYywgbGFuZ3VhZ2VJZCwgdGhpcy50b2tlbml6YXRpb25TdXBwb3J0LCBsaW5lLCBmYWxzZSwgc3RhdGUpO1xuICAgICAgICAgICAgc3RhdGUgPSByLmVuZFN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG4vKipcbiAqICoqSW52YXJpYW50OioqXG4gKiBJZiB0aGUgdGV4dCBtb2RlbCBpcyByZXRva2VuaXplZCBmcm9tIGxpbmUgMSB0byB7QGxpbmsgZ2V0Rmlyc3RJbnZhbGlkRW5kU3RhdGVMaW5lTnVtYmVyfSgpIC0gMSxcbiAqIHRoZW4gdGhlIHJlY29tcHV0ZWQgZW5kIHN0YXRlIGZvciBsaW5lIGwgd2lsbCBiZSBlcXVhbCB0byB7QGxpbmsgZ2V0RW5kU3RhdGV9KGwpLlxuICovXG5leHBvcnQgY2xhc3MgVHJhY2tpbmdUb2tlbml6YXRpb25TdGF0ZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lQ291bnQpIHtcbiAgICAgICAgdGhpcy5saW5lQ291bnQgPSBsaW5lQ291bnQ7XG4gICAgICAgIHRoaXMuX3Rva2VuaXphdGlvblN0YXRlU3RvcmUgPSBuZXcgVG9rZW5pemF0aW9uU3RhdGVTdG9yZSgpO1xuICAgICAgICB0aGlzLl9pbnZhbGlkRW5kU3RhdGVzTGluZU51bWJlcnMgPSBuZXcgUmFuZ2VQcmlvcml0eVF1ZXVlSW1wbCgpO1xuICAgICAgICB0aGlzLl9pbnZhbGlkRW5kU3RhdGVzTGluZU51bWJlcnMuYWRkUmFuZ2UobmV3IE9mZnNldFJhbmdlKDEsIGxpbmVDb3VudCArIDEpKTtcbiAgICB9XG4gICAgZ2V0RW5kU3RhdGUobGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5pemF0aW9uU3RhdGVTdG9yZS5nZXRFbmRTdGF0ZShsaW5lTnVtYmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgaWYgdGhlIGVuZCBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBzZXRFbmRTdGF0ZShsaW5lTnVtYmVyLCBzdGF0ZSkge1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKCdDYW5ub3Qgc2V0IG51bGwvdW5kZWZpbmVkIHN0YXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52YWxpZEVuZFN0YXRlc0xpbmVOdW1iZXJzLmRlbGV0ZShsaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuX3Rva2VuaXphdGlvblN0YXRlU3RvcmUuc2V0RW5kU3RhdGUobGluZU51bWJlciwgc3RhdGUpO1xuICAgICAgICBpZiAociAmJiBsaW5lTnVtYmVyIDwgdGhpcy5saW5lQ291bnQpIHtcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIHN0YXRlIGNoYW5nZWQsIHdlIGNhbm5vdCB0cnVzdCB0aGUgbmV4dCBzdGF0ZSBhbnltb3JlIGFuZCBoYXZlIHRvIGludmFsaWRhdGUgaXQuXG4gICAgICAgICAgICB0aGlzLl9pbnZhbGlkRW5kU3RhdGVzTGluZU51bWJlcnMuYWRkUmFuZ2UobmV3IE9mZnNldFJhbmdlKGxpbmVOdW1iZXIgKyAxLCBsaW5lTnVtYmVyICsgMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBhY2NlcHRDaGFuZ2UocmFuZ2UsIG5ld0xpbmVDb3VudCkge1xuICAgICAgICB0aGlzLmxpbmVDb3VudCArPSBuZXdMaW5lQ291bnQgLSByYW5nZS5sZW5ndGg7XG4gICAgICAgIHRoaXMuX3Rva2VuaXphdGlvblN0YXRlU3RvcmUuYWNjZXB0Q2hhbmdlKHJhbmdlLCBuZXdMaW5lQ291bnQpO1xuICAgICAgICB0aGlzLl9pbnZhbGlkRW5kU3RhdGVzTGluZU51bWJlcnMuYWRkUmFuZ2VBbmRSZXNpemUobmV3IE9mZnNldFJhbmdlKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSksIG5ld0xpbmVDb3VudCk7XG4gICAgfVxuICAgIGFjY2VwdENoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2hhbmdlcykge1xuICAgICAgICAgICAgY29uc3QgW2VvbENvdW50XSA9IGNvdW50RU9MKGMudGV4dCk7XG4gICAgICAgICAgICB0aGlzLmFjY2VwdENoYW5nZShuZXcgTGluZVJhbmdlKGMucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCBjLnJhbmdlLmVuZExpbmVOdW1iZXIgKyAxKSwgZW9sQ291bnQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZhbGlkYXRlRW5kU3RhdGVSYW5nZShyYW5nZSkge1xuICAgICAgICB0aGlzLl9pbnZhbGlkRW5kU3RhdGVzTGluZU51bWJlcnMuYWRkUmFuZ2UobmV3IE9mZnNldFJhbmdlKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSkpO1xuICAgIH1cbiAgICBnZXRGaXJzdEludmFsaWRFbmRTdGF0ZUxpbmVOdW1iZXIoKSB7IHJldHVybiB0aGlzLl9pbnZhbGlkRW5kU3RhdGVzTGluZU51bWJlcnMubWluOyB9XG4gICAgZ2V0Rmlyc3RJbnZhbGlkRW5kU3RhdGVMaW5lTnVtYmVyT3JNYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpcnN0SW52YWxpZEVuZFN0YXRlTGluZU51bWJlcigpIHx8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cbiAgICBhbGxTdGF0ZXNWYWxpZCgpIHsgcmV0dXJuIHRoaXMuX2ludmFsaWRFbmRTdGF0ZXNMaW5lTnVtYmVycy5taW4gPT09IG51bGw7IH1cbiAgICBnZXRTdGFydFN0YXRlKGxpbmVOdW1iZXIsIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAobGluZU51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmRTdGF0ZShsaW5lTnVtYmVyIC0gMSk7XG4gICAgfVxuICAgIGdldEZpcnN0SW52YWxpZExpbmUoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IGxpbmVOdW1iZXIgPSB0aGlzLmdldEZpcnN0SW52YWxpZEVuZFN0YXRlTGluZU51bWJlcigpO1xuICAgICAgICBpZiAobGluZU51bWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRTdGF0ZSA9IHRoaXMuZ2V0U3RhcnRTdGF0ZShsaW5lTnVtYmVyLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICBpZiAoIXN0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ1N0YXJ0IHN0YXRlIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmVOdW1iZXIsIHN0YXJ0U3RhdGUgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVG9rZW5pemF0aW9uU3RhdGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2xpbmVFbmRTdGF0ZXMgPSBuZXcgRml4ZWRBcnJheShudWxsKTtcbiAgICB9XG4gICAgZ2V0RW5kU3RhdGUobGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZUVuZFN0YXRlcy5nZXQobGluZU51bWJlcik7XG4gICAgfVxuICAgIHNldEVuZFN0YXRlKGxpbmVOdW1iZXIsIHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5fbGluZUVuZFN0YXRlcy5nZXQobGluZU51bWJlcik7XG4gICAgICAgIGlmIChvbGRTdGF0ZSAmJiBvbGRTdGF0ZS5lcXVhbHMoc3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGluZUVuZFN0YXRlcy5zZXQobGluZU51bWJlciwgc3RhdGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYWNjZXB0Q2hhbmdlKHJhbmdlLCBuZXdMaW5lQ291bnQpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHJhbmdlLmxlbmd0aDtcbiAgICAgICAgaWYgKG5ld0xpbmVDb3VudCA+IDAgJiYgbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gS2VlcCB0aGUgbGFzdCBzdGF0ZSwgZXZlbiB0aG91Z2ggaXQgaXMgdW5yZWxhdGVkLlxuICAgICAgICAgICAgLy8gQnV0IGlmIHRoZSBuZXcgc3RhdGUgaGFwcGVucyB0byBhZ3JlZSB3aXRoIHRoaXMgbGFzdCBzdGF0ZSwgdGhlbiB3ZSBrbm93IHdlIGNhbiBzdG9wIHRva2VuaXppbmcuXG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIG5ld0xpbmVDb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpbmVFbmRTdGF0ZXMucmVwbGFjZShyYW5nZS5zdGFydExpbmVOdW1iZXIsIGxlbmd0aCwgbmV3TGluZUNvdW50KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmFuZ2VQcmlvcml0eVF1ZXVlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3JhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBnZXQgbWluKCkge1xuICAgICAgICBpZiAodGhpcy5fcmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jhbmdlc1swXS5zdGFydDtcbiAgICB9XG4gICAgZGVsZXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX3Jhbmdlcy5maW5kSW5kZXgociA9PiByLmNvbnRhaW5zKHZhbHVlKSk7XG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuX3Jhbmdlc1tpZHhdO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbmRFeGNsdXNpdmUgPT09IHZhbHVlICsgMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZXNbaWR4XSA9IG5ldyBPZmZzZXRSYW5nZSh2YWx1ZSArIDEsIHJhbmdlLmVuZEV4Y2x1c2l2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmVuZEV4Y2x1c2l2ZSA9PT0gdmFsdWUgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jhbmdlc1tpZHhdID0gbmV3IE9mZnNldFJhbmdlKHJhbmdlLnN0YXJ0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZXMuc3BsaWNlKGlkeCwgMSwgbmV3IE9mZnNldFJhbmdlKHJhbmdlLnN0YXJ0LCB2YWx1ZSksIG5ldyBPZmZzZXRSYW5nZSh2YWx1ZSArIDEsIHJhbmdlLmVuZEV4Y2x1c2l2ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRSYW5nZShyYW5nZSkge1xuICAgICAgICBPZmZzZXRSYW5nZS5hZGRSYW5nZShyYW5nZSwgdGhpcy5fcmFuZ2VzKTtcbiAgICB9XG4gICAgYWRkUmFuZ2VBbmRSZXNpemUocmFuZ2UsIG5ld0xlbmd0aCkge1xuICAgICAgICBsZXQgaWR4Rmlyc3RNaWdodEJlSW50ZXJzZWN0aW5nID0gMDtcbiAgICAgICAgd2hpbGUgKCEoaWR4Rmlyc3RNaWdodEJlSW50ZXJzZWN0aW5nID49IHRoaXMuX3Jhbmdlcy5sZW5ndGggfHwgcmFuZ2Uuc3RhcnQgPD0gdGhpcy5fcmFuZ2VzW2lkeEZpcnN0TWlnaHRCZUludGVyc2VjdGluZ10uZW5kRXhjbHVzaXZlKSkge1xuICAgICAgICAgICAgaWR4Rmlyc3RNaWdodEJlSW50ZXJzZWN0aW5nKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkeEZpcnN0SXNBZnRlciA9IGlkeEZpcnN0TWlnaHRCZUludGVyc2VjdGluZztcbiAgICAgICAgd2hpbGUgKCEoaWR4Rmlyc3RJc0FmdGVyID49IHRoaXMuX3Jhbmdlcy5sZW5ndGggfHwgcmFuZ2UuZW5kRXhjbHVzaXZlIDwgdGhpcy5fcmFuZ2VzW2lkeEZpcnN0SXNBZnRlcl0uc3RhcnQpKSB7XG4gICAgICAgICAgICBpZHhGaXJzdElzQWZ0ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IG5ld0xlbmd0aCAtIHJhbmdlLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGlkeEZpcnN0SXNBZnRlcjsgaSA8IHRoaXMuX3Jhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fcmFuZ2VzW2ldID0gdGhpcy5fcmFuZ2VzW2ldLmRlbHRhKGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWR4Rmlyc3RNaWdodEJlSW50ZXJzZWN0aW5nID09PSBpZHhGaXJzdElzQWZ0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JhbmdlID0gbmV3IE9mZnNldFJhbmdlKHJhbmdlLnN0YXJ0LCByYW5nZS5zdGFydCArIG5ld0xlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIW5ld1JhbmdlLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZXMuc3BsaWNlKGlkeEZpcnN0TWlnaHRCZUludGVyc2VjdGluZywgMCwgbmV3UmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihyYW5nZS5zdGFydCwgdGhpcy5fcmFuZ2VzW2lkeEZpcnN0TWlnaHRCZUludGVyc2VjdGluZ10uc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgZW5kRXggPSBNYXRoLm1heChyYW5nZS5lbmRFeGNsdXNpdmUsIHRoaXMuX3Jhbmdlc1tpZHhGaXJzdElzQWZ0ZXIgLSAxXS5lbmRFeGNsdXNpdmUpO1xuICAgICAgICAgICAgY29uc3QgbmV3UmFuZ2UgPSBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQsIGVuZEV4ICsgZGVsdGEpO1xuICAgICAgICAgICAgaWYgKCFuZXdSYW5nZS5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZ2VzLnNwbGljZShpZHhGaXJzdE1pZ2h0QmVJbnRlcnNlY3RpbmcsIGlkeEZpcnN0SXNBZnRlciAtIGlkeEZpcnN0TWlnaHRCZUludGVyc2VjdGluZywgbmV3UmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZ2VzLnNwbGljZShpZHhGaXJzdE1pZ2h0QmVJbnRlcnNlY3RpbmcsIGlkeEZpcnN0SXNBZnRlciAtIGlkeEZpcnN0TWlnaHRCZUludGVyc2VjdGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYW5nZXMubWFwKHIgPT4gci50b1N0cmluZygpKS5qb2luKCcgKyAnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYWZlVG9rZW5pemUobGFuZ3VhZ2VJZENvZGVjLCBsYW5ndWFnZUlkLCB0b2tlbml6YXRpb25TdXBwb3J0LCB0ZXh0LCBoYXNFT0wsIHN0YXRlKSB7XG4gICAgbGV0IHIgPSBudWxsO1xuICAgIGlmICh0b2tlbml6YXRpb25TdXBwb3J0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByID0gdG9rZW5pemF0aW9uU3VwcG9ydC50b2tlbml6ZUVuY29kZWQodGV4dCwgaGFzRU9MLCBzdGF0ZS5jbG9uZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb25VbmV4cGVjdGVkRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyKSB7XG4gICAgICAgIHIgPSBudWxsVG9rZW5pemVFbmNvZGVkKGxhbmd1YWdlSWRDb2RlYy5lbmNvZGVMYW5ndWFnZUlkKGxhbmd1YWdlSWQpLCBzdGF0ZSk7XG4gICAgfVxuICAgIExpbmVUb2tlbnMuY29udmVydFRvRW5kT2Zmc2V0KHIudG9rZW5zLCB0ZXh0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnQgY2xhc3MgRGVmYXVsdEJhY2tncm91bmRUb2tlbml6ZXIge1xuICAgIGNvbnN0cnVjdG9yKF90b2tlbml6ZXJXaXRoU3RhdGVTdG9yZSwgX2JhY2tncm91bmRUb2tlblN0b3JlKSB7XG4gICAgICAgIHRoaXMuX3Rva2VuaXplcldpdGhTdGF0ZVN0b3JlID0gX3Rva2VuaXplcldpdGhTdGF0ZVN0b3JlO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kVG9rZW5TdG9yZSA9IF9iYWNrZ3JvdW5kVG9rZW5TdG9yZTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5CYWNrZ3JvdW5kVG9rZW5pemF0aW9uKCk7XG4gICAgfVxuICAgIF9iZWdpbkJhY2tncm91bmRUb2tlbml6YXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1NjaGVkdWxlZCB8fCAhdGhpcy5fdG9rZW5pemVyV2l0aFN0YXRlU3RvcmUuX3RleHRNb2RlbC5pc0F0dGFjaGVkVG9FZGl0b3IoKSB8fCAhdGhpcy5faGFzTGluZXNUb1Rva2VuaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHJ1bldoZW5HbG9iYWxJZGxlKChkZWFkbGluZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmRUb2tlbml6ZVdpdGhEZWFkbGluZShkZWFkbGluZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZSB1bnRpbCB0aGUgZGVhZGxpbmUgb2NjdXJzLCBidXQgdHJ5IHRvIHlpZWxkIGV2ZXJ5IDEtMm1zLlxuICAgICAqL1xuICAgIF9iYWNrZ3JvdW5kVG9rZW5pemVXaXRoRGVhZGxpbmUoZGVhZGxpbmUpIHtcbiAgICAgICAgLy8gUmVhZCB0aGUgdGltZSByZW1haW5pbmcgZnJvbSB0aGUgYGRlYWRsaW5lYCBpbW1lZGlhdGVseSBiZWNhdXNlIGl0IGlzIHVuY2xlYXJcbiAgICAgICAgLy8gaWYgdGhlIGBkZWFkbGluZWAgb2JqZWN0IHdpbGwgYmUgdmFsaWQgYWZ0ZXIgZXhlY3V0aW9uIGxlYXZlcyB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKTtcbiAgICAgICAgY29uc3QgZXhlY3V0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkIHx8ICF0aGlzLl90b2tlbml6ZXJXaXRoU3RhdGVTdG9yZS5fdGV4dE1vZGVsLmlzQXR0YWNoZWRUb0VkaXRvcigpIHx8ICF0aGlzLl9oYXNMaW5lc1RvVG9rZW5pemUoKSkge1xuICAgICAgICAgICAgICAgIC8vIGRpc3Bvc2VkIGluIHRoZSBtZWFudGltZSBvciBkZXRhY2hlZCBvciBmaW5pc2hlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmRUb2tlbml6ZUZvckF0TGVhc3QxbXMoKTtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIDwgZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIHN0aWxsIHRpbWUgYmVmb3JlIHJlYWNoaW5nIHRoZSBkZWFkbGluZSwgc28geWllbGQgdG8gdGhlIGJyb3dzZXIgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBleGVjdXRpb25cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0MChleGVjdXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkZWFkbGluZSBoYXMgYmVlbiByZWFjaGVkLCBzbyBzY2hlZHVsZSBhIG5ldyBpZGxlIGNhbGxiYWNrIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIHRoaXMuX2JlZ2luQmFja2dyb3VuZFRva2VuaXphdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBleGVjdXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRva2VuaXplIGZvciBhdCBsZWFzdCAxbXMuXG4gICAgICovXG4gICAgX2JhY2tncm91bmRUb2tlbml6ZUZvckF0TGVhc3QxbXMoKSB7XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMuX3Rva2VuaXplcldpdGhTdGF0ZVN0b3JlLl90ZXh0TW9kZWwuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgQ29udGlndW91c011bHRpbGluZVRva2Vuc0J1aWxkZXIoKTtcbiAgICAgICAgY29uc3Qgc3cgPSBTdG9wV2F0Y2guY3JlYXRlKGZhbHNlKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHN3LmVsYXBzZWQoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29tcGFyaXNvbiBpcyBpbnRlbnRpb25hbGx5ID4gMSBhbmQgbm90ID49IDEgdG8gZW5zdXJlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBhIGZ1bGwgbWlsbGlzZWNvbmQgaGFzIGVsYXBzZWQsIGdpdmVuIGhvdyBtaWNyb3NlY29uZHMgYXJlIHJvdW5kZWRcbiAgICAgICAgICAgICAgICAvLyB0byBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuaXplZExpbmVOdW1iZXIgPSB0aGlzLl90b2tlbml6ZU9uZUludmFsaWRMaW5lKGJ1aWxkZXIpO1xuICAgICAgICAgICAgaWYgKHRva2VuaXplZExpbmVOdW1iZXIgPj0gbGluZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuX2hhc0xpbmVzVG9Ub2tlbml6ZSgpKTtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZFRva2VuU3RvcmUuc2V0VG9rZW5zKGJ1aWxkZXIuZmluYWxpemUoKSk7XG4gICAgICAgIHRoaXMuY2hlY2tGaW5pc2hlZCgpO1xuICAgIH1cbiAgICBfaGFzTGluZXNUb1Rva2VuaXplKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuaXplcldpdGhTdGF0ZVN0b3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLl90b2tlbml6ZXJXaXRoU3RhdGVTdG9yZS5zdG9yZS5hbGxTdGF0ZXNWYWxpZCgpO1xuICAgIH1cbiAgICBfdG9rZW5pemVPbmVJbnZhbGlkTGluZShidWlsZGVyKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0SW52YWxpZExpbmUgPSB0aGlzLl90b2tlbml6ZXJXaXRoU3RhdGVTdG9yZT8uZ2V0Rmlyc3RJbnZhbGlkTGluZSgpO1xuICAgICAgICBpZiAoIWZpcnN0SW52YWxpZExpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2tlbml6ZXJXaXRoU3RhdGVTdG9yZS5fdGV4dE1vZGVsLmdldExpbmVDb3VudCgpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90b2tlbml6ZXJXaXRoU3RhdGVTdG9yZS51cGRhdGVUb2tlbnNVbnRpbExpbmUoYnVpbGRlciwgZmlyc3RJbnZhbGlkTGluZS5saW5lTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0SW52YWxpZExpbmUubGluZU51bWJlcjtcbiAgICB9XG4gICAgY2hlY2tGaW5pc2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdG9rZW5pemVyV2l0aFN0YXRlU3RvcmUuc3RvcmUuYWxsU3RhdGVzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZFRva2VuU3RvcmUuYmFja2dyb3VuZFRva2VuaXphdGlvbkZpbmlzaGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdFRva2VucyhzdGFydExpbmVOdW1iZXIsIGVuZExpbmVOdW1iZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgdGhpcy5fdG9rZW5pemVyV2l0aFN0YXRlU3RvcmUuc3RvcmUuaW52YWxpZGF0ZUVuZFN0YXRlUmFuZ2UobmV3IExpbmVSYW5nZShzdGFydExpbmVOdW1iZXIsIGVuZExpbmVOdW1iZXJFeGNsdXNpdmUpKTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xudmFyIFRva2VuaXphdGlvblRleHRNb2RlbFBhcnRfMTtcbmltcG9ydCB7IEJ1Z0luZGljYXRpbmdFcnJvciwgb25VbmV4cGVjdGVkRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgRW1pdHRlciwgRXZlbnQgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9ldmVudC5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlTWFwLCBEaXNwb3NhYmxlU3RvcmUsIE11dGFibGVEaXNwb3NhYmxlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IGNvdW50RU9MIH0gZnJvbSAnLi4vY29yZS9lb2xDb3VudGVyLmpzJztcbmltcG9ydCB7IExpbmVSYW5nZSB9IGZyb20gJy4uL2NvcmUvbGluZVJhbmdlLmpzJztcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBnZXRXb3JkQXRUZXh0IH0gZnJvbSAnLi4vY29yZS93b3JkSGVscGVyLmpzJztcbmltcG9ydCB7IFRva2VuaXphdGlvblJlZ2lzdHJ5LCBUcmVlU2l0dGVyVG9rZW5pemF0aW9uUmVnaXN0cnkgfSBmcm9tICcuLi9sYW5ndWFnZXMuanMnO1xuaW1wb3J0IHsgSUxhbmd1YWdlU2VydmljZSB9IGZyb20gJy4uL2xhbmd1YWdlcy9sYW5ndWFnZS5qcyc7XG5pbXBvcnQgeyBJTGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZSB9IGZyb20gJy4uL2xhbmd1YWdlcy9sYW5ndWFnZUNvbmZpZ3VyYXRpb25SZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyBUZXh0TW9kZWxQYXJ0IH0gZnJvbSAnLi90ZXh0TW9kZWxQYXJ0LmpzJztcbmltcG9ydCB7IERlZmF1bHRCYWNrZ3JvdW5kVG9rZW5pemVyLCBUb2tlbml6ZXJXaXRoU3RhdGVTdG9yZUFuZFRleHRNb2RlbCwgVHJhY2tpbmdUb2tlbml6YXRpb25TdGF0ZVN0b3JlIH0gZnJvbSAnLi90ZXh0TW9kZWxUb2tlbnMuanMnO1xuaW1wb3J0IHsgQWJzdHJhY3RUb2tlbnMsIEF0dGFjaGVkVmlld0hhbmRsZXIgfSBmcm9tICcuL3Rva2Vucy5qcyc7XG5pbXBvcnQgeyBUcmVlU2l0dGVyVG9rZW5zIH0gZnJvbSAnLi90cmVlU2l0dGVyVG9rZW5zLmpzJztcbmltcG9ydCB7IElUcmVlU2l0dGVyUGFyc2VyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3RyZWVTaXR0ZXJQYXJzZXJTZXJ2aWNlLmpzJztcbmltcG9ydCB7IENvbnRpZ3VvdXNNdWx0aWxpbmVUb2tlbnNCdWlsZGVyIH0gZnJvbSAnLi4vdG9rZW5zL2NvbnRpZ3VvdXNNdWx0aWxpbmVUb2tlbnNCdWlsZGVyLmpzJztcbmltcG9ydCB7IENvbnRpZ3VvdXNUb2tlbnNTdG9yZSB9IGZyb20gJy4uL3Rva2Vucy9jb250aWd1b3VzVG9rZW5zU3RvcmUuanMnO1xuaW1wb3J0IHsgU3BhcnNlVG9rZW5zU3RvcmUgfSBmcm9tICcuLi90b2tlbnMvc3BhcnNlVG9rZW5zU3RvcmUuanMnO1xubGV0IFRva2VuaXphdGlvblRleHRNb2RlbFBhcnQgPSBUb2tlbml6YXRpb25UZXh0TW9kZWxQYXJ0XzEgPSBjbGFzcyBUb2tlbml6YXRpb25UZXh0TW9kZWxQYXJ0IGV4dGVuZHMgVGV4dE1vZGVsUGFydCB7XG4gICAgY29uc3RydWN0b3IoX3RleHRNb2RlbCwgX2JyYWNrZXRQYWlyc1RleHRNb2RlbFBhcnQsIF9sYW5ndWFnZUlkLCBfYXR0YWNoZWRWaWV3cywgX2xhbmd1YWdlU2VydmljZSwgX2xhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2UsIF90cmVlU2l0dGVyU2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90ZXh0TW9kZWwgPSBfdGV4dE1vZGVsO1xuICAgICAgICB0aGlzLl9icmFja2V0UGFpcnNUZXh0TW9kZWxQYXJ0ID0gX2JyYWNrZXRQYWlyc1RleHRNb2RlbFBhcnQ7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBfbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fYXR0YWNoZWRWaWV3cyA9IF9hdHRhY2hlZFZpZXdzO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZVNlcnZpY2UgPSBfbGFuZ3VhZ2VTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gX2xhbmd1YWdlQ29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuX3RyZWVTaXR0ZXJTZXJ2aWNlID0gX3RyZWVTaXR0ZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9zZW1hbnRpY1Rva2VucyA9IG5ldyBTcGFyc2VUb2tlbnNTdG9yZSh0aGlzLl9sYW5ndWFnZVNlcnZpY2UubGFuZ3VhZ2VJZENvZGVjKTtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VMYW5ndWFnZSA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBFbWl0dGVyKCkpO1xuICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlTGFuZ3VhZ2UgPSB0aGlzLl9vbkRpZENoYW5nZUxhbmd1YWdlLmV2ZW50O1xuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZUxhbmd1YWdlQ29uZmlndXJhdGlvbiA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBFbWl0dGVyKCkpO1xuICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlTGFuZ3VhZ2VDb25maWd1cmF0aW9uID0gdGhpcy5fb25EaWRDaGFuZ2VMYW5ndWFnZUNvbmZpZ3VyYXRpb24uZXZlbnQ7XG4gICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlVG9rZW5zID0gdGhpcy5fcmVnaXN0ZXIobmV3IEVtaXR0ZXIoKSk7XG4gICAgICAgIHRoaXMub25EaWRDaGFuZ2VUb2tlbnMgPSB0aGlzLl9vbkRpZENoYW5nZVRva2Vucy5ldmVudDtcbiAgICAgICAgdGhpcy5fdG9rZW5zRGlzcG9zYWJsZXMgPSB0aGlzLl9yZWdpc3RlcihuZXcgRGlzcG9zYWJsZVN0b3JlKCkpO1xuICAgICAgICB0aGlzLl9yZWdpc3Rlcih0aGlzLl9sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlLm9uRGlkQ2hhbmdlKGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUuYWZmZWN0cyh0aGlzLl9sYW5ndWFnZUlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlTGFuZ3VhZ2VDb25maWd1cmF0aW9uLmZpcmUoe30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIFdlIGp1c3QgbG9vayBhdCByZWdpc3RyeSBjaGFuZ2VzIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHVzZSB0cmVlIHNpdHRlci5cbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHJlbW92aW5nIGEgbGFuZ3VhZ2UgZnJvbSB0aGUgc2V0dGluZyB3aWxsIG5vdCBjYXVzZSBhIHN3aXRjaCB0byB0ZXh0bWF0ZSBhbmQgd2lsbCByZXF1aXJlIGEgcmVsb2FkLlxuICAgICAgICAvLyBBZGRpbmcgYSBsYW5ndWFnZSB0byB0aGUgc2V0dGluZyB3aWxsIG5vdCBuZWVkIGEgcmVsb2FkLCBob3dldmVyLlxuICAgICAgICB0aGlzLl9yZWdpc3RlcihFdmVudC5maWx0ZXIoVHJlZVNpdHRlclRva2VuaXphdGlvblJlZ2lzdHJ5Lm9uRGlkQ2hhbmdlLCAoZSkgPT4gZS5jaGFuZ2VkTGFuZ3VhZ2VzLmluY2x1ZGVzKHRoaXMuX2xhbmd1YWdlSWQpKSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVByZWZlcnJlZFRva2VuUHJvdmlkZXIoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmNyZWF0ZVByZWZlcnJlZFRva2VuUHJvdmlkZXIoKTtcbiAgICB9XG4gICAgY3JlYXRlR3JhbW1hclRva2VucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyKG5ldyBHcmFtbWFyVG9rZW5zKHRoaXMuX2xhbmd1YWdlU2VydmljZS5sYW5ndWFnZUlkQ29kZWMsIHRoaXMuX3RleHRNb2RlbCwgKCkgPT4gdGhpcy5fbGFuZ3VhZ2VJZCwgdGhpcy5fYXR0YWNoZWRWaWV3cykpO1xuICAgIH1cbiAgICBjcmVhdGVUcmVlU2l0dGVyVG9rZW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXIobmV3IFRyZWVTaXR0ZXJUb2tlbnModGhpcy5fdHJlZVNpdHRlclNlcnZpY2UsIHRoaXMuX2xhbmd1YWdlU2VydmljZS5sYW5ndWFnZUlkQ29kZWMsIHRoaXMuX3RleHRNb2RlbCwgKCkgPT4gdGhpcy5fbGFuZ3VhZ2VJZCkpO1xuICAgIH1cbiAgICBjcmVhdGVUb2tlbnModXNlVHJlZVNpdHRlcikge1xuICAgICAgICBjb25zdCBuZWVkc1Jlc2V0ID0gdGhpcy5fdG9rZW5zICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3Rva2Vucz8uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl90b2tlbnMgPSB1c2VUcmVlU2l0dGVyID8gdGhpcy5jcmVhdGVUcmVlU2l0dGVyVG9rZW5zKCkgOiB0aGlzLmNyZWF0ZUdyYW1tYXJUb2tlbnMoKTtcbiAgICAgICAgdGhpcy5fdG9rZW5zRGlzcG9zYWJsZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fdG9rZW5zRGlzcG9zYWJsZXMuYWRkKHRoaXMuX3Rva2Vucy5vbkRpZENoYW5nZVRva2VucyhlID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRNb2RlbFRva2Vuc0NoYW5nZWRFdmVudChlKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLl90b2tlbnNEaXNwb3NhYmxlcy5hZGQodGhpcy5fdG9rZW5zLm9uRGlkQ2hhbmdlQmFja2dyb3VuZFRva2VuaXphdGlvblN0YXRlKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYnJhY2tldFBhaXJzVGV4dE1vZGVsUGFydC5oYW5kbGVEaWRDaGFuZ2VCYWNrZ3JvdW5kVG9rZW5pemF0aW9uU3RhdGUoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAobmVlZHNSZXNldCkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByZXNldCB0aGUgdG9rZW5pemF0aW9uLCBhcyB0aGUgbmV3IHRva2VuIHByb3ZpZGVyIG90aGVyd2lzZSB3b24ndCBoYXZlIGEgY2hhbmNlIHRvIHByb3ZpZGUgdG9rZW5zIHVudGlsIHNvbWUgYWN0aW9uIGhhcHBlbnMgaW4gdGhlIGVkaXRvci5cbiAgICAgICAgICAgIHRoaXMuX3Rva2Vucy5yZXNldFRva2VuaXphdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVByZWZlcnJlZFRva2VuUHJvdmlkZXIoKSB7XG4gICAgICAgIGlmIChUcmVlU2l0dGVyVG9rZW5pemF0aW9uUmVnaXN0cnkuZ2V0KHRoaXMuX2xhbmd1YWdlSWQpKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl90b2tlbnMgaW5zdGFuY2VvZiBUcmVlU2l0dGVyVG9rZW5zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9rZW5zKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5fdG9rZW5zIGluc3RhbmNlb2YgR3JhbW1hclRva2VucykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVRva2VucyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlTGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZUNoYW5nZShlKSB7XG4gICAgICAgIGlmIChlLmFmZmVjdHModGhpcy5fbGFuZ3VhZ2VJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlTGFuZ3VhZ2VDb25maWd1cmF0aW9uLmZpcmUoe30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZURpZENoYW5nZUNvbnRlbnQoZSkge1xuICAgICAgICBpZiAoZS5pc0ZsdXNoKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW1hbnRpY1Rva2Vucy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFlLmlzRW9sQ2hhbmdlKSB7IC8vIFdlIGRvbid0IGhhdmUgdG8gZG8gYW55dGhpbmcgb24gYW4gRU9MIGNoYW5nZVxuICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGUuY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtlb2xDb3VudCwgZmlyc3RMaW5lTGVuZ3RoLCBsYXN0TGluZUxlbmd0aF0gPSBjb3VudEVPTChjLnRleHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbWFudGljVG9rZW5zLmFjY2VwdEVkaXQoYy5yYW5nZSwgZW9sQ291bnQsIGZpcnN0TGluZUxlbmd0aCwgbGFzdExpbmVMZW5ndGgsIGMudGV4dC5sZW5ndGggPiAwID8gYy50ZXh0LmNoYXJDb2RlQXQoMCkgOiAwIC8qIENoYXJDb2RlLk51bGwgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rva2Vucy5oYW5kbGVEaWRDaGFuZ2VDb250ZW50KGUpO1xuICAgIH1cbiAgICBoYW5kbGVEaWRDaGFuZ2VBdHRhY2hlZCgpIHtcbiAgICAgICAgdGhpcy5fdG9rZW5zLmhhbmRsZURpZENoYW5nZUF0dGFjaGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluY2x1ZGVzIGdyYW1tYXIgYW5kIHNlbWFudGljIHRva2Vucy5cbiAgICAgKi9cbiAgICBnZXRMaW5lVG9rZW5zKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUxpbmVOdW1iZXIobGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IHN5bnRhY3RpY1Rva2VucyA9IHRoaXMuX3Rva2Vucy5nZXRMaW5lVG9rZW5zKGxpbmVOdW1iZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYW50aWNUb2tlbnMuYWRkU3BhcnNlVG9rZW5zKGxpbmVOdW1iZXIsIHN5bnRhY3RpY1Rva2Vucyk7XG4gICAgfVxuICAgIF9lbWl0TW9kZWxUb2tlbnNDaGFuZ2VkRXZlbnQoZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHRNb2RlbC5faXNEaXNwb3NpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5fYnJhY2tldFBhaXJzVGV4dE1vZGVsUGFydC5oYW5kbGVEaWRDaGFuZ2VUb2tlbnMoZSk7XG4gICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZVRva2Vucy5maXJlKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vICNyZWdpb24gR3JhbW1hciBUb2tlbnNcbiAgICB2YWxpZGF0ZUxpbmVOdW1iZXIobGluZU51bWJlcikge1xuICAgICAgICBpZiAobGluZU51bWJlciA8IDEgfHwgbGluZU51bWJlciA+IHRoaXMuX3RleHRNb2RlbC5nZXRMaW5lQ291bnQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcignSWxsZWdhbCB2YWx1ZSBmb3IgbGluZU51bWJlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBoYXNUb2tlbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbnMuaGFzVG9rZW5zO1xuICAgIH1cbiAgICByZXNldFRva2VuaXphdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdG9rZW5zLnJlc2V0VG9rZW5pemF0aW9uKCk7XG4gICAgfVxuICAgIGdldCBiYWNrZ3JvdW5kVG9rZW5pemF0aW9uU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbnMuYmFja2dyb3VuZFRva2VuaXphdGlvblN0YXRlO1xuICAgIH1cbiAgICBmb3JjZVRva2VuaXphdGlvbihsaW5lTnVtYmVyKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVMaW5lTnVtYmVyKGxpbmVOdW1iZXIpO1xuICAgICAgICB0aGlzLl90b2tlbnMuZm9yY2VUb2tlbml6YXRpb24obGluZU51bWJlcik7XG4gICAgfVxuICAgIGhhc0FjY3VyYXRlVG9rZW5zRm9yTGluZShsaW5lTnVtYmVyKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVMaW5lTnVtYmVyKGxpbmVOdW1iZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5zLmhhc0FjY3VyYXRlVG9rZW5zRm9yTGluZShsaW5lTnVtYmVyKTtcbiAgICB9XG4gICAgaXNDaGVhcFRvVG9rZW5pemUobGluZU51bWJlcikge1xuICAgICAgICB0aGlzLnZhbGlkYXRlTGluZU51bWJlcihsaW5lTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vucy5pc0NoZWFwVG9Ub2tlbml6ZShsaW5lTnVtYmVyKTtcbiAgICB9XG4gICAgdG9rZW5pemVJZkNoZWFwKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUxpbmVOdW1iZXIobGluZU51bWJlcik7XG4gICAgICAgIHRoaXMuX3Rva2Vucy50b2tlbml6ZUlmQ2hlYXAobGluZU51bWJlcik7XG4gICAgfVxuICAgIGdldFRva2VuVHlwZUlmSW5zZXJ0aW5nQ2hhcmFjdGVyKGxpbmVOdW1iZXIsIGNvbHVtbiwgY2hhcmFjdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbnMuZ2V0VG9rZW5UeXBlSWZJbnNlcnRpbmdDaGFyYWN0ZXIobGluZU51bWJlciwgY29sdW1uLCBjaGFyYWN0ZXIpO1xuICAgIH1cbiAgICB0b2tlbml6ZUxpbmVXaXRoRWRpdChwb3NpdGlvbiwgbGVuZ3RoLCBuZXdUZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbnMudG9rZW5pemVMaW5lV2l0aEVkaXQocG9zaXRpb24sIGxlbmd0aCwgbmV3VGV4dCk7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIFNlbWFudGljIFRva2Vuc1xuICAgIHNldFNlbWFudGljVG9rZW5zKHRva2VucywgaXNDb21wbGV0ZSkge1xuICAgICAgICB0aGlzLl9zZW1hbnRpY1Rva2Vucy5zZXQodG9rZW5zLCBpc0NvbXBsZXRlKTtcbiAgICAgICAgdGhpcy5fZW1pdE1vZGVsVG9rZW5zQ2hhbmdlZEV2ZW50KHtcbiAgICAgICAgICAgIHNlbWFudGljVG9rZW5zQXBwbGllZDogdG9rZW5zICE9PSBudWxsLFxuICAgICAgICAgICAgcmFuZ2VzOiBbeyBmcm9tTGluZU51bWJlcjogMSwgdG9MaW5lTnVtYmVyOiB0aGlzLl90ZXh0TW9kZWwuZ2V0TGluZUNvdW50KCkgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYXNDb21wbGV0ZVNlbWFudGljVG9rZW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYW50aWNUb2tlbnMuaXNDb21wbGV0ZSgpO1xuICAgIH1cbiAgICBoYXNTb21lU2VtYW50aWNUb2tlbnMoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fc2VtYW50aWNUb2tlbnMuaXNFbXB0eSgpO1xuICAgIH1cbiAgICBzZXRQYXJ0aWFsU2VtYW50aWNUb2tlbnMocmFuZ2UsIHRva2Vucykge1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wbGV0ZVNlbWFudGljVG9rZW5zKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFuZ2VkUmFuZ2UgPSB0aGlzLl90ZXh0TW9kZWwudmFsaWRhdGVSYW5nZSh0aGlzLl9zZW1hbnRpY1Rva2Vucy5zZXRQYXJ0aWFsKHJhbmdlLCB0b2tlbnMpKTtcbiAgICAgICAgdGhpcy5fZW1pdE1vZGVsVG9rZW5zQ2hhbmdlZEV2ZW50KHtcbiAgICAgICAgICAgIHNlbWFudGljVG9rZW5zQXBwbGllZDogdHJ1ZSxcbiAgICAgICAgICAgIHJhbmdlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUxpbmVOdW1iZXI6IGNoYW5nZWRSYW5nZS5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHRvTGluZU51bWJlcjogY2hhbmdlZFJhbmdlLmVuZExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiBVdGlsaXR5IE1ldGhvZHNcbiAgICBnZXRXb3JkQXRQb3NpdGlvbihfcG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX3RleHRNb2RlbC52YWxpZGF0ZVBvc2l0aW9uKF9wb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gdGhpcy5fdGV4dE1vZGVsLmdldExpbmVDb250ZW50KHBvc2l0aW9uLmxpbmVOdW1iZXIpO1xuICAgICAgICBjb25zdCBsaW5lVG9rZW5zID0gdGhpcy5nZXRMaW5lVG9rZW5zKHBvc2l0aW9uLmxpbmVOdW1iZXIpO1xuICAgICAgICBjb25zdCB0b2tlbkluZGV4ID0gbGluZVRva2Vucy5maW5kVG9rZW5JbmRleEF0T2Zmc2V0KHBvc2l0aW9uLmNvbHVtbiAtIDEpO1xuICAgICAgICAvLyAoMSkuIEZpcnN0IHRyeSBjaGVja2luZyByaWdodCBiaWFzZWQgd29yZFxuICAgICAgICBjb25zdCBbcmJTdGFydE9mZnNldCwgcmJFbmRPZmZzZXRdID0gVG9rZW5pemF0aW9uVGV4dE1vZGVsUGFydF8xLl9maW5kTGFuZ3VhZ2VCb3VuZGFyaWVzKGxpbmVUb2tlbnMsIHRva2VuSW5kZXgpO1xuICAgICAgICBjb25zdCByaWdodEJpYXNlZFdvcmQgPSBnZXRXb3JkQXRUZXh0KHBvc2l0aW9uLmNvbHVtbiwgdGhpcy5nZXRMYW5ndWFnZUNvbmZpZ3VyYXRpb24obGluZVRva2Vucy5nZXRMYW5ndWFnZUlkKHRva2VuSW5kZXgpKS5nZXRXb3JkRGVmaW5pdGlvbigpLCBsaW5lQ29udGVudC5zdWJzdHJpbmcocmJTdGFydE9mZnNldCwgcmJFbmRPZmZzZXQpLCByYlN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByZXN1bHQgdG91Y2hlcyB0aGUgb3JpZ2luYWwgcGFzc2VkIGluIHBvc2l0aW9uXG4gICAgICAgIGlmIChyaWdodEJpYXNlZFdvcmQgJiZcbiAgICAgICAgICAgIHJpZ2h0Qmlhc2VkV29yZC5zdGFydENvbHVtbiA8PSBfcG9zaXRpb24uY29sdW1uICYmXG4gICAgICAgICAgICBfcG9zaXRpb24uY29sdW1uIDw9IHJpZ2h0Qmlhc2VkV29yZC5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiByaWdodEJpYXNlZFdvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gKDIpLiBFbHNlLCBpZiB3ZSB3ZXJlIGF0IGEgbGFuZ3VhZ2UgYm91bmRhcnksIGNoZWNrIHRoZSBsZWZ0IGJpYXNlZCB3b3JkXG4gICAgICAgIGlmICh0b2tlbkluZGV4ID4gMCAmJiByYlN0YXJ0T2Zmc2V0ID09PSBwb3NpdGlvbi5jb2x1bW4gLSAxKSB7XG4gICAgICAgICAgICAvLyBlZGdlIGNhc2UsIHdoZXJlIGBwb3NpdGlvbmAgc2l0cyBiZXR3ZWVuIHR3byB0b2tlbnMgYmVsb25naW5nIHRvIHR3byBkaWZmZXJlbnQgbGFuZ3VhZ2VzXG4gICAgICAgICAgICBjb25zdCBbbGJTdGFydE9mZnNldCwgbGJFbmRPZmZzZXRdID0gVG9rZW5pemF0aW9uVGV4dE1vZGVsUGFydF8xLl9maW5kTGFuZ3VhZ2VCb3VuZGFyaWVzKGxpbmVUb2tlbnMsIHRva2VuSW5kZXggLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRCaWFzZWRXb3JkID0gZ2V0V29yZEF0VGV4dChwb3NpdGlvbi5jb2x1bW4sIHRoaXMuZ2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uKGxpbmVUb2tlbnMuZ2V0TGFuZ3VhZ2VJZCh0b2tlbkluZGV4IC0gMSkpLmdldFdvcmREZWZpbml0aW9uKCksIGxpbmVDb250ZW50LnN1YnN0cmluZyhsYlN0YXJ0T2Zmc2V0LCBsYkVuZE9mZnNldCksIGxiU3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByZXN1bHQgdG91Y2hlcyB0aGUgb3JpZ2luYWwgcGFzc2VkIGluIHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAobGVmdEJpYXNlZFdvcmQgJiZcbiAgICAgICAgICAgICAgICBsZWZ0Qmlhc2VkV29yZC5zdGFydENvbHVtbiA8PSBfcG9zaXRpb24uY29sdW1uICYmXG4gICAgICAgICAgICAgICAgX3Bvc2l0aW9uLmNvbHVtbiA8PSBsZWZ0Qmlhc2VkV29yZC5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdEJpYXNlZFdvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYW5ndWFnZUNvbmZpZ3VyYXRpb25TZXJ2aWNlLmdldExhbmd1YWdlQ29uZmlndXJhdGlvbihsYW5ndWFnZUlkKTtcbiAgICB9XG4gICAgc3RhdGljIF9maW5kTGFuZ3VhZ2VCb3VuZGFyaWVzKGxpbmVUb2tlbnMsIHRva2VuSW5kZXgpIHtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VJZCA9IGxpbmVUb2tlbnMuZ2V0TGFuZ3VhZ2VJZCh0b2tlbkluZGV4KTtcbiAgICAgICAgLy8gZ28gbGVmdCB1bnRpbCBhIGRpZmZlcmVudCBsYW5ndWFnZSBpcyBoaXRcbiAgICAgICAgbGV0IHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRva2VuSW5kZXg7IGkgPj0gMCAmJiBsaW5lVG9rZW5zLmdldExhbmd1YWdlSWQoaSkgPT09IGxhbmd1YWdlSWQ7IGktLSkge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBsaW5lVG9rZW5zLmdldFN0YXJ0T2Zmc2V0KGkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdvIHJpZ2h0IHVudGlsIGEgZGlmZmVyZW50IGxhbmd1YWdlIGlzIGhpdFxuICAgICAgICBsZXQgZW5kT2Zmc2V0ID0gbGluZVRva2Vucy5nZXRMaW5lQ29udGVudCgpLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRva2VuSW5kZXgsIHRva2VuQ291bnQgPSBsaW5lVG9rZW5zLmdldENvdW50KCk7IGkgPCB0b2tlbkNvdW50ICYmIGxpbmVUb2tlbnMuZ2V0TGFuZ3VhZ2VJZChpKSA9PT0gbGFuZ3VhZ2VJZDsgaSsrKSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBsaW5lVG9rZW5zLmdldEVuZE9mZnNldChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N0YXJ0T2Zmc2V0LCBlbmRPZmZzZXRdO1xuICAgIH1cbiAgICBnZXRXb3JkVW50aWxQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBjb25zdCB3b3JkQXRQb3NpdGlvbiA9IHRoaXMuZ2V0V29yZEF0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICBpZiAoIXdvcmRBdFBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4geyB3b3JkOiAnJywgc3RhcnRDb2x1bW46IHBvc2l0aW9uLmNvbHVtbiwgZW5kQ29sdW1uOiBwb3NpdGlvbi5jb2x1bW4sIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdvcmQ6IHdvcmRBdFBvc2l0aW9uLndvcmQuc3Vic3RyKDAsIHBvc2l0aW9uLmNvbHVtbiAtIHdvcmRBdFBvc2l0aW9uLnN0YXJ0Q29sdW1uKSxcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiB3b3JkQXRQb3NpdGlvbi5zdGFydENvbHVtbixcbiAgICAgICAgICAgIGVuZENvbHVtbjogcG9zaXRpb24uY29sdW1uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiBMYW5ndWFnZSBJZCBoYW5kbGluZ1xuICAgIGdldExhbmd1YWdlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYW5ndWFnZUlkO1xuICAgIH1cbiAgICBnZXRMYW5ndWFnZUlkQXRQb3NpdGlvbihsaW5lTnVtYmVyLCBjb2x1bW4pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl90ZXh0TW9kZWwudmFsaWRhdGVQb3NpdGlvbihuZXcgUG9zaXRpb24obGluZU51bWJlciwgY29sdW1uKSk7XG4gICAgICAgIGNvbnN0IGxpbmVUb2tlbnMgPSB0aGlzLmdldExpbmVUb2tlbnMocG9zaXRpb24ubGluZU51bWJlcik7XG4gICAgICAgIHJldHVybiBsaW5lVG9rZW5zLmdldExhbmd1YWdlSWQobGluZVRva2Vucy5maW5kVG9rZW5JbmRleEF0T2Zmc2V0KHBvc2l0aW9uLmNvbHVtbiAtIDEpKTtcbiAgICB9XG4gICAgc2V0TGFuZ3VhZ2VJZChsYW5ndWFnZUlkLCBzb3VyY2UgPSAnYXBpJykge1xuICAgICAgICBpZiAodGhpcy5fbGFuZ3VhZ2VJZCA9PT0gbGFuZ3VhZ2VJZCkge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgICAgIG9sZExhbmd1YWdlOiB0aGlzLl9sYW5ndWFnZUlkLFxuICAgICAgICAgICAgbmV3TGFuZ3VhZ2U6IGxhbmd1YWdlSWQsXG4gICAgICAgICAgICBzb3VyY2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbGFuZ3VhZ2VJZCA9IGxhbmd1YWdlSWQ7XG4gICAgICAgIHRoaXMuX2JyYWNrZXRQYWlyc1RleHRNb2RlbFBhcnQuaGFuZGxlRGlkQ2hhbmdlTGFuZ3VhZ2UoZSk7XG4gICAgICAgIHRoaXMuX3Rva2Vucy5yZXNldFRva2VuaXphdGlvbigpO1xuICAgICAgICB0aGlzLmNyZWF0ZVByZWZlcnJlZFRva2VuUHJvdmlkZXIoKTtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VMYW5ndWFnZS5maXJlKGUpO1xuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZUxhbmd1YWdlQ29uZmlndXJhdGlvbi5maXJlKHt9KTtcbiAgICB9XG59O1xuVG9rZW5pemF0aW9uVGV4dE1vZGVsUGFydCA9IFRva2VuaXphdGlvblRleHRNb2RlbFBhcnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oNCwgSUxhbmd1YWdlU2VydmljZSksXG4gICAgX19wYXJhbSg1LCBJTGFuZ3VhZ2VDb25maWd1cmF0aW9uU2VydmljZSksXG4gICAgX19wYXJhbSg2LCBJVHJlZVNpdHRlclBhcnNlclNlcnZpY2UpXG5dLCBUb2tlbml6YXRpb25UZXh0TW9kZWxQYXJ0KTtcbmV4cG9ydCB7IFRva2VuaXphdGlvblRleHRNb2RlbFBhcnQgfTtcbmNsYXNzIEdyYW1tYXJUb2tlbnMgZXh0ZW5kcyBBYnN0cmFjdFRva2VucyB7XG4gICAgY29uc3RydWN0b3IobGFuZ3VhZ2VJZENvZGVjLCB0ZXh0TW9kZWwsIGdldExhbmd1YWdlSWQsIGF0dGFjaGVkVmlld3MpIHtcbiAgICAgICAgc3VwZXIobGFuZ3VhZ2VJZENvZGVjLCB0ZXh0TW9kZWwsIGdldExhbmd1YWdlSWQpO1xuICAgICAgICB0aGlzLl90b2tlbml6ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWZhdWx0QmFja2dyb3VuZFRva2VuaXplciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRUb2tlbml6ZXIgPSB0aGlzLl9yZWdpc3RlcihuZXcgTXV0YWJsZURpc3Bvc2FibGUoKSk7XG4gICAgICAgIHRoaXMuX3Rva2VucyA9IG5ldyBDb250aWd1b3VzVG9rZW5zU3RvcmUodGhpcy5fbGFuZ3VhZ2VJZENvZGVjKTtcbiAgICAgICAgdGhpcy5fZGVidWdCYWNrZ3JvdW5kVG9rZW5pemVyID0gdGhpcy5fcmVnaXN0ZXIobmV3IE11dGFibGVEaXNwb3NhYmxlKCkpO1xuICAgICAgICB0aGlzLl9hdHRhY2hlZFZpZXdTdGF0ZXMgPSB0aGlzLl9yZWdpc3RlcihuZXcgRGlzcG9zYWJsZU1hcCgpKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXIoVG9rZW5pemF0aW9uUmVnaXN0cnkub25EaWRDaGFuZ2UoKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlSWQgPSB0aGlzLmdldExhbmd1YWdlSWQoKTtcbiAgICAgICAgICAgIGlmIChlLmNoYW5nZWRMYW5ndWFnZXMuaW5kZXhPZihsYW5ndWFnZUlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0VG9rZW5pemF0aW9uKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5yZXNldFRva2VuaXphdGlvbigpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlcihhdHRhY2hlZFZpZXdzLm9uRGlkQ2hhbmdlVmlzaWJsZVJhbmdlcygoeyB2aWV3LCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXhpc3RpbmcgPSB0aGlzLl9hdHRhY2hlZFZpZXdTdGF0ZXMuZ2V0KHZpZXcpO1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcgPSBuZXcgQXR0YWNoZWRWaWV3SGFuZGxlcigoKSA9PiB0aGlzLnJlZnJlc2hSYW5nZXMoZXhpc3RpbmcubGluZVJhbmdlcykpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hlZFZpZXdTdGF0ZXMuc2V0KHZpZXcsIGV4aXN0aW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhpc3RpbmcuaGFuZGxlU3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWRWaWV3U3RhdGVzLmRlbGV0ZUFuZERpc3Bvc2Uodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmVzZXRUb2tlbml6YXRpb24oZmlyZVRva2VuQ2hhbmdlRXZlbnQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3Rva2Vucy5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9kZWJ1Z0JhY2tncm91bmRUb2tlbnM/LmZsdXNoKCk7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0JhY2tncm91bmRTdGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnQmFja2dyb3VuZFN0YXRlcyA9IG5ldyBUcmFja2luZ1Rva2VuaXphdGlvblN0YXRlU3RvcmUodGhpcy5fdGV4dE1vZGVsLmdldExpbmVDb3VudCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyZVRva2VuQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlVG9rZW5zLmZpcmUoe1xuICAgICAgICAgICAgICAgIHNlbWFudGljVG9rZW5zQXBwbGllZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmFuZ2VzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21MaW5lTnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9MaW5lTnVtYmVyOiB0aGlzLl90ZXh0TW9kZWwuZ2V0TGluZUNvdW50KCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXRpYWxpemVUb2tlbml6YXRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dE1vZGVsLmlzVG9vTGFyZ2VGb3JUb2tlbml6YXRpb24oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b2tlbml6YXRpb25TdXBwb3J0ID0gVG9rZW5pemF0aW9uUmVnaXN0cnkuZ2V0KHRoaXMuZ2V0TGFuZ3VhZ2VJZCgpKTtcbiAgICAgICAgICAgIGlmICghdG9rZW5pemF0aW9uU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5pdGlhbFN0YXRlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbml0aWFsU3RhdGUgPSB0b2tlbml6YXRpb25TdXBwb3J0LmdldEluaXRpYWxTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBvblVuZXhwZWN0ZWRFcnJvcihlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt0b2tlbml6YXRpb25TdXBwb3J0LCBpbml0aWFsU3RhdGVdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBbdG9rZW5pemF0aW9uU3VwcG9ydCwgaW5pdGlhbFN0YXRlXSA9IGluaXRpYWxpemVUb2tlbml6YXRpb24oKTtcbiAgICAgICAgaWYgKHRva2VuaXphdGlvblN1cHBvcnQgJiYgaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl90b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyV2l0aFN0YXRlU3RvcmVBbmRUZXh0TW9kZWwodGhpcy5fdGV4dE1vZGVsLmdldExpbmVDb3VudCgpLCB0b2tlbml6YXRpb25TdXBwb3J0LCB0aGlzLl90ZXh0TW9kZWwsIHRoaXMuX2xhbmd1YWdlSWRDb2RlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2tlbml6ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRUb2tlbml6ZXIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEJhY2tncm91bmRUb2tlbml6ZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdG9rZW5pemVyKSB7XG4gICAgICAgICAgICBjb25zdCBiID0ge1xuICAgICAgICAgICAgICAgIHNldFRva2VuczogKHRva2VucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRva2Vucyh0b2tlbnMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFRva2VuaXphdGlvbkZpbmlzaGVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kVG9rZW5pemF0aW9uU3RhdGUgPT09IDIgLyogQmFja2dyb3VuZFRva2VuaXphdGlvblN0YXRlLkNvbXBsZXRlZCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBkaWQgYSBmdWxsIHRva2VuaXphdGlvbiBhbmQgZG9uJ3QgZ28gYmFjayB0byBwcm9ncmVzc2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IDIgLyogQmFja2dyb3VuZFRva2VuaXphdGlvblN0YXRlLkNvbXBsZXRlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZFRva2VuaXphdGlvblN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlQmFja2dyb3VuZFRva2VuaXphdGlvblN0YXRlLmZpcmUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldEVuZFN0YXRlOiAobGluZU51bWJlciwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90b2tlbml6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEludmFsaWRFbmRTdGF0ZUxpbmVOdW1iZXIgPSB0aGlzLl90b2tlbml6ZXIuc3RvcmUuZ2V0Rmlyc3RJbnZhbGlkRW5kU3RhdGVMaW5lTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFjY2VwdCBzdGF0ZXMgZm9yIGRlZmluaXRlbHkgdmFsaWQgc3RhdGVzLCB0aGUgcmVuZGVyZXIgaXMgYWhlYWQgb2YgdGhlIHdvcmtlciFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0SW52YWxpZEVuZFN0YXRlTGluZU51bWJlciAhPT0gbnVsbCAmJiBsaW5lTnVtYmVyID49IGZpcnN0SW52YWxpZEVuZFN0YXRlTGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5pemVyPy5zdG9yZS5zZXRFbmRTdGF0ZShsaW5lTnVtYmVyLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0b2tlbml6YXRpb25TdXBwb3J0ICYmIHRva2VuaXphdGlvblN1cHBvcnQuY3JlYXRlQmFja2dyb3VuZFRva2VuaXplciAmJiAhdG9rZW5pemF0aW9uU3VwcG9ydC5iYWNrZ3JvdW5kVG9rZW5pemVyU2hvdWxkT25seVZlcmlmeVRva2Vucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmRUb2tlbml6ZXIudmFsdWUgPSB0b2tlbml6YXRpb25TdXBwb3J0LmNyZWF0ZUJhY2tncm91bmRUb2tlbml6ZXIodGhpcy5fdGV4dE1vZGVsLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fYmFja2dyb3VuZFRva2VuaXplci52YWx1ZSAmJiAhdGhpcy5fdGV4dE1vZGVsLmlzVG9vTGFyZ2VGb3JUb2tlbml6YXRpb24oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmRUb2tlbml6ZXIudmFsdWUgPSB0aGlzLl9kZWZhdWx0QmFja2dyb3VuZFRva2VuaXplciA9XG4gICAgICAgICAgICAgICAgICAgIG5ldyBEZWZhdWx0QmFja2dyb3VuZFRva2VuaXplcih0aGlzLl90b2tlbml6ZXIsIGIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRCYWNrZ3JvdW5kVG9rZW5pemVyLmhhbmRsZUNoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbml6YXRpb25TdXBwb3J0Py5iYWNrZ3JvdW5kVG9rZW5pemVyU2hvdWxkT25seVZlcmlmeVRva2VucyAmJiB0b2tlbml6YXRpb25TdXBwb3J0LmNyZWF0ZUJhY2tncm91bmRUb2tlbml6ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1Z0JhY2tncm91bmRUb2tlbnMgPSBuZXcgQ29udGlndW91c1Rva2Vuc1N0b3JlKHRoaXMuX2xhbmd1YWdlSWRDb2RlYyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWdCYWNrZ3JvdW5kU3RhdGVzID0gbmV3IFRyYWNraW5nVG9rZW5pemF0aW9uU3RhdGVTdG9yZSh0aGlzLl90ZXh0TW9kZWwuZ2V0TGluZUNvdW50KCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnQmFja2dyb3VuZFRva2VuaXplci5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnQmFja2dyb3VuZFRva2VuaXplci52YWx1ZSA9IHRva2VuaXphdGlvblN1cHBvcnQuY3JlYXRlQmFja2dyb3VuZFRva2VuaXplcih0aGlzLl90ZXh0TW9kZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VG9rZW5zOiAodG9rZW5zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1Z0JhY2tncm91bmRUb2tlbnM/LnNldE11bHRpbGluZVRva2Vucyh0b2tlbnMsIHRoaXMuX3RleHRNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRUb2tlbml6YXRpb25GaW5pc2hlZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PIE9QXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldEVuZFN0YXRlOiAobGluZU51bWJlciwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnQmFja2dyb3VuZFN0YXRlcz8uc2V0RW5kU3RhdGUobGluZU51bWJlciwgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWdCYWNrZ3JvdW5kVG9rZW5zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnQmFja2dyb3VuZFN0YXRlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1Z0JhY2tncm91bmRUb2tlbml6ZXIudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZyZXNoQWxsVmlzaWJsZUxpbmVUb2tlbnMoKTtcbiAgICB9XG4gICAgaGFuZGxlRGlkQ2hhbmdlQXR0YWNoZWQoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRCYWNrZ3JvdW5kVG9rZW5pemVyPy5oYW5kbGVDaGFuZ2VzKCk7XG4gICAgfVxuICAgIGhhbmRsZURpZENoYW5nZUNvbnRlbnQoZSkge1xuICAgICAgICBpZiAoZS5pc0ZsdXNoKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCwgYXMgdGhlIHZpZXcgbWlnaHQgbm90IGhhdmUgZ290IHRoZSB0ZXh0IGNoYW5nZSBldmVudCB5ZXRcbiAgICAgICAgICAgIHRoaXMucmVzZXRUb2tlbml6YXRpb24oZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFlLmlzRW9sQ2hhbmdlKSB7IC8vIFdlIGRvbid0IGhhdmUgdG8gZG8gYW55dGhpbmcgb24gYW4gRU9MIGNoYW5nZVxuICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGUuY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtlb2xDb3VudCwgZmlyc3RMaW5lTGVuZ3RoXSA9IGNvdW50RU9MKGMudGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5zLmFjY2VwdEVkaXQoYy5yYW5nZSwgZW9sQ291bnQsIGZpcnN0TGluZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWdCYWNrZ3JvdW5kVG9rZW5zPy5hY2NlcHRFZGl0KGMucmFuZ2UsIGVvbENvdW50LCBmaXJzdExpbmVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVidWdCYWNrZ3JvdW5kU3RhdGVzPy5hY2NlcHRDaGFuZ2VzKGUuY2hhbmdlcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9rZW5pemVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5pemVyLnN0b3JlLmFjY2VwdENoYW5nZXMoZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRCYWNrZ3JvdW5kVG9rZW5pemVyPy5oYW5kbGVDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VG9rZW5zKHRva2Vucykge1xuICAgICAgICBjb25zdCB7IGNoYW5nZXMgfSA9IHRoaXMuX3Rva2Vucy5zZXRNdWx0aWxpbmVUb2tlbnModG9rZW5zLCB0aGlzLl90ZXh0TW9kZWwpO1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZVRva2Vucy5maXJlKHsgc2VtYW50aWNUb2tlbnNBcHBsaWVkOiBmYWxzZSwgcmFuZ2VzOiBjaGFuZ2VzLCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBjaGFuZ2VzIH07XG4gICAgfVxuICAgIHJlZnJlc2hBbGxWaXNpYmxlTGluZVRva2VucygpIHtcbiAgICAgICAgY29uc3QgcmFuZ2VzID0gTGluZVJhbmdlLmpvaW5NYW55KFsuLi50aGlzLl9hdHRhY2hlZFZpZXdTdGF0ZXNdLm1hcCgoW18sIHNdKSA9PiBzLmxpbmVSYW5nZXMpKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoUmFuZ2VzKHJhbmdlcyk7XG4gICAgfVxuICAgIHJlZnJlc2hSYW5nZXMocmFuZ2VzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgcmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hSYW5nZShyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWZyZXNoUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBlbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW5pemVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gTWF0aC5tYXgoMSwgTWF0aC5taW4odGhpcy5fdGV4dE1vZGVsLmdldExpbmVDb3VudCgpLCBzdGFydExpbmVOdW1iZXIpKTtcbiAgICAgICAgZW5kTGluZU51bWJlciA9IE1hdGgubWluKHRoaXMuX3RleHRNb2RlbC5nZXRMaW5lQ291bnQoKSwgZW5kTGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgQ29udGlndW91c011bHRpbGluZVRva2Vuc0J1aWxkZXIoKTtcbiAgICAgICAgY29uc3QgeyBoZXVyaXN0aWNUb2tlbnMgfSA9IHRoaXMuX3Rva2VuaXplci50b2tlbml6ZUhldXJpc3RpY2FsbHkoYnVpbGRlciwgc3RhcnRMaW5lTnVtYmVyLCBlbmRMaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgY2hhbmdlZFRva2VucyA9IHRoaXMuc2V0VG9rZW5zKGJ1aWxkZXIuZmluYWxpemUoKSk7XG4gICAgICAgIGlmIChoZXVyaXN0aWNUb2tlbnMpIHtcbiAgICAgICAgICAgIC8vIFdlIG92ZXJyb2RlIHRva2VucyB3aXRoIGhldXJpc3RpY2FsbHkgY29tcHV0ZWQgb25lcy5cbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugb2xkIHN0YXRlcyBtaWdodCBnZXQgcmV1c2VkICh0aHVzIHN0b3BwaW5nIGludmFsaWRhdGlvbiksXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGV4cGxpY2l0bHkgcmVxdWVzdCB0aGUgdG9rZW5zIGZvciB0aGUgY2hhbmdlZCByYW5nZXMgYWdhaW4uXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2hhbmdlZFRva2Vucy5jaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZFRva2VuaXplci52YWx1ZT8ucmVxdWVzdFRva2VucyhjLmZyb21MaW5lTnVtYmVyLCBjLnRvTGluZU51bWJlciArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlZmF1bHRCYWNrZ3JvdW5kVG9rZW5pemVyPy5jaGVja0ZpbmlzaGVkKCk7XG4gICAgfVxuICAgIGZvcmNlVG9rZW5pemF0aW9uKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgY29uc3QgYnVpbGRlciA9IG5ldyBDb250aWd1b3VzTXVsdGlsaW5lVG9rZW5zQnVpbGRlcigpO1xuICAgICAgICB0aGlzLl90b2tlbml6ZXI/LnVwZGF0ZVRva2Vuc1VudGlsTGluZShidWlsZGVyLCBsaW5lTnVtYmVyKTtcbiAgICAgICAgdGhpcy5zZXRUb2tlbnMoYnVpbGRlci5maW5hbGl6ZSgpKTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEJhY2tncm91bmRUb2tlbml6ZXI/LmNoZWNrRmluaXNoZWQoKTtcbiAgICB9XG4gICAgaGFzQWNjdXJhdGVUb2tlbnNGb3JMaW5lKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbml6ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbml6ZXIuaGFzQWNjdXJhdGVUb2tlbnNGb3JMaW5lKGxpbmVOdW1iZXIpO1xuICAgIH1cbiAgICBpc0NoZWFwVG9Ub2tlbml6ZShsaW5lTnVtYmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW5pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5pemVyLmlzQ2hlYXBUb1Rva2VuaXplKGxpbmVOdW1iZXIpO1xuICAgIH1cbiAgICBnZXRMaW5lVG9rZW5zKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgY29uc3QgbGluZVRleHQgPSB0aGlzLl90ZXh0TW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3Rva2Vucy5nZXRUb2tlbnModGhpcy5fdGV4dE1vZGVsLmdldExhbmd1YWdlSWQoKSwgbGluZU51bWJlciAtIDEsIGxpbmVUZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnQmFja2dyb3VuZFRva2VucyAmJiB0aGlzLl9kZWJ1Z0JhY2tncm91bmRTdGF0ZXMgJiYgdGhpcy5fdG9rZW5pemVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVidWdCYWNrZ3JvdW5kU3RhdGVzLmdldEZpcnN0SW52YWxpZEVuZFN0YXRlTGluZU51bWJlck9yTWF4KCkgPiBsaW5lTnVtYmVyICYmIHRoaXMuX3Rva2VuaXplci5zdG9yZS5nZXRGaXJzdEludmFsaWRFbmRTdGF0ZUxpbmVOdW1iZXJPck1heCgpID4gbGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhY2tncm91bmRSZXN1bHQgPSB0aGlzLl9kZWJ1Z0JhY2tncm91bmRUb2tlbnMuZ2V0VG9rZW5zKHRoaXMuX3RleHRNb2RlbC5nZXRMYW5ndWFnZUlkKCksIGxpbmVOdW1iZXIgLSAxLCBsaW5lVGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXF1YWxzKGJhY2tncm91bmRSZXN1bHQpICYmIHRoaXMuX2RlYnVnQmFja2dyb3VuZFRva2VuaXplci52YWx1ZT8ucmVwb3J0TWlzbWF0Y2hpbmdUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWdCYWNrZ3JvdW5kVG9rZW5pemVyLnZhbHVlLnJlcG9ydE1pc21hdGNoaW5nVG9rZW5zKGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRUb2tlblR5cGVJZkluc2VydGluZ0NoYXJhY3RlcihsaW5lTnVtYmVyLCBjb2x1bW4sIGNoYXJhY3Rlcikge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuaXplcikge1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogU3RhbmRhcmRUb2tlblR5cGUuT3RoZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl90ZXh0TW9kZWwudmFsaWRhdGVQb3NpdGlvbihuZXcgUG9zaXRpb24obGluZU51bWJlciwgY29sdW1uKSk7XG4gICAgICAgIHRoaXMuZm9yY2VUb2tlbml6YXRpb24ocG9zaXRpb24ubGluZU51bWJlcik7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbml6ZXIuZ2V0VG9rZW5UeXBlSWZJbnNlcnRpbmdDaGFyYWN0ZXIocG9zaXRpb24sIGNoYXJhY3Rlcik7XG4gICAgfVxuICAgIHRva2VuaXplTGluZVdpdGhFZGl0KHBvc2l0aW9uLCBsZW5ndGgsIG5ld1RleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbml6ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZFBvc2l0aW9uID0gdGhpcy5fdGV4dE1vZGVsLnZhbGlkYXRlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB0aGlzLmZvcmNlVG9rZW5pemF0aW9uKHZhbGlkYXRlZFBvc2l0aW9uLmxpbmVOdW1iZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5pemVyLnRva2VuaXplTGluZVdpdGhFZGl0KHZhbGlkYXRlZFBvc2l0aW9uLCBsZW5ndGgsIG5ld1RleHQpO1xuICAgIH1cbiAgICBnZXQgaGFzVG9rZW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5zLmhhc1Rva2VucztcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGVxdWFscyB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2FycmF5cy5qcyc7XG5pbXBvcnQgeyBSdW5PbmNlU2NoZWR1bGVyIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vYXN5bmMuanMnO1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2V2ZW50LmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgTGluZVJhbmdlIH0gZnJvbSAnLi4vY29yZS9saW5lUmFuZ2UuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEF0dGFjaGVkVmlld3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZVZpc2libGVSYW5nZXMgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlVmlzaWJsZVJhbmdlcyA9IHRoaXMuX29uRGlkQ2hhbmdlVmlzaWJsZVJhbmdlcy5ldmVudDtcbiAgICAgICAgdGhpcy5fdmlld3MgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGF0dGFjaFZpZXcoKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgQXR0YWNoZWRWaWV3SW1wbCgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlVmlzaWJsZVJhbmdlcy5maXJlKHsgdmlldywgc3RhdGUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl92aWV3cy5hZGQodmlldyk7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH1cbiAgICBkZXRhY2hWaWV3KHZpZXcpIHtcbiAgICAgICAgdGhpcy5fdmlld3MuZGVsZXRlKHZpZXcpO1xuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZVZpc2libGVSYW5nZXMuZmlyZSh7IHZpZXcsIHN0YXRlOiB1bmRlZmluZWQgfSk7XG4gICAgfVxufVxuY2xhc3MgQXR0YWNoZWRWaWV3SW1wbCB7XG4gICAgY29uc3RydWN0b3IoaGFuZGxlU3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTdGF0ZUNoYW5nZSA9IGhhbmRsZVN0YXRlQ2hhbmdlO1xuICAgIH1cbiAgICBzZXRWaXNpYmxlTGluZXModmlzaWJsZUxpbmVzLCBzdGFiaWxpemVkKSB7XG4gICAgICAgIGNvbnN0IHZpc2libGVMaW5lUmFuZ2VzID0gdmlzaWJsZUxpbmVzLm1hcCgobGluZSkgPT4gbmV3IExpbmVSYW5nZShsaW5lLnN0YXJ0TGluZU51bWJlciwgbGluZS5lbmRMaW5lTnVtYmVyICsgMSkpO1xuICAgICAgICB0aGlzLmhhbmRsZVN0YXRlQ2hhbmdlKHsgdmlzaWJsZUxpbmVSYW5nZXMsIHN0YWJpbGl6ZWQgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF0dGFjaGVkVmlld0hhbmRsZXIgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgICBnZXQgbGluZVJhbmdlcygpIHsgcmV0dXJuIHRoaXMuX2xpbmVSYW5nZXM7IH1cbiAgICBjb25zdHJ1Y3RvcihfcmVmcmVzaFRva2Vucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoVG9rZW5zID0gX3JlZnJlc2hUb2tlbnM7XG4gICAgICAgIHRoaXMucnVubmVyID0gdGhpcy5fcmVnaXN0ZXIobmV3IFJ1bk9uY2VTY2hlZHVsZXIoKCkgPT4gdGhpcy51cGRhdGUoKSwgNTApKTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZWRMaW5lUmFuZ2VzID0gW107XG4gICAgICAgIHRoaXMuX2xpbmVSYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAoZXF1YWxzKHRoaXMuX2NvbXB1dGVkTGluZVJhbmdlcywgdGhpcy5fbGluZVJhbmdlcywgKGEsIGIpID0+IGEuZXF1YWxzKGIpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbXB1dGVkTGluZVJhbmdlcyA9IHRoaXMuX2xpbmVSYW5nZXM7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hUb2tlbnMoKTtcbiAgICB9XG4gICAgaGFuZGxlU3RhdGVDaGFuZ2Uoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5fbGluZVJhbmdlcyA9IHN0YXRlLnZpc2libGVMaW5lUmFuZ2VzO1xuICAgICAgICBpZiAoc3RhdGUuc3RhYmlsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5ydW5uZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ydW5uZXIuc2NoZWR1bGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFRva2VucyBleHRlbmRzIERpc3Bvc2FibGUge1xuICAgIGdldCBiYWNrZ3JvdW5kVG9rZW5pemF0aW9uU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kVG9rZW5pemF0aW9uU3RhdGU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9sYW5ndWFnZUlkQ29kZWMsIF90ZXh0TW9kZWwsIGdldExhbmd1YWdlSWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbGFuZ3VhZ2VJZENvZGVjID0gX2xhbmd1YWdlSWRDb2RlYztcbiAgICAgICAgdGhpcy5fdGV4dE1vZGVsID0gX3RleHRNb2RlbDtcbiAgICAgICAgdGhpcy5nZXRMYW5ndWFnZUlkID0gZ2V0TGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZFRva2VuaXphdGlvblN0YXRlID0gMSAvKiBCYWNrZ3JvdW5kVG9rZW5pemF0aW9uU3RhdGUuSW5Qcm9ncmVzcyAqLztcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VCYWNrZ3JvdW5kVG9rZW5pemF0aW9uU3RhdGUgPSB0aGlzLl9yZWdpc3RlcihuZXcgRW1pdHRlcigpKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCwgc2hvdWxkIG5vdCBiZSBleHBvc2VkIGJ5IHRoZSB0ZXh0IG1vZGVsISAqL1xuICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlQmFja2dyb3VuZFRva2VuaXphdGlvblN0YXRlID0gdGhpcy5fb25EaWRDaGFuZ2VCYWNrZ3JvdW5kVG9rZW5pemF0aW9uU3RhdGUuZXZlbnQ7XG4gICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlVG9rZW5zID0gdGhpcy5fcmVnaXN0ZXIobmV3IEVtaXR0ZXIoKSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwsIHNob3VsZCBub3QgYmUgZXhwb3NlZCBieSB0aGUgdGV4dCBtb2RlbCEgKi9cbiAgICAgICAgdGhpcy5vbkRpZENoYW5nZVRva2VucyA9IHRoaXMuX29uRGlkQ2hhbmdlVG9rZW5zLmV2ZW50O1xuICAgIH1cbiAgICB0b2tlbml6ZUlmQ2hlYXAobGluZU51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5pc0NoZWFwVG9Ub2tlbml6ZShsaW5lTnVtYmVyKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JjZVRva2VuaXphdGlvbihsaW5lTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgVHJlZVNpdHRlclRva2VuaXphdGlvblJlZ2lzdHJ5IH0gZnJvbSAnLi4vbGFuZ3VhZ2VzLmpzJztcbmltcG9ydCB7IExpbmVUb2tlbnMgfSBmcm9tICcuLi90b2tlbnMvbGluZVRva2Vucy5qcyc7XG5pbXBvcnQgeyBBYnN0cmFjdFRva2VucyB9IGZyb20gJy4vdG9rZW5zLmpzJztcbmV4cG9ydCBjbGFzcyBUcmVlU2l0dGVyVG9rZW5zIGV4dGVuZHMgQWJzdHJhY3RUb2tlbnMge1xuICAgIGNvbnN0cnVjdG9yKF90cmVlU2l0dGVyU2VydmljZSwgbGFuZ3VhZ2VJZENvZGVjLCB0ZXh0TW9kZWwsIGxhbmd1YWdlSWQpIHtcbiAgICAgICAgc3VwZXIobGFuZ3VhZ2VJZENvZGVjLCB0ZXh0TW9kZWwsIGxhbmd1YWdlSWQpO1xuICAgICAgICB0aGlzLl90cmVlU2l0dGVyU2VydmljZSA9IF90cmVlU2l0dGVyU2VydmljZTtcbiAgICAgICAgdGhpcy5fdG9rZW5pemF0aW9uU3VwcG9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICB9XG4gICAgX2luaXRpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IG5ld0xhbmd1YWdlID0gdGhpcy5nZXRMYW5ndWFnZUlkKCk7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW5pemF0aW9uU3VwcG9ydCB8fCB0aGlzLl9sYXN0TGFuZ3VhZ2VJZCAhPT0gbmV3TGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RMYW5ndWFnZUlkID0gbmV3TGFuZ3VhZ2U7XG4gICAgICAgICAgICB0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0ID0gVHJlZVNpdHRlclRva2VuaXphdGlvblJlZ2lzdHJ5LmdldChuZXdMYW5ndWFnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TGluZVRva2VucyhsaW5lTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl90ZXh0TW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcik7XG4gICAgICAgIGlmICh0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0KSB7XG4gICAgICAgICAgICBjb25zdCByYXdUb2tlbnMgPSB0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0LnRva2VuaXplRW5jb2RlZChsaW5lTnVtYmVyLCB0aGlzLl90ZXh0TW9kZWwpO1xuICAgICAgICAgICAgaWYgKHJhd1Rva2Vucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGluZVRva2VucyhyYXdUb2tlbnMsIGNvbnRlbnQsIHRoaXMuX2xhbmd1YWdlSWRDb2RlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIExpbmVUb2tlbnMuY3JlYXRlRW1wdHkoY29udGVudCwgdGhpcy5fbGFuZ3VhZ2VJZENvZGVjKTtcbiAgICB9XG4gICAgcmVzZXRUb2tlbml6YXRpb24oZmlyZVRva2VuQ2hhbmdlRXZlbnQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChmaXJlVG9rZW5DaGFuZ2VFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2VUb2tlbnMuZmlyZSh7XG4gICAgICAgICAgICAgICAgc2VtYW50aWNUb2tlbnNBcHBsaWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByYW5nZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUxpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b0xpbmVOdW1iZXI6IHRoaXMuX3RleHRNb2RlbC5nZXRMaW5lQ291bnQoKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICBoYW5kbGVEaWRDaGFuZ2VBdHRhY2hlZCgpIHtcbiAgICAgICAgLy8gVE9ETyBAYWxleHIwMCBpbXBsZW1lbnQgZm9yIGJhY2tncm91bmQgdG9rZW5pemF0aW9uXG4gICAgfVxuICAgIGhhbmRsZURpZENoYW5nZUNvbnRlbnQoZSkge1xuICAgICAgICBpZiAoZS5pc0ZsdXNoKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCwgYXMgdGhlIHZpZXcgbWlnaHQgbm90IGhhdmUgZ290IHRoZSB0ZXh0IGNoYW5nZSBldmVudCB5ZXRcbiAgICAgICAgICAgIHRoaXMucmVzZXRUb2tlbml6YXRpb24oZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcmNlVG9rZW5pemF0aW9uKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgLy8gVE9ETyBAYWxleHIwMCBpbXBsZW1lbnRcbiAgICB9XG4gICAgaGFzQWNjdXJhdGVUb2tlbnNGb3JMaW5lKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgLy8gVE9ETyBAYWxleHIwMCB1cGRhdGUgZm9yIGJhY2tncm91bmQgdG9rZW5pemF0aW9uXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc0NoZWFwVG9Ub2tlbml6ZShsaW5lTnVtYmVyKSB7XG4gICAgICAgIC8vIFRPRE8gQGFsZXhyMDAgdXBkYXRlIGZvciBiYWNrZ3JvdW5kIHRva2VuaXphdGlvblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0VG9rZW5UeXBlSWZJbnNlcnRpbmdDaGFyYWN0ZXIobGluZU51bWJlciwgY29sdW1uLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgLy8gVE9ETyBAYWxleHIwMCBpbXBsZW1lbnQgb25jZSB3ZSBoYXZlIGN1c3RvbSBwYXJzaW5nIGFuZCBkb24ndCBqdXN0IGZlZWQgaW4gdGhlIHdob2xlIHRleHQgbW9kZWwgdmFsdWVcbiAgICAgICAgcmV0dXJuIDAgLyogU3RhbmRhcmRUb2tlblR5cGUuT3RoZXIgKi87XG4gICAgfVxuICAgIHRva2VuaXplTGluZVdpdGhFZGl0KHBvc2l0aW9uLCBsZW5ndGgsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gVE9ETyBAYWxleHIwMCB1bmRlcnN0YW5kIHdoYXQgdGhpcyBpcyBmb3IgYW5kIGltcGxlbWVudFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGhhc1Rva2VucygpIHtcbiAgICAgICAgLy8gVE9ETyBAYWxleHIwMCBvbmNlIHdlIGhhdmUgYSB0b2tlbiBzdG9yZSwgaW1wbGVtZW50IHByb3Blcmx5XG4gICAgICAgIGNvbnN0IGhhc1RyZWUgPSB0aGlzLl90cmVlU2l0dGVyU2VydmljZS5nZXRQYXJzZVJlc3VsdCh0aGlzLl90ZXh0TW9kZWwpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBoYXNUcmVlO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBSZXR1cm5zOlxuICogIC0gLTEgPT4gdGhlIGxpbmUgY29uc2lzdHMgb2Ygd2hpdGVzcGFjZVxuICogIC0gb3RoZXJ3aXNlID0+IHRoZSBpbmRlbnQgbGV2ZWwgaXMgcmV0dXJuZWQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbmRlbnRMZXZlbChsaW5lLCB0YWJTaXplKSB7XG4gICAgbGV0IGluZGVudCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGxlbiA9IGxpbmUubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGNvbnN0IGNoQ29kZSA9IGxpbmUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoQ29kZSA9PT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8pIHtcbiAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoQ29kZSA9PT0gOSAvKiBDaGFyQ29kZS5UYWIgKi8pIHtcbiAgICAgICAgICAgIGluZGVudCA9IGluZGVudCAtIGluZGVudCAlIHRhYlNpemUgKyB0YWJTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgIHJldHVybiAtMTsgLy8gbGluZSBvbmx5IGNvbnNpc3RzIG9mIHdoaXRlc3BhY2VcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudDtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG52YXIgTW9kZWxTZXJ2aWNlXzE7XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZXZlbnQuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSwgRGlzcG9zYWJsZVN0b3JlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCAqIGFzIHBsYXRmb3JtIGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IFRleHRNb2RlbCB9IGZyb20gJy4uL21vZGVsL3RleHRNb2RlbC5qcyc7XG5pbXBvcnQgeyBFRElUT1JfTU9ERUxfREVGQVVMVFMgfSBmcm9tICcuLi9jb3JlL3RleHRNb2RlbERlZmF1bHRzLmpzJztcbmltcG9ydCB7IFBMQUlOVEVYVF9MQU5HVUFHRV9JRCB9IGZyb20gJy4uL2xhbmd1YWdlcy9tb2Rlc1JlZ2lzdHJ5LmpzJztcbmltcG9ydCB7IElUZXh0UmVzb3VyY2VQcm9wZXJ0aWVzU2VydmljZSB9IGZyb20gJy4vdGV4dFJlc291cmNlQ29uZmlndXJhdGlvbi5qcyc7XG5pbXBvcnQgeyBJQ29uZmlndXJhdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9wbGF0Zm9ybS9jb25maWd1cmF0aW9uL2NvbW1vbi9jb25maWd1cmF0aW9uLmpzJztcbmltcG9ydCB7IElVbmRvUmVkb1NlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9wbGF0Zm9ybS91bmRvUmVkby9jb21tb24vdW5kb1JlZG8uanMnO1xuaW1wb3J0IHsgU3RyaW5nU0hBMSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2hhc2guanMnO1xuaW1wb3J0IHsgaXNFZGl0U3RhY2tFbGVtZW50IH0gZnJvbSAnLi4vbW9kZWwvZWRpdFN0YWNrLmpzJztcbmltcG9ydCB7IFNjaGVtYXMgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9uZXR3b3JrLmpzJztcbmltcG9ydCB7IGVxdWFscyB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL29iamVjdHMuanMnO1xuaW1wb3J0IHsgSUluc3RhbnRpYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vcGxhdGZvcm0vaW5zdGFudGlhdGlvbi9jb21tb24vaW5zdGFudGlhdGlvbi5qcyc7XG5mdW5jdGlvbiBNT0RFTF9JRChyZXNvdXJjZSkge1xuICAgIHJldHVybiByZXNvdXJjZS50b1N0cmluZygpO1xufVxuY2xhc3MgTW9kZWxEYXRhIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwgb25XaWxsRGlzcG9zZSwgb25EaWRDaGFuZ2VMYW5ndWFnZSkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuX21vZGVsRXZlbnRMaXN0ZW5lcnMgPSBuZXcgRGlzcG9zYWJsZVN0b3JlKCk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5fbW9kZWxFdmVudExpc3RlbmVycy5hZGQobW9kZWwub25XaWxsRGlzcG9zZSgoKSA9PiBvbldpbGxEaXNwb3NlKG1vZGVsKSkpO1xuICAgICAgICB0aGlzLl9tb2RlbEV2ZW50TGlzdGVuZXJzLmFkZChtb2RlbC5vbkRpZENoYW5nZUxhbmd1YWdlKChlKSA9PiBvbkRpZENoYW5nZUxhbmd1YWdlKG1vZGVsLCBlKSkpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9tb2RlbEV2ZW50TGlzdGVuZXJzLmRpc3Bvc2UoKTtcbiAgICB9XG59XG5jb25zdCBERUZBVUxUX0VPTCA9IChwbGF0Zm9ybS5pc0xpbnV4IHx8IHBsYXRmb3JtLmlzTWFjaW50b3NoKSA/IDEgLyogRGVmYXVsdEVuZE9mTGluZS5MRiAqLyA6IDIgLyogRGVmYXVsdEVuZE9mTGluZS5DUkxGICovO1xuY2xhc3MgRGlzcG9zZWRNb2RlbEluZm8ge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgaW5pdGlhbFVuZG9SZWRvU25hcHNob3QsIHRpbWUsIHNoYXJlc1VuZG9SZWRvU3RhY2ssIGhlYXBTaXplLCBzaGExLCB2ZXJzaW9uSWQsIGFsdGVybmF0aXZlVmVyc2lvbklkKSB7XG4gICAgICAgIHRoaXMudXJpID0gdXJpO1xuICAgICAgICB0aGlzLmluaXRpYWxVbmRvUmVkb1NuYXBzaG90ID0gaW5pdGlhbFVuZG9SZWRvU25hcHNob3Q7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMuc2hhcmVzVW5kb1JlZG9TdGFjayA9IHNoYXJlc1VuZG9SZWRvU3RhY2s7XG4gICAgICAgIHRoaXMuaGVhcFNpemUgPSBoZWFwU2l6ZTtcbiAgICAgICAgdGhpcy5zaGExID0gc2hhMTtcbiAgICAgICAgdGhpcy52ZXJzaW9uSWQgPSB2ZXJzaW9uSWQ7XG4gICAgICAgIHRoaXMuYWx0ZXJuYXRpdmVWZXJzaW9uSWQgPSBhbHRlcm5hdGl2ZVZlcnNpb25JZDtcbiAgICB9XG59XG5sZXQgTW9kZWxTZXJ2aWNlID0gY2xhc3MgTW9kZWxTZXJ2aWNlIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG4gICAgc3RhdGljIHsgTW9kZWxTZXJ2aWNlXzEgPSB0aGlzOyB9XG4gICAgc3RhdGljIHsgdGhpcy5NQVhfTUVNT1JZX0ZPUl9DTE9TRURfRklMRVNfVU5ET19TVEFDSyA9IDIwICogMTAyNCAqIDEwMjQ7IH1cbiAgICBjb25zdHJ1Y3RvcihfY29uZmlndXJhdGlvblNlcnZpY2UsIF9yZXNvdXJjZVByb3BlcnRpZXNTZXJ2aWNlLCBfdW5kb1JlZG9TZXJ2aWNlLCBfaW5zdGFudGlhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fY29uZmlndXJhdGlvblNlcnZpY2UgPSBfY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuX3Jlc291cmNlUHJvcGVydGllc1NlcnZpY2UgPSBfcmVzb3VyY2VQcm9wZXJ0aWVzU2VydmljZTtcbiAgICAgICAgdGhpcy5fdW5kb1JlZG9TZXJ2aWNlID0gX3VuZG9SZWRvU2VydmljZTtcbiAgICAgICAgdGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2UgPSBfaW5zdGFudGlhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuX29uTW9kZWxBZGRlZCA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBFbWl0dGVyKCkpO1xuICAgICAgICB0aGlzLm9uTW9kZWxBZGRlZCA9IHRoaXMuX29uTW9kZWxBZGRlZC5ldmVudDtcbiAgICAgICAgdGhpcy5fb25Nb2RlbFJlbW92ZWQgPSB0aGlzLl9yZWdpc3RlcihuZXcgRW1pdHRlcigpKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsUmVtb3ZlZCA9IHRoaXMuX29uTW9kZWxSZW1vdmVkLmV2ZW50O1xuICAgICAgICB0aGlzLl9vbk1vZGVsTW9kZUNoYW5nZWQgPSB0aGlzLl9yZWdpc3RlcihuZXcgRW1pdHRlcigpKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsTGFuZ3VhZ2VDaGFuZ2VkID0gdGhpcy5fb25Nb2RlbE1vZGVDaGFuZ2VkLmV2ZW50O1xuICAgICAgICB0aGlzLl9tb2RlbENyZWF0aW9uT3B0aW9uc0J5TGFuZ3VhZ2VBbmRSZXNvdXJjZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX21vZGVscyA9IHt9O1xuICAgICAgICB0aGlzLl9kaXNwb3NlZE1vZGVscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZWRNb2RlbHNIZWFwU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyKHRoaXMuX2NvbmZpZ3VyYXRpb25TZXJ2aWNlLm9uRGlkQ2hhbmdlQ29uZmlndXJhdGlvbihlID0+IHRoaXMuX3VwZGF0ZU1vZGVsT3B0aW9ucyhlKSkpO1xuICAgICAgICB0aGlzLl91cGRhdGVNb2RlbE9wdGlvbnModW5kZWZpbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIF9yZWFkTW9kZWxPcHRpb25zKGNvbmZpZywgaXNGb3JTaW1wbGVXaWRnZXQpIHtcbiAgICAgICAgbGV0IHRhYlNpemUgPSBFRElUT1JfTU9ERUxfREVGQVVMVFMudGFiU2l6ZTtcbiAgICAgICAgaWYgKGNvbmZpZy5lZGl0b3IgJiYgdHlwZW9mIGNvbmZpZy5lZGl0b3IudGFiU2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFRhYlNpemUgPSBwYXJzZUludChjb25maWcuZWRpdG9yLnRhYlNpemUsIDEwKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VkVGFiU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICB0YWJTaXplID0gcGFyc2VkVGFiU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWJTaXplIDwgMSkge1xuICAgICAgICAgICAgICAgIHRhYlNpemUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRlbnRTaXplID0gJ3RhYlNpemUnO1xuICAgICAgICBpZiAoY29uZmlnLmVkaXRvciAmJiB0eXBlb2YgY29uZmlnLmVkaXRvci5pbmRlbnRTaXplICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuZWRpdG9yLmluZGVudFNpemUgIT09ICd0YWJTaXplJykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkSW5kZW50U2l6ZSA9IHBhcnNlSW50KGNvbmZpZy5lZGl0b3IuaW5kZW50U2l6ZSwgMTApO1xuICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZWRJbmRlbnRTaXplKSkge1xuICAgICAgICAgICAgICAgIGluZGVudFNpemUgPSBNYXRoLm1heChwYXJzZWRJbmRlbnRTaXplLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5zZXJ0U3BhY2VzID0gRURJVE9SX01PREVMX0RFRkFVTFRTLmluc2VydFNwYWNlcztcbiAgICAgICAgaWYgKGNvbmZpZy5lZGl0b3IgJiYgdHlwZW9mIGNvbmZpZy5lZGl0b3IuaW5zZXJ0U3BhY2VzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaW5zZXJ0U3BhY2VzID0gKGNvbmZpZy5lZGl0b3IuaW5zZXJ0U3BhY2VzID09PSAnZmFsc2UnID8gZmFsc2UgOiBCb29sZWFuKGNvbmZpZy5lZGl0b3IuaW5zZXJ0U3BhY2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0RlZmF1bHRFT0wgPSBERUZBVUxUX0VPTDtcbiAgICAgICAgY29uc3QgZW9sID0gY29uZmlnLmVvbDtcbiAgICAgICAgaWYgKGVvbCA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgICAgIG5ld0RlZmF1bHRFT0wgPSAyIC8qIERlZmF1bHRFbmRPZkxpbmUuQ1JMRiAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlb2wgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBuZXdEZWZhdWx0RU9MID0gMSAvKiBEZWZhdWx0RW5kT2ZMaW5lLkxGICovO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0cmltQXV0b1doaXRlc3BhY2UgPSBFRElUT1JfTU9ERUxfREVGQVVMVFMudHJpbUF1dG9XaGl0ZXNwYWNlO1xuICAgICAgICBpZiAoY29uZmlnLmVkaXRvciAmJiB0eXBlb2YgY29uZmlnLmVkaXRvci50cmltQXV0b1doaXRlc3BhY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0cmltQXV0b1doaXRlc3BhY2UgPSAoY29uZmlnLmVkaXRvci50cmltQXV0b1doaXRlc3BhY2UgPT09ICdmYWxzZScgPyBmYWxzZSA6IEJvb2xlYW4oY29uZmlnLmVkaXRvci50cmltQXV0b1doaXRlc3BhY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGV0ZWN0SW5kZW50YXRpb24gPSBFRElUT1JfTU9ERUxfREVGQVVMVFMuZGV0ZWN0SW5kZW50YXRpb247XG4gICAgICAgIGlmIChjb25maWcuZWRpdG9yICYmIHR5cGVvZiBjb25maWcuZWRpdG9yLmRldGVjdEluZGVudGF0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGV0ZWN0SW5kZW50YXRpb24gPSAoY29uZmlnLmVkaXRvci5kZXRlY3RJbmRlbnRhdGlvbiA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogQm9vbGVhbihjb25maWcuZWRpdG9yLmRldGVjdEluZGVudGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhcmdlRmlsZU9wdGltaXphdGlvbnMgPSBFRElUT1JfTU9ERUxfREVGQVVMVFMubGFyZ2VGaWxlT3B0aW1pemF0aW9ucztcbiAgICAgICAgaWYgKGNvbmZpZy5lZGl0b3IgJiYgdHlwZW9mIGNvbmZpZy5lZGl0b3IubGFyZ2VGaWxlT3B0aW1pemF0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxhcmdlRmlsZU9wdGltaXphdGlvbnMgPSAoY29uZmlnLmVkaXRvci5sYXJnZUZpbGVPcHRpbWl6YXRpb25zID09PSAnZmFsc2UnID8gZmFsc2UgOiBCb29sZWFuKGNvbmZpZy5lZGl0b3IubGFyZ2VGaWxlT3B0aW1pemF0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBicmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnMgPSBFRElUT1JfTU9ERUxfREVGQVVMVFMuYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zO1xuICAgICAgICBpZiAoY29uZmlnLmVkaXRvcj8uYnJhY2tldFBhaXJDb2xvcml6YXRpb24gJiYgdHlwZW9mIGNvbmZpZy5lZGl0b3IuYnJhY2tldFBhaXJDb2xvcml6YXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBicmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogISFjb25maWcuZWRpdG9yLmJyYWNrZXRQYWlyQ29sb3JpemF0aW9uLmVuYWJsZWQsXG4gICAgICAgICAgICAgICAgaW5kZXBlbmRlbnRDb2xvclBvb2xQZXJCcmFja2V0VHlwZTogISFjb25maWcuZWRpdG9yLmJyYWNrZXRQYWlyQ29sb3JpemF0aW9uLmluZGVwZW5kZW50Q29sb3JQb29sUGVyQnJhY2tldFR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzRm9yU2ltcGxlV2lkZ2V0OiBpc0ZvclNpbXBsZVdpZGdldCxcbiAgICAgICAgICAgIHRhYlNpemU6IHRhYlNpemUsXG4gICAgICAgICAgICBpbmRlbnRTaXplOiBpbmRlbnRTaXplLFxuICAgICAgICAgICAgaW5zZXJ0U3BhY2VzOiBpbnNlcnRTcGFjZXMsXG4gICAgICAgICAgICBkZXRlY3RJbmRlbnRhdGlvbjogZGV0ZWN0SW5kZW50YXRpb24sXG4gICAgICAgICAgICBkZWZhdWx0RU9MOiBuZXdEZWZhdWx0RU9MLFxuICAgICAgICAgICAgdHJpbUF1dG9XaGl0ZXNwYWNlOiB0cmltQXV0b1doaXRlc3BhY2UsXG4gICAgICAgICAgICBsYXJnZUZpbGVPcHRpbWl6YXRpb25zOiBsYXJnZUZpbGVPcHRpbWl6YXRpb25zLFxuICAgICAgICAgICAgYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRFT0wocmVzb3VyY2UsIGxhbmd1YWdlKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc291cmNlUHJvcGVydGllc1NlcnZpY2UuZ2V0RU9MKHJlc291cmNlLCBsYW5ndWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW9sID0gdGhpcy5fY29uZmlndXJhdGlvblNlcnZpY2UuZ2V0VmFsdWUoJ2ZpbGVzLmVvbCcsIHsgb3ZlcnJpZGVJZGVudGlmaWVyOiBsYW5ndWFnZSB9KTtcbiAgICAgICAgaWYgKGVvbCAmJiB0eXBlb2YgZW9sID09PSAnc3RyaW5nJyAmJiBlb2wgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmV0dXJuIGVvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhdGZvcm0uT1MgPT09IDMgLyogcGxhdGZvcm0uT3BlcmF0aW5nU3lzdGVtLkxpbnV4ICovIHx8IHBsYXRmb3JtLk9TID09PSAyIC8qIHBsYXRmb3JtLk9wZXJhdGluZ1N5c3RlbS5NYWNpbnRvc2ggKi8gPyAnXFxuJyA6ICdcXHJcXG4nO1xuICAgIH1cbiAgICBfc2hvdWxkUmVzdG9yZVVuZG9TdGFjaygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY29uZmlndXJhdGlvblNlcnZpY2UuZ2V0VmFsdWUoJ2ZpbGVzLnJlc3RvcmVVbmRvU3RhY2snKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0Q3JlYXRpb25PcHRpb25zKGxhbmd1YWdlSWRPclNlbGVjdGlvbiwgcmVzb3VyY2UsIGlzRm9yU2ltcGxlV2lkZ2V0KSB7XG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gKHR5cGVvZiBsYW5ndWFnZUlkT3JTZWxlY3Rpb24gPT09ICdzdHJpbmcnID8gbGFuZ3VhZ2VJZE9yU2VsZWN0aW9uIDogbGFuZ3VhZ2VJZE9yU2VsZWN0aW9uLmxhbmd1YWdlSWQpO1xuICAgICAgICBsZXQgY3JlYXRpb25PcHRpb25zID0gdGhpcy5fbW9kZWxDcmVhdGlvbk9wdGlvbnNCeUxhbmd1YWdlQW5kUmVzb3VyY2VbbGFuZ3VhZ2UgKyByZXNvdXJjZV07XG4gICAgICAgIGlmICghY3JlYXRpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9jb25maWd1cmF0aW9uU2VydmljZS5nZXRWYWx1ZSgnZWRpdG9yJywgeyBvdmVycmlkZUlkZW50aWZpZXI6IGxhbmd1YWdlLCByZXNvdXJjZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGVvbCA9IHRoaXMuX2dldEVPTChyZXNvdXJjZSwgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgY3JlYXRpb25PcHRpb25zID0gTW9kZWxTZXJ2aWNlXzEuX3JlYWRNb2RlbE9wdGlvbnMoeyBlZGl0b3IsIGVvbCB9LCBpc0ZvclNpbXBsZVdpZGdldCk7XG4gICAgICAgICAgICB0aGlzLl9tb2RlbENyZWF0aW9uT3B0aW9uc0J5TGFuZ3VhZ2VBbmRSZXNvdXJjZVtsYW5ndWFnZSArIHJlc291cmNlXSA9IGNyZWF0aW9uT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRpb25PcHRpb25zO1xuICAgIH1cbiAgICBfdXBkYXRlTW9kZWxPcHRpb25zKGUpIHtcbiAgICAgICAgY29uc3Qgb2xkT3B0aW9uc0J5TGFuZ3VhZ2VBbmRSZXNvdXJjZSA9IHRoaXMuX21vZGVsQ3JlYXRpb25PcHRpb25zQnlMYW5ndWFnZUFuZFJlc291cmNlO1xuICAgICAgICB0aGlzLl9tb2RlbENyZWF0aW9uT3B0aW9uc0J5TGFuZ3VhZ2VBbmRSZXNvdXJjZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8vIFVwZGF0ZSBvcHRpb25zIG9uIGFsbCBtb2RlbHNcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX21vZGVscyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbElkID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsRGF0YSA9IHRoaXMuX21vZGVsc1ttb2RlbElkXTtcbiAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gbW9kZWxEYXRhLm1vZGVsLmdldExhbmd1YWdlSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG1vZGVsRGF0YS5tb2RlbC51cmk7XG4gICAgICAgICAgICBpZiAoZSAmJiAhZS5hZmZlY3RzQ29uZmlndXJhdGlvbignZWRpdG9yJywgeyBvdmVycmlkZUlkZW50aWZpZXI6IGxhbmd1YWdlLCByZXNvdXJjZTogdXJpIH0pICYmICFlLmFmZmVjdHNDb25maWd1cmF0aW9uKCdmaWxlcy5lb2wnLCB7IG92ZXJyaWRlSWRlbnRpZmllcjogbGFuZ3VhZ2UsIHJlc291cmNlOiB1cmkgfSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gcGVyZjogc2tpcCBpZiB0aGlzIG1vZGVsIGlzIG5vdCBhZmZlY3RlZCBieSBjb25maWd1cmF0aW9uIGNoYW5nZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2xkT3B0aW9ucyA9IG9sZE9wdGlvbnNCeUxhbmd1YWdlQW5kUmVzb3VyY2VbbGFuZ3VhZ2UgKyB1cmldO1xuICAgICAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHRoaXMuZ2V0Q3JlYXRpb25PcHRpb25zKGxhbmd1YWdlLCB1cmksIG1vZGVsRGF0YS5tb2RlbC5pc0ZvclNpbXBsZVdpZGdldCk7XG4gICAgICAgICAgICBNb2RlbFNlcnZpY2VfMS5fc2V0TW9kZWxPcHRpb25zRm9yTW9kZWwobW9kZWxEYXRhLm1vZGVsLCBuZXdPcHRpb25zLCBvbGRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgX3NldE1vZGVsT3B0aW9uc0Zvck1vZGVsKG1vZGVsLCBuZXdPcHRpb25zLCBjdXJyZW50T3B0aW9ucykge1xuICAgICAgICBpZiAoY3VycmVudE9wdGlvbnMgJiYgY3VycmVudE9wdGlvbnMuZGVmYXVsdEVPTCAhPT0gbmV3T3B0aW9ucy5kZWZhdWx0RU9MICYmIG1vZGVsLmdldExpbmVDb3VudCgpID09PSAxKSB7XG4gICAgICAgICAgICBtb2RlbC5zZXRFT0wobmV3T3B0aW9ucy5kZWZhdWx0RU9MID09PSAxIC8qIERlZmF1bHRFbmRPZkxpbmUuTEYgKi8gPyAwIC8qIEVuZE9mTGluZVNlcXVlbmNlLkxGICovIDogMSAvKiBFbmRPZkxpbmVTZXF1ZW5jZS5DUkxGICovKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudE9wdGlvbnNcbiAgICAgICAgICAgICYmIChjdXJyZW50T3B0aW9ucy5kZXRlY3RJbmRlbnRhdGlvbiA9PT0gbmV3T3B0aW9ucy5kZXRlY3RJbmRlbnRhdGlvbilcbiAgICAgICAgICAgICYmIChjdXJyZW50T3B0aW9ucy5pbnNlcnRTcGFjZXMgPT09IG5ld09wdGlvbnMuaW5zZXJ0U3BhY2VzKVxuICAgICAgICAgICAgJiYgKGN1cnJlbnRPcHRpb25zLnRhYlNpemUgPT09IG5ld09wdGlvbnMudGFiU2l6ZSlcbiAgICAgICAgICAgICYmIChjdXJyZW50T3B0aW9ucy5pbmRlbnRTaXplID09PSBuZXdPcHRpb25zLmluZGVudFNpemUpXG4gICAgICAgICAgICAmJiAoY3VycmVudE9wdGlvbnMudHJpbUF1dG9XaGl0ZXNwYWNlID09PSBuZXdPcHRpb25zLnRyaW1BdXRvV2hpdGVzcGFjZSlcbiAgICAgICAgICAgICYmIGVxdWFscyhjdXJyZW50T3B0aW9ucy5icmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnMsIG5ld09wdGlvbnMuYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zKSkge1xuICAgICAgICAgICAgLy8gU2FtZSBpbmRlbnQgb3B0cywgbm8gbmVlZCB0byB0b3VjaCB0aGUgbW9kZWxcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3T3B0aW9ucy5kZXRlY3RJbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgbW9kZWwuZGV0ZWN0SW5kZW50YXRpb24obmV3T3B0aW9ucy5pbnNlcnRTcGFjZXMsIG5ld09wdGlvbnMudGFiU2l6ZSk7XG4gICAgICAgICAgICBtb2RlbC51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgICAgICB0cmltQXV0b1doaXRlc3BhY2U6IG5ld09wdGlvbnMudHJpbUF1dG9XaGl0ZXNwYWNlLFxuICAgICAgICAgICAgICAgIGJyYWNrZXRDb2xvcml6YXRpb25PcHRpb25zOiBuZXdPcHRpb25zLmJyYWNrZXRQYWlyQ29sb3JpemF0aW9uT3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtb2RlbC51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBpbnNlcnRTcGFjZXM6IG5ld09wdGlvbnMuaW5zZXJ0U3BhY2VzLFxuICAgICAgICAgICAgICAgIHRhYlNpemU6IG5ld09wdGlvbnMudGFiU2l6ZSxcbiAgICAgICAgICAgICAgICBpbmRlbnRTaXplOiBuZXdPcHRpb25zLmluZGVudFNpemUsXG4gICAgICAgICAgICAgICAgdHJpbUF1dG9XaGl0ZXNwYWNlOiBuZXdPcHRpb25zLnRyaW1BdXRvV2hpdGVzcGFjZSxcbiAgICAgICAgICAgICAgICBicmFja2V0Q29sb3JpemF0aW9uT3B0aW9uczogbmV3T3B0aW9ucy5icmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLSBiZWdpbiBJTW9kZWxTZXJ2aWNlXG4gICAgX2luc2VydERpc3Bvc2VkTW9kZWwoZGlzcG9zZWRNb2RlbERhdGEpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZWRNb2RlbHMuc2V0KE1PREVMX0lEKGRpc3Bvc2VkTW9kZWxEYXRhLnVyaSksIGRpc3Bvc2VkTW9kZWxEYXRhKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZWRNb2RlbHNIZWFwU2l6ZSArPSBkaXNwb3NlZE1vZGVsRGF0YS5oZWFwU2l6ZTtcbiAgICB9XG4gICAgX3JlbW92ZURpc3Bvc2VkTW9kZWwocmVzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgZGlzcG9zZWRNb2RlbERhdGEgPSB0aGlzLl9kaXNwb3NlZE1vZGVscy5nZXQoTU9ERUxfSUQocmVzb3VyY2UpKTtcbiAgICAgICAgaWYgKGRpc3Bvc2VkTW9kZWxEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlZE1vZGVsc0hlYXBTaXplIC09IGRpc3Bvc2VkTW9kZWxEYXRhLmhlYXBTaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkTW9kZWxzLmRlbGV0ZShNT0RFTF9JRChyZXNvdXJjZSkpO1xuICAgICAgICByZXR1cm4gZGlzcG9zZWRNb2RlbERhdGE7XG4gICAgfVxuICAgIF9lbnN1cmVEaXNwb3NlZE1vZGVsc0hlYXBTaXplKG1heE1vZGVsc0hlYXBTaXplKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZE1vZGVsc0hlYXBTaXplID4gbWF4TW9kZWxzSGVhcFNpemUpIHtcbiAgICAgICAgICAgIC8vIHdlIG11c3QgcmVtb3ZlIHNvbWUgb2xkIHVuZG8gc3RhY2sgZWxlbWVudHMgdG8gZnJlZSB1cCBzb21lIG1lbW9yeVxuICAgICAgICAgICAgY29uc3QgZGlzcG9zZWRNb2RlbHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VkTW9kZWxzLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZW50cnkuc2hhcmVzVW5kb1JlZG9TdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlZE1vZGVscy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3Bvc2VkTW9kZWxzLnNvcnQoKGEsIGIpID0+IGEudGltZSAtIGIudGltZSk7XG4gICAgICAgICAgICB3aGlsZSAoZGlzcG9zZWRNb2RlbHMubGVuZ3RoID4gMCAmJiB0aGlzLl9kaXNwb3NlZE1vZGVsc0hlYXBTaXplID4gbWF4TW9kZWxzSGVhcFNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNwb3NlZE1vZGVsID0gZGlzcG9zZWRNb2RlbHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVEaXNwb3NlZE1vZGVsKGRpc3Bvc2VkTW9kZWwudXJpKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcG9zZWRNb2RlbC5pbml0aWFsVW5kb1JlZG9TbmFwc2hvdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmRvUmVkb1NlcnZpY2UucmVzdG9yZVNuYXBzaG90KGRpc3Bvc2VkTW9kZWwuaW5pdGlhbFVuZG9SZWRvU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfY3JlYXRlTW9kZWxEYXRhKHZhbHVlLCBsYW5ndWFnZUlkT3JTZWxlY3Rpb24sIHJlc291cmNlLCBpc0ZvclNpbXBsZVdpZGdldCkge1xuICAgICAgICAvLyBjcmVhdGUgJiBzYXZlIHRoZSBtb2RlbFxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRDcmVhdGlvbk9wdGlvbnMobGFuZ3VhZ2VJZE9yU2VsZWN0aW9uLCByZXNvdXJjZSwgaXNGb3JTaW1wbGVXaWRnZXQpO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKFRleHRNb2RlbCwgdmFsdWUsIGxhbmd1YWdlSWRPclNlbGVjdGlvbiwgb3B0aW9ucywgcmVzb3VyY2UpO1xuICAgICAgICBpZiAocmVzb3VyY2UgJiYgdGhpcy5fZGlzcG9zZWRNb2RlbHMuaGFzKE1PREVMX0lEKHJlc291cmNlKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3Bvc2VkTW9kZWxEYXRhID0gdGhpcy5fcmVtb3ZlRGlzcG9zZWRNb2RlbChyZXNvdXJjZSk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX3VuZG9SZWRvU2VydmljZS5nZXRFbGVtZW50cyhyZXNvdXJjZSk7XG4gICAgICAgICAgICBjb25zdCBzaGExQ29tcHV0ZXIgPSB0aGlzLl9nZXRTSEExQ29tcHV0ZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHNoYTFJc0VxdWFsID0gKHNoYTFDb21wdXRlci5jYW5Db21wdXRlU0hBMShtb2RlbClcbiAgICAgICAgICAgICAgICA/IHNoYTFDb21wdXRlci5jb21wdXRlU0hBMShtb2RlbCkgPT09IGRpc3Bvc2VkTW9kZWxEYXRhLnNoYTFcbiAgICAgICAgICAgICAgICA6IGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChzaGExSXNFcXVhbCB8fCBkaXNwb3NlZE1vZGVsRGF0YS5zaGFyZXNVbmRvUmVkb1N0YWNrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzLnBhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRWRpdFN0YWNrRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50Lm1hdGNoZXNSZXNvdXJjZShyZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0TW9kZWwobW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cy5mdXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRWRpdFN0YWNrRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50Lm1hdGNoZXNSZXNvdXJjZShyZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0TW9kZWwobW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3VuZG9SZWRvU2VydmljZS5zZXRFbGVtZW50c1ZhbGlkRmxhZyhyZXNvdXJjZSwgdHJ1ZSwgKGVsZW1lbnQpID0+IChpc0VkaXRTdGFja0VsZW1lbnQoZWxlbWVudCkgJiYgZWxlbWVudC5tYXRjaGVzUmVzb3VyY2UocmVzb3VyY2UpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNoYTFJc0VxdWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLl9vdmVyd3JpdGVWZXJzaW9uSWQoZGlzcG9zZWRNb2RlbERhdGEudmVyc2lvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuX292ZXJ3cml0ZUFsdGVybmF0aXZlVmVyc2lvbklkKGRpc3Bvc2VkTW9kZWxEYXRhLmFsdGVybmF0aXZlVmVyc2lvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuX292ZXJ3cml0ZUluaXRpYWxVbmRvUmVkb1NuYXBzaG90KGRpc3Bvc2VkTW9kZWxEYXRhLmluaXRpYWxVbmRvUmVkb1NuYXBzaG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcG9zZWRNb2RlbERhdGEuaW5pdGlhbFVuZG9SZWRvU25hcHNob3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5kb1JlZG9TZXJ2aWNlLnJlc3RvcmVTbmFwc2hvdChkaXNwb3NlZE1vZGVsRGF0YS5pbml0aWFsVW5kb1JlZG9TbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsSWQgPSBNT0RFTF9JRChtb2RlbC51cmkpO1xuICAgICAgICBpZiAodGhpcy5fbW9kZWxzW21vZGVsSWRdKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBhbHJlYWR5IGV4aXN0cyBhIG1vZGVsIHdpdGggdGhpcyBpZCA9PiB0aGlzIGlzIGEgcHJvZ3JhbW1lciBlcnJvclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb2RlbFNlcnZpY2U6IENhbm5vdCBhZGQgbW9kZWwgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cyEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbERhdGEgPSBuZXcgTW9kZWxEYXRhKG1vZGVsLCAobW9kZWwpID0+IHRoaXMuX29uV2lsbERpc3Bvc2UobW9kZWwpLCAobW9kZWwsIGUpID0+IHRoaXMuX29uRGlkQ2hhbmdlTGFuZ3VhZ2UobW9kZWwsIGUpKTtcbiAgICAgICAgdGhpcy5fbW9kZWxzW21vZGVsSWRdID0gbW9kZWxEYXRhO1xuICAgICAgICByZXR1cm4gbW9kZWxEYXRhO1xuICAgIH1cbiAgICBjcmVhdGVNb2RlbCh2YWx1ZSwgbGFuZ3VhZ2VTZWxlY3Rpb24sIHJlc291cmNlLCBpc0ZvclNpbXBsZVdpZGdldCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBtb2RlbERhdGE7XG4gICAgICAgIGlmIChsYW5ndWFnZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgbW9kZWxEYXRhID0gdGhpcy5fY3JlYXRlTW9kZWxEYXRhKHZhbHVlLCBsYW5ndWFnZVNlbGVjdGlvbiwgcmVzb3VyY2UsIGlzRm9yU2ltcGxlV2lkZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vZGVsRGF0YSA9IHRoaXMuX2NyZWF0ZU1vZGVsRGF0YSh2YWx1ZSwgUExBSU5URVhUX0xBTkdVQUdFX0lELCByZXNvdXJjZSwgaXNGb3JTaW1wbGVXaWRnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uTW9kZWxBZGRlZC5maXJlKG1vZGVsRGF0YS5tb2RlbCk7XG4gICAgICAgIHJldHVybiBtb2RlbERhdGEubW9kZWw7XG4gICAgfVxuICAgIGdldE1vZGVscygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9tb2RlbHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxJZCA9IGtleXNbaV07XG4gICAgICAgICAgICByZXQucHVzaCh0aGlzLl9tb2RlbHNbbW9kZWxJZF0ubW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGdldE1vZGVsKHJlc291cmNlKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsSWQgPSBNT0RFTF9JRChyZXNvdXJjZSk7XG4gICAgICAgIGNvbnN0IG1vZGVsRGF0YSA9IHRoaXMuX21vZGVsc1ttb2RlbElkXTtcbiAgICAgICAgaWYgKCFtb2RlbERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RlbERhdGEubW9kZWw7XG4gICAgfVxuICAgIC8vIC0tLSBlbmQgSU1vZGVsU2VydmljZVxuICAgIF9zY2hlbWFTaG91bGRNYWludGFpblVuZG9SZWRvRWxlbWVudHMocmVzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIChyZXNvdXJjZS5zY2hlbWUgPT09IFNjaGVtYXMuZmlsZVxuICAgICAgICAgICAgfHwgcmVzb3VyY2Uuc2NoZW1lID09PSBTY2hlbWFzLnZzY29kZVJlbW90ZVxuICAgICAgICAgICAgfHwgcmVzb3VyY2Uuc2NoZW1lID09PSBTY2hlbWFzLnZzY29kZVVzZXJEYXRhXG4gICAgICAgICAgICB8fCByZXNvdXJjZS5zY2hlbWUgPT09IFNjaGVtYXMudnNjb2RlTm90ZWJvb2tDZWxsXG4gICAgICAgICAgICB8fCByZXNvdXJjZS5zY2hlbWUgPT09ICdmYWtlLWZzJyAvLyBmb3IgdGVzdHNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgX29uV2lsbERpc3Bvc2UobW9kZWwpIHtcbiAgICAgICAgY29uc3QgbW9kZWxJZCA9IE1PREVMX0lEKG1vZGVsLnVyaSk7XG4gICAgICAgIGNvbnN0IG1vZGVsRGF0YSA9IHRoaXMuX21vZGVsc1ttb2RlbElkXTtcbiAgICAgICAgY29uc3Qgc2hhcmVzVW5kb1JlZG9TdGFjayA9ICh0aGlzLl91bmRvUmVkb1NlcnZpY2UuZ2V0VXJpQ29tcGFyaXNvbktleShtb2RlbC51cmkpICE9PSBtb2RlbC51cmkudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBtYWludGFpblVuZG9SZWRvU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgbGV0IGhlYXBTaXplID0gMDtcbiAgICAgICAgaWYgKHNoYXJlc1VuZG9SZWRvU3RhY2sgfHwgKHRoaXMuX3Nob3VsZFJlc3RvcmVVbmRvU3RhY2soKSAmJiB0aGlzLl9zY2hlbWFTaG91bGRNYWludGFpblVuZG9SZWRvRWxlbWVudHMobW9kZWwudXJpKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fdW5kb1JlZG9TZXJ2aWNlLmdldEVsZW1lbnRzKG1vZGVsLnVyaSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMucGFzdC5sZW5ndGggPiAwIHx8IGVsZW1lbnRzLmZ1dHVyZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzLnBhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRWRpdFN0YWNrRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50Lm1hdGNoZXNSZXNvdXJjZShtb2RlbC51cmkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWludGFpblVuZG9SZWRvU3RhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhcFNpemUgKz0gZWxlbWVudC5oZWFwU2l6ZShtb2RlbC51cmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRNb2RlbChtb2RlbC51cmkpOyAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gdGV4dCBidWZmZXIgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMuZnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VkaXRTdGFja0VsZW1lbnQoZWxlbWVudCkgJiYgZWxlbWVudC5tYXRjaGVzUmVzb3VyY2UobW9kZWwudXJpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbnRhaW5VbmRvUmVkb1N0YWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYXBTaXplICs9IGVsZW1lbnQuaGVhcFNpemUobW9kZWwudXJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0TW9kZWwobW9kZWwudXJpKTsgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIHRleHQgYnVmZmVyIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4TWVtb3J5ID0gTW9kZWxTZXJ2aWNlXzEuTUFYX01FTU9SWV9GT1JfQ0xPU0VEX0ZJTEVTX1VORE9fU1RBQ0s7XG4gICAgICAgIGNvbnN0IHNoYTFDb21wdXRlciA9IHRoaXMuX2dldFNIQTFDb21wdXRlcigpO1xuICAgICAgICBpZiAoIW1haW50YWluVW5kb1JlZG9TdGFjaykge1xuICAgICAgICAgICAgaWYgKCFzaGFyZXNVbmRvUmVkb1N0YWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFVuZG9SZWRvU25hcHNob3QgPSBtb2RlbERhdGEubW9kZWwuZ2V0SW5pdGlhbFVuZG9SZWRvU25hcHNob3QoKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFVuZG9SZWRvU25hcHNob3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5kb1JlZG9TZXJ2aWNlLnJlc3RvcmVTbmFwc2hvdChpbml0aWFsVW5kb1JlZG9TbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzaGFyZXNVbmRvUmVkb1N0YWNrICYmIChoZWFwU2l6ZSA+IG1heE1lbW9yeSB8fCAhc2hhMUNvbXB1dGVyLmNhbkNvbXB1dGVTSEExKG1vZGVsKSkpIHtcbiAgICAgICAgICAgIC8vIHRoZSB1bmRvIHN0YWNrIGZvciB0aGlzIGZpbGUgd291bGQgbmV2ZXIgZml0IGluIHRoZSBjb25maWd1cmVkIG1lbW9yeSBvciB0aGUgZmlsZSBpcyB2ZXJ5IGxhcmdlLCBzbyBkb24ndCBib3RoZXIgd2l0aCBpdC5cbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxVbmRvUmVkb1NuYXBzaG90ID0gbW9kZWxEYXRhLm1vZGVsLmdldEluaXRpYWxVbmRvUmVkb1NuYXBzaG90KCk7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbFVuZG9SZWRvU25hcHNob3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmRvUmVkb1NlcnZpY2UucmVzdG9yZVNuYXBzaG90KGluaXRpYWxVbmRvUmVkb1NuYXBzaG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZURpc3Bvc2VkTW9kZWxzSGVhcFNpemUobWF4TWVtb3J5IC0gaGVhcFNpemUpO1xuICAgICAgICAgICAgLy8gV2Ugb25seSBpbnZhbGlkYXRlIHRoZSBlbGVtZW50cywgYnV0IHRoZXkgcmVtYWluIGluIHRoZSB1bmRvLXJlZG8gc2VydmljZS5cbiAgICAgICAgICAgIHRoaXMuX3VuZG9SZWRvU2VydmljZS5zZXRFbGVtZW50c1ZhbGlkRmxhZyhtb2RlbC51cmksIGZhbHNlLCAoZWxlbWVudCkgPT4gKGlzRWRpdFN0YWNrRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50Lm1hdGNoZXNSZXNvdXJjZShtb2RlbC51cmkpKSk7XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnREaXNwb3NlZE1vZGVsKG5ldyBEaXNwb3NlZE1vZGVsSW5mbyhtb2RlbC51cmksIG1vZGVsRGF0YS5tb2RlbC5nZXRJbml0aWFsVW5kb1JlZG9TbmFwc2hvdCgpLCBEYXRlLm5vdygpLCBzaGFyZXNVbmRvUmVkb1N0YWNrLCBoZWFwU2l6ZSwgc2hhMUNvbXB1dGVyLmNvbXB1dGVTSEExKG1vZGVsKSwgbW9kZWwuZ2V0VmVyc2lvbklkKCksIG1vZGVsLmdldEFsdGVybmF0aXZlVmVyc2lvbklkKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fbW9kZWxzW21vZGVsSWRdO1xuICAgICAgICBtb2RlbERhdGEuZGlzcG9zZSgpO1xuICAgICAgICAvLyBjbGVhbiB1cCBjYWNoZVxuICAgICAgICBkZWxldGUgdGhpcy5fbW9kZWxDcmVhdGlvbk9wdGlvbnNCeUxhbmd1YWdlQW5kUmVzb3VyY2VbbW9kZWwuZ2V0TGFuZ3VhZ2VJZCgpICsgbW9kZWwudXJpXTtcbiAgICAgICAgdGhpcy5fb25Nb2RlbFJlbW92ZWQuZmlyZShtb2RlbCk7XG4gICAgfVxuICAgIF9vbkRpZENoYW5nZUxhbmd1YWdlKG1vZGVsLCBlKSB7XG4gICAgICAgIGNvbnN0IG9sZExhbmd1YWdlSWQgPSBlLm9sZExhbmd1YWdlO1xuICAgICAgICBjb25zdCBuZXdMYW5ndWFnZUlkID0gbW9kZWwuZ2V0TGFuZ3VhZ2VJZCgpO1xuICAgICAgICBjb25zdCBvbGRPcHRpb25zID0gdGhpcy5nZXRDcmVhdGlvbk9wdGlvbnMob2xkTGFuZ3VhZ2VJZCwgbW9kZWwudXJpLCBtb2RlbC5pc0ZvclNpbXBsZVdpZGdldCk7XG4gICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSB0aGlzLmdldENyZWF0aW9uT3B0aW9ucyhuZXdMYW5ndWFnZUlkLCBtb2RlbC51cmksIG1vZGVsLmlzRm9yU2ltcGxlV2lkZ2V0KTtcbiAgICAgICAgTW9kZWxTZXJ2aWNlXzEuX3NldE1vZGVsT3B0aW9uc0Zvck1vZGVsKG1vZGVsLCBuZXdPcHRpb25zLCBvbGRPcHRpb25zKTtcbiAgICAgICAgdGhpcy5fb25Nb2RlbE1vZGVDaGFuZ2VkLmZpcmUoeyBtb2RlbCwgb2xkTGFuZ3VhZ2VJZDogb2xkTGFuZ3VhZ2VJZCB9KTtcbiAgICB9XG4gICAgX2dldFNIQTFDb21wdXRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0TW9kZWxTSEExQ29tcHV0ZXIoKTtcbiAgICB9XG59O1xuTW9kZWxTZXJ2aWNlID0gTW9kZWxTZXJ2aWNlXzEgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIElDb25maWd1cmF0aW9uU2VydmljZSksXG4gICAgX19wYXJhbSgxLCBJVGV4dFJlc291cmNlUHJvcGVydGllc1NlcnZpY2UpLFxuICAgIF9fcGFyYW0oMiwgSVVuZG9SZWRvU2VydmljZSksXG4gICAgX19wYXJhbSgzLCBJSW5zdGFudGlhdGlvblNlcnZpY2UpXG5dLCBNb2RlbFNlcnZpY2UpO1xuZXhwb3J0IHsgTW9kZWxTZXJ2aWNlIH07XG5leHBvcnQgY2xhc3MgRGVmYXVsdE1vZGVsU0hBMUNvbXB1dGVyIHtcbiAgICBzdGF0aWMgeyB0aGlzLk1BWF9NT0RFTF9TSVpFID0gMTAgKiAxMDI0ICogMTAyNDsgfSAvLyB0YWtlcyAyMDBtcyB0byBjb21wdXRlIGEgc2hhMSBvbiBhIDEwTUIgbW9kZWwgb24gYSBuZXcgbWFjaGluZVxuICAgIGNhbkNvbXB1dGVTSEExKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiAobW9kZWwuZ2V0VmFsdWVMZW5ndGgoKSA8PSBEZWZhdWx0TW9kZWxTSEExQ29tcHV0ZXIuTUFYX01PREVMX1NJWkUpO1xuICAgIH1cbiAgICBjb21wdXRlU0hBMShtb2RlbCkge1xuICAgICAgICAvLyBjb21wdXRlIHRoZSBzaGExXG4gICAgICAgIGNvbnN0IHNoYUNvbXB1dGVyID0gbmV3IFN0cmluZ1NIQTEoKTtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBtb2RlbC5jcmVhdGVTbmFwc2hvdCgpO1xuICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgd2hpbGUgKCh0ZXh0ID0gc25hcHNob3QucmVhZCgpKSkge1xuICAgICAgICAgICAgc2hhQ29tcHV0ZXIudXBkYXRlKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFDb21wdXRlci5kaWdlc3QoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVEZWNvcmF0b3IgfSBmcm9tICcuLi8uLi8uLi9wbGF0Zm9ybS9pbnN0YW50aWF0aW9uL2NvbW1vbi9pbnN0YW50aWF0aW9uLmpzJztcbmV4cG9ydCBjb25zdCBJVGV4dFJlc291cmNlQ29uZmlndXJhdGlvblNlcnZpY2UgPSBjcmVhdGVEZWNvcmF0b3IoJ3RleHRSZXNvdXJjZUNvbmZpZ3VyYXRpb25TZXJ2aWNlJyk7XG5leHBvcnQgY29uc3QgSVRleHRSZXNvdXJjZVByb3BlcnRpZXNTZXJ2aWNlID0gY3JlYXRlRGVjb3JhdG9yKCd0ZXh0UmVzb3VyY2VQcm9wZXJ0aWVzU2VydmljZScpO1xuIiwiaW1wb3J0IHsgY3JlYXRlRGVjb3JhdG9yIH0gZnJvbSAnLi4vLi4vLi4vcGxhdGZvcm0vaW5zdGFudGlhdGlvbi9jb21tb24vaW5zdGFudGlhdGlvbi5qcyc7XG5leHBvcnQgY29uc3QgSVRyZWVTaXR0ZXJQYXJzZXJTZXJ2aWNlID0gY3JlYXRlRGVjb3JhdG9yKCd0cmVlU2l0dGVyUGFyc2VyU2VydmljZScpO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgY2xhc3MgQnJhY2tldEluZm8ge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCBcbiAgICAvKiogMC1iYXNlZCBsZXZlbCAqL1xuICAgIG5lc3RpbmdMZXZlbCwgbmVzdGluZ0xldmVsT2ZFcXVhbEJyYWNrZXRUeXBlLCBpc0ludmFsaWQpIHtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICB0aGlzLm5lc3RpbmdMZXZlbCA9IG5lc3RpbmdMZXZlbDtcbiAgICAgICAgdGhpcy5uZXN0aW5nTGV2ZWxPZkVxdWFsQnJhY2tldFR5cGUgPSBuZXN0aW5nTGV2ZWxPZkVxdWFsQnJhY2tldFR5cGU7XG4gICAgICAgIHRoaXMuaXNJbnZhbGlkID0gaXNJbnZhbGlkO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCcmFja2V0UGFpckluZm8ge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCBvcGVuaW5nQnJhY2tldFJhbmdlLCBjbG9zaW5nQnJhY2tldFJhbmdlLCBcbiAgICAvKiogMC1iYXNlZCAqL1xuICAgIG5lc3RpbmdMZXZlbCwgbmVzdGluZ0xldmVsT2ZFcXVhbEJyYWNrZXRUeXBlLCBicmFja2V0UGFpck5vZGUpIHtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICB0aGlzLm9wZW5pbmdCcmFja2V0UmFuZ2UgPSBvcGVuaW5nQnJhY2tldFJhbmdlO1xuICAgICAgICB0aGlzLmNsb3NpbmdCcmFja2V0UmFuZ2UgPSBjbG9zaW5nQnJhY2tldFJhbmdlO1xuICAgICAgICB0aGlzLm5lc3RpbmdMZXZlbCA9IG5lc3RpbmdMZXZlbDtcbiAgICAgICAgdGhpcy5uZXN0aW5nTGV2ZWxPZkVxdWFsQnJhY2tldFR5cGUgPSBuZXN0aW5nTGV2ZWxPZkVxdWFsQnJhY2tldFR5cGU7XG4gICAgICAgIHRoaXMuYnJhY2tldFBhaXJOb2RlID0gYnJhY2tldFBhaXJOb2RlO1xuICAgIH1cbiAgICBnZXQgb3BlbmluZ0JyYWNrZXRJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icmFja2V0UGFpck5vZGUub3BlbmluZ0JyYWNrZXQuYnJhY2tldEluZm87XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJyYWNrZXRQYWlyV2l0aE1pbkluZGVudGF0aW9uSW5mbyBleHRlbmRzIEJyYWNrZXRQYWlySW5mbyB7XG4gICAgY29uc3RydWN0b3IocmFuZ2UsIG9wZW5pbmdCcmFja2V0UmFuZ2UsIGNsb3NpbmdCcmFja2V0UmFuZ2UsIFxuICAgIC8qKlxuICAgICAqIDAtYmFzZWRcbiAgICAqL1xuICAgIG5lc3RpbmdMZXZlbCwgbmVzdGluZ0xldmVsT2ZFcXVhbEJyYWNrZXRUeXBlLCBicmFja2V0UGFpck5vZGUsIFxuICAgIC8qKlxuICAgICAqIC0xIGlmIG5vdCByZXF1ZXN0ZWQsIG90aGVyd2lzZSB0aGUgc2l6ZSBvZiB0aGUgbWluaW11bSBpbmRlbnRhdGlvbiBpbiB0aGUgYnJhY2tldCBwYWlyIGluIHRlcm1zIG9mIHZpc2libGUgY29sdW1ucy5cbiAgICAqL1xuICAgIG1pblZpc2libGVDb2x1bW5JbmRlbnRhdGlvbikge1xuICAgICAgICBzdXBlcihyYW5nZSwgb3BlbmluZ0JyYWNrZXRSYW5nZSwgY2xvc2luZ0JyYWNrZXRSYW5nZSwgbmVzdGluZ0xldmVsLCBuZXN0aW5nTGV2ZWxPZkVxdWFsQnJhY2tldFR5cGUsIGJyYWNrZXRQYWlyTm9kZSk7XG4gICAgICAgIHRoaXMubWluVmlzaWJsZUNvbHVtbkluZGVudGF0aW9uID0gbWluVmlzaWJsZUNvbHVtbkluZGVudGF0aW9uO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBBbiBldmVudCBkZXNjcmliaW5nIHRoYXQgYSBtb2RlbCBoYXMgYmVlbiByZXNldCB0byBhIG5ldyB2YWx1ZS5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgTW9kZWxSYXdGbHVzaCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlVHlwZSA9IDEgLyogUmF3Q29udGVudENoYW5nZWRUeXBlLkZsdXNoICovO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyB0ZXh0IGluamVjdGVkIG9uIGEgbGluZVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBMaW5lSW5qZWN0ZWRUZXh0IHtcbiAgICBzdGF0aWMgYXBwbHlJbmplY3RlZFRleHQobGluZVRleHQsIGluamVjdGVkVGV4dHMpIHtcbiAgICAgICAgaWYgKCFpbmplY3RlZFRleHRzIHx8IGluamVjdGVkVGV4dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZVRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBsZXQgbGFzdE9yaWdpbmFsT2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBpbmplY3RlZFRleHQgb2YgaW5qZWN0ZWRUZXh0cykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVUZXh0LnN1YnN0cmluZyhsYXN0T3JpZ2luYWxPZmZzZXQsIGluamVjdGVkVGV4dC5jb2x1bW4gLSAxKTtcbiAgICAgICAgICAgIGxhc3RPcmlnaW5hbE9mZnNldCA9IGluamVjdGVkVGV4dC5jb2x1bW4gLSAxO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGluamVjdGVkVGV4dC5vcHRpb25zLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGxpbmVUZXh0LnN1YnN0cmluZyhsYXN0T3JpZ2luYWxPZmZzZXQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbURlY29yYXRpb25zKGRlY29yYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGRlY29yYXRpb24gb2YgZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChkZWNvcmF0aW9uLm9wdGlvbnMuYmVmb3JlICYmIGRlY29yYXRpb24ub3B0aW9ucy5iZWZvcmUuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IExpbmVJbmplY3RlZFRleHQoZGVjb3JhdGlvbi5vd25lcklkLCBkZWNvcmF0aW9uLnJhbmdlLnN0YXJ0TGluZU51bWJlciwgZGVjb3JhdGlvbi5yYW5nZS5zdGFydENvbHVtbiwgZGVjb3JhdGlvbi5vcHRpb25zLmJlZm9yZSwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY29yYXRpb24ub3B0aW9ucy5hZnRlciAmJiBkZWNvcmF0aW9uLm9wdGlvbnMuYWZ0ZXIuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IExpbmVJbmplY3RlZFRleHQoZGVjb3JhdGlvbi5vd25lcklkLCBkZWNvcmF0aW9uLnJhbmdlLmVuZExpbmVOdW1iZXIsIGRlY29yYXRpb24ucmFuZ2UuZW5kQ29sdW1uLCBkZWNvcmF0aW9uLm9wdGlvbnMuYWZ0ZXIsIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEubGluZU51bWJlciA9PT0gYi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEuY29sdW1uID09PSBiLmNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhLmNvbHVtbiAtIGIuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEubGluZU51bWJlciAtIGIubGluZU51bWJlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG93bmVySWQsIGxpbmVOdW1iZXIsIGNvbHVtbiwgb3B0aW9ucywgb3JkZXIpIHtcbiAgICAgICAgdGhpcy5vd25lcklkID0gb3duZXJJZDtcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMub3JkZXIgPSBvcmRlcjtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IGRlc2NyaWJpbmcgdGhhdCBhIGxpbmUgaGFzIGNoYW5nZWQgaW4gYSBtb2RlbC5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgTW9kZWxSYXdMaW5lQ2hhbmdlZCB7XG4gICAgY29uc3RydWN0b3IobGluZU51bWJlciwgZGV0YWlsLCBpbmplY3RlZFRleHQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VUeXBlID0gMiAvKiBSYXdDb250ZW50Q2hhbmdlZFR5cGUuTGluZUNoYW5nZWQgKi87XG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuZGV0YWlsID0gZGV0YWlsO1xuICAgICAgICB0aGlzLmluamVjdGVkVGV4dCA9IGluamVjdGVkVGV4dDtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IGRlc2NyaWJpbmcgdGhhdCBsaW5lKHMpIGhhdmUgYmVlbiBkZWxldGVkIGluIGEgbW9kZWwuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIE1vZGVsUmF3TGluZXNEZWxldGVkIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tTGluZU51bWJlciwgdG9MaW5lTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlVHlwZSA9IDMgLyogUmF3Q29udGVudENoYW5nZWRUeXBlLkxpbmVzRGVsZXRlZCAqLztcbiAgICAgICAgdGhpcy5mcm9tTGluZU51bWJlciA9IGZyb21MaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLnRvTGluZU51bWJlciA9IHRvTGluZU51bWJlcjtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IGRlc2NyaWJpbmcgdGhhdCBsaW5lKHMpIGhhdmUgYmVlbiBpbnNlcnRlZCBpbiBhIG1vZGVsLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2RlbFJhd0xpbmVzSW5zZXJ0ZWQge1xuICAgIGNvbnN0cnVjdG9yKGZyb21MaW5lTnVtYmVyLCB0b0xpbmVOdW1iZXIsIGRldGFpbCwgaW5qZWN0ZWRUZXh0cykge1xuICAgICAgICB0aGlzLmNoYW5nZVR5cGUgPSA0IC8qIFJhd0NvbnRlbnRDaGFuZ2VkVHlwZS5MaW5lc0luc2VydGVkICovO1xuICAgICAgICB0aGlzLmluamVjdGVkVGV4dHMgPSBpbmplY3RlZFRleHRzO1xuICAgICAgICB0aGlzLmZyb21MaW5lTnVtYmVyID0gZnJvbUxpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMudG9MaW5lTnVtYmVyID0gdG9MaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLmRldGFpbCA9IGRldGFpbDtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IGRlc2NyaWJpbmcgdGhhdCBhIG1vZGVsIGhhcyBoYWQgaXRzIEVPTCBjaGFuZ2VkLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2RlbFJhd0VPTENoYW5nZWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZVR5cGUgPSA1IC8qIFJhd0NvbnRlbnRDaGFuZ2VkVHlwZS5FT0xDaGFuZ2VkICovO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgZGVzY3JpYmluZyBhIGNoYW5nZSBpbiB0aGUgdGV4dCBvZiBhIG1vZGVsLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2RlbFJhd0NvbnRlbnRDaGFuZ2VkRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZXMsIHZlcnNpb25JZCwgaXNVbmRvaW5nLCBpc1JlZG9pbmcpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy52ZXJzaW9uSWQgPSB2ZXJzaW9uSWQ7XG4gICAgICAgIHRoaXMuaXNVbmRvaW5nID0gaXNVbmRvaW5nO1xuICAgICAgICB0aGlzLmlzUmVkb2luZyA9IGlzUmVkb2luZztcbiAgICAgICAgdGhpcy5yZXN1bHRpbmdTZWxlY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBjb250YWluc0V2ZW50KHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuY2hhbmdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gdGhpcy5jaGFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5jaGFuZ2VUeXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2UoYSwgYikge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW10uY29uY2F0KGEuY2hhbmdlcykuY29uY2F0KGIuY2hhbmdlcyk7XG4gICAgICAgIGNvbnN0IHZlcnNpb25JZCA9IGIudmVyc2lvbklkO1xuICAgICAgICBjb25zdCBpc1VuZG9pbmcgPSAoYS5pc1VuZG9pbmcgfHwgYi5pc1VuZG9pbmcpO1xuICAgICAgICBjb25zdCBpc1JlZG9pbmcgPSAoYS5pc1JlZG9pbmcgfHwgYi5pc1JlZG9pbmcpO1xuICAgICAgICByZXR1cm4gbmV3IE1vZGVsUmF3Q29udGVudENoYW5nZWRFdmVudChjaGFuZ2VzLCB2ZXJzaW9uSWQsIGlzVW5kb2luZywgaXNSZWRvaW5nKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IGRlc2NyaWJpbmcgYSBjaGFuZ2UgaW4gaW5qZWN0ZWQgdGV4dC5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgTW9kZWxJbmplY3RlZFRleHRDaGFuZ2VkRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxNb2RlbENvbnRlbnRDaGFuZ2VFdmVudCB7XG4gICAgY29uc3RydWN0b3IocmF3Q29udGVudENoYW5nZWRFdmVudCwgY29udGVudENoYW5nZWRFdmVudCkge1xuICAgICAgICB0aGlzLnJhd0NvbnRlbnRDaGFuZ2VkRXZlbnQgPSByYXdDb250ZW50Q2hhbmdlZEV2ZW50O1xuICAgICAgICB0aGlzLmNvbnRlbnRDaGFuZ2VkRXZlbnQgPSBjb250ZW50Q2hhbmdlZEV2ZW50O1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBjb25zdCByYXdDb250ZW50Q2hhbmdlZEV2ZW50ID0gTW9kZWxSYXdDb250ZW50Q2hhbmdlZEV2ZW50Lm1lcmdlKHRoaXMucmF3Q29udGVudENoYW5nZWRFdmVudCwgb3RoZXIucmF3Q29udGVudENoYW5nZWRFdmVudCk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRDaGFuZ2VkRXZlbnQgPSBJbnRlcm5hbE1vZGVsQ29udGVudENoYW5nZUV2ZW50Ll9tZXJnZUNoYW5nZUV2ZW50cyh0aGlzLmNvbnRlbnRDaGFuZ2VkRXZlbnQsIG90aGVyLmNvbnRlbnRDaGFuZ2VkRXZlbnQpO1xuICAgICAgICByZXR1cm4gbmV3IEludGVybmFsTW9kZWxDb250ZW50Q2hhbmdlRXZlbnQocmF3Q29udGVudENoYW5nZWRFdmVudCwgY29udGVudENoYW5nZWRFdmVudCk7XG4gICAgfVxuICAgIHN0YXRpYyBfbWVyZ2VDaGFuZ2VFdmVudHMoYSwgYikge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW10uY29uY2F0KGEuY2hhbmdlcykuY29uY2F0KGIuY2hhbmdlcyk7XG4gICAgICAgIGNvbnN0IGVvbCA9IGIuZW9sO1xuICAgICAgICBjb25zdCB2ZXJzaW9uSWQgPSBiLnZlcnNpb25JZDtcbiAgICAgICAgY29uc3QgaXNVbmRvaW5nID0gKGEuaXNVbmRvaW5nIHx8IGIuaXNVbmRvaW5nKTtcbiAgICAgICAgY29uc3QgaXNSZWRvaW5nID0gKGEuaXNSZWRvaW5nIHx8IGIuaXNSZWRvaW5nKTtcbiAgICAgICAgY29uc3QgaXNGbHVzaCA9IChhLmlzRmx1c2ggfHwgYi5pc0ZsdXNoKTtcbiAgICAgICAgY29uc3QgaXNFb2xDaGFuZ2UgPSBhLmlzRW9sQ2hhbmdlICYmIGIuaXNFb2xDaGFuZ2U7IC8vIGJvdGggbXVzdCBiZSB0cnVlIHRvIG5vdCBjb25mdXNlIGxpc3RlbmVycyB3aG8gc2tpcCBzdWNoIGVkaXRzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzOiBjaGFuZ2VzLFxuICAgICAgICAgICAgZW9sOiBlb2wsXG4gICAgICAgICAgICBpc0VvbENoYW5nZTogaXNFb2xDaGFuZ2UsXG4gICAgICAgICAgICB2ZXJzaW9uSWQ6IHZlcnNpb25JZCxcbiAgICAgICAgICAgIGlzVW5kb2luZzogaXNVbmRvaW5nLFxuICAgICAgICAgICAgaXNSZWRvaW5nOiBpc1JlZG9pbmcsXG4gICAgICAgICAgICBpc0ZsdXNoOiBpc0ZsdXNoLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IHZhciBIb3Jpem9udGFsR3VpZGVzU3RhdGU7XG4oZnVuY3Rpb24gKEhvcml6b250YWxHdWlkZXNTdGF0ZSkge1xuICAgIEhvcml6b250YWxHdWlkZXNTdGF0ZVtIb3Jpem9udGFsR3VpZGVzU3RhdGVbXCJEaXNhYmxlZFwiXSA9IDBdID0gXCJEaXNhYmxlZFwiO1xuICAgIEhvcml6b250YWxHdWlkZXNTdGF0ZVtIb3Jpem9udGFsR3VpZGVzU3RhdGVbXCJFbmFibGVkRm9yQWN0aXZlXCJdID0gMV0gPSBcIkVuYWJsZWRGb3JBY3RpdmVcIjtcbiAgICBIb3Jpem9udGFsR3VpZGVzU3RhdGVbSG9yaXpvbnRhbEd1aWRlc1N0YXRlW1wiRW5hYmxlZFwiXSA9IDJdID0gXCJFbmFibGVkXCI7XG59KShIb3Jpem9udGFsR3VpZGVzU3RhdGUgfHwgKEhvcml6b250YWxHdWlkZXNTdGF0ZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgSW5kZW50R3VpZGUge1xuICAgIGNvbnN0cnVjdG9yKHZpc2libGVDb2x1bW4sIGNvbHVtbiwgY2xhc3NOYW1lLCBcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoaXMgaW5kZW50IGd1aWRlIGlzIGEgaG9yaXpvbnRhbCBndWlkZSAobm8gdmVydGljYWwgcGFydCkuXG4gICAgICogSXQgc3RhcnRzIGF0IHZpc2libGVDb2x1bW4gYW5kIGNvbnRpbnVlcyB1bnRpbCBlbmRDb2x1bW4uXG4gICAgKi9cbiAgICBob3Jpem9udGFsTGluZSwgXG4gICAgLyoqXG4gICAgICogSWYgc2V0ICghPSAtMSksIG9ubHkgc2hvdyB0aGlzIGd1aWRlIGZvciB3cmFwcGVkIGxpbmVzIHRoYXQgZG9uJ3QgY29udGFpbiB0aGlzIG1vZGVsIGNvbHVtbiwgYnV0IGFyZSBhZnRlciBpdC5cbiAgICAqL1xuICAgIGZvcldyYXBwZWRMaW5lc0FmdGVyQ29sdW1uLCBmb3JXcmFwcGVkTGluZXNCZWZvcmVPckF0Q29sdW1uKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbiA9IHZpc2libGVDb2x1bW47XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsTGluZSA9IGhvcml6b250YWxMaW5lO1xuICAgICAgICB0aGlzLmZvcldyYXBwZWRMaW5lc0FmdGVyQ29sdW1uID0gZm9yV3JhcHBlZExpbmVzQWZ0ZXJDb2x1bW47XG4gICAgICAgIHRoaXMuZm9yV3JhcHBlZExpbmVzQmVmb3JlT3JBdENvbHVtbiA9IGZvcldyYXBwZWRMaW5lc0JlZm9yZU9yQXRDb2x1bW47XG4gICAgICAgIGlmICgodmlzaWJsZUNvbHVtbiAhPT0gLTEpID09PSAoY29sdW1uICE9PSAtMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEluZGVudEd1aWRlSG9yaXpvbnRhbExpbmUge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgZW5kQ29sdW1uKSB7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGVuZENvbHVtbjtcbiAgICB9XG59XG4iLCIvKipcbiAqIFJlcHJlc2VudHMgY29udGlndW91cyB0b2tlbnMgb3ZlciBhIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgbGluZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250aWd1b3VzTXVsdGlsaW5lVG9rZW5zIHtcbiAgICAvKipcbiAgICAgKiAoSW5jbHVzaXZlKSBzdGFydCBsaW5lIG51bWJlciBmb3IgdGhlc2UgdG9rZW5zLlxuICAgICAqL1xuICAgIGdldCBzdGFydExpbmVOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydExpbmVOdW1iZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIChJbmNsdXNpdmUpIGVuZCBsaW5lIG51bWJlciBmb3IgdGhlc2UgdG9rZW5zLlxuICAgICAqL1xuICAgIGdldCBlbmRMaW5lTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRMaW5lTnVtYmVyICsgdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0YXJ0TGluZU51bWJlciwgdG9rZW5zKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0TGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5fdG9rZW5zID0gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBfdG9rZW5zfVxuICAgICAqL1xuICAgIGdldExpbmVUb2tlbnMobGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5zW2xpbmVOdW1iZXIgLSB0aGlzLl9zdGFydExpbmVOdW1iZXJdO1xuICAgIH1cbiAgICBhcHBlbmRMaW5lVG9rZW5zKGxpbmVUb2tlbnMpIHtcbiAgICAgICAgdGhpcy5fdG9rZW5zLnB1c2gobGluZVRva2Vucyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udGlndW91c011bHRpbGluZVRva2VucyB9IGZyb20gJy4vY29udGlndW91c011bHRpbGluZVRva2Vucy5qcyc7XG5leHBvcnQgY2xhc3MgQ29udGlndW91c011bHRpbGluZVRva2Vuc0J1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl90b2tlbnMgPSBbXTtcbiAgICB9XG4gICAgYWRkKGxpbmVOdW1iZXIsIGxpbmVUb2tlbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Rva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5fdG9rZW5zW3RoaXMuX3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0LmVuZExpbmVOdW1iZXIgKyAxID09PSBsaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kXG4gICAgICAgICAgICAgICAgbGFzdC5hcHBlbmRMaW5lVG9rZW5zKGxpbmVUb2tlbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90b2tlbnMucHVzaChuZXcgQ29udGlndW91c011bHRpbGluZVRva2VucyhsaW5lTnVtYmVyLCBbbGluZVRva2Vuc10pKTtcbiAgICB9XG4gICAgZmluYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbnM7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBMaW5lVG9rZW5zIH0gZnJvbSAnLi9saW5lVG9rZW5zLmpzJztcbmV4cG9ydCBjb25zdCBFTVBUWV9MSU5FX1RPS0VOUyA9IChuZXcgVWludDMyQXJyYXkoMCkpLmJ1ZmZlcjtcbmV4cG9ydCBjbGFzcyBDb250aWd1b3VzVG9rZW5zRWRpdGluZyB7XG4gICAgc3RhdGljIGRlbGV0ZUJlZ2lubmluZyhsaW5lVG9rZW5zLCB0b0NoSW5kZXgpIHtcbiAgICAgICAgaWYgKGxpbmVUb2tlbnMgPT09IG51bGwgfHwgbGluZVRva2VucyA9PT0gRU1QVFlfTElORV9UT0tFTlMpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lVG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb250aWd1b3VzVG9rZW5zRWRpdGluZy5kZWxldGUobGluZVRva2VucywgMCwgdG9DaEluZGV4KTtcbiAgICB9XG4gICAgc3RhdGljIGRlbGV0ZUVuZGluZyhsaW5lVG9rZW5zLCBmcm9tQ2hJbmRleCkge1xuICAgICAgICBpZiAobGluZVRva2VucyA9PT0gbnVsbCB8fCBsaW5lVG9rZW5zID09PSBFTVBUWV9MSU5FX1RPS0VOUykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVUb2tlbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW5zID0gdG9VaW50MzJBcnJheShsaW5lVG9rZW5zKTtcbiAgICAgICAgY29uc3QgbGluZVRleHRMZW5ndGggPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDJdO1xuICAgICAgICByZXR1cm4gQ29udGlndW91c1Rva2Vuc0VkaXRpbmcuZGVsZXRlKGxpbmVUb2tlbnMsIGZyb21DaEluZGV4LCBsaW5lVGV4dExlbmd0aCk7XG4gICAgfVxuICAgIHN0YXRpYyBkZWxldGUobGluZVRva2VucywgZnJvbUNoSW5kZXgsIHRvQ2hJbmRleCkge1xuICAgICAgICBpZiAobGluZVRva2VucyA9PT0gbnVsbCB8fCBsaW5lVG9rZW5zID09PSBFTVBUWV9MSU5FX1RPS0VOUyB8fCBmcm9tQ2hJbmRleCA9PT0gdG9DaEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZVRva2VucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbnMgPSB0b1VpbnQzMkFycmF5KGxpbmVUb2tlbnMpO1xuICAgICAgICBjb25zdCB0b2tlbnNDb3VudCA9ICh0b2tlbnMubGVuZ3RoID4+PiAxKTtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBkZWxldGluZyBldmVyeXRoaW5nXG4gICAgICAgIGlmIChmcm9tQ2hJbmRleCA9PT0gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDJdID09PSB0b0NoSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9MSU5FX1RPS0VOUztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tVG9rZW5JbmRleCA9IExpbmVUb2tlbnMuZmluZEluZGV4SW5Ub2tlbnNBcnJheSh0b2tlbnMsIGZyb21DaEluZGV4KTtcbiAgICAgICAgY29uc3QgZnJvbVRva2VuU3RhcnRPZmZzZXQgPSAoZnJvbVRva2VuSW5kZXggPiAwID8gdG9rZW5zWyhmcm9tVG9rZW5JbmRleCAtIDEpIDw8IDFdIDogMCk7XG4gICAgICAgIGNvbnN0IGZyb21Ub2tlbkVuZE9mZnNldCA9IHRva2Vuc1tmcm9tVG9rZW5JbmRleCA8PCAxXTtcbiAgICAgICAgaWYgKHRvQ2hJbmRleCA8IGZyb21Ub2tlbkVuZE9mZnNldCkge1xuICAgICAgICAgICAgLy8gdGhlIGRlbGV0ZSByYW5nZSBpcyBpbnNpZGUgYSBzaW5nbGUgdG9rZW5cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gKHRvQ2hJbmRleCAtIGZyb21DaEluZGV4KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tVG9rZW5JbmRleDsgaSA8IHRva2Vuc0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b2tlbnNbaSA8PCAxXSAtPSBkZWx0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lVG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXN0O1xuICAgICAgICBsZXQgbGFzdEVuZDtcbiAgICAgICAgaWYgKGZyb21Ub2tlblN0YXJ0T2Zmc2V0ICE9PSBmcm9tQ2hJbmRleCkge1xuICAgICAgICAgICAgdG9rZW5zW2Zyb21Ub2tlbkluZGV4IDw8IDFdID0gZnJvbUNoSW5kZXg7XG4gICAgICAgICAgICBkZXN0ID0gKChmcm9tVG9rZW5JbmRleCArIDEpIDw8IDEpO1xuICAgICAgICAgICAgbGFzdEVuZCA9IGZyb21DaEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdCA9IChmcm9tVG9rZW5JbmRleCA8PCAxKTtcbiAgICAgICAgICAgIGxhc3RFbmQgPSBmcm9tVG9rZW5TdGFydE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9ICh0b0NoSW5kZXggLSBmcm9tQ2hJbmRleCk7XG4gICAgICAgIGZvciAobGV0IHRva2VuSW5kZXggPSBmcm9tVG9rZW5JbmRleCArIDE7IHRva2VuSW5kZXggPCB0b2tlbnNDb3VudDsgdG9rZW5JbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkVuZE9mZnNldCA9IHRva2Vuc1t0b2tlbkluZGV4IDw8IDFdIC0gZGVsdGE7XG4gICAgICAgICAgICBpZiAodG9rZW5FbmRPZmZzZXQgPiBsYXN0RW5kKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zW2Rlc3QrK10gPSB0b2tlbkVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICB0b2tlbnNbZGVzdCsrXSA9IHRva2Vuc1sodG9rZW5JbmRleCA8PCAxKSArIDFdO1xuICAgICAgICAgICAgICAgIGxhc3RFbmQgPSB0b2tlbkVuZE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzdCA9PT0gdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byB0cmltXG4gICAgICAgICAgICByZXR1cm4gbGluZVRva2VucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0bXAgPSBuZXcgVWludDMyQXJyYXkoZGVzdCk7XG4gICAgICAgIHRtcC5zZXQodG9rZW5zLnN1YmFycmF5KDAsIGRlc3QpLCAwKTtcbiAgICAgICAgcmV0dXJuIHRtcC5idWZmZXI7XG4gICAgfVxuICAgIHN0YXRpYyBhcHBlbmQobGluZVRva2VucywgX290aGVyVG9rZW5zKSB7XG4gICAgICAgIGlmIChfb3RoZXJUb2tlbnMgPT09IEVNUFRZX0xJTkVfVE9LRU5TKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZVRva2VucztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVRva2VucyA9PT0gRU1QVFlfTElORV9UT0tFTlMpIHtcbiAgICAgICAgICAgIHJldHVybiBfb3RoZXJUb2tlbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVUb2tlbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lVG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfb3RoZXJUb2tlbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNhbm5vdCBkZXRlcm1pbmUgY29tYmluZWQgbGluZSBsZW5ndGguLi5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG15VG9rZW5zID0gdG9VaW50MzJBcnJheShsaW5lVG9rZW5zKTtcbiAgICAgICAgY29uc3Qgb3RoZXJUb2tlbnMgPSB0b1VpbnQzMkFycmF5KF9vdGhlclRva2Vucyk7XG4gICAgICAgIGNvbnN0IG90aGVyVG9rZW5zQ291bnQgPSAob3RoZXJUb2tlbnMubGVuZ3RoID4+PiAxKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQzMkFycmF5KG15VG9rZW5zLmxlbmd0aCArIG90aGVyVG9rZW5zLmxlbmd0aCk7XG4gICAgICAgIHJlc3VsdC5zZXQobXlUb2tlbnMsIDApO1xuICAgICAgICBsZXQgZGVzdCA9IG15VG9rZW5zLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBteVRva2Vuc1tteVRva2Vucy5sZW5ndGggLSAyXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdGhlclRva2Vuc0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtkZXN0KytdID0gb3RoZXJUb2tlbnNbKGkgPDwgMSldICsgZGVsdGE7XG4gICAgICAgICAgICByZXN1bHRbZGVzdCsrXSA9IG90aGVyVG9rZW5zWyhpIDw8IDEpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG4gICAgfVxuICAgIHN0YXRpYyBpbnNlcnQobGluZVRva2VucywgY2hJbmRleCwgdGV4dExlbmd0aCkge1xuICAgICAgICBpZiAobGluZVRva2VucyA9PT0gbnVsbCB8fCBsaW5lVG9rZW5zID09PSBFTVBUWV9MSU5FX1RPS0VOUykge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVUb2tlbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW5zID0gdG9VaW50MzJBcnJheShsaW5lVG9rZW5zKTtcbiAgICAgICAgY29uc3QgdG9rZW5zQ291bnQgPSAodG9rZW5zLmxlbmd0aCA+Pj4gMSk7XG4gICAgICAgIGxldCBmcm9tVG9rZW5JbmRleCA9IExpbmVUb2tlbnMuZmluZEluZGV4SW5Ub2tlbnNBcnJheSh0b2tlbnMsIGNoSW5kZXgpO1xuICAgICAgICBpZiAoZnJvbVRva2VuSW5kZXggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tVG9rZW5TdGFydE9mZnNldCA9IHRva2Vuc1soZnJvbVRva2VuSW5kZXggLSAxKSA8PCAxXTtcbiAgICAgICAgICAgIGlmIChmcm9tVG9rZW5TdGFydE9mZnNldCA9PT0gY2hJbmRleCkge1xuICAgICAgICAgICAgICAgIGZyb21Ub2tlbkluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdG9rZW5JbmRleCA9IGZyb21Ub2tlbkluZGV4OyB0b2tlbkluZGV4IDwgdG9rZW5zQ291bnQ7IHRva2VuSW5kZXgrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuSW5kZXggPDwgMV0gKz0gdGV4dExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZVRva2VucztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdG9VaW50MzJBcnJheShhcnIpIHtcbiAgICBpZiAoYXJyIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYXJyKTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIGFycmF5cyBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuLi9jb3JlL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IENvbnRpZ3VvdXNUb2tlbnNFZGl0aW5nLCBFTVBUWV9MSU5FX1RPS0VOUywgdG9VaW50MzJBcnJheSB9IGZyb20gJy4vY29udGlndW91c1Rva2Vuc0VkaXRpbmcuanMnO1xuaW1wb3J0IHsgTGluZVRva2VucyB9IGZyb20gJy4vbGluZVRva2Vucy5qcyc7XG5pbXBvcnQgeyBUb2tlbk1ldGFkYXRhIH0gZnJvbSAnLi4vZW5jb2RlZFRva2VuQXR0cmlidXRlcy5qcyc7XG4vKipcbiAqIFJlcHJlc2VudHMgY29udGlndW91cyB0b2tlbnMgaW4gYSB0ZXh0IG1vZGVsLlxuICovXG5leHBvcnQgY2xhc3MgQ29udGlndW91c1Rva2Vuc1N0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihsYW5ndWFnZUlkQ29kZWMpIHtcbiAgICAgICAgdGhpcy5fbGluZVRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLl9sZW4gPSAwO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkQ29kZWMgPSBsYW5ndWFnZUlkQ29kZWM7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICB0aGlzLl9saW5lVG9rZW5zID0gW107XG4gICAgICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgfVxuICAgIGdldCBoYXNUb2tlbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lVG9rZW5zLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldFRva2Vucyh0b3BMZXZlbExhbmd1YWdlSWQsIGxpbmVJbmRleCwgbGluZVRleHQpIHtcbiAgICAgICAgbGV0IHJhd0xpbmVUb2tlbnMgPSBudWxsO1xuICAgICAgICBpZiAobGluZUluZGV4IDwgdGhpcy5fbGVuKSB7XG4gICAgICAgICAgICByYXdMaW5lVG9rZW5zID0gdGhpcy5fbGluZVRva2Vuc1tsaW5lSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYXdMaW5lVG9rZW5zICE9PSBudWxsICYmIHJhd0xpbmVUb2tlbnMgIT09IEVNUFRZX0xJTkVfVE9LRU5TKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbmVUb2tlbnModG9VaW50MzJBcnJheShyYXdMaW5lVG9rZW5zKSwgbGluZVRleHQsIHRoaXMuX2xhbmd1YWdlSWRDb2RlYyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZVRva2VucyA9IG5ldyBVaW50MzJBcnJheSgyKTtcbiAgICAgICAgbGluZVRva2Vuc1swXSA9IGxpbmVUZXh0Lmxlbmd0aDtcbiAgICAgICAgbGluZVRva2Vuc1sxXSA9IGdldERlZmF1bHRNZXRhZGF0YSh0aGlzLl9sYW5ndWFnZUlkQ29kZWMuZW5jb2RlTGFuZ3VhZ2VJZCh0b3BMZXZlbExhbmd1YWdlSWQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lVG9rZW5zKGxpbmVUb2tlbnMsIGxpbmVUZXh0LCB0aGlzLl9sYW5ndWFnZUlkQ29kZWMpO1xuICAgIH1cbiAgICBzdGF0aWMgX21hc3NhZ2VUb2tlbnModG9wTGV2ZWxMYW5ndWFnZUlkLCBsaW5lVGV4dExlbmd0aCwgX3Rva2Vucykge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBfdG9rZW5zID8gdG9VaW50MzJBcnJheShfdG9rZW5zKSA6IG51bGw7XG4gICAgICAgIGlmIChsaW5lVGV4dExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbGV0IGhhc0RpZmZlcmVudExhbmd1YWdlSWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0b2tlbnMgJiYgdG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBoYXNEaWZmZXJlbnRMYW5ndWFnZUlkID0gKFRva2VuTWV0YWRhdGEuZ2V0TGFuZ3VhZ2VJZCh0b2tlbnNbMV0pICE9PSB0b3BMZXZlbExhbmd1YWdlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNEaWZmZXJlbnRMYW5ndWFnZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0xJTkVfVE9LRU5TO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdG9rZW5zIHx8IHRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IG5ldyBVaW50MzJBcnJheSgyKTtcbiAgICAgICAgICAgIHRva2Vuc1swXSA9IGxpbmVUZXh0TGVuZ3RoO1xuICAgICAgICAgICAgdG9rZW5zWzFdID0gZ2V0RGVmYXVsdE1ldGFkYXRhKHRvcExldmVsTGFuZ3VhZ2VJZCk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIGxhc3QgdG9rZW4gY292ZXJzIHRoZSBlbmQgb2YgdGhlIHRleHRcbiAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAyXSA9IGxpbmVUZXh0TGVuZ3RoO1xuICAgICAgICBpZiAodG9rZW5zLmJ5dGVPZmZzZXQgPT09IDAgJiYgdG9rZW5zLmJ5dGVMZW5ndGggPT09IHRva2Vucy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgLy8gU3RvcmUgZGlyZWN0bHkgdGhlIEFycmF5QnVmZmVyIHBvaW50ZXIgdG8gc2F2ZSBhbiBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnMuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIF9lbnN1cmVMaW5lKGxpbmVJbmRleCkge1xuICAgICAgICB3aGlsZSAobGluZUluZGV4ID49IHRoaXMuX2xlbikge1xuICAgICAgICAgICAgdGhpcy5fbGluZVRva2Vuc1t0aGlzLl9sZW5dID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2xlbisrO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9kZWxldGVMaW5lcyhzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgaWYgKGRlbGV0ZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ICsgZGVsZXRlQ291bnQgPiB0aGlzLl9sZW4pIHtcbiAgICAgICAgICAgIGRlbGV0ZUNvdW50ID0gdGhpcy5fbGVuIC0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGluZVRva2Vucy5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KTtcbiAgICAgICAgdGhpcy5fbGVuIC09IGRlbGV0ZUNvdW50O1xuICAgIH1cbiAgICBfaW5zZXJ0TGluZXMoaW5zZXJ0SW5kZXgsIGluc2VydENvdW50KSB7XG4gICAgICAgIGlmIChpbnNlcnRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVUb2tlbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnNlcnRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lVG9rZW5zW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9saW5lVG9rZW5zID0gYXJyYXlzLmFycmF5SW5zZXJ0KHRoaXMuX2xpbmVUb2tlbnMsIGluc2VydEluZGV4LCBsaW5lVG9rZW5zKTtcbiAgICAgICAgdGhpcy5fbGVuICs9IGluc2VydENvdW50O1xuICAgIH1cbiAgICBzZXRUb2tlbnModG9wTGV2ZWxMYW5ndWFnZUlkLCBsaW5lSW5kZXgsIGxpbmVUZXh0TGVuZ3RoLCBfdG9rZW5zLCBjaGVja0VxdWFsaXR5KSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IENvbnRpZ3VvdXNUb2tlbnNTdG9yZS5fbWFzc2FnZVRva2Vucyh0aGlzLl9sYW5ndWFnZUlkQ29kZWMuZW5jb2RlTGFuZ3VhZ2VJZCh0b3BMZXZlbExhbmd1YWdlSWQpLCBsaW5lVGV4dExlbmd0aCwgX3Rva2Vucyk7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgICAgY29uc3Qgb2xkVG9rZW5zID0gdGhpcy5fbGluZVRva2Vuc1tsaW5lSW5kZXhdO1xuICAgICAgICB0aGlzLl9saW5lVG9rZW5zW2xpbmVJbmRleF0gPSB0b2tlbnM7XG4gICAgICAgIGlmIChjaGVja0VxdWFsaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gIUNvbnRpZ3VvdXNUb2tlbnNTdG9yZS5fZXF1YWxzKG9sZFRva2VucywgdG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXRpYyBfZXF1YWxzKF9hLCBfYikge1xuICAgICAgICBpZiAoIV9hIHx8ICFfYikge1xuICAgICAgICAgICAgcmV0dXJuICFfYSAmJiAhX2I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYSA9IHRvVWludDMyQXJyYXkoX2EpO1xuICAgICAgICBjb25zdCBiID0gdG9VaW50MzJBcnJheShfYik7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vI3JlZ2lvbiBFZGl0aW5nXG4gICAgYWNjZXB0RWRpdChyYW5nZSwgZW9sQ291bnQsIGZpcnN0TGluZUxlbmd0aCkge1xuICAgICAgICB0aGlzLl9hY2NlcHREZWxldGVSYW5nZShyYW5nZSk7XG4gICAgICAgIHRoaXMuX2FjY2VwdEluc2VydFRleHQobmV3IFBvc2l0aW9uKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4pLCBlb2xDb3VudCwgZmlyc3RMaW5lTGVuZ3RoKTtcbiAgICB9XG4gICAgX2FjY2VwdERlbGV0ZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0TGluZUluZGV4ID0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMTtcbiAgICAgICAgaWYgKGZpcnN0TGluZUluZGV4ID49IHRoaXMuX2xlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydENvbHVtbiA9PT0gcmFuZ2UuZW5kQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkZWxldGVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lVG9rZW5zW2ZpcnN0TGluZUluZGV4XSA9IENvbnRpZ3VvdXNUb2tlbnNFZGl0aW5nLmRlbGV0ZSh0aGlzLl9saW5lVG9rZW5zW2ZpcnN0TGluZUluZGV4XSwgcmFuZ2Uuc3RhcnRDb2x1bW4gLSAxLCByYW5nZS5lbmRDb2x1bW4gLSAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9saW5lVG9rZW5zW2ZpcnN0TGluZUluZGV4XSA9IENvbnRpZ3VvdXNUb2tlbnNFZGl0aW5nLmRlbGV0ZUVuZGluZyh0aGlzLl9saW5lVG9rZW5zW2ZpcnN0TGluZUluZGV4XSwgcmFuZ2Uuc3RhcnRDb2x1bW4gLSAxKTtcbiAgICAgICAgY29uc3QgbGFzdExpbmVJbmRleCA9IHJhbmdlLmVuZExpbmVOdW1iZXIgLSAxO1xuICAgICAgICBsZXQgbGFzdExpbmVUb2tlbnMgPSBudWxsO1xuICAgICAgICBpZiAobGFzdExpbmVJbmRleCA8IHRoaXMuX2xlbikge1xuICAgICAgICAgICAgbGFzdExpbmVUb2tlbnMgPSBDb250aWd1b3VzVG9rZW5zRWRpdGluZy5kZWxldGVCZWdpbm5pbmcodGhpcy5fbGluZVRva2Vuc1tsYXN0TGluZUluZGV4XSwgcmFuZ2UuZW5kQ29sdW1uIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGFrZSByZW1haW5pbmcgdGV4dCBvbiBsYXN0IGxpbmUgYW5kIGFwcGVuZCBpdCB0byByZW1haW5pbmcgdGV4dCBvbiBmaXJzdCBsaW5lXG4gICAgICAgIHRoaXMuX2xpbmVUb2tlbnNbZmlyc3RMaW5lSW5kZXhdID0gQ29udGlndW91c1Rva2Vuc0VkaXRpbmcuYXBwZW5kKHRoaXMuX2xpbmVUb2tlbnNbZmlyc3RMaW5lSW5kZXhdLCBsYXN0TGluZVRva2Vucyk7XG4gICAgICAgIC8vIERlbGV0ZSBtaWRkbGUgbGluZXNcbiAgICAgICAgdGhpcy5fZGVsZXRlTGluZXMocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyIC0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKTtcbiAgICB9XG4gICAgX2FjY2VwdEluc2VydFRleHQocG9zaXRpb24sIGVvbENvdW50LCBmaXJzdExpbmVMZW5ndGgpIHtcbiAgICAgICAgaWYgKGVvbENvdW50ID09PSAwICYmIGZpcnN0TGluZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm90aGluZyB0byBpbnNlcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lSW5kZXggPSBwb3NpdGlvbi5saW5lTnVtYmVyIC0gMTtcbiAgICAgICAgaWYgKGxpbmVJbmRleCA+PSB0aGlzLl9sZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW9sQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEluc2VydGluZyB0ZXh0IG9uIG9uZSBsaW5lXG4gICAgICAgICAgICB0aGlzLl9saW5lVG9rZW5zW2xpbmVJbmRleF0gPSBDb250aWd1b3VzVG9rZW5zRWRpdGluZy5pbnNlcnQodGhpcy5fbGluZVRva2Vuc1tsaW5lSW5kZXhdLCBwb3NpdGlvbi5jb2x1bW4gLSAxLCBmaXJzdExpbmVMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpbmVUb2tlbnNbbGluZUluZGV4XSA9IENvbnRpZ3VvdXNUb2tlbnNFZGl0aW5nLmRlbGV0ZUVuZGluZyh0aGlzLl9saW5lVG9rZW5zW2xpbmVJbmRleF0sIHBvc2l0aW9uLmNvbHVtbiAtIDEpO1xuICAgICAgICB0aGlzLl9saW5lVG9rZW5zW2xpbmVJbmRleF0gPSBDb250aWd1b3VzVG9rZW5zRWRpdGluZy5pbnNlcnQodGhpcy5fbGluZVRva2Vuc1tsaW5lSW5kZXhdLCBwb3NpdGlvbi5jb2x1bW4gLSAxLCBmaXJzdExpbmVMZW5ndGgpO1xuICAgICAgICB0aGlzLl9pbnNlcnRMaW5lcyhwb3NpdGlvbi5saW5lTnVtYmVyLCBlb2xDb3VudCk7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICAgIHNldE11bHRpbGluZVRva2Vucyh0b2tlbnMsIHRleHRNb2RlbCkge1xuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW10gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIGxldCBtaW5DaGFuZ2VkTGluZU51bWJlciA9IDA7XG4gICAgICAgICAgICBsZXQgbWF4Q2hhbmdlZExpbmVOdW1iZXIgPSAwO1xuICAgICAgICAgICAgbGV0IGhhc0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgbGluZU51bWJlciA9IGVsZW1lbnQuc3RhcnRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyIDw9IGVsZW1lbnQuZW5kTGluZU51bWJlcjsgbGluZU51bWJlcisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRva2Vucyh0ZXh0TW9kZWwuZ2V0TGFuZ3VhZ2VJZCgpLCBsaW5lTnVtYmVyIC0gMSwgdGV4dE1vZGVsLmdldExpbmVMZW5ndGgobGluZU51bWJlciksIGVsZW1lbnQuZ2V0TGluZVRva2VucyhsaW5lTnVtYmVyKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBtYXhDaGFuZ2VkTGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lSGFzQ2hhbmdlID0gdGhpcy5zZXRUb2tlbnModGV4dE1vZGVsLmdldExhbmd1YWdlSWQoKSwgbGluZU51bWJlciAtIDEsIHRleHRNb2RlbC5nZXRMaW5lTGVuZ3RoKGxpbmVOdW1iZXIpLCBlbGVtZW50LmdldExpbmVUb2tlbnMobGluZU51bWJlciksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZUhhc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNoYW5nZWRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heENoYW5nZWRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb21MaW5lTnVtYmVyOiBtaW5DaGFuZ2VkTGluZU51bWJlciwgdG9MaW5lTnVtYmVyOiBtYXhDaGFuZ2VkTGluZU51bWJlciwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogcmFuZ2VzIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdE1ldGFkYXRhKHRvcExldmVsTGFuZ3VhZ2VJZCkge1xuICAgIHJldHVybiAoKHRvcExldmVsTGFuZ3VhZ2VJZCA8PCAwIC8qIE1ldGFkYXRhQ29uc3RzLkxBTkdVQUdFSURfT0ZGU0VUICovKVxuICAgICAgICB8ICgwIC8qIFN0YW5kYXJkVG9rZW5UeXBlLk90aGVyICovIDw8IDggLyogTWV0YWRhdGFDb25zdHMuVE9LRU5fVFlQRV9PRkZTRVQgKi8pXG4gICAgICAgIHwgKDAgLyogRm9udFN0eWxlLk5vbmUgKi8gPDwgMTEgLyogTWV0YWRhdGFDb25zdHMuRk9OVF9TVFlMRV9PRkZTRVQgKi8pXG4gICAgICAgIHwgKDEgLyogQ29sb3JJZC5EZWZhdWx0Rm9yZWdyb3VuZCAqLyA8PCAxNSAvKiBNZXRhZGF0YUNvbnN0cy5GT1JFR1JPVU5EX09GRlNFVCAqLylcbiAgICAgICAgfCAoMiAvKiBDb2xvcklkLkRlZmF1bHRCYWNrZ3JvdW5kICovIDw8IDI0IC8qIE1ldGFkYXRhQ29uc3RzLkJBQ0tHUk9VTkRfT0ZGU0VUICovKVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBncmFtbWFyLCB3ZSBqdXN0IHRha2UgYSBndWVzcyBhbmQgdHJ5IHRvIG1hdGNoIGJyYWNrZXRzLlxuICAgICAgICB8ICgxMDI0IC8qIE1ldGFkYXRhQ29uc3RzLkJBTEFOQ0VEX0JSQUNLRVRTX01BU0sgKi8pKSA+Pj4gMDtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgVG9rZW5NZXRhZGF0YSB9IGZyb20gJy4uL2VuY29kZWRUb2tlbkF0dHJpYnV0ZXMuanMnO1xuZXhwb3J0IGNsYXNzIExpbmVUb2tlbnMge1xuICAgIHN0YXRpYyB7IHRoaXMuZGVmYXVsdFRva2VuTWV0YWRhdGEgPSAoKDAgLyogRm9udFN0eWxlLk5vbmUgKi8gPDwgMTEgLyogTWV0YWRhdGFDb25zdHMuRk9OVF9TVFlMRV9PRkZTRVQgKi8pXG4gICAgICAgIHwgKDEgLyogQ29sb3JJZC5EZWZhdWx0Rm9yZWdyb3VuZCAqLyA8PCAxNSAvKiBNZXRhZGF0YUNvbnN0cy5GT1JFR1JPVU5EX09GRlNFVCAqLylcbiAgICAgICAgfCAoMiAvKiBDb2xvcklkLkRlZmF1bHRCYWNrZ3JvdW5kICovIDw8IDI0IC8qIE1ldGFkYXRhQ29uc3RzLkJBQ0tHUk9VTkRfT0ZGU0VUICovKSkgPj4+IDA7IH1cbiAgICBzdGF0aWMgY3JlYXRlRW1wdHkobGluZUNvbnRlbnQsIGRlY29kZXIpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhID0gTGluZVRva2Vucy5kZWZhdWx0VG9rZW5NZXRhZGF0YTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gbmV3IFVpbnQzMkFycmF5KDIpO1xuICAgICAgICB0b2tlbnNbMF0gPSBsaW5lQ29udGVudC5sZW5ndGg7XG4gICAgICAgIHRva2Vuc1sxXSA9IGRlZmF1bHRNZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lVG9rZW5zKHRva2VucywgbGluZUNvbnRlbnQsIGRlY29kZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbVRleHRBbmRNZXRhZGF0YShkYXRhLCBkZWNvZGVyKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgZnVsbFRleHQgPSAnJztcbiAgICAgICAgY29uc3QgdG9rZW5zID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGZvciAoY29uc3QgeyB0ZXh0LCBtZXRhZGF0YSB9IG9mIGRhdGEpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKG9mZnNldCArIHRleHQubGVuZ3RoLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBmdWxsVGV4dCArPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGluZVRva2VucyhuZXcgVWludDMyQXJyYXkodG9rZW5zKSwgZnVsbFRleHQsIGRlY29kZXIpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMsIHRleHQsIGRlY29kZXIpIHtcbiAgICAgICAgdGhpcy5fbGluZVRva2Vuc0JyYW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuX3Rva2Vuc0NvdW50ID0gKHRoaXMuX3Rva2Vucy5sZW5ndGggPj4+IDEpO1xuICAgICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUlkQ29kZWMgPSBkZWNvZGVyO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgTGluZVRva2Vucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2VkRXF1YWxzKG90aGVyLCAwLCB0aGlzLl90b2tlbnNDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzbGljZWRFcXVhbHMob3RoZXIsIHNsaWNlRnJvbVRva2VuSW5kZXgsIHNsaWNlVG9rZW5Db3VudCkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dCAhPT0gb3RoZXIuX3RleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdG9rZW5zQ291bnQgIT09IG90aGVyLl90b2tlbnNDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyb20gPSAoc2xpY2VGcm9tVG9rZW5JbmRleCA8PCAxKTtcbiAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgKHNsaWNlVG9rZW5Db3VudCA8PCAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9rZW5zW2ldICE9PSBvdGhlci5fdG9rZW5zW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXRMaW5lQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gICAgfVxuICAgIGdldENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5zQ291bnQ7XG4gICAgfVxuICAgIGdldFN0YXJ0T2Zmc2V0KHRva2VuSW5kZXgpIHtcbiAgICAgICAgaWYgKHRva2VuSW5kZXggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5zWyh0b2tlbkluZGV4IC0gMSkgPDwgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGdldE1ldGFkYXRhKHRva2VuSW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLl90b2tlbnNbKHRva2VuSW5kZXggPDwgMSkgKyAxXTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICBnZXRMYW5ndWFnZUlkKHRva2VuSW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLl90b2tlbnNbKHRva2VuSW5kZXggPDwgMSkgKyAxXTtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VJZCA9IFRva2VuTWV0YWRhdGEuZ2V0TGFuZ3VhZ2VJZChtZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxhbmd1YWdlSWRDb2RlYy5kZWNvZGVMYW5ndWFnZUlkKGxhbmd1YWdlSWQpO1xuICAgIH1cbiAgICBnZXRTdGFuZGFyZFRva2VuVHlwZSh0b2tlbkluZGV4KSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5fdG9rZW5zWyh0b2tlbkluZGV4IDw8IDEpICsgMV07XG4gICAgICAgIHJldHVybiBUb2tlbk1ldGFkYXRhLmdldFRva2VuVHlwZShtZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldEZvcmVncm91bmQodG9rZW5JbmRleCkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuX3Rva2Vuc1sodG9rZW5JbmRleCA8PCAxKSArIDFdO1xuICAgICAgICByZXR1cm4gVG9rZW5NZXRhZGF0YS5nZXRGb3JlZ3JvdW5kKG1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0Q2xhc3NOYW1lKHRva2VuSW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLl90b2tlbnNbKHRva2VuSW5kZXggPDwgMSkgKyAxXTtcbiAgICAgICAgcmV0dXJuIFRva2VuTWV0YWRhdGEuZ2V0Q2xhc3NOYW1lRnJvbU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0SW5saW5lU3R5bGUodG9rZW5JbmRleCwgY29sb3JNYXApIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLl90b2tlbnNbKHRva2VuSW5kZXggPDwgMSkgKyAxXTtcbiAgICAgICAgcmV0dXJuIFRva2VuTWV0YWRhdGEuZ2V0SW5saW5lU3R5bGVGcm9tTWV0YWRhdGEobWV0YWRhdGEsIGNvbG9yTWFwKTtcbiAgICB9XG4gICAgZ2V0UHJlc2VudGF0aW9uKHRva2VuSW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLl90b2tlbnNbKHRva2VuSW5kZXggPDwgMSkgKyAxXTtcbiAgICAgICAgcmV0dXJuIFRva2VuTWV0YWRhdGEuZ2V0UHJlc2VudGF0aW9uRnJvbU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RW5kT2Zmc2V0KHRva2VuSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vuc1t0b2tlbkluZGV4IDw8IDFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSB0b2tlbiBjb250YWluaW5nIG9mZnNldCBgb2Zmc2V0YC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBzZWFyY2ggb2Zmc2V0XG4gICAgICogQHJldHVybiBUaGUgaW5kZXggb2YgdGhlIHRva2VuIGNvbnRhaW5pbmcgdGhlIG9mZnNldC5cbiAgICAgKi9cbiAgICBmaW5kVG9rZW5JbmRleEF0T2Zmc2V0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gTGluZVRva2Vucy5maW5kSW5kZXhJblRva2Vuc0FycmF5KHRoaXMuX3Rva2Vucywgb2Zmc2V0KTtcbiAgICB9XG4gICAgaW5mbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNsaWNlQW5kSW5mbGF0ZShzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBkZWx0YU9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlTGluZVRva2Vucyh0aGlzLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBkZWx0YU9mZnNldCk7XG4gICAgfVxuICAgIHN0YXRpYyBjb252ZXJ0VG9FbmRPZmZzZXQodG9rZW5zLCBsaW5lVGV4dExlbmd0aCkge1xuICAgICAgICBjb25zdCB0b2tlbkNvdW50ID0gKHRva2Vucy5sZW5ndGggPj4+IDEpO1xuICAgICAgICBjb25zdCBsYXN0VG9rZW5JbmRleCA9IHRva2VuQ291bnQgLSAxO1xuICAgICAgICBmb3IgKGxldCB0b2tlbkluZGV4ID0gMDsgdG9rZW5JbmRleCA8IGxhc3RUb2tlbkluZGV4OyB0b2tlbkluZGV4KyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbkluZGV4IDw8IDFdID0gdG9rZW5zWyh0b2tlbkluZGV4ICsgMSkgPDwgMV07XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zW2xhc3RUb2tlbkluZGV4IDw8IDFdID0gbGluZVRleHRMZW5ndGg7XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kSW5kZXhJblRva2Vuc0FycmF5KHRva2VucywgZGVzaXJlZEluZGV4KSB7XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsb3cgPSAwO1xuICAgICAgICBsZXQgaGlnaCA9ICh0b2tlbnMubGVuZ3RoID4+PiAxKSAtIDE7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBsb3cgKyBNYXRoLmZsb29yKChoaWdoIC0gbG93KSAvIDIpO1xuICAgICAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gdG9rZW5zWyhtaWQgPDwgMSldO1xuICAgICAgICAgICAgaWYgKGVuZE9mZnNldCA9PT0gZGVzaXJlZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmRPZmZzZXQgPCBkZXNpcmVkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kT2Zmc2V0ID4gZGVzaXJlZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVyZVxuICAgICAqIEBwYXJhbSBpbnNlcnRUb2tlbnMgTXVzdCBiZSBzb3J0ZWQgYnkgb2Zmc2V0LlxuICAgICovXG4gICAgd2l0aEluc2VydGVkKGluc2VydFRva2Vucykge1xuICAgICAgICBpZiAoaW5zZXJ0VG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRPcmlnaW5hbFRva2VuSWR4ID0gMDtcbiAgICAgICAgbGV0IG5leHRJbnNlcnRUb2tlbklkeCA9IDA7XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGNvbnN0IG5ld1Rva2VucyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBsZXQgb3JpZ2luYWxFbmRPZmZzZXQgPSAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dE9yaWdpbmFsVG9rZW5FbmRPZmZzZXQgPSBuZXh0T3JpZ2luYWxUb2tlbklkeCA8IHRoaXMuX3Rva2Vuc0NvdW50ID8gdGhpcy5fdG9rZW5zW25leHRPcmlnaW5hbFRva2VuSWR4IDw8IDFdIDogLTE7XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5zZXJ0VG9rZW4gPSBuZXh0SW5zZXJ0VG9rZW5JZHggPCBpbnNlcnRUb2tlbnMubGVuZ3RoID8gaW5zZXJ0VG9rZW5zW25leHRJbnNlcnRUb2tlbklkeF0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKG5leHRPcmlnaW5hbFRva2VuRW5kT2Zmc2V0ICE9PSAtMSAmJiAobmV4dEluc2VydFRva2VuID09PSBudWxsIHx8IG5leHRPcmlnaW5hbFRva2VuRW5kT2Zmc2V0IDw9IG5leHRJbnNlcnRUb2tlbi5vZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgdG9rZW4gZW5kcyBiZWZvcmUgbmV4dCBpbnNlcnQgdG9rZW5cbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHRoaXMuX3RleHQuc3Vic3RyaW5nKG9yaWdpbmFsRW5kT2Zmc2V0LCBuZXh0T3JpZ2luYWxUb2tlbkVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLl90b2tlbnNbKG5leHRPcmlnaW5hbFRva2VuSWR4IDw8IDEpICsgMV07XG4gICAgICAgICAgICAgICAgbmV3VG9rZW5zLnB1c2godGV4dC5sZW5ndGgsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICBuZXh0T3JpZ2luYWxUb2tlbklkeCsrO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kT2Zmc2V0ID0gbmV4dE9yaWdpbmFsVG9rZW5FbmRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0SW5zZXJ0VG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEluc2VydFRva2VuLm9mZnNldCA+IG9yaWdpbmFsRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0b2tlbiBpcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBuZXh0IHRva2VuLlxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHRoaXMuX3RleHQuc3Vic3RyaW5nKG9yaWdpbmFsRW5kT2Zmc2V0LCBuZXh0SW5zZXJ0VG9rZW4ub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLl90b2tlbnNbKG5leHRPcmlnaW5hbFRva2VuSWR4IDw8IDEpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIG5ld1Rva2Vucy5wdXNoKHRleHQubGVuZ3RoLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kT2Zmc2V0ID0gbmV4dEluc2VydFRva2VuLm9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dCArPSBuZXh0SW5zZXJ0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICBuZXdUb2tlbnMucHVzaCh0ZXh0Lmxlbmd0aCwgbmV4dEluc2VydFRva2VuLnRva2VuTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIG5leHRJbnNlcnRUb2tlbklkeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lVG9rZW5zKG5ldyBVaW50MzJBcnJheShuZXdUb2tlbnMpLCB0ZXh0LCB0aGlzLmxhbmd1YWdlSWRDb2RlYyk7XG4gICAgfVxuICAgIGdldFRva2VuVGV4dCh0b2tlbkluZGV4KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5nZXRTdGFydE9mZnNldCh0b2tlbkluZGV4KTtcbiAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gdGhpcy5nZXRFbmRPZmZzZXQodG9rZW5JbmRleCk7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLl90ZXh0LnN1YnN0cmluZyhzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdG9rZW5Db3VudCA9IHRoaXMuZ2V0Q291bnQoKTtcbiAgICAgICAgZm9yIChsZXQgdG9rZW5JbmRleCA9IDA7IHRva2VuSW5kZXggPCB0b2tlbkNvdW50OyB0b2tlbkluZGV4KyspIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRva2VuSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2xpY2VMaW5lVG9rZW5zIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIGRlbHRhT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5fc3RhcnRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgdGhpcy5fZW5kT2Zmc2V0ID0gZW5kT2Zmc2V0O1xuICAgICAgICB0aGlzLl9kZWx0YU9mZnNldCA9IGRlbHRhT2Zmc2V0O1xuICAgICAgICB0aGlzLl9maXJzdFRva2VuSW5kZXggPSBzb3VyY2UuZmluZFRva2VuSW5kZXhBdE9mZnNldChzdGFydE9mZnNldCk7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2VJZENvZGVjID0gc291cmNlLmxhbmd1YWdlSWRDb2RlYztcbiAgICAgICAgdGhpcy5fdG9rZW5zQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fZmlyc3RUb2tlbkluZGV4LCBsZW4gPSBzb3VyY2UuZ2V0Q291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlblN0YXJ0T2Zmc2V0ID0gc291cmNlLmdldFN0YXJ0T2Zmc2V0KGkpO1xuICAgICAgICAgICAgaWYgKHRva2VuU3RhcnRPZmZzZXQgPj0gZW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90b2tlbnNDb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1ldGFkYXRhKHRva2VuSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5nZXRNZXRhZGF0YSh0aGlzLl9maXJzdFRva2VuSW5kZXggKyB0b2tlbkluZGV4KTtcbiAgICB9XG4gICAgZ2V0TGFuZ3VhZ2VJZCh0b2tlbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UuZ2V0TGFuZ3VhZ2VJZCh0aGlzLl9maXJzdFRva2VuSW5kZXggKyB0b2tlbkluZGV4KTtcbiAgICB9XG4gICAgZ2V0TGluZUNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UuZ2V0TGluZUNvbnRlbnQoKS5zdWJzdHJpbmcodGhpcy5fc3RhcnRPZmZzZXQsIHRoaXMuX2VuZE9mZnNldCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBTbGljZUxpbmVUb2tlbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fc3RhcnRPZmZzZXQgPT09IG90aGVyLl9zdGFydE9mZnNldFxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2VuZE9mZnNldCA9PT0gb3RoZXIuX2VuZE9mZnNldFxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2RlbHRhT2Zmc2V0ID09PSBvdGhlci5fZGVsdGFPZmZzZXRcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2Uuc2xpY2VkRXF1YWxzKG90aGVyLl9zb3VyY2UsIHRoaXMuX2ZpcnN0VG9rZW5JbmRleCwgdGhpcy5fdG9rZW5zQ291bnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5zQ291bnQ7XG4gICAgfVxuICAgIGdldFN0YW5kYXJkVG9rZW5UeXBlKHRva2VuSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5nZXRTdGFuZGFyZFRva2VuVHlwZSh0aGlzLl9maXJzdFRva2VuSW5kZXggKyB0b2tlbkluZGV4KTtcbiAgICB9XG4gICAgZ2V0Rm9yZWdyb3VuZCh0b2tlbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UuZ2V0Rm9yZWdyb3VuZCh0aGlzLl9maXJzdFRva2VuSW5kZXggKyB0b2tlbkluZGV4KTtcbiAgICB9XG4gICAgZ2V0RW5kT2Zmc2V0KHRva2VuSW5kZXgpIHtcbiAgICAgICAgY29uc3QgdG9rZW5FbmRPZmZzZXQgPSB0aGlzLl9zb3VyY2UuZ2V0RW5kT2Zmc2V0KHRoaXMuX2ZpcnN0VG9rZW5JbmRleCArIHRva2VuSW5kZXgpO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5fZW5kT2Zmc2V0LCB0b2tlbkVuZE9mZnNldCkgLSB0aGlzLl9zdGFydE9mZnNldCArIHRoaXMuX2RlbHRhT2Zmc2V0O1xuICAgIH1cbiAgICBnZXRDbGFzc05hbWUodG9rZW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlLmdldENsYXNzTmFtZSh0aGlzLl9maXJzdFRva2VuSW5kZXggKyB0b2tlbkluZGV4KTtcbiAgICB9XG4gICAgZ2V0SW5saW5lU3R5bGUodG9rZW5JbmRleCwgY29sb3JNYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5nZXRJbmxpbmVTdHlsZSh0aGlzLl9maXJzdFRva2VuSW5kZXggKyB0b2tlbkluZGV4LCBjb2xvck1hcCk7XG4gICAgfVxuICAgIGdldFByZXNlbnRhdGlvbih0b2tlbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UuZ2V0UHJlc2VudGF0aW9uKHRoaXMuX2ZpcnN0VG9rZW5JbmRleCArIHRva2VuSW5kZXgpO1xuICAgIH1cbiAgICBmaW5kVG9rZW5JbmRleEF0T2Zmc2V0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlLmZpbmRUb2tlbkluZGV4QXRPZmZzZXQob2Zmc2V0ICsgdGhpcy5fc3RhcnRPZmZzZXQgLSB0aGlzLl9kZWx0YU9mZnNldCkgLSB0aGlzLl9maXJzdFRva2VuSW5kZXg7XG4gICAgfVxuICAgIGdldFRva2VuVGV4dCh0b2tlbkluZGV4KSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkVG9rZW5JbmRleCA9IHRoaXMuX2ZpcnN0VG9rZW5JbmRleCArIHRva2VuSW5kZXg7XG4gICAgICAgIGNvbnN0IHRva2VuU3RhcnRPZmZzZXQgPSB0aGlzLl9zb3VyY2UuZ2V0U3RhcnRPZmZzZXQoYWRqdXN0ZWRUb2tlbkluZGV4KTtcbiAgICAgICAgY29uc3QgdG9rZW5FbmRPZmZzZXQgPSB0aGlzLl9zb3VyY2UuZ2V0RW5kT2Zmc2V0KGFkanVzdGVkVG9rZW5JbmRleCk7XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5fc291cmNlLmdldFRva2VuVGV4dChhZGp1c3RlZFRva2VuSW5kZXgpO1xuICAgICAgICBpZiAodG9rZW5TdGFydE9mZnNldCA8IHRoaXMuX3N0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcodGhpcy5fc3RhcnRPZmZzZXQgLSB0b2tlblN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5FbmRPZmZzZXQgPiB0aGlzLl9lbmRPZmZzZXQpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCB0ZXh0Lmxlbmd0aCAtICh0b2tlbkVuZE9mZnNldCAtIHRoaXMuX2VuZE9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGZvciAobGV0IHRva2VuSW5kZXggPSAwOyB0b2tlbkluZGV4IDwgdGhpcy5nZXRDb3VudCgpOyB0b2tlbkluZGV4KyspIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRva2VuSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YW5kYXJkVG9rZW5UeXBlQXRQb3NpdGlvbihtb2RlbCwgcG9zaXRpb24pIHtcbiAgICBjb25zdCBsaW5lTnVtYmVyID0gcG9zaXRpb24ubGluZU51bWJlcjtcbiAgICBpZiAoIW1vZGVsLnRva2VuaXphdGlvbi5pc0NoZWFwVG9Ub2tlbml6ZShsaW5lTnVtYmVyKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBtb2RlbC50b2tlbml6YXRpb24uZm9yY2VUb2tlbml6YXRpb24obGluZU51bWJlcik7XG4gICAgY29uc3QgbGluZVRva2VucyA9IG1vZGVsLnRva2VuaXphdGlvbi5nZXRMaW5lVG9rZW5zKGxpbmVOdW1iZXIpO1xuICAgIGNvbnN0IHRva2VuSW5kZXggPSBsaW5lVG9rZW5zLmZpbmRUb2tlbkluZGV4QXRPZmZzZXQocG9zaXRpb24uY29sdW1uIC0gMSk7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gbGluZVRva2Vucy5nZXRTdGFuZGFyZFRva2VuVHlwZSh0b2tlbkluZGV4KTtcbiAgICByZXR1cm4gdG9rZW5UeXBlO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyBhcnJheXMgZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzLmpzJztcbmltcG9ydCB7IExpbmVUb2tlbnMgfSBmcm9tICcuL2xpbmVUb2tlbnMuanMnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHNwYXJzZSB0b2tlbnMgaW4gYSB0ZXh0IG1vZGVsLlxuICovXG5leHBvcnQgY2xhc3MgU3BhcnNlVG9rZW5zU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGxhbmd1YWdlSWRDb2RlYykge1xuICAgICAgICB0aGlzLl9waWVjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkQ29kZWMgPSBsYW5ndWFnZUlkQ29kZWM7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICB0aGlzLl9waWVjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3BpZWNlcy5sZW5ndGggPT09IDApO1xuICAgIH1cbiAgICBzZXQocGllY2VzLCBpc0NvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuX3BpZWNlcyA9IHBpZWNlcyB8fCBbXTtcbiAgICAgICAgdGhpcy5faXNDb21wbGV0ZSA9IGlzQ29tcGxldGU7XG4gICAgfVxuICAgIHNldFBhcnRpYWwoX3JhbmdlLCBwaWVjZXMpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYHNldFBhcnRpYWwgJHtfcmFuZ2V9ICR7cGllY2VzLm1hcChwID0+IHAudG9TdHJpbmcoKSkuam9pbignLCAnKX1gKTtcbiAgICAgICAgbGV0IHJhbmdlID0gX3JhbmdlO1xuICAgICAgICBpZiAocGllY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IF9maXJzdFJhbmdlID0gcGllY2VzWzBdLmdldFJhbmdlKCk7XG4gICAgICAgICAgICBjb25zdCBfbGFzdFJhbmdlID0gcGllY2VzW3BpZWNlcy5sZW5ndGggLSAxXS5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKCFfZmlyc3RSYW5nZSB8fCAhX2xhc3RSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZSA9IF9yYW5nZS5wbHVzUmFuZ2UoX2ZpcnN0UmFuZ2UpLnBsdXNSYW5nZShfbGFzdFJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5zZXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fcGllY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX3BpZWNlc1tpXTtcbiAgICAgICAgICAgIGlmIChwaWVjZS5lbmRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBwaWVjZSBpcyBiZWZvcmUgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGllY2Uuc3RhcnRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgcGllY2UgaXMgYWZ0ZXIgdGhlIHJhbmdlLCBzbyBtYXJrIHRoZSBzcG90IGJlZm9yZSB0aGlzIHBpZWNlXG4gICAgICAgICAgICAgICAgLy8gYXMgYSBnb29kIGluc2VydGlvbiBwb3NpdGlvbiBhbmQgc3RvcCBsb29waW5nXG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb24gPSBpbnNlcnRQb3NpdGlvbiB8fCB7IGluZGV4OiBpIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIHBpZWNlIG1pZ2h0IGludGVyc2VjdCB3aXRoIHRoZSByYW5nZVxuICAgICAgICAgICAgcGllY2UucmVtb3ZlVG9rZW5zKHJhbmdlKTtcbiAgICAgICAgICAgIGlmIChwaWVjZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHBpZWNlIGlmIGl0IGJlY2FtZSBlbXB0eVxuICAgICAgICAgICAgICAgIHRoaXMuX3BpZWNlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBpZWNlLmVuZExpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBhZnRlciByZW1vdmFsLCB0aGlzIHBpZWNlIGlzIGJlZm9yZSB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwaWVjZS5zdGFydExpbmVOdW1iZXIgPiByYW5nZS5lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgcmVtb3ZhbCwgdGhpcyBwaWVjZSBpcyBhZnRlciB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbiA9IGluc2VydFBvc2l0aW9uIHx8IHsgaW5kZXg6IGkgfTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFmdGVyIHJlbW92YWwsIHRoaXMgcGllY2UgY29udGFpbnMgdGhlIHJhbmdlXG4gICAgICAgICAgICBjb25zdCBbYSwgYl0gPSBwaWVjZS5zcGxpdChyYW5nZSk7XG4gICAgICAgICAgICBpZiAoYS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHBpZWNlIGlzIGFjdHVhbGx5IGFmdGVyIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uID0gaW5zZXJ0UG9zaXRpb24gfHwgeyBpbmRleDogaSB9O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBwaWVjZSBpcyBhY3R1YWxseSBiZWZvcmUgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9waWVjZXMuc3BsaWNlKGksIDEsIGEsIGIpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgbGVuKys7XG4gICAgICAgICAgICBpbnNlcnRQb3NpdGlvbiA9IGluc2VydFBvc2l0aW9uIHx8IHsgaW5kZXg6IGkgfTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRQb3NpdGlvbiA9IGluc2VydFBvc2l0aW9uIHx8IHsgaW5kZXg6IHRoaXMuX3BpZWNlcy5sZW5ndGggfTtcbiAgICAgICAgaWYgKHBpZWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9waWVjZXMgPSBhcnJheXMuYXJyYXlJbnNlcnQodGhpcy5fcGllY2VzLCBpbnNlcnRQb3NpdGlvbi5pbmRleCwgcGllY2VzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgSSBIQVZFICR7dGhpcy5fcGllY2VzLmxlbmd0aH0gcGllY2VzYCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGAke3RoaXMuX3BpZWNlcy5tYXAocCA9PiBwLnRvU3RyaW5nKCkpLmpvaW4oJ1xcbicpfWApO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIGlzQ29tcGxldGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NvbXBsZXRlO1xuICAgIH1cbiAgICBhZGRTcGFyc2VUb2tlbnMobGluZU51bWJlciwgYVRva2Vucykge1xuICAgICAgICBpZiAoYVRva2Vucy5nZXRMaW5lQ29udGVudCgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgZm9yIGVtcHR5IGxpbmVzXG4gICAgICAgICAgICByZXR1cm4gYVRva2VucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaWVjZXMgPSB0aGlzLl9waWVjZXM7XG4gICAgICAgIGlmIChwaWVjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYVRva2VucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaWVjZUluZGV4ID0gU3BhcnNlVG9rZW5zU3RvcmUuX2ZpbmRGaXJzdFBpZWNlV2l0aExpbmUocGllY2VzLCBsaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgYlRva2VucyA9IHBpZWNlc1twaWVjZUluZGV4XS5nZXRMaW5lVG9rZW5zKGxpbmVOdW1iZXIpO1xuICAgICAgICBpZiAoIWJUb2tlbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBhVG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFMZW4gPSBhVG9rZW5zLmdldENvdW50KCk7XG4gICAgICAgIGNvbnN0IGJMZW4gPSBiVG9rZW5zLmdldENvdW50KCk7XG4gICAgICAgIGxldCBhSW5kZXggPSAwO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IHJlc3VsdExlbiA9IDA7XG4gICAgICAgIGxldCBsYXN0RW5kT2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgZW1pdFRva2VuID0gKGVuZE9mZnNldCwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlbmRPZmZzZXQgPT09IGxhc3RFbmRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0RW5kT2Zmc2V0ID0gZW5kT2Zmc2V0O1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IGVuZE9mZnNldDtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBtZXRhZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgYkluZGV4ID0gMDsgYkluZGV4IDwgYkxlbjsgYkluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJTdGFydENoYXJhY3RlciA9IGJUb2tlbnMuZ2V0U3RhcnRDaGFyYWN0ZXIoYkluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGJFbmRDaGFyYWN0ZXIgPSBiVG9rZW5zLmdldEVuZENoYXJhY3RlcihiSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgYk1ldGFkYXRhID0gYlRva2Vucy5nZXRNZXRhZGF0YShiSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgYk1hc2sgPSAoKChiTWV0YWRhdGEgJiAxIC8qIE1ldGFkYXRhQ29uc3RzLlNFTUFOVElDX1VTRV9JVEFMSUMgKi8pID8gMjA0OCAvKiBNZXRhZGF0YUNvbnN0cy5JVEFMSUNfTUFTSyAqLyA6IDApXG4gICAgICAgICAgICAgICAgfCAoKGJNZXRhZGF0YSAmIDIgLyogTWV0YWRhdGFDb25zdHMuU0VNQU5USUNfVVNFX0JPTEQgKi8pID8gNDA5NiAvKiBNZXRhZGF0YUNvbnN0cy5CT0xEX01BU0sgKi8gOiAwKVxuICAgICAgICAgICAgICAgIHwgKChiTWV0YWRhdGEgJiA0IC8qIE1ldGFkYXRhQ29uc3RzLlNFTUFOVElDX1VTRV9VTkRFUkxJTkUgKi8pID8gODE5MiAvKiBNZXRhZGF0YUNvbnN0cy5VTkRFUkxJTkVfTUFTSyAqLyA6IDApXG4gICAgICAgICAgICAgICAgfCAoKGJNZXRhZGF0YSAmIDggLyogTWV0YWRhdGFDb25zdHMuU0VNQU5USUNfVVNFX1NUUklLRVRIUk9VR0ggKi8pID8gMTYzODQgLyogTWV0YWRhdGFDb25zdHMuU1RSSUtFVEhST1VHSF9NQVNLICovIDogMClcbiAgICAgICAgICAgICAgICB8ICgoYk1ldGFkYXRhICYgMTYgLyogTWV0YWRhdGFDb25zdHMuU0VNQU5USUNfVVNFX0ZPUkVHUk9VTkQgKi8pID8gMTY3NDQ0NDggLyogTWV0YWRhdGFDb25zdHMuRk9SRUdST1VORF9NQVNLICovIDogMClcbiAgICAgICAgICAgICAgICB8ICgoYk1ldGFkYXRhICYgMzIgLyogTWV0YWRhdGFDb25zdHMuU0VNQU5USUNfVVNFX0JBQ0tHUk9VTkQgKi8pID8gNDI3ODE5MDA4MCAvKiBNZXRhZGF0YUNvbnN0cy5CQUNLR1JPVU5EX01BU0sgKi8gOiAwKSkgPj4+IDA7XG4gICAgICAgICAgICBjb25zdCBhTWFzayA9ICh+Yk1hc2spID4+PiAwO1xuICAgICAgICAgICAgLy8gcHVzaCBhbnkgdG9rZW4gZnJvbSBgYWAgdGhhdCBpcyBiZWZvcmUgYGJgXG4gICAgICAgICAgICB3aGlsZSAoYUluZGV4IDwgYUxlbiAmJiBhVG9rZW5zLmdldEVuZE9mZnNldChhSW5kZXgpIDw9IGJTdGFydENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIGVtaXRUb2tlbihhVG9rZW5zLmdldEVuZE9mZnNldChhSW5kZXgpLCBhVG9rZW5zLmdldE1ldGFkYXRhKGFJbmRleCkpO1xuICAgICAgICAgICAgICAgIGFJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHVzaCB0aGUgdG9rZW4gZnJvbSBgYWAgaWYgaXQgaW50ZXJzZWN0cyB0aGUgdG9rZW4gZnJvbSBgYmBcbiAgICAgICAgICAgIGlmIChhSW5kZXggPCBhTGVuICYmIGFUb2tlbnMuZ2V0U3RhcnRPZmZzZXQoYUluZGV4KSA8IGJTdGFydENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIGVtaXRUb2tlbihiU3RhcnRDaGFyYWN0ZXIsIGFUb2tlbnMuZ2V0TWV0YWRhdGEoYUluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIGFueSB0b2tlbnMgZnJvbSBgYWAgdGhhdCBhcmUgY29udGFpbmVkIGluc2lkZSBgYmBcbiAgICAgICAgICAgIHdoaWxlIChhSW5kZXggPCBhTGVuICYmIGFUb2tlbnMuZ2V0RW5kT2Zmc2V0KGFJbmRleCkgPCBiRW5kQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgZW1pdFRva2VuKGFUb2tlbnMuZ2V0RW5kT2Zmc2V0KGFJbmRleCksIChhVG9rZW5zLmdldE1ldGFkYXRhKGFJbmRleCkgJiBhTWFzaykgfCAoYk1ldGFkYXRhICYgYk1hc2spKTtcbiAgICAgICAgICAgICAgICBhSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhSW5kZXggPCBhTGVuKSB7XG4gICAgICAgICAgICAgICAgZW1pdFRva2VuKGJFbmRDaGFyYWN0ZXIsIChhVG9rZW5zLmdldE1ldGFkYXRhKGFJbmRleCkgJiBhTWFzaykgfCAoYk1ldGFkYXRhICYgYk1hc2spKTtcbiAgICAgICAgICAgICAgICBpZiAoYVRva2Vucy5nZXRFbmRPZmZzZXQoYUluZGV4KSA9PT0gYkVuZENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBgYWAgZW5kcyBleGFjdGx5IGF0IHRoZSBzYW1lIHNwb3QgYXMgYGJgIVxuICAgICAgICAgICAgICAgICAgICBhSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhTWVyZ2VJbmRleCA9IE1hdGgubWluKE1hdGgubWF4KDAsIGFJbmRleCAtIDEpLCBhTGVuIC0gMSk7XG4gICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgdG9rZW4gZnJvbSBgYmBcbiAgICAgICAgICAgICAgICBlbWl0VG9rZW4oYkVuZENoYXJhY3RlciwgKGFUb2tlbnMuZ2V0TWV0YWRhdGEoYU1lcmdlSW5kZXgpICYgYU1hc2spIHwgKGJNZXRhZGF0YSAmIGJNYXNrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHVzaCB0aGUgcmVtYWluaW5nIHRva2VucyBmcm9tIGBhYFxuICAgICAgICB3aGlsZSAoYUluZGV4IDwgYUxlbikge1xuICAgICAgICAgICAgZW1pdFRva2VuKGFUb2tlbnMuZ2V0RW5kT2Zmc2V0KGFJbmRleCksIGFUb2tlbnMuZ2V0TWV0YWRhdGEoYUluZGV4KSk7XG4gICAgICAgICAgICBhSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVUb2tlbnMobmV3IFVpbnQzMkFycmF5KHJlc3VsdCksIGFUb2tlbnMuZ2V0TGluZUNvbnRlbnQoKSwgdGhpcy5fbGFuZ3VhZ2VJZENvZGVjKTtcbiAgICB9XG4gICAgc3RhdGljIF9maW5kRmlyc3RQaWVjZVdpdGhMaW5lKHBpZWNlcywgbGluZU51bWJlcikge1xuICAgICAgICBsZXQgbG93ID0gMDtcbiAgICAgICAgbGV0IGhpZ2ggPSBwaWVjZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSBsb3cgKyBNYXRoLmZsb29yKChoaWdoIC0gbG93KSAvIDIpO1xuICAgICAgICAgICAgaWYgKHBpZWNlc1ttaWRdLmVuZExpbmVOdW1iZXIgPCBsaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBpZWNlc1ttaWRdLnN0YXJ0TGluZU51bWJlciA+IGxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChtaWQgPiBsb3cgJiYgcGllY2VzW21pZCAtIDFdLnN0YXJ0TGluZU51bWJlciA8PSBsaW5lTnVtYmVyICYmIGxpbmVOdW1iZXIgPD0gcGllY2VzW21pZCAtIDFdLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlkLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvdztcbiAgICB9XG4gICAgYWNjZXB0RWRpdChyYW5nZSwgZW9sQ291bnQsIGZpcnN0TGluZUxlbmd0aCwgbGFzdExpbmVMZW5ndGgsIGZpcnN0Q2hhckNvZGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBwaWVjZSBvZiB0aGlzLl9waWVjZXMpIHtcbiAgICAgICAgICAgIHBpZWNlLmFjY2VwdEVkaXQocmFuZ2UsIGVvbENvdW50LCBmaXJzdExpbmVMZW5ndGgsIGxhc3RMaW5lTGVuZ3RoLCBmaXJzdENoYXJDb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGNsYXNzIFN5bmNEZXNjcmlwdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihjdG9yLCBzdGF0aWNBcmd1bWVudHMgPSBbXSwgc3VwcG9ydHNEZWxheWVkSW5zdGFudGlhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuY3RvciA9IGN0b3I7XG4gICAgICAgIHRoaXMuc3RhdGljQXJndW1lbnRzID0gc3RhdGljQXJndW1lbnRzO1xuICAgICAgICB0aGlzLnN1cHBvcnRzRGVsYXllZEluc3RhbnRpYXRpb24gPSBzdXBwb3J0c0RlbGF5ZWRJbnN0YW50aWF0aW9uO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgU3luY0Rlc2NyaXB0b3IgfSBmcm9tICcuL2Rlc2NyaXB0b3JzLmpzJztcbmNvbnN0IF9yZWdpc3RyeSA9IFtdO1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyU2luZ2xldG9uKGlkLCBjdG9yT3JEZXNjcmlwdG9yLCBzdXBwb3J0c0RlbGF5ZWRJbnN0YW50aWF0aW9uKSB7XG4gICAgaWYgKCEoY3Rvck9yRGVzY3JpcHRvciBpbnN0YW5jZW9mIFN5bmNEZXNjcmlwdG9yKSkge1xuICAgICAgICBjdG9yT3JEZXNjcmlwdG9yID0gbmV3IFN5bmNEZXNjcmlwdG9yKGN0b3JPckRlc2NyaXB0b3IsIFtdLCBCb29sZWFuKHN1cHBvcnRzRGVsYXllZEluc3RhbnRpYXRpb24pKTtcbiAgICB9XG4gICAgX3JlZ2lzdHJ5LnB1c2goW2lkLCBjdG9yT3JEZXNjcmlwdG9yXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U2luZ2xldG9uU2VydmljZURlc2NyaXB0b3JzKCkge1xuICAgIHJldHVybiBfcmVnaXN0cnk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGNyZWF0ZURlY29yYXRvciB9IGZyb20gJy4uLy4uL2luc3RhbnRpYXRpb24vY29tbW9uL2luc3RhbnRpYXRpb24uanMnO1xuZXhwb3J0IGNvbnN0IElVbmRvUmVkb1NlcnZpY2UgPSBjcmVhdGVEZWNvcmF0b3IoJ3VuZG9SZWRvU2VydmljZScpO1xuZXhwb3J0IGNsYXNzIFJlc291cmNlRWRpdFN0YWNrU25hcHNob3Qge1xuICAgIGNvbnN0cnVjdG9yKHJlc291cmNlLCBlbGVtZW50cykge1xuICAgICAgICB0aGlzLnJlc291cmNlID0gcmVzb3VyY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVW5kb1JlZG9Hcm91cCB7XG4gICAgc3RhdGljIHsgdGhpcy5fSUQgPSAwOyB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaWQgPSBVbmRvUmVkb0dyb3VwLl9JRCsrO1xuICAgICAgICB0aGlzLm9yZGVyID0gMTtcbiAgICB9XG4gICAgbmV4dE9yZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5pZCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3JkZXIrKztcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy5Ob25lID0gbmV3IFVuZG9SZWRvR3JvdXAoKTsgfVxufVxuZXhwb3J0IGNsYXNzIFVuZG9SZWRvU291cmNlIHtcbiAgICBzdGF0aWMgeyB0aGlzLl9JRCA9IDA7IH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pZCA9IFVuZG9SZWRvU291cmNlLl9JRCsrO1xuICAgICAgICB0aGlzLm9yZGVyID0gMTtcbiAgICB9XG4gICAgbmV4dE9yZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5pZCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3JkZXIrKztcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy5Ob25lID0gbmV3IFVuZG9SZWRvU291cmNlKCk7IH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==