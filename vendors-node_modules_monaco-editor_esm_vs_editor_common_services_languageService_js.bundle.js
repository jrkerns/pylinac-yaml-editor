"use strict";
(self["webpackChunkpylinac_yaml_editor"] = self["webpackChunkpylinac_yaml_editor"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languageService_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/base/common/equals.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/equals.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   equalsIfDefined: () => (/* binding */ equalsIfDefined),
/* harmony export */   itemEquals: () => (/* binding */ itemEquals),
/* harmony export */   itemsEquals: () => (/* binding */ itemsEquals),
/* harmony export */   strictEquals: () => (/* binding */ strictEquals),
/* harmony export */   structuralEquals: () => (/* binding */ structuralEquals)
/* harmony export */ });
/* harmony import */ var _arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Compares two items for equality using strict equality.
*/
const strictEquals = (a, b) => a === b;
/**
 * Checks if the items of two arrays are equal.
 * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.
 */
function itemsEquals(itemEquals = strictEquals) {
    return (a, b) => _arrays_js__WEBPACK_IMPORTED_MODULE_0__.equals(a, b, itemEquals);
}
/**
 * Uses `item.equals(other)` to determine equality.
 */
function itemEquals() {
    return (a, b) => a.equals(b);
}
function equalsIfDefined(equalsOrV1, v2, equals) {
    if (equals !== undefined) {
        const v1 = equalsOrV1;
        if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {
            return v2 === v1;
        }
        return equals(v1, v2);
    }
    else {
        const equals = equalsOrV1;
        return (v1, v2) => {
            if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {
                return v2 === v1;
            }
            return equals(v1, v2);
        };
    }
}
/**
 * Drills into arrays (items ordered) and objects (keys unordered) and uses strict equality on everything else.
*/
function structuralEquals(a, b) {
    if (a === b) {
        return true;
    }
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!structuralEquals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    if (a && typeof a === 'object' && b && typeof b === 'object') {
        if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {
            const aObj = a;
            const bObj = b;
            const keysA = Object.keys(aObj);
            const keysB = Object.keys(bObj);
            const keysBSet = new Set(keysB);
            if (keysA.length !== keysB.length) {
                return false;
            }
            for (const key of keysA) {
                if (!keysBSet.has(key)) {
                    return false;
                }
                if (!structuralEquals(aObj[key], bObj[key])) {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}
const objIds = new WeakMap();


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observable.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObservablePromise: () => (/* reexport safe */ _observableInternal_promise_js__WEBPACK_IMPORTED_MODULE_4__.ObservablePromise),
/* harmony export */   PromiseResult: () => (/* reexport safe */ _observableInternal_promise_js__WEBPACK_IMPORTED_MODULE_4__.PromiseResult),
/* harmony export */   autorun: () => (/* reexport safe */ _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__.autorun),
/* harmony export */   autorunHandleChanges: () => (/* reexport safe */ _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__.autorunHandleChanges),
/* harmony export */   autorunOpts: () => (/* reexport safe */ _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__.autorunOpts),
/* harmony export */   autorunWithStore: () => (/* reexport safe */ _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__.autorunWithStore),
/* harmony export */   autorunWithStoreHandleChanges: () => (/* reexport safe */ _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__.autorunWithStoreHandleChanges),
/* harmony export */   constObservable: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.constObservable),
/* harmony export */   derived: () => (/* reexport safe */ _observableInternal_derived_js__WEBPACK_IMPORTED_MODULE_1__.derived),
/* harmony export */   derivedHandleChanges: () => (/* reexport safe */ _observableInternal_derived_js__WEBPACK_IMPORTED_MODULE_1__.derivedHandleChanges),
/* harmony export */   derivedObservableWithCache: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.derivedObservableWithCache),
/* harmony export */   derivedObservableWithWritableCache: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.derivedObservableWithWritableCache),
/* harmony export */   derivedOpts: () => (/* reexport safe */ _observableInternal_derived_js__WEBPACK_IMPORTED_MODULE_1__.derivedOpts),
/* harmony export */   derivedWithStore: () => (/* reexport safe */ _observableInternal_derived_js__WEBPACK_IMPORTED_MODULE_1__.derivedWithStore),
/* harmony export */   disposableObservableValue: () => (/* reexport safe */ _observableInternal_base_js__WEBPACK_IMPORTED_MODULE_0__.disposableObservableValue),
/* harmony export */   keepObserved: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.keepObserved),
/* harmony export */   observableFromEvent: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.observableFromEvent),
/* harmony export */   observableSignal: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.observableSignal),
/* harmony export */   observableSignalFromEvent: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.observableSignalFromEvent),
/* harmony export */   observableValue: () => (/* reexport safe */ _observableInternal_base_js__WEBPACK_IMPORTED_MODULE_0__.observableValue),
/* harmony export */   observableValueOpts: () => (/* reexport safe */ _observableInternal_api_js__WEBPACK_IMPORTED_MODULE_5__.observableValueOpts),
/* harmony export */   recomputeInitiallyAndOnChange: () => (/* reexport safe */ _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__.recomputeInitiallyAndOnChange),
/* harmony export */   subtransaction: () => (/* reexport safe */ _observableInternal_base_js__WEBPACK_IMPORTED_MODULE_0__.subtransaction),
/* harmony export */   transaction: () => (/* reexport safe */ _observableInternal_base_js__WEBPACK_IMPORTED_MODULE_0__.transaction),
/* harmony export */   waitForState: () => (/* reexport safe */ _observableInternal_promise_js__WEBPACK_IMPORTED_MODULE_4__.waitForState)
/* harmony export */ });
/* harmony import */ var _observableInternal_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observableInternal/base.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js");
/* harmony import */ var _observableInternal_derived_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observableInternal/derived.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js");
/* harmony import */ var _observableInternal_autorun_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./observableInternal/autorun.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js");
/* harmony import */ var _observableInternal_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observableInternal/utils.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js");
/* harmony import */ var _observableInternal_promise_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./observableInternal/promise.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js");
/* harmony import */ var _observableInternal_api_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./observableInternal/api.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js");
/* harmony import */ var _observableInternal_logging_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./observableInternal/logging.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/







// Remove "//" in the next line to enable logging
const enableLogging = false;
if (enableLogging) {
    (0,_observableInternal_logging_js__WEBPACK_IMPORTED_MODULE_6__.setLogger)(new _observableInternal_logging_js__WEBPACK_IMPORTED_MODULE_6__.ConsoleObservableLogger());
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   observableValueOpts: () => (/* binding */ observableValueOpts)
/* harmony export */ });
/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../equals.js */ "./node_modules/monaco-editor/esm/vs/base/common/equals.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js");
/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debugName.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js");
/* harmony import */ var _lazyObservableValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lazyObservableValue.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




function observableValueOpts(options, initialValue) {
    if (options.lazy) {
        return new _lazyObservableValue_js__WEBPACK_IMPORTED_MODULE_3__.LazyObservableValue(new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? _equals_js__WEBPACK_IMPORTED_MODULE_0__.strictEquals);
    }
    return new _base_js__WEBPACK_IMPORTED_MODULE_1__.ObservableValue(new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? _equals_js__WEBPACK_IMPORTED_MODULE_0__.strictEquals);
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutorunObserver: () => (/* binding */ AutorunObserver),
/* harmony export */   autorun: () => (/* binding */ autorun),
/* harmony export */   autorunHandleChanges: () => (/* binding */ autorunHandleChanges),
/* harmony export */   autorunOpts: () => (/* binding */ autorunOpts),
/* harmony export */   autorunWithStore: () => (/* binding */ autorunWithStore),
/* harmony export */   autorunWithStoreHandleChanges: () => (/* binding */ autorunWithStoreHandleChanges)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assert.js */ "./node_modules/monaco-editor/esm/vs/base/common/assert.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debugName.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js");
/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logging.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




/**
 * Runs immediately and whenever a transaction ends and an observed observable changed.
 * {@link fn} should start with a JS Doc using `@description` to name the autorun.
 */
function autorun(fn) {
    return new AutorunObserver(new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(undefined, undefined, fn), fn, undefined, undefined);
}
/**
 * Runs immediately and whenever a transaction ends and an observed observable changed.
 * {@link fn} should start with a JS Doc using `@description` to name the autorun.
 */
function autorunOpts(options, fn) {
    return new AutorunObserver(new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, undefined, undefined);
}
/**
 * Runs immediately and whenever a transaction ends and an observed observable changed.
 * {@link fn} should start with a JS Doc using `@description` to name the autorun.
 *
 * Use `createEmptyChangeSummary` to create a "change summary" that can collect the changes.
 * Use `handleChange` to add a reported change to the change summary.
 * The run function is given the last change summary.
 * The change summary is discarded after the run function was called.
 *
 * @see autorun
 */
function autorunHandleChanges(options, fn) {
    return new AutorunObserver(new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, options.createEmptyChangeSummary, options.handleChange);
}
/**
 * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)
 */
function autorunWithStoreHandleChanges(options, fn) {
    const store = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore();
    const disposable = autorunHandleChanges({
        owner: options.owner,
        debugName: options.debugName,
        debugReferenceFn: options.debugReferenceFn ?? fn,
        createEmptyChangeSummary: options.createEmptyChangeSummary,
        handleChange: options.handleChange,
    }, (reader, changeSummary) => {
        store.clear();
        fn(reader, changeSummary, store);
    });
    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
        disposable.dispose();
        store.dispose();
    });
}
/**
 * @see autorun (but with a disposable store that is cleared before the next run or on dispose)
 */
function autorunWithStore(fn) {
    const store = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore();
    const disposable = autorunOpts({
        owner: undefined,
        debugName: undefined,
        debugReferenceFn: fn,
    }, reader => {
        store.clear();
        fn(reader, store);
    });
    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
        disposable.dispose();
        store.dispose();
    });
}
class AutorunObserver {
    get debugName() {
        return this._debugNameData.getDebugName(this) ?? '(anonymous)';
    }
    constructor(_debugNameData, _runFn, createChangeSummary, _handleChange) {
        this._debugNameData = _debugNameData;
        this._runFn = _runFn;
        this.createChangeSummary = createChangeSummary;
        this._handleChange = _handleChange;
        this.state = 2 /* AutorunState.stale */;
        this.updateCount = 0;
        this.disposed = false;
        this.dependencies = new Set();
        this.dependenciesToBeRemoved = new Set();
        this.changeSummary = this.createChangeSummary?.();
        (0,_logging_js__WEBPACK_IMPORTED_MODULE_3__.getLogger)()?.handleAutorunCreated(this);
        this._runIfNeeded();
        (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.trackDisposable)(this);
    }
    dispose() {
        this.disposed = true;
        for (const o of this.dependencies) {
            o.removeObserver(this);
        }
        this.dependencies.clear();
        (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.markAsDisposed)(this);
    }
    _runIfNeeded() {
        if (this.state === 3 /* AutorunState.upToDate */) {
            return;
        }
        const emptySet = this.dependenciesToBeRemoved;
        this.dependenciesToBeRemoved = this.dependencies;
        this.dependencies = emptySet;
        this.state = 3 /* AutorunState.upToDate */;
        const isDisposed = this.disposed;
        try {
            if (!isDisposed) {
                (0,_logging_js__WEBPACK_IMPORTED_MODULE_3__.getLogger)()?.handleAutorunTriggered(this);
                const changeSummary = this.changeSummary;
                this.changeSummary = this.createChangeSummary?.();
                this._runFn(this, changeSummary);
            }
        }
        finally {
            if (!isDisposed) {
                (0,_logging_js__WEBPACK_IMPORTED_MODULE_3__.getLogger)()?.handleAutorunFinished(this);
            }
            // We don't want our observed observables to think that they are (not even temporarily) not being observed.
            // Thus, we only unsubscribe from observables that are definitely not read anymore.
            for (const o of this.dependenciesToBeRemoved) {
                o.removeObserver(this);
            }
            this.dependenciesToBeRemoved.clear();
        }
    }
    toString() {
        return `Autorun<${this.debugName}>`;
    }
    // IObserver implementation
    beginUpdate() {
        if (this.state === 3 /* AutorunState.upToDate */) {
            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;
        }
        this.updateCount++;
    }
    endUpdate() {
        if (this.updateCount === 1) {
            do {
                if (this.state === 1 /* AutorunState.dependenciesMightHaveChanged */) {
                    this.state = 3 /* AutorunState.upToDate */;
                    for (const d of this.dependencies) {
                        d.reportChanges();
                        if (this.state === 2 /* AutorunState.stale */) {
                            // The other dependencies will refresh on demand
                            break;
                        }
                    }
                }
                this._runIfNeeded();
            } while (this.state !== 3 /* AutorunState.upToDate */);
        }
        this.updateCount--;
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertFn)(() => this.updateCount >= 0);
    }
    handlePossibleChange(observable) {
        if (this.state === 3 /* AutorunState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {
            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;
        }
    }
    handleChange(observable, change) {
        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {
            const shouldReact = this._handleChange ? this._handleChange({
                changedObservable: observable,
                change,
                didChange: (o) => o === observable,
            }, this.changeSummary) : true;
            if (shouldReact) {
                this.state = 2 /* AutorunState.stale */;
            }
        }
    }
    // IReader implementation
    readObservable(observable) {
        // In case the run action disposes the autorun
        if (this.disposed) {
            return observable.get();
        }
        observable.addObserver(this);
        const value = observable.get();
        this.dependencies.add(observable);
        this.dependenciesToBeRemoved.delete(observable);
        return value;
    }
}
(function (autorun) {
    autorun.Observer = AutorunObserver;
})(autorun || (autorun = {}));


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseObservable: () => (/* binding */ BaseObservable),
/* harmony export */   ConvenientObservable: () => (/* binding */ ConvenientObservable),
/* harmony export */   DisposableObservableValue: () => (/* binding */ DisposableObservableValue),
/* harmony export */   ObservableValue: () => (/* binding */ ObservableValue),
/* harmony export */   TransactionImpl: () => (/* binding */ TransactionImpl),
/* harmony export */   _setDerivedOpts: () => (/* binding */ _setDerivedOpts),
/* harmony export */   _setKeepObserved: () => (/* binding */ _setKeepObserved),
/* harmony export */   _setRecomputeInitiallyAndOnChange: () => (/* binding */ _setRecomputeInitiallyAndOnChange),
/* harmony export */   asyncTransaction: () => (/* binding */ asyncTransaction),
/* harmony export */   disposableObservableValue: () => (/* binding */ disposableObservableValue),
/* harmony export */   globalTransaction: () => (/* binding */ globalTransaction),
/* harmony export */   observableValue: () => (/* binding */ observableValue),
/* harmony export */   subtransaction: () => (/* binding */ subtransaction),
/* harmony export */   transaction: () => (/* binding */ transaction)
/* harmony export */ });
/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../equals.js */ "./node_modules/monaco-editor/esm/vs/base/common/equals.js");
/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debugName.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js");
/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



let _recomputeInitiallyAndOnChange;
function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {
    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;
}
let _keepObserved;
function _setKeepObserved(keepObserved) {
    _keepObserved = keepObserved;
}
let _derived;
/**
 * @internal
 * This is to allow splitting files.
*/
function _setDerivedOpts(derived) {
    _derived = derived;
}
class ConvenientObservable {
    get TChange() { return null; }
    reportChanges() {
        this.get();
    }
    /** @sealed */
    read(reader) {
        if (reader) {
            return reader.readObservable(this);
        }
        else {
            return this.get();
        }
    }
    map(fnOrOwner, fnOrUndefined) {
        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;
        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;
        return _derived({
            owner,
            debugName: () => {
                const name = (0,_debugName_js__WEBPACK_IMPORTED_MODULE_1__.getFunctionName)(fn);
                if (name !== undefined) {
                    return name;
                }
                // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):
                const regexp = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/;
                const match = regexp.exec(fn.toString());
                if (match) {
                    return `${this.debugName}.${match[2]}`;
                }
                if (!owner) {
                    return `${this.debugName} (mapped)`;
                }
                return undefined;
            },
            debugReferenceFn: fn,
        }, (reader) => fn(this.read(reader), reader));
    }
    /**
     * @sealed
     * Converts an observable of an observable value into a direct observable of the value.
    */
    flatten() {
        return _derived({
            owner: undefined,
            debugName: () => `${this.debugName} (flattened)`,
        }, (reader) => this.read(reader).read(reader));
    }
    recomputeInitiallyAndOnChange(store, handleValue) {
        store.add(_recomputeInitiallyAndOnChange(this, handleValue));
        return this;
    }
    /**
     * Ensures that this observable is observed. This keeps the cache alive.
     * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).
     * Use `recomputeInitiallyAndOnChange` for eager evaluation.
     */
    keepObserved(store) {
        store.add(_keepObserved(this));
        return this;
    }
}
class BaseObservable extends ConvenientObservable {
    constructor() {
        super(...arguments);
        this.observers = new Set();
    }
    addObserver(observer) {
        const len = this.observers.size;
        this.observers.add(observer);
        if (len === 0) {
            this.onFirstObserverAdded();
        }
    }
    removeObserver(observer) {
        const deleted = this.observers.delete(observer);
        if (deleted && this.observers.size === 0) {
            this.onLastObserverRemoved();
        }
    }
    onFirstObserverAdded() { }
    onLastObserverRemoved() { }
}
/**
 * Starts a transaction in which many observables can be changed at once.
 * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.
 * Reaction run on demand or when the transaction ends.
 */
function transaction(fn, getDebugName) {
    const tx = new TransactionImpl(fn, getDebugName);
    try {
        fn(tx);
    }
    finally {
        tx.finish();
    }
}
let _globalTransaction = undefined;
function globalTransaction(fn) {
    if (_globalTransaction) {
        fn(_globalTransaction);
    }
    else {
        const tx = new TransactionImpl(fn, undefined);
        _globalTransaction = tx;
        try {
            fn(tx);
        }
        finally {
            tx.finish(); // During finish, more actions might be added to the transaction.
            // Which is why we only clear the global transaction after finish.
            _globalTransaction = undefined;
        }
    }
}
async function asyncTransaction(fn, getDebugName) {
    const tx = new TransactionImpl(fn, getDebugName);
    try {
        await fn(tx);
    }
    finally {
        tx.finish();
    }
}
/**
 * Allows to chain transactions.
 */
function subtransaction(tx, fn, getDebugName) {
    if (!tx) {
        transaction(fn, getDebugName);
    }
    else {
        fn(tx);
    }
}
class TransactionImpl {
    constructor(_fn, _getDebugName) {
        this._fn = _fn;
        this._getDebugName = _getDebugName;
        this.updatingObservers = [];
        (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.getLogger)()?.handleBeginTransaction(this);
    }
    getDebugName() {
        if (this._getDebugName) {
            return this._getDebugName();
        }
        return (0,_debugName_js__WEBPACK_IMPORTED_MODULE_1__.getFunctionName)(this._fn);
    }
    updateObserver(observer, observable) {
        // When this gets called while finish is active, they will still get considered
        this.updatingObservers.push({ observer, observable });
        observer.beginUpdate(observable);
    }
    finish() {
        const updatingObservers = this.updatingObservers;
        for (let i = 0; i < updatingObservers.length; i++) {
            const { observer, observable } = updatingObservers[i];
            observer.endUpdate(observable);
        }
        // Prevent anyone from updating observers from now on.
        this.updatingObservers = null;
        (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.getLogger)()?.handleEndTransaction();
    }
}
function observableValue(nameOrOwner, initialValue) {
    let debugNameData;
    if (typeof nameOrOwner === 'string') {
        debugNameData = new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(undefined, nameOrOwner, undefined);
    }
    else {
        debugNameData = new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(nameOrOwner, undefined, undefined);
    }
    return new ObservableValue(debugNameData, initialValue, _equals_js__WEBPACK_IMPORTED_MODULE_0__.strictEquals);
}
class ObservableValue extends BaseObservable {
    get debugName() {
        return this._debugNameData.getDebugName(this) ?? 'ObservableValue';
    }
    constructor(_debugNameData, initialValue, _equalityComparator) {
        super();
        this._debugNameData = _debugNameData;
        this._equalityComparator = _equalityComparator;
        this._value = initialValue;
    }
    get() {
        return this._value;
    }
    set(value, tx, change) {
        if (change === undefined && this._equalityComparator(this._value, value)) {
            return;
        }
        let _tx;
        if (!tx) {
            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);
        }
        try {
            const oldValue = this._value;
            this._setValue(value);
            (0,_logging_js__WEBPACK_IMPORTED_MODULE_2__.getLogger)()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });
            for (const observer of this.observers) {
                tx.updateObserver(observer, this);
                observer.handleChange(this, change);
            }
        }
        finally {
            if (_tx) {
                _tx.finish();
            }
        }
    }
    toString() {
        return `${this.debugName}: ${this._value}`;
    }
    _setValue(newValue) {
        this._value = newValue;
    }
}
/**
 * A disposable observable. When disposed, its value is also disposed.
 * When a new value is set, the previous value is disposed.
 */
function disposableObservableValue(nameOrOwner, initialValue) {
    let debugNameData;
    if (typeof nameOrOwner === 'string') {
        debugNameData = new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(undefined, nameOrOwner, undefined);
    }
    else {
        debugNameData = new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(nameOrOwner, undefined, undefined);
    }
    return new DisposableObservableValue(debugNameData, initialValue, _equals_js__WEBPACK_IMPORTED_MODULE_0__.strictEquals);
}
class DisposableObservableValue extends ObservableValue {
    _setValue(newValue) {
        if (this._value === newValue) {
            return;
        }
        if (this._value) {
            this._value.dispose();
        }
        this._value = newValue;
    }
    dispose() {
        this._value?.dispose();
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DebugNameData: () => (/* binding */ DebugNameData),
/* harmony export */   getDebugName: () => (/* binding */ getDebugName),
/* harmony export */   getFunctionName: () => (/* binding */ getFunctionName)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class DebugNameData {
    constructor(owner, debugNameSource, referenceFn) {
        this.owner = owner;
        this.debugNameSource = debugNameSource;
        this.referenceFn = referenceFn;
    }
    getDebugName(target) {
        return getDebugName(target, this);
    }
}
const countPerName = new Map();
const cachedDebugName = new WeakMap();
function getDebugName(target, data) {
    const cached = cachedDebugName.get(target);
    if (cached) {
        return cached;
    }
    const dbgName = computeDebugName(target, data);
    if (dbgName) {
        let count = countPerName.get(dbgName) ?? 0;
        count++;
        countPerName.set(dbgName, count);
        const result = count === 1 ? dbgName : `${dbgName}#${count}`;
        cachedDebugName.set(target, result);
        return result;
    }
    return undefined;
}
function computeDebugName(self, data) {
    const cached = cachedDebugName.get(self);
    if (cached) {
        return cached;
    }
    const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';
    let result;
    const debugNameSource = data.debugNameSource;
    if (debugNameSource !== undefined) {
        if (typeof debugNameSource === 'function') {
            result = debugNameSource();
            if (result !== undefined) {
                return ownerStr + result;
            }
        }
        else {
            return ownerStr + debugNameSource;
        }
    }
    const referenceFn = data.referenceFn;
    if (referenceFn !== undefined) {
        result = getFunctionName(referenceFn);
        if (result !== undefined) {
            return ownerStr + result;
        }
    }
    if (data.owner !== undefined) {
        const key = findKey(data.owner, self);
        if (key !== undefined) {
            return ownerStr + key;
        }
    }
    return undefined;
}
function findKey(obj, value) {
    for (const key in obj) {
        if (obj[key] === value) {
            return key;
        }
    }
    return undefined;
}
const countPerClassName = new Map();
const ownerId = new WeakMap();
function formatOwner(owner) {
    const id = ownerId.get(owner);
    if (id) {
        return id;
    }
    const className = getClassName(owner);
    let count = countPerClassName.get(className) ?? 0;
    count++;
    countPerClassName.set(className, count);
    const result = count === 1 ? className : `${className}#${count}`;
    ownerId.set(owner, result);
    return result;
}
function getClassName(obj) {
    const ctor = obj.constructor;
    if (ctor) {
        return ctor.name;
    }
    return 'Object';
}
function getFunctionName(fn) {
    const fnSrc = fn.toString();
    // Pattern: /** @description ... */
    const regexp = /\/\*\*\s*@description\s*([^*]*)\*\//;
    const match = regexp.exec(fnSrc);
    const result = match ? match[1] : undefined;
    return result?.trim();
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Derived: () => (/* binding */ Derived),
/* harmony export */   DerivedWithSetter: () => (/* binding */ DerivedWithSetter),
/* harmony export */   derived: () => (/* binding */ derived),
/* harmony export */   derivedDisposable: () => (/* binding */ derivedDisposable),
/* harmony export */   derivedHandleChanges: () => (/* binding */ derivedHandleChanges),
/* harmony export */   derivedOpts: () => (/* binding */ derivedOpts),
/* harmony export */   derivedWithSetter: () => (/* binding */ derivedWithSetter),
/* harmony export */   derivedWithStore: () => (/* binding */ derivedWithStore)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assert.js */ "./node_modules/monaco-editor/esm/vs/base/common/assert.js");
/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../equals.js */ "./node_modules/monaco-editor/esm/vs/base/common/equals.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js");
/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./debugName.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js");
/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./logging.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






function derived(computeFnOrOwner, computeFn) {
    if (computeFn !== undefined) {
        return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, undefined, _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);
    }
    return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(undefined, undefined, computeFnOrOwner), computeFnOrOwner, undefined, undefined, undefined, _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);
}
function derivedWithSetter(owner, computeFn, setter) {
    return new DerivedWithSetter(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(owner, undefined, computeFn), computeFn, undefined, undefined, undefined, _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals, setter);
}
function derivedOpts(options, computeFn) {
    return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, undefined, options.onLastObserverRemoved, options.equalsFn ?? _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);
}
(0,_base_js__WEBPACK_IMPORTED_MODULE_3__._setDerivedOpts)(derivedOpts);
/**
 * Represents an observable that is derived from other observables.
 * The value is only recomputed when absolutely needed.
 *
 * {@link computeFn} should start with a JS Doc using `@description` to name the derived.
 *
 * Use `createEmptyChangeSummary` to create a "change summary" that can collect the changes.
 * Use `handleChange` to add a reported change to the change summary.
 * The compute function is given the last change summary.
 * The change summary is discarded after the compute function was called.
 *
 * @see derived
 */
function derivedHandleChanges(options, computeFn) {
    return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(options.owner, options.debugName, undefined), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, options.equalityComparer ?? _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);
}
function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {
    let computeFn;
    let owner;
    if (computeFnOrUndefined === undefined) {
        computeFn = computeFnOrOwner;
        owner = undefined;
    }
    else {
        owner = computeFnOrOwner;
        computeFn = computeFnOrUndefined;
    }
    const store = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStore();
    return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(owner, undefined, computeFn), r => {
        store.clear();
        return computeFn(r, store);
    }, undefined, undefined, () => store.dispose(), _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);
}
function derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {
    let computeFn;
    let owner;
    if (computeFnOrUndefined === undefined) {
        computeFn = computeFnOrOwner;
        owner = undefined;
    }
    else {
        owner = computeFnOrOwner;
        computeFn = computeFnOrUndefined;
    }
    let store = undefined;
    return new Derived(new _debugName_js__WEBPACK_IMPORTED_MODULE_4__.DebugNameData(owner, undefined, computeFn), r => {
        if (!store) {
            store = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStore();
        }
        else {
            store.clear();
        }
        const result = computeFn(r);
        if (result) {
            store.add(result);
        }
        return result;
    }, undefined, undefined, () => {
        if (store) {
            store.dispose();
            store = undefined;
        }
    }, _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals);
}
class Derived extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseObservable {
    get debugName() {
        return this._debugNameData.getDebugName(this) ?? '(anonymous)';
    }
    constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {
        super();
        this._debugNameData = _debugNameData;
        this._computeFn = _computeFn;
        this.createChangeSummary = createChangeSummary;
        this._handleChange = _handleChange;
        this._handleLastObserverRemoved = _handleLastObserverRemoved;
        this._equalityComparator = _equalityComparator;
        this.state = 0 /* DerivedState.initial */;
        this.value = undefined;
        this.updateCount = 0;
        this.dependencies = new Set();
        this.dependenciesToBeRemoved = new Set();
        this.changeSummary = undefined;
        this.changeSummary = this.createChangeSummary?.();
        (0,_logging_js__WEBPACK_IMPORTED_MODULE_5__.getLogger)()?.handleDerivedCreated(this);
    }
    onLastObserverRemoved() {
        /**
         * We are not tracking changes anymore, thus we have to assume
         * that our cache is invalid.
         */
        this.state = 0 /* DerivedState.initial */;
        this.value = undefined;
        for (const d of this.dependencies) {
            d.removeObserver(this);
        }
        this.dependencies.clear();
        this._handleLastObserverRemoved?.();
    }
    get() {
        if (this.observers.size === 0) {
            // Without observers, we don't know when to clean up stuff.
            // Thus, we don't cache anything to prevent memory leaks.
            const result = this._computeFn(this, this.createChangeSummary?.());
            // Clear new dependencies
            this.onLastObserverRemoved();
            return result;
        }
        else {
            do {
                // We might not get a notification for a dependency that changed while it is updating,
                // thus we also have to ask all our depedencies if they changed in this case.
                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {
                    for (const d of this.dependencies) {
                        /** might call {@link handleChange} indirectly, which could make us stale */
                        d.reportChanges();
                        if (this.state === 2 /* DerivedState.stale */) {
                            // The other dependencies will refresh on demand, so early break
                            break;
                        }
                    }
                }
                // We called report changes of all dependencies.
                // If we are still not stale, we can assume to be up to date again.
                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {
                    this.state = 3 /* DerivedState.upToDate */;
                }
                this._recomputeIfNeeded();
                // In case recomputation changed one of our dependencies, we need to recompute again.
            } while (this.state !== 3 /* DerivedState.upToDate */);
            return this.value;
        }
    }
    _recomputeIfNeeded() {
        if (this.state === 3 /* DerivedState.upToDate */) {
            return;
        }
        const emptySet = this.dependenciesToBeRemoved;
        this.dependenciesToBeRemoved = this.dependencies;
        this.dependencies = emptySet;
        const hadValue = this.state !== 0 /* DerivedState.initial */;
        const oldValue = this.value;
        this.state = 3 /* DerivedState.upToDate */;
        const changeSummary = this.changeSummary;
        this.changeSummary = this.createChangeSummary?.();
        try {
            /** might call {@link handleChange} indirectly, which could invalidate us */
            this.value = this._computeFn(this, changeSummary);
        }
        finally {
            // We don't want our observed observables to think that they are (not even temporarily) not being observed.
            // Thus, we only unsubscribe from observables that are definitely not read anymore.
            for (const o of this.dependenciesToBeRemoved) {
                o.removeObserver(this);
            }
            this.dependenciesToBeRemoved.clear();
        }
        const didChange = hadValue && !(this._equalityComparator(oldValue, this.value));
        (0,_logging_js__WEBPACK_IMPORTED_MODULE_5__.getLogger)()?.handleDerivedRecomputed(this, {
            oldValue,
            newValue: this.value,
            change: undefined,
            didChange,
            hadValue,
        });
        if (didChange) {
            for (const r of this.observers) {
                r.handleChange(this, undefined);
            }
        }
    }
    toString() {
        return `LazyDerived<${this.debugName}>`;
    }
    // IObserver Implementation
    beginUpdate(_observable) {
        this.updateCount++;
        const propagateBeginUpdate = this.updateCount === 1;
        if (this.state === 3 /* DerivedState.upToDate */) {
            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;
            // If we propagate begin update, that will already signal a possible change.
            if (!propagateBeginUpdate) {
                for (const r of this.observers) {
                    r.handlePossibleChange(this);
                }
            }
        }
        if (propagateBeginUpdate) {
            for (const r of this.observers) {
                r.beginUpdate(this); // This signals a possible change
            }
        }
    }
    endUpdate(_observable) {
        this.updateCount--;
        if (this.updateCount === 0) {
            // End update could change the observer list.
            const observers = [...this.observers];
            for (const r of observers) {
                r.endUpdate(this);
            }
        }
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertFn)(() => this.updateCount >= 0);
    }
    handlePossibleChange(observable) {
        // In all other states, observers already know that we might have changed.
        if (this.state === 3 /* DerivedState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {
            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;
            for (const r of this.observers) {
                r.handlePossibleChange(this);
            }
        }
    }
    handleChange(observable, change) {
        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {
            const shouldReact = this._handleChange ? this._handleChange({
                changedObservable: observable,
                change,
                didChange: (o) => o === observable,
            }, this.changeSummary) : true;
            const wasUpToDate = this.state === 3 /* DerivedState.upToDate */;
            if (shouldReact && (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {
                this.state = 2 /* DerivedState.stale */;
                if (wasUpToDate) {
                    for (const r of this.observers) {
                        r.handlePossibleChange(this);
                    }
                }
            }
        }
    }
    // IReader Implementation
    readObservable(observable) {
        // Subscribe before getting the value to enable caching
        observable.addObserver(this);
        /** This might call {@link handleChange} indirectly, which could invalidate us */
        const value = observable.get();
        // Which is why we only add the observable to the dependencies now.
        this.dependencies.add(observable);
        this.dependenciesToBeRemoved.delete(observable);
        return value;
    }
    addObserver(observer) {
        const shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;
        super.addObserver(observer);
        if (shouldCallBeginUpdate) {
            observer.beginUpdate(this);
        }
    }
    removeObserver(observer) {
        const shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;
        super.removeObserver(observer);
        if (shouldCallEndUpdate) {
            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.
            observer.endUpdate(this);
        }
    }
}
class DerivedWithSetter extends Derived {
    constructor(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved = undefined, equalityComparator, set) {
        super(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved, equalityComparator);
        this.set = set;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LazyObservableValue: () => (/* binding */ LazyObservableValue)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Holds off updating observers until the value is actually read.
*/
class LazyObservableValue extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseObservable {
    get debugName() {
        return this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';
    }
    constructor(_debugNameData, initialValue, _equalityComparator) {
        super();
        this._debugNameData = _debugNameData;
        this._equalityComparator = _equalityComparator;
        this._isUpToDate = true;
        this._deltas = [];
        this._updateCounter = 0;
        this._value = initialValue;
    }
    get() {
        this._update();
        return this._value;
    }
    _update() {
        if (this._isUpToDate) {
            return;
        }
        this._isUpToDate = true;
        if (this._deltas.length > 0) {
            for (const observer of this.observers) {
                for (const change of this._deltas) {
                    observer.handleChange(this, change);
                }
            }
            this._deltas.length = 0;
        }
        else {
            for (const observer of this.observers) {
                observer.handleChange(this, undefined);
            }
        }
    }
    _beginUpdate() {
        this._updateCounter++;
        if (this._updateCounter === 1) {
            for (const observer of this.observers) {
                observer.beginUpdate(this);
            }
        }
    }
    _endUpdate() {
        this._updateCounter--;
        if (this._updateCounter === 0) {
            this._update();
            // End update could change the observer list.
            const observers = [...this.observers];
            for (const r of observers) {
                r.endUpdate(this);
            }
        }
    }
    addObserver(observer) {
        const shouldCallBeginUpdate = !this.observers.has(observer) && this._updateCounter > 0;
        super.addObserver(observer);
        if (shouldCallBeginUpdate) {
            observer.beginUpdate(this);
        }
    }
    removeObserver(observer) {
        const shouldCallEndUpdate = this.observers.has(observer) && this._updateCounter > 0;
        super.removeObserver(observer);
        if (shouldCallEndUpdate) {
            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.
            observer.endUpdate(this);
        }
    }
    set(value, tx, change) {
        if (change === undefined && this._equalityComparator(this._value, value)) {
            return;
        }
        let _tx;
        if (!tx) {
            tx = _tx = new _base_js__WEBPACK_IMPORTED_MODULE_0__.TransactionImpl(() => { }, () => `Setting ${this.debugName}`);
        }
        try {
            this._isUpToDate = false;
            this._setValue(value);
            if (change !== undefined) {
                this._deltas.push(change);
            }
            tx.updateObserver({
                beginUpdate: () => this._beginUpdate(),
                endUpdate: () => this._endUpdate(),
                handleChange: (observable, change) => { },
                handlePossibleChange: (observable) => { },
            }, this);
            if (this._updateCounter > 1) {
                // We already started begin/end update, so we need to manually call handlePossibleChange
                for (const observer of this.observers) {
                    observer.handlePossibleChange(this);
                }
            }
        }
        finally {
            if (_tx) {
                _tx.finish();
            }
        }
    }
    toString() {
        return `${this.debugName}: ${this._value}`;
    }
    _setValue(newValue) {
        this._value = newValue;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConsoleObservableLogger: () => (/* binding */ ConsoleObservableLogger),
/* harmony export */   getLogger: () => (/* binding */ getLogger),
/* harmony export */   setLogger: () => (/* binding */ setLogger)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
let globalObservableLogger;
function setLogger(logger) {
    globalObservableLogger = logger;
}
function getLogger() {
    return globalObservableLogger;
}
class ConsoleObservableLogger {
    constructor() {
        this.indentation = 0;
        this.changedObservablesSets = new WeakMap();
    }
    textToConsoleArgs(text) {
        return consoleTextToArgs([
            normalText(repeat('|  ', this.indentation)),
            text,
        ]);
    }
    formatInfo(info) {
        if (!info.hadValue) {
            return [
                normalText(` `),
                styled(formatValue(info.newValue, 60), {
                    color: 'green',
                }),
                normalText(` (initial)`),
            ];
        }
        return info.didChange
            ? [
                normalText(` `),
                styled(formatValue(info.oldValue, 70), {
                    color: 'red',
                    strikeThrough: true,
                }),
                normalText(` `),
                styled(formatValue(info.newValue, 60), {
                    color: 'green',
                }),
            ]
            : [normalText(` (unchanged)`)];
    }
    handleObservableChanged(observable, info) {
        console.log(...this.textToConsoleArgs([
            formatKind('observable value changed'),
            styled(observable.debugName, { color: 'BlueViolet' }),
            ...this.formatInfo(info),
        ]));
    }
    formatChanges(changes) {
        if (changes.size === 0) {
            return undefined;
        }
        return styled(' (changed deps: ' +
            [...changes].map((o) => o.debugName).join(', ') +
            ')', { color: 'gray' });
    }
    handleDerivedCreated(derived) {
        const existingHandleChange = derived.handleChange;
        this.changedObservablesSets.set(derived, new Set());
        derived.handleChange = (observable, change) => {
            this.changedObservablesSets.get(derived).add(observable);
            return existingHandleChange.apply(derived, [observable, change]);
        };
    }
    handleDerivedRecomputed(derived, info) {
        const changedObservables = this.changedObservablesSets.get(derived);
        console.log(...this.textToConsoleArgs([
            formatKind('derived recomputed'),
            styled(derived.debugName, { color: 'BlueViolet' }),
            ...this.formatInfo(info),
            this.formatChanges(changedObservables),
            { data: [{ fn: derived._debugNameData.referenceFn ?? derived._computeFn }] }
        ]));
        changedObservables.clear();
    }
    handleFromEventObservableTriggered(observable, info) {
        console.log(...this.textToConsoleArgs([
            formatKind('observable from event triggered'),
            styled(observable.debugName, { color: 'BlueViolet' }),
            ...this.formatInfo(info),
            { data: [{ fn: observable._getValue }] }
        ]));
    }
    handleAutorunCreated(autorun) {
        const existingHandleChange = autorun.handleChange;
        this.changedObservablesSets.set(autorun, new Set());
        autorun.handleChange = (observable, change) => {
            this.changedObservablesSets.get(autorun).add(observable);
            return existingHandleChange.apply(autorun, [observable, change]);
        };
    }
    handleAutorunTriggered(autorun) {
        const changedObservables = this.changedObservablesSets.get(autorun);
        console.log(...this.textToConsoleArgs([
            formatKind('autorun'),
            styled(autorun.debugName, { color: 'BlueViolet' }),
            this.formatChanges(changedObservables),
            { data: [{ fn: autorun._debugNameData.referenceFn ?? autorun._runFn }] }
        ]));
        changedObservables.clear();
        this.indentation++;
    }
    handleAutorunFinished(autorun) {
        this.indentation--;
    }
    handleBeginTransaction(transaction) {
        let transactionName = transaction.getDebugName();
        if (transactionName === undefined) {
            transactionName = '';
        }
        console.log(...this.textToConsoleArgs([
            formatKind('transaction'),
            styled(transactionName, { color: 'BlueViolet' }),
            { data: [{ fn: transaction._fn }] }
        ]));
        this.indentation++;
    }
    handleEndTransaction() {
        this.indentation--;
    }
}
function consoleTextToArgs(text) {
    const styles = new Array();
    const data = [];
    let firstArg = '';
    function process(t) {
        if ('length' in t) {
            for (const item of t) {
                if (item) {
                    process(item);
                }
            }
        }
        else if ('text' in t) {
            firstArg += `%c${t.text}`;
            styles.push(t.style);
            if (t.data) {
                data.push(...t.data);
            }
        }
        else if ('data' in t) {
            data.push(...t.data);
        }
    }
    process(text);
    const result = [firstArg, ...styles];
    result.push(...data);
    return result;
}
function normalText(text) {
    return styled(text, { color: 'black' });
}
function formatKind(kind) {
    return styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });
}
function styled(text, options = {
    color: 'black',
}) {
    function objToCss(styleObj) {
        return Object.entries(styleObj).reduce((styleString, [propName, propValue]) => {
            return `${styleString}${propName}:${propValue};`;
        }, '');
    }
    const style = {
        color: options.color,
    };
    if (options.strikeThrough) {
        style['text-decoration'] = 'line-through';
    }
    if (options.bold) {
        style['font-weight'] = 'bold';
    }
    return {
        text,
        style: objToCss(style),
    };
}
function formatValue(value, availableLen) {
    switch (typeof value) {
        case 'number':
            return '' + value;
        case 'string':
            if (value.length + 2 <= availableLen) {
                return `"${value}"`;
            }
            return `"${value.substr(0, availableLen - 7)}"+...`;
        case 'boolean':
            return value ? 'true' : 'false';
        case 'undefined':
            return 'undefined';
        case 'object':
            if (value === null) {
                return 'null';
            }
            if (Array.isArray(value)) {
                return formatArray(value, availableLen);
            }
            return formatObject(value, availableLen);
        case 'symbol':
            return value.toString();
        case 'function':
            return `[[Function${value.name ? ' ' + value.name : ''}]]`;
        default:
            return '' + value;
    }
}
function formatArray(value, availableLen) {
    let result = '[ ';
    let first = true;
    for (const val of value) {
        if (!first) {
            result += ', ';
        }
        if (result.length - 5 > availableLen) {
            result += '...';
            break;
        }
        first = false;
        result += `${formatValue(val, availableLen - result.length)}`;
    }
    result += ' ]';
    return result;
}
function formatObject(value, availableLen) {
    let result = '{ ';
    let first = true;
    for (const [key, val] of Object.entries(value)) {
        if (!first) {
            result += ', ';
        }
        if (result.length - 5 > availableLen) {
            result += '...';
            break;
        }
        first = false;
        result += `${key}: ${formatValue(val, availableLen - result.length)}`;
    }
    result += ' }';
    return result;
}
function repeat(str, count) {
    let result = '';
    for (let i = 1; i <= count; i++) {
        result += str;
    }
    return result;
}
function padStr(str, length) {
    while (str.length < length) {
        str += ' ';
    }
    return str;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObservablePromise: () => (/* binding */ ObservablePromise),
/* harmony export */   PromiseResult: () => (/* binding */ PromiseResult),
/* harmony export */   waitForState: () => (/* binding */ waitForState)
/* harmony export */ });
/* harmony import */ var _autorun_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./autorun.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js");
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



/**
 * A promise whose state is observable.
 */
class ObservablePromise {
    static fromFn(fn) {
        return new ObservablePromise(fn());
    }
    constructor(promise) {
        this._value = (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.observableValue)(this, undefined);
        /**
         * The current state of the promise.
         * Is `undefined` if the promise didn't resolve yet.
         */
        this.promiseResult = this._value;
        this.promise = promise.then(value => {
            (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.transaction)(tx => {
                /** @description onPromiseResolved */
                this._value.set(new PromiseResult(value, undefined), tx);
            });
            return value;
        }, error => {
            (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.transaction)(tx => {
                /** @description onPromiseRejected */
                this._value.set(new PromiseResult(undefined, error), tx);
            });
            throw error;
        });
    }
}
class PromiseResult {
    constructor(
    /**
     * The value of the resolved promise.
     * Undefined if the promise rejected.
     */
    data, 
    /**
     * The error in case of a rejected promise.
     * Undefined if the promise resolved.
     */
    error) {
        this.data = data;
        this.error = error;
    }
}
function waitForState(observable, predicate, isError, cancellationToken) {
    if (!predicate) {
        predicate = state => state !== null && state !== undefined;
    }
    return new Promise((resolve, reject) => {
        let isImmediateRun = true;
        let shouldDispose = false;
        const stateObs = observable.map(state => {
            /** @description waitForState.state */
            return {
                isFinished: predicate(state),
                error: isError ? isError(state) : false,
                state
            };
        });
        const d = (0,_autorun_js__WEBPACK_IMPORTED_MODULE_0__.autorun)(reader => {
            /** @description waitForState */
            const { isFinished, error, state } = stateObs.read(reader);
            if (isFinished || error) {
                if (isImmediateRun) {
                    // The variable `d` is not initialized yet
                    shouldDispose = true;
                }
                else {
                    d.dispose();
                }
                if (error) {
                    reject(error === true ? state : error);
                }
                else {
                    resolve(state);
                }
            }
        });
        if (cancellationToken) {
            const dc = cancellationToken.onCancellationRequested(() => {
                d.dispose();
                dc.dispose();
                reject(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.CancellationError());
            });
            if (cancellationToken.isCancellationRequested) {
                d.dispose();
                dc.dispose();
                reject(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.CancellationError());
                return;
            }
        }
        isImmediateRun = false;
        if (shouldDispose) {
            d.dispose();
        }
    });
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FromEventObservable: () => (/* binding */ FromEventObservable),
/* harmony export */   KeepAliveObserver: () => (/* binding */ KeepAliveObserver),
/* harmony export */   ValueWithChangeEventFromObservable: () => (/* binding */ ValueWithChangeEventFromObservable),
/* harmony export */   constObservable: () => (/* binding */ constObservable),
/* harmony export */   derivedConstOnceDefined: () => (/* binding */ derivedConstOnceDefined),
/* harmony export */   derivedObservableWithCache: () => (/* binding */ derivedObservableWithCache),
/* harmony export */   derivedObservableWithWritableCache: () => (/* binding */ derivedObservableWithWritableCache),
/* harmony export */   keepObserved: () => (/* binding */ keepObserved),
/* harmony export */   mapObservableArrayCached: () => (/* binding */ mapObservableArrayCached),
/* harmony export */   observableFromEvent: () => (/* binding */ observableFromEvent),
/* harmony export */   observableFromEventOpts: () => (/* binding */ observableFromEventOpts),
/* harmony export */   observableFromValueWithChangeEvent: () => (/* binding */ observableFromValueWithChangeEvent),
/* harmony export */   observableSignal: () => (/* binding */ observableSignal),
/* harmony export */   observableSignalFromEvent: () => (/* binding */ observableSignalFromEvent),
/* harmony export */   recomputeInitiallyAndOnChange: () => (/* binding */ recomputeInitiallyAndOnChange)
/* harmony export */ });
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js");
/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./debugName.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js");
/* harmony import */ var _derived_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./derived.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js");
/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./logging.js */ "./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js");
/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../equals.js */ "./node_modules/monaco-editor/esm/vs/base/common/equals.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/







/**
 * Represents an efficient observable whose value never changes.
 */
function constObservable(value) {
    return new ConstObservable(value);
}
class ConstObservable extends _base_js__WEBPACK_IMPORTED_MODULE_2__.ConvenientObservable {
    constructor(value) {
        super();
        this.value = value;
    }
    get debugName() {
        return this.toString();
    }
    get() {
        return this.value;
    }
    addObserver(observer) {
        // NO OP
    }
    removeObserver(observer) {
        // NO OP
    }
    toString() {
        return `Const: ${this.value}`;
    }
}
function observableFromEvent(...args) {
    let owner;
    let event;
    let getValue;
    if (args.length === 3) {
        [owner, event, getValue] = args;
    }
    else {
        [event, getValue] = args;
    }
    return new FromEventObservable(new _debugName_js__WEBPACK_IMPORTED_MODULE_3__.DebugNameData(owner, undefined, getValue), event, getValue, () => FromEventObservable.globalTransaction, _equals_js__WEBPACK_IMPORTED_MODULE_6__.strictEquals);
}
function observableFromEventOpts(options, event, getValue) {
    return new FromEventObservable(new _debugName_js__WEBPACK_IMPORTED_MODULE_3__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue), event, getValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? _equals_js__WEBPACK_IMPORTED_MODULE_6__.strictEquals);
}
class FromEventObservable extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseObservable {
    constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator) {
        super();
        this._debugNameData = _debugNameData;
        this.event = event;
        this._getValue = _getValue;
        this._getTransaction = _getTransaction;
        this._equalityComparator = _equalityComparator;
        this.hasValue = false;
        this.handleEvent = (args) => {
            const newValue = this._getValue(args);
            const oldValue = this.value;
            const didChange = !this.hasValue || !(this._equalityComparator(oldValue, newValue));
            let didRunTransaction = false;
            if (didChange) {
                this.value = newValue;
                if (this.hasValue) {
                    didRunTransaction = true;
                    (0,_base_js__WEBPACK_IMPORTED_MODULE_2__.subtransaction)(this._getTransaction(), (tx) => {
                        (0,_logging_js__WEBPACK_IMPORTED_MODULE_5__.getLogger)()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });
                        for (const o of this.observers) {
                            tx.updateObserver(o, this);
                            o.handleChange(this, undefined);
                        }
                    }, () => {
                        const name = this.getDebugName();
                        return 'Event fired' + (name ? `: ${name}` : '');
                    });
                }
                this.hasValue = true;
            }
            if (!didRunTransaction) {
                (0,_logging_js__WEBPACK_IMPORTED_MODULE_5__.getLogger)()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });
            }
        };
    }
    getDebugName() {
        return this._debugNameData.getDebugName(this);
    }
    get debugName() {
        const name = this.getDebugName();
        return 'From Event' + (name ? `: ${name}` : '');
    }
    onFirstObserverAdded() {
        this.subscription = this.event(this.handleEvent);
    }
    onLastObserverRemoved() {
        this.subscription.dispose();
        this.subscription = undefined;
        this.hasValue = false;
        this.value = undefined;
    }
    get() {
        if (this.subscription) {
            if (!this.hasValue) {
                this.handleEvent(undefined);
            }
            return this.value;
        }
        else {
            // no cache, as there are no subscribers to keep it updated
            const value = this._getValue(undefined);
            return value;
        }
    }
}
(function (observableFromEvent) {
    observableFromEvent.Observer = FromEventObservable;
    function batchEventsGlobally(tx, fn) {
        let didSet = false;
        if (FromEventObservable.globalTransaction === undefined) {
            FromEventObservable.globalTransaction = tx;
            didSet = true;
        }
        try {
            fn();
        }
        finally {
            if (didSet) {
                FromEventObservable.globalTransaction = undefined;
            }
        }
    }
    observableFromEvent.batchEventsGlobally = batchEventsGlobally;
})(observableFromEvent || (observableFromEvent = {}));
function observableSignalFromEvent(debugName, event) {
    return new FromEventObservableSignal(debugName, event);
}
class FromEventObservableSignal extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseObservable {
    constructor(debugName, event) {
        super();
        this.debugName = debugName;
        this.event = event;
        this.handleEvent = () => {
            (0,_base_js__WEBPACK_IMPORTED_MODULE_2__.transaction)((tx) => {
                for (const o of this.observers) {
                    tx.updateObserver(o, this);
                    o.handleChange(this, undefined);
                }
            }, () => this.debugName);
        };
    }
    onFirstObserverAdded() {
        this.subscription = this.event(this.handleEvent);
    }
    onLastObserverRemoved() {
        this.subscription.dispose();
        this.subscription = undefined;
    }
    get() {
        // NO OP
    }
}
function observableSignal(debugNameOrOwner) {
    if (typeof debugNameOrOwner === 'string') {
        return new ObservableSignal(debugNameOrOwner);
    }
    else {
        return new ObservableSignal(undefined, debugNameOrOwner);
    }
}
class ObservableSignal extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseObservable {
    get debugName() {
        return new _debugName_js__WEBPACK_IMPORTED_MODULE_3__.DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';
    }
    toString() {
        return this.debugName;
    }
    constructor(_debugName, _owner) {
        super();
        this._debugName = _debugName;
        this._owner = _owner;
    }
    trigger(tx, change) {
        if (!tx) {
            (0,_base_js__WEBPACK_IMPORTED_MODULE_2__.transaction)(tx => {
                this.trigger(tx, change);
            }, () => `Trigger signal ${this.debugName}`);
            return;
        }
        for (const o of this.observers) {
            tx.updateObserver(o, this);
            o.handleChange(this, change);
        }
    }
    get() {
        // NO OP
    }
}
/**
 * This makes sure the observable is being observed and keeps its cache alive.
 */
function keepObserved(observable) {
    const o = new KeepAliveObserver(false, undefined);
    observable.addObserver(o);
    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
        observable.removeObserver(o);
    });
}
(0,_base_js__WEBPACK_IMPORTED_MODULE_2__._setKeepObserved)(keepObserved);
/**
 * This converts the given observable into an autorun.
 */
function recomputeInitiallyAndOnChange(observable, handleValue) {
    const o = new KeepAliveObserver(true, handleValue);
    observable.addObserver(o);
    if (handleValue) {
        handleValue(observable.get());
    }
    else {
        observable.reportChanges();
    }
    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
        observable.removeObserver(o);
    });
}
(0,_base_js__WEBPACK_IMPORTED_MODULE_2__._setRecomputeInitiallyAndOnChange)(recomputeInitiallyAndOnChange);
class KeepAliveObserver {
    constructor(_forceRecompute, _handleValue) {
        this._forceRecompute = _forceRecompute;
        this._handleValue = _handleValue;
        this._counter = 0;
    }
    beginUpdate(observable) {
        this._counter++;
    }
    endUpdate(observable) {
        this._counter--;
        if (this._counter === 0 && this._forceRecompute) {
            if (this._handleValue) {
                this._handleValue(observable.get());
            }
            else {
                observable.reportChanges();
            }
        }
    }
    handlePossibleChange(observable) {
        // NO OP
    }
    handleChange(observable, change) {
        // NO OP
    }
}
function derivedObservableWithCache(owner, computeFn) {
    let lastValue = undefined;
    const observable = (0,_derived_js__WEBPACK_IMPORTED_MODULE_4__.derivedOpts)({ owner, debugReferenceFn: computeFn }, reader => {
        lastValue = computeFn(reader, lastValue);
        return lastValue;
    });
    return observable;
}
function derivedObservableWithWritableCache(owner, computeFn) {
    let lastValue = undefined;
    const onChange = observableSignal('derivedObservableWithWritableCache');
    const observable = (0,_derived_js__WEBPACK_IMPORTED_MODULE_4__.derived)(owner, reader => {
        onChange.read(reader);
        lastValue = computeFn(reader, lastValue);
        return lastValue;
    });
    return Object.assign(observable, {
        clearCache: (tx) => {
            lastValue = undefined;
            onChange.trigger(tx);
        },
        setCache: (newValue, tx) => {
            lastValue = newValue;
            onChange.trigger(tx);
        }
    });
}
/**
 * When the items array changes, referential equal items are not mapped again.
 */
function mapObservableArrayCached(owner, items, map, keySelector) {
    let m = new ArrayMap(map, keySelector);
    const self = (0,_derived_js__WEBPACK_IMPORTED_MODULE_4__.derivedOpts)({
        debugReferenceFn: map,
        owner,
        onLastObserverRemoved: () => {
            m.dispose();
            m = new ArrayMap(map);
        }
    }, (reader) => {
        m.setItems(items.read(reader));
        return m.getItems();
    });
    return self;
}
class ArrayMap {
    constructor(_map, _keySelector) {
        this._map = _map;
        this._keySelector = _keySelector;
        this._cache = new Map();
        this._items = [];
    }
    dispose() {
        this._cache.forEach(entry => entry.store.dispose());
        this._cache.clear();
    }
    setItems(items) {
        const newItems = [];
        const itemsToRemove = new Set(this._cache.keys());
        for (const item of items) {
            const key = this._keySelector ? this._keySelector(item) : item;
            let entry = this._cache.get(key);
            if (!entry) {
                const store = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore();
                const out = this._map(item, store);
                entry = { out, store };
                this._cache.set(key, entry);
            }
            else {
                itemsToRemove.delete(key);
            }
            newItems.push(entry.out);
        }
        for (const item of itemsToRemove) {
            const entry = this._cache.get(item);
            entry.store.dispose();
            this._cache.delete(item);
        }
        this._items = newItems;
    }
    getItems() {
        return this._items;
    }
}
class ValueWithChangeEventFromObservable {
    constructor(observable) {
        this.observable = observable;
    }
    get onDidChange() {
        return _event_js__WEBPACK_IMPORTED_MODULE_0__.Event.fromObservableLight(this.observable);
    }
    get value() {
        return this.observable.get();
    }
}
function observableFromValueWithChangeEvent(owner, value) {
    if (value instanceof ValueWithChangeEventFromObservable) {
        return value.observable;
    }
    return observableFromEvent(owner, value.onDidChange, () => value.value);
}
/**
 * Works like a derived.
 * However, if the value is not undefined, it is cached and will not be recomputed anymore.
 * In that case, the derived will unsubscribe from its dependencies.
*/
function derivedConstOnceDefined(owner, fn) {
    return derivedObservableWithCache(owner, (reader, lastValue) => lastValue ?? fn(reader));
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LanguageService: () => (/* binding */ LanguageService)
/* harmony export */ });
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _languagesRegistry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./languagesRegistry.js */ "./node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js");
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _languages_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../languages.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages.js");
/* harmony import */ var _languages_modesRegistry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../languages/modesRegistry.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js");
/* harmony import */ var _base_common_observable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../base/common/observable.js */ "./node_modules/monaco-editor/esm/vs/base/common/observable.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/







class LanguageService extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    static { this.instanceCount = 0; }
    constructor(warnOnOverwrite = false) {
        super();
        this._onDidRequestBasicLanguageFeatures = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter());
        this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event;
        this._onDidRequestRichLanguageFeatures = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter());
        this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event;
        this._onDidChange = this._register(new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter({ leakWarningThreshold: 200 /* https://github.com/microsoft/vscode/issues/119968 */ }));
        this.onDidChange = this._onDidChange.event;
        this._requestedBasicLanguages = new Set();
        this._requestedRichLanguages = new Set();
        LanguageService.instanceCount++;
        this._registry = this._register(new _languagesRegistry_js__WEBPACK_IMPORTED_MODULE_2__.LanguagesRegistry(true, warnOnOverwrite));
        this.languageIdCodec = this._registry.languageIdCodec;
        this._register(this._registry.onDidChange(() => this._onDidChange.fire()));
    }
    dispose() {
        LanguageService.instanceCount--;
        super.dispose();
    }
    isRegisteredLanguageId(languageId) {
        return this._registry.isRegisteredLanguageId(languageId);
    }
    getLanguageIdByLanguageName(languageName) {
        return this._registry.getLanguageIdByLanguageName(languageName);
    }
    getLanguageIdByMimeType(mimeType) {
        return this._registry.getLanguageIdByMimeType(mimeType);
    }
    guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {
        const languageIds = this._registry.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);
        return (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_3__.firstOrDefault)(languageIds, null);
    }
    createById(languageId) {
        return new LanguageSelection(this.onDidChange, () => {
            return this._createAndGetLanguageIdentifier(languageId);
        });
    }
    createByFilepathOrFirstLine(resource, firstLine) {
        return new LanguageSelection(this.onDidChange, () => {
            const languageId = this.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);
            return this._createAndGetLanguageIdentifier(languageId);
        });
    }
    _createAndGetLanguageIdentifier(languageId) {
        if (!languageId || !this.isRegisteredLanguageId(languageId)) {
            // Fall back to plain text if language is unknown
            languageId = _languages_modesRegistry_js__WEBPACK_IMPORTED_MODULE_5__.PLAINTEXT_LANGUAGE_ID;
        }
        return languageId;
    }
    requestBasicLanguageFeatures(languageId) {
        if (!this._requestedBasicLanguages.has(languageId)) {
            this._requestedBasicLanguages.add(languageId);
            this._onDidRequestBasicLanguageFeatures.fire(languageId);
        }
    }
    requestRichLanguageFeatures(languageId) {
        if (!this._requestedRichLanguages.has(languageId)) {
            this._requestedRichLanguages.add(languageId);
            // Ensure basic features are requested
            this.requestBasicLanguageFeatures(languageId);
            // Ensure tokenizers are created
            _languages_js__WEBPACK_IMPORTED_MODULE_4__.TokenizationRegistry.getOrCreate(languageId);
            this._onDidRequestRichLanguageFeatures.fire(languageId);
        }
    }
}
class LanguageSelection {
    constructor(onDidChangeLanguages, selector) {
        this._value = (0,_base_common_observable_js__WEBPACK_IMPORTED_MODULE_6__.observableFromEvent)(this, onDidChangeLanguages, () => selector());
        this.onDidChange = _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Event.fromObservable(this._value);
    }
    get languageId() {
        return this._value.get();
    }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19sYW5ndWFnZVNlcnZpY2VfanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFCQUFxQiw4Q0FBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDdUg7QUFDUjtBQUMrQjtBQUNpRztBQUM5STtBQUMvQjtBQUNtQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlFQUFTLEtBQUssbUZBQXVCO0FBQ3pDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDQTtBQUNHO0FBQ2dCO0FBQ3hEO0FBQ1A7QUFDQSxtQkFBbUIsd0VBQW1CLEtBQUssd0RBQWEsaUZBQWlGLG9EQUFZO0FBQ3JKO0FBQ0EsZUFBZSxxREFBZSxLQUFLLHdEQUFhLGlGQUFpRixvREFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3V0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0Q7QUFDQTtBQUNKO0FBQ0s7QUFDVDtBQUNlO0FBQ0c7QUFDbEUsOEJBQThCLGlFQUFVO0FBQy9DLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUVBQXFFLDBEQUFPO0FBQzVFO0FBQ0Esb0VBQW9FLDBEQUFPO0FBQzNFO0FBQ0EsK0NBQStDLDBEQUFPLEdBQUcsbUZBQW1GO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9FQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNFQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOEVBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrRUFBbUI7QUFDekMsMkJBQTJCLHdEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2VxdWFscy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL29ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9vYnNlcnZhYmxlSW50ZXJuYWwvYXBpLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vb2JzZXJ2YWJsZUludGVybmFsL2F1dG9ydW4uanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9vYnNlcnZhYmxlSW50ZXJuYWwvYmFzZS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL29ic2VydmFibGVJbnRlcm5hbC9kZWJ1Z05hbWUuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9vYnNlcnZhYmxlSW50ZXJuYWwvZGVyaXZlZC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL29ic2VydmFibGVJbnRlcm5hbC9sYXp5T2JzZXJ2YWJsZVZhbHVlLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vb2JzZXJ2YWJsZUludGVybmFsL2xvZ2dpbmcuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9vYnNlcnZhYmxlSW50ZXJuYWwvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL29ic2VydmFibGVJbnRlcm5hbC91dGlscy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbGFuZ3VhZ2VTZXJ2aWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgYXJyYXlzIGZyb20gJy4vYXJyYXlzLmpzJztcbi8qKlxuICogQ29tcGFyZXMgdHdvIGl0ZW1zIGZvciBlcXVhbGl0eSB1c2luZyBzdHJpY3QgZXF1YWxpdHkuXG4qL1xuZXhwb3J0IGNvbnN0IHN0cmljdEVxdWFscyA9IChhLCBiKSA9PiBhID09PSBiO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGl0ZW1zIG9mIHR3byBhcnJheXMgYXJlIGVxdWFsLlxuICogQnkgZGVmYXVsdCwgc3RyaWN0IGVxdWFsaXR5IGlzIHVzZWQgdG8gY29tcGFyZSBlbGVtZW50cywgYnV0IGEgY3VzdG9tIGVxdWFsaXR5IGNvbXBhcmVyIGNhbiBiZSBwcm92aWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGl0ZW1zRXF1YWxzKGl0ZW1FcXVhbHMgPSBzdHJpY3RFcXVhbHMpIHtcbiAgICByZXR1cm4gKGEsIGIpID0+IGFycmF5cy5lcXVhbHMoYSwgYiwgaXRlbUVxdWFscyk7XG59XG4vKipcbiAqIFVzZXMgYGl0ZW0uZXF1YWxzKG90aGVyKWAgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXRlbUVxdWFscygpIHtcbiAgICByZXR1cm4gKGEsIGIpID0+IGEuZXF1YWxzKGIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsc0lmRGVmaW5lZChlcXVhbHNPclYxLCB2MiwgZXF1YWxzKSB7XG4gICAgaWYgKGVxdWFscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHYxID0gZXF1YWxzT3JWMTtcbiAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQgfHwgdjEgPT09IG51bGwgfHwgdjIgPT09IHVuZGVmaW5lZCB8fCB2MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHYyID09PSB2MTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXF1YWxzKHYxLCB2Mik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBlcXVhbHMgPSBlcXVhbHNPclYxO1xuICAgICAgICByZXR1cm4gKHYxLCB2MikgPT4ge1xuICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQgfHwgdjEgPT09IG51bGwgfHwgdjIgPT09IHVuZGVmaW5lZCB8fCB2MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2MiA9PT0gdjE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXF1YWxzKHYxLCB2Mik7XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBEcmlsbHMgaW50byBhcnJheXMgKGl0ZW1zIG9yZGVyZWQpIGFuZCBvYmplY3RzIChrZXlzIHVub3JkZXJlZCkgYW5kIHVzZXMgc3RyaWN0IGVxdWFsaXR5IG9uIGV2ZXJ5dGhpbmcgZWxzZS5cbiovXG5leHBvcnQgZnVuY3Rpb24gc3RydWN0dXJhbEVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFzdHJ1Y3R1cmFsRXF1YWxzKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYiAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSA9PT0gT2JqZWN0LnByb3RvdHlwZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFPYmogPSBhO1xuICAgICAgICAgICAgY29uc3QgYk9iaiA9IGI7XG4gICAgICAgICAgICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKGFPYmopO1xuICAgICAgICAgICAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhiT2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGtleXNCU2V0ID0gbmV3IFNldChrZXlzQik7XG4gICAgICAgICAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzQSkge1xuICAgICAgICAgICAgICAgIGlmICgha2V5c0JTZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0cnVjdHVyYWxFcXVhbHMoYU9ialtrZXldLCBiT2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBvYmpJZHMgPSBuZXcgV2Vha01hcCgpO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgeyBvYnNlcnZhYmxlVmFsdWUsIGRpc3Bvc2FibGVPYnNlcnZhYmxlVmFsdWUsIHRyYW5zYWN0aW9uLCBzdWJ0cmFuc2FjdGlvbiB9IGZyb20gJy4vb2JzZXJ2YWJsZUludGVybmFsL2Jhc2UuanMnO1xuZXhwb3J0IHsgZGVyaXZlZCwgZGVyaXZlZE9wdHMsIGRlcml2ZWRIYW5kbGVDaGFuZ2VzLCBkZXJpdmVkV2l0aFN0b3JlIH0gZnJvbSAnLi9vYnNlcnZhYmxlSW50ZXJuYWwvZGVyaXZlZC5qcyc7XG5leHBvcnQgeyBhdXRvcnVuLCBhdXRvcnVuSGFuZGxlQ2hhbmdlcywgYXV0b3J1bldpdGhTdG9yZSwgYXV0b3J1bk9wdHMsIGF1dG9ydW5XaXRoU3RvcmVIYW5kbGVDaGFuZ2VzIH0gZnJvbSAnLi9vYnNlcnZhYmxlSW50ZXJuYWwvYXV0b3J1bi5qcyc7XG5leHBvcnQgeyBjb25zdE9ic2VydmFibGUsIGRlcml2ZWRPYnNlcnZhYmxlV2l0aENhY2hlLCBkZXJpdmVkT2JzZXJ2YWJsZVdpdGhXcml0YWJsZUNhY2hlLCBrZWVwT2JzZXJ2ZWQsIHJlY29tcHV0ZUluaXRpYWxseUFuZE9uQ2hhbmdlLCBvYnNlcnZhYmxlRnJvbUV2ZW50LCBvYnNlcnZhYmxlU2lnbmFsLCBvYnNlcnZhYmxlU2lnbmFsRnJvbUV2ZW50IH0gZnJvbSAnLi9vYnNlcnZhYmxlSW50ZXJuYWwvdXRpbHMuanMnO1xuZXhwb3J0IHsgT2JzZXJ2YWJsZVByb21pc2UsIFByb21pc2VSZXN1bHQsIHdhaXRGb3JTdGF0ZSB9IGZyb20gJy4vb2JzZXJ2YWJsZUludGVybmFsL3Byb21pc2UuanMnO1xuZXhwb3J0IHsgb2JzZXJ2YWJsZVZhbHVlT3B0cyB9IGZyb20gJy4vb2JzZXJ2YWJsZUludGVybmFsL2FwaS5qcyc7XG5pbXBvcnQgeyBDb25zb2xlT2JzZXJ2YWJsZUxvZ2dlciwgc2V0TG9nZ2VyIH0gZnJvbSAnLi9vYnNlcnZhYmxlSW50ZXJuYWwvbG9nZ2luZy5qcyc7XG4vLyBSZW1vdmUgXCIvL1wiIGluIHRoZSBuZXh0IGxpbmUgdG8gZW5hYmxlIGxvZ2dpbmdcbmNvbnN0IGVuYWJsZUxvZ2dpbmcgPSBmYWxzZTtcbmlmIChlbmFibGVMb2dnaW5nKSB7XG4gICAgc2V0TG9nZ2VyKG5ldyBDb25zb2xlT2JzZXJ2YWJsZUxvZ2dlcigpKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgc3RyaWN0RXF1YWxzIH0gZnJvbSAnLi4vZXF1YWxzLmpzJztcbmltcG9ydCB7IE9ic2VydmFibGVWYWx1ZSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgeyBEZWJ1Z05hbWVEYXRhIH0gZnJvbSAnLi9kZWJ1Z05hbWUuanMnO1xuaW1wb3J0IHsgTGF6eU9ic2VydmFibGVWYWx1ZSB9IGZyb20gJy4vbGF6eU9ic2VydmFibGVWYWx1ZS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2YWJsZVZhbHVlT3B0cyhvcHRpb25zLCBpbml0aWFsVmFsdWUpIHtcbiAgICBpZiAob3B0aW9ucy5sYXp5KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eU9ic2VydmFibGVWYWx1ZShuZXcgRGVidWdOYW1lRGF0YShvcHRpb25zLm93bmVyLCBvcHRpb25zLmRlYnVnTmFtZSwgdW5kZWZpbmVkKSwgaW5pdGlhbFZhbHVlLCBvcHRpb25zLmVxdWFsc0ZuID8/IHN0cmljdEVxdWFscyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVZhbHVlKG5ldyBEZWJ1Z05hbWVEYXRhKG9wdGlvbnMub3duZXIsIG9wdGlvbnMuZGVidWdOYW1lLCB1bmRlZmluZWQpLCBpbml0aWFsVmFsdWUsIG9wdGlvbnMuZXF1YWxzRm4gPz8gc3RyaWN0RXF1YWxzKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgYXNzZXJ0Rm4gfSBmcm9tICcuLi9hc3NlcnQuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZVN0b3JlLCBtYXJrQXNEaXNwb3NlZCwgdG9EaXNwb3NhYmxlLCB0cmFja0Rpc3Bvc2FibGUgfSBmcm9tICcuLi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgRGVidWdOYW1lRGF0YSB9IGZyb20gJy4vZGVidWdOYW1lLmpzJztcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJy4vbG9nZ2luZy5qcyc7XG4vKipcbiAqIFJ1bnMgaW1tZWRpYXRlbHkgYW5kIHdoZW5ldmVyIGEgdHJhbnNhY3Rpb24gZW5kcyBhbmQgYW4gb2JzZXJ2ZWQgb2JzZXJ2YWJsZSBjaGFuZ2VkLlxuICoge0BsaW5rIGZufSBzaG91bGQgc3RhcnQgd2l0aCBhIEpTIERvYyB1c2luZyBgQGRlc2NyaXB0aW9uYCB0byBuYW1lIHRoZSBhdXRvcnVuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXV0b3J1bihmbikge1xuICAgIHJldHVybiBuZXcgQXV0b3J1bk9ic2VydmVyKG5ldyBEZWJ1Z05hbWVEYXRhKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmbiksIGZuLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG59XG4vKipcbiAqIFJ1bnMgaW1tZWRpYXRlbHkgYW5kIHdoZW5ldmVyIGEgdHJhbnNhY3Rpb24gZW5kcyBhbmQgYW4gb2JzZXJ2ZWQgb2JzZXJ2YWJsZSBjaGFuZ2VkLlxuICoge0BsaW5rIGZufSBzaG91bGQgc3RhcnQgd2l0aCBhIEpTIERvYyB1c2luZyBgQGRlc2NyaXB0aW9uYCB0byBuYW1lIHRoZSBhdXRvcnVuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXV0b3J1bk9wdHMob3B0aW9ucywgZm4pIHtcbiAgICByZXR1cm4gbmV3IEF1dG9ydW5PYnNlcnZlcihuZXcgRGVidWdOYW1lRGF0YShvcHRpb25zLm93bmVyLCBvcHRpb25zLmRlYnVnTmFtZSwgb3B0aW9ucy5kZWJ1Z1JlZmVyZW5jZUZuID8/IGZuKSwgZm4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn1cbi8qKlxuICogUnVucyBpbW1lZGlhdGVseSBhbmQgd2hlbmV2ZXIgYSB0cmFuc2FjdGlvbiBlbmRzIGFuZCBhbiBvYnNlcnZlZCBvYnNlcnZhYmxlIGNoYW5nZWQuXG4gKiB7QGxpbmsgZm59IHNob3VsZCBzdGFydCB3aXRoIGEgSlMgRG9jIHVzaW5nIGBAZGVzY3JpcHRpb25gIHRvIG5hbWUgdGhlIGF1dG9ydW4uXG4gKlxuICogVXNlIGBjcmVhdGVFbXB0eUNoYW5nZVN1bW1hcnlgIHRvIGNyZWF0ZSBhIFwiY2hhbmdlIHN1bW1hcnlcIiB0aGF0IGNhbiBjb2xsZWN0IHRoZSBjaGFuZ2VzLlxuICogVXNlIGBoYW5kbGVDaGFuZ2VgIHRvIGFkZCBhIHJlcG9ydGVkIGNoYW5nZSB0byB0aGUgY2hhbmdlIHN1bW1hcnkuXG4gKiBUaGUgcnVuIGZ1bmN0aW9uIGlzIGdpdmVuIHRoZSBsYXN0IGNoYW5nZSBzdW1tYXJ5LlxuICogVGhlIGNoYW5nZSBzdW1tYXJ5IGlzIGRpc2NhcmRlZCBhZnRlciB0aGUgcnVuIGZ1bmN0aW9uIHdhcyBjYWxsZWQuXG4gKlxuICogQHNlZSBhdXRvcnVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdXRvcnVuSGFuZGxlQ2hhbmdlcyhvcHRpb25zLCBmbikge1xuICAgIHJldHVybiBuZXcgQXV0b3J1bk9ic2VydmVyKG5ldyBEZWJ1Z05hbWVEYXRhKG9wdGlvbnMub3duZXIsIG9wdGlvbnMuZGVidWdOYW1lLCBvcHRpb25zLmRlYnVnUmVmZXJlbmNlRm4gPz8gZm4pLCBmbiwgb3B0aW9ucy5jcmVhdGVFbXB0eUNoYW5nZVN1bW1hcnksIG9wdGlvbnMuaGFuZGxlQ2hhbmdlKTtcbn1cbi8qKlxuICogQHNlZSBhdXRvcnVuSGFuZGxlQ2hhbmdlcyAoYnV0IHdpdGggYSBkaXNwb3NhYmxlIHN0b3JlIHRoYXQgaXMgY2xlYXJlZCBiZWZvcmUgdGhlIG5leHQgcnVuIG9yIG9uIGRpc3Bvc2UpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdXRvcnVuV2l0aFN0b3JlSGFuZGxlQ2hhbmdlcyhvcHRpb25zLCBmbikge1xuICAgIGNvbnN0IHN0b3JlID0gbmV3IERpc3Bvc2FibGVTdG9yZSgpO1xuICAgIGNvbnN0IGRpc3Bvc2FibGUgPSBhdXRvcnVuSGFuZGxlQ2hhbmdlcyh7XG4gICAgICAgIG93bmVyOiBvcHRpb25zLm93bmVyLFxuICAgICAgICBkZWJ1Z05hbWU6IG9wdGlvbnMuZGVidWdOYW1lLFxuICAgICAgICBkZWJ1Z1JlZmVyZW5jZUZuOiBvcHRpb25zLmRlYnVnUmVmZXJlbmNlRm4gPz8gZm4sXG4gICAgICAgIGNyZWF0ZUVtcHR5Q2hhbmdlU3VtbWFyeTogb3B0aW9ucy5jcmVhdGVFbXB0eUNoYW5nZVN1bW1hcnksXG4gICAgICAgIGhhbmRsZUNoYW5nZTogb3B0aW9ucy5oYW5kbGVDaGFuZ2UsXG4gICAgfSwgKHJlYWRlciwgY2hhbmdlU3VtbWFyeSkgPT4ge1xuICAgICAgICBzdG9yZS5jbGVhcigpO1xuICAgICAgICBmbihyZWFkZXIsIGNoYW5nZVN1bW1hcnksIHN0b3JlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9EaXNwb3NhYmxlKCgpID0+IHtcbiAgICAgICAgZGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgIHN0b3JlLmRpc3Bvc2UoKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQHNlZSBhdXRvcnVuIChidXQgd2l0aCBhIGRpc3Bvc2FibGUgc3RvcmUgdGhhdCBpcyBjbGVhcmVkIGJlZm9yZSB0aGUgbmV4dCBydW4gb3Igb24gZGlzcG9zZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG9ydW5XaXRoU3RvcmUoZm4pIHtcbiAgICBjb25zdCBzdG9yZSA9IG5ldyBEaXNwb3NhYmxlU3RvcmUoKTtcbiAgICBjb25zdCBkaXNwb3NhYmxlID0gYXV0b3J1bk9wdHMoe1xuICAgICAgICBvd25lcjogdW5kZWZpbmVkLFxuICAgICAgICBkZWJ1Z05hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVidWdSZWZlcmVuY2VGbjogZm4sXG4gICAgfSwgcmVhZGVyID0+IHtcbiAgICAgICAgc3RvcmUuY2xlYXIoKTtcbiAgICAgICAgZm4ocmVhZGVyLCBzdG9yZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICBzdG9yZS5kaXNwb3NlKCk7XG4gICAgfSk7XG59XG5leHBvcnQgY2xhc3MgQXV0b3J1bk9ic2VydmVyIHtcbiAgICBnZXQgZGVidWdOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVidWdOYW1lRGF0YS5nZXREZWJ1Z05hbWUodGhpcykgPz8gJyhhbm9ueW1vdXMpJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoX2RlYnVnTmFtZURhdGEsIF9ydW5GbiwgY3JlYXRlQ2hhbmdlU3VtbWFyeSwgX2hhbmRsZUNoYW5nZSkge1xuICAgICAgICB0aGlzLl9kZWJ1Z05hbWVEYXRhID0gX2RlYnVnTmFtZURhdGE7XG4gICAgICAgIHRoaXMuX3J1bkZuID0gX3J1bkZuO1xuICAgICAgICB0aGlzLmNyZWF0ZUNoYW5nZVN1bW1hcnkgPSBjcmVhdGVDaGFuZ2VTdW1tYXJ5O1xuICAgICAgICB0aGlzLl9oYW5kbGVDaGFuZ2UgPSBfaGFuZGxlQ2hhbmdlO1xuICAgICAgICB0aGlzLnN0YXRlID0gMiAvKiBBdXRvcnVuU3RhdGUuc3RhbGUgKi87XG4gICAgICAgIHRoaXMudXBkYXRlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llc1RvQmVSZW1vdmVkID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmNoYW5nZVN1bW1hcnkgPSB0aGlzLmNyZWF0ZUNoYW5nZVN1bW1hcnk/LigpO1xuICAgICAgICBnZXRMb2dnZXIoKT8uaGFuZGxlQXV0b3J1bkNyZWF0ZWQodGhpcyk7XG4gICAgICAgIHRoaXMuX3J1bklmTmVlZGVkKCk7XG4gICAgICAgIHRyYWNrRGlzcG9zYWJsZSh0aGlzKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgbyBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgby5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5jbGVhcigpO1xuICAgICAgICBtYXJrQXNEaXNwb3NlZCh0aGlzKTtcbiAgICB9XG4gICAgX3J1bklmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMyAvKiBBdXRvcnVuU3RhdGUudXBUb0RhdGUgKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbXB0eVNldCA9IHRoaXMuZGVwZW5kZW5jaWVzVG9CZVJlbW92ZWQ7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzVG9CZVJlbW92ZWQgPSB0aGlzLmRlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBlbXB0eVNldDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDMgLyogQXV0b3J1blN0YXRlLnVwVG9EYXRlICovO1xuICAgICAgICBjb25zdCBpc0Rpc3Bvc2VkID0gdGhpcy5kaXNwb3NlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIGdldExvZ2dlcigpPy5oYW5kbGVBdXRvcnVuVHJpZ2dlcmVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZVN1bW1hcnkgPSB0aGlzLmNoYW5nZVN1bW1hcnk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdW1tYXJ5ID0gdGhpcy5jcmVhdGVDaGFuZ2VTdW1tYXJ5Py4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ydW5Gbih0aGlzLCBjaGFuZ2VTdW1tYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICghaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIGdldExvZ2dlcigpPy5oYW5kbGVBdXRvcnVuRmluaXNoZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IG91ciBvYnNlcnZlZCBvYnNlcnZhYmxlcyB0byB0aGluayB0aGF0IHRoZXkgYXJlIChub3QgZXZlbiB0ZW1wb3JhcmlseSkgbm90IGJlaW5nIG9ic2VydmVkLlxuICAgICAgICAgICAgLy8gVGh1cywgd2Ugb25seSB1bnN1YnNjcmliZSBmcm9tIG9ic2VydmFibGVzIHRoYXQgYXJlIGRlZmluaXRlbHkgbm90IHJlYWQgYW55bW9yZS5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbyBvZiB0aGlzLmRlcGVuZGVuY2llc1RvQmVSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgby5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzVG9CZVJlbW92ZWQuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBBdXRvcnVuPCR7dGhpcy5kZWJ1Z05hbWV9PmA7XG4gICAgfVxuICAgIC8vIElPYnNlcnZlciBpbXBsZW1lbnRhdGlvblxuICAgIGJlZ2luVXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMyAvKiBBdXRvcnVuU3RhdGUudXBUb0RhdGUgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxIC8qIEF1dG9ydW5TdGF0ZS5kZXBlbmRlbmNpZXNNaWdodEhhdmVDaGFuZ2VkICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlQ291bnQrKztcbiAgICB9XG4gICAgZW5kVXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAxIC8qIEF1dG9ydW5TdGF0ZS5kZXBlbmRlbmNpZXNNaWdodEhhdmVDaGFuZ2VkICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzIC8qIEF1dG9ydW5TdGF0ZS51cFRvRGF0ZSAqLztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnJlcG9ydENoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAyIC8qIEF1dG9ydW5TdGF0ZS5zdGFsZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvdGhlciBkZXBlbmRlbmNpZXMgd2lsbCByZWZyZXNoIG9uIGRlbWFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3J1bklmTmVlZGVkKCk7XG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLnN0YXRlICE9PSAzIC8qIEF1dG9ydW5TdGF0ZS51cFRvRGF0ZSAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVDb3VudC0tO1xuICAgICAgICBhc3NlcnRGbigoKSA9PiB0aGlzLnVwZGF0ZUNvdW50ID49IDApO1xuICAgIH1cbiAgICBoYW5kbGVQb3NzaWJsZUNoYW5nZShvYnNlcnZhYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAzIC8qIEF1dG9ydW5TdGF0ZS51cFRvRGF0ZSAqLyAmJiB0aGlzLmRlcGVuZGVuY2llcy5oYXMob2JzZXJ2YWJsZSkgJiYgIXRoaXMuZGVwZW5kZW5jaWVzVG9CZVJlbW92ZWQuaGFzKG9ic2VydmFibGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMSAvKiBBdXRvcnVuU3RhdGUuZGVwZW5kZW5jaWVzTWlnaHRIYXZlQ2hhbmdlZCAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2Uob2JzZXJ2YWJsZSwgY2hhbmdlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY2llcy5oYXMob2JzZXJ2YWJsZSkgJiYgIXRoaXMuZGVwZW5kZW5jaWVzVG9CZVJlbW92ZWQuaGFzKG9ic2VydmFibGUpKSB7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZWFjdCA9IHRoaXMuX2hhbmRsZUNoYW5nZSA/IHRoaXMuX2hhbmRsZUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgY2hhbmdlZE9ic2VydmFibGU6IG9ic2VydmFibGUsXG4gICAgICAgICAgICAgICAgY2hhbmdlLFxuICAgICAgICAgICAgICAgIGRpZENoYW5nZTogKG8pID0+IG8gPT09IG9ic2VydmFibGUsXG4gICAgICAgICAgICB9LCB0aGlzLmNoYW5nZVN1bW1hcnkpIDogdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZWFjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyIC8qIEF1dG9ydW5TdGF0ZS5zdGFsZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJUmVhZGVyIGltcGxlbWVudGF0aW9uXG4gICAgcmVhZE9ic2VydmFibGUob2JzZXJ2YWJsZSkge1xuICAgICAgICAvLyBJbiBjYXNlIHRoZSBydW4gYWN0aW9uIGRpc3Bvc2VzIHRoZSBhdXRvcnVuXG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5nZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZhYmxlLmFkZE9ic2VydmVyKHRoaXMpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9ic2VydmFibGUuZ2V0KCk7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLmFkZChvYnNlcnZhYmxlKTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXNUb0JlUmVtb3ZlZC5kZWxldGUob2JzZXJ2YWJsZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKGF1dG9ydW4pIHtcbiAgICBhdXRvcnVuLk9ic2VydmVyID0gQXV0b3J1bk9ic2VydmVyO1xufSkoYXV0b3J1biB8fCAoYXV0b3J1biA9IHt9KSk7XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IHN0cmljdEVxdWFscyB9IGZyb20gJy4uL2VxdWFscy5qcyc7XG5pbXBvcnQgeyBEZWJ1Z05hbWVEYXRhLCBnZXRGdW5jdGlvbk5hbWUgfSBmcm9tICcuL2RlYnVnTmFtZS5qcyc7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tICcuL2xvZ2dpbmcuanMnO1xubGV0IF9yZWNvbXB1dGVJbml0aWFsbHlBbmRPbkNoYW5nZTtcbmV4cG9ydCBmdW5jdGlvbiBfc2V0UmVjb21wdXRlSW5pdGlhbGx5QW5kT25DaGFuZ2UocmVjb21wdXRlSW5pdGlhbGx5QW5kT25DaGFuZ2UpIHtcbiAgICBfcmVjb21wdXRlSW5pdGlhbGx5QW5kT25DaGFuZ2UgPSByZWNvbXB1dGVJbml0aWFsbHlBbmRPbkNoYW5nZTtcbn1cbmxldCBfa2VlcE9ic2VydmVkO1xuZXhwb3J0IGZ1bmN0aW9uIF9zZXRLZWVwT2JzZXJ2ZWQoa2VlcE9ic2VydmVkKSB7XG4gICAgX2tlZXBPYnNlcnZlZCA9IGtlZXBPYnNlcnZlZDtcbn1cbmxldCBfZGVyaXZlZDtcbi8qKlxuICogQGludGVybmFsXG4gKiBUaGlzIGlzIHRvIGFsbG93IHNwbGl0dGluZyBmaWxlcy5cbiovXG5leHBvcnQgZnVuY3Rpb24gX3NldERlcml2ZWRPcHRzKGRlcml2ZWQpIHtcbiAgICBfZGVyaXZlZCA9IGRlcml2ZWQ7XG59XG5leHBvcnQgY2xhc3MgQ29udmVuaWVudE9ic2VydmFibGUge1xuICAgIGdldCBUQ2hhbmdlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHJlcG9ydENoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMuZ2V0KCk7XG4gICAgfVxuICAgIC8qKiBAc2VhbGVkICovXG4gICAgcmVhZChyZWFkZXIpIHtcbiAgICAgICAgaWYgKHJlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkT2JzZXJ2YWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hcChmbk9yT3duZXIsIGZuT3JVbmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgb3duZXIgPSBmbk9yVW5kZWZpbmVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBmbk9yT3duZXI7XG4gICAgICAgIGNvbnN0IGZuID0gZm5PclVuZGVmaW5lZCA9PT0gdW5kZWZpbmVkID8gZm5Pck93bmVyIDogZm5PclVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIF9kZXJpdmVkKHtcbiAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgZGVidWdOYW1lOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldEZ1bmN0aW9uTmFtZShmbik7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVnZXhwIHRvIG1hdGNoIGB4ID0+IHgueWAgb3IgYHggPT4geD8ueWAgd2hlcmUgeCBhbmQgeSBjYW4gYmUgYXJiaXRyYXJ5IGlkZW50aWZpZXJzICh1c2VzIGJhY2tyZWYpOlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4cCA9IC9eXFxzKlxcKD9cXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKilcXHMqXFwpP1xccyo9PlxccypcXDEoPzpcXD8/KVxcLihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFxzKiQvO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVnZXhwLmV4ZWMoZm4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmRlYnVnTmFtZX0uJHttYXRjaFsyXX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmRlYnVnTmFtZX0gKG1hcHBlZClgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYnVnUmVmZXJlbmNlRm46IGZuLFxuICAgICAgICB9LCAocmVhZGVyKSA9PiBmbih0aGlzLnJlYWQocmVhZGVyKSwgcmVhZGVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWFsZWRcbiAgICAgKiBDb252ZXJ0cyBhbiBvYnNlcnZhYmxlIG9mIGFuIG9ic2VydmFibGUgdmFsdWUgaW50byBhIGRpcmVjdCBvYnNlcnZhYmxlIG9mIHRoZSB2YWx1ZS5cbiAgICAqL1xuICAgIGZsYXR0ZW4oKSB7XG4gICAgICAgIHJldHVybiBfZGVyaXZlZCh7XG4gICAgICAgICAgICBvd25lcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVidWdOYW1lOiAoKSA9PiBgJHt0aGlzLmRlYnVnTmFtZX0gKGZsYXR0ZW5lZClgLFxuICAgICAgICB9LCAocmVhZGVyKSA9PiB0aGlzLnJlYWQocmVhZGVyKS5yZWFkKHJlYWRlcikpO1xuICAgIH1cbiAgICByZWNvbXB1dGVJbml0aWFsbHlBbmRPbkNoYW5nZShzdG9yZSwgaGFuZGxlVmFsdWUpIHtcbiAgICAgICAgc3RvcmUuYWRkKF9yZWNvbXB1dGVJbml0aWFsbHlBbmRPbkNoYW5nZSh0aGlzLCBoYW5kbGVWYWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IHRoaXMgb2JzZXJ2YWJsZSBpcyBvYnNlcnZlZC4gVGhpcyBrZWVwcyB0aGUgY2FjaGUgYWxpdmUuXG4gICAgICogSG93ZXZlciwgaW4gY2FzZSBvZiBkZXJpdmVkcywgaXQgZG9lcyBub3QgZm9yY2UgZWFnZXIgZXZhbHVhdGlvbiAob25seSB3aGVuIHRoZSB2YWx1ZSBpcyByZWFkL2dldCkuXG4gICAgICogVXNlIGByZWNvbXB1dGVJbml0aWFsbHlBbmRPbkNoYW5nZWAgZm9yIGVhZ2VyIGV2YWx1YXRpb24uXG4gICAgICovXG4gICAga2VlcE9ic2VydmVkKHN0b3JlKSB7XG4gICAgICAgIHN0b3JlLmFkZChfa2VlcE9ic2VydmVkKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJhc2VPYnNlcnZhYmxlIGV4dGVuZHMgQ29udmVuaWVudE9ic2VydmFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vYnNlcnZlcnMuc2l6ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vbkZpcnN0T2JzZXJ2ZXJBZGRlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpO1xuICAgICAgICBpZiAoZGVsZXRlZCAmJiB0aGlzLm9ic2VydmVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm9uTGFzdE9ic2VydmVyUmVtb3ZlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uRmlyc3RPYnNlcnZlckFkZGVkKCkgeyB9XG4gICAgb25MYXN0T2JzZXJ2ZXJSZW1vdmVkKCkgeyB9XG59XG4vKipcbiAqIFN0YXJ0cyBhIHRyYW5zYWN0aW9uIGluIHdoaWNoIG1hbnkgb2JzZXJ2YWJsZXMgY2FuIGJlIGNoYW5nZWQgYXQgb25jZS5cbiAqIHtAbGluayBmbn0gc2hvdWxkIHN0YXJ0IHdpdGggYSBKUyBEb2MgdXNpbmcgYEBkZXNjcmlwdGlvbmAgdG8gZ2l2ZSB0aGUgdHJhbnNhY3Rpb24gYSBkZWJ1ZyBuYW1lLlxuICogUmVhY3Rpb24gcnVuIG9uIGRlbWFuZCBvciB3aGVuIHRoZSB0cmFuc2FjdGlvbiBlbmRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNhY3Rpb24oZm4sIGdldERlYnVnTmFtZSkge1xuICAgIGNvbnN0IHR4ID0gbmV3IFRyYW5zYWN0aW9uSW1wbChmbiwgZ2V0RGVidWdOYW1lKTtcbiAgICB0cnkge1xuICAgICAgICBmbih0eCk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0eC5maW5pc2goKTtcbiAgICB9XG59XG5sZXQgX2dsb2JhbFRyYW5zYWN0aW9uID0gdW5kZWZpbmVkO1xuZXhwb3J0IGZ1bmN0aW9uIGdsb2JhbFRyYW5zYWN0aW9uKGZuKSB7XG4gICAgaWYgKF9nbG9iYWxUcmFuc2FjdGlvbikge1xuICAgICAgICBmbihfZ2xvYmFsVHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb25JbXBsKGZuLCB1bmRlZmluZWQpO1xuICAgICAgICBfZ2xvYmFsVHJhbnNhY3Rpb24gPSB0eDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuKHR4KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHR4LmZpbmlzaCgpOyAvLyBEdXJpbmcgZmluaXNoLCBtb3JlIGFjdGlvbnMgbWlnaHQgYmUgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgLy8gV2hpY2ggaXMgd2h5IHdlIG9ubHkgY2xlYXIgdGhlIGdsb2JhbCB0cmFuc2FjdGlvbiBhZnRlciBmaW5pc2guXG4gICAgICAgICAgICBfZ2xvYmFsVHJhbnNhY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNUcmFuc2FjdGlvbihmbiwgZ2V0RGVidWdOYW1lKSB7XG4gICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb25JbXBsKGZuLCBnZXREZWJ1Z05hbWUpO1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZuKHR4KTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHR4LmZpbmlzaCgpO1xuICAgIH1cbn1cbi8qKlxuICogQWxsb3dzIHRvIGNoYWluIHRyYW5zYWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYW5zYWN0aW9uKHR4LCBmbiwgZ2V0RGVidWdOYW1lKSB7XG4gICAgaWYgKCF0eCkge1xuICAgICAgICB0cmFuc2FjdGlvbihmbiwgZ2V0RGVidWdOYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZuKHR4KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihfZm4sIF9nZXREZWJ1Z05hbWUpIHtcbiAgICAgICAgdGhpcy5fZm4gPSBfZm47XG4gICAgICAgIHRoaXMuX2dldERlYnVnTmFtZSA9IF9nZXREZWJ1Z05hbWU7XG4gICAgICAgIHRoaXMudXBkYXRpbmdPYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgZ2V0TG9nZ2VyKCk/LmhhbmRsZUJlZ2luVHJhbnNhY3Rpb24odGhpcyk7XG4gICAgfVxuICAgIGdldERlYnVnTmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dldERlYnVnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldERlYnVnTmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRGdW5jdGlvbk5hbWUodGhpcy5fZm4pO1xuICAgIH1cbiAgICB1cGRhdGVPYnNlcnZlcihvYnNlcnZlciwgb2JzZXJ2YWJsZSkge1xuICAgICAgICAvLyBXaGVuIHRoaXMgZ2V0cyBjYWxsZWQgd2hpbGUgZmluaXNoIGlzIGFjdGl2ZSwgdGhleSB3aWxsIHN0aWxsIGdldCBjb25zaWRlcmVkXG4gICAgICAgIHRoaXMudXBkYXRpbmdPYnNlcnZlcnMucHVzaCh7IG9ic2VydmVyLCBvYnNlcnZhYmxlIH0pO1xuICAgICAgICBvYnNlcnZlci5iZWdpblVwZGF0ZShvYnNlcnZhYmxlKTtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBjb25zdCB1cGRhdGluZ09ic2VydmVycyA9IHRoaXMudXBkYXRpbmdPYnNlcnZlcnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXBkYXRpbmdPYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb2JzZXJ2ZXIsIG9ic2VydmFibGUgfSA9IHVwZGF0aW5nT2JzZXJ2ZXJzW2ldO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZW5kVXBkYXRlKG9ic2VydmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgYW55b25lIGZyb20gdXBkYXRpbmcgb2JzZXJ2ZXJzIGZyb20gbm93IG9uLlxuICAgICAgICB0aGlzLnVwZGF0aW5nT2JzZXJ2ZXJzID0gbnVsbDtcbiAgICAgICAgZ2V0TG9nZ2VyKCk/LmhhbmRsZUVuZFRyYW5zYWN0aW9uKCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmFibGVWYWx1ZShuYW1lT3JPd25lciwgaW5pdGlhbFZhbHVlKSB7XG4gICAgbGV0IGRlYnVnTmFtZURhdGE7XG4gICAgaWYgKHR5cGVvZiBuYW1lT3JPd25lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGVidWdOYW1lRGF0YSA9IG5ldyBEZWJ1Z05hbWVEYXRhKHVuZGVmaW5lZCwgbmFtZU9yT3duZXIsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWJ1Z05hbWVEYXRhID0gbmV3IERlYnVnTmFtZURhdGEobmFtZU9yT3duZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlVmFsdWUoZGVidWdOYW1lRGF0YSwgaW5pdGlhbFZhbHVlLCBzdHJpY3RFcXVhbHMpO1xufVxuZXhwb3J0IGNsYXNzIE9ic2VydmFibGVWYWx1ZSBleHRlbmRzIEJhc2VPYnNlcnZhYmxlIHtcbiAgICBnZXQgZGVidWdOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVidWdOYW1lRGF0YS5nZXREZWJ1Z05hbWUodGhpcykgPz8gJ09ic2VydmFibGVWYWx1ZSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9kZWJ1Z05hbWVEYXRhLCBpbml0aWFsVmFsdWUsIF9lcXVhbGl0eUNvbXBhcmF0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZGVidWdOYW1lRGF0YSA9IF9kZWJ1Z05hbWVEYXRhO1xuICAgICAgICB0aGlzLl9lcXVhbGl0eUNvbXBhcmF0b3IgPSBfZXF1YWxpdHlDb21wYXJhdG9yO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCh2YWx1ZSwgdHgsIGNoYW5nZSkge1xuICAgICAgICBpZiAoY2hhbmdlID09PSB1bmRlZmluZWQgJiYgdGhpcy5fZXF1YWxpdHlDb21wYXJhdG9yKHRoaXMuX3ZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgX3R4O1xuICAgICAgICBpZiAoIXR4KSB7XG4gICAgICAgICAgICB0eCA9IF90eCA9IG5ldyBUcmFuc2FjdGlvbkltcGwoKCkgPT4geyB9LCAoKSA9PiBgU2V0dGluZyAke3RoaXMuZGVidWdOYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgZ2V0TG9nZ2VyKCk/LmhhbmRsZU9ic2VydmFibGVDaGFuZ2VkKHRoaXMsIHsgb2xkVmFsdWUsIG5ld1ZhbHVlOiB2YWx1ZSwgY2hhbmdlLCBkaWRDaGFuZ2U6IHRydWUsIGhhZFZhbHVlOiB0cnVlIH0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiB0aGlzLm9ic2VydmVycykge1xuICAgICAgICAgICAgICAgIHR4LnVwZGF0ZU9ic2VydmVyKG9ic2VydmVyLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5oYW5kbGVDaGFuZ2UodGhpcywgY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfdHgpIHtcbiAgICAgICAgICAgICAgICBfdHguZmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmRlYnVnTmFtZX06ICR7dGhpcy5fdmFsdWV9YDtcbiAgICB9XG4gICAgX3NldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBBIGRpc3Bvc2FibGUgb2JzZXJ2YWJsZS4gV2hlbiBkaXNwb3NlZCwgaXRzIHZhbHVlIGlzIGFsc28gZGlzcG9zZWQuXG4gKiBXaGVuIGEgbmV3IHZhbHVlIGlzIHNldCwgdGhlIHByZXZpb3VzIHZhbHVlIGlzIGRpc3Bvc2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzcG9zYWJsZU9ic2VydmFibGVWYWx1ZShuYW1lT3JPd25lciwgaW5pdGlhbFZhbHVlKSB7XG4gICAgbGV0IGRlYnVnTmFtZURhdGE7XG4gICAgaWYgKHR5cGVvZiBuYW1lT3JPd25lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGVidWdOYW1lRGF0YSA9IG5ldyBEZWJ1Z05hbWVEYXRhKHVuZGVmaW5lZCwgbmFtZU9yT3duZXIsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWJ1Z05hbWVEYXRhID0gbmV3IERlYnVnTmFtZURhdGEobmFtZU9yT3duZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEaXNwb3NhYmxlT2JzZXJ2YWJsZVZhbHVlKGRlYnVnTmFtZURhdGEsIGluaXRpYWxWYWx1ZSwgc3RyaWN0RXF1YWxzKTtcbn1cbmV4cG9ydCBjbGFzcyBEaXNwb3NhYmxlT2JzZXJ2YWJsZVZhbHVlIGV4dGVuZHMgT2JzZXJ2YWJsZVZhbHVlIHtcbiAgICBfc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlID09PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlPy5kaXNwb3NlKCk7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgY2xhc3MgRGVidWdOYW1lRGF0YSB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIGRlYnVnTmFtZVNvdXJjZSwgcmVmZXJlbmNlRm4pIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLmRlYnVnTmFtZVNvdXJjZSA9IGRlYnVnTmFtZVNvdXJjZTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VGbiA9IHJlZmVyZW5jZUZuO1xuICAgIH1cbiAgICBnZXREZWJ1Z05hbWUodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBnZXREZWJ1Z05hbWUodGFyZ2V0LCB0aGlzKTtcbiAgICB9XG59XG5jb25zdCBjb3VudFBlck5hbWUgPSBuZXcgTWFwKCk7XG5jb25zdCBjYWNoZWREZWJ1Z05hbWUgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlYnVnTmFtZSh0YXJnZXQsIGRhdGEpIHtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZWREZWJ1Z05hbWUuZ2V0KHRhcmdldCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBkYmdOYW1lID0gY29tcHV0ZURlYnVnTmFtZSh0YXJnZXQsIGRhdGEpO1xuICAgIGlmIChkYmdOYW1lKSB7XG4gICAgICAgIGxldCBjb3VudCA9IGNvdW50UGVyTmFtZS5nZXQoZGJnTmFtZSkgPz8gMDtcbiAgICAgICAgY291bnQrKztcbiAgICAgICAgY291bnRQZXJOYW1lLnNldChkYmdOYW1lLCBjb3VudCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvdW50ID09PSAxID8gZGJnTmFtZSA6IGAke2RiZ05hbWV9IyR7Y291bnR9YDtcbiAgICAgICAgY2FjaGVkRGVidWdOYW1lLnNldCh0YXJnZXQsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjb21wdXRlRGVidWdOYW1lKHNlbGYsIGRhdGEpIHtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZWREZWJ1Z05hbWUuZ2V0KHNlbGYpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3Qgb3duZXJTdHIgPSBkYXRhLm93bmVyID8gZm9ybWF0T3duZXIoZGF0YS5vd25lcikgKyBgLmAgOiAnJztcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IGRlYnVnTmFtZVNvdXJjZSA9IGRhdGEuZGVidWdOYW1lU291cmNlO1xuICAgIGlmIChkZWJ1Z05hbWVTb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGRlYnVnTmFtZVNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGVidWdOYW1lU291cmNlKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duZXJTdHIgKyByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3duZXJTdHIgKyBkZWJ1Z05hbWVTb3VyY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVmZXJlbmNlRm4gPSBkYXRhLnJlZmVyZW5jZUZuO1xuICAgIGlmIChyZWZlcmVuY2VGbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IGdldEZ1bmN0aW9uTmFtZShyZWZlcmVuY2VGbik7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG93bmVyU3RyICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLm93bmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZmluZEtleShkYXRhLm93bmVyLCBzZWxmKTtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb3duZXJTdHIgKyBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGZpbmRLZXkob2JqLCB2YWx1ZSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5jb25zdCBjb3VudFBlckNsYXNzTmFtZSA9IG5ldyBNYXAoKTtcbmNvbnN0IG93bmVySWQgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZm9ybWF0T3duZXIob3duZXIpIHtcbiAgICBjb25zdCBpZCA9IG93bmVySWQuZ2V0KG93bmVyKTtcbiAgICBpZiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc05hbWUgPSBnZXRDbGFzc05hbWUob3duZXIpO1xuICAgIGxldCBjb3VudCA9IGNvdW50UGVyQ2xhc3NOYW1lLmdldChjbGFzc05hbWUpID8/IDA7XG4gICAgY291bnQrKztcbiAgICBjb3VudFBlckNsYXNzTmFtZS5zZXQoY2xhc3NOYW1lLCBjb3VudCk7XG4gICAgY29uc3QgcmVzdWx0ID0gY291bnQgPT09IDEgPyBjbGFzc05hbWUgOiBgJHtjbGFzc05hbWV9IyR7Y291bnR9YDtcbiAgICBvd25lcklkLnNldChvd25lciwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKG9iaikge1xuICAgIGNvbnN0IGN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gICAgaWYgKGN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGN0b3IubmFtZTtcbiAgICB9XG4gICAgcmV0dXJuICdPYmplY3QnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuICAgIGNvbnN0IGZuU3JjID0gZm4udG9TdHJpbmcoKTtcbiAgICAvLyBQYXR0ZXJuOiAvKiogQGRlc2NyaXB0aW9uIC4uLiAqL1xuICAgIGNvbnN0IHJlZ2V4cCA9IC9cXC9cXCpcXCpcXHMqQGRlc2NyaXB0aW9uXFxzKihbXipdKilcXCpcXC8vO1xuICAgIGNvbnN0IG1hdGNoID0gcmVnZXhwLmV4ZWMoZm5TcmMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdD8udHJpbSgpO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBhc3NlcnRGbiB9IGZyb20gJy4uL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBzdHJpY3RFcXVhbHMgfSBmcm9tICcuLi9lcXVhbHMuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZVN0b3JlIH0gZnJvbSAnLi4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IEJhc2VPYnNlcnZhYmxlLCBfc2V0RGVyaXZlZE9wdHMgfSBmcm9tICcuL2Jhc2UuanMnO1xuaW1wb3J0IHsgRGVidWdOYW1lRGF0YSB9IGZyb20gJy4vZGVidWdOYW1lLmpzJztcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJy4vbG9nZ2luZy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZChjb21wdXRlRm5Pck93bmVyLCBjb21wdXRlRm4pIHtcbiAgICBpZiAoY29tcHV0ZUZuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXJpdmVkKG5ldyBEZWJ1Z05hbWVEYXRhKGNvbXB1dGVGbk9yT3duZXIsIHVuZGVmaW5lZCwgY29tcHV0ZUZuKSwgY29tcHV0ZUZuLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBzdHJpY3RFcXVhbHMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERlcml2ZWQobmV3IERlYnVnTmFtZURhdGEodW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbXB1dGVGbk9yT3duZXIpLCBjb21wdXRlRm5Pck93bmVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBzdHJpY3RFcXVhbHMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRXaXRoU2V0dGVyKG93bmVyLCBjb21wdXRlRm4sIHNldHRlcikge1xuICAgIHJldHVybiBuZXcgRGVyaXZlZFdpdGhTZXR0ZXIobmV3IERlYnVnTmFtZURhdGEob3duZXIsIHVuZGVmaW5lZCwgY29tcHV0ZUZuKSwgY29tcHV0ZUZuLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBzdHJpY3RFcXVhbHMsIHNldHRlcik7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZE9wdHMob3B0aW9ucywgY29tcHV0ZUZuKSB7XG4gICAgcmV0dXJuIG5ldyBEZXJpdmVkKG5ldyBEZWJ1Z05hbWVEYXRhKG9wdGlvbnMub3duZXIsIG9wdGlvbnMuZGVidWdOYW1lLCBvcHRpb25zLmRlYnVnUmVmZXJlbmNlRm4pLCBjb21wdXRlRm4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zLm9uTGFzdE9ic2VydmVyUmVtb3ZlZCwgb3B0aW9ucy5lcXVhbHNGbiA/PyBzdHJpY3RFcXVhbHMpO1xufVxuX3NldERlcml2ZWRPcHRzKGRlcml2ZWRPcHRzKTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBvYnNlcnZhYmxlIHRoYXQgaXMgZGVyaXZlZCBmcm9tIG90aGVyIG9ic2VydmFibGVzLlxuICogVGhlIHZhbHVlIGlzIG9ubHkgcmVjb21wdXRlZCB3aGVuIGFic29sdXRlbHkgbmVlZGVkLlxuICpcbiAqIHtAbGluayBjb21wdXRlRm59IHNob3VsZCBzdGFydCB3aXRoIGEgSlMgRG9jIHVzaW5nIGBAZGVzY3JpcHRpb25gIHRvIG5hbWUgdGhlIGRlcml2ZWQuXG4gKlxuICogVXNlIGBjcmVhdGVFbXB0eUNoYW5nZVN1bW1hcnlgIHRvIGNyZWF0ZSBhIFwiY2hhbmdlIHN1bW1hcnlcIiB0aGF0IGNhbiBjb2xsZWN0IHRoZSBjaGFuZ2VzLlxuICogVXNlIGBoYW5kbGVDaGFuZ2VgIHRvIGFkZCBhIHJlcG9ydGVkIGNoYW5nZSB0byB0aGUgY2hhbmdlIHN1bW1hcnkuXG4gKiBUaGUgY29tcHV0ZSBmdW5jdGlvbiBpcyBnaXZlbiB0aGUgbGFzdCBjaGFuZ2Ugc3VtbWFyeS5cbiAqIFRoZSBjaGFuZ2Ugc3VtbWFyeSBpcyBkaXNjYXJkZWQgYWZ0ZXIgdGhlIGNvbXB1dGUgZnVuY3Rpb24gd2FzIGNhbGxlZC5cbiAqXG4gKiBAc2VlIGRlcml2ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRIYW5kbGVDaGFuZ2VzKG9wdGlvbnMsIGNvbXB1dGVGbikge1xuICAgIHJldHVybiBuZXcgRGVyaXZlZChuZXcgRGVidWdOYW1lRGF0YShvcHRpb25zLm93bmVyLCBvcHRpb25zLmRlYnVnTmFtZSwgdW5kZWZpbmVkKSwgY29tcHV0ZUZuLCBvcHRpb25zLmNyZWF0ZUVtcHR5Q2hhbmdlU3VtbWFyeSwgb3B0aW9ucy5oYW5kbGVDaGFuZ2UsIHVuZGVmaW5lZCwgb3B0aW9ucy5lcXVhbGl0eUNvbXBhcmVyID8/IHN0cmljdEVxdWFscyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZFdpdGhTdG9yZShjb21wdXRlRm5Pck93bmVyLCBjb21wdXRlRm5PclVuZGVmaW5lZCkge1xuICAgIGxldCBjb21wdXRlRm47XG4gICAgbGV0IG93bmVyO1xuICAgIGlmIChjb21wdXRlRm5PclVuZGVmaW5lZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXB1dGVGbiA9IGNvbXB1dGVGbk9yT3duZXI7XG4gICAgICAgIG93bmVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3duZXIgPSBjb21wdXRlRm5Pck93bmVyO1xuICAgICAgICBjb21wdXRlRm4gPSBjb21wdXRlRm5PclVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmUgPSBuZXcgRGlzcG9zYWJsZVN0b3JlKCk7XG4gICAgcmV0dXJuIG5ldyBEZXJpdmVkKG5ldyBEZWJ1Z05hbWVEYXRhKG93bmVyLCB1bmRlZmluZWQsIGNvbXB1dGVGbiksIHIgPT4ge1xuICAgICAgICBzdG9yZS5jbGVhcigpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZUZuKHIsIHN0b3JlKTtcbiAgICB9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgKCkgPT4gc3RvcmUuZGlzcG9zZSgpLCBzdHJpY3RFcXVhbHMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWREaXNwb3NhYmxlKGNvbXB1dGVGbk9yT3duZXIsIGNvbXB1dGVGbk9yVW5kZWZpbmVkKSB7XG4gICAgbGV0IGNvbXB1dGVGbjtcbiAgICBsZXQgb3duZXI7XG4gICAgaWYgKGNvbXB1dGVGbk9yVW5kZWZpbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcHV0ZUZuID0gY29tcHV0ZUZuT3JPd25lcjtcbiAgICAgICAgb3duZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvd25lciA9IGNvbXB1dGVGbk9yT3duZXI7XG4gICAgICAgIGNvbXB1dGVGbiA9IGNvbXB1dGVGbk9yVW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgc3RvcmUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG5ldyBEZXJpdmVkKG5ldyBEZWJ1Z05hbWVEYXRhKG93bmVyLCB1bmRlZmluZWQsIGNvbXB1dGVGbiksIHIgPT4ge1xuICAgICAgICBpZiAoIXN0b3JlKSB7XG4gICAgICAgICAgICBzdG9yZSA9IG5ldyBEaXNwb3NhYmxlU3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0b3JlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcHV0ZUZuKHIpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBzdG9yZS5hZGQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAoKSA9PiB7XG4gICAgICAgIGlmIChzdG9yZSkge1xuICAgICAgICAgICAgc3RvcmUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgc3RvcmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9LCBzdHJpY3RFcXVhbHMpO1xufVxuZXhwb3J0IGNsYXNzIERlcml2ZWQgZXh0ZW5kcyBCYXNlT2JzZXJ2YWJsZSB7XG4gICAgZ2V0IGRlYnVnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYnVnTmFtZURhdGEuZ2V0RGVidWdOYW1lKHRoaXMpID8/ICcoYW5vbnltb3VzKSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9kZWJ1Z05hbWVEYXRhLCBfY29tcHV0ZUZuLCBjcmVhdGVDaGFuZ2VTdW1tYXJ5LCBfaGFuZGxlQ2hhbmdlLCBfaGFuZGxlTGFzdE9ic2VydmVyUmVtb3ZlZCA9IHVuZGVmaW5lZCwgX2VxdWFsaXR5Q29tcGFyYXRvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9kZWJ1Z05hbWVEYXRhID0gX2RlYnVnTmFtZURhdGE7XG4gICAgICAgIHRoaXMuX2NvbXB1dGVGbiA9IF9jb21wdXRlRm47XG4gICAgICAgIHRoaXMuY3JlYXRlQ2hhbmdlU3VtbWFyeSA9IGNyZWF0ZUNoYW5nZVN1bW1hcnk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUNoYW5nZSA9IF9oYW5kbGVDaGFuZ2U7XG4gICAgICAgIHRoaXMuX2hhbmRsZUxhc3RPYnNlcnZlclJlbW92ZWQgPSBfaGFuZGxlTGFzdE9ic2VydmVyUmVtb3ZlZDtcbiAgICAgICAgdGhpcy5fZXF1YWxpdHlDb21wYXJhdG9yID0gX2VxdWFsaXR5Q29tcGFyYXRvcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDAgLyogRGVyaXZlZFN0YXRlLmluaXRpYWwgKi87XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudXBkYXRlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXNUb0JlUmVtb3ZlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VTdW1tYXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNoYW5nZVN1bW1hcnkgPSB0aGlzLmNyZWF0ZUNoYW5nZVN1bW1hcnk/LigpO1xuICAgICAgICBnZXRMb2dnZXIoKT8uaGFuZGxlRGVyaXZlZENyZWF0ZWQodGhpcyk7XG4gICAgfVxuICAgIG9uTGFzdE9ic2VydmVyUmVtb3ZlZCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGFyZSBub3QgdHJhY2tpbmcgY2hhbmdlcyBhbnltb3JlLCB0aHVzIHdlIGhhdmUgdG8gYXNzdW1lXG4gICAgICAgICAqIHRoYXQgb3VyIGNhY2hlIGlzIGludmFsaWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBEZXJpdmVkU3RhdGUuaW5pdGlhbCAqLztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBkLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUxhc3RPYnNlcnZlclJlbW92ZWQ/LigpO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXaXRob3V0IG9ic2VydmVycywgd2UgZG9uJ3Qga25vdyB3aGVuIHRvIGNsZWFuIHVwIHN0dWZmLlxuICAgICAgICAgICAgLy8gVGh1cywgd2UgZG9uJ3QgY2FjaGUgYW55dGhpbmcgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jb21wdXRlRm4odGhpcywgdGhpcy5jcmVhdGVDaGFuZ2VTdW1tYXJ5Py4oKSk7XG4gICAgICAgICAgICAvLyBDbGVhciBuZXcgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICB0aGlzLm9uTGFzdE9ic2VydmVyUmVtb3ZlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBtaWdodCBub3QgZ2V0IGEgbm90aWZpY2F0aW9uIGZvciBhIGRlcGVuZGVuY3kgdGhhdCBjaGFuZ2VkIHdoaWxlIGl0IGlzIHVwZGF0aW5nLFxuICAgICAgICAgICAgICAgIC8vIHRodXMgd2UgYWxzbyBoYXZlIHRvIGFzayBhbGwgb3VyIGRlcGVkZW5jaWVzIGlmIHRoZXkgY2hhbmdlZCBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDEgLyogRGVyaXZlZFN0YXRlLmRlcGVuZGVuY2llc01pZ2h0SGF2ZUNoYW5nZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogbWlnaHQgY2FsbCB7QGxpbmsgaGFuZGxlQ2hhbmdlfSBpbmRpcmVjdGx5LCB3aGljaCBjb3VsZCBtYWtlIHVzIHN0YWxlICovXG4gICAgICAgICAgICAgICAgICAgICAgICBkLnJlcG9ydENoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAyIC8qIERlcml2ZWRTdGF0ZS5zdGFsZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvdGhlciBkZXBlbmRlbmNpZXMgd2lsbCByZWZyZXNoIG9uIGRlbWFuZCwgc28gZWFybHkgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBjYWxsZWQgcmVwb3J0IGNoYW5nZXMgb2YgYWxsIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc3RpbGwgbm90IHN0YWxlLCB3ZSBjYW4gYXNzdW1lIHRvIGJlIHVwIHRvIGRhdGUgYWdhaW4uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDEgLyogRGVyaXZlZFN0YXRlLmRlcGVuZGVuY2llc01pZ2h0SGF2ZUNoYW5nZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMgLyogRGVyaXZlZFN0YXRlLnVwVG9EYXRlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNvbXB1dGVJZk5lZWRlZCgpO1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgcmVjb21wdXRhdGlvbiBjaGFuZ2VkIG9uZSBvZiBvdXIgZGVwZW5kZW5jaWVzLCB3ZSBuZWVkIHRvIHJlY29tcHV0ZSBhZ2Fpbi5cbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuc3RhdGUgIT09IDMgLyogRGVyaXZlZFN0YXRlLnVwVG9EYXRlICovKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZWNvbXB1dGVJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDMgLyogRGVyaXZlZFN0YXRlLnVwVG9EYXRlICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1wdHlTZXQgPSB0aGlzLmRlcGVuZGVuY2llc1RvQmVSZW1vdmVkO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llc1RvQmVSZW1vdmVkID0gdGhpcy5kZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZW1wdHlTZXQ7XG4gICAgICAgIGNvbnN0IGhhZFZhbHVlID0gdGhpcy5zdGF0ZSAhPT0gMCAvKiBEZXJpdmVkU3RhdGUuaW5pdGlhbCAqLztcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnN0YXRlID0gMyAvKiBEZXJpdmVkU3RhdGUudXBUb0RhdGUgKi87XG4gICAgICAgIGNvbnN0IGNoYW5nZVN1bW1hcnkgPSB0aGlzLmNoYW5nZVN1bW1hcnk7XG4gICAgICAgIHRoaXMuY2hhbmdlU3VtbWFyeSA9IHRoaXMuY3JlYXRlQ2hhbmdlU3VtbWFyeT8uKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvKiogbWlnaHQgY2FsbCB7QGxpbmsgaGFuZGxlQ2hhbmdlfSBpbmRpcmVjdGx5LCB3aGljaCBjb3VsZCBpbnZhbGlkYXRlIHVzICovXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5fY29tcHV0ZUZuKHRoaXMsIGNoYW5nZVN1bW1hcnkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCBvdXIgb2JzZXJ2ZWQgb2JzZXJ2YWJsZXMgdG8gdGhpbmsgdGhhdCB0aGV5IGFyZSAobm90IGV2ZW4gdGVtcG9yYXJpbHkpIG5vdCBiZWluZyBvYnNlcnZlZC5cbiAgICAgICAgICAgIC8vIFRodXMsIHdlIG9ubHkgdW5zdWJzY3JpYmUgZnJvbSBvYnNlcnZhYmxlcyB0aGF0IGFyZSBkZWZpbml0ZWx5IG5vdCByZWFkIGFueW1vcmUuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG8gb2YgdGhpcy5kZXBlbmRlbmNpZXNUb0JlUmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIG8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVuY2llc1RvQmVSZW1vdmVkLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlkQ2hhbmdlID0gaGFkVmFsdWUgJiYgISh0aGlzLl9lcXVhbGl0eUNvbXBhcmF0b3Iob2xkVmFsdWUsIHRoaXMudmFsdWUpKTtcbiAgICAgICAgZ2V0TG9nZ2VyKCk/LmhhbmRsZURlcml2ZWRSZWNvbXB1dGVkKHRoaXMsIHtcbiAgICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgICAgbmV3VmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBjaGFuZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRpZENoYW5nZSxcbiAgICAgICAgICAgIGhhZFZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgci5oYW5kbGVDaGFuZ2UodGhpcywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBMYXp5RGVyaXZlZDwke3RoaXMuZGVidWdOYW1lfT5gO1xuICAgIH1cbiAgICAvLyBJT2JzZXJ2ZXIgSW1wbGVtZW50YXRpb25cbiAgICBiZWdpblVwZGF0ZShfb2JzZXJ2YWJsZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvdW50Kys7XG4gICAgICAgIGNvbnN0IHByb3BhZ2F0ZUJlZ2luVXBkYXRlID0gdGhpcy51cGRhdGVDb3VudCA9PT0gMTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDMgLyogRGVyaXZlZFN0YXRlLnVwVG9EYXRlICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMSAvKiBEZXJpdmVkU3RhdGUuZGVwZW5kZW5jaWVzTWlnaHRIYXZlQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIC8vIElmIHdlIHByb3BhZ2F0ZSBiZWdpbiB1cGRhdGUsIHRoYXQgd2lsbCBhbHJlYWR5IHNpZ25hbCBhIHBvc3NpYmxlIGNoYW5nZS5cbiAgICAgICAgICAgIGlmICghcHJvcGFnYXRlQmVnaW5VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgci5oYW5kbGVQb3NzaWJsZUNoYW5nZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BhZ2F0ZUJlZ2luVXBkYXRlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICByLmJlZ2luVXBkYXRlKHRoaXMpOyAvLyBUaGlzIHNpZ25hbHMgYSBwb3NzaWJsZSBjaGFuZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmRVcGRhdGUoX29ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb3VudC0tO1xuICAgICAgICBpZiAodGhpcy51cGRhdGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRW5kIHVwZGF0ZSBjb3VsZCBjaGFuZ2UgdGhlIG9ic2VydmVyIGxpc3QuXG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlcnMgPSBbLi4udGhpcy5vYnNlcnZlcnNdO1xuICAgICAgICAgICAgZm9yIChjb25zdCByIG9mIG9ic2VydmVycykge1xuICAgICAgICAgICAgICAgIHIuZW5kVXBkYXRlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydEZuKCgpID0+IHRoaXMudXBkYXRlQ291bnQgPj0gMCk7XG4gICAgfVxuICAgIGhhbmRsZVBvc3NpYmxlQ2hhbmdlKG9ic2VydmFibGUpIHtcbiAgICAgICAgLy8gSW4gYWxsIG90aGVyIHN0YXRlcywgb2JzZXJ2ZXJzIGFscmVhZHkga25vdyB0aGF0IHdlIG1pZ2h0IGhhdmUgY2hhbmdlZC5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDMgLyogRGVyaXZlZFN0YXRlLnVwVG9EYXRlICovICYmIHRoaXMuZGVwZW5kZW5jaWVzLmhhcyhvYnNlcnZhYmxlKSAmJiAhdGhpcy5kZXBlbmRlbmNpZXNUb0JlUmVtb3ZlZC5oYXMob2JzZXJ2YWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxIC8qIERlcml2ZWRTdGF0ZS5kZXBlbmRlbmNpZXNNaWdodEhhdmVDaGFuZ2VkICovO1xuICAgICAgICAgICAgZm9yIChjb25zdCByIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgci5oYW5kbGVQb3NzaWJsZUNoYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2Uob2JzZXJ2YWJsZSwgY2hhbmdlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY2llcy5oYXMob2JzZXJ2YWJsZSkgJiYgIXRoaXMuZGVwZW5kZW5jaWVzVG9CZVJlbW92ZWQuaGFzKG9ic2VydmFibGUpKSB7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZWFjdCA9IHRoaXMuX2hhbmRsZUNoYW5nZSA/IHRoaXMuX2hhbmRsZUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgY2hhbmdlZE9ic2VydmFibGU6IG9ic2VydmFibGUsXG4gICAgICAgICAgICAgICAgY2hhbmdlLFxuICAgICAgICAgICAgICAgIGRpZENoYW5nZTogKG8pID0+IG8gPT09IG9ic2VydmFibGUsXG4gICAgICAgICAgICB9LCB0aGlzLmNoYW5nZVN1bW1hcnkpIDogdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHdhc1VwVG9EYXRlID0gdGhpcy5zdGF0ZSA9PT0gMyAvKiBEZXJpdmVkU3RhdGUudXBUb0RhdGUgKi87XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVhY3QgJiYgKHRoaXMuc3RhdGUgPT09IDEgLyogRGVyaXZlZFN0YXRlLmRlcGVuZGVuY2llc01pZ2h0SGF2ZUNoYW5nZWQgKi8gfHwgd2FzVXBUb0RhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIgLyogRGVyaXZlZFN0YXRlLnN0YWxlICovO1xuICAgICAgICAgICAgICAgIGlmICh3YXNVcFRvRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuaGFuZGxlUG9zc2libGVDaGFuZ2UodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSVJlYWRlciBJbXBsZW1lbnRhdGlvblxuICAgIHJlYWRPYnNlcnZhYmxlKG9ic2VydmFibGUpIHtcbiAgICAgICAgLy8gU3Vic2NyaWJlIGJlZm9yZSBnZXR0aW5nIHRoZSB2YWx1ZSB0byBlbmFibGUgY2FjaGluZ1xuICAgICAgICBvYnNlcnZhYmxlLmFkZE9ic2VydmVyKHRoaXMpO1xuICAgICAgICAvKiogVGhpcyBtaWdodCBjYWxsIHtAbGluayBoYW5kbGVDaGFuZ2V9IGluZGlyZWN0bHksIHdoaWNoIGNvdWxkIGludmFsaWRhdGUgdXMgKi9cbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYnNlcnZhYmxlLmdldCgpO1xuICAgICAgICAvLyBXaGljaCBpcyB3aHkgd2Ugb25seSBhZGQgdGhlIG9ic2VydmFibGUgdG8gdGhlIGRlcGVuZGVuY2llcyBub3cuXG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLmFkZChvYnNlcnZhYmxlKTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXNUb0JlUmVtb3ZlZC5kZWxldGUob2JzZXJ2YWJsZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ2FsbEJlZ2luVXBkYXRlID0gIXRoaXMub2JzZXJ2ZXJzLmhhcyhvYnNlcnZlcikgJiYgdGhpcy51cGRhdGVDb3VudCA+IDA7XG4gICAgICAgIHN1cGVyLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgaWYgKHNob3VsZENhbGxCZWdpblVwZGF0ZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuYmVnaW5VcGRhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ2FsbEVuZFVwZGF0ZSA9IHRoaXMub2JzZXJ2ZXJzLmhhcyhvYnNlcnZlcikgJiYgdGhpcy51cGRhdGVDb3VudCA+IDA7XG4gICAgICAgIHN1cGVyLnJlbW92ZU9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgaWYgKHNob3VsZENhbGxFbmRVcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgZW5kIHVwZGF0ZSBhZnRlciByZW1vdmluZyB0aGUgb2JzZXJ2ZXIgbWFrZXMgc3VyZSBlbmRVcGRhdGUgY2Fubm90IGJlIGNhbGxlZCB0d2ljZSBoZXJlLlxuICAgICAgICAgICAgb2JzZXJ2ZXIuZW5kVXBkYXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIERlcml2ZWRXaXRoU2V0dGVyIGV4dGVuZHMgRGVyaXZlZCB7XG4gICAgY29uc3RydWN0b3IoZGVidWdOYW1lRGF0YSwgY29tcHV0ZUZuLCBjcmVhdGVDaGFuZ2VTdW1tYXJ5LCBoYW5kbGVDaGFuZ2UsIGhhbmRsZUxhc3RPYnNlcnZlclJlbW92ZWQgPSB1bmRlZmluZWQsIGVxdWFsaXR5Q29tcGFyYXRvciwgc2V0KSB7XG4gICAgICAgIHN1cGVyKGRlYnVnTmFtZURhdGEsIGNvbXB1dGVGbiwgY3JlYXRlQ2hhbmdlU3VtbWFyeSwgaGFuZGxlQ2hhbmdlLCBoYW5kbGVMYXN0T2JzZXJ2ZXJSZW1vdmVkLCBlcXVhbGl0eUNvbXBhcmF0b3IpO1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEJhc2VPYnNlcnZhYmxlLCBUcmFuc2FjdGlvbkltcGwgfSBmcm9tICcuL2Jhc2UuanMnO1xuLyoqXG4gKiBIb2xkcyBvZmYgdXBkYXRpbmcgb2JzZXJ2ZXJzIHVudGlsIHRoZSB2YWx1ZSBpcyBhY3R1YWxseSByZWFkLlxuKi9cbmV4cG9ydCBjbGFzcyBMYXp5T2JzZXJ2YWJsZVZhbHVlIGV4dGVuZHMgQmFzZU9ic2VydmFibGUge1xuICAgIGdldCBkZWJ1Z05hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJ1Z05hbWVEYXRhLmdldERlYnVnTmFtZSh0aGlzKSA/PyAnTGF6eU9ic2VydmFibGVWYWx1ZSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9kZWJ1Z05hbWVEYXRhLCBpbml0aWFsVmFsdWUsIF9lcXVhbGl0eUNvbXBhcmF0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZGVidWdOYW1lRGF0YSA9IF9kZWJ1Z05hbWVEYXRhO1xuICAgICAgICB0aGlzLl9lcXVhbGl0eUNvbXBhcmF0b3IgPSBfZXF1YWxpdHlDb21wYXJhdG9yO1xuICAgICAgICB0aGlzLl9pc1VwVG9EYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGVsdGFzID0gW107XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBfdXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5faXNVcFRvRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzVXBUb0RhdGUgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fZGVsdGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiB0aGlzLl9kZWx0YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuaGFuZGxlQ2hhbmdlKHRoaXMsIGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsdGFzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuaGFuZGxlQ2hhbmdlKHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2JlZ2luVXBkYXRlKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVDb3VudGVyKys7XG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVDb3VudGVyID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuYmVnaW5VcGRhdGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2VuZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ291bnRlci0tO1xuICAgICAgICBpZiAodGhpcy5fdXBkYXRlQ291bnRlciA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICAvLyBFbmQgdXBkYXRlIGNvdWxkIGNoYW5nZSB0aGUgb2JzZXJ2ZXIgbGlzdC5cbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVycyA9IFsuLi50aGlzLm9ic2VydmVyc107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2Ygb2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgci5lbmRVcGRhdGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ2FsbEJlZ2luVXBkYXRlID0gIXRoaXMub2JzZXJ2ZXJzLmhhcyhvYnNlcnZlcikgJiYgdGhpcy5fdXBkYXRlQ291bnRlciA+IDA7XG4gICAgICAgIHN1cGVyLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgaWYgKHNob3VsZENhbGxCZWdpblVwZGF0ZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuYmVnaW5VcGRhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ2FsbEVuZFVwZGF0ZSA9IHRoaXMub2JzZXJ2ZXJzLmhhcyhvYnNlcnZlcikgJiYgdGhpcy5fdXBkYXRlQ291bnRlciA+IDA7XG4gICAgICAgIHN1cGVyLnJlbW92ZU9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgaWYgKHNob3VsZENhbGxFbmRVcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgZW5kIHVwZGF0ZSBhZnRlciByZW1vdmluZyB0aGUgb2JzZXJ2ZXIgbWFrZXMgc3VyZSBlbmRVcGRhdGUgY2Fubm90IGJlIGNhbGxlZCB0d2ljZSBoZXJlLlxuICAgICAgICAgICAgb2JzZXJ2ZXIuZW5kVXBkYXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCh2YWx1ZSwgdHgsIGNoYW5nZSkge1xuICAgICAgICBpZiAoY2hhbmdlID09PSB1bmRlZmluZWQgJiYgdGhpcy5fZXF1YWxpdHlDb21wYXJhdG9yKHRoaXMuX3ZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgX3R4O1xuICAgICAgICBpZiAoIXR4KSB7XG4gICAgICAgICAgICB0eCA9IF90eCA9IG5ldyBUcmFuc2FjdGlvbkltcGwoKCkgPT4geyB9LCAoKSA9PiBgU2V0dGluZyAke3RoaXMuZGVidWdOYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9pc1VwVG9EYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWx0YXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHgudXBkYXRlT2JzZXJ2ZXIoe1xuICAgICAgICAgICAgICAgIGJlZ2luVXBkYXRlOiAoKSA9PiB0aGlzLl9iZWdpblVwZGF0ZSgpLFxuICAgICAgICAgICAgICAgIGVuZFVwZGF0ZTogKCkgPT4gdGhpcy5fZW5kVXBkYXRlKCksXG4gICAgICAgICAgICAgICAgaGFuZGxlQ2hhbmdlOiAob2JzZXJ2YWJsZSwgY2hhbmdlKSA9PiB7IH0sXG4gICAgICAgICAgICAgICAgaGFuZGxlUG9zc2libGVDaGFuZ2U6IChvYnNlcnZhYmxlKSA9PiB7IH0sXG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl91cGRhdGVDb3VudGVyID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgc3RhcnRlZCBiZWdpbi9lbmQgdXBkYXRlLCBzbyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNhbGwgaGFuZGxlUG9zc2libGVDaGFuZ2VcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmhhbmRsZVBvc3NpYmxlQ2hhbmdlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfdHgpIHtcbiAgICAgICAgICAgICAgICBfdHguZmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmRlYnVnTmFtZX06ICR7dGhpcy5fdmFsdWV9YDtcbiAgICB9XG4gICAgX3NldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5sZXQgZ2xvYmFsT2JzZXJ2YWJsZUxvZ2dlcjtcbmV4cG9ydCBmdW5jdGlvbiBzZXRMb2dnZXIobG9nZ2VyKSB7XG4gICAgZ2xvYmFsT2JzZXJ2YWJsZUxvZ2dlciA9IGxvZ2dlcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dnZXIoKSB7XG4gICAgcmV0dXJuIGdsb2JhbE9ic2VydmFibGVMb2dnZXI7XG59XG5leHBvcnQgY2xhc3MgQ29uc29sZU9ic2VydmFibGVMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluZGVudGF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5jaGFuZ2VkT2JzZXJ2YWJsZXNTZXRzID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgdGV4dFRvQ29uc29sZUFyZ3ModGV4dCkge1xuICAgICAgICByZXR1cm4gY29uc29sZVRleHRUb0FyZ3MoW1xuICAgICAgICAgICAgbm9ybWFsVGV4dChyZXBlYXQoJ3wgICcsIHRoaXMuaW5kZW50YXRpb24pKSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBmb3JtYXRJbmZvKGluZm8pIHtcbiAgICAgICAgaWYgKCFpbmZvLmhhZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5vcm1hbFRleHQoYCBgKSxcbiAgICAgICAgICAgICAgICBzdHlsZWQoZm9ybWF0VmFsdWUoaW5mby5uZXdWYWx1ZSwgNjApLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnZ3JlZW4nLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5vcm1hbFRleHQoYCAoaW5pdGlhbClgKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZm8uZGlkQ2hhbmdlXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICBub3JtYWxUZXh0KGAgYCksXG4gICAgICAgICAgICAgICAgc3R5bGVkKGZvcm1hdFZhbHVlKGluZm8ub2xkVmFsdWUsIDcwKSwge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgIHN0cmlrZVRocm91Z2g6IHRydWUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbm9ybWFsVGV4dChgIGApLFxuICAgICAgICAgICAgICAgIHN0eWxlZChmb3JtYXRWYWx1ZShpbmZvLm5ld1ZhbHVlLCA2MCksIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdncmVlbicsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtub3JtYWxUZXh0KGAgKHVuY2hhbmdlZClgKV07XG4gICAgfVxuICAgIGhhbmRsZU9ic2VydmFibGVDaGFuZ2VkKG9ic2VydmFibGUsIGluZm8pIHtcbiAgICAgICAgY29uc29sZS5sb2coLi4udGhpcy50ZXh0VG9Db25zb2xlQXJncyhbXG4gICAgICAgICAgICBmb3JtYXRLaW5kKCdvYnNlcnZhYmxlIHZhbHVlIGNoYW5nZWQnKSxcbiAgICAgICAgICAgIHN0eWxlZChvYnNlcnZhYmxlLmRlYnVnTmFtZSwgeyBjb2xvcjogJ0JsdWVWaW9sZXQnIH0pLFxuICAgICAgICAgICAgLi4udGhpcy5mb3JtYXRJbmZvKGluZm8pLFxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIGZvcm1hdENoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZWQoJyAoY2hhbmdlZCBkZXBzOiAnICtcbiAgICAgICAgICAgIFsuLi5jaGFuZ2VzXS5tYXAoKG8pID0+IG8uZGVidWdOYW1lKS5qb2luKCcsICcpICtcbiAgICAgICAgICAgICcpJywgeyBjb2xvcjogJ2dyYXknIH0pO1xuICAgIH1cbiAgICBoYW5kbGVEZXJpdmVkQ3JlYXRlZChkZXJpdmVkKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSGFuZGxlQ2hhbmdlID0gZGVyaXZlZC5oYW5kbGVDaGFuZ2U7XG4gICAgICAgIHRoaXMuY2hhbmdlZE9ic2VydmFibGVzU2V0cy5zZXQoZGVyaXZlZCwgbmV3IFNldCgpKTtcbiAgICAgICAgZGVyaXZlZC5oYW5kbGVDaGFuZ2UgPSAob2JzZXJ2YWJsZSwgY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRPYnNlcnZhYmxlc1NldHMuZ2V0KGRlcml2ZWQpLmFkZChvYnNlcnZhYmxlKTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0hhbmRsZUNoYW5nZS5hcHBseShkZXJpdmVkLCBbb2JzZXJ2YWJsZSwgY2hhbmdlXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGhhbmRsZURlcml2ZWRSZWNvbXB1dGVkKGRlcml2ZWQsIGluZm8pIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZE9ic2VydmFibGVzID0gdGhpcy5jaGFuZ2VkT2JzZXJ2YWJsZXNTZXRzLmdldChkZXJpdmVkKTtcbiAgICAgICAgY29uc29sZS5sb2coLi4udGhpcy50ZXh0VG9Db25zb2xlQXJncyhbXG4gICAgICAgICAgICBmb3JtYXRLaW5kKCdkZXJpdmVkIHJlY29tcHV0ZWQnKSxcbiAgICAgICAgICAgIHN0eWxlZChkZXJpdmVkLmRlYnVnTmFtZSwgeyBjb2xvcjogJ0JsdWVWaW9sZXQnIH0pLFxuICAgICAgICAgICAgLi4udGhpcy5mb3JtYXRJbmZvKGluZm8pLFxuICAgICAgICAgICAgdGhpcy5mb3JtYXRDaGFuZ2VzKGNoYW5nZWRPYnNlcnZhYmxlcyksXG4gICAgICAgICAgICB7IGRhdGE6IFt7IGZuOiBkZXJpdmVkLl9kZWJ1Z05hbWVEYXRhLnJlZmVyZW5jZUZuID8/IGRlcml2ZWQuX2NvbXB1dGVGbiB9XSB9XG4gICAgICAgIF0pKTtcbiAgICAgICAgY2hhbmdlZE9ic2VydmFibGVzLmNsZWFyKCk7XG4gICAgfVxuICAgIGhhbmRsZUZyb21FdmVudE9ic2VydmFibGVUcmlnZ2VyZWQob2JzZXJ2YWJsZSwgaW5mbykge1xuICAgICAgICBjb25zb2xlLmxvZyguLi50aGlzLnRleHRUb0NvbnNvbGVBcmdzKFtcbiAgICAgICAgICAgIGZvcm1hdEtpbmQoJ29ic2VydmFibGUgZnJvbSBldmVudCB0cmlnZ2VyZWQnKSxcbiAgICAgICAgICAgIHN0eWxlZChvYnNlcnZhYmxlLmRlYnVnTmFtZSwgeyBjb2xvcjogJ0JsdWVWaW9sZXQnIH0pLFxuICAgICAgICAgICAgLi4udGhpcy5mb3JtYXRJbmZvKGluZm8pLFxuICAgICAgICAgICAgeyBkYXRhOiBbeyBmbjogb2JzZXJ2YWJsZS5fZ2V0VmFsdWUgfV0gfVxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIGhhbmRsZUF1dG9ydW5DcmVhdGVkKGF1dG9ydW4pIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdIYW5kbGVDaGFuZ2UgPSBhdXRvcnVuLmhhbmRsZUNoYW5nZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkT2JzZXJ2YWJsZXNTZXRzLnNldChhdXRvcnVuLCBuZXcgU2V0KCkpO1xuICAgICAgICBhdXRvcnVuLmhhbmRsZUNoYW5nZSA9IChvYnNlcnZhYmxlLCBjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZE9ic2VydmFibGVzU2V0cy5nZXQoYXV0b3J1bikuYWRkKG9ic2VydmFibGUpO1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSGFuZGxlQ2hhbmdlLmFwcGx5KGF1dG9ydW4sIFtvYnNlcnZhYmxlLCBjaGFuZ2VdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaGFuZGxlQXV0b3J1blRyaWdnZXJlZChhdXRvcnVuKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRPYnNlcnZhYmxlcyA9IHRoaXMuY2hhbmdlZE9ic2VydmFibGVzU2V0cy5nZXQoYXV0b3J1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKC4uLnRoaXMudGV4dFRvQ29uc29sZUFyZ3MoW1xuICAgICAgICAgICAgZm9ybWF0S2luZCgnYXV0b3J1bicpLFxuICAgICAgICAgICAgc3R5bGVkKGF1dG9ydW4uZGVidWdOYW1lLCB7IGNvbG9yOiAnQmx1ZVZpb2xldCcgfSksXG4gICAgICAgICAgICB0aGlzLmZvcm1hdENoYW5nZXMoY2hhbmdlZE9ic2VydmFibGVzKSxcbiAgICAgICAgICAgIHsgZGF0YTogW3sgZm46IGF1dG9ydW4uX2RlYnVnTmFtZURhdGEucmVmZXJlbmNlRm4gPz8gYXV0b3J1bi5fcnVuRm4gfV0gfVxuICAgICAgICBdKSk7XG4gICAgICAgIGNoYW5nZWRPYnNlcnZhYmxlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmluZGVudGF0aW9uKys7XG4gICAgfVxuICAgIGhhbmRsZUF1dG9ydW5GaW5pc2hlZChhdXRvcnVuKSB7XG4gICAgICAgIHRoaXMuaW5kZW50YXRpb24tLTtcbiAgICB9XG4gICAgaGFuZGxlQmVnaW5UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICBsZXQgdHJhbnNhY3Rpb25OYW1lID0gdHJhbnNhY3Rpb24uZ2V0RGVidWdOYW1lKCk7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25OYW1lID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coLi4udGhpcy50ZXh0VG9Db25zb2xlQXJncyhbXG4gICAgICAgICAgICBmb3JtYXRLaW5kKCd0cmFuc2FjdGlvbicpLFxuICAgICAgICAgICAgc3R5bGVkKHRyYW5zYWN0aW9uTmFtZSwgeyBjb2xvcjogJ0JsdWVWaW9sZXQnIH0pLFxuICAgICAgICAgICAgeyBkYXRhOiBbeyBmbjogdHJhbnNhY3Rpb24uX2ZuIH1dIH1cbiAgICAgICAgXSkpO1xuICAgICAgICB0aGlzLmluZGVudGF0aW9uKys7XG4gICAgfVxuICAgIGhhbmRsZUVuZFRyYW5zYWN0aW9uKCkge1xuICAgICAgICB0aGlzLmluZGVudGF0aW9uLS07XG4gICAgfVxufVxuZnVuY3Rpb24gY29uc29sZVRleHRUb0FyZ3ModGV4dCkge1xuICAgIGNvbnN0IHN0eWxlcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICBsZXQgZmlyc3RBcmcgPSAnJztcbiAgICBmdW5jdGlvbiBwcm9jZXNzKHQpIHtcbiAgICAgICAgaWYgKCdsZW5ndGgnIGluIHQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyhpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3RleHQnIGluIHQpIHtcbiAgICAgICAgICAgIGZpcnN0QXJnICs9IGAlYyR7dC50ZXh0fWA7XG4gICAgICAgICAgICBzdHlsZXMucHVzaCh0LnN0eWxlKTtcbiAgICAgICAgICAgIGlmICh0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goLi4udC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnZGF0YScgaW4gdCkge1xuICAgICAgICAgICAgZGF0YS5wdXNoKC4uLnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzcyh0ZXh0KTtcbiAgICBjb25zdCByZXN1bHQgPSBbZmlyc3RBcmcsIC4uLnN0eWxlc107XG4gICAgcmVzdWx0LnB1c2goLi4uZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbFRleHQodGV4dCkge1xuICAgIHJldHVybiBzdHlsZWQodGV4dCwgeyBjb2xvcjogJ2JsYWNrJyB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEtpbmQoa2luZCkge1xuICAgIHJldHVybiBzdHlsZWQocGFkU3RyKGAke2tpbmR9OiBgLCAxMCksIHsgY29sb3I6ICdibGFjaycsIGJvbGQ6IHRydWUgfSk7XG59XG5mdW5jdGlvbiBzdHlsZWQodGV4dCwgb3B0aW9ucyA9IHtcbiAgICBjb2xvcjogJ2JsYWNrJyxcbn0pIHtcbiAgICBmdW5jdGlvbiBvYmpUb0NzcyhzdHlsZU9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc3R5bGVPYmopLnJlZHVjZSgoc3R5bGVTdHJpbmcsIFtwcm9wTmFtZSwgcHJvcFZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGAke3N0eWxlU3RyaW5nfSR7cHJvcE5hbWV9OiR7cHJvcFZhbHVlfTtgO1xuICAgICAgICB9LCAnJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICBjb2xvcjogb3B0aW9ucy5jb2xvcixcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLnN0cmlrZVRocm91Z2gpIHtcbiAgICAgICAgc3R5bGVbJ3RleHQtZGVjb3JhdGlvbiddID0gJ2xpbmUtdGhyb3VnaCc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJvbGQpIHtcbiAgICAgICAgc3R5bGVbJ2ZvbnQtd2VpZ2h0J10gPSAnYm9sZCc7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRleHQsXG4gICAgICAgIHN0eWxlOiBvYmpUb0NzcyhzdHlsZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlLCBhdmFpbGFibGVMZW4pIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgcmV0dXJuICcnICsgdmFsdWU7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICsgMiA8PSBhdmFpbGFibGVMZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYFwiJHt2YWx1ZS5zdWJzdHIoMCwgYXZhaWxhYmxlTGVuIC0gNyl9XCIrLi4uYDtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRBcnJheSh2YWx1ZSwgYXZhaWxhYmxlTGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPYmplY3QodmFsdWUsIGF2YWlsYWJsZUxlbik7XG4gICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIGBbW0Z1bmN0aW9uJHt2YWx1ZS5uYW1lID8gJyAnICsgdmFsdWUubmFtZSA6ICcnfV1dYDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnJyArIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KHZhbHVlLCBhdmFpbGFibGVMZW4pIHtcbiAgICBsZXQgcmVzdWx0ID0gJ1sgJztcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHVlKSB7XG4gICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIC0gNSA+IGF2YWlsYWJsZUxlbikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcuLi4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0ICs9IGAke2Zvcm1hdFZhbHVlKHZhbCwgYXZhaWxhYmxlTGVuIC0gcmVzdWx0Lmxlbmd0aCl9YDtcbiAgICB9XG4gICAgcmVzdWx0ICs9ICcgXSc7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdCh2YWx1ZSwgYXZhaWxhYmxlTGVuKSB7XG4gICAgbGV0IHJlc3VsdCA9ICd7ICc7XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIC0gNSA+IGF2YWlsYWJsZUxlbikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcuLi4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0ICs9IGAke2tleX06ICR7Zm9ybWF0VmFsdWUodmFsLCBhdmFpbGFibGVMZW4gLSByZXN1bHQubGVuZ3RoKX1gO1xuICAgIH1cbiAgICByZXN1bHQgKz0gJyB9JztcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgY291bnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gY291bnQ7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFkU3RyKHN0ciwgbGVuZ3RoKSB7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgc3RyICs9ICcgJztcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgYXV0b3J1biB9IGZyb20gJy4vYXV0b3J1bi5qcyc7XG5pbXBvcnQgeyBvYnNlcnZhYmxlVmFsdWUsIHRyYW5zYWN0aW9uIH0gZnJvbSAnLi9iYXNlLmpzJztcbmltcG9ydCB7IENhbmNlbGxhdGlvbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbi8qKlxuICogQSBwcm9taXNlIHdob3NlIHN0YXRlIGlzIG9ic2VydmFibGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBPYnNlcnZhYmxlUHJvbWlzZSB7XG4gICAgc3RhdGljIGZyb21Gbihmbikge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQcm9taXNlKGZuKCkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihwcm9taXNlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gb2JzZXJ2YWJsZVZhbHVlKHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcHJvbWlzZS5cbiAgICAgICAgICogSXMgYHVuZGVmaW5lZGAgaWYgdGhlIHByb21pc2UgZGlkbid0IHJlc29sdmUgeWV0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9taXNlUmVzdWx0ID0gdGhpcy5fdmFsdWU7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbih0eCA9PiB7XG4gICAgICAgICAgICAgICAgLyoqIEBkZXNjcmlwdGlvbiBvblByb21pc2VSZXNvbHZlZCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlLnNldChuZXcgUHJvbWlzZVJlc3VsdCh2YWx1ZSwgdW5kZWZpbmVkKSwgdHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uKHR4ID0+IHtcbiAgICAgICAgICAgICAgICAvKiogQGRlc2NyaXB0aW9uIG9uUHJvbWlzZVJlamVjdGVkICovXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUuc2V0KG5ldyBQcm9taXNlUmVzdWx0KHVuZGVmaW5lZCwgZXJyb3IpLCB0eCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUHJvbWlzZVJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoZSByZXNvbHZlZCBwcm9taXNlLlxuICAgICAqIFVuZGVmaW5lZCBpZiB0aGUgcHJvbWlzZSByZWplY3RlZC5cbiAgICAgKi9cbiAgICBkYXRhLCBcbiAgICAvKipcbiAgICAgKiBUaGUgZXJyb3IgaW4gY2FzZSBvZiBhIHJlamVjdGVkIHByb21pc2UuXG4gICAgICogVW5kZWZpbmVkIGlmIHRoZSBwcm9taXNlIHJlc29sdmVkLlxuICAgICAqL1xuICAgIGVycm9yKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gd2FpdEZvclN0YXRlKG9ic2VydmFibGUsIHByZWRpY2F0ZSwgaXNFcnJvciwgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICBwcmVkaWNhdGUgPSBzdGF0ZSA9PiBzdGF0ZSAhPT0gbnVsbCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgaXNJbW1lZGlhdGVSdW4gPSB0cnVlO1xuICAgICAgICBsZXQgc2hvdWxkRGlzcG9zZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdGF0ZU9icyA9IG9ic2VydmFibGUubWFwKHN0YXRlID0+IHtcbiAgICAgICAgICAgIC8qKiBAZGVzY3JpcHRpb24gd2FpdEZvclN0YXRlLnN0YXRlICovXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzRmluaXNoZWQ6IHByZWRpY2F0ZShzdGF0ZSksXG4gICAgICAgICAgICAgICAgZXJyb3I6IGlzRXJyb3IgPyBpc0Vycm9yKHN0YXRlKSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZCA9IGF1dG9ydW4ocmVhZGVyID0+IHtcbiAgICAgICAgICAgIC8qKiBAZGVzY3JpcHRpb24gd2FpdEZvclN0YXRlICovXG4gICAgICAgICAgICBjb25zdCB7IGlzRmluaXNoZWQsIGVycm9yLCBzdGF0ZSB9ID0gc3RhdGVPYnMucmVhZChyZWFkZXIpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXNoZWQgfHwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbW1lZGlhdGVSdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHZhcmlhYmxlIGBkYCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZERpc3Bvc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IgPT09IHRydWUgPyBzdGF0ZSA6IGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICAgICAgY29uc3QgZGMgPSBjYW5jZWxsYXRpb25Ub2tlbi5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgZGMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjYW5jZWxsYXRpb25Ub2tlbi5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCkge1xuICAgICAgICAgICAgICAgIGQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGRjLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IENhbmNlbGxhdGlvbkVycm9yKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc0ltbWVkaWF0ZVJ1biA9IGZhbHNlO1xuICAgICAgICBpZiAoc2hvdWxkRGlzcG9zZSkge1xuICAgICAgICAgICAgZC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuLi9ldmVudC5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlU3RvcmUsIHRvRGlzcG9zYWJsZSB9IGZyb20gJy4uL2xpZmVjeWNsZS5qcyc7XG5pbXBvcnQgeyBCYXNlT2JzZXJ2YWJsZSwgQ29udmVuaWVudE9ic2VydmFibGUsIF9zZXRLZWVwT2JzZXJ2ZWQsIF9zZXRSZWNvbXB1dGVJbml0aWFsbHlBbmRPbkNoYW5nZSwgc3VidHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uIH0gZnJvbSAnLi9iYXNlLmpzJztcbmltcG9ydCB7IERlYnVnTmFtZURhdGEgfSBmcm9tICcuL2RlYnVnTmFtZS5qcyc7XG5pbXBvcnQgeyBkZXJpdmVkLCBkZXJpdmVkT3B0cyB9IGZyb20gJy4vZGVyaXZlZC5qcyc7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tICcuL2xvZ2dpbmcuanMnO1xuaW1wb3J0IHsgc3RyaWN0RXF1YWxzIH0gZnJvbSAnLi4vZXF1YWxzLmpzJztcbi8qKlxuICogUmVwcmVzZW50cyBhbiBlZmZpY2llbnQgb2JzZXJ2YWJsZSB3aG9zZSB2YWx1ZSBuZXZlciBjaGFuZ2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uc3RPYnNlcnZhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdE9ic2VydmFibGUodmFsdWUpO1xufVxuY2xhc3MgQ29uc3RPYnNlcnZhYmxlIGV4dGVuZHMgQ29udmVuaWVudE9ic2VydmFibGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGRlYnVnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgICAgLy8gTk8gT1BcbiAgICB9XG4gICAgcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgICAgLy8gTk8gT1BcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgQ29uc3Q6ICR7dGhpcy52YWx1ZX1gO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZhYmxlRnJvbUV2ZW50KC4uLmFyZ3MpIHtcbiAgICBsZXQgb3duZXI7XG4gICAgbGV0IGV2ZW50O1xuICAgIGxldCBnZXRWYWx1ZTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgW293bmVyLCBldmVudCwgZ2V0VmFsdWVdID0gYXJncztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIFtldmVudCwgZ2V0VmFsdWVdID0gYXJncztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGcm9tRXZlbnRPYnNlcnZhYmxlKG5ldyBEZWJ1Z05hbWVEYXRhKG93bmVyLCB1bmRlZmluZWQsIGdldFZhbHVlKSwgZXZlbnQsIGdldFZhbHVlLCAoKSA9PiBGcm9tRXZlbnRPYnNlcnZhYmxlLmdsb2JhbFRyYW5zYWN0aW9uLCBzdHJpY3RFcXVhbHMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmFibGVGcm9tRXZlbnRPcHRzKG9wdGlvbnMsIGV2ZW50LCBnZXRWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgRnJvbUV2ZW50T2JzZXJ2YWJsZShuZXcgRGVidWdOYW1lRGF0YShvcHRpb25zLm93bmVyLCBvcHRpb25zLmRlYnVnTmFtZSwgb3B0aW9ucy5kZWJ1Z1JlZmVyZW5jZUZuID8/IGdldFZhbHVlKSwgZXZlbnQsIGdldFZhbHVlLCAoKSA9PiBGcm9tRXZlbnRPYnNlcnZhYmxlLmdsb2JhbFRyYW5zYWN0aW9uLCBvcHRpb25zLmVxdWFsc0ZuID8/IHN0cmljdEVxdWFscyk7XG59XG5leHBvcnQgY2xhc3MgRnJvbUV2ZW50T2JzZXJ2YWJsZSBleHRlbmRzIEJhc2VPYnNlcnZhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihfZGVidWdOYW1lRGF0YSwgZXZlbnQsIF9nZXRWYWx1ZSwgX2dldFRyYW5zYWN0aW9uLCBfZXF1YWxpdHlDb21wYXJhdG9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2RlYnVnTmFtZURhdGEgPSBfZGVidWdOYW1lRGF0YTtcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLl9nZXRWYWx1ZSA9IF9nZXRWYWx1ZTtcbiAgICAgICAgdGhpcy5fZ2V0VHJhbnNhY3Rpb24gPSBfZ2V0VHJhbnNhY3Rpb247XG4gICAgICAgIHRoaXMuX2VxdWFsaXR5Q29tcGFyYXRvciA9IF9lcXVhbGl0eUNvbXBhcmF0b3I7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVFdmVudCA9IChhcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuX2dldFZhbHVlKGFyZ3MpO1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgZGlkQ2hhbmdlID0gIXRoaXMuaGFzVmFsdWUgfHwgISh0aGlzLl9lcXVhbGl0eUNvbXBhcmF0b3Iob2xkVmFsdWUsIG5ld1ZhbHVlKSk7XG4gICAgICAgICAgICBsZXQgZGlkUnVuVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlkUnVuVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdWJ0cmFuc2FjdGlvbih0aGlzLl9nZXRUcmFuc2FjdGlvbigpLCAodHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvZ2dlcigpPy5oYW5kbGVGcm9tRXZlbnRPYnNlcnZhYmxlVHJpZ2dlcmVkKHRoaXMsIHsgb2xkVmFsdWUsIG5ld1ZhbHVlLCBjaGFuZ2U6IHVuZGVmaW5lZCwgZGlkQ2hhbmdlLCBoYWRWYWx1ZTogdGhpcy5oYXNWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbyBvZiB0aGlzLm9ic2VydmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LnVwZGF0ZU9ic2VydmVyKG8sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uaGFuZGxlQ2hhbmdlKHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmdldERlYnVnTmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdFdmVudCBmaXJlZCcgKyAobmFtZSA/IGA6ICR7bmFtZX1gIDogJycpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRpZFJ1blRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZ2V0TG9nZ2VyKCk/LmhhbmRsZUZyb21FdmVudE9ic2VydmFibGVUcmlnZ2VyZWQodGhpcywgeyBvbGRWYWx1ZSwgbmV3VmFsdWUsIGNoYW5nZTogdW5kZWZpbmVkLCBkaWRDaGFuZ2UsIGhhZFZhbHVlOiB0aGlzLmhhc1ZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXREZWJ1Z05hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJ1Z05hbWVEYXRhLmdldERlYnVnTmFtZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRlYnVnTmFtZSgpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0RGVidWdOYW1lKCk7XG4gICAgICAgIHJldHVybiAnRnJvbSBFdmVudCcgKyAobmFtZSA/IGA6ICR7bmFtZX1gIDogJycpO1xuICAgIH1cbiAgICBvbkZpcnN0T2JzZXJ2ZXJBZGRlZCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmV2ZW50KHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgIH1cbiAgICBvbkxhc3RPYnNlcnZlclJlbW92ZWQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXZlbnQodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gY2FjaGUsIGFzIHRoZXJlIGFyZSBubyBzdWJzY3JpYmVycyB0byBrZWVwIGl0IHVwZGF0ZWRcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ2V0VmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbihmdW5jdGlvbiAob2JzZXJ2YWJsZUZyb21FdmVudCkge1xuICAgIG9ic2VydmFibGVGcm9tRXZlbnQuT2JzZXJ2ZXIgPSBGcm9tRXZlbnRPYnNlcnZhYmxlO1xuICAgIGZ1bmN0aW9uIGJhdGNoRXZlbnRzR2xvYmFsbHkodHgsIGZuKSB7XG4gICAgICAgIGxldCBkaWRTZXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKEZyb21FdmVudE9ic2VydmFibGUuZ2xvYmFsVHJhbnNhY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5nbG9iYWxUcmFuc2FjdGlvbiA9IHR4O1xuICAgICAgICAgICAgZGlkU2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChkaWRTZXQpIHtcbiAgICAgICAgICAgICAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLmdsb2JhbFRyYW5zYWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmFibGVGcm9tRXZlbnQuYmF0Y2hFdmVudHNHbG9iYWxseSA9IGJhdGNoRXZlbnRzR2xvYmFsbHk7XG59KShvYnNlcnZhYmxlRnJvbUV2ZW50IHx8IChvYnNlcnZhYmxlRnJvbUV2ZW50ID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZhYmxlU2lnbmFsRnJvbUV2ZW50KGRlYnVnTmFtZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IEZyb21FdmVudE9ic2VydmFibGVTaWduYWwoZGVidWdOYW1lLCBldmVudCk7XG59XG5jbGFzcyBGcm9tRXZlbnRPYnNlcnZhYmxlU2lnbmFsIGV4dGVuZHMgQmFzZU9ic2VydmFibGUge1xuICAgIGNvbnN0cnVjdG9yKGRlYnVnTmFtZSwgZXZlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kZWJ1Z05hbWUgPSBkZWJ1Z05hbWU7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5oYW5kbGVFdmVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uKCh0eCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbyBvZiB0aGlzLm9ic2VydmVycykge1xuICAgICAgICAgICAgICAgICAgICB0eC51cGRhdGVPYnNlcnZlcihvLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgby5oYW5kbGVDaGFuZ2UodGhpcywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAoKSA9PiB0aGlzLmRlYnVnTmFtZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIG9uRmlyc3RPYnNlcnZlckFkZGVkKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuZXZlbnQodGhpcy5oYW5kbGVFdmVudCk7XG4gICAgfVxuICAgIG9uTGFzdE9ic2VydmVyUmVtb3ZlZCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICAvLyBOTyBPUFxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZhYmxlU2lnbmFsKGRlYnVnTmFtZU9yT3duZXIpIHtcbiAgICBpZiAodHlwZW9mIGRlYnVnTmFtZU9yT3duZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVNpZ25hbChkZWJ1Z05hbWVPck93bmVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVNpZ25hbCh1bmRlZmluZWQsIGRlYnVnTmFtZU9yT3duZXIpO1xuICAgIH1cbn1cbmNsYXNzIE9ic2VydmFibGVTaWduYWwgZXh0ZW5kcyBCYXNlT2JzZXJ2YWJsZSB7XG4gICAgZ2V0IGRlYnVnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWJ1Z05hbWVEYXRhKHRoaXMuX293bmVyLCB0aGlzLl9kZWJ1Z05hbWUsIHVuZGVmaW5lZCkuZ2V0RGVidWdOYW1lKHRoaXMpID8/ICdPYnNlcnZhYmxlIFNpZ25hbCc7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWJ1Z05hbWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9kZWJ1Z05hbWUsIF9vd25lcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9kZWJ1Z05hbWUgPSBfZGVidWdOYW1lO1xuICAgICAgICB0aGlzLl9vd25lciA9IF9vd25lcjtcbiAgICB9XG4gICAgdHJpZ2dlcih0eCwgY2hhbmdlKSB7XG4gICAgICAgIGlmICghdHgpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uKHR4ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIodHgsIGNoYW5nZSk7XG4gICAgICAgICAgICB9LCAoKSA9PiBgVHJpZ2dlciBzaWduYWwgJHt0aGlzLmRlYnVnTmFtZX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG8gb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIHR4LnVwZGF0ZU9ic2VydmVyKG8sIHRoaXMpO1xuICAgICAgICAgICAgby5oYW5kbGVDaGFuZ2UodGhpcywgY2hhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIC8vIE5PIE9QXG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIG1ha2VzIHN1cmUgdGhlIG9ic2VydmFibGUgaXMgYmVpbmcgb2JzZXJ2ZWQgYW5kIGtlZXBzIGl0cyBjYWNoZSBhbGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlZXBPYnNlcnZlZChvYnNlcnZhYmxlKSB7XG4gICAgY29uc3QgbyA9IG5ldyBLZWVwQWxpdmVPYnNlcnZlcihmYWxzZSwgdW5kZWZpbmVkKTtcbiAgICBvYnNlcnZhYmxlLmFkZE9ic2VydmVyKG8pO1xuICAgIHJldHVybiB0b0Rpc3Bvc2FibGUoKCkgPT4ge1xuICAgICAgICBvYnNlcnZhYmxlLnJlbW92ZU9ic2VydmVyKG8pO1xuICAgIH0pO1xufVxuX3NldEtlZXBPYnNlcnZlZChrZWVwT2JzZXJ2ZWQpO1xuLyoqXG4gKiBUaGlzIGNvbnZlcnRzIHRoZSBnaXZlbiBvYnNlcnZhYmxlIGludG8gYW4gYXV0b3J1bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY29tcHV0ZUluaXRpYWxseUFuZE9uQ2hhbmdlKG9ic2VydmFibGUsIGhhbmRsZVZhbHVlKSB7XG4gICAgY29uc3QgbyA9IG5ldyBLZWVwQWxpdmVPYnNlcnZlcih0cnVlLCBoYW5kbGVWYWx1ZSk7XG4gICAgb2JzZXJ2YWJsZS5hZGRPYnNlcnZlcihvKTtcbiAgICBpZiAoaGFuZGxlVmFsdWUpIHtcbiAgICAgICAgaGFuZGxlVmFsdWUob2JzZXJ2YWJsZS5nZXQoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvYnNlcnZhYmxlLnJlcG9ydENoYW5nZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICAgIG9ic2VydmFibGUucmVtb3ZlT2JzZXJ2ZXIobyk7XG4gICAgfSk7XG59XG5fc2V0UmVjb21wdXRlSW5pdGlhbGx5QW5kT25DaGFuZ2UocmVjb21wdXRlSW5pdGlhbGx5QW5kT25DaGFuZ2UpO1xuZXhwb3J0IGNsYXNzIEtlZXBBbGl2ZU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihfZm9yY2VSZWNvbXB1dGUsIF9oYW5kbGVWYWx1ZSkge1xuICAgICAgICB0aGlzLl9mb3JjZVJlY29tcHV0ZSA9IF9mb3JjZVJlY29tcHV0ZTtcbiAgICAgICAgdGhpcy5faGFuZGxlVmFsdWUgPSBfaGFuZGxlVmFsdWU7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSAwO1xuICAgIH1cbiAgICBiZWdpblVwZGF0ZShvYnNlcnZhYmxlKSB7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIrKztcbiAgICB9XG4gICAgZW5kVXBkYXRlKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy5fY291bnRlci0tO1xuICAgICAgICBpZiAodGhpcy5fY291bnRlciA9PT0gMCAmJiB0aGlzLl9mb3JjZVJlY29tcHV0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlVmFsdWUob2JzZXJ2YWJsZS5nZXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlLnJlcG9ydENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVQb3NzaWJsZUNoYW5nZShvYnNlcnZhYmxlKSB7XG4gICAgICAgIC8vIE5PIE9QXG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShvYnNlcnZhYmxlLCBjaGFuZ2UpIHtcbiAgICAgICAgLy8gTk8gT1BcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZE9ic2VydmFibGVXaXRoQ2FjaGUob3duZXIsIGNvbXB1dGVGbikge1xuICAgIGxldCBsYXN0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb2JzZXJ2YWJsZSA9IGRlcml2ZWRPcHRzKHsgb3duZXIsIGRlYnVnUmVmZXJlbmNlRm46IGNvbXB1dGVGbiB9LCByZWFkZXIgPT4ge1xuICAgICAgICBsYXN0VmFsdWUgPSBjb21wdXRlRm4ocmVhZGVyLCBsYXN0VmFsdWUpO1xuICAgICAgICByZXR1cm4gbGFzdFZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBvYnNlcnZhYmxlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRPYnNlcnZhYmxlV2l0aFdyaXRhYmxlQ2FjaGUob3duZXIsIGNvbXB1dGVGbikge1xuICAgIGxldCBsYXN0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25DaGFuZ2UgPSBvYnNlcnZhYmxlU2lnbmFsKCdkZXJpdmVkT2JzZXJ2YWJsZVdpdGhXcml0YWJsZUNhY2hlJyk7XG4gICAgY29uc3Qgb2JzZXJ2YWJsZSA9IGRlcml2ZWQob3duZXIsIHJlYWRlciA9PiB7XG4gICAgICAgIG9uQ2hhbmdlLnJlYWQocmVhZGVyKTtcbiAgICAgICAgbGFzdFZhbHVlID0gY29tcHV0ZUZuKHJlYWRlciwgbGFzdFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxhc3RWYWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYnNlcnZhYmxlLCB7XG4gICAgICAgIGNsZWFyQ2FjaGU6ICh0eCkgPT4ge1xuICAgICAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgb25DaGFuZ2UudHJpZ2dlcih0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENhY2hlOiAobmV3VmFsdWUsIHR4KSA9PiB7XG4gICAgICAgICAgICBsYXN0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIG9uQ2hhbmdlLnRyaWdnZXIodHgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFdoZW4gdGhlIGl0ZW1zIGFycmF5IGNoYW5nZXMsIHJlZmVyZW50aWFsIGVxdWFsIGl0ZW1zIGFyZSBub3QgbWFwcGVkIGFnYWluLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwT2JzZXJ2YWJsZUFycmF5Q2FjaGVkKG93bmVyLCBpdGVtcywgbWFwLCBrZXlTZWxlY3Rvcikge1xuICAgIGxldCBtID0gbmV3IEFycmF5TWFwKG1hcCwga2V5U2VsZWN0b3IpO1xuICAgIGNvbnN0IHNlbGYgPSBkZXJpdmVkT3B0cyh7XG4gICAgICAgIGRlYnVnUmVmZXJlbmNlRm46IG1hcCxcbiAgICAgICAgb3duZXIsXG4gICAgICAgIG9uTGFzdE9ic2VydmVyUmVtb3ZlZDogKCkgPT4ge1xuICAgICAgICAgICAgbS5kaXNwb3NlKCk7XG4gICAgICAgICAgICBtID0gbmV3IEFycmF5TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCAocmVhZGVyKSA9PiB7XG4gICAgICAgIG0uc2V0SXRlbXMoaXRlbXMucmVhZChyZWFkZXIpKTtcbiAgICAgICAgcmV0dXJuIG0uZ2V0SXRlbXMoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbn1cbmNsYXNzIEFycmF5TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihfbWFwLCBfa2V5U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gX21hcDtcbiAgICAgICAgdGhpcy5fa2V5U2VsZWN0b3IgPSBfa2V5U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9jYWNoZS5mb3JFYWNoKGVudHJ5ID0+IGVudHJ5LnN0b3JlLmRpc3Bvc2UoKSk7XG4gICAgICAgIHRoaXMuX2NhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHNldEl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IG5ld0l0ZW1zID0gW107XG4gICAgICAgIGNvbnN0IGl0ZW1zVG9SZW1vdmUgPSBuZXcgU2V0KHRoaXMuX2NhY2hlLmtleXMoKSk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5fa2V5U2VsZWN0b3IgPyB0aGlzLl9rZXlTZWxlY3RvcihpdGVtKSA6IGl0ZW07XG4gICAgICAgICAgICBsZXQgZW50cnkgPSB0aGlzLl9jYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IG5ldyBEaXNwb3NhYmxlU3RvcmUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSB0aGlzLl9tYXAoaXRlbSwgc3RvcmUpO1xuICAgICAgICAgICAgICAgIGVudHJ5ID0geyBvdXQsIHN0b3JlIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuc2V0KGtleSwgZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbXNUb1JlbW92ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2goZW50cnkub3V0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXNUb1JlbW92ZSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl9jYWNoZS5nZXQoaXRlbSk7XG4gICAgICAgICAgICBlbnRyeS5zdG9yZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXRlbXMgPSBuZXdJdGVtcztcbiAgICB9XG4gICAgZ2V0SXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVmFsdWVXaXRoQ2hhbmdlRXZlbnRGcm9tT2JzZXJ2YWJsZSB7XG4gICAgY29uc3RydWN0b3Iob2JzZXJ2YWJsZSkge1xuICAgICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuICAgIH1cbiAgICBnZXQgb25EaWRDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBFdmVudC5mcm9tT2JzZXJ2YWJsZUxpZ2h0KHRoaXMub2JzZXJ2YWJsZSk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2YWJsZS5nZXQoKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2YWJsZUZyb21WYWx1ZVdpdGhDaGFuZ2VFdmVudChvd25lciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBWYWx1ZVdpdGhDaGFuZ2VFdmVudEZyb21PYnNlcnZhYmxlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5vYnNlcnZhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gb2JzZXJ2YWJsZUZyb21FdmVudChvd25lciwgdmFsdWUub25EaWRDaGFuZ2UsICgpID0+IHZhbHVlLnZhbHVlKTtcbn1cbi8qKlxuICogV29ya3MgbGlrZSBhIGRlcml2ZWQuXG4gKiBIb3dldmVyLCBpZiB0aGUgdmFsdWUgaXMgbm90IHVuZGVmaW5lZCwgaXQgaXMgY2FjaGVkIGFuZCB3aWxsIG5vdCBiZSByZWNvbXB1dGVkIGFueW1vcmUuXG4gKiBJbiB0aGF0IGNhc2UsIHRoZSBkZXJpdmVkIHdpbGwgdW5zdWJzY3JpYmUgZnJvbSBpdHMgZGVwZW5kZW5jaWVzLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkQ29uc3RPbmNlRGVmaW5lZChvd25lciwgZm4pIHtcbiAgICByZXR1cm4gZGVyaXZlZE9ic2VydmFibGVXaXRoQ2FjaGUob3duZXIsIChyZWFkZXIsIGxhc3RWYWx1ZSkgPT4gbGFzdFZhbHVlID8/IGZuKHJlYWRlcikpO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFbWl0dGVyLCBFdmVudCB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2V2ZW50LmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgTGFuZ3VhZ2VzUmVnaXN0cnkgfSBmcm9tICcuL2xhbmd1YWdlc1JlZ2lzdHJ5LmpzJztcbmltcG9ydCB7IGZpcnN0T3JEZWZhdWx0IH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzLmpzJztcbmltcG9ydCB7IFRva2VuaXphdGlvblJlZ2lzdHJ5IH0gZnJvbSAnLi4vbGFuZ3VhZ2VzLmpzJztcbmltcG9ydCB7IFBMQUlOVEVYVF9MQU5HVUFHRV9JRCB9IGZyb20gJy4uL2xhbmd1YWdlcy9tb2Rlc1JlZ2lzdHJ5LmpzJztcbmltcG9ydCB7IG9ic2VydmFibGVGcm9tRXZlbnQgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9vYnNlcnZhYmxlLmpzJztcbmV4cG9ydCBjbGFzcyBMYW5ndWFnZVNlcnZpY2UgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgICBzdGF0aWMgeyB0aGlzLmluc3RhbmNlQ291bnQgPSAwOyB9XG4gICAgY29uc3RydWN0b3Iod2Fybk9uT3ZlcndyaXRlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fb25EaWRSZXF1ZXN0QmFzaWNMYW5ndWFnZUZlYXR1cmVzID0gdGhpcy5fcmVnaXN0ZXIobmV3IEVtaXR0ZXIoKSk7XG4gICAgICAgIHRoaXMub25EaWRSZXF1ZXN0QmFzaWNMYW5ndWFnZUZlYXR1cmVzID0gdGhpcy5fb25EaWRSZXF1ZXN0QmFzaWNMYW5ndWFnZUZlYXR1cmVzLmV2ZW50O1xuICAgICAgICB0aGlzLl9vbkRpZFJlcXVlc3RSaWNoTGFuZ3VhZ2VGZWF0dXJlcyA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBFbWl0dGVyKCkpO1xuICAgICAgICB0aGlzLm9uRGlkUmVxdWVzdFJpY2hMYW5ndWFnZUZlYXR1cmVzID0gdGhpcy5fb25EaWRSZXF1ZXN0UmljaExhbmd1YWdlRmVhdHVyZXMuZXZlbnQ7XG4gICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlID0gdGhpcy5fcmVnaXN0ZXIobmV3IEVtaXR0ZXIoeyBsZWFrV2FybmluZ1RocmVzaG9sZDogMjAwIC8qIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvdnNjb2RlL2lzc3Vlcy8xMTk5NjggKi8gfSkpO1xuICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlID0gdGhpcy5fb25EaWRDaGFuZ2UuZXZlbnQ7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RlZEJhc2ljTGFuZ3VhZ2VzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRSaWNoTGFuZ3VhZ2VzID0gbmV3IFNldCgpO1xuICAgICAgICBMYW5ndWFnZVNlcnZpY2UuaW5zdGFuY2VDb3VudCsrO1xuICAgICAgICB0aGlzLl9yZWdpc3RyeSA9IHRoaXMuX3JlZ2lzdGVyKG5ldyBMYW5ndWFnZXNSZWdpc3RyeSh0cnVlLCB3YXJuT25PdmVyd3JpdGUpKTtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUlkQ29kZWMgPSB0aGlzLl9yZWdpc3RyeS5sYW5ndWFnZUlkQ29kZWM7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyKHRoaXMuX3JlZ2lzdHJ5Lm9uRGlkQ2hhbmdlKCgpID0+IHRoaXMuX29uRGlkQ2hhbmdlLmZpcmUoKSkpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBMYW5ndWFnZVNlcnZpY2UuaW5zdGFuY2VDb3VudC0tO1xuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlzUmVnaXN0ZXJlZExhbmd1YWdlSWQobGFuZ3VhZ2VJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0cnkuaXNSZWdpc3RlcmVkTGFuZ3VhZ2VJZChsYW5ndWFnZUlkKTtcbiAgICB9XG4gICAgZ2V0TGFuZ3VhZ2VJZEJ5TGFuZ3VhZ2VOYW1lKGxhbmd1YWdlTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0cnkuZ2V0TGFuZ3VhZ2VJZEJ5TGFuZ3VhZ2VOYW1lKGxhbmd1YWdlTmFtZSk7XG4gICAgfVxuICAgIGdldExhbmd1YWdlSWRCeU1pbWVUeXBlKG1pbWVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RyeS5nZXRMYW5ndWFnZUlkQnlNaW1lVHlwZShtaW1lVHlwZSk7XG4gICAgfVxuICAgIGd1ZXNzTGFuZ3VhZ2VJZEJ5RmlsZXBhdGhPckZpcnN0TGluZShyZXNvdXJjZSwgZmlyc3RMaW5lKSB7XG4gICAgICAgIGNvbnN0IGxhbmd1YWdlSWRzID0gdGhpcy5fcmVnaXN0cnkuZ3Vlc3NMYW5ndWFnZUlkQnlGaWxlcGF0aE9yRmlyc3RMaW5lKHJlc291cmNlLCBmaXJzdExpbmUpO1xuICAgICAgICByZXR1cm4gZmlyc3RPckRlZmF1bHQobGFuZ3VhZ2VJZHMsIG51bGwpO1xuICAgIH1cbiAgICBjcmVhdGVCeUlkKGxhbmd1YWdlSWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVNlbGVjdGlvbih0aGlzLm9uRGlkQ2hhbmdlLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQW5kR2V0TGFuZ3VhZ2VJZGVudGlmaWVyKGxhbmd1YWdlSWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlQnlGaWxlcGF0aE9yRmlyc3RMaW5lKHJlc291cmNlLCBmaXJzdExpbmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVNlbGVjdGlvbih0aGlzLm9uRGlkQ2hhbmdlLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYW5ndWFnZUlkID0gdGhpcy5ndWVzc0xhbmd1YWdlSWRCeUZpbGVwYXRoT3JGaXJzdExpbmUocmVzb3VyY2UsIGZpcnN0TGluZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQW5kR2V0TGFuZ3VhZ2VJZGVudGlmaWVyKGxhbmd1YWdlSWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NyZWF0ZUFuZEdldExhbmd1YWdlSWRlbnRpZmllcihsYW5ndWFnZUlkKSB7XG4gICAgICAgIGlmICghbGFuZ3VhZ2VJZCB8fCAhdGhpcy5pc1JlZ2lzdGVyZWRMYW5ndWFnZUlkKGxhbmd1YWdlSWQpKSB7XG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gcGxhaW4gdGV4dCBpZiBsYW5ndWFnZSBpcyB1bmtub3duXG4gICAgICAgICAgICBsYW5ndWFnZUlkID0gUExBSU5URVhUX0xBTkdVQUdFX0lEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYW5ndWFnZUlkO1xuICAgIH1cbiAgICByZXF1ZXN0QmFzaWNMYW5ndWFnZUZlYXR1cmVzKGxhbmd1YWdlSWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0ZWRCYXNpY0xhbmd1YWdlcy5oYXMobGFuZ3VhZ2VJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RlZEJhc2ljTGFuZ3VhZ2VzLmFkZChsYW5ndWFnZUlkKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkUmVxdWVzdEJhc2ljTGFuZ3VhZ2VGZWF0dXJlcy5maXJlKGxhbmd1YWdlSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RSaWNoTGFuZ3VhZ2VGZWF0dXJlcyhsYW5ndWFnZUlkKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdGVkUmljaExhbmd1YWdlcy5oYXMobGFuZ3VhZ2VJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RlZFJpY2hMYW5ndWFnZXMuYWRkKGxhbmd1YWdlSWQpO1xuICAgICAgICAgICAgLy8gRW5zdXJlIGJhc2ljIGZlYXR1cmVzIGFyZSByZXF1ZXN0ZWRcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEJhc2ljTGFuZ3VhZ2VGZWF0dXJlcyhsYW5ndWFnZUlkKTtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0b2tlbml6ZXJzIGFyZSBjcmVhdGVkXG4gICAgICAgICAgICBUb2tlbml6YXRpb25SZWdpc3RyeS5nZXRPckNyZWF0ZShsYW5ndWFnZUlkKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlkUmVxdWVzdFJpY2hMYW5ndWFnZUZlYXR1cmVzLmZpcmUobGFuZ3VhZ2VJZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBMYW5ndWFnZVNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob25EaWRDaGFuZ2VMYW5ndWFnZXMsIHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gb2JzZXJ2YWJsZUZyb21FdmVudCh0aGlzLCBvbkRpZENoYW5nZUxhbmd1YWdlcywgKCkgPT4gc2VsZWN0b3IoKSk7XG4gICAgICAgIHRoaXMub25EaWRDaGFuZ2UgPSBFdmVudC5mcm9tT2JzZXJ2YWJsZSh0aGlzLl92YWx1ZSk7XG4gICAgfVxuICAgIGdldCBsYW5ndWFnZUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUuZ2V0KCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9