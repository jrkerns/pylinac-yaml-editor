/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/arrays.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrayQueue: () => (/* binding */ ArrayQueue),
/* harmony export */   CallbackIterable: () => (/* binding */ CallbackIterable),
/* harmony export */   CompareResult: () => (/* binding */ CompareResult),
/* harmony export */   Permutation: () => (/* binding */ Permutation),
/* harmony export */   arrayInsert: () => (/* binding */ arrayInsert),
/* harmony export */   asArray: () => (/* binding */ asArray),
/* harmony export */   binarySearch: () => (/* binding */ binarySearch),
/* harmony export */   binarySearch2: () => (/* binding */ binarySearch2),
/* harmony export */   booleanComparator: () => (/* binding */ booleanComparator),
/* harmony export */   coalesce: () => (/* binding */ coalesce),
/* harmony export */   coalesceInPlace: () => (/* binding */ coalesceInPlace),
/* harmony export */   compareBy: () => (/* binding */ compareBy),
/* harmony export */   distinct: () => (/* binding */ distinct),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   firstOrDefault: () => (/* binding */ firstOrDefault),
/* harmony export */   forEachAdjacent: () => (/* binding */ forEachAdjacent),
/* harmony export */   forEachWithNeighbors: () => (/* binding */ forEachWithNeighbors),
/* harmony export */   groupAdjacentBy: () => (/* binding */ groupAdjacentBy),
/* harmony export */   groupBy: () => (/* binding */ groupBy),
/* harmony export */   insertInto: () => (/* binding */ insertInto),
/* harmony export */   isFalsyOrEmpty: () => (/* binding */ isFalsyOrEmpty),
/* harmony export */   isNonEmptyArray: () => (/* binding */ isNonEmptyArray),
/* harmony export */   numberComparator: () => (/* binding */ numberComparator),
/* harmony export */   pushMany: () => (/* binding */ pushMany),
/* harmony export */   pushToEnd: () => (/* binding */ pushToEnd),
/* harmony export */   pushToStart: () => (/* binding */ pushToStart),
/* harmony export */   quickSelect: () => (/* binding */ quickSelect),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   removeFastWithoutKeepingOrder: () => (/* binding */ removeFastWithoutKeepingOrder),
/* harmony export */   reverseOrder: () => (/* binding */ reverseOrder),
/* harmony export */   splice: () => (/* binding */ splice),
/* harmony export */   tail: () => (/* binding */ tail),
/* harmony export */   tail2: () => (/* binding */ tail2),
/* harmony export */   tieBreakComparators: () => (/* binding */ tieBreakComparators)
/* harmony export */ });
/**
 * Returns the last element of an array.
 * @param array The array.
 * @param n Which element from the end (default is zero).
 */
function tail(array, n = 0) {
    return array[array.length - (1 + n)];
}
function tail2(arr) {
    if (arr.length === 0) {
        throw new Error('Invalid tail call');
    }
    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
}
function equals(one, other, itemEquals = (a, b) => a === b) {
    if (one === other) {
        return true;
    }
    if (!one || !other) {
        return false;
    }
    if (one.length !== other.length) {
        return false;
    }
    for (let i = 0, len = one.length; i < len; i++) {
        if (!itemEquals(one[i], other[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Remove the element at `index` by replacing it with the last element. This is faster than `splice`
 * but changes the order of the array
 */
function removeFastWithoutKeepingOrder(array, index) {
    const last = array.length - 1;
    if (index < last) {
        array[index] = array[last];
    }
    array.pop();
}
/**
 * Performs a binary search algorithm over a sorted array.
 *
 * @param array The array being searched.
 * @param key The value we search for.
 * @param comparator A function that takes two array elements and returns zero
 *   if they are equal, a negative number if the first element precedes the
 *   second one in the sorting order, or a positive number if the second element
 *   precedes the first one.
 * @return See {@link binarySearch2}
 */
function binarySearch(array, key, comparator) {
    return binarySearch2(array.length, i => comparator(array[i], key));
}
/**
 * Performs a binary search algorithm over a sorted collection. Useful for cases
 * when we need to perform a binary search over something that isn't actually an
 * array, and converting data to an array would defeat the use of binary search
 * in the first place.
 *
 * @param length The collection length.
 * @param compareToKey A function that takes an index of an element in the
 *   collection and returns zero if the value at this index is equal to the
 *   search key, a negative number if the value precedes the search key in the
 *   sorting order, or a positive number if the search key precedes the value.
 * @return A non-negative index of an element, if found. If not found, the
 *   result is -(n+1) (or ~n, using bitwise notation), where n is the index
 *   where the key should be inserted to maintain the sorting order.
 */
function binarySearch2(length, compareToKey) {
    let low = 0, high = length - 1;
    while (low <= high) {
        const mid = ((low + high) / 2) | 0;
        const comp = compareToKey(mid);
        if (comp < 0) {
            low = mid + 1;
        }
        else if (comp > 0) {
            high = mid - 1;
        }
        else {
            return mid;
        }
    }
    return -(low + 1);
}
function quickSelect(nth, data, compare) {
    nth = nth | 0;
    if (nth >= data.length) {
        throw new TypeError('invalid index');
    }
    const pivotValue = data[Math.floor(data.length * Math.random())];
    const lower = [];
    const higher = [];
    const pivots = [];
    for (const value of data) {
        const val = compare(value, pivotValue);
        if (val < 0) {
            lower.push(value);
        }
        else if (val > 0) {
            higher.push(value);
        }
        else {
            pivots.push(value);
        }
    }
    if (nth < lower.length) {
        return quickSelect(nth, lower, compare);
    }
    else if (nth < lower.length + pivots.length) {
        return pivots[0];
    }
    else {
        return quickSelect(nth - (lower.length + pivots.length), higher, compare);
    }
}
function groupBy(data, compare) {
    const result = [];
    let currentGroup = undefined;
    for (const element of data.slice(0).sort(compare)) {
        if (!currentGroup || compare(currentGroup[0], element) !== 0) {
            currentGroup = [element];
            result.push(currentGroup);
        }
        else {
            currentGroup.push(element);
        }
    }
    return result;
}
/**
 * Splits the given items into a list of (non-empty) groups.
 * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.
 * The order of the items is preserved.
 */
function* groupAdjacentBy(items, shouldBeGrouped) {
    let currentGroup;
    let last;
    for (const item of items) {
        if (last !== undefined && shouldBeGrouped(last, item)) {
            currentGroup.push(item);
        }
        else {
            if (currentGroup) {
                yield currentGroup;
            }
            currentGroup = [item];
        }
        last = item;
    }
    if (currentGroup) {
        yield currentGroup;
    }
}
function forEachAdjacent(arr, f) {
    for (let i = 0; i <= arr.length; i++) {
        f(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);
    }
}
function forEachWithNeighbors(arr, f) {
    for (let i = 0; i < arr.length; i++) {
        f(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);
    }
}
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
function coalesce(array) {
    return array.filter((e) => !!e);
}
/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
function coalesceInPlace(array) {
    let to = 0;
    for (let i = 0; i < array.length; i++) {
        if (!!array[i]) {
            array[to] = array[i];
            to += 1;
        }
    }
    array.length = to;
}
/**
 * @returns false if the provided object is an array and not empty.
 */
function isFalsyOrEmpty(obj) {
    return !Array.isArray(obj) || obj.length === 0;
}
function isNonEmptyArray(obj) {
    return Array.isArray(obj) && obj.length > 0;
}
/**
 * Removes duplicates from the given array. The optional keyFn allows to specify
 * how elements are checked for equality by returning an alternate value for each.
 */
function distinct(array, keyFn = value => value) {
    const seen = new Set();
    return array.filter(element => {
        const key = keyFn(element);
        if (seen.has(key)) {
            return false;
        }
        seen.add(key);
        return true;
    });
}
function firstOrDefault(array, notFoundValue) {
    return array.length > 0 ? array[0] : notFoundValue;
}
function range(arg, to) {
    let from = typeof to === 'number' ? arg : 0;
    if (typeof to === 'number') {
        from = arg;
    }
    else {
        from = 0;
        to = arg;
    }
    const result = [];
    if (from <= to) {
        for (let i = from; i < to; i++) {
            result.push(i);
        }
    }
    else {
        for (let i = from; i > to; i--) {
            result.push(i);
        }
    }
    return result;
}
/**
 * Insert `insertArr` inside `target` at `insertIndex`.
 * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
 */
function arrayInsert(target, insertIndex, insertArr) {
    const before = target.slice(0, insertIndex);
    const after = target.slice(insertIndex);
    return before.concat(insertArr, after);
}
/**
 * Pushes an element to the start of the array, if found.
 */
function pushToStart(arr, value) {
    const index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
        arr.unshift(value);
    }
}
/**
 * Pushes an element to the end of the array, if found.
 */
function pushToEnd(arr, value) {
    const index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
        arr.push(value);
    }
}
function pushMany(arr, items) {
    for (const item of items) {
        arr.push(item);
    }
}
function asArray(x) {
    return Array.isArray(x) ? x : [x];
}
/**
 * Insert the new items in the array.
 * @param array The original array.
 * @param start The zero-based location in the array from which to start inserting elements.
 * @param newItems The items to be inserted
 */
function insertInto(array, start, newItems) {
    const startIdx = getActualStartIndex(array, start);
    const originalLength = array.length;
    const newItemsLength = newItems.length;
    array.length = originalLength + newItemsLength;
    // Move the items after the start index, start from the end so that we don't overwrite any value.
    for (let i = originalLength - 1; i >= startIdx; i--) {
        array[i + newItemsLength] = array[i];
    }
    for (let i = 0; i < newItemsLength; i++) {
        array[i + startIdx] = newItems[i];
    }
}
/**
 * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it
 * can only support limited number of items due to the maximum call stack size limit.
 * @param array The original array.
 * @param start The zero-based location in the array from which to start removing elements.
 * @param deleteCount The number of elements to remove.
 * @returns An array containing the elements that were deleted.
 */
function splice(array, start, deleteCount, newItems) {
    const index = getActualStartIndex(array, start);
    let result = array.splice(index, deleteCount);
    if (result === undefined) {
        // see https://bugs.webkit.org/show_bug.cgi?id=261140
        result = [];
    }
    insertInto(array, index, newItems);
    return result;
}
/**
 * Determine the actual start index (same logic as the native splice() or slice())
 * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.
 * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.
 * @param array The target array.
 * @param start The operation index.
 */
function getActualStartIndex(array, start) {
    return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);
}
var CompareResult;
(function (CompareResult) {
    function isLessThan(result) {
        return result < 0;
    }
    CompareResult.isLessThan = isLessThan;
    function isLessThanOrEqual(result) {
        return result <= 0;
    }
    CompareResult.isLessThanOrEqual = isLessThanOrEqual;
    function isGreaterThan(result) {
        return result > 0;
    }
    CompareResult.isGreaterThan = isGreaterThan;
    function isNeitherLessOrGreaterThan(result) {
        return result === 0;
    }
    CompareResult.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
    CompareResult.greaterThan = 1;
    CompareResult.lessThan = -1;
    CompareResult.neitherLessOrGreaterThan = 0;
})(CompareResult || (CompareResult = {}));
function compareBy(selector, comparator) {
    return (a, b) => comparator(selector(a), selector(b));
}
function tieBreakComparators(...comparators) {
    return (item1, item2) => {
        for (const comparator of comparators) {
            const result = comparator(item1, item2);
            if (!CompareResult.isNeitherLessOrGreaterThan(result)) {
                return result;
            }
        }
        return CompareResult.neitherLessOrGreaterThan;
    };
}
/**
 * The natural order on numbers.
*/
const numberComparator = (a, b) => a - b;
const booleanComparator = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);
function reverseOrder(comparator) {
    return (a, b) => -comparator(a, b);
}
class ArrayQueue {
    /**
     * Constructs a queue that is backed by the given array. Runtime is O(1).
    */
    constructor(items) {
        this.items = items;
        this.firstIdx = 0;
        this.lastIdx = this.items.length - 1;
    }
    get length() {
        return this.lastIdx - this.firstIdx + 1;
    }
    /**
     * Consumes elements from the beginning of the queue as long as the predicate returns true.
     * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).
    */
    takeWhile(predicate) {
        // P(k) := k <= this.lastIdx && predicate(this.items[k])
        // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)
        let startIdx = this.firstIdx;
        while (startIdx < this.items.length && predicate(this.items[startIdx])) {
            startIdx++;
        }
        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);
        this.firstIdx = startIdx;
        return result;
    }
    /**
     * Consumes elements from the end of the queue as long as the predicate returns true.
     * If no elements were consumed, `null` is returned.
     * The result has the same order as the underlying array!
    */
    takeFromEndWhile(predicate) {
        // P(k) := this.firstIdx >= k && predicate(this.items[k])
        // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]
        let endIdx = this.lastIdx;
        while (endIdx >= 0 && predicate(this.items[endIdx])) {
            endIdx--;
        }
        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);
        this.lastIdx = endIdx;
        return result;
    }
    peek() {
        if (this.length === 0) {
            return undefined;
        }
        return this.items[this.firstIdx];
    }
    dequeue() {
        const result = this.items[this.firstIdx];
        this.firstIdx++;
        return result;
    }
    takeCount(count) {
        const result = this.items.slice(this.firstIdx, this.firstIdx + count);
        this.firstIdx += count;
        return result;
    }
}
/**
 * This class is faster than an iterator and array for lazy computed data.
*/
class CallbackIterable {
    static { this.empty = new CallbackIterable(_callback => { }); }
    constructor(
    /**
     * Calls the callback for every item.
     * Stops when the callback returns false.
    */
    iterate) {
        this.iterate = iterate;
    }
    toArray() {
        const result = [];
        this.iterate(item => { result.push(item); return true; });
        return result;
    }
    filter(predicate) {
        return new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));
    }
    map(mapFn) {
        return new CallbackIterable(cb => this.iterate(item => cb(mapFn(item))));
    }
    findLast(predicate) {
        let result;
        this.iterate(item => {
            if (predicate(item)) {
                result = item;
            }
            return true;
        });
        return result;
    }
    findLastMaxBy(comparator) {
        let result;
        let first = true;
        this.iterate(item => {
            if (first || CompareResult.isGreaterThan(comparator(item, result))) {
                first = false;
                result = item;
            }
            return true;
        });
        return result;
    }
}
/**
 * Represents a re-arrangement of items in an array.
 */
class Permutation {
    constructor(_indexMap) {
        this._indexMap = _indexMap;
    }
    /**
     * Returns a permutation that sorts the given array according to the given compare function.
     */
    static createSortPermutation(arr, compareFn) {
        const sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));
        return new Permutation(sortIndices);
    }
    /**
     * Returns a new array with the elements of the given array re-arranged according to this permutation.
     */
    apply(arr) {
        return arr.map((_, index) => arr[this._indexMap[index]]);
    }
    /**
     * Returns a new permutation that undoes the re-arrangement of this permutation.
    */
    inverse() {
        const inverseIndexMap = this._indexMap.slice();
        for (let i = 0; i < this._indexMap.length; i++) {
            inverseIndexMap[this._indexMap[i]] = i;
        }
        return new Permutation(inverseIndexMap);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MonotonousArray: () => (/* binding */ MonotonousArray),
/* harmony export */   findFirstIdxMonotonousOrArrLen: () => (/* binding */ findFirstIdxMonotonousOrArrLen),
/* harmony export */   findFirstMax: () => (/* binding */ findFirstMax),
/* harmony export */   findFirstMin: () => (/* binding */ findFirstMin),
/* harmony export */   findFirstMonotonous: () => (/* binding */ findFirstMonotonous),
/* harmony export */   findLast: () => (/* binding */ findLast),
/* harmony export */   findLastIdx: () => (/* binding */ findLastIdx),
/* harmony export */   findLastIdxMonotonous: () => (/* binding */ findLastIdxMonotonous),
/* harmony export */   findLastMax: () => (/* binding */ findLastMax),
/* harmony export */   findLastMonotonous: () => (/* binding */ findLastMonotonous),
/* harmony export */   findMaxIdx: () => (/* binding */ findMaxIdx),
/* harmony export */   mapFindFirst: () => (/* binding */ mapFindFirst)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function findLast(array, predicate) {
    const idx = findLastIdx(array, predicate);
    if (idx === -1) {
        return undefined;
    }
    return array[idx];
}
function findLastIdx(array, predicate, fromIndex = array.length - 1) {
    for (let i = fromIndex; i >= 0; i--) {
        const element = array[i];
        if (predicate(element)) {
            return i;
        }
    }
    return -1;
}
/**
 * Finds the last item where predicate is true using binary search.
 * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
 *
 * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.
 */
function findLastMonotonous(array, predicate) {
    const idx = findLastIdxMonotonous(array, predicate);
    return idx === -1 ? undefined : array[idx];
}
/**
 * Finds the last item where predicate is true using binary search.
 * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
 *
 * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.
 */
function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
    let i = startIdx;
    let j = endIdxEx;
    while (i < j) {
        const k = Math.floor((i + j) / 2);
        if (predicate(array[k])) {
            i = k + 1;
        }
        else {
            j = k;
        }
    }
    return i - 1;
}
/**
 * Finds the first item where predicate is true using binary search.
 * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!
 *
 * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.
 */
function findFirstMonotonous(array, predicate) {
    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);
    return idx === array.length ? undefined : array[idx];
}
/**
 * Finds the first item where predicate is true using binary search.
 * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!
 *
 * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.
 */
function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {
    let i = startIdx;
    let j = endIdxEx;
    while (i < j) {
        const k = Math.floor((i + j) / 2);
        if (predicate(array[k])) {
            j = k;
        }
        else {
            i = k + 1;
        }
    }
    return i;
}
/**
 * Use this when
 * * You have a sorted array
 * * You query this array with a monotonous predicate to find the last item that has a certain property.
 * * You query this array multiple times with monotonous predicates that get weaker and weaker.
 */
class MonotonousArray {
    static { this.assertInvariants = false; }
    constructor(_array) {
        this._array = _array;
        this._findLastMonotonousLastIdx = 0;
    }
    /**
     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
     */
    findLastMonotonous(predicate) {
        if (MonotonousArray.assertInvariants) {
            if (this._prevFindLastPredicate) {
                for (const item of this._array) {
                    if (this._prevFindLastPredicate(item) && !predicate(item)) {
                        throw new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');
                    }
                }
            }
            this._prevFindLastPredicate = predicate;
        }
        const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);
        this._findLastMonotonousLastIdx = idx + 1;
        return idx === -1 ? undefined : this._array[idx];
    }
}
/**
 * Returns the first item that is equal to or greater than every other item.
*/
function findFirstMax(array, comparator) {
    if (array.length === 0) {
        return undefined;
    }
    let max = array[0];
    for (let i = 1; i < array.length; i++) {
        const item = array[i];
        if (comparator(item, max) > 0) {
            max = item;
        }
    }
    return max;
}
/**
 * Returns the last item that is equal to or greater than every other item.
*/
function findLastMax(array, comparator) {
    if (array.length === 0) {
        return undefined;
    }
    let max = array[0];
    for (let i = 1; i < array.length; i++) {
        const item = array[i];
        if (comparator(item, max) >= 0) {
            max = item;
        }
    }
    return max;
}
/**
 * Returns the first item that is equal to or less than every other item.
*/
function findFirstMin(array, comparator) {
    return findFirstMax(array, (a, b) => -comparator(a, b));
}
function findMaxIdx(array, comparator) {
    if (array.length === 0) {
        return -1;
    }
    let maxIdx = 0;
    for (let i = 1; i < array.length; i++) {
        const item = array[i];
        if (comparator(item, array[maxIdx]) > 0) {
            maxIdx = i;
        }
    }
    return maxIdx;
}
/**
 * Returns the first mapped value of the array which is not undefined.
 */
function mapFindFirst(items, mapFn) {
    for (const value of items) {
        const mapped = mapFn(value);
        if (mapped !== undefined) {
            return mapped;
        }
    }
    return undefined;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/assert.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/assert.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assertFn: () => (/* binding */ assertFn),
/* harmony export */   assertNever: () => (/* binding */ assertNever),
/* harmony export */   checkAdjacentItems: () => (/* binding */ checkAdjacentItems),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   softAssert: () => (/* binding */ softAssert)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.
 *
 * @deprecated Use `assert(...)` instead.
 * This method is usually used like this:
 * ```ts
 * import * as assert from 'vs/base/common/assert';
 * assert.ok(...);
 * ```
 *
 * However, `assert` in that example is a user chosen name.
 * There is no tooling for generating such an import statement.
 * Thus, the `assert(...)` function should be used instead.
 */
function ok(value, message) {
    if (!value) {
        throw new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');
    }
}
function assertNever(value, message = 'Unreachable') {
    throw new Error(message);
}
/**
 * Like assert, but doesn't throw.
 */
function softAssert(condition) {
    if (!condition) {
        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('Soft Assertion Failed'));
    }
}
/**
 * condition must be side-effect free!
 */
function assertFn(condition) {
    if (!condition()) {
        // eslint-disable-next-line no-debugger
        debugger;
        // Reevaluate `condition` again to make debugging easier
        condition();
        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('Assertion Failed'));
    }
}
function checkAdjacentItems(items, predicate) {
    let i = 0;
    while (i < items.length - 1) {
        const a = items[i];
        const b = items[i + 1];
        if (!predicate(a, b)) {
            return false;
        }
        i++;
    }
    return true;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/async.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/async.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractIdleValue: () => (/* binding */ AbstractIdleValue),
/* harmony export */   AsyncIterableObject: () => (/* binding */ AsyncIterableObject),
/* harmony export */   CancelableAsyncIterableObject: () => (/* binding */ CancelableAsyncIterableObject),
/* harmony export */   DeferredPromise: () => (/* binding */ DeferredPromise),
/* harmony export */   Delayer: () => (/* binding */ Delayer),
/* harmony export */   GlobalIdleValue: () => (/* binding */ GlobalIdleValue),
/* harmony export */   IntervalTimer: () => (/* binding */ IntervalTimer),
/* harmony export */   Promises: () => (/* binding */ Promises),
/* harmony export */   RunOnceScheduler: () => (/* binding */ RunOnceScheduler),
/* harmony export */   ThrottledDelayer: () => (/* binding */ ThrottledDelayer),
/* harmony export */   Throttler: () => (/* binding */ Throttler),
/* harmony export */   TimeoutTimer: () => (/* binding */ TimeoutTimer),
/* harmony export */   _runWhenIdle: () => (/* binding */ _runWhenIdle),
/* harmony export */   createCancelableAsyncIterable: () => (/* binding */ createCancelableAsyncIterable),
/* harmony export */   createCancelablePromise: () => (/* binding */ createCancelablePromise),
/* harmony export */   disposableTimeout: () => (/* binding */ disposableTimeout),
/* harmony export */   first: () => (/* binding */ first),
/* harmony export */   isThenable: () => (/* binding */ isThenable),
/* harmony export */   raceCancellation: () => (/* binding */ raceCancellation),
/* harmony export */   runWhenGlobalIdle: () => (/* binding */ runWhenGlobalIdle),
/* harmony export */   timeout: () => (/* binding */ timeout)
/* harmony export */ });
/* harmony import */ var _cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cancellation.js */ "./node_modules/monaco-editor/esm/vs/base/common/cancellation.js");
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbols.js */ "./node_modules/monaco-editor/esm/vs/base/common/symbols.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






function isThenable(obj) {
    return !!obj && typeof obj.then === 'function';
}
function createCancelablePromise(callback) {
    const source = new _cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource();
    const thenable = callback(source.token);
    const promise = new Promise((resolve, reject) => {
        const subscription = source.token.onCancellationRequested(() => {
            subscription.dispose();
            reject(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.CancellationError());
        });
        Promise.resolve(thenable).then(value => {
            subscription.dispose();
            source.dispose();
            resolve(value);
        }, err => {
            subscription.dispose();
            source.dispose();
            reject(err);
        });
    });
    return new class {
        cancel() {
            source.cancel();
            source.dispose();
        }
        then(resolve, reject) {
            return promise.then(resolve, reject);
        }
        catch(reject) {
            return this.then(undefined, reject);
        }
        finally(onfinally) {
            return promise.finally(onfinally);
        }
    };
}
function raceCancellation(promise, token, defaultValue) {
    return new Promise((resolve, reject) => {
        const ref = token.onCancellationRequested(() => {
            ref.dispose();
            resolve(defaultValue);
        });
        promise.then(resolve, reject).finally(() => ref.dispose());
    });
}
/**
 * A helper to prevent accumulation of sequential async tasks.
 *
 * Imagine a mail man with the sole task of delivering letters. As soon as
 * a letter submitted for delivery, he drives to the destination, delivers it
 * and returns to his base. Imagine that during the trip, N more letters were submitted.
 * When the mail man returns, he picks those N letters and delivers them all in a
 * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.
 *
 * The throttler implements this via the queue() method, by providing it a task
 * factory. Following the example:
 *
 * 		const throttler = new Throttler();
 * 		const letters = [];
 *
 * 		function deliver() {
 * 			const lettersToDeliver = letters;
 * 			letters = [];
 * 			return makeTheTrip(lettersToDeliver);
 * 		}
 *
 * 		function onLetterReceived(l) {
 * 			letters.push(l);
 * 			throttler.queue(deliver);
 * 		}
 */
class Throttler {
    constructor() {
        this.isDisposed = false;
        this.activePromise = null;
        this.queuedPromise = null;
        this.queuedPromiseFactory = null;
    }
    queue(promiseFactory) {
        if (this.isDisposed) {
            return Promise.reject(new Error('Throttler is disposed'));
        }
        if (this.activePromise) {
            this.queuedPromiseFactory = promiseFactory;
            if (!this.queuedPromise) {
                const onComplete = () => {
                    this.queuedPromise = null;
                    if (this.isDisposed) {
                        return;
                    }
                    const result = this.queue(this.queuedPromiseFactory);
                    this.queuedPromiseFactory = null;
                    return result;
                };
                this.queuedPromise = new Promise(resolve => {
                    this.activePromise.then(onComplete, onComplete).then(resolve);
                });
            }
            return new Promise((resolve, reject) => {
                this.queuedPromise.then(resolve, reject);
            });
        }
        this.activePromise = promiseFactory();
        return new Promise((resolve, reject) => {
            this.activePromise.then((result) => {
                this.activePromise = null;
                resolve(result);
            }, (err) => {
                this.activePromise = null;
                reject(err);
            });
        });
    }
    dispose() {
        this.isDisposed = true;
    }
}
const timeoutDeferred = (timeout, fn) => {
    let scheduled = true;
    const handle = setTimeout(() => {
        scheduled = false;
        fn();
    }, timeout);
    return {
        isTriggered: () => scheduled,
        dispose: () => {
            clearTimeout(handle);
            scheduled = false;
        },
    };
};
const microtaskDeferred = (fn) => {
    let scheduled = true;
    queueMicrotask(() => {
        if (scheduled) {
            scheduled = false;
            fn();
        }
    });
    return {
        isTriggered: () => scheduled,
        dispose: () => { scheduled = false; },
    };
};
/**
 * A helper to delay (debounce) execution of a task that is being requested often.
 *
 * Following the throttler, now imagine the mail man wants to optimize the number of
 * trips proactively. The trip itself can be long, so he decides not to make the trip
 * as soon as a letter is submitted. Instead he waits a while, in case more
 * letters are submitted. After said waiting period, if no letters were submitted, he
 * decides to make the trip. Imagine that N more letters were submitted after the first
 * one, all within a short period of time between each other. Even though N+1
 * submissions occurred, only 1 delivery was made.
 *
 * The delayer offers this behavior via the trigger() method, into which both the task
 * to be executed and the waiting period (delay) must be passed in as arguments. Following
 * the example:
 *
 * 		const delayer = new Delayer(WAITING_PERIOD);
 * 		const letters = [];
 *
 * 		function letterReceived(l) {
 * 			letters.push(l);
 * 			delayer.trigger(() => { return makeTheTrip(); });
 * 		}
 */
class Delayer {
    constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.deferred = null;
        this.completionPromise = null;
        this.doResolve = null;
        this.doReject = null;
        this.task = null;
    }
    trigger(task, delay = this.defaultDelay) {
        this.task = task;
        this.cancelTimeout();
        if (!this.completionPromise) {
            this.completionPromise = new Promise((resolve, reject) => {
                this.doResolve = resolve;
                this.doReject = reject;
            }).then(() => {
                this.completionPromise = null;
                this.doResolve = null;
                if (this.task) {
                    const task = this.task;
                    this.task = null;
                    return task();
                }
                return undefined;
            });
        }
        const fn = () => {
            this.deferred = null;
            this.doResolve?.(null);
        };
        this.deferred = delay === _symbols_js__WEBPACK_IMPORTED_MODULE_5__.MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);
        return this.completionPromise;
    }
    isTriggered() {
        return !!this.deferred?.isTriggered();
    }
    cancel() {
        this.cancelTimeout();
        if (this.completionPromise) {
            this.doReject?.(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.CancellationError());
            this.completionPromise = null;
        }
    }
    cancelTimeout() {
        this.deferred?.dispose();
        this.deferred = null;
    }
    dispose() {
        this.cancel();
    }
}
/**
 * A helper to delay execution of a task that is being requested often, while
 * preventing accumulation of consecutive executions, while the task runs.
 *
 * The mail man is clever and waits for a certain amount of time, before going
 * out to deliver letters. While the mail man is going out, more letters arrive
 * and can only be delivered once he is back. Once he is back the mail man will
 * do one more trip to deliver the letters that have accumulated while he was out.
 */
class ThrottledDelayer {
    constructor(defaultDelay) {
        this.delayer = new Delayer(defaultDelay);
        this.throttler = new Throttler();
    }
    trigger(promiseFactory, delay) {
        return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);
    }
    cancel() {
        this.delayer.cancel();
    }
    dispose() {
        this.delayer.dispose();
        this.throttler.dispose();
    }
}
function timeout(millis, token) {
    if (!token) {
        return createCancelablePromise(token => timeout(millis, token));
    }
    return new Promise((resolve, reject) => {
        const handle = setTimeout(() => {
            disposable.dispose();
            resolve();
        }, millis);
        const disposable = token.onCancellationRequested(() => {
            clearTimeout(handle);
            disposable.dispose();
            reject(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.CancellationError());
        });
    });
}
/**
 * Creates a timeout that can be disposed using its returned value.
 * @param handler The timeout handler.
 * @param timeout An optional timeout in milliseconds.
 * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.
 *
 * @example
 * const store = new DisposableStore;
 * // Call the timeout after 1000ms at which point it will be automatically
 * // evicted from the store.
 * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);
 *
 * if (foo) {
 *   // Cancel the timeout and evict it from store.
 *   timeoutDisposable.dispose();
 * }
 */
function disposableTimeout(handler, timeout = 0, store) {
    const timer = setTimeout(() => {
        handler();
        if (store) {
            disposable.dispose();
        }
    }, timeout);
    const disposable = (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_3__.toDisposable)(() => {
        clearTimeout(timer);
        store?.deleteAndLeak(disposable);
    });
    store?.add(disposable);
    return disposable;
}
function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {
    let index = 0;
    const len = promiseFactories.length;
    const loop = () => {
        if (index >= len) {
            return Promise.resolve(defaultValue);
        }
        const factory = promiseFactories[index++];
        const promise = Promise.resolve(factory());
        return promise.then(result => {
            if (shouldStop(result)) {
                return Promise.resolve(result);
            }
            return loop();
        });
    };
    return loop();
}
class TimeoutTimer {
    constructor(runner, timeout) {
        this._isDisposed = false;
        this._token = -1;
        if (typeof runner === 'function' && typeof timeout === 'number') {
            this.setIfNotSet(runner, timeout);
        }
    }
    dispose() {
        this.cancel();
        this._isDisposed = true;
    }
    cancel() {
        if (this._token !== -1) {
            clearTimeout(this._token);
            this._token = -1;
        }
    }
    cancelAndSet(runner, timeout) {
        if (this._isDisposed) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);
        }
        this.cancel();
        this._token = setTimeout(() => {
            this._token = -1;
            runner();
        }, timeout);
    }
    setIfNotSet(runner, timeout) {
        if (this._isDisposed) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);
        }
        if (this._token !== -1) {
            // timer is already set
            return;
        }
        this._token = setTimeout(() => {
            this._token = -1;
            runner();
        }, timeout);
    }
}
class IntervalTimer {
    constructor() {
        this.disposable = undefined;
        this.isDisposed = false;
    }
    cancel() {
        this.disposable?.dispose();
        this.disposable = undefined;
    }
    cancelAndSet(runner, interval, context = globalThis) {
        if (this.isDisposed) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);
        }
        this.cancel();
        const handle = context.setInterval(() => {
            runner();
        }, interval);
        this.disposable = (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_3__.toDisposable)(() => {
            context.clearInterval(handle);
            this.disposable = undefined;
        });
    }
    dispose() {
        this.cancel();
        this.isDisposed = true;
    }
}
class RunOnceScheduler {
    constructor(runner, delay) {
        this.timeoutToken = -1;
        this.runner = runner;
        this.timeout = delay;
        this.timeoutHandler = this.onTimeout.bind(this);
    }
    /**
     * Dispose RunOnceScheduler
     */
    dispose() {
        this.cancel();
        this.runner = null;
    }
    /**
     * Cancel current scheduled runner (if any).
     */
    cancel() {
        if (this.isScheduled()) {
            clearTimeout(this.timeoutToken);
            this.timeoutToken = -1;
        }
    }
    /**
     * Cancel previous runner (if any) & schedule a new runner.
     */
    schedule(delay = this.timeout) {
        this.cancel();
        this.timeoutToken = setTimeout(this.timeoutHandler, delay);
    }
    get delay() {
        return this.timeout;
    }
    set delay(value) {
        this.timeout = value;
    }
    /**
     * Returns true if scheduled.
     */
    isScheduled() {
        return this.timeoutToken !== -1;
    }
    onTimeout() {
        this.timeoutToken = -1;
        if (this.runner) {
            this.doRun();
        }
    }
    doRun() {
        this.runner?.();
    }
}
/**
 * Execute the callback the next time the browser is idle, returning an
 * {@link IDisposable} that will cancel the callback when disposed. This wraps
 * [requestIdleCallback] so it will fallback to [setTimeout] if the environment
 * doesn't support it.
 *
 * @param callback The callback to run when idle, this includes an
 * [IdleDeadline] that provides the time alloted for the idle callback by the
 * browser. Not respecting this deadline will result in a degraded user
 * experience.
 * @param timeout A timeout at which point to queue no longer wait for an idle
 * callback but queue it on the regular event loop (like setTimeout). Typically
 * this should not be used.
 *
 * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline
 * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback
 * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout
 *
 * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser
 * context
 */
let runWhenGlobalIdle;
let _runWhenIdle;
(function () {
    if (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {
        _runWhenIdle = (_targetWindow, runner) => {
            (0,_platform_js__WEBPACK_IMPORTED_MODULE_4__.setTimeout0)(() => {
                if (disposed) {
                    return;
                }
                const end = Date.now() + 15; // one frame at 64fps
                const deadline = {
                    didTimeout: true,
                    timeRemaining() {
                        return Math.max(0, end - Date.now());
                    }
                };
                runner(Object.freeze(deadline));
            });
            let disposed = false;
            return {
                dispose() {
                    if (disposed) {
                        return;
                    }
                    disposed = true;
                }
            };
        };
    }
    else {
        _runWhenIdle = (targetWindow, runner, timeout) => {
            const handle = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);
            let disposed = false;
            return {
                dispose() {
                    if (disposed) {
                        return;
                    }
                    disposed = true;
                    targetWindow.cancelIdleCallback(handle);
                }
            };
        };
    }
    runWhenGlobalIdle = (runner) => _runWhenIdle(globalThis, runner);
})();
class AbstractIdleValue {
    constructor(targetWindow, executor) {
        this._didRun = false;
        this._executor = () => {
            try {
                this._value = executor();
            }
            catch (err) {
                this._error = err;
            }
            finally {
                this._didRun = true;
            }
        };
        this._handle = _runWhenIdle(targetWindow, () => this._executor());
    }
    dispose() {
        this._handle.dispose();
    }
    get value() {
        if (!this._didRun) {
            this._handle.dispose();
            this._executor();
        }
        if (this._error) {
            throw this._error;
        }
        return this._value;
    }
    get isInitialized() {
        return this._didRun;
    }
}
/**
 * An `IdleValue` that always uses the current window (which might be throttled or inactive)
 *
 * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser
 * context
 */
class GlobalIdleValue extends AbstractIdleValue {
    constructor(executor) {
        super(globalThis, executor);
    }
}
/**
 * Creates a promise whose resolution or rejection can be controlled imperatively.
 */
class DeferredPromise {
    get isRejected() {
        return this.outcome?.outcome === 1 /* DeferredOutcome.Rejected */;
    }
    get isSettled() {
        return !!this.outcome;
    }
    constructor() {
        this.p = new Promise((c, e) => {
            this.completeCallback = c;
            this.errorCallback = e;
        });
    }
    complete(value) {
        return new Promise(resolve => {
            this.completeCallback(value);
            this.outcome = { outcome: 0 /* DeferredOutcome.Resolved */, value };
            resolve();
        });
    }
    error(err) {
        return new Promise(resolve => {
            this.errorCallback(err);
            this.outcome = { outcome: 1 /* DeferredOutcome.Rejected */, value: err };
            resolve();
        });
    }
    cancel() {
        return this.error(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.CancellationError());
    }
}
//#endregion
//#region Promises
var Promises;
(function (Promises) {
    /**
     * A drop-in replacement for `Promise.all` with the only difference
     * that the method awaits every promise to either fulfill or reject.
     *
     * Similar to `Promise.all`, only the first error will be returned
     * if any.
     */
    async function settled(promises) {
        let firstError = undefined;
        const result = await Promise.all(promises.map(promise => promise.then(value => value, error => {
            if (!firstError) {
                firstError = error;
            }
            return undefined; // do not rethrow so that other promises can settle
        })));
        if (typeof firstError !== 'undefined') {
            throw firstError;
        }
        return result; // cast is needed and protected by the `throw` above
    }
    Promises.settled = settled;
    /**
     * A helper to create a new `Promise<T>` with a body that is a promise
     * itself. By default, an error that raises from the async body will
     * end up as a unhandled rejection, so this utility properly awaits the
     * body and rejects the promise as a normal promise does without async
     * body.
     *
     * This method should only be used in rare cases where otherwise `async`
     * cannot be used (e.g. when callbacks are involved that require this).
     */
    function withAsyncBody(bodyFn) {
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(async (resolve, reject) => {
            try {
                await bodyFn(resolve, reject);
            }
            catch (error) {
                reject(error);
            }
        });
    }
    Promises.withAsyncBody = withAsyncBody;
})(Promises || (Promises = {}));
/**
 * A rich implementation for an `AsyncIterable<T>`.
 */
class AsyncIterableObject {
    static fromArray(items) {
        return new AsyncIterableObject((writer) => {
            writer.emitMany(items);
        });
    }
    static fromPromise(promise) {
        return new AsyncIterableObject(async (emitter) => {
            emitter.emitMany(await promise);
        });
    }
    static fromPromises(promises) {
        return new AsyncIterableObject(async (emitter) => {
            await Promise.all(promises.map(async (p) => emitter.emitOne(await p)));
        });
    }
    static merge(iterables) {
        return new AsyncIterableObject(async (emitter) => {
            await Promise.all(iterables.map(async (iterable) => {
                for await (const item of iterable) {
                    emitter.emitOne(item);
                }
            }));
        });
    }
    static { this.EMPTY = AsyncIterableObject.fromArray([]); }
    constructor(executor, onReturn) {
        this._state = 0 /* AsyncIterableSourceState.Initial */;
        this._results = [];
        this._error = null;
        this._onReturn = onReturn;
        this._onStateChanged = new _event_js__WEBPACK_IMPORTED_MODULE_2__.Emitter();
        queueMicrotask(async () => {
            const writer = {
                emitOne: (item) => this.emitOne(item),
                emitMany: (items) => this.emitMany(items),
                reject: (error) => this.reject(error)
            };
            try {
                await Promise.resolve(executor(writer));
                this.resolve();
            }
            catch (err) {
                this.reject(err);
            }
            finally {
                writer.emitOne = undefined;
                writer.emitMany = undefined;
                writer.reject = undefined;
            }
        });
    }
    [Symbol.asyncIterator]() {
        let i = 0;
        return {
            next: async () => {
                do {
                    if (this._state === 2 /* AsyncIterableSourceState.DoneError */) {
                        throw this._error;
                    }
                    if (i < this._results.length) {
                        return { done: false, value: this._results[i++] };
                    }
                    if (this._state === 1 /* AsyncIterableSourceState.DoneOK */) {
                        return { done: true, value: undefined };
                    }
                    await _event_js__WEBPACK_IMPORTED_MODULE_2__.Event.toPromise(this._onStateChanged.event);
                } while (true);
            },
            return: async () => {
                this._onReturn?.();
                return { done: true, value: undefined };
            }
        };
    }
    static map(iterable, mapFn) {
        return new AsyncIterableObject(async (emitter) => {
            for await (const item of iterable) {
                emitter.emitOne(mapFn(item));
            }
        });
    }
    map(mapFn) {
        return AsyncIterableObject.map(this, mapFn);
    }
    static filter(iterable, filterFn) {
        return new AsyncIterableObject(async (emitter) => {
            for await (const item of iterable) {
                if (filterFn(item)) {
                    emitter.emitOne(item);
                }
            }
        });
    }
    filter(filterFn) {
        return AsyncIterableObject.filter(this, filterFn);
    }
    static coalesce(iterable) {
        return AsyncIterableObject.filter(iterable, item => !!item);
    }
    coalesce() {
        return AsyncIterableObject.coalesce(this);
    }
    static async toPromise(iterable) {
        const result = [];
        for await (const item of iterable) {
            result.push(item);
        }
        return result;
    }
    toPromise() {
        return AsyncIterableObject.toPromise(this);
    }
    /**
     * The value will be appended at the end.
     *
     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
     */
    emitOne(value) {
        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {
            return;
        }
        // it is important to add new values at the end,
        // as we may have iterators already running on the array
        this._results.push(value);
        this._onStateChanged.fire();
    }
    /**
     * The values will be appended at the end.
     *
     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
     */
    emitMany(values) {
        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {
            return;
        }
        // it is important to add new values at the end,
        // as we may have iterators already running on the array
        this._results = this._results.concat(values);
        this._onStateChanged.fire();
    }
    /**
     * Calling `resolve()` will mark the result array as complete.
     *
     * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
     */
    resolve() {
        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {
            return;
        }
        this._state = 1 /* AsyncIterableSourceState.DoneOK */;
        this._onStateChanged.fire();
    }
    /**
     * Writing an error will permanently invalidate this iterable.
     * The current users will receive an error thrown, as will all future users.
     *
     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
     */
    reject(error) {
        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {
            return;
        }
        this._state = 2 /* AsyncIterableSourceState.DoneError */;
        this._error = error;
        this._onStateChanged.fire();
    }
}
class CancelableAsyncIterableObject extends AsyncIterableObject {
    constructor(_source, executor) {
        super(executor);
        this._source = _source;
    }
    cancel() {
        this._source.cancel();
    }
}
function createCancelableAsyncIterable(callback) {
    const source = new _cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource();
    const innerIterable = callback(source.token);
    return new CancelableAsyncIterableObject(source, async (emitter) => {
        const subscription = source.token.onCancellationRequested(() => {
            subscription.dispose();
            source.dispose();
            emitter.reject(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.CancellationError());
        });
        try {
            for await (const item of innerIterable) {
                if (source.token.isCancellationRequested) {
                    // canceled in the meantime
                    return;
                }
                emitter.emitOne(item);
            }
            subscription.dispose();
            source.dispose();
        }
        catch (err) {
            subscription.dispose();
            source.dispose();
            emitter.reject(err);
        }
    });
}
//#endregion


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/cache.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/cache.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CachedFunction: () => (/* binding */ CachedFunction),
/* harmony export */   LRUCachedFunction: () => (/* binding */ LRUCachedFunction),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function identity(t) {
    return t;
}
/**
 * Uses a LRU cache to make a given parametrized function cached.
 * Caches just the last key/value.
*/
class LRUCachedFunction {
    constructor(arg1, arg2) {
        this.lastCache = undefined;
        this.lastArgKey = undefined;
        if (typeof arg1 === 'function') {
            this._fn = arg1;
            this._computeKey = identity;
        }
        else {
            this._fn = arg2;
            this._computeKey = arg1.getCacheKey;
        }
    }
    get(arg) {
        const key = this._computeKey(arg);
        if (this.lastArgKey !== key) {
            this.lastArgKey = key;
            this.lastCache = this._fn(arg);
        }
        return this.lastCache;
    }
}
/**
 * Uses an unbounded cache to memoize the results of the given function.
*/
class CachedFunction {
    get cachedValues() {
        return this._map;
    }
    constructor(arg1, arg2) {
        this._map = new Map();
        this._map2 = new Map();
        if (typeof arg1 === 'function') {
            this._fn = arg1;
            this._computeKey = identity;
        }
        else {
            this._fn = arg2;
            this._computeKey = arg1.getCacheKey;
        }
    }
    get(arg) {
        const key = this._computeKey(arg);
        if (this._map2.has(key)) {
            return this._map2.get(key);
        }
        const value = this._fn(arg);
        this._map.set(arg, value);
        this._map2.set(key, value);
        return value;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/cancellation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/cancellation.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CancellationToken: () => (/* binding */ CancellationToken),
/* harmony export */   CancellationTokenSource: () => (/* binding */ CancellationTokenSource),
/* harmony export */   cancelOnDispose: () => (/* binding */ cancelOnDispose)
/* harmony export */ });
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = setTimeout(callback.bind(context), 0);
    return { dispose() { clearTimeout(handle); } };
});
var CancellationToken;
(function (CancellationToken) {
    function isCancellationToken(thing) {
        if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {
            return true;
        }
        if (thing instanceof MutableToken) {
            return true;
        }
        if (!thing || typeof thing !== 'object') {
            return false;
        }
        return typeof thing.isCancellationRequested === 'boolean'
            && typeof thing.onCancellationRequested === 'function';
    }
    CancellationToken.isCancellationToken = isCancellationToken;
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: _event_js__WEBPACK_IMPORTED_MODULE_0__.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: shortcutEvent
    });
})(CancellationToken || (CancellationToken = {}));
class MutableToken {
    constructor() {
        this._isCancelled = false;
        this._emitter = null;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new _event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = null;
        }
    }
}
class CancellationTokenSource {
    constructor(parent) {
        this._token = undefined;
        this._parentListener = undefined;
        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
    }
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else if (this._token instanceof MutableToken) {
            // actually cancel
            this._token.cancel();
        }
    }
    dispose(cancel = false) {
        if (cancel) {
            this.cancel();
        }
        this._parentListener?.dispose();
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
function cancelOnDispose(store) {
    const source = new CancellationTokenSource();
    store.add({ dispose() { source.cancel(); } });
    return source.token;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/codicons.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/codicons.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Codicon: () => (/* binding */ Codicon),
/* harmony export */   codiconsDerived: () => (/* binding */ codiconsDerived)
/* harmony export */ });
/* harmony import */ var _codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codiconsUtil.js */ "./node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js");
/* harmony import */ var _codiconsLibrary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./codiconsLibrary.js */ "./node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js");


/**
 * Derived icons, that could become separate icons.
 * These mappings should be moved into the mapping file in the vscode-codicons repo at some point.
 */
const codiconsDerived = {
    dialogError: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dialog-error', 'error'),
    dialogWarning: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dialog-warning', 'warning'),
    dialogInfo: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dialog-info', 'info'),
    dialogClose: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dialog-close', 'close'),
    treeItemExpanded: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tree-item-expanded', 'chevron-down'), // collapsed is done with rotation
    treeFilterOnTypeOn: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tree-filter-on-type-on', 'list-filter'),
    treeFilterOnTypeOff: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tree-filter-on-type-off', 'list-selection'),
    treeFilterClear: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tree-filter-clear', 'close'),
    treeItemLoading: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tree-item-loading', 'loading'),
    menuSelection: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('menu-selection', 'check'),
    menuSubmenu: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('menu-submenu', 'chevron-right'),
    menuBarMore: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('menubar-more', 'more'),
    scrollbarButtonLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('scrollbar-button-left', 'triangle-left'),
    scrollbarButtonRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('scrollbar-button-right', 'triangle-right'),
    scrollbarButtonUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('scrollbar-button-up', 'triangle-up'),
    scrollbarButtonDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('scrollbar-button-down', 'triangle-down'),
    toolBarMore: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('toolbar-more', 'more'),
    quickInputBack: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('quick-input-back', 'arrow-left'),
    dropDownButton: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('drop-down-button', 0xeab4),
    symbolCustomColor: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-customcolor', 0xeb5c),
    exportIcon: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('export', 0xebac),
    workspaceUnspecified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('workspace-unspecified', 0xebc3),
    newLine: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('newline', 0xebea),
    thumbsDownFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsdown-filled', 0xec13),
    thumbsUpFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsup-filled', 0xec14),
    gitFetch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-fetch', 0xec1d),
    lightbulbSparkleAutofix: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lightbulb-sparkle-autofix', 0xec1f),
    debugBreakpointPending: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-pending', 0xebd9),
};
/**
 * The Codicon library is a set of default icons that are built-in in VS Code.
 *
 * In the product (outside of base) Codicons should only be used as defaults. In order to have all icons in VS Code
 * themeable, component should define new, UI component specific icons using `iconRegistry.registerIcon`.
 * In that call a Codicon can be named as default.
 */
const Codicon = {
    ..._codiconsLibrary_js__WEBPACK_IMPORTED_MODULE_1__.codiconsLibrary,
    ...codiconsDerived
};


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   codiconsLibrary: () => (/* binding */ codiconsLibrary)
/* harmony export */ });
/* harmony import */ var _codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codiconsUtil.js */ "./node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

// This file is automatically generated by (microsoft/vscode-codicons)/scripts/export-to-ts.js
// Please don't edit it, as your changes will be overwritten.
// Instead, add mappings to codiconsDerived in codicons.ts.
const codiconsLibrary = {
    add: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('add', 0xea60),
    plus: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('plus', 0xea60),
    gistNew: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gist-new', 0xea60),
    repoCreate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-create', 0xea60),
    lightbulb: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lightbulb', 0xea61),
    lightBulb: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('light-bulb', 0xea61),
    repo: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo', 0xea62),
    repoDelete: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-delete', 0xea62),
    gistFork: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gist-fork', 0xea63),
    repoForked: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-forked', 0xea63),
    gitPullRequest: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request', 0xea64),
    gitPullRequestAbandoned: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-abandoned', 0xea64),
    recordKeys: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('record-keys', 0xea65),
    keyboard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('keyboard', 0xea65),
    tag: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tag', 0xea66),
    gitPullRequestLabel: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-label', 0xea66),
    tagAdd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tag-add', 0xea66),
    tagRemove: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tag-remove', 0xea66),
    person: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('person', 0xea67),
    personFollow: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('person-follow', 0xea67),
    personOutline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('person-outline', 0xea67),
    personFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('person-filled', 0xea67),
    gitBranch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-branch', 0xea68),
    gitBranchCreate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-branch-create', 0xea68),
    gitBranchDelete: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-branch-delete', 0xea68),
    sourceControl: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('source-control', 0xea68),
    mirror: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mirror', 0xea69),
    mirrorPublic: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mirror-public', 0xea69),
    star: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star', 0xea6a),
    starAdd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star-add', 0xea6a),
    starDelete: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star-delete', 0xea6a),
    starEmpty: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star-empty', 0xea6a),
    comment: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('comment', 0xea6b),
    commentAdd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('comment-add', 0xea6b),
    alert: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('alert', 0xea6c),
    warning: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('warning', 0xea6c),
    search: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('search', 0xea6d),
    searchSave: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('search-save', 0xea6d),
    logOut: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('log-out', 0xea6e),
    signOut: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sign-out', 0xea6e),
    logIn: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('log-in', 0xea6f),
    signIn: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sign-in', 0xea6f),
    eye: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('eye', 0xea70),
    eyeUnwatch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('eye-unwatch', 0xea70),
    eyeWatch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('eye-watch', 0xea70),
    circleFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-filled', 0xea71),
    primitiveDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('primitive-dot', 0xea71),
    closeDirty: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('close-dirty', 0xea71),
    debugBreakpoint: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint', 0xea71),
    debugBreakpointDisabled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-disabled', 0xea71),
    debugHint: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-hint', 0xea71),
    terminalDecorationSuccess: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-decoration-success', 0xea71),
    primitiveSquare: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('primitive-square', 0xea72),
    edit: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('edit', 0xea73),
    pencil: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pencil', 0xea73),
    info: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('info', 0xea74),
    issueOpened: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('issue-opened', 0xea74),
    gistPrivate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gist-private', 0xea75),
    gitForkPrivate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-fork-private', 0xea75),
    lock: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lock', 0xea75),
    mirrorPrivate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mirror-private', 0xea75),
    close: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('close', 0xea76),
    removeClose: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('remove-close', 0xea76),
    x: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('x', 0xea76),
    repoSync: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-sync', 0xea77),
    sync: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sync', 0xea77),
    clone: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('clone', 0xea78),
    desktopDownload: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('desktop-download', 0xea78),
    beaker: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('beaker', 0xea79),
    microscope: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('microscope', 0xea79),
    vm: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vm', 0xea7a),
    deviceDesktop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('device-desktop', 0xea7a),
    file: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file', 0xea7b),
    fileText: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-text', 0xea7b),
    more: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('more', 0xea7c),
    ellipsis: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('ellipsis', 0xea7c),
    kebabHorizontal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('kebab-horizontal', 0xea7c),
    mailReply: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mail-reply', 0xea7d),
    reply: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('reply', 0xea7d),
    organization: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('organization', 0xea7e),
    organizationFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('organization-filled', 0xea7e),
    organizationOutline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('organization-outline', 0xea7e),
    newFile: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('new-file', 0xea7f),
    fileAdd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-add', 0xea7f),
    newFolder: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('new-folder', 0xea80),
    fileDirectoryCreate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-directory-create', 0xea80),
    trash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('trash', 0xea81),
    trashcan: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('trashcan', 0xea81),
    history: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('history', 0xea82),
    clock: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('clock', 0xea82),
    folder: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('folder', 0xea83),
    fileDirectory: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-directory', 0xea83),
    symbolFolder: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-folder', 0xea83),
    logoGithub: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('logo-github', 0xea84),
    markGithub: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mark-github', 0xea84),
    github: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('github', 0xea84),
    terminal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal', 0xea85),
    console: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('console', 0xea85),
    repl: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repl', 0xea85),
    zap: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('zap', 0xea86),
    symbolEvent: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-event', 0xea86),
    error: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('error', 0xea87),
    stop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('stop', 0xea87),
    variable: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('variable', 0xea88),
    symbolVariable: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-variable', 0xea88),
    array: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('array', 0xea8a),
    symbolArray: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-array', 0xea8a),
    symbolModule: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-module', 0xea8b),
    symbolPackage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-package', 0xea8b),
    symbolNamespace: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-namespace', 0xea8b),
    symbolObject: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-object', 0xea8b),
    symbolMethod: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-method', 0xea8c),
    symbolFunction: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-function', 0xea8c),
    symbolConstructor: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-constructor', 0xea8c),
    symbolBoolean: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-boolean', 0xea8f),
    symbolNull: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-null', 0xea8f),
    symbolNumeric: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-numeric', 0xea90),
    symbolNumber: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-number', 0xea90),
    symbolStructure: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-structure', 0xea91),
    symbolStruct: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-struct', 0xea91),
    symbolParameter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-parameter', 0xea92),
    symbolTypeParameter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-type-parameter', 0xea92),
    symbolKey: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-key', 0xea93),
    symbolText: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-text', 0xea93),
    symbolReference: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-reference', 0xea94),
    goToFile: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('go-to-file', 0xea94),
    symbolEnum: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-enum', 0xea95),
    symbolValue: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-value', 0xea95),
    symbolRuler: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-ruler', 0xea96),
    symbolUnit: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-unit', 0xea96),
    activateBreakpoints: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('activate-breakpoints', 0xea97),
    archive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('archive', 0xea98),
    arrowBoth: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-both', 0xea99),
    arrowDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-down', 0xea9a),
    arrowLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-left', 0xea9b),
    arrowRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-right', 0xea9c),
    arrowSmallDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-small-down', 0xea9d),
    arrowSmallLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-small-left', 0xea9e),
    arrowSmallRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-small-right', 0xea9f),
    arrowSmallUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-small-up', 0xeaa0),
    arrowUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-up', 0xeaa1),
    bell: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bell', 0xeaa2),
    bold: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bold', 0xeaa3),
    book: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('book', 0xeaa4),
    bookmark: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bookmark', 0xeaa5),
    debugBreakpointConditionalUnverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-conditional-unverified', 0xeaa6),
    debugBreakpointConditional: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-conditional', 0xeaa7),
    debugBreakpointConditionalDisabled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-conditional-disabled', 0xeaa7),
    debugBreakpointDataUnverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-data-unverified', 0xeaa8),
    debugBreakpointData: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-data', 0xeaa9),
    debugBreakpointDataDisabled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-data-disabled', 0xeaa9),
    debugBreakpointLogUnverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-log-unverified', 0xeaaa),
    debugBreakpointLog: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-log', 0xeaab),
    debugBreakpointLogDisabled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-log-disabled', 0xeaab),
    briefcase: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('briefcase', 0xeaac),
    broadcast: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('broadcast', 0xeaad),
    browser: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('browser', 0xeaae),
    bug: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bug', 0xeaaf),
    calendar: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('calendar', 0xeab0),
    caseSensitive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('case-sensitive', 0xeab1),
    check: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('check', 0xeab2),
    checklist: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('checklist', 0xeab3),
    chevronDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chevron-down', 0xeab4),
    chevronLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chevron-left', 0xeab5),
    chevronRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chevron-right', 0xeab6),
    chevronUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chevron-up', 0xeab7),
    chromeClose: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chrome-close', 0xeab8),
    chromeMaximize: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chrome-maximize', 0xeab9),
    chromeMinimize: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chrome-minimize', 0xeaba),
    chromeRestore: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chrome-restore', 0xeabb),
    circleOutline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-outline', 0xeabc),
    circle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle', 0xeabc),
    debugBreakpointUnverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-unverified', 0xeabc),
    terminalDecorationIncomplete: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-decoration-incomplete', 0xeabc),
    circleSlash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-slash', 0xeabd),
    circuitBoard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circuit-board', 0xeabe),
    clearAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('clear-all', 0xeabf),
    clippy: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('clippy', 0xeac0),
    closeAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('close-all', 0xeac1),
    cloudDownload: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('cloud-download', 0xeac2),
    cloudUpload: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('cloud-upload', 0xeac3),
    code: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('code', 0xeac4),
    collapseAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('collapse-all', 0xeac5),
    colorMode: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('color-mode', 0xeac6),
    commentDiscussion: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('comment-discussion', 0xeac7),
    creditCard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('credit-card', 0xeac9),
    dash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dash', 0xeacc),
    dashboard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dashboard', 0xeacd),
    database: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('database', 0xeace),
    debugContinue: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-continue', 0xeacf),
    debugDisconnect: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-disconnect', 0xead0),
    debugPause: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-pause', 0xead1),
    debugRestart: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-restart', 0xead2),
    debugStart: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-start', 0xead3),
    debugStepInto: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-step-into', 0xead4),
    debugStepOut: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-step-out', 0xead5),
    debugStepOver: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-step-over', 0xead6),
    debugStop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-stop', 0xead7),
    debug: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug', 0xead8),
    deviceCameraVideo: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('device-camera-video', 0xead9),
    deviceCamera: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('device-camera', 0xeada),
    deviceMobile: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('device-mobile', 0xeadb),
    diffAdded: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-added', 0xeadc),
    diffIgnored: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-ignored', 0xeadd),
    diffModified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-modified', 0xeade),
    diffRemoved: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-removed', 0xeadf),
    diffRenamed: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-renamed', 0xeae0),
    diff: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff', 0xeae1),
    diffSidebyside: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-sidebyside', 0xeae1),
    discard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('discard', 0xeae2),
    editorLayout: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('editor-layout', 0xeae3),
    emptyWindow: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('empty-window', 0xeae4),
    exclude: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('exclude', 0xeae5),
    extensions: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('extensions', 0xeae6),
    eyeClosed: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('eye-closed', 0xeae7),
    fileBinary: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-binary', 0xeae8),
    fileCode: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-code', 0xeae9),
    fileMedia: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-media', 0xeaea),
    filePdf: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-pdf', 0xeaeb),
    fileSubmodule: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-submodule', 0xeaec),
    fileSymlinkDirectory: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-symlink-directory', 0xeaed),
    fileSymlinkFile: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-symlink-file', 0xeaee),
    fileZip: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-zip', 0xeaef),
    files: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('files', 0xeaf0),
    filter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('filter', 0xeaf1),
    flame: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('flame', 0xeaf2),
    foldDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-down', 0xeaf3),
    foldUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-up', 0xeaf4),
    fold: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold', 0xeaf5),
    folderActive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('folder-active', 0xeaf6),
    folderOpened: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('folder-opened', 0xeaf7),
    gear: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gear', 0xeaf8),
    gift: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gift', 0xeaf9),
    gistSecret: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gist-secret', 0xeafa),
    gist: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gist', 0xeafb),
    gitCommit: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-commit', 0xeafc),
    gitCompare: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-compare', 0xeafd),
    compareChanges: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('compare-changes', 0xeafd),
    gitMerge: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-merge', 0xeafe),
    githubAction: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('github-action', 0xeaff),
    githubAlt: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('github-alt', 0xeb00),
    globe: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('globe', 0xeb01),
    grabber: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('grabber', 0xeb02),
    graph: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('graph', 0xeb03),
    gripper: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gripper', 0xeb04),
    heart: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('heart', 0xeb05),
    home: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('home', 0xeb06),
    horizontalRule: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('horizontal-rule', 0xeb07),
    hubot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('hubot', 0xeb08),
    inbox: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('inbox', 0xeb09),
    issueReopened: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('issue-reopened', 0xeb0b),
    issues: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('issues', 0xeb0c),
    italic: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('italic', 0xeb0d),
    jersey: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('jersey', 0xeb0e),
    json: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('json', 0xeb0f),
    kebabVertical: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('kebab-vertical', 0xeb10),
    key: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('key', 0xeb11),
    law: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('law', 0xeb12),
    lightbulbAutofix: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lightbulb-autofix', 0xeb13),
    linkExternal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('link-external', 0xeb14),
    link: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('link', 0xeb15),
    listOrdered: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-ordered', 0xeb16),
    listUnordered: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-unordered', 0xeb17),
    liveShare: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('live-share', 0xeb18),
    loading: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('loading', 0xeb19),
    location: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('location', 0xeb1a),
    mailRead: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mail-read', 0xeb1b),
    mail: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mail', 0xeb1c),
    markdown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('markdown', 0xeb1d),
    megaphone: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('megaphone', 0xeb1e),
    mention: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mention', 0xeb1f),
    milestone: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('milestone', 0xeb20),
    gitPullRequestMilestone: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-milestone', 0xeb20),
    mortarBoard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mortar-board', 0xeb21),
    move: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('move', 0xeb22),
    multipleWindows: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('multiple-windows', 0xeb23),
    mute: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mute', 0xeb24),
    noNewline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('no-newline', 0xeb25),
    note: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('note', 0xeb26),
    octoface: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('octoface', 0xeb27),
    openPreview: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('open-preview', 0xeb28),
    package: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('package', 0xeb29),
    paintcan: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('paintcan', 0xeb2a),
    pin: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pin', 0xeb2b),
    play: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('play', 0xeb2c),
    run: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run', 0xeb2c),
    plug: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('plug', 0xeb2d),
    preserveCase: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('preserve-case', 0xeb2e),
    preview: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('preview', 0xeb2f),
    project: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('project', 0xeb30),
    pulse: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pulse', 0xeb31),
    question: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('question', 0xeb32),
    quote: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('quote', 0xeb33),
    radioTower: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('radio-tower', 0xeb34),
    reactions: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('reactions', 0xeb35),
    references: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('references', 0xeb36),
    refresh: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('refresh', 0xeb37),
    regex: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('regex', 0xeb38),
    remoteExplorer: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('remote-explorer', 0xeb39),
    remote: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('remote', 0xeb3a),
    remove: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('remove', 0xeb3b),
    replaceAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('replace-all', 0xeb3c),
    replace: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('replace', 0xeb3d),
    repoClone: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-clone', 0xeb3e),
    repoForcePush: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-force-push', 0xeb3f),
    repoPull: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-pull', 0xeb40),
    repoPush: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-push', 0xeb41),
    report: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('report', 0xeb42),
    requestChanges: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('request-changes', 0xeb43),
    rocket: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('rocket', 0xeb44),
    rootFolderOpened: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('root-folder-opened', 0xeb45),
    rootFolder: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('root-folder', 0xeb46),
    rss: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('rss', 0xeb47),
    ruby: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('ruby', 0xeb48),
    saveAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('save-all', 0xeb49),
    saveAs: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('save-as', 0xeb4a),
    save: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('save', 0xeb4b),
    screenFull: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('screen-full', 0xeb4c),
    screenNormal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('screen-normal', 0xeb4d),
    searchStop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('search-stop', 0xeb4e),
    server: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('server', 0xeb50),
    settingsGear: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('settings-gear', 0xeb51),
    settings: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('settings', 0xeb52),
    shield: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('shield', 0xeb53),
    smiley: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('smiley', 0xeb54),
    sortPrecedence: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sort-precedence', 0xeb55),
    splitHorizontal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('split-horizontal', 0xeb56),
    splitVertical: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('split-vertical', 0xeb57),
    squirrel: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('squirrel', 0xeb58),
    starFull: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star-full', 0xeb59),
    starHalf: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star-half', 0xeb5a),
    symbolClass: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-class', 0xeb5b),
    symbolColor: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-color', 0xeb5c),
    symbolConstant: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-constant', 0xeb5d),
    symbolEnumMember: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-enum-member', 0xeb5e),
    symbolField: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-field', 0xeb5f),
    symbolFile: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-file', 0xeb60),
    symbolInterface: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-interface', 0xeb61),
    symbolKeyword: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-keyword', 0xeb62),
    symbolMisc: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-misc', 0xeb63),
    symbolOperator: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-operator', 0xeb64),
    symbolProperty: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-property', 0xeb65),
    wrench: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('wrench', 0xeb65),
    wrenchSubaction: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('wrench-subaction', 0xeb65),
    symbolSnippet: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-snippet', 0xeb66),
    tasklist: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tasklist', 0xeb67),
    telescope: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('telescope', 0xeb68),
    textSize: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('text-size', 0xeb69),
    threeBars: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('three-bars', 0xeb6a),
    thumbsdown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsdown', 0xeb6b),
    thumbsup: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsup', 0xeb6c),
    tools: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tools', 0xeb6d),
    triangleDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('triangle-down', 0xeb6e),
    triangleLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('triangle-left', 0xeb6f),
    triangleRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('triangle-right', 0xeb70),
    triangleUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('triangle-up', 0xeb71),
    twitter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('twitter', 0xeb72),
    unfold: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('unfold', 0xeb73),
    unlock: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('unlock', 0xeb74),
    unmute: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('unmute', 0xeb75),
    unverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('unverified', 0xeb76),
    verified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('verified', 0xeb77),
    versions: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('versions', 0xeb78),
    vmActive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vm-active', 0xeb79),
    vmOutline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vm-outline', 0xeb7a),
    vmRunning: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vm-running', 0xeb7b),
    watch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('watch', 0xeb7c),
    whitespace: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('whitespace', 0xeb7d),
    wholeWord: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('whole-word', 0xeb7e),
    window: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('window', 0xeb7f),
    wordWrap: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('word-wrap', 0xeb80),
    zoomIn: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('zoom-in', 0xeb81),
    zoomOut: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('zoom-out', 0xeb82),
    listFilter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-filter', 0xeb83),
    listFlat: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-flat', 0xeb84),
    listSelection: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-selection', 0xeb85),
    selection: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('selection', 0xeb85),
    listTree: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-tree', 0xeb86),
    debugBreakpointFunctionUnverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-function-unverified', 0xeb87),
    debugBreakpointFunction: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-function', 0xeb88),
    debugBreakpointFunctionDisabled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-function-disabled', 0xeb88),
    debugStackframeActive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-stackframe-active', 0xeb89),
    circleSmallFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-small-filled', 0xeb8a),
    debugStackframeDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-stackframe-dot', 0xeb8a),
    terminalDecorationMark: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-decoration-mark', 0xeb8a),
    debugStackframe: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-stackframe', 0xeb8b),
    debugStackframeFocused: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-stackframe-focused', 0xeb8b),
    debugBreakpointUnsupported: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-unsupported', 0xeb8c),
    symbolString: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-string', 0xeb8d),
    debugReverseContinue: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-reverse-continue', 0xeb8e),
    debugStepBack: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-step-back', 0xeb8f),
    debugRestartFrame: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-restart-frame', 0xeb90),
    debugAlt: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-alt', 0xeb91),
    callIncoming: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('call-incoming', 0xeb92),
    callOutgoing: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('call-outgoing', 0xeb93),
    menu: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('menu', 0xeb94),
    expandAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('expand-all', 0xeb95),
    feedback: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('feedback', 0xeb96),
    gitPullRequestReviewer: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-reviewer', 0xeb96),
    groupByRefType: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('group-by-ref-type', 0xeb97),
    ungroupByRefType: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('ungroup-by-ref-type', 0xeb98),
    account: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('account', 0xeb99),
    gitPullRequestAssignee: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-assignee', 0xeb99),
    bellDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bell-dot', 0xeb9a),
    debugConsole: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-console', 0xeb9b),
    library: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('library', 0xeb9c),
    output: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('output', 0xeb9d),
    runAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-all', 0xeb9e),
    syncIgnored: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sync-ignored', 0xeb9f),
    pinned: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pinned', 0xeba0),
    githubInverted: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('github-inverted', 0xeba1),
    serverProcess: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('server-process', 0xeba2),
    serverEnvironment: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('server-environment', 0xeba3),
    pass: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pass', 0xeba4),
    issueClosed: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('issue-closed', 0xeba4),
    stopCircle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('stop-circle', 0xeba5),
    playCircle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('play-circle', 0xeba6),
    record: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('record', 0xeba7),
    debugAltSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-alt-small', 0xeba8),
    vmConnect: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vm-connect', 0xeba9),
    cloud: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('cloud', 0xebaa),
    merge: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('merge', 0xebab),
    export: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('export', 0xebac),
    graphLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('graph-left', 0xebad),
    magnet: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('magnet', 0xebae),
    notebook: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('notebook', 0xebaf),
    redo: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('redo', 0xebb0),
    checkAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('check-all', 0xebb1),
    pinnedDirty: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pinned-dirty', 0xebb2),
    passFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pass-filled', 0xebb3),
    circleLargeFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-large-filled', 0xebb4),
    circleLarge: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-large', 0xebb5),
    circleLargeOutline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-large-outline', 0xebb5),
    combine: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('combine', 0xebb6),
    gather: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gather', 0xebb6),
    table: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('table', 0xebb7),
    variableGroup: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('variable-group', 0xebb8),
    typeHierarchy: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('type-hierarchy', 0xebb9),
    typeHierarchySub: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('type-hierarchy-sub', 0xebba),
    typeHierarchySuper: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('type-hierarchy-super', 0xebbb),
    gitPullRequestCreate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-create', 0xebbc),
    runAbove: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-above', 0xebbd),
    runBelow: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-below', 0xebbe),
    notebookTemplate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('notebook-template', 0xebbf),
    debugRerun: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-rerun', 0xebc0),
    workspaceTrusted: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('workspace-trusted', 0xebc1),
    workspaceUntrusted: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('workspace-untrusted', 0xebc2),
    workspaceUnknown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('workspace-unknown', 0xebc3),
    terminalCmd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-cmd', 0xebc4),
    terminalDebian: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-debian', 0xebc5),
    terminalLinux: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-linux', 0xebc6),
    terminalPowershell: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-powershell', 0xebc7),
    terminalTmux: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-tmux', 0xebc8),
    terminalUbuntu: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-ubuntu', 0xebc9),
    terminalBash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-bash', 0xebca),
    arrowSwap: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-swap', 0xebcb),
    copy: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('copy', 0xebcc),
    personAdd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('person-add', 0xebcd),
    filterFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('filter-filled', 0xebce),
    wand: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('wand', 0xebcf),
    debugLineByLine: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-line-by-line', 0xebd0),
    inspect: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('inspect', 0xebd1),
    layers: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layers', 0xebd2),
    layersDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layers-dot', 0xebd3),
    layersActive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layers-active', 0xebd4),
    compass: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('compass', 0xebd5),
    compassDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('compass-dot', 0xebd6),
    compassActive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('compass-active', 0xebd7),
    azure: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('azure', 0xebd8),
    issueDraft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('issue-draft', 0xebd9),
    gitPullRequestClosed: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-closed', 0xebda),
    gitPullRequestDraft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-draft', 0xebdb),
    debugAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-all', 0xebdc),
    debugCoverage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-coverage', 0xebdd),
    runErrors: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-errors', 0xebde),
    folderLibrary: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('folder-library', 0xebdf),
    debugContinueSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-continue-small', 0xebe0),
    beakerStop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('beaker-stop', 0xebe1),
    graphLine: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('graph-line', 0xebe2),
    graphScatter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('graph-scatter', 0xebe3),
    pieChart: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pie-chart', 0xebe4),
    bracket: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bracket', 0xeb0f),
    bracketDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bracket-dot', 0xebe5),
    bracketError: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bracket-error', 0xebe6),
    lockSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lock-small', 0xebe7),
    azureDevops: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('azure-devops', 0xebe8),
    verifiedFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('verified-filled', 0xebe9),
    newline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('newline', 0xebea),
    layout: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout', 0xebeb),
    layoutActivitybarLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-activitybar-left', 0xebec),
    layoutActivitybarRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-activitybar-right', 0xebed),
    layoutPanelLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel-left', 0xebee),
    layoutPanelCenter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel-center', 0xebef),
    layoutPanelJustify: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel-justify', 0xebf0),
    layoutPanelRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel-right', 0xebf1),
    layoutPanel: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel', 0xebf2),
    layoutSidebarLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-sidebar-left', 0xebf3),
    layoutSidebarRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-sidebar-right', 0xebf4),
    layoutStatusbar: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-statusbar', 0xebf5),
    layoutMenubar: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-menubar', 0xebf6),
    layoutCentered: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-centered', 0xebf7),
    target: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('target', 0xebf8),
    indent: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('indent', 0xebf9),
    recordSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('record-small', 0xebfa),
    errorSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('error-small', 0xebfb),
    terminalDecorationError: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-decoration-error', 0xebfb),
    arrowCircleDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-circle-down', 0xebfc),
    arrowCircleLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-circle-left', 0xebfd),
    arrowCircleRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-circle-right', 0xebfe),
    arrowCircleUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-circle-up', 0xebff),
    layoutSidebarRightOff: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-sidebar-right-off', 0xec00),
    layoutPanelOff: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel-off', 0xec01),
    layoutSidebarLeftOff: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-sidebar-left-off', 0xec02),
    blank: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('blank', 0xec03),
    heartFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('heart-filled', 0xec04),
    map: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map', 0xec05),
    mapHorizontal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map-horizontal', 0xec05),
    foldHorizontal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-horizontal', 0xec05),
    mapFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map-filled', 0xec06),
    mapHorizontalFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map-horizontal-filled', 0xec06),
    foldHorizontalFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-horizontal-filled', 0xec06),
    circleSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-small', 0xec07),
    bellSlash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bell-slash', 0xec08),
    bellSlashDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bell-slash-dot', 0xec09),
    commentUnresolved: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('comment-unresolved', 0xec0a),
    gitPullRequestGoToChanges: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-go-to-changes', 0xec0b),
    gitPullRequestNewChanges: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-new-changes', 0xec0c),
    searchFuzzy: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('search-fuzzy', 0xec0d),
    commentDraft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('comment-draft', 0xec0e),
    send: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('send', 0xec0f),
    sparkle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sparkle', 0xec10),
    insert: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('insert', 0xec11),
    mic: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mic', 0xec12),
    thumbsdownFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsdown-filled', 0xec13),
    thumbsupFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsup-filled', 0xec14),
    coffee: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('coffee', 0xec15),
    snake: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('snake', 0xec16),
    game: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('game', 0xec17),
    vr: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vr', 0xec18),
    chip: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chip', 0xec19),
    piano: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('piano', 0xec1a),
    music: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('music', 0xec1b),
    micFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mic-filled', 0xec1c),
    repoFetch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-fetch', 0xec1d),
    copilot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('copilot', 0xec1e),
    lightbulbSparkle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lightbulb-sparkle', 0xec1f),
    robot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('robot', 0xec20),
    sparkleFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sparkle-filled', 0xec21),
    diffSingle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-single', 0xec22),
    diffMultiple: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-multiple', 0xec23),
    surroundWith: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('surround-with', 0xec24),
    share: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('share', 0xec25),
    gitStash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-stash', 0xec26),
    gitStashApply: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-stash-apply', 0xec27),
    gitStashPop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-stash-pop', 0xec28),
    vscode: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vscode', 0xec29),
    vscodeInsiders: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vscode-insiders', 0xec2a),
    codeOss: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('code-oss', 0xec2b),
    runCoverage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-coverage', 0xec2c),
    runAllCoverage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-all-coverage', 0xec2d),
    coverage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('coverage', 0xec2e),
    githubProject: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('github-project', 0xec2f),
    mapVertical: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map-vertical', 0xec30),
    foldVertical: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-vertical', 0xec30),
    mapVerticalFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map-vertical-filled', 0xec31),
    foldVerticalFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-vertical-filled', 0xec31),
    goToSearch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('go-to-search', 0xec32),
    percentage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('percentage', 0xec33),
    sortPercentage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sort-percentage', 0xec33),
    attach: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('attach', 0xec34),
};


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCodiconFontCharacters: () => (/* binding */ getCodiconFontCharacters),
/* harmony export */   register: () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/monaco-editor/esm/vs/base/common/types.js");

const _codiconFontCharacters = Object.create(null);
function register(id, fontCharacter) {
    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isString)(fontCharacter)) {
        const val = _codiconFontCharacters[fontCharacter];
        if (val === undefined) {
            throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);
        }
        fontCharacter = val;
    }
    _codiconFontCharacters[id] = fontCharacter;
    return { id };
}
/**
 * Only to be used by the iconRegistry.
 */
function getCodiconFontCharacters() {
    return _codiconFontCharacters;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/color.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/color.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   HSLA: () => (/* binding */ HSLA),
/* harmony export */   HSVA: () => (/* binding */ HSVA),
/* harmony export */   RGBA: () => (/* binding */ RGBA)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function roundFloat(number, decimalPoints) {
    const decimal = Math.pow(10, decimalPoints);
    return Math.round(number * decimal) / decimal;
}
class RGBA {
    constructor(r, g, b, a = 1) {
        this._rgbaBrand = undefined;
        this.r = Math.min(255, Math.max(0, r)) | 0;
        this.g = Math.min(255, Math.max(0, g)) | 0;
        this.b = Math.min(255, Math.max(0, b)) | 0;
        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
        return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
    }
}
class HSLA {
    constructor(h, s, l, a) {
        this._hslaBrand = undefined;
        this.h = Math.max(Math.min(360, h), 0) | 0;
        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
        this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
        return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;
    }
    /**
     * Converts an RGB color value to HSL. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes r, g, and b are contained in the set [0, 255] and
     * returns h in the set [0, 360], s, and l in the set [0, 1].
     */
    static fromRGBA(rgba) {
        const r = rgba.r / 255;
        const g = rgba.g / 255;
        const b = rgba.b / 255;
        const a = rgba.a;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h = 0;
        let s = 0;
        const l = (min + max) / 2;
        const chroma = max - min;
        if (chroma > 0) {
            s = Math.min((l <= 0.5 ? chroma / (2 * l) : chroma / (2 - (2 * l))), 1);
            switch (max) {
                case r:
                    h = (g - b) / chroma + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / chroma + 2;
                    break;
                case b:
                    h = (r - g) / chroma + 4;
                    break;
            }
            h *= 60;
            h = Math.round(h);
        }
        return new HSLA(h, s, l, a);
    }
    static _hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
    }
    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     */
    static toRGBA(hsla) {
        const h = hsla.h / 360;
        const { s, l, a } = hsla;
        let r, g, b;
        if (s === 0) {
            r = g = b = l; // achromatic
        }
        else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = HSLA._hue2rgb(p, q, h + 1 / 3);
            g = HSLA._hue2rgb(p, q, h);
            b = HSLA._hue2rgb(p, q, h - 1 / 3);
        }
        return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);
    }
}
class HSVA {
    constructor(h, s, v, a) {
        this._hsvaBrand = undefined;
        this.h = Math.max(Math.min(360, h), 0) | 0;
        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
        this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
        return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;
    }
    // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
    static fromRGBA(rgba) {
        const r = rgba.r / 255;
        const g = rgba.g / 255;
        const b = rgba.b / 255;
        const cmax = Math.max(r, g, b);
        const cmin = Math.min(r, g, b);
        const delta = cmax - cmin;
        const s = cmax === 0 ? 0 : (delta / cmax);
        let m;
        if (delta === 0) {
            m = 0;
        }
        else if (cmax === r) {
            m = ((((g - b) / delta) % 6) + 6) % 6;
        }
        else if (cmax === g) {
            m = ((b - r) / delta) + 2;
        }
        else {
            m = ((r - g) / delta) + 4;
        }
        return new HSVA(Math.round(m * 60), s, cmax, rgba.a);
    }
    // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
    static toRGBA(hsva) {
        const { h, s, v, a } = hsva;
        const c = v * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = v - c;
        let [r, g, b] = [0, 0, 0];
        if (h < 60) {
            r = c;
            g = x;
        }
        else if (h < 120) {
            r = x;
            g = c;
        }
        else if (h < 180) {
            g = c;
            b = x;
        }
        else if (h < 240) {
            g = x;
            b = c;
        }
        else if (h < 300) {
            r = x;
            b = c;
        }
        else if (h <= 360) {
            r = c;
            b = x;
        }
        r = Math.round((r + m) * 255);
        g = Math.round((g + m) * 255);
        b = Math.round((b + m) * 255);
        return new RGBA(r, g, b, a);
    }
}
class Color {
    static fromHex(hex) {
        return Color.Format.CSS.parseHex(hex) || Color.red;
    }
    static equals(a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        return a.equals(b);
    }
    get hsla() {
        if (this._hsla) {
            return this._hsla;
        }
        else {
            return HSLA.fromRGBA(this.rgba);
        }
    }
    get hsva() {
        if (this._hsva) {
            return this._hsva;
        }
        return HSVA.fromRGBA(this.rgba);
    }
    constructor(arg) {
        if (!arg) {
            throw new Error('Color needs a value');
        }
        else if (arg instanceof RGBA) {
            this.rgba = arg;
        }
        else if (arg instanceof HSLA) {
            this._hsla = arg;
            this.rgba = HSLA.toRGBA(arg);
        }
        else if (arg instanceof HSVA) {
            this._hsva = arg;
            this.rgba = HSVA.toRGBA(arg);
        }
        else {
            throw new Error('Invalid color ctor argument');
        }
    }
    equals(other) {
        return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
    }
    /**
     * http://www.w3.org/TR/WCAG20/#relativeluminancedef
     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
     */
    getRelativeLuminance() {
        const R = Color._relativeLuminanceForComponent(this.rgba.r);
        const G = Color._relativeLuminanceForComponent(this.rgba.g);
        const B = Color._relativeLuminanceForComponent(this.rgba.b);
        const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
        return roundFloat(luminance, 4);
    }
    static _relativeLuminanceForComponent(color) {
        const c = color / 255;
        return (c <= 0.03928) ? c / 12.92 : Math.pow(((c + 0.055) / 1.055), 2.4);
    }
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if lighter color otherwise 'false'
     */
    isLighter() {
        const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;
        return yiq >= 128;
    }
    isLighterThan(another) {
        const lum1 = this.getRelativeLuminance();
        const lum2 = another.getRelativeLuminance();
        return lum1 > lum2;
    }
    isDarkerThan(another) {
        const lum1 = this.getRelativeLuminance();
        const lum2 = another.getRelativeLuminance();
        return lum1 < lum2;
    }
    lighten(factor) {
        return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));
    }
    darken(factor) {
        return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));
    }
    transparent(factor) {
        const { r, g, b, a } = this.rgba;
        return new Color(new RGBA(r, g, b, a * factor));
    }
    isTransparent() {
        return this.rgba.a === 0;
    }
    isOpaque() {
        return this.rgba.a === 1;
    }
    opposite() {
        return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
    }
    makeOpaque(opaqueBackground) {
        if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
            // only allow to blend onto a non-opaque color onto a opaque color
            return this;
        }
        const { r, g, b, a } = this.rgba;
        // https://stackoverflow.com/questions/12228548/finding-equivalent-color-with-opacity
        return new Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b), 1));
    }
    toString() {
        if (!this._toString) {
            this._toString = Color.Format.CSS.format(this);
        }
        return this._toString;
    }
    static getLighterColor(of, relative, factor) {
        if (of.isLighterThan(relative)) {
            return of;
        }
        factor = factor ? factor : 0.5;
        const lum1 = of.getRelativeLuminance();
        const lum2 = relative.getRelativeLuminance();
        factor = factor * (lum2 - lum1) / lum2;
        return of.lighten(factor);
    }
    static getDarkerColor(of, relative, factor) {
        if (of.isDarkerThan(relative)) {
            return of;
        }
        factor = factor ? factor : 0.5;
        const lum1 = of.getRelativeLuminance();
        const lum2 = relative.getRelativeLuminance();
        factor = factor * (lum1 - lum2) / lum1;
        return of.darken(factor);
    }
    static { this.white = new Color(new RGBA(255, 255, 255, 1)); }
    static { this.black = new Color(new RGBA(0, 0, 0, 1)); }
    static { this.red = new Color(new RGBA(255, 0, 0, 1)); }
    static { this.blue = new Color(new RGBA(0, 0, 255, 1)); }
    static { this.green = new Color(new RGBA(0, 255, 0, 1)); }
    static { this.cyan = new Color(new RGBA(0, 255, 255, 1)); }
    static { this.lightgrey = new Color(new RGBA(211, 211, 211, 1)); }
    static { this.transparent = new Color(new RGBA(0, 0, 0, 0)); }
}
(function (Color) {
    let Format;
    (function (Format) {
        let CSS;
        (function (CSS) {
            function formatRGB(color) {
                if (color.rgba.a === 1) {
                    return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;
                }
                return Color.Format.CSS.formatRGBA(color);
            }
            CSS.formatRGB = formatRGB;
            function formatRGBA(color) {
                return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+(color.rgba.a).toFixed(2)})`;
            }
            CSS.formatRGBA = formatRGBA;
            function formatHSL(color) {
                if (color.hsla.a === 1) {
                    return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;
                }
                return Color.Format.CSS.formatHSLA(color);
            }
            CSS.formatHSL = formatHSL;
            function formatHSLA(color) {
                return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;
            }
            CSS.formatHSLA = formatHSLA;
            function _toTwoDigitHex(n) {
                const r = n.toString(16);
                return r.length !== 2 ? '0' + r : r;
            }
            /**
             * Formats the color as #RRGGBB
             */
            function formatHex(color) {
                return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;
            }
            CSS.formatHex = formatHex;
            /**
             * Formats the color as #RRGGBBAA
             * If 'compact' is set, colors without transparancy will be printed as #RRGGBB
             */
            function formatHexA(color, compact = false) {
                if (compact && color.rgba.a === 1) {
                    return Color.Format.CSS.formatHex(color);
                }
                return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;
            }
            CSS.formatHexA = formatHexA;
            /**
             * The default format will use HEX if opaque and RGBA otherwise.
             */
            function format(color) {
                if (color.isOpaque()) {
                    return Color.Format.CSS.formatHex(color);
                }
                return Color.Format.CSS.formatRGBA(color);
            }
            CSS.format = format;
            /**
             * Converts an Hex color value to a Color.
             * returns r, g, and b are contained in the set [0, 255]
             * @param hex string (#RGB, #RGBA, #RRGGBB or #RRGGBBAA).
             */
            function parseHex(hex) {
                const length = hex.length;
                if (length === 0) {
                    // Invalid color
                    return null;
                }
                if (hex.charCodeAt(0) !== 35 /* CharCode.Hash */) {
                    // Does not begin with a #
                    return null;
                }
                if (length === 7) {
                    // #RRGGBB format
                    const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
                    const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
                    const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
                    return new Color(new RGBA(r, g, b, 1));
                }
                if (length === 9) {
                    // #RRGGBBAA format
                    const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
                    const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
                    const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
                    const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
                    return new Color(new RGBA(r, g, b, a / 255));
                }
                if (length === 4) {
                    // #RGB format
                    const r = _parseHexDigit(hex.charCodeAt(1));
                    const g = _parseHexDigit(hex.charCodeAt(2));
                    const b = _parseHexDigit(hex.charCodeAt(3));
                    return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));
                }
                if (length === 5) {
                    // #RGBA format
                    const r = _parseHexDigit(hex.charCodeAt(1));
                    const g = _parseHexDigit(hex.charCodeAt(2));
                    const b = _parseHexDigit(hex.charCodeAt(3));
                    const a = _parseHexDigit(hex.charCodeAt(4));
                    return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));
                }
                // Invalid color
                return null;
            }
            CSS.parseHex = parseHex;
            function _parseHexDigit(charCode) {
                switch (charCode) {
                    case 48 /* CharCode.Digit0 */: return 0;
                    case 49 /* CharCode.Digit1 */: return 1;
                    case 50 /* CharCode.Digit2 */: return 2;
                    case 51 /* CharCode.Digit3 */: return 3;
                    case 52 /* CharCode.Digit4 */: return 4;
                    case 53 /* CharCode.Digit5 */: return 5;
                    case 54 /* CharCode.Digit6 */: return 6;
                    case 55 /* CharCode.Digit7 */: return 7;
                    case 56 /* CharCode.Digit8 */: return 8;
                    case 57 /* CharCode.Digit9 */: return 9;
                    case 97 /* CharCode.a */: return 10;
                    case 65 /* CharCode.A */: return 10;
                    case 98 /* CharCode.b */: return 11;
                    case 66 /* CharCode.B */: return 11;
                    case 99 /* CharCode.c */: return 12;
                    case 67 /* CharCode.C */: return 12;
                    case 100 /* CharCode.d */: return 13;
                    case 68 /* CharCode.D */: return 13;
                    case 101 /* CharCode.e */: return 14;
                    case 69 /* CharCode.E */: return 14;
                    case 102 /* CharCode.f */: return 15;
                    case 70 /* CharCode.F */: return 15;
                }
                return 0;
            }
        })(CSS = Format.CSS || (Format.CSS = {}));
    })(Format = Color.Format || (Color.Format = {}));
})(Color || (Color = {}));


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js":
/*!********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LcsDiff: () => (/* binding */ LcsDiff),
/* harmony export */   StringDiffSequence: () => (/* binding */ StringDiffSequence),
/* harmony export */   stringDiff: () => (/* binding */ stringDiff)
/* harmony export */ });
/* harmony import */ var _diffChange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diffChange.js */ "./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js");
/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hash.js */ "./node_modules/monaco-editor/esm/vs/base/common/hash.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


class StringDiffSequence {
    constructor(source) {
        this.source = source;
    }
    getElements() {
        const source = this.source;
        const characters = new Int32Array(source.length);
        for (let i = 0, len = source.length; i < len; i++) {
            characters[i] = source.charCodeAt(i);
        }
        return characters;
    }
}
function stringDiff(original, modified, pretty) {
    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
}
//
// The code below has been ported from a C# implementation in VS
//
class Debug {
    static Assert(condition, message) {
        if (!condition) {
            throw new Error(message);
        }
    }
}
class MyArray {
    /**
     * Copies a range of elements from an Array starting at the specified source index and pastes
     * them to another Array starting at the specified destination index. The length and the indexes
     * are specified as 64-bit integers.
     * sourceArray:
     *		The Array that contains the data to copy.
     * sourceIndex:
     *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
     * destinationArray:
     *		The Array that receives the data.
     * destinationIndex:
     *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
     * length:
     *		A 64-bit integer that represents the number of elements to copy.
     */
    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
        }
    }
    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
        }
    }
}
/**
 * A utility class which helps to create the set of DiffChanges from
 * a difference operation. This class accepts original DiffElements and
 * modified DiffElements that are involved in a particular change. The
 * MarkNextChange() method can be called to mark the separation between
 * distinct changes. At the end, the Changes property can be called to retrieve
 * the constructed changes.
 */
class DiffChangeHelper {
    /**
     * Constructs a new DiffChangeHelper for the given DiffSequences.
     */
    constructor() {
        this.m_changes = [];
        this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;
        this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
    }
    /**
     * Marks the beginning of the next change in the set of differences.
     */
    MarkNextChange() {
        // Only add to the list if there is something to add
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Add the new change to our list
            this.m_changes.push(new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
        }
        // Reset for the next change
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
        this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;
        this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;
    }
    /**
     * Adds the original element at the given position to the elements
     * affected by the current change. The modified index gives context
     * to the change position with respect to the original sequence.
     * @param originalIndex The index of the original element to add.
     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
     */
    AddOriginalElement(originalIndex, modifiedIndex) {
        // The 'true' start index is the smallest of the ones we've seen
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_originalCount++;
    }
    /**
     * Adds the modified element at the given position to the elements
     * affected by the current change. The original index gives context
     * to the change position with respect to the modified sequence.
     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
     * @param modifiedIndex The index of the modified element to add.
     */
    AddModifiedElement(originalIndex, modifiedIndex) {
        // The 'true' start index is the smallest of the ones we've seen
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_modifiedCount++;
    }
    /**
     * Retrieves all of the changes marked by the class.
     */
    getChanges() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Finish up on whatever is left
            this.MarkNextChange();
        }
        return this.m_changes;
    }
    /**
     * Retrieves all of the changes marked by the class in the reverse order
     */
    getReverseChanges() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Finish up on whatever is left
            this.MarkNextChange();
        }
        this.m_changes.reverse();
        return this.m_changes;
    }
}
/**
 * An implementation of the difference algorithm described in
 * "An O(ND) Difference Algorithm and its variations" by Eugene W. Myers
 */
class LcsDiff {
    /**
     * Constructs the DiffFinder
     */
    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
        this.ContinueProcessingPredicate = continueProcessingPredicate;
        this._originalSequence = originalSequence;
        this._modifiedSequence = modifiedSequence;
        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);
        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);
        this._hasStrings = (originalHasStrings && modifiedHasStrings);
        this._originalStringElements = originalStringElements;
        this._originalElementsOrHash = originalElementsOrHash;
        this._modifiedStringElements = modifiedStringElements;
        this._modifiedElementsOrHash = modifiedElementsOrHash;
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
    }
    static _isStringArray(arr) {
        return (arr.length > 0 && typeof arr[0] === 'string');
    }
    static _getElements(sequence) {
        const elements = sequence.getElements();
        if (LcsDiff._isStringArray(elements)) {
            const hashes = new Int32Array(elements.length);
            for (let i = 0, len = elements.length; i < len; i++) {
                hashes[i] = (0,_hash_js__WEBPACK_IMPORTED_MODULE_1__.stringHash)(elements[i], 0);
            }
            return [elements, hashes, true];
        }
        if (elements instanceof Int32Array) {
            return [[], elements, false];
        }
        return [[], new Int32Array(elements), false];
    }
    ElementsAreEqual(originalIndex, newIndex) {
        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
            return false;
        }
        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);
    }
    ElementsAreStrictEqual(originalIndex, newIndex) {
        if (!this.ElementsAreEqual(originalIndex, newIndex)) {
            return false;
        }
        const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);
        const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
        return (originalElement === modifiedElement);
    }
    static _getStrictElement(sequence, index) {
        if (typeof sequence.getStrictElement === 'function') {
            return sequence.getStrictElement(index);
        }
        return null;
    }
    OriginalElementsAreEqual(index1, index2) {
        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
            return false;
        }
        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);
    }
    ModifiedElementsAreEqual(index1, index2) {
        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
            return false;
        }
        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);
    }
    ComputeDiff(pretty) {
        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
    }
    /**
     * Computes the differences between the original and modified input
     * sequences on the bounded range.
     * @returns An array of the differences between the two input sequences.
     */
    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
        const quitEarlyArr = [false];
        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
        if (pretty) {
            // We have to clean up the computed diff to be more intuitive
            // but it turns out this cannot be done correctly until the entire set
            // of diffs have been computed
            changes = this.PrettifyChanges(changes);
        }
        return {
            quitEarly: quitEarlyArr[0],
            changes: changes
        };
    }
    /**
     * Private helper method which computes the differences on the bounded range
     * recursively.
     * @returns An array of the differences between the two input sequences.
     */
    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
        quitEarlyArr[0] = false;
        // Find the start of the differences
        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
            originalStart++;
            modifiedStart++;
        }
        // Find the end of the differences
        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
            originalEnd--;
            modifiedEnd--;
        }
        // In the special case where we either have all insertions or all deletions or the sequences are identical
        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
            let changes;
            if (modifiedStart <= modifiedEnd) {
                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                // All insertions
                changes = [
                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
                ];
            }
            else if (originalStart <= originalEnd) {
                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                // All deletions
                changes = [
                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
                ];
            }
            else {
                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                // Identical sequences - No differences
                changes = [];
            }
            return changes;
        }
        // This problem can be solved using the Divide-And-Conquer technique.
        const midOriginalArr = [0];
        const midModifiedArr = [0];
        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
        const midOriginal = midOriginalArr[0];
        const midModified = midModifiedArr[0];
        if (result !== null) {
            // Result is not-null when there was enough memory to compute the changes while
            // searching for the recursion point
            return result;
        }
        else if (!quitEarlyArr[0]) {
            // We can break the problem down recursively by finding the changes in the
            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)
            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)
            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point
            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
            let rightChanges = [];
            if (!quitEarlyArr[0]) {
                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
            }
            else {
                // We didn't have time to finish the first half, so we don't have time to compute this half.
                // Consider the entire rest of the sequence different.
                rightChanges = [
                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
                ];
            }
            return this.ConcatenateChanges(leftChanges, rightChanges);
        }
        // If we hit here, we quit early, and so can't return anything meaningful
        return [
            new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
        ];
    }
    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
        let forwardChanges = null;
        let reverseChanges = null;
        // First, walk backward through the forward diagonals history
        let changeHelper = new DiffChangeHelper();
        let diagonalMin = diagonalForwardStart;
        let diagonalMax = diagonalForwardEnd;
        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;
        let lastOriginalIndex = -1073741824 /* Constants.MIN_SAFE_SMALL_INTEGER */;
        let historyIndex = this.m_forwardHistory.length - 1;
        do {
            // Get the diagonal index from the relative diagonal number
            const diagonal = diagonalRelative + diagonalForwardBase;
            // Figure out where we came from
            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                // Vertical line (the element is an insert)
                originalIndex = forwardPoints[diagonal + 1];
                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                if (originalIndex < lastOriginalIndex) {
                    changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex;
                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration
            }
            else {
                // Horizontal line (the element is a deletion)
                originalIndex = forwardPoints[diagonal - 1] + 1;
                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                if (originalIndex < lastOriginalIndex) {
                    changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex - 1;
                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration
            }
            if (historyIndex >= 0) {
                forwardPoints = this.m_forwardHistory[historyIndex];
                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot
                diagonalMin = 1;
                diagonalMax = forwardPoints.length - 1;
            }
        } while (--historyIndex >= -1);
        // Ironically, we get the forward changes as the reverse of the
        // order we added them since we technically added them backwards
        forwardChanges = changeHelper.getReverseChanges();
        if (quitEarlyArr[0]) {
            // TODO: Calculate a partial from the reverse diagonals.
            //       For now, just assume everything after the midOriginal/midModified point is a diff
            let originalStartPoint = midOriginalArr[0] + 1;
            let modifiedStartPoint = midModifiedArr[0] + 1;
            if (forwardChanges !== null && forwardChanges.length > 0) {
                const lastForwardChange = forwardChanges[forwardChanges.length - 1];
                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
            }
            reverseChanges = [
                new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
            ];
        }
        else {
            // Now walk backward through the reverse diagonals history
            changeHelper = new DiffChangeHelper();
            diagonalMin = diagonalReverseStart;
            diagonalMax = diagonalReverseEnd;
            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;
            lastOriginalIndex = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;
            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
            do {
                // Get the diagonal index from the relative diagonal number
                const diagonal = diagonalRelative + diagonalReverseBase;
                // Figure out where we came from
                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                    // Horizontal line (the element is a deletion))
                    originalIndex = reversePoints[diagonal + 1] - 1;
                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                    if (originalIndex > lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex + 1;
                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration
                }
                else {
                    // Vertical line (the element is an insertion)
                    originalIndex = reversePoints[diagonal - 1];
                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                    if (originalIndex > lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex;
                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration
                }
                if (historyIndex >= 0) {
                    reversePoints = this.m_reverseHistory[historyIndex];
                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot
                    diagonalMin = 1;
                    diagonalMax = reversePoints.length - 1;
                }
            } while (--historyIndex >= -1);
            // There are cases where the reverse history will find diffs that
            // are correct, but not intuitive, so we need shift them.
            reverseChanges = changeHelper.getChanges();
        }
        return this.ConcatenateChanges(forwardChanges, reverseChanges);
    }
    /**
     * Given the range to compute the diff on, this method finds the point:
     * (midOriginal, midModified)
     * that exists in the middle of the LCS of the two sequences and
     * is the point at which the LCS problem may be broken down recursively.
     * This method will try to keep the LCS trace in memory. If the LCS recursion
     * point is calculated and the full trace is available in memory, then this method
     * will return the change list.
     * @param originalStart The start bound of the original sequence range
     * @param originalEnd The end bound of the original sequence range
     * @param modifiedStart The start bound of the modified sequence range
     * @param modifiedEnd The end bound of the modified sequence range
     * @param midOriginal The middle point of the original sequence range
     * @param midModified The middle point of the modified sequence range
     * @returns The diff changes, if available, otherwise null
     */
    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
        let originalIndex = 0, modifiedIndex = 0;
        let diagonalForwardStart = 0, diagonalForwardEnd = 0;
        let diagonalReverseStart = 0, diagonalReverseEnd = 0;
        // To traverse the edit graph and produce the proper LCS, our actual
        // start position is just outside the given boundary
        originalStart--;
        modifiedStart--;
        // We set these up to make the compiler happy, but they will
        // be replaced before we return with the actual recursion point
        midOriginalArr[0] = 0;
        midModifiedArr[0] = 0;
        // Clear out the history
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
        // Each cell in the two arrays corresponds to a diagonal in the edit graph.
        // The integer value in the cell represents the originalIndex of the furthest
        // reaching point found so far that ends in that diagonal.
        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.
        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);
        const numDiagonals = maxDifferences + 1;
        const forwardPoints = new Int32Array(numDiagonals);
        const reversePoints = new Int32Array(numDiagonals);
        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)
        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)
        const diagonalForwardBase = (modifiedEnd - modifiedStart);
        const diagonalReverseBase = (originalEnd - originalStart);
        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
        //    diagonal number (relative to diagonalForwardBase)
        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
        //    diagonal number (relative to diagonalReverseBase)
        const diagonalForwardOffset = (originalStart - modifiedStart);
        const diagonalReverseOffset = (originalEnd - modifiedEnd);
        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers
        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.
        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap
        const delta = diagonalReverseBase - diagonalForwardBase;
        const deltaIsEven = (delta % 2 === 0);
        // Here we set up the start and end points as the furthest points found so far
        // in both the forward and reverse directions, respectively
        forwardPoints[diagonalForwardBase] = originalStart;
        reversePoints[diagonalReverseBase] = originalEnd;
        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.
        quitEarlyArr[0] = false;
        // A couple of points:
        // --With this method, we iterate on the number of differences between the two sequences.
        //   The more differences there actually are, the longer this will take.
        // --Also, as the number of differences increases, we have to search on diagonals further
        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).
        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences
        //   is even and odd diagonals only when numDifferences is odd.
        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {
            let furthestOriginalIndex = 0;
            let furthestModifiedIndex = 0;
            // Run the algorithm in the forward direction
            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
                // STEP 1: We extend the furthest reaching point in the present diagonal
                // by looking at the diagonals above and below and picking the one whose point
                // is further away from the start point (originalStart, modifiedStart)
                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                    originalIndex = forwardPoints[diagonal + 1];
                }
                else {
                    originalIndex = forwardPoints[diagonal - 1] + 1;
                }
                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
                // Save the current originalIndex so we can test for false overlap in step 3
                const tempOriginalIndex = originalIndex;
                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                // so long as the elements are equal.
                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
                    originalIndex++;
                    modifiedIndex++;
                }
                forwardPoints[diagonal] = originalIndex;
                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
                    furthestOriginalIndex = originalIndex;
                    furthestModifiedIndex = modifiedIndex;
                }
                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)
                // and diagonal is in the range of reverse diagonals computed for numDifferences-1
                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)
                // then check for overlap.
                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {
                    if (originalIndex >= reversePoints[diagonal]) {
                        midOriginalArr[0] = originalIndex;
                        midModifiedArr[0] = modifiedIndex;
                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {
                            // BINGO! We overlapped, and we have the full trace in memory!
                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                        }
                        else {
                            // Either false overlap, or we didn't have enough memory for the full trace
                            // Just return the recursion point
                            return null;
                        }
                    }
                }
            }
            // Check to see if we should be quitting early, before moving on to the next iteration.
            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
                // We can't finish, so skip ahead to generating a result from what we have.
                quitEarlyArr[0] = true;
                // Use the furthest distance we got in the forward direction.
                midOriginalArr[0] = furthestOriginalIndex;
                midModifiedArr[0] = furthestModifiedIndex;
                if (matchLengthOfLongest > 0 && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {
                    // Enough of the history is in memory to walk it backwards
                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                }
                else {
                    // We didn't actually remember enough of the history.
                    //Since we are quitting the diff early, we need to shift back the originalStart and modified start
                    //back into the boundary limits since we decremented their value above beyond the boundary limit.
                    originalStart++;
                    modifiedStart++;
                    return [
                        new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
                    ];
                }
            }
            // Run the algorithm in the reverse direction
            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
                // STEP 1: We extend the furthest reaching point in the present diagonal
                // by looking at the diagonals above and below and picking the one whose point
                // is further away from the start point (originalEnd, modifiedEnd)
                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                    originalIndex = reversePoints[diagonal + 1] - 1;
                }
                else {
                    originalIndex = reversePoints[diagonal - 1];
                }
                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
                // Save the current originalIndex so we can test for false overlap
                const tempOriginalIndex = originalIndex;
                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                // as long as the elements are equal.
                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
                    originalIndex--;
                    modifiedIndex--;
                }
                reversePoints[diagonal] = originalIndex;
                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)
                // and diagonal is in the range of forward diagonals computed for numDifferences
                // then check for overlap.
                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
                    if (originalIndex <= forwardPoints[diagonal]) {
                        midOriginalArr[0] = originalIndex;
                        midModifiedArr[0] = modifiedIndex;
                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {
                            // BINGO! We overlapped, and we have the full trace in memory!
                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                        }
                        else {
                            // Either false overlap, or we didn't have enough memory for the full trace
                            // Just return the recursion point
                            return null;
                        }
                    }
                }
            }
            // Save current vectors to history before the next iteration
            if (numDifferences <= 1447 /* LocalConstants.MaxDifferencesHistory */) {
                // We are allocating space for one extra int, which we fill with
                // the index of the diagonal base index
                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
                this.m_forwardHistory.push(temp);
                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
                this.m_reverseHistory.push(temp);
            }
        }
        // If we got here, then we have the full trace in history. We just have to convert it to a change list
        // NOTE: This part is a bit messy
        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
    }
    /**
     * Shifts the given changes to provide a more intuitive diff.
     * While the first element in a diff matches the first element after the diff,
     * we shift the diff down.
     *
     * @param changes The list of changes to shift
     * @returns The shifted changes
     */
    PrettifyChanges(changes) {
        // Shift all the changes down first
        for (let i = 0; i < changes.length; i++) {
            const change = changes[i];
            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            while (change.originalStart + change.originalLength < originalStop
                && change.modifiedStart + change.modifiedLength < modifiedStop
                && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))
                && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
                const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
                const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
                if (endStrictEqual && !startStrictEqual) {
                    // moving the change down would create an equal change, but the elements are not strict equal
                    break;
                }
                change.originalStart++;
                change.modifiedStart++;
            }
            const mergedChangeArr = [null];
            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
                changes[i] = mergedChangeArr[0];
                changes.splice(i + 1, 1);
                i--;
                continue;
            }
        }
        // Shift changes back up until we hit empty or whitespace-only lines
        for (let i = changes.length - 1; i >= 0; i--) {
            const change = changes[i];
            let originalStop = 0;
            let modifiedStop = 0;
            if (i > 0) {
                const prevChange = changes[i - 1];
                originalStop = prevChange.originalStart + prevChange.originalLength;
                modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
            }
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            let bestDelta = 0;
            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
            for (let delta = 1;; delta++) {
                const originalStart = change.originalStart - delta;
                const modifiedStart = change.modifiedStart - delta;
                if (originalStart < originalStop || modifiedStart < modifiedStop) {
                    break;
                }
                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
                    break;
                }
                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
                    break;
                }
                const touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);
                const score = ((touchingPreviousChange ? 5 : 0)
                    + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength));
                if (score > bestScore) {
                    bestScore = score;
                    bestDelta = delta;
                }
            }
            change.originalStart -= bestDelta;
            change.modifiedStart -= bestDelta;
            const mergedChangeArr = [null];
            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
                changes[i - 1] = mergedChangeArr[0];
                changes.splice(i, 1);
                i++;
                continue;
            }
        }
        // There could be multiple longest common substrings.
        // Give preference to the ones containing longer lines
        if (this._hasStrings) {
            for (let i = 1, len = changes.length; i < len; i++) {
                const aChange = changes[i - 1];
                const bChange = changes[i];
                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
                const aOriginalStart = aChange.originalStart;
                const bOriginalEnd = bChange.originalStart + bChange.originalLength;
                const abOriginalLength = bOriginalEnd - aOriginalStart;
                const aModifiedStart = aChange.modifiedStart;
                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
                const abModifiedLength = bModifiedEnd - aModifiedStart;
                // Avoid wasting a lot of time with these searches
                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
                    if (t) {
                        const [originalMatchStart, modifiedMatchStart] = t;
                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                            // switch to another sequence that has a better score
                            aChange.originalLength = originalMatchStart - aChange.originalStart;
                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                            bChange.originalStart = originalMatchStart + matchedLength;
                            bChange.modifiedStart = modifiedMatchStart + matchedLength;
                            bChange.originalLength = bOriginalEnd - bChange.originalStart;
                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
                        }
                    }
                }
            }
        }
        return changes;
    }
    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
        if (originalLength < desiredLength || modifiedLength < desiredLength) {
            return null;
        }
        const originalMax = originalStart + originalLength - desiredLength + 1;
        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
        let bestScore = 0;
        let bestOriginalStart = 0;
        let bestModifiedStart = 0;
        for (let i = originalStart; i < originalMax; i++) {
            for (let j = modifiedStart; j < modifiedMax; j++) {
                const score = this._contiguousSequenceScore(i, j, desiredLength);
                if (score > 0 && score > bestScore) {
                    bestScore = score;
                    bestOriginalStart = i;
                    bestModifiedStart = j;
                }
            }
        }
        if (bestScore > 0) {
            return [bestOriginalStart, bestModifiedStart];
        }
        return null;
    }
    _contiguousSequenceScore(originalStart, modifiedStart, length) {
        let score = 0;
        for (let l = 0; l < length; l++) {
            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
                return 0;
            }
            score += this._originalStringElements[originalStart + l].length;
        }
        return score;
    }
    _OriginalIsBoundary(index) {
        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
            return true;
        }
        return (this._hasStrings && /^\s*$/.test(this._originalStringElements[index]));
    }
    _OriginalRegionIsBoundary(originalStart, originalLength) {
        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
            return true;
        }
        if (originalLength > 0) {
            const originalEnd = originalStart + originalLength;
            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
                return true;
            }
        }
        return false;
    }
    _ModifiedIsBoundary(index) {
        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
            return true;
        }
        return (this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]));
    }
    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
            return true;
        }
        if (modifiedLength > 0) {
            const modifiedEnd = modifiedStart + modifiedLength;
            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
                return true;
            }
        }
        return false;
    }
    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);
        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);
        return (originalScore + modifiedScore);
    }
    /**
     * Concatenates the two input DiffChange lists and returns the resulting
     * list.
     * @param The left changes
     * @param The right changes
     * @returns The concatenated list
     */
    ConcatenateChanges(left, right) {
        const mergedChangeArr = [];
        if (left.length === 0 || right.length === 0) {
            return (right.length > 0) ? right : left;
        }
        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
            // Since we break the problem down recursively, it is possible that we
            // might recurse in the middle of a change thereby splitting it into
            // two changes. Here in the combining stage, we detect and fuse those
            // changes back together
            const result = new Array(left.length + right.length - 1);
            MyArray.Copy(left, 0, result, 0, left.length - 1);
            result[left.length - 1] = mergedChangeArr[0];
            MyArray.Copy(right, 1, result, left.length, right.length - 1);
            return result;
        }
        else {
            const result = new Array(left.length + right.length);
            MyArray.Copy(left, 0, result, 0, left.length);
            MyArray.Copy(right, 0, result, left.length, right.length);
            return result;
        }
    }
    /**
     * Returns true if the two changes overlap and can be merged into a single
     * change
     * @param left The left change
     * @param right The right change
     * @param mergedChange The merged change if the two overlap, null otherwise
     * @returns True if the two changes overlap
     */
    ChangesOverlap(left, right, mergedChangeArr) {
        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');
        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');
        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
            const originalStart = left.originalStart;
            let originalLength = left.originalLength;
            const modifiedStart = left.modifiedStart;
            let modifiedLength = left.modifiedLength;
            if (left.originalStart + left.originalLength >= right.originalStart) {
                originalLength = right.originalStart + right.originalLength - left.originalStart;
            }
            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
            }
            mergedChangeArr[0] = new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
            return true;
        }
        else {
            mergedChangeArr[0] = null;
            return false;
        }
    }
    /**
     * Helper method used to clip a diagonal index to the range of valid
     * diagonals. This also decides whether or not the diagonal index,
     * if it exceeds the boundary, should be clipped to the boundary or clipped
     * one inside the boundary depending on the Even/Odd status of the boundary
     * and numDifferences.
     * @param diagonal The index of the diagonal to clip.
     * @param numDifferences The current number of differences being iterated upon.
     * @param diagonalBaseIndex The base reference diagonal.
     * @param numDiagonals The total number of diagonals.
     * @returns The clipped diagonal index.
     */
    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
        if (diagonal >= 0 && diagonal < numDiagonals) {
            // Nothing to clip, its in range
            return diagonal;
        }
        // diagonalsBelow: The number of diagonals below the reference diagonal
        // diagonalsAbove: The number of diagonals above the reference diagonal
        const diagonalsBelow = diagonalBaseIndex;
        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
        const diffEven = (numDifferences % 2 === 0);
        if (diagonal < 0) {
            const lowerBoundEven = (diagonalsBelow % 2 === 0);
            return (diffEven === lowerBoundEven) ? 0 : 1;
        }
        else {
            const upperBoundEven = (diagonalsAbove % 2 === 0);
            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DiffChange: () => (/* binding */ DiffChange)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Represents information about a specific difference between two sequences.
 */
class DiffChange {
    /**
     * Constructs a new DiffChange with the given sequence information
     * and content.
     */
    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
        //Debug.Assert(originalLength > 0 || modifiedLength > 0, "originalLength and modifiedLength cannot both be <= 0");
        this.originalStart = originalStart;
        this.originalLength = originalLength;
        this.modifiedStart = modifiedStart;
        this.modifiedLength = modifiedLength;
    }
    /**
     * The end point (exclusive) of the change in the original sequence.
     */
    getOriginalEnd() {
        return this.originalStart + this.originalLength;
    }
    /**
     * The end point (exclusive) of the change in the modified sequence.
     */
    getModifiedEnd() {
        return this.modifiedStart + this.modifiedLength;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/errors.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/errors.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BugIndicatingError: () => (/* binding */ BugIndicatingError),
/* harmony export */   CancellationError: () => (/* binding */ CancellationError),
/* harmony export */   ErrorHandler: () => (/* binding */ ErrorHandler),
/* harmony export */   ErrorNoTelemetry: () => (/* binding */ ErrorNoTelemetry),
/* harmony export */   NotSupportedError: () => (/* binding */ NotSupportedError),
/* harmony export */   canceled: () => (/* binding */ canceled),
/* harmony export */   errorHandler: () => (/* binding */ errorHandler),
/* harmony export */   illegalArgument: () => (/* binding */ illegalArgument),
/* harmony export */   illegalState: () => (/* binding */ illegalState),
/* harmony export */   isCancellationError: () => (/* binding */ isCancellationError),
/* harmony export */   onUnexpectedError: () => (/* binding */ onUnexpectedError),
/* harmony export */   onUnexpectedExternalError: () => (/* binding */ onUnexpectedExternalError),
/* harmony export */   transformErrorForSerialization: () => (/* binding */ transformErrorForSerialization)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Avoid circular dependency on EventEmitter by implementing a subset of the interface.
class ErrorHandler {
    constructor() {
        this.listeners = [];
        this.unexpectedErrorHandler = function (e) {
            setTimeout(() => {
                if (e.stack) {
                    if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {
                        throw new ErrorNoTelemetry(e.message + '\n\n' + e.stack);
                    }
                    throw new Error(e.message + '\n\n' + e.stack);
                }
                throw e;
            }, 0);
        };
    }
    emit(e) {
        this.listeners.forEach((listener) => {
            listener(e);
        });
    }
    onUnexpectedError(e) {
        this.unexpectedErrorHandler(e);
        this.emit(e);
    }
    // For external errors, we don't want the listeners to be called
    onUnexpectedExternalError(e) {
        this.unexpectedErrorHandler(e);
    }
}
const errorHandler = new ErrorHandler();
function onUnexpectedError(e) {
    // ignore errors from cancelled promises
    if (!isCancellationError(e)) {
        errorHandler.onUnexpectedError(e);
    }
    return undefined;
}
function onUnexpectedExternalError(e) {
    // ignore errors from cancelled promises
    if (!isCancellationError(e)) {
        errorHandler.onUnexpectedExternalError(e);
    }
    return undefined;
}
function transformErrorForSerialization(error) {
    if (error instanceof Error) {
        const { name, message } = error;
        const stack = error.stacktrace || error.stack;
        return {
            $isError: true,
            name,
            message,
            stack,
            noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)
        };
    }
    // return as is
    return error;
}
const canceledName = 'Canceled';
/**
 * Checks if the given error is a promise in canceled state
 */
function isCancellationError(error) {
    if (error instanceof CancellationError) {
        return true;
    }
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
// !!!IMPORTANT!!!
// Do NOT change this class because it is also used as an API-type.
class CancellationError extends Error {
    constructor() {
        super(canceledName);
        this.name = this.message;
    }
}
/**
 * @deprecated use {@link CancellationError `new CancellationError()`} instead
 */
function canceled() {
    const error = new Error(canceledName);
    error.name = error.message;
    return error;
}
function illegalArgument(name) {
    if (name) {
        return new Error(`Illegal argument: ${name}`);
    }
    else {
        return new Error('Illegal argument');
    }
}
function illegalState(name) {
    if (name) {
        return new Error(`Illegal state: ${name}`);
    }
    else {
        return new Error('Illegal state');
    }
}
class NotSupportedError extends Error {
    constructor(message) {
        super('NotSupported');
        if (message) {
            this.message = message;
        }
    }
}
/**
 * Error that when thrown won't be logged in telemetry as an unhandled error.
 */
class ErrorNoTelemetry extends Error {
    constructor(msg) {
        super(msg);
        this.name = 'CodeExpectedError';
    }
    static fromError(err) {
        if (err instanceof ErrorNoTelemetry) {
            return err;
        }
        const result = new ErrorNoTelemetry();
        result.message = err.message;
        result.stack = err.stack;
        return result;
    }
    static isErrorNoTelemetry(err) {
        return err.name === 'CodeExpectedError';
    }
}
/**
 * This error indicates a bug.
 * Do not throw this for invalid user input.
 * Only catch this error to recover gracefully from bugs.
 */
class BugIndicatingError extends Error {
    constructor(message) {
        super(message || 'An unexpected bug occurred.');
        Object.setPrototypeOf(this, BugIndicatingError.prototype);
        // Because we know for sure only buggy code throws this,
        // we definitely want to break here and fix the bug.
        // eslint-disable-next-line no-debugger
        // debugger;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/event.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/event.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DebounceEmitter: () => (/* binding */ DebounceEmitter),
/* harmony export */   Emitter: () => (/* binding */ Emitter),
/* harmony export */   Event: () => (/* binding */ Event),
/* harmony export */   EventBufferer: () => (/* binding */ EventBufferer),
/* harmony export */   EventMultiplexer: () => (/* binding */ EventMultiplexer),
/* harmony export */   EventProfiling: () => (/* binding */ EventProfiling),
/* harmony export */   ListenerLeakError: () => (/* binding */ ListenerLeakError),
/* harmony export */   ListenerRefusalError: () => (/* binding */ ListenerRefusalError),
/* harmony export */   MicrotaskEmitter: () => (/* binding */ MicrotaskEmitter),
/* harmony export */   PauseableEmitter: () => (/* binding */ PauseableEmitter),
/* harmony export */   Relay: () => (/* binding */ Relay),
/* harmony export */   createEventDeliveryQueue: () => (/* binding */ createEventDeliveryQueue)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _functional_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional.js */ "./node_modules/monaco-editor/esm/vs/base/common/functional.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _linkedList_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./linkedList.js */ "./node_modules/monaco-editor/esm/vs/base/common/linkedList.js");
/* harmony import */ var _stopwatch_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stopwatch.js */ "./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js");





// -----------------------------------------------------------------------------------------------------------------------
// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.
// -----------------------------------------------------------------------------------------------------------------------
const _enableListenerGCedWarning = false;
// -----------------------------------------------------------------------------------------------------------------------
// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.
// -----------------------------------------------------------------------------------------------------------------------
const _enableDisposeWithListenerWarning = false;
// -----------------------------------------------------------------------------------------------------------------------
// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.
// See https://github.com/microsoft/vscode/issues/142851
// -----------------------------------------------------------------------------------------------------------------------
const _enableSnapshotPotentialLeakWarning = false;
var Event;
(function (Event) {
    Event.None = () => _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;
    function _addLeakageTraceLogic(options) {
        if (_enableSnapshotPotentialLeakWarning) {
            const { onDidAddListener: origListenerDidAdd } = options;
            const stack = Stacktrace.create();
            let count = 0;
            options.onDidAddListener = () => {
                if (++count === 2) {
                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');
                    stack.print();
                }
                origListenerDidAdd?.();
            };
        }
    }
    /**
     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared
     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a
     * result of merging events and to try prevent race conditions that could arise when using related deferred and
     * non-deferred events.
     *
     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work
     * (eg. latency of keypress to text rendered).
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The event source for the new event.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function defer(event, disposable) {
        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);
    }
    Event.defer = defer;
    /**
     * Given an event, returns another event which only fires once.
     *
     * @param event The event source for the new event.
     */
    function once(event) {
        return (listener, thisArgs = null, disposables) => {
            // we need this, in case the event fires during the listener call
            let didFire = false;
            let result = undefined;
            result = event(e => {
                if (didFire) {
                    return;
                }
                else if (result) {
                    result.dispose();
                }
                else {
                    didFire = true;
                }
                return listener.call(thisArgs, e);
            }, null, disposables);
            if (didFire) {
                result.dispose();
            }
            return result;
        };
    }
    Event.once = once;
    /**
     * Given an event, returns another event which only fires once, and only when the condition is met.
     *
     * @param event The event source for the new event.
     */
    function onceIf(event, condition) {
        return Event.once(Event.filter(event, condition));
    }
    Event.onceIf = onceIf;
    /**
     * Maps an event of one type into an event of another type using a mapping function, similar to how
     * `Array.prototype.map` works.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The event source for the new event.
     * @param map The mapping function.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function map(event, map, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);
    }
    Event.map = map;
    /**
     * Wraps an event in another event that performs some function on the event object before firing.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The event source for the new event.
     * @param each The function to perform on the event object.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function forEach(event, each, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);
    }
    Event.forEach = forEach;
    function filter(event, filter, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);
    }
    Event.filter = filter;
    /**
     * Given an event, returns the same event but typed as `Event<void>`.
     */
    function signal(event) {
        return event;
    }
    Event.signal = signal;
    function any(...events) {
        return (listener, thisArgs = null, disposables) => {
            const disposable = (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.combinedDisposable)(...events.map(event => event(e => listener.call(thisArgs, e))));
            return addAndReturnDisposable(disposable, disposables);
        };
    }
    Event.any = any;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function reduce(event, merge, initial, disposable) {
        let output = initial;
        return map(event, e => {
            output = merge(output, e);
            return output;
        }, disposable);
    }
    Event.reduce = reduce;
    function snapshot(event, disposable) {
        let listener;
        const options = {
            onWillAddFirstListener() {
                listener = event(emitter.fire, emitter);
            },
            onDidRemoveLastListener() {
                listener?.dispose();
            }
        };
        if (!disposable) {
            _addLeakageTraceLogic(options);
        }
        const emitter = new Emitter(options);
        disposable?.add(emitter);
        return emitter.event;
    }
    /**
     * Adds the IDisposable to the store if it's set, and returns it. Useful to
     * Event function implementation.
     */
    function addAndReturnDisposable(d, store) {
        if (store instanceof Array) {
            store.push(d);
        }
        else if (store) {
            store.add(d);
        }
        return d;
    }
    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
        let subscription;
        let output = undefined;
        let handle = undefined;
        let numDebouncedCalls = 0;
        let doFire;
        const options = {
            leakWarningThreshold,
            onWillAddFirstListener() {
                subscription = event(cur => {
                    numDebouncedCalls++;
                    output = merge(output, cur);
                    if (leading && !handle) {
                        emitter.fire(output);
                        output = undefined;
                    }
                    doFire = () => {
                        const _output = output;
                        output = undefined;
                        handle = undefined;
                        if (!leading || numDebouncedCalls > 1) {
                            emitter.fire(_output);
                        }
                        numDebouncedCalls = 0;
                    };
                    if (typeof delay === 'number') {
                        clearTimeout(handle);
                        handle = setTimeout(doFire, delay);
                    }
                    else {
                        if (handle === undefined) {
                            handle = 0;
                            queueMicrotask(doFire);
                        }
                    }
                });
            },
            onWillRemoveListener() {
                if (flushOnListenerRemove && numDebouncedCalls > 0) {
                    doFire?.();
                }
            },
            onDidRemoveLastListener() {
                doFire = undefined;
                subscription.dispose();
            }
        };
        if (!disposable) {
            _addLeakageTraceLogic(options);
        }
        const emitter = new Emitter(options);
        disposable?.add(emitter);
        return emitter.event;
    }
    Event.debounce = debounce;
    /**
     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function accumulate(event, delay = 0, disposable) {
        return Event.debounce(event, (last, e) => {
            if (!last) {
                return [e];
            }
            last.push(e);
            return last;
        }, delay, undefined, true, undefined, disposable);
    }
    Event.accumulate = accumulate;
    /**
     * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate
     * event objects from different sources do not fire the same event object.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The event source for the new event.
     * @param equals The equality condition.
     * @param disposable A disposable store to add the new EventEmitter to.
     *
     * @example
     * ```
     * // Fire only one time when a single window is opened or focused
     * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))
     * ```
     */
    function latch(event, equals = (a, b) => a === b, disposable) {
        let firstCall = true;
        let cache;
        return filter(event, value => {
            const shouldEmit = firstCall || !equals(value, cache);
            firstCall = false;
            cache = value;
            return shouldEmit;
        }, disposable);
    }
    Event.latch = latch;
    /**
     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @example
     * ```
     * const event = new EventEmitter<number | undefined>().event;
     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);
     * ```
     *
     * @param event The event source for the new event.
     * @param isT A function that determines what event is of the first type.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function split(event, isT, disposable) {
        return [
            Event.filter(event, isT, disposable),
            Event.filter(event, e => !isT(e), disposable),
        ];
    }
    Event.split = split;
    /**
     * Buffers an event until it has a listener attached.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The event source for the new event.
     * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a
     * `setTimeout` when the first event listener is added.
     * @param _buffer Internal: A source event array used for tests.
     *
     * @example
     * ```
     * // Start accumulating events, when the first listener is attached, flush
     * // the event after a timeout such that multiple listeners attached before
     * // the timeout would receive the event
     * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);
     * ```
     */
    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {
        let buffer = _buffer.slice();
        let listener = event(e => {
            if (buffer) {
                buffer.push(e);
            }
            else {
                emitter.fire(e);
            }
        });
        if (disposable) {
            disposable.add(listener);
        }
        const flush = () => {
            buffer?.forEach(e => emitter.fire(e));
            buffer = null;
        };
        const emitter = new Emitter({
            onWillAddFirstListener() {
                if (!listener) {
                    listener = event(e => emitter.fire(e));
                    if (disposable) {
                        disposable.add(listener);
                    }
                }
            },
            onDidAddFirstListener() {
                if (buffer) {
                    if (flushAfterTimeout) {
                        setTimeout(flush);
                    }
                    else {
                        flush();
                    }
                }
            },
            onDidRemoveLastListener() {
                if (listener) {
                    listener.dispose();
                }
                listener = null;
            }
        });
        if (disposable) {
            disposable.add(emitter);
        }
        return emitter.event;
    }
    Event.buffer = buffer;
    /**
     * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.
     *
     * @example
     * ```
     * // Normal
     * const onEnterPressNormal = Event.filter(
     *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),
     *   e.keyCode === KeyCode.Enter
     * ).event;
     *
     * // Using chain
     * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $
     *   .map(e => new StandardKeyboardEvent(e))
     *   .filter(e => e.keyCode === KeyCode.Enter)
     * );
     * ```
     */
    function chain(event, sythensize) {
        const fn = (listener, thisArgs, disposables) => {
            const cs = sythensize(new ChainableSynthesis());
            return event(function (value) {
                const result = cs.evaluate(value);
                if (result !== HaltChainable) {
                    listener.call(thisArgs, result);
                }
            }, undefined, disposables);
        };
        return fn;
    }
    Event.chain = chain;
    const HaltChainable = Symbol('HaltChainable');
    class ChainableSynthesis {
        constructor() {
            this.steps = [];
        }
        map(fn) {
            this.steps.push(fn);
            return this;
        }
        forEach(fn) {
            this.steps.push(v => {
                fn(v);
                return v;
            });
            return this;
        }
        filter(fn) {
            this.steps.push(v => fn(v) ? v : HaltChainable);
            return this;
        }
        reduce(merge, initial) {
            let last = initial;
            this.steps.push(v => {
                last = merge(last, v);
                return last;
            });
            return this;
        }
        latch(equals = (a, b) => a === b) {
            let firstCall = true;
            let cache;
            this.steps.push(value => {
                const shouldEmit = firstCall || !equals(value, cache);
                firstCall = false;
                cache = value;
                return shouldEmit ? value : HaltChainable;
            });
            return this;
        }
        evaluate(value) {
            for (const step of this.steps) {
                value = step(value);
                if (value === HaltChainable) {
                    break;
                }
            }
            return value;
        }
    }
    /**
     * Creates an {@link Event} from a node event emitter.
     */
    function fromNodeEventEmitter(emitter, eventName, map = id => id) {
        const fn = (...args) => result.fire(map(...args));
        const onFirstListenerAdd = () => emitter.on(eventName, fn);
        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
        return result.event;
    }
    Event.fromNodeEventEmitter = fromNodeEventEmitter;
    /**
     * Creates an {@link Event} from a DOM event emitter.
     */
    function fromDOMEventEmitter(emitter, eventName, map = id => id) {
        const fn = (...args) => result.fire(map(...args));
        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
        return result.event;
    }
    Event.fromDOMEventEmitter = fromDOMEventEmitter;
    /**
     * Creates a promise out of an event, using the {@link Event.once} helper.
     */
    function toPromise(event) {
        return new Promise(resolve => once(event)(resolve));
    }
    Event.toPromise = toPromise;
    /**
     * Creates an event out of a promise that fires once when the promise is
     * resolved with the result of the promise or `undefined`.
     */
    function fromPromise(promise) {
        const result = new Emitter();
        promise.then(res => {
            result.fire(res);
        }, () => {
            result.fire(undefined);
        }).finally(() => {
            result.dispose();
        });
        return result.event;
    }
    Event.fromPromise = fromPromise;
    /**
     * A convenience function for forwarding an event to another emitter which
     * improves readability.
     *
     * This is similar to {@link Relay} but allows instantiating and forwarding
     * on a single line and also allows for multiple source events.
     * @param from The event to forward.
     * @param to The emitter to forward the event to.
     * @example
     * Event.forward(event, emitter);
     * // equivalent to
     * event(e => emitter.fire(e));
     * // equivalent to
     * event(emitter.fire, emitter);
     */
    function forward(from, to) {
        return from(e => to.fire(e));
    }
    Event.forward = forward;
    function runAndSubscribe(event, handler, initial) {
        handler(initial);
        return event(e => handler(e));
    }
    Event.runAndSubscribe = runAndSubscribe;
    class EmitterObserver {
        constructor(_observable, store) {
            this._observable = _observable;
            this._counter = 0;
            this._hasChanged = false;
            const options = {
                onWillAddFirstListener: () => {
                    _observable.addObserver(this);
                    // Communicate to the observable that we received its current value and would like to be notified about future changes.
                    this._observable.reportChanges();
                },
                onDidRemoveLastListener: () => {
                    _observable.removeObserver(this);
                }
            };
            if (!store) {
                _addLeakageTraceLogic(options);
            }
            this.emitter = new Emitter(options);
            if (store) {
                store.add(this.emitter);
            }
        }
        beginUpdate(_observable) {
            // assert(_observable === this.obs);
            this._counter++;
        }
        handlePossibleChange(_observable) {
            // assert(_observable === this.obs);
        }
        handleChange(_observable, _change) {
            // assert(_observable === this.obs);
            this._hasChanged = true;
        }
        endUpdate(_observable) {
            // assert(_observable === this.obs);
            this._counter--;
            if (this._counter === 0) {
                this._observable.reportChanges();
                if (this._hasChanged) {
                    this._hasChanged = false;
                    this.emitter.fire(this._observable.get());
                }
            }
        }
    }
    /**
     * Creates an event emitter that is fired when the observable changes.
     * Each listeners subscribes to the emitter.
     */
    function fromObservable(obs, store) {
        const observer = new EmitterObserver(obs, store);
        return observer.emitter.event;
    }
    Event.fromObservable = fromObservable;
    /**
     * Each listener is attached to the observable directly.
     */
    function fromObservableLight(observable) {
        return (listener, thisArgs, disposables) => {
            let count = 0;
            let didChange = false;
            const observer = {
                beginUpdate() {
                    count++;
                },
                endUpdate() {
                    count--;
                    if (count === 0) {
                        observable.reportChanges();
                        if (didChange) {
                            didChange = false;
                            listener.call(thisArgs);
                        }
                    }
                },
                handlePossibleChange() {
                    // noop
                },
                handleChange() {
                    didChange = true;
                }
            };
            observable.addObserver(observer);
            observable.reportChanges();
            const disposable = {
                dispose() {
                    observable.removeObserver(observer);
                }
            };
            if (disposables instanceof _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStore) {
                disposables.add(disposable);
            }
            else if (Array.isArray(disposables)) {
                disposables.push(disposable);
            }
            return disposable;
        };
    }
    Event.fromObservableLight = fromObservableLight;
})(Event || (Event = {}));
class EventProfiling {
    static { this.all = new Set(); }
    static { this._idPool = 0; }
    constructor(name) {
        this.listenerCount = 0;
        this.invocationCount = 0;
        this.elapsedOverall = 0;
        this.durations = [];
        this.name = `${name}_${EventProfiling._idPool++}`;
        EventProfiling.all.add(this);
    }
    start(listenerCount) {
        this._stopWatch = new _stopwatch_js__WEBPACK_IMPORTED_MODULE_4__.StopWatch();
        this.listenerCount = listenerCount;
    }
    stop() {
        if (this._stopWatch) {
            const elapsed = this._stopWatch.elapsed();
            this.durations.push(elapsed);
            this.elapsedOverall += elapsed;
            this.invocationCount += 1;
            this._stopWatch = undefined;
        }
    }
}
let _globalLeakWarningThreshold = -1;
class LeakageMonitor {
    static { this._idPool = 1; }
    constructor(_errorHandler, threshold, name = (LeakageMonitor._idPool++).toString(16).padStart(3, '0')) {
        this._errorHandler = _errorHandler;
        this.threshold = threshold;
        this.name = name;
        this._warnCountdown = 0;
    }
    dispose() {
        this._stacks?.clear();
    }
    check(stack, listenerCount) {
        const threshold = this.threshold;
        if (threshold <= 0 || listenerCount < threshold) {
            return undefined;
        }
        if (!this._stacks) {
            this._stacks = new Map();
        }
        const count = (this._stacks.get(stack.value) || 0);
        this._stacks.set(stack.value, count + 1);
        this._warnCountdown -= 1;
        if (this._warnCountdown <= 0) {
            // only warn on first exceed and then every time the limit
            // is exceeded by 50% again
            this._warnCountdown = threshold * 0.5;
            const [topStack, topCount] = this.getMostFrequentStack();
            const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;
            console.warn(message);
            console.warn(topStack);
            const error = new ListenerLeakError(message, topStack);
            this._errorHandler(error);
        }
        return () => {
            const count = (this._stacks.get(stack.value) || 0);
            this._stacks.set(stack.value, count - 1);
        };
    }
    getMostFrequentStack() {
        if (!this._stacks) {
            return undefined;
        }
        let topStack;
        let topCount = 0;
        for (const [stack, count] of this._stacks) {
            if (!topStack || topCount < count) {
                topStack = [stack, count];
                topCount = count;
            }
        }
        return topStack;
    }
}
class Stacktrace {
    static create() {
        const err = new Error();
        return new Stacktrace(err.stack ?? '');
    }
    constructor(value) {
        this.value = value;
    }
    print() {
        console.warn(this.value.split('\n').slice(2).join('\n'));
    }
}
// error that is logged when going over the configured listener threshold
class ListenerLeakError extends Error {
    constructor(message, stack) {
        super(message);
        this.name = 'ListenerLeakError';
        this.stack = stack;
    }
}
// SEVERE error that is logged when having gone way over the configured listener
// threshold so that the emitter refuses to accept more listeners
class ListenerRefusalError extends Error {
    constructor(message, stack) {
        super(message);
        this.name = 'ListenerRefusalError';
        this.stack = stack;
    }
}
class UniqueContainer {
    constructor(value) {
        this.value = value;
    }
}
const compactionThreshold = 2;
const forEachListener = (listeners, fn) => {
    if (listeners instanceof UniqueContainer) {
        fn(listeners);
    }
    else {
        for (let i = 0; i < listeners.length; i++) {
            const l = listeners[i];
            if (l) {
                fn(l);
            }
        }
    }
};
let _listenerFinalizers;
if (_enableListenerGCedWarning) {
    const leaks = [];
    setInterval(() => {
        if (leaks.length === 0) {
            return;
        }
        console.warn('[LEAKING LISTENERS] GC\'ed these listeners that were NOT yet disposed:');
        console.warn(leaks.join('\n'));
        leaks.length = 0;
    }, 3000);
    _listenerFinalizers = new FinalizationRegistry(heldValue => {
        if (typeof heldValue === 'string') {
            leaks.push(heldValue);
        }
    });
}
/**
 * The Emitter can be used to expose an Event to the public
 * to fire it from the insides.
 * Sample:
    class Document {

        private readonly _onDidChange = new Emitter<(value:string)=>any>();

        public onDidChange = this._onDidChange.event;

        // getter-style
        // get onDidChange(): Event<(value:string)=>any> {
        // 	return this._onDidChange.event;
        // }

        private _doIt() {
            //...
            this._onDidChange.fire(value);
        }
    }
 */
class Emitter {
    constructor(options) {
        this._size = 0;
        this._options = options;
        this._leakageMon = (_globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold)
            ? new LeakageMonitor(options?.onListenerError ?? _errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) :
            undefined;
        this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;
        this._deliveryQueue = this._options?.deliveryQueue;
    }
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter
            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and
            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the
            // the following programming pattern is very popular:
            //
            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model
            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener
            // ...later...
            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the "overall dispose" is done
            if (this._deliveryQueue?.current === this) {
                this._deliveryQueue.reset();
            }
            if (this._listeners) {
                if (_enableDisposeWithListenerWarning) {
                    const listeners = this._listeners;
                    queueMicrotask(() => {
                        forEachListener(listeners, l => l.stack?.print());
                    });
                }
                this._listeners = undefined;
                this._size = 0;
            }
            this._options?.onDidRemoveLastListener?.();
            this._leakageMon?.dispose();
        }
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        this._event ??= (callback, thisArgs, disposables) => {
            if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
                const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
                console.warn(message);
                const tuple = this._leakageMon.getMostFrequentStack() ?? ['UNKNOWN stack', -1];
                const error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);
                const errorHandler = this._options?.onListenerError || _errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError;
                errorHandler(error);
                return _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;
            }
            if (this._disposed) {
                // todo: should we warn if a listener is added to a disposed emitter? This happens often
                return _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;
            }
            if (thisArgs) {
                callback = callback.bind(thisArgs);
            }
            const contained = new UniqueContainer(callback);
            let removeMonitor;
            let stack;
            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
                // check and record this emitter for potential leakage
                contained.stack = Stacktrace.create();
                removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
            }
            if (_enableDisposeWithListenerWarning) {
                contained.stack = stack ?? Stacktrace.create();
            }
            if (!this._listeners) {
                this._options?.onWillAddFirstListener?.(this);
                this._listeners = contained;
                this._options?.onDidAddFirstListener?.(this);
            }
            else if (this._listeners instanceof UniqueContainer) {
                this._deliveryQueue ??= new EventDeliveryQueuePrivate();
                this._listeners = [this._listeners, contained];
            }
            else {
                this._listeners.push(contained);
            }
            this._size++;
            const result = (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.toDisposable)(() => {
                _listenerFinalizers?.unregister(result);
                removeMonitor?.();
                this._removeListener(contained);
            });
            if (disposables instanceof _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStore) {
                disposables.add(result);
            }
            else if (Array.isArray(disposables)) {
                disposables.push(result);
            }
            if (_listenerFinalizers) {
                const stack = new Error().stack.split('\n').slice(2, 3).join('\n').trim();
                const match = /(file:|vscode-file:\/\/vscode-app)?(\/[^:]*:\d+:\d+)/.exec(stack);
                _listenerFinalizers.register(result, match?.[2] ?? stack, result);
            }
            return result;
        };
        return this._event;
    }
    _removeListener(listener) {
        this._options?.onWillRemoveListener?.(this);
        if (!this._listeners) {
            return; // expected if a listener gets disposed
        }
        if (this._size === 1) {
            this._listeners = undefined;
            this._options?.onDidRemoveLastListener?.(this);
            this._size = 0;
            return;
        }
        // size > 1 which requires that listeners be a list:
        const listeners = this._listeners;
        const index = listeners.indexOf(listener);
        if (index === -1) {
            console.log('disposed?', this._disposed);
            console.log('size?', this._size);
            console.log('arr?', JSON.stringify(this._listeners));
            throw new Error('Attempted to dispose unknown listener');
        }
        this._size--;
        listeners[index] = undefined;
        const adjustDeliveryQueue = this._deliveryQueue.current === this;
        if (this._size * compactionThreshold <= listeners.length) {
            let n = 0;
            for (let i = 0; i < listeners.length; i++) {
                if (listeners[i]) {
                    listeners[n++] = listeners[i];
                }
                else if (adjustDeliveryQueue) {
                    this._deliveryQueue.end--;
                    if (n < this._deliveryQueue.i) {
                        this._deliveryQueue.i--;
                    }
                }
            }
            listeners.length = n;
        }
    }
    _deliver(listener, value) {
        if (!listener) {
            return;
        }
        const errorHandler = this._options?.onListenerError || _errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError;
        if (!errorHandler) {
            listener.value(value);
            return;
        }
        try {
            listener.value(value);
        }
        catch (e) {
            errorHandler(e);
        }
    }
    /** Delivers items in the queue. Assumes the queue is ready to go. */
    _deliverQueue(dq) {
        const listeners = dq.current._listeners;
        while (dq.i < dq.end) {
            // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()
            this._deliver(listeners[dq.i++], dq.value);
        }
        dq.reset();
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._deliveryQueue?.current) {
            this._deliverQueue(this._deliveryQueue);
            this._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch
        }
        this._perfMon?.start(this._size);
        if (!this._listeners) {
            // no-op
        }
        else if (this._listeners instanceof UniqueContainer) {
            this._deliver(this._listeners, event);
        }
        else {
            const dq = this._deliveryQueue;
            dq.enqueue(this, event, this._listeners.length);
            this._deliverQueue(dq);
        }
        this._perfMon?.stop();
    }
    hasListeners() {
        return this._size > 0;
    }
}
const createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();
class EventDeliveryQueuePrivate {
    constructor() {
        /**
         * Index in current's listener list.
         */
        this.i = -1;
        /**
         * The last index in the listener's list to deliver.
         */
        this.end = 0;
    }
    enqueue(emitter, value, end) {
        this.i = 0;
        this.end = end;
        this.current = emitter;
        this.value = value;
    }
    reset() {
        this.i = this.end; // force any current emission loop to stop, mainly for during dispose
        this.current = undefined;
        this.value = undefined;
    }
}
class PauseableEmitter extends Emitter {
    constructor(options) {
        super(options);
        this._isPaused = 0;
        this._eventQueue = new _linkedList_js__WEBPACK_IMPORTED_MODULE_3__.LinkedList();
        this._mergeFn = options?.merge;
    }
    pause() {
        this._isPaused++;
    }
    resume() {
        if (this._isPaused !== 0 && --this._isPaused === 0) {
            if (this._mergeFn) {
                // use the merge function to create a single composite
                // event. make a copy in case firing pauses this emitter
                if (this._eventQueue.size > 0) {
                    const events = Array.from(this._eventQueue);
                    this._eventQueue.clear();
                    super.fire(this._mergeFn(events));
                }
            }
            else {
                // no merging, fire each event individually and test
                // that this emitter isn't paused halfway through
                while (!this._isPaused && this._eventQueue.size !== 0) {
                    super.fire(this._eventQueue.shift());
                }
            }
        }
    }
    fire(event) {
        if (this._size) {
            if (this._isPaused !== 0) {
                this._eventQueue.push(event);
            }
            else {
                super.fire(event);
            }
        }
    }
}
class DebounceEmitter extends PauseableEmitter {
    constructor(options) {
        super(options);
        this._delay = options.delay ?? 100;
    }
    fire(event) {
        if (!this._handle) {
            this.pause();
            this._handle = setTimeout(() => {
                this._handle = undefined;
                this.resume();
            }, this._delay);
        }
        super.fire(event);
    }
}
/**
 * An emitter which queue all events and then process them at the
 * end of the event loop.
 */
class MicrotaskEmitter extends Emitter {
    constructor(options) {
        super(options);
        this._queuedEvents = [];
        this._mergeFn = options?.merge;
    }
    fire(event) {
        if (!this.hasListeners()) {
            return;
        }
        this._queuedEvents.push(event);
        if (this._queuedEvents.length === 1) {
            queueMicrotask(() => {
                if (this._mergeFn) {
                    super.fire(this._mergeFn(this._queuedEvents));
                }
                else {
                    this._queuedEvents.forEach(e => super.fire(e));
                }
                this._queuedEvents = [];
            });
        }
    }
}
/**
 * An event emitter that multiplexes many events into a single event.
 *
 * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s
 * to the multiplexer as needed.
 *
 * ```typescript
 * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();
 *
 * const thingListeners = DisposableMap<Thing, IDisposable>();
 *
 * thingService.onDidAddThing(thing => {
 *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);
 * });
 * thingService.onDidRemoveThing(thing => {
 *   thingListeners.deleteAndDispose(thing);
 * });
 *
 * anythingDataMultiplexer.event(e => {
 *   console.log('Something fired data ' + e.data)
 * });
 * ```
 */
class EventMultiplexer {
    constructor() {
        this.hasListeners = false;
        this.events = [];
        this.emitter = new Emitter({
            onWillAddFirstListener: () => this.onFirstListenerAdd(),
            onDidRemoveLastListener: () => this.onLastListenerRemove()
        });
    }
    get event() {
        return this.emitter.event;
    }
    add(event) {
        const e = { event: event, listener: null };
        this.events.push(e);
        if (this.hasListeners) {
            this.hook(e);
        }
        const dispose = () => {
            if (this.hasListeners) {
                this.unhook(e);
            }
            const idx = this.events.indexOf(e);
            this.events.splice(idx, 1);
        };
        return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.toDisposable)((0,_functional_js__WEBPACK_IMPORTED_MODULE_1__.createSingleCallFunction)(dispose));
    }
    onFirstListenerAdd() {
        this.hasListeners = true;
        this.events.forEach(e => this.hook(e));
    }
    onLastListenerRemove() {
        this.hasListeners = false;
        this.events.forEach(e => this.unhook(e));
    }
    hook(e) {
        e.listener = e.event(r => this.emitter.fire(r));
    }
    unhook(e) {
        e.listener?.dispose();
        e.listener = null;
    }
    dispose() {
        this.emitter.dispose();
        for (const e of this.events) {
            e.listener?.dispose();
        }
        this.events = [];
    }
}
/**
 * The EventBufferer is useful in situations in which you want
 * to delay firing your events during some code.
 * You can wrap that code and be sure that the event will not
 * be fired during that wrap.
 *
 * ```
 * const emitter: Emitter;
 * const delayer = new EventDelayer();
 * const delayedEvent = delayer.wrapEvent(emitter.event);
 *
 * delayedEvent(console.log);
 *
 * delayer.bufferEvents(() => {
 *   emitter.fire(); // event will not be fired yet
 * });
 *
 * // event will only be fired at this point
 * ```
 */
class EventBufferer {
    constructor() {
        this.data = [];
    }
    wrapEvent(event, reduce, initial) {
        return (listener, thisArgs, disposables) => {
            return event(i => {
                const data = this.data[this.data.length - 1];
                // Non-reduce scenario
                if (!reduce) {
                    // Buffering case
                    if (data) {
                        data.buffers.push(() => listener.call(thisArgs, i));
                    }
                    else {
                        // Not buffering case
                        listener.call(thisArgs, i);
                    }
                    return;
                }
                // Reduce scenario
                const reduceData = data;
                // Not buffering case
                if (!reduceData) {
                    // TODO: Is there a way to cache this reduce call for all listeners?
                    listener.call(thisArgs, reduce(initial, i));
                    return;
                }
                // Buffering case
                reduceData.items ??= [];
                reduceData.items.push(i);
                if (reduceData.buffers.length === 0) {
                    // Include a single buffered function that will reduce all events when we're done buffering events
                    data.buffers.push(() => {
                        // cache the reduced result so that the value can be shared across all listeners
                        reduceData.reducedResult ??= initial
                            ? reduceData.items.reduce(reduce, initial)
                            : reduceData.items.reduce(reduce);
                        listener.call(thisArgs, reduceData.reducedResult);
                    });
                }
            }, undefined, disposables);
        };
    }
    bufferEvents(fn) {
        const data = { buffers: new Array() };
        this.data.push(data);
        const r = fn();
        this.data.pop();
        data.buffers.forEach(flush => flush());
        return r;
    }
}
/**
 * A Relay is an event forwarder which functions as a replugabble event pipe.
 * Once created, you can connect an input event to it and it will simply forward
 * events from that input event through its own `event` property. The `input`
 * can be changed at any point in time.
 */
class Relay {
    constructor() {
        this.listening = false;
        this.inputEvent = Event.None;
        this.inputEventListener = _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;
        this.emitter = new Emitter({
            onDidAddFirstListener: () => {
                this.listening = true;
                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
            },
            onDidRemoveLastListener: () => {
                this.listening = false;
                this.inputEventListener.dispose();
            }
        });
        this.event = this.emitter.event;
    }
    set input(event) {
        this.inputEvent = event;
        if (this.listening) {
            this.inputEventListener.dispose();
            this.inputEventListener = event(this.emitter.fire, this.emitter);
        }
    }
    dispose() {
        this.inputEventListener.dispose();
        this.emitter.dispose();
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/functional.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/functional.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSingleCallFunction: () => (/* binding */ createSingleCallFunction)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Given a function, returns a function that is only calling that function once.
 */
function createSingleCallFunction(fn, fnDidRunCallback) {
    const _this = this;
    let didCall = false;
    let result;
    return function () {
        if (didCall) {
            return result;
        }
        didCall = true;
        if (fnDidRunCallback) {
            try {
                result = fn.apply(_this, arguments);
            }
            finally {
                fnDidRunCallback();
            }
        }
        else {
            result = fn.apply(_this, arguments);
        }
        return result;
    };
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/hash.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/hash.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringSHA1: () => (/* binding */ StringSHA1),
/* harmony export */   doHash: () => (/* binding */ doHash),
/* harmony export */   hash: () => (/* binding */ hash),
/* harmony export */   numberHash: () => (/* binding */ numberHash),
/* harmony export */   stringHash: () => (/* binding */ stringHash),
/* harmony export */   toHexString: () => (/* binding */ toHexString)
/* harmony export */ });
/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Return a hash value for an object.
 */
function hash(obj) {
    return doHash(obj, 0);
}
function doHash(obj, hashVal) {
    switch (typeof obj) {
        case 'object':
            if (obj === null) {
                return numberHash(349, hashVal);
            }
            else if (Array.isArray(obj)) {
                return arrayHash(obj, hashVal);
            }
            return objectHash(obj, hashVal);
        case 'string':
            return stringHash(obj, hashVal);
        case 'boolean':
            return booleanHash(obj, hashVal);
        case 'number':
            return numberHash(obj, hashVal);
        case 'undefined':
            return numberHash(937, hashVal);
        default:
            return numberHash(617, hashVal);
    }
}
function numberHash(val, initialHashVal) {
    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32
}
function booleanHash(b, initialHashVal) {
    return numberHash(b ? 433 : 863, initialHashVal);
}
function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i = 0, length = s.length; i < length; i++) {
        hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
}
function arrayHash(arr, initialHashVal) {
    initialHashVal = numberHash(104579, initialHashVal);
    return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);
}
function objectHash(obj, initialHashVal) {
    initialHashVal = numberHash(181387, initialHashVal);
    return Object.keys(obj).sort().reduce((hashVal, key) => {
        hashVal = stringHash(key, hashVal);
        return doHash(obj[key], hashVal);
    }, initialHashVal);
}
function leftRotate(value, bits, totalBits = 32) {
    // delta + bits = totalBits
    const delta = totalBits - bits;
    // All ones, expect `delta` zeros aligned to the right
    const mask = ~((1 << delta) - 1);
    // Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)
    return ((value << bits) | ((mask & value) >>> delta)) >>> 0;
}
function fill(dest, index = 0, count = dest.byteLength, value = 0) {
    for (let i = 0; i < count; i++) {
        dest[index + i] = value;
    }
}
function leftPad(value, length, char = '0') {
    while (value.length < length) {
        value = char + value;
    }
    return value;
}
function toHexString(bufferOrValue, bitsize = 32) {
    if (bufferOrValue instanceof ArrayBuffer) {
        return Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');
    }
    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
}
/**
 * A SHA1 implementation that works with strings and does not allocate.
 */
class StringSHA1 {
    static { this._bigBlock32 = new DataView(new ArrayBuffer(320)); } // 80 * 4 = 320
    constructor() {
        this._h0 = 0x67452301;
        this._h1 = 0xEFCDAB89;
        this._h2 = 0x98BADCFE;
        this._h3 = 0x10325476;
        this._h4 = 0xC3D2E1F0;
        this._buff = new Uint8Array(64 /* SHA1Constant.BLOCK_SIZE */ + 3 /* to fit any utf-8 */);
        this._buffDV = new DataView(this._buff.buffer);
        this._buffLen = 0;
        this._totalLen = 0;
        this._leftoverHighSurrogate = 0;
        this._finished = false;
    }
    update(str) {
        const strLen = str.length;
        if (strLen === 0) {
            return;
        }
        const buff = this._buff;
        let buffLen = this._buffLen;
        let leftoverHighSurrogate = this._leftoverHighSurrogate;
        let charCode;
        let offset;
        if (leftoverHighSurrogate !== 0) {
            charCode = leftoverHighSurrogate;
            offset = -1;
            leftoverHighSurrogate = 0;
        }
        else {
            charCode = str.charCodeAt(0);
            offset = 0;
        }
        while (true) {
            let codePoint = charCode;
            if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isHighSurrogate(charCode)) {
                if (offset + 1 < strLen) {
                    const nextCharCode = str.charCodeAt(offset + 1);
                    if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isLowSurrogate(nextCharCode)) {
                        offset++;
                        codePoint = _strings_js__WEBPACK_IMPORTED_MODULE_0__.computeCodePoint(charCode, nextCharCode);
                    }
                    else {
                        // illegal => unicode replacement character
                        codePoint = 65533 /* SHA1Constant.UNICODE_REPLACEMENT */;
                    }
                }
                else {
                    // last character is a surrogate pair
                    leftoverHighSurrogate = charCode;
                    break;
                }
            }
            else if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isLowSurrogate(charCode)) {
                // illegal => unicode replacement character
                codePoint = 65533 /* SHA1Constant.UNICODE_REPLACEMENT */;
            }
            buffLen = this._push(buff, buffLen, codePoint);
            offset++;
            if (offset < strLen) {
                charCode = str.charCodeAt(offset);
            }
            else {
                break;
            }
        }
        this._buffLen = buffLen;
        this._leftoverHighSurrogate = leftoverHighSurrogate;
    }
    _push(buff, buffLen, codePoint) {
        if (codePoint < 0x0080) {
            buff[buffLen++] = codePoint;
        }
        else if (codePoint < 0x0800) {
            buff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
        else if (codePoint < 0x10000) {
            buff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
        else {
            buff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
        if (buffLen >= 64 /* SHA1Constant.BLOCK_SIZE */) {
            this._step();
            buffLen -= 64 /* SHA1Constant.BLOCK_SIZE */;
            this._totalLen += 64 /* SHA1Constant.BLOCK_SIZE */;
            // take last 3 in case of UTF8 overflow
            buff[0] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 0];
            buff[1] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 1];
            buff[2] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 2];
        }
        return buffLen;
    }
    digest() {
        if (!this._finished) {
            this._finished = true;
            if (this._leftoverHighSurrogate) {
                // illegal => unicode replacement character
                this._leftoverHighSurrogate = 0;
                this._buffLen = this._push(this._buff, this._buffLen, 65533 /* SHA1Constant.UNICODE_REPLACEMENT */);
            }
            this._totalLen += this._buffLen;
            this._wrapUp();
        }
        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
    }
    _wrapUp() {
        this._buff[this._buffLen++] = 0x80;
        fill(this._buff, this._buffLen);
        if (this._buffLen > 56) {
            this._step();
            fill(this._buff);
        }
        // this will fit because the mantissa can cover up to 52 bits
        const ml = 8 * this._totalLen;
        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
        this._buffDV.setUint32(60, ml % 4294967296, false);
        this._step();
    }
    _step() {
        const bigBlock32 = StringSHA1._bigBlock32;
        const data = this._buffDV;
        for (let j = 0; j < 64 /* 16*4 */; j += 4) {
            bigBlock32.setUint32(j, data.getUint32(j, false), false);
        }
        for (let j = 64; j < 320 /* 80*4 */; j += 4) {
            bigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);
        }
        let a = this._h0;
        let b = this._h1;
        let c = this._h2;
        let d = this._h3;
        let e = this._h4;
        let f, k;
        let temp;
        for (let j = 0; j < 80; j++) {
            if (j < 20) {
                f = (b & c) | ((~b) & d);
                k = 0x5A827999;
            }
            else if (j < 40) {
                f = b ^ c ^ d;
                k = 0x6ED9EBA1;
            }
            else if (j < 60) {
                f = (b & c) | (b & d) | (c & d);
                k = 0x8F1BBCDC;
            }
            else {
                f = b ^ c ^ d;
                k = 0xCA62C1D6;
            }
            temp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;
            e = d;
            d = c;
            c = leftRotate(b, 30);
            b = a;
            a = temp;
        }
        this._h0 = (this._h0 + a) & 0xffffffff;
        this._h1 = (this._h1 + b) & 0xffffffff;
        this._h2 = (this._h2 + c) & 0xffffffff;
        this._h3 = (this._h3 + d) & 0xffffffff;
        this._h4 = (this._h4 + e) & 0xffffffff;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/iterator.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Iterable: () => (/* binding */ Iterable)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Iterable;
(function (Iterable) {
    function is(thing) {
        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';
    }
    Iterable.is = is;
    const _empty = Object.freeze([]);
    function empty() {
        return _empty;
    }
    Iterable.empty = empty;
    function* single(element) {
        yield element;
    }
    Iterable.single = single;
    function wrap(iterableOrElement) {
        if (is(iterableOrElement)) {
            return iterableOrElement;
        }
        else {
            return single(iterableOrElement);
        }
    }
    Iterable.wrap = wrap;
    function from(iterable) {
        return iterable || _empty;
    }
    Iterable.from = from;
    function* reverse(array) {
        for (let i = array.length - 1; i >= 0; i--) {
            yield array[i];
        }
    }
    Iterable.reverse = reverse;
    function isEmpty(iterable) {
        return !iterable || iterable[Symbol.iterator]().next().done === true;
    }
    Iterable.isEmpty = isEmpty;
    function first(iterable) {
        return iterable[Symbol.iterator]().next().value;
    }
    Iterable.first = first;
    function some(iterable, predicate) {
        let i = 0;
        for (const element of iterable) {
            if (predicate(element, i++)) {
                return true;
            }
        }
        return false;
    }
    Iterable.some = some;
    function find(iterable, predicate) {
        for (const element of iterable) {
            if (predicate(element)) {
                return element;
            }
        }
        return undefined;
    }
    Iterable.find = find;
    function* filter(iterable, predicate) {
        for (const element of iterable) {
            if (predicate(element)) {
                yield element;
            }
        }
    }
    Iterable.filter = filter;
    function* map(iterable, fn) {
        let index = 0;
        for (const element of iterable) {
            yield fn(element, index++);
        }
    }
    Iterable.map = map;
    function* flatMap(iterable, fn) {
        let index = 0;
        for (const element of iterable) {
            yield* fn(element, index++);
        }
    }
    Iterable.flatMap = flatMap;
    function* concat(...iterables) {
        for (const iterable of iterables) {
            yield* iterable;
        }
    }
    Iterable.concat = concat;
    function reduce(iterable, reducer, initialValue) {
        let value = initialValue;
        for (const element of iterable) {
            value = reducer(value, element);
        }
        return value;
    }
    Iterable.reduce = reduce;
    /**
     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.
     */
    function* slice(arr, from, to = arr.length) {
        if (from < 0) {
            from += arr.length;
        }
        if (to < 0) {
            to += arr.length;
        }
        else if (to > arr.length) {
            to = arr.length;
        }
        for (; from < to; from++) {
            yield arr[from];
        }
    }
    Iterable.slice = slice;
    /**
     * Consumes `atMost` elements from iterable and returns the consumed elements,
     * and an iterable for the rest of the elements.
     */
    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
        const consumed = [];
        if (atMost === 0) {
            return [consumed, iterable];
        }
        const iterator = iterable[Symbol.iterator]();
        for (let i = 0; i < atMost; i++) {
            const next = iterator.next();
            if (next.done) {
                return [consumed, Iterable.empty()];
            }
            consumed.push(next.value);
        }
        return [consumed, { [Symbol.iterator]() { return iterator; } }];
    }
    Iterable.consume = consume;
    async function asyncToArray(iterable) {
        const result = [];
        for await (const item of iterable) {
            result.push(item);
        }
        return Promise.resolve(result);
    }
    Iterable.asyncToArray = asyncToArray;
})(Iterable || (Iterable = {}));


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EVENT_KEY_CODE_MAP: () => (/* binding */ EVENT_KEY_CODE_MAP),
/* harmony export */   IMMUTABLE_CODE_TO_KEY_CODE: () => (/* binding */ IMMUTABLE_CODE_TO_KEY_CODE),
/* harmony export */   IMMUTABLE_KEY_CODE_TO_CODE: () => (/* binding */ IMMUTABLE_KEY_CODE_TO_CODE),
/* harmony export */   KeyChord: () => (/* binding */ KeyChord),
/* harmony export */   KeyCodeUtils: () => (/* binding */ KeyCodeUtils),
/* harmony export */   NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE: () => (/* binding */ NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class KeyCodeStrMap {
    constructor() {
        this._keyCodeToStr = [];
        this._strToKeyCode = Object.create(null);
    }
    define(keyCode, str) {
        this._keyCodeToStr[keyCode] = str;
        this._strToKeyCode[str.toLowerCase()] = keyCode;
    }
    keyCodeToStr(keyCode) {
        return this._keyCodeToStr[keyCode];
    }
    strToKeyCode(str) {
        return this._strToKeyCode[str.toLowerCase()] || 0 /* KeyCode.Unknown */;
    }
}
const uiMap = new KeyCodeStrMap();
const userSettingsUSMap = new KeyCodeStrMap();
const userSettingsGeneralMap = new KeyCodeStrMap();
const EVENT_KEY_CODE_MAP = new Array(230);
const NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
const scanCodeIntToStr = [];
const scanCodeStrToInt = Object.create(null);
const scanCodeLowerCaseStrToInt = Object.create(null);
/**
 * -1 if a ScanCode => KeyCode mapping depends on kb layout.
 */
const IMMUTABLE_CODE_TO_KEY_CODE = [];
/**
 * -1 if a KeyCode => ScanCode mapping depends on kb layout.
 */
const IMMUTABLE_KEY_CODE_TO_CODE = [];
for (let i = 0; i <= 193 /* ScanCode.MAX_VALUE */; i++) {
    IMMUTABLE_CODE_TO_KEY_CODE[i] = -1 /* KeyCode.DependsOnKbLayout */;
}
for (let i = 0; i <= 132 /* KeyCode.MAX_VALUE */; i++) {
    IMMUTABLE_KEY_CODE_TO_CODE[i] = -1 /* ScanCode.DependsOnKbLayout */;
}
(function () {
    // See https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
    // See https://github.com/microsoft/node-native-keymap/blob/88c0b0e5/deps/chromium/keyboard_codes_win.h
    const empty = '';
    const mappings = [
        // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
        [1, 0 /* ScanCode.None */, 'None', 0 /* KeyCode.Unknown */, 'unknown', 0, 'VK_UNKNOWN', empty, empty],
        [1, 1 /* ScanCode.Hyper */, 'Hyper', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 2 /* ScanCode.Super */, 'Super', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 3 /* ScanCode.Fn */, 'Fn', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 4 /* ScanCode.FnLock */, 'FnLock', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 5 /* ScanCode.Suspend */, 'Suspend', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 6 /* ScanCode.Resume */, 'Resume', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 7 /* ScanCode.Turbo */, 'Turbo', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 8 /* ScanCode.Sleep */, 'Sleep', 0 /* KeyCode.Unknown */, empty, 0, 'VK_SLEEP', empty, empty],
        [1, 9 /* ScanCode.WakeUp */, 'WakeUp', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [0, 10 /* ScanCode.KeyA */, 'KeyA', 31 /* KeyCode.KeyA */, 'A', 65, 'VK_A', empty, empty],
        [0, 11 /* ScanCode.KeyB */, 'KeyB', 32 /* KeyCode.KeyB */, 'B', 66, 'VK_B', empty, empty],
        [0, 12 /* ScanCode.KeyC */, 'KeyC', 33 /* KeyCode.KeyC */, 'C', 67, 'VK_C', empty, empty],
        [0, 13 /* ScanCode.KeyD */, 'KeyD', 34 /* KeyCode.KeyD */, 'D', 68, 'VK_D', empty, empty],
        [0, 14 /* ScanCode.KeyE */, 'KeyE', 35 /* KeyCode.KeyE */, 'E', 69, 'VK_E', empty, empty],
        [0, 15 /* ScanCode.KeyF */, 'KeyF', 36 /* KeyCode.KeyF */, 'F', 70, 'VK_F', empty, empty],
        [0, 16 /* ScanCode.KeyG */, 'KeyG', 37 /* KeyCode.KeyG */, 'G', 71, 'VK_G', empty, empty],
        [0, 17 /* ScanCode.KeyH */, 'KeyH', 38 /* KeyCode.KeyH */, 'H', 72, 'VK_H', empty, empty],
        [0, 18 /* ScanCode.KeyI */, 'KeyI', 39 /* KeyCode.KeyI */, 'I', 73, 'VK_I', empty, empty],
        [0, 19 /* ScanCode.KeyJ */, 'KeyJ', 40 /* KeyCode.KeyJ */, 'J', 74, 'VK_J', empty, empty],
        [0, 20 /* ScanCode.KeyK */, 'KeyK', 41 /* KeyCode.KeyK */, 'K', 75, 'VK_K', empty, empty],
        [0, 21 /* ScanCode.KeyL */, 'KeyL', 42 /* KeyCode.KeyL */, 'L', 76, 'VK_L', empty, empty],
        [0, 22 /* ScanCode.KeyM */, 'KeyM', 43 /* KeyCode.KeyM */, 'M', 77, 'VK_M', empty, empty],
        [0, 23 /* ScanCode.KeyN */, 'KeyN', 44 /* KeyCode.KeyN */, 'N', 78, 'VK_N', empty, empty],
        [0, 24 /* ScanCode.KeyO */, 'KeyO', 45 /* KeyCode.KeyO */, 'O', 79, 'VK_O', empty, empty],
        [0, 25 /* ScanCode.KeyP */, 'KeyP', 46 /* KeyCode.KeyP */, 'P', 80, 'VK_P', empty, empty],
        [0, 26 /* ScanCode.KeyQ */, 'KeyQ', 47 /* KeyCode.KeyQ */, 'Q', 81, 'VK_Q', empty, empty],
        [0, 27 /* ScanCode.KeyR */, 'KeyR', 48 /* KeyCode.KeyR */, 'R', 82, 'VK_R', empty, empty],
        [0, 28 /* ScanCode.KeyS */, 'KeyS', 49 /* KeyCode.KeyS */, 'S', 83, 'VK_S', empty, empty],
        [0, 29 /* ScanCode.KeyT */, 'KeyT', 50 /* KeyCode.KeyT */, 'T', 84, 'VK_T', empty, empty],
        [0, 30 /* ScanCode.KeyU */, 'KeyU', 51 /* KeyCode.KeyU */, 'U', 85, 'VK_U', empty, empty],
        [0, 31 /* ScanCode.KeyV */, 'KeyV', 52 /* KeyCode.KeyV */, 'V', 86, 'VK_V', empty, empty],
        [0, 32 /* ScanCode.KeyW */, 'KeyW', 53 /* KeyCode.KeyW */, 'W', 87, 'VK_W', empty, empty],
        [0, 33 /* ScanCode.KeyX */, 'KeyX', 54 /* KeyCode.KeyX */, 'X', 88, 'VK_X', empty, empty],
        [0, 34 /* ScanCode.KeyY */, 'KeyY', 55 /* KeyCode.KeyY */, 'Y', 89, 'VK_Y', empty, empty],
        [0, 35 /* ScanCode.KeyZ */, 'KeyZ', 56 /* KeyCode.KeyZ */, 'Z', 90, 'VK_Z', empty, empty],
        [0, 36 /* ScanCode.Digit1 */, 'Digit1', 22 /* KeyCode.Digit1 */, '1', 49, 'VK_1', empty, empty],
        [0, 37 /* ScanCode.Digit2 */, 'Digit2', 23 /* KeyCode.Digit2 */, '2', 50, 'VK_2', empty, empty],
        [0, 38 /* ScanCode.Digit3 */, 'Digit3', 24 /* KeyCode.Digit3 */, '3', 51, 'VK_3', empty, empty],
        [0, 39 /* ScanCode.Digit4 */, 'Digit4', 25 /* KeyCode.Digit4 */, '4', 52, 'VK_4', empty, empty],
        [0, 40 /* ScanCode.Digit5 */, 'Digit5', 26 /* KeyCode.Digit5 */, '5', 53, 'VK_5', empty, empty],
        [0, 41 /* ScanCode.Digit6 */, 'Digit6', 27 /* KeyCode.Digit6 */, '6', 54, 'VK_6', empty, empty],
        [0, 42 /* ScanCode.Digit7 */, 'Digit7', 28 /* KeyCode.Digit7 */, '7', 55, 'VK_7', empty, empty],
        [0, 43 /* ScanCode.Digit8 */, 'Digit8', 29 /* KeyCode.Digit8 */, '8', 56, 'VK_8', empty, empty],
        [0, 44 /* ScanCode.Digit9 */, 'Digit9', 30 /* KeyCode.Digit9 */, '9', 57, 'VK_9', empty, empty],
        [0, 45 /* ScanCode.Digit0 */, 'Digit0', 21 /* KeyCode.Digit0 */, '0', 48, 'VK_0', empty, empty],
        [1, 46 /* ScanCode.Enter */, 'Enter', 3 /* KeyCode.Enter */, 'Enter', 13, 'VK_RETURN', empty, empty],
        [1, 47 /* ScanCode.Escape */, 'Escape', 9 /* KeyCode.Escape */, 'Escape', 27, 'VK_ESCAPE', empty, empty],
        [1, 48 /* ScanCode.Backspace */, 'Backspace', 1 /* KeyCode.Backspace */, 'Backspace', 8, 'VK_BACK', empty, empty],
        [1, 49 /* ScanCode.Tab */, 'Tab', 2 /* KeyCode.Tab */, 'Tab', 9, 'VK_TAB', empty, empty],
        [1, 50 /* ScanCode.Space */, 'Space', 10 /* KeyCode.Space */, 'Space', 32, 'VK_SPACE', empty, empty],
        [0, 51 /* ScanCode.Minus */, 'Minus', 88 /* KeyCode.Minus */, '-', 189, 'VK_OEM_MINUS', '-', 'OEM_MINUS'],
        [0, 52 /* ScanCode.Equal */, 'Equal', 86 /* KeyCode.Equal */, '=', 187, 'VK_OEM_PLUS', '=', 'OEM_PLUS'],
        [0, 53 /* ScanCode.BracketLeft */, 'BracketLeft', 92 /* KeyCode.BracketLeft */, '[', 219, 'VK_OEM_4', '[', 'OEM_4'],
        [0, 54 /* ScanCode.BracketRight */, 'BracketRight', 94 /* KeyCode.BracketRight */, ']', 221, 'VK_OEM_6', ']', 'OEM_6'],
        [0, 55 /* ScanCode.Backslash */, 'Backslash', 93 /* KeyCode.Backslash */, '\\', 220, 'VK_OEM_5', '\\', 'OEM_5'],
        [0, 56 /* ScanCode.IntlHash */, 'IntlHash', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty], // has been dropped from the w3c spec
        [0, 57 /* ScanCode.Semicolon */, 'Semicolon', 85 /* KeyCode.Semicolon */, ';', 186, 'VK_OEM_1', ';', 'OEM_1'],
        [0, 58 /* ScanCode.Quote */, 'Quote', 95 /* KeyCode.Quote */, '\'', 222, 'VK_OEM_7', '\'', 'OEM_7'],
        [0, 59 /* ScanCode.Backquote */, 'Backquote', 91 /* KeyCode.Backquote */, '`', 192, 'VK_OEM_3', '`', 'OEM_3'],
        [0, 60 /* ScanCode.Comma */, 'Comma', 87 /* KeyCode.Comma */, ',', 188, 'VK_OEM_COMMA', ',', 'OEM_COMMA'],
        [0, 61 /* ScanCode.Period */, 'Period', 89 /* KeyCode.Period */, '.', 190, 'VK_OEM_PERIOD', '.', 'OEM_PERIOD'],
        [0, 62 /* ScanCode.Slash */, 'Slash', 90 /* KeyCode.Slash */, '/', 191, 'VK_OEM_2', '/', 'OEM_2'],
        [1, 63 /* ScanCode.CapsLock */, 'CapsLock', 8 /* KeyCode.CapsLock */, 'CapsLock', 20, 'VK_CAPITAL', empty, empty],
        [1, 64 /* ScanCode.F1 */, 'F1', 59 /* KeyCode.F1 */, 'F1', 112, 'VK_F1', empty, empty],
        [1, 65 /* ScanCode.F2 */, 'F2', 60 /* KeyCode.F2 */, 'F2', 113, 'VK_F2', empty, empty],
        [1, 66 /* ScanCode.F3 */, 'F3', 61 /* KeyCode.F3 */, 'F3', 114, 'VK_F3', empty, empty],
        [1, 67 /* ScanCode.F4 */, 'F4', 62 /* KeyCode.F4 */, 'F4', 115, 'VK_F4', empty, empty],
        [1, 68 /* ScanCode.F5 */, 'F5', 63 /* KeyCode.F5 */, 'F5', 116, 'VK_F5', empty, empty],
        [1, 69 /* ScanCode.F6 */, 'F6', 64 /* KeyCode.F6 */, 'F6', 117, 'VK_F6', empty, empty],
        [1, 70 /* ScanCode.F7 */, 'F7', 65 /* KeyCode.F7 */, 'F7', 118, 'VK_F7', empty, empty],
        [1, 71 /* ScanCode.F8 */, 'F8', 66 /* KeyCode.F8 */, 'F8', 119, 'VK_F8', empty, empty],
        [1, 72 /* ScanCode.F9 */, 'F9', 67 /* KeyCode.F9 */, 'F9', 120, 'VK_F9', empty, empty],
        [1, 73 /* ScanCode.F10 */, 'F10', 68 /* KeyCode.F10 */, 'F10', 121, 'VK_F10', empty, empty],
        [1, 74 /* ScanCode.F11 */, 'F11', 69 /* KeyCode.F11 */, 'F11', 122, 'VK_F11', empty, empty],
        [1, 75 /* ScanCode.F12 */, 'F12', 70 /* KeyCode.F12 */, 'F12', 123, 'VK_F12', empty, empty],
        [1, 76 /* ScanCode.PrintScreen */, 'PrintScreen', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 77 /* ScanCode.ScrollLock */, 'ScrollLock', 84 /* KeyCode.ScrollLock */, 'ScrollLock', 145, 'VK_SCROLL', empty, empty],
        [1, 78 /* ScanCode.Pause */, 'Pause', 7 /* KeyCode.PauseBreak */, 'PauseBreak', 19, 'VK_PAUSE', empty, empty],
        [1, 79 /* ScanCode.Insert */, 'Insert', 19 /* KeyCode.Insert */, 'Insert', 45, 'VK_INSERT', empty, empty],
        [1, 80 /* ScanCode.Home */, 'Home', 14 /* KeyCode.Home */, 'Home', 36, 'VK_HOME', empty, empty],
        [1, 81 /* ScanCode.PageUp */, 'PageUp', 11 /* KeyCode.PageUp */, 'PageUp', 33, 'VK_PRIOR', empty, empty],
        [1, 82 /* ScanCode.Delete */, 'Delete', 20 /* KeyCode.Delete */, 'Delete', 46, 'VK_DELETE', empty, empty],
        [1, 83 /* ScanCode.End */, 'End', 13 /* KeyCode.End */, 'End', 35, 'VK_END', empty, empty],
        [1, 84 /* ScanCode.PageDown */, 'PageDown', 12 /* KeyCode.PageDown */, 'PageDown', 34, 'VK_NEXT', empty, empty],
        [1, 85 /* ScanCode.ArrowRight */, 'ArrowRight', 17 /* KeyCode.RightArrow */, 'RightArrow', 39, 'VK_RIGHT', 'Right', empty],
        [1, 86 /* ScanCode.ArrowLeft */, 'ArrowLeft', 15 /* KeyCode.LeftArrow */, 'LeftArrow', 37, 'VK_LEFT', 'Left', empty],
        [1, 87 /* ScanCode.ArrowDown */, 'ArrowDown', 18 /* KeyCode.DownArrow */, 'DownArrow', 40, 'VK_DOWN', 'Down', empty],
        [1, 88 /* ScanCode.ArrowUp */, 'ArrowUp', 16 /* KeyCode.UpArrow */, 'UpArrow', 38, 'VK_UP', 'Up', empty],
        [1, 89 /* ScanCode.NumLock */, 'NumLock', 83 /* KeyCode.NumLock */, 'NumLock', 144, 'VK_NUMLOCK', empty, empty],
        [1, 90 /* ScanCode.NumpadDivide */, 'NumpadDivide', 113 /* KeyCode.NumpadDivide */, 'NumPad_Divide', 111, 'VK_DIVIDE', empty, empty],
        [1, 91 /* ScanCode.NumpadMultiply */, 'NumpadMultiply', 108 /* KeyCode.NumpadMultiply */, 'NumPad_Multiply', 106, 'VK_MULTIPLY', empty, empty],
        [1, 92 /* ScanCode.NumpadSubtract */, 'NumpadSubtract', 111 /* KeyCode.NumpadSubtract */, 'NumPad_Subtract', 109, 'VK_SUBTRACT', empty, empty],
        [1, 93 /* ScanCode.NumpadAdd */, 'NumpadAdd', 109 /* KeyCode.NumpadAdd */, 'NumPad_Add', 107, 'VK_ADD', empty, empty],
        [1, 94 /* ScanCode.NumpadEnter */, 'NumpadEnter', 3 /* KeyCode.Enter */, empty, 0, empty, empty, empty],
        [1, 95 /* ScanCode.Numpad1 */, 'Numpad1', 99 /* KeyCode.Numpad1 */, 'NumPad1', 97, 'VK_NUMPAD1', empty, empty],
        [1, 96 /* ScanCode.Numpad2 */, 'Numpad2', 100 /* KeyCode.Numpad2 */, 'NumPad2', 98, 'VK_NUMPAD2', empty, empty],
        [1, 97 /* ScanCode.Numpad3 */, 'Numpad3', 101 /* KeyCode.Numpad3 */, 'NumPad3', 99, 'VK_NUMPAD3', empty, empty],
        [1, 98 /* ScanCode.Numpad4 */, 'Numpad4', 102 /* KeyCode.Numpad4 */, 'NumPad4', 100, 'VK_NUMPAD4', empty, empty],
        [1, 99 /* ScanCode.Numpad5 */, 'Numpad5', 103 /* KeyCode.Numpad5 */, 'NumPad5', 101, 'VK_NUMPAD5', empty, empty],
        [1, 100 /* ScanCode.Numpad6 */, 'Numpad6', 104 /* KeyCode.Numpad6 */, 'NumPad6', 102, 'VK_NUMPAD6', empty, empty],
        [1, 101 /* ScanCode.Numpad7 */, 'Numpad7', 105 /* KeyCode.Numpad7 */, 'NumPad7', 103, 'VK_NUMPAD7', empty, empty],
        [1, 102 /* ScanCode.Numpad8 */, 'Numpad8', 106 /* KeyCode.Numpad8 */, 'NumPad8', 104, 'VK_NUMPAD8', empty, empty],
        [1, 103 /* ScanCode.Numpad9 */, 'Numpad9', 107 /* KeyCode.Numpad9 */, 'NumPad9', 105, 'VK_NUMPAD9', empty, empty],
        [1, 104 /* ScanCode.Numpad0 */, 'Numpad0', 98 /* KeyCode.Numpad0 */, 'NumPad0', 96, 'VK_NUMPAD0', empty, empty],
        [1, 105 /* ScanCode.NumpadDecimal */, 'NumpadDecimal', 112 /* KeyCode.NumpadDecimal */, 'NumPad_Decimal', 110, 'VK_DECIMAL', empty, empty],
        [0, 106 /* ScanCode.IntlBackslash */, 'IntlBackslash', 97 /* KeyCode.IntlBackslash */, 'OEM_102', 226, 'VK_OEM_102', empty, empty],
        [1, 107 /* ScanCode.ContextMenu */, 'ContextMenu', 58 /* KeyCode.ContextMenu */, 'ContextMenu', 93, empty, empty, empty],
        [1, 108 /* ScanCode.Power */, 'Power', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 109 /* ScanCode.NumpadEqual */, 'NumpadEqual', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 110 /* ScanCode.F13 */, 'F13', 71 /* KeyCode.F13 */, 'F13', 124, 'VK_F13', empty, empty],
        [1, 111 /* ScanCode.F14 */, 'F14', 72 /* KeyCode.F14 */, 'F14', 125, 'VK_F14', empty, empty],
        [1, 112 /* ScanCode.F15 */, 'F15', 73 /* KeyCode.F15 */, 'F15', 126, 'VK_F15', empty, empty],
        [1, 113 /* ScanCode.F16 */, 'F16', 74 /* KeyCode.F16 */, 'F16', 127, 'VK_F16', empty, empty],
        [1, 114 /* ScanCode.F17 */, 'F17', 75 /* KeyCode.F17 */, 'F17', 128, 'VK_F17', empty, empty],
        [1, 115 /* ScanCode.F18 */, 'F18', 76 /* KeyCode.F18 */, 'F18', 129, 'VK_F18', empty, empty],
        [1, 116 /* ScanCode.F19 */, 'F19', 77 /* KeyCode.F19 */, 'F19', 130, 'VK_F19', empty, empty],
        [1, 117 /* ScanCode.F20 */, 'F20', 78 /* KeyCode.F20 */, 'F20', 131, 'VK_F20', empty, empty],
        [1, 118 /* ScanCode.F21 */, 'F21', 79 /* KeyCode.F21 */, 'F21', 132, 'VK_F21', empty, empty],
        [1, 119 /* ScanCode.F22 */, 'F22', 80 /* KeyCode.F22 */, 'F22', 133, 'VK_F22', empty, empty],
        [1, 120 /* ScanCode.F23 */, 'F23', 81 /* KeyCode.F23 */, 'F23', 134, 'VK_F23', empty, empty],
        [1, 121 /* ScanCode.F24 */, 'F24', 82 /* KeyCode.F24 */, 'F24', 135, 'VK_F24', empty, empty],
        [1, 122 /* ScanCode.Open */, 'Open', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 123 /* ScanCode.Help */, 'Help', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 124 /* ScanCode.Select */, 'Select', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 125 /* ScanCode.Again */, 'Again', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 126 /* ScanCode.Undo */, 'Undo', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 127 /* ScanCode.Cut */, 'Cut', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 128 /* ScanCode.Copy */, 'Copy', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 129 /* ScanCode.Paste */, 'Paste', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 130 /* ScanCode.Find */, 'Find', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 131 /* ScanCode.AudioVolumeMute */, 'AudioVolumeMute', 117 /* KeyCode.AudioVolumeMute */, 'AudioVolumeMute', 173, 'VK_VOLUME_MUTE', empty, empty],
        [1, 132 /* ScanCode.AudioVolumeUp */, 'AudioVolumeUp', 118 /* KeyCode.AudioVolumeUp */, 'AudioVolumeUp', 175, 'VK_VOLUME_UP', empty, empty],
        [1, 133 /* ScanCode.AudioVolumeDown */, 'AudioVolumeDown', 119 /* KeyCode.AudioVolumeDown */, 'AudioVolumeDown', 174, 'VK_VOLUME_DOWN', empty, empty],
        [1, 134 /* ScanCode.NumpadComma */, 'NumpadComma', 110 /* KeyCode.NUMPAD_SEPARATOR */, 'NumPad_Separator', 108, 'VK_SEPARATOR', empty, empty],
        [0, 135 /* ScanCode.IntlRo */, 'IntlRo', 115 /* KeyCode.ABNT_C1 */, 'ABNT_C1', 193, 'VK_ABNT_C1', empty, empty],
        [1, 136 /* ScanCode.KanaMode */, 'KanaMode', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [0, 137 /* ScanCode.IntlYen */, 'IntlYen', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 138 /* ScanCode.Convert */, 'Convert', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 139 /* ScanCode.NonConvert */, 'NonConvert', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 140 /* ScanCode.Lang1 */, 'Lang1', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 141 /* ScanCode.Lang2 */, 'Lang2', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 142 /* ScanCode.Lang3 */, 'Lang3', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 143 /* ScanCode.Lang4 */, 'Lang4', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 144 /* ScanCode.Lang5 */, 'Lang5', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 145 /* ScanCode.Abort */, 'Abort', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 146 /* ScanCode.Props */, 'Props', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 147 /* ScanCode.NumpadParenLeft */, 'NumpadParenLeft', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 148 /* ScanCode.NumpadParenRight */, 'NumpadParenRight', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 149 /* ScanCode.NumpadBackspace */, 'NumpadBackspace', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 150 /* ScanCode.NumpadMemoryStore */, 'NumpadMemoryStore', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 151 /* ScanCode.NumpadMemoryRecall */, 'NumpadMemoryRecall', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 152 /* ScanCode.NumpadMemoryClear */, 'NumpadMemoryClear', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 153 /* ScanCode.NumpadMemoryAdd */, 'NumpadMemoryAdd', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 154 /* ScanCode.NumpadMemorySubtract */, 'NumpadMemorySubtract', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 155 /* ScanCode.NumpadClear */, 'NumpadClear', 131 /* KeyCode.Clear */, 'Clear', 12, 'VK_CLEAR', empty, empty],
        [1, 156 /* ScanCode.NumpadClearEntry */, 'NumpadClearEntry', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 0 /* ScanCode.None */, empty, 5 /* KeyCode.Ctrl */, 'Ctrl', 17, 'VK_CONTROL', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 4 /* KeyCode.Shift */, 'Shift', 16, 'VK_SHIFT', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 6 /* KeyCode.Alt */, 'Alt', 18, 'VK_MENU', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 57 /* KeyCode.Meta */, 'Meta', 91, 'VK_COMMAND', empty, empty],
        [1, 157 /* ScanCode.ControlLeft */, 'ControlLeft', 5 /* KeyCode.Ctrl */, empty, 0, 'VK_LCONTROL', empty, empty],
        [1, 158 /* ScanCode.ShiftLeft */, 'ShiftLeft', 4 /* KeyCode.Shift */, empty, 0, 'VK_LSHIFT', empty, empty],
        [1, 159 /* ScanCode.AltLeft */, 'AltLeft', 6 /* KeyCode.Alt */, empty, 0, 'VK_LMENU', empty, empty],
        [1, 160 /* ScanCode.MetaLeft */, 'MetaLeft', 57 /* KeyCode.Meta */, empty, 0, 'VK_LWIN', empty, empty],
        [1, 161 /* ScanCode.ControlRight */, 'ControlRight', 5 /* KeyCode.Ctrl */, empty, 0, 'VK_RCONTROL', empty, empty],
        [1, 162 /* ScanCode.ShiftRight */, 'ShiftRight', 4 /* KeyCode.Shift */, empty, 0, 'VK_RSHIFT', empty, empty],
        [1, 163 /* ScanCode.AltRight */, 'AltRight', 6 /* KeyCode.Alt */, empty, 0, 'VK_RMENU', empty, empty],
        [1, 164 /* ScanCode.MetaRight */, 'MetaRight', 57 /* KeyCode.Meta */, empty, 0, 'VK_RWIN', empty, empty],
        [1, 165 /* ScanCode.BrightnessUp */, 'BrightnessUp', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 166 /* ScanCode.BrightnessDown */, 'BrightnessDown', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 167 /* ScanCode.MediaPlay */, 'MediaPlay', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 168 /* ScanCode.MediaRecord */, 'MediaRecord', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 169 /* ScanCode.MediaFastForward */, 'MediaFastForward', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 170 /* ScanCode.MediaRewind */, 'MediaRewind', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 171 /* ScanCode.MediaTrackNext */, 'MediaTrackNext', 124 /* KeyCode.MediaTrackNext */, 'MediaTrackNext', 176, 'VK_MEDIA_NEXT_TRACK', empty, empty],
        [1, 172 /* ScanCode.MediaTrackPrevious */, 'MediaTrackPrevious', 125 /* KeyCode.MediaTrackPrevious */, 'MediaTrackPrevious', 177, 'VK_MEDIA_PREV_TRACK', empty, empty],
        [1, 173 /* ScanCode.MediaStop */, 'MediaStop', 126 /* KeyCode.MediaStop */, 'MediaStop', 178, 'VK_MEDIA_STOP', empty, empty],
        [1, 174 /* ScanCode.Eject */, 'Eject', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 175 /* ScanCode.MediaPlayPause */, 'MediaPlayPause', 127 /* KeyCode.MediaPlayPause */, 'MediaPlayPause', 179, 'VK_MEDIA_PLAY_PAUSE', empty, empty],
        [1, 176 /* ScanCode.MediaSelect */, 'MediaSelect', 128 /* KeyCode.LaunchMediaPlayer */, 'LaunchMediaPlayer', 181, 'VK_MEDIA_LAUNCH_MEDIA_SELECT', empty, empty],
        [1, 177 /* ScanCode.LaunchMail */, 'LaunchMail', 129 /* KeyCode.LaunchMail */, 'LaunchMail', 180, 'VK_MEDIA_LAUNCH_MAIL', empty, empty],
        [1, 178 /* ScanCode.LaunchApp2 */, 'LaunchApp2', 130 /* KeyCode.LaunchApp2 */, 'LaunchApp2', 183, 'VK_MEDIA_LAUNCH_APP2', empty, empty],
        [1, 179 /* ScanCode.LaunchApp1 */, 'LaunchApp1', 0 /* KeyCode.Unknown */, empty, 0, 'VK_MEDIA_LAUNCH_APP1', empty, empty],
        [1, 180 /* ScanCode.SelectTask */, 'SelectTask', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 181 /* ScanCode.LaunchScreenSaver */, 'LaunchScreenSaver', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 182 /* ScanCode.BrowserSearch */, 'BrowserSearch', 120 /* KeyCode.BrowserSearch */, 'BrowserSearch', 170, 'VK_BROWSER_SEARCH', empty, empty],
        [1, 183 /* ScanCode.BrowserHome */, 'BrowserHome', 121 /* KeyCode.BrowserHome */, 'BrowserHome', 172, 'VK_BROWSER_HOME', empty, empty],
        [1, 184 /* ScanCode.BrowserBack */, 'BrowserBack', 122 /* KeyCode.BrowserBack */, 'BrowserBack', 166, 'VK_BROWSER_BACK', empty, empty],
        [1, 185 /* ScanCode.BrowserForward */, 'BrowserForward', 123 /* KeyCode.BrowserForward */, 'BrowserForward', 167, 'VK_BROWSER_FORWARD', empty, empty],
        [1, 186 /* ScanCode.BrowserStop */, 'BrowserStop', 0 /* KeyCode.Unknown */, empty, 0, 'VK_BROWSER_STOP', empty, empty],
        [1, 187 /* ScanCode.BrowserRefresh */, 'BrowserRefresh', 0 /* KeyCode.Unknown */, empty, 0, 'VK_BROWSER_REFRESH', empty, empty],
        [1, 188 /* ScanCode.BrowserFavorites */, 'BrowserFavorites', 0 /* KeyCode.Unknown */, empty, 0, 'VK_BROWSER_FAVORITES', empty, empty],
        [1, 189 /* ScanCode.ZoomToggle */, 'ZoomToggle', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 190 /* ScanCode.MailReply */, 'MailReply', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 191 /* ScanCode.MailForward */, 'MailForward', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        [1, 192 /* ScanCode.MailSend */, 'MailSend', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],
        // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
        // If an Input Method Editor is processing key input and the event is keydown, return 229.
        [1, 0 /* ScanCode.None */, empty, 114 /* KeyCode.KEY_IN_COMPOSITION */, 'KeyInComposition', 229, empty, empty, empty],
        [1, 0 /* ScanCode.None */, empty, 116 /* KeyCode.ABNT_C2 */, 'ABNT_C2', 194, 'VK_ABNT_C2', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 96 /* KeyCode.OEM_8 */, 'OEM_8', 223, 'VK_OEM_8', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_KANA', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_HANGUL', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_JUNJA', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_FINAL', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_HANJA', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_KANJI', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_CONVERT', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_NONCONVERT', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_ACCEPT', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_MODECHANGE', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_SELECT', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PRINT', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_EXECUTE', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_SNAPSHOT', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_HELP', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_APPS', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PROCESSKEY', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PACKET', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_DBE_SBCSCHAR', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_DBE_DBCSCHAR', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_ATTN', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_CRSEL', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_EXSEL', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_EREOF', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PLAY', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_ZOOM', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_NONAME', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PA1', empty, empty],
        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_OEM_CLEAR', empty, empty],
    ];
    const seenKeyCode = [];
    const seenScanCode = [];
    for (const mapping of mappings) {
        const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
        if (!seenScanCode[scanCode]) {
            seenScanCode[scanCode] = true;
            scanCodeIntToStr[scanCode] = scanCodeStr;
            scanCodeStrToInt[scanCodeStr] = scanCode;
            scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
            if (immutable) {
                IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
                if ((keyCode !== 0 /* KeyCode.Unknown */)
                    && (keyCode !== 3 /* KeyCode.Enter */)
                    && (keyCode !== 5 /* KeyCode.Ctrl */)
                    && (keyCode !== 4 /* KeyCode.Shift */)
                    && (keyCode !== 6 /* KeyCode.Alt */)
                    && (keyCode !== 57 /* KeyCode.Meta */)) {
                    IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
                }
            }
        }
        if (!seenKeyCode[keyCode]) {
            seenKeyCode[keyCode] = true;
            if (!keyCodeStr) {
                throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
            }
            uiMap.define(keyCode, keyCodeStr);
            userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
            userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
        }
        if (eventKeyCode) {
            EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
        }
        if (vkey) {
            NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
        }
    }
    // Manually added due to the exclusion above (due to duplication with NumpadEnter)
    IMMUTABLE_KEY_CODE_TO_CODE[3 /* KeyCode.Enter */] = 46 /* ScanCode.Enter */;
})();
var KeyCodeUtils;
(function (KeyCodeUtils) {
    function toString(keyCode) {
        return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toString = toString;
    function fromString(key) {
        return uiMap.strToKeyCode(key);
    }
    KeyCodeUtils.fromString = fromString;
    function toUserSettingsUS(keyCode) {
        return userSettingsUSMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;
    function toUserSettingsGeneral(keyCode) {
        return userSettingsGeneralMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;
    function fromUserSettings(key) {
        return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
    }
    KeyCodeUtils.fromUserSettings = fromUserSettings;
    function toElectronAccelerator(keyCode) {
        if (keyCode >= 98 /* KeyCode.Numpad0 */ && keyCode <= 113 /* KeyCode.NumpadDivide */) {
            // [Electron Accelerators] Electron is able to parse numpad keys, but unfortunately it
            // renders them just as regular keys in menus. For example, num0 is rendered as "0",
            // numdiv is rendered as "/", numsub is rendered as "-".
            //
            // This can lead to incredible confusion, as it makes numpad based keybindings indistinguishable
            // from keybindings based on regular keys.
            //
            // We therefore need to fall back to custom rendering for numpad keys.
            return null;
        }
        switch (keyCode) {
            case 16 /* KeyCode.UpArrow */:
                return 'Up';
            case 18 /* KeyCode.DownArrow */:
                return 'Down';
            case 15 /* KeyCode.LeftArrow */:
                return 'Left';
            case 17 /* KeyCode.RightArrow */:
                return 'Right';
        }
        return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toElectronAccelerator = toElectronAccelerator;
})(KeyCodeUtils || (KeyCodeUtils = {}));
function KeyChord(firstPart, secondPart) {
    const chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;
    return (firstPart | chordPart) >>> 0;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/lazy.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/lazy.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Lazy: () => (/* binding */ Lazy)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class Lazy {
    constructor(executor) {
        this.executor = executor;
        this._didRun = false;
    }
    /**
     * Get the wrapped value.
     *
     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
     */
    get value() {
        if (!this._didRun) {
            try {
                this._value = this.executor();
            }
            catch (err) {
                this._error = err;
            }
            finally {
                this._didRun = true;
            }
        }
        if (this._error) {
            throw this._error;
        }
        return this._value;
    }
    /**
     * Get the wrapped value without forcing evaluation.
     */
    get rawValue() { return this._value; }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js":
/*!********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Disposable: () => (/* binding */ Disposable),
/* harmony export */   DisposableMap: () => (/* binding */ DisposableMap),
/* harmony export */   DisposableStore: () => (/* binding */ DisposableStore),
/* harmony export */   ImmortalReference: () => (/* binding */ ImmortalReference),
/* harmony export */   MutableDisposable: () => (/* binding */ MutableDisposable),
/* harmony export */   RefCountedDisposable: () => (/* binding */ RefCountedDisposable),
/* harmony export */   combinedDisposable: () => (/* binding */ combinedDisposable),
/* harmony export */   dispose: () => (/* binding */ dispose),
/* harmony export */   isDisposable: () => (/* binding */ isDisposable),
/* harmony export */   markAsDisposed: () => (/* binding */ markAsDisposed),
/* harmony export */   markAsSingleton: () => (/* binding */ markAsSingleton),
/* harmony export */   setDisposableTracker: () => (/* binding */ setDisposableTracker),
/* harmony export */   toDisposable: () => (/* binding */ toDisposable),
/* harmony export */   trackDisposable: () => (/* binding */ trackDisposable)
/* harmony export */ });
/* harmony import */ var _functional_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functional.js */ "./node_modules/monaco-editor/esm/vs/base/common/functional.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/monaco-editor/esm/vs/base/common/iterator.js");


// #region Disposable Tracking
/**
 * Enables logging of potentially leaked disposables.
 *
 * A disposable is considered leaked if it is not disposed or not registered as the child of
 * another disposable. This tracking is very simple an only works for classes that either
 * extend Disposable or use a DisposableStore. This means there are a lot of false positives.
 */
const TRACK_DISPOSABLES = false;
let disposableTracker = null;
function setDisposableTracker(tracker) {
    disposableTracker = tracker;
}
if (TRACK_DISPOSABLES) {
    const __is_disposable_tracked__ = '__is_disposable_tracked__';
    setDisposableTracker(new class {
        trackDisposable(x) {
            const stack = new Error('Potentially leaked disposable').stack;
            setTimeout(() => {
                if (!x[__is_disposable_tracked__]) {
                    console.log(stack);
                }
            }, 3000);
        }
        setParent(child, parent) {
            if (child && child !== Disposable.None) {
                try {
                    child[__is_disposable_tracked__] = true;
                }
                catch {
                    // noop
                }
            }
        }
        markAsDisposed(disposable) {
            if (disposable && disposable !== Disposable.None) {
                try {
                    disposable[__is_disposable_tracked__] = true;
                }
                catch {
                    // noop
                }
            }
        }
        markAsSingleton(disposable) { }
    });
}
function trackDisposable(x) {
    disposableTracker?.trackDisposable(x);
    return x;
}
function markAsDisposed(disposable) {
    disposableTracker?.markAsDisposed(disposable);
}
function setParentOfDisposable(child, parent) {
    disposableTracker?.setParent(child, parent);
}
function setParentOfDisposables(children, parent) {
    if (!disposableTracker) {
        return;
    }
    for (const child of children) {
        disposableTracker.setParent(child, parent);
    }
}
/**
 * Indicates that the given object is a singleton which does not need to be disposed.
*/
function markAsSingleton(singleton) {
    disposableTracker?.markAsSingleton(singleton);
    return singleton;
}
/**
 * Check if `thing` is {@link IDisposable disposable}.
 */
function isDisposable(thing) {
    return typeof thing === 'object' && thing !== null && typeof thing.dispose === 'function' && thing.dispose.length === 0;
}
function dispose(arg) {
    if (_iterator_js__WEBPACK_IMPORTED_MODULE_1__.Iterable.is(arg)) {
        const errors = [];
        for (const d of arg) {
            if (d) {
                try {
                    d.dispose();
                }
                catch (e) {
                    errors.push(e);
                }
            }
        }
        if (errors.length === 1) {
            throw errors[0];
        }
        else if (errors.length > 1) {
            throw new AggregateError(errors, 'Encountered errors while disposing of store');
        }
        return Array.isArray(arg) ? [] : arg;
    }
    else if (arg) {
        arg.dispose();
        return arg;
    }
}
/**
 * Combine multiple disposable values into a single {@link IDisposable}.
 */
function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
}
/**
 * Turn a function that implements dispose into an {@link IDisposable}.
 *
 * @param fn Clean up function, guaranteed to be called only **once**.
 */
function toDisposable(fn) {
    const self = trackDisposable({
        dispose: (0,_functional_js__WEBPACK_IMPORTED_MODULE_0__.createSingleCallFunction)(() => {
            markAsDisposed(self);
            fn();
        })
    });
    return self;
}
/**
 * Manages a collection of disposable values.
 *
 * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an
 * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a
 * store that has already been disposed of.
 */
class DisposableStore {
    static { this.DISABLE_DISPOSED_WARNING = false; }
    constructor() {
        this._toDispose = new Set();
        this._isDisposed = false;
        trackDisposable(this);
    }
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        markAsDisposed(this);
        this._isDisposed = true;
        this.clear();
    }
    /**
     * @return `true` if this object has been disposed of.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear() {
        if (this._toDispose.size === 0) {
            return;
        }
        try {
            dispose(this._toDispose);
        }
        finally {
            this._toDispose.clear();
        }
    }
    /**
     * Add a new {@link IDisposable disposable} to the collection.
     */
    add(o) {
        if (!o) {
            return o;
        }
        if (o === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        setParentOfDisposable(o, this);
        if (this._isDisposed) {
            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {
                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);
            }
        }
        else {
            this._toDispose.add(o);
        }
        return o;
    }
    /**
     * Deletes the value from the store, but does not dispose it.
     */
    deleteAndLeak(o) {
        if (!o) {
            return;
        }
        if (this._toDispose.has(o)) {
            this._toDispose.delete(o);
            setParentOfDisposable(o, null);
        }
    }
}
/**
 * Abstract base class for a {@link IDisposable disposable} object.
 *
 * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.
 */
class Disposable {
    /**
     * A disposable that does nothing when it is disposed of.
     *
     * TODO: This should not be a static property.
     */
    static { this.None = Object.freeze({ dispose() { } }); }
    constructor() {
        this._store = new DisposableStore();
        trackDisposable(this);
        setParentOfDisposable(this._store, this);
    }
    dispose() {
        markAsDisposed(this);
        this._store.dispose();
    }
    /**
     * Adds `o` to the collection of disposables managed by this object.
     */
    _register(o) {
        if (o === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        return this._store.add(o);
    }
}
/**
 * Manages the lifecycle of a disposable value that may be changed.
 *
 * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can
 * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.
 */
class MutableDisposable {
    constructor() {
        this._isDisposed = false;
        trackDisposable(this);
    }
    get value() {
        return this._isDisposed ? undefined : this._value;
    }
    set value(value) {
        if (this._isDisposed || value === this._value) {
            return;
        }
        this._value?.dispose();
        if (value) {
            setParentOfDisposable(value, this);
        }
        this._value = value;
    }
    /**
     * Resets the stored value and disposed of the previously stored value.
     */
    clear() {
        this.value = undefined;
    }
    dispose() {
        this._isDisposed = true;
        markAsDisposed(this);
        this._value?.dispose();
        this._value = undefined;
    }
}
class RefCountedDisposable {
    constructor(_disposable) {
        this._disposable = _disposable;
        this._counter = 1;
    }
    acquire() {
        this._counter++;
        return this;
    }
    release() {
        if (--this._counter === 0) {
            this._disposable.dispose();
        }
        return this;
    }
}
class ImmortalReference {
    constructor(object) {
        this.object = object;
    }
    dispose() { }
}
/**
 * A map the manages the lifecycle of the values that it stores.
 */
class DisposableMap {
    constructor() {
        this._store = new Map();
        this._isDisposed = false;
        trackDisposable(this);
    }
    /**
     * Disposes of all stored values and mark this object as disposed.
     *
     * Trying to use this object after it has been disposed of is an error.
     */
    dispose() {
        markAsDisposed(this);
        this._isDisposed = true;
        this.clearAndDisposeAll();
    }
    /**
     * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.
     */
    clearAndDisposeAll() {
        if (!this._store.size) {
            return;
        }
        try {
            dispose(this._store.values());
        }
        finally {
            this._store.clear();
        }
    }
    get(key) {
        return this._store.get(key);
    }
    set(key, value, skipDisposeOnOverwrite = false) {
        if (this._isDisposed) {
            console.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);
        }
        if (!skipDisposeOnOverwrite) {
            this._store.get(key)?.dispose();
        }
        this._store.set(key, value);
    }
    /**
     * Delete the value stored for `key` from this map and also dispose of it.
     */
    deleteAndDispose(key) {
        this._store.get(key)?.dispose();
        this._store.delete(key);
    }
    [Symbol.iterator]() {
        return this._store[Symbol.iterator]();
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/linkedList.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/linkedList.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinkedList: () => (/* binding */ LinkedList)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class Node {
    static { this.Undefined = new Node(undefined); }
    constructor(element) {
        this.element = element;
        this.next = Node.Undefined;
        this.prev = Node.Undefined;
    }
}
class LinkedList {
    constructor() {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
    }
    get size() {
        return this._size;
    }
    isEmpty() {
        return this._first === Node.Undefined;
    }
    clear() {
        let node = this._first;
        while (node !== Node.Undefined) {
            const next = node.next;
            node.prev = Node.Undefined;
            node.next = Node.Undefined;
            node = next;
        }
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
    }
    unshift(element) {
        return this._insert(element, false);
    }
    push(element) {
        return this._insert(element, true);
    }
    _insert(element, atTheEnd) {
        const newNode = new Node(element);
        if (this._first === Node.Undefined) {
            this._first = newNode;
            this._last = newNode;
        }
        else if (atTheEnd) {
            // push
            const oldLast = this._last;
            this._last = newNode;
            newNode.prev = oldLast;
            oldLast.next = newNode;
        }
        else {
            // unshift
            const oldFirst = this._first;
            this._first = newNode;
            newNode.next = oldFirst;
            oldFirst.prev = newNode;
        }
        this._size += 1;
        let didRemove = false;
        return () => {
            if (!didRemove) {
                didRemove = true;
                this._remove(newNode);
            }
        };
    }
    shift() {
        if (this._first === Node.Undefined) {
            return undefined;
        }
        else {
            const res = this._first.element;
            this._remove(this._first);
            return res;
        }
    }
    pop() {
        if (this._last === Node.Undefined) {
            return undefined;
        }
        else {
            const res = this._last.element;
            this._remove(this._last);
            return res;
        }
    }
    _remove(node) {
        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
            // middle
            const anchor = node.prev;
            anchor.next = node.next;
            node.next.prev = anchor;
        }
        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
            // only node
            this._first = Node.Undefined;
            this._last = Node.Undefined;
        }
        else if (node.next === Node.Undefined) {
            // last
            this._last = this._last.prev;
            this._last.next = Node.Undefined;
        }
        else if (node.prev === Node.Undefined) {
            // first
            this._first = this._first.next;
            this._first.prev = Node.Undefined;
        }
        // done
        this._size -= 1;
    }
    *[Symbol.iterator]() {
        let node = this._first;
        while (node !== Node.Undefined) {
            yield node.element;
            node = node.next;
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/map.js":
/*!**************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/map.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidirectionalMap: () => (/* binding */ BidirectionalMap),
/* harmony export */   LRUCache: () => (/* binding */ LRUCache),
/* harmony export */   LinkedMap: () => (/* binding */ LinkedMap),
/* harmony export */   ResourceMap: () => (/* binding */ ResourceMap),
/* harmony export */   SetMap: () => (/* binding */ SetMap)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a, _b;
class ResourceMapEntry {
    constructor(uri, value) {
        this.uri = uri;
        this.value = value;
    }
}
function isEntries(arg) {
    return Array.isArray(arg);
}
class ResourceMap {
    static { this.defaultToKey = (resource) => resource.toString(); }
    constructor(arg, toKey) {
        this[_a] = 'ResourceMap';
        if (arg instanceof ResourceMap) {
            this.map = new Map(arg.map);
            this.toKey = toKey ?? ResourceMap.defaultToKey;
        }
        else if (isEntries(arg)) {
            this.map = new Map();
            this.toKey = toKey ?? ResourceMap.defaultToKey;
            for (const [resource, value] of arg) {
                this.set(resource, value);
            }
        }
        else {
            this.map = new Map();
            this.toKey = arg ?? ResourceMap.defaultToKey;
        }
    }
    set(resource, value) {
        this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));
        return this;
    }
    get(resource) {
        return this.map.get(this.toKey(resource))?.value;
    }
    has(resource) {
        return this.map.has(this.toKey(resource));
    }
    get size() {
        return this.map.size;
    }
    clear() {
        this.map.clear();
    }
    delete(resource) {
        return this.map.delete(this.toKey(resource));
    }
    forEach(clb, thisArg) {
        if (typeof thisArg !== 'undefined') {
            clb = clb.bind(thisArg);
        }
        for (const [_, entry] of this.map) {
            clb(entry.value, entry.uri, this);
        }
    }
    *values() {
        for (const entry of this.map.values()) {
            yield entry.value;
        }
    }
    *keys() {
        for (const entry of this.map.values()) {
            yield entry.uri;
        }
    }
    *entries() {
        for (const entry of this.map.values()) {
            yield [entry.uri, entry.value];
        }
    }
    *[(_a = Symbol.toStringTag, Symbol.iterator)]() {
        for (const [, entry] of this.map) {
            yield [entry.uri, entry.value];
        }
    }
}
class LinkedMap {
    constructor() {
        this[_b] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        return this._head?.value;
    }
    get last() {
        return this._tail?.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = 0 /* Touch.None */) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== 0 /* Touch.None */) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = 0 /* Touch.None */) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== 0 /* Touch.None */) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case 0 /* Touch.None */:
                    this.addItemLast(item);
                    break;
                case 1 /* Touch.AsOld */:
                    this.addItemFirst(item);
                    break;
                case 2 /* Touch.AsNew */:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [(_b = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    trimNew(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._tail;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.previous;
            currentSize--;
        }
        this._tail = current;
        this._size = currentSize;
        if (current) {
            current.next = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happen if size === 1 which is handled
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happen if size === 1 which is handled
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== 1 /* Touch.AsOld */ && touch !== 2 /* Touch.AsNew */)) {
            return;
        }
        if (touch === 1 /* Touch.AsOld */) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === 2 /* Touch.AsNew */) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
class Cache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get(key, touch = 2 /* Touch.AsNew */) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, 0 /* Touch.None */);
    }
    set(key, value) {
        super.set(key, value, 2 /* Touch.AsNew */);
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trim(Math.round(this._limit * this._ratio));
        }
    }
}
class LRUCache extends Cache {
    constructor(limit, ratio = 1) {
        super(limit, ratio);
    }
    trim(newSize) {
        this.trimOld(newSize);
    }
    set(key, value) {
        super.set(key, value);
        this.checkTrim();
        return this;
    }
}
/**
 * A map that allows access both by keys and values.
 * **NOTE**: values need to be unique.
 */
class BidirectionalMap {
    constructor(entries) {
        this._m1 = new Map();
        this._m2 = new Map();
        if (entries) {
            for (const [key, value] of entries) {
                this.set(key, value);
            }
        }
    }
    clear() {
        this._m1.clear();
        this._m2.clear();
    }
    set(key, value) {
        this._m1.set(key, value);
        this._m2.set(value, key);
    }
    get(key) {
        return this._m1.get(key);
    }
    getKey(value) {
        return this._m2.get(value);
    }
    delete(key) {
        const value = this._m1.get(key);
        if (value === undefined) {
            return false;
        }
        this._m1.delete(key);
        this._m2.delete(value);
        return true;
    }
    keys() {
        return this._m1.keys();
    }
    values() {
        return this._m1.values();
    }
}
class SetMap {
    constructor() {
        this.map = new Map();
    }
    add(key, value) {
        let values = this.map.get(key);
        if (!values) {
            values = new Set();
            this.map.set(key, values);
        }
        values.add(value);
    }
    delete(key, value) {
        const values = this.map.get(key);
        if (!values) {
            return;
        }
        values.delete(value);
        if (values.size === 0) {
            this.map.delete(key);
        }
    }
    forEach(key, fn) {
        const values = this.map.get(key);
        if (!values) {
            return;
        }
        values.forEach(fn);
    }
    get(key) {
        const values = this.map.get(key);
        if (!values) {
            return new Set();
        }
        return values;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/network.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/network.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COI: () => (/* binding */ COI),
/* harmony export */   FileAccess: () => (/* binding */ FileAccess),
/* harmony export */   RemoteAuthorities: () => (/* binding */ RemoteAuthorities),
/* harmony export */   Schemas: () => (/* binding */ Schemas),
/* harmony export */   VSCODE_AUTHORITY: () => (/* binding */ VSCODE_AUTHORITY),
/* harmony export */   connectionTokenQueryName: () => (/* binding */ connectionTokenQueryName),
/* harmony export */   matchesScheme: () => (/* binding */ matchesScheme),
/* harmony export */   matchesSomeScheme: () => (/* binding */ matchesSomeScheme)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uri.js */ "./node_modules/monaco-editor/esm/vs/base/common/uri.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./path.js */ "./node_modules/monaco-editor/esm/vs/base/common/path.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





var Schemas;
(function (Schemas) {
    /**
     * A schema that is used for models that exist in memory
     * only and that have no correspondence on a server or such.
     */
    Schemas.inMemory = 'inmemory';
    /**
     * A schema that is used for setting files
     */
    Schemas.vscode = 'vscode';
    /**
     * A schema that is used for internal private files
     */
    Schemas.internal = 'private';
    /**
     * A walk-through document.
     */
    Schemas.walkThrough = 'walkThrough';
    /**
     * An embedded code snippet.
     */
    Schemas.walkThroughSnippet = 'walkThroughSnippet';
    Schemas.http = 'http';
    Schemas.https = 'https';
    Schemas.file = 'file';
    Schemas.mailto = 'mailto';
    Schemas.untitled = 'untitled';
    Schemas.data = 'data';
    Schemas.command = 'command';
    Schemas.vscodeRemote = 'vscode-remote';
    Schemas.vscodeRemoteResource = 'vscode-remote-resource';
    Schemas.vscodeManagedRemoteResource = 'vscode-managed-remote-resource';
    Schemas.vscodeUserData = 'vscode-userdata';
    Schemas.vscodeCustomEditor = 'vscode-custom-editor';
    Schemas.vscodeNotebookCell = 'vscode-notebook-cell';
    Schemas.vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';
    Schemas.vscodeNotebookCellMetadataDiff = 'vscode-notebook-cell-metadata-diff';
    Schemas.vscodeNotebookCellOutput = 'vscode-notebook-cell-output';
    Schemas.vscodeNotebookCellOutputDiff = 'vscode-notebook-cell-output-diff';
    Schemas.vscodeNotebookMetadata = 'vscode-notebook-metadata';
    Schemas.vscodeInteractiveInput = 'vscode-interactive-input';
    Schemas.vscodeSettings = 'vscode-settings';
    Schemas.vscodeWorkspaceTrust = 'vscode-workspace-trust';
    Schemas.vscodeTerminal = 'vscode-terminal';
    /** Scheme used for code blocks in chat. */
    Schemas.vscodeChatCodeBlock = 'vscode-chat-code-block';
    /** Scheme used for LHS of code compare (aka diff) blocks in chat. */
    Schemas.vscodeChatCodeCompareBlock = 'vscode-chat-code-compare-block';
    /** Scheme used for the chat input editor. */
    Schemas.vscodeChatSesssion = 'vscode-chat-editor';
    /**
     * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)
     */
    Schemas.webviewPanel = 'webview-panel';
    /**
     * Scheme used for loading the wrapper html and script in webviews.
     */
    Schemas.vscodeWebview = 'vscode-webview';
    /**
     * Scheme used for extension pages
     */
    Schemas.extension = 'extension';
    /**
     * Scheme used as a replacement of `file` scheme to load
     * files with our custom protocol handler (desktop only).
     */
    Schemas.vscodeFileResource = 'vscode-file';
    /**
     * Scheme used for temporary resources
     */
    Schemas.tmp = 'tmp';
    /**
     * Scheme used vs live share
     */
    Schemas.vsls = 'vsls';
    /**
     * Scheme used for the Source Control commit input's text document
     */
    Schemas.vscodeSourceControl = 'vscode-scm';
    /**
     * Scheme used for input box for creating comments.
     */
    Schemas.commentsInput = 'comment';
    /**
     * Scheme used for special rendering of settings in the release notes
     */
    Schemas.codeSetting = 'code-setting';
    /**
     * Scheme used for output panel resources
     */
    Schemas.outputChannel = 'output';
})(Schemas || (Schemas = {}));
function matchesScheme(target, scheme) {
    if (_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.isUri(target)) {
        return (0,_strings_js__WEBPACK_IMPORTED_MODULE_2__.equalsIgnoreCase)(target.scheme, scheme);
    }
    else {
        return (0,_strings_js__WEBPACK_IMPORTED_MODULE_2__.startsWithIgnoreCase)(target, scheme + ':');
    }
}
function matchesSomeScheme(target, ...schemes) {
    return schemes.some(scheme => matchesScheme(target, scheme));
}
const connectionTokenQueryName = 'tkn';
class RemoteAuthoritiesImpl {
    constructor() {
        this._hosts = Object.create(null);
        this._ports = Object.create(null);
        this._connectionTokens = Object.create(null);
        this._preferredWebSchema = 'http';
        this._delegate = null;
        this._serverRootPath = '/';
    }
    setPreferredWebSchema(schema) {
        this._preferredWebSchema = schema;
    }
    get _remoteResourcesPath() {
        return _path_js__WEBPACK_IMPORTED_MODULE_4__.posix.join(this._serverRootPath, Schemas.vscodeRemoteResource);
    }
    rewrite(uri) {
        if (this._delegate) {
            try {
                return this._delegate(uri);
            }
            catch (err) {
                _errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError(err);
                return uri;
            }
        }
        const authority = uri.authority;
        let host = this._hosts[authority];
        if (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {
            host = `[${host}]`;
        }
        const port = this._ports[authority];
        const connectionToken = this._connectionTokens[authority];
        let query = `path=${encodeURIComponent(uri.path)}`;
        if (typeof connectionToken === 'string') {
            query += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;
        }
        return _uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.from({
            scheme: _platform_js__WEBPACK_IMPORTED_MODULE_1__.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,
            authority: `${host}:${port}`,
            path: this._remoteResourcesPath,
            query
        });
    }
}
const RemoteAuthorities = new RemoteAuthoritiesImpl();
const VSCODE_AUTHORITY = 'vscode-app';
class FileAccessImpl {
    static { this.FALLBACK_AUTHORITY = VSCODE_AUTHORITY; }
    /**
     * Returns a URI to use in contexts where the browser is responsible
     * for loading (e.g. fetch()) or when used within the DOM.
     *
     * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
     */
    asBrowserUri(resourcePath) {
        // ESM-comment-begin
        // 		const uri = this.toUri(resourcePath, require);
        // ESM-comment-end
        // ESM-uncomment-begin
        const uri = this.toUri(resourcePath);
        // ESM-uncomment-end
        return this.uriToBrowserUri(uri);
    }
    /**
     * Returns a URI to use in contexts where the browser is responsible
     * for loading (e.g. fetch()) or when used within the DOM.
     *
     * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
     */
    uriToBrowserUri(uri) {
        // Handle remote URIs via `RemoteAuthorities`
        if (uri.scheme === Schemas.vscodeRemote) {
            return RemoteAuthorities.rewrite(uri);
        }
        // Convert to `vscode-file` resource..
        if (
        // ...only ever for `file` resources
        uri.scheme === Schemas.file &&
            (
            // ...and we run in native environments
            _platform_js__WEBPACK_IMPORTED_MODULE_1__.isNative ||
                // ...or web worker extensions on desktop
                (_platform_js__WEBPACK_IMPORTED_MODULE_1__.webWorkerOrigin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`))) {
            return uri.with({
                scheme: Schemas.vscodeFileResource,
                // We need to provide an authority here so that it can serve
                // as origin for network and loading matters in chromium.
                // If the URI is not coming with an authority already, we
                // add our own
                authority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,
                query: null,
                fragment: null
            });
        }
        return uri;
    }
    toUri(uriOrModule, moduleIdToUrl) {
        if (_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.isUri(uriOrModule)) {
            return uriOrModule;
        }
        if (globalThis._VSCODE_FILE_ROOT) {
            const rootUriOrPath = globalThis._VSCODE_FILE_ROOT;
            // File URL (with scheme)
            if (/^\w[\w\d+.-]*:\/\//.test(rootUriOrPath)) {
                return _uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.joinPath(_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.parse(rootUriOrPath, true), uriOrModule);
            }
            // File Path (no scheme)
            const modulePath = _path_js__WEBPACK_IMPORTED_MODULE_4__.join(rootUriOrPath, uriOrModule);
            return _uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.file(modulePath);
        }
        return _uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.parse(moduleIdToUrl.toUrl(uriOrModule));
    }
}
const FileAccess = new FileAccessImpl();
var COI;
(function (COI) {
    const coiHeaders = new Map([
        ['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],
        ['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],
        ['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],
    ]);
    COI.CoopAndCoep = Object.freeze(coiHeaders.get('3'));
    const coiSearchParamName = 'vscode-coi';
    /**
     * Extract desired headers from `vscode-coi` invocation
     */
    function getHeadersFromQuery(url) {
        let params;
        if (typeof url === 'string') {
            params = new URL(url).searchParams;
        }
        else if (url instanceof URL) {
            params = url.searchParams;
        }
        else if (_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.isUri(url)) {
            params = new URL(url.toString(true)).searchParams;
        }
        const value = params?.get(coiSearchParamName);
        if (!value) {
            return undefined;
        }
        return coiHeaders.get(value);
    }
    COI.getHeadersFromQuery = getHeadersFromQuery;
    /**
     * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`
     * isn't enabled the current context
     */
    function addSearchParam(urlOrSearch, coop, coep) {
        if (!globalThis.crossOriginIsolated) {
            // depends on the current context being COI
            return;
        }
        const value = coop && coep ? '3' : coep ? '2' : '1';
        if (urlOrSearch instanceof URLSearchParams) {
            urlOrSearch.set(coiSearchParamName, value);
        }
        else {
            urlOrSearch[coiSearchParamName] = value;
        }
    }
    COI.addSearchParam = addSearchParam;
})(COI || (COI = {}));


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/objects.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/objects.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cloneAndChange: () => (/* binding */ cloneAndChange),
/* harmony export */   createProxyObject: () => (/* binding */ createProxyObject),
/* harmony export */   deepClone: () => (/* binding */ deepClone),
/* harmony export */   deepFreeze: () => (/* binding */ deepFreeze),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   getAllMethodNames: () => (/* binding */ getAllMethodNames),
/* harmony export */   getAllPropertyNames: () => (/* binding */ getAllPropertyNames),
/* harmony export */   mixin: () => (/* binding */ mixin)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/monaco-editor/esm/vs/base/common/types.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

function deepClone(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    if (obj instanceof RegExp) {
        return obj;
    }
    const result = Array.isArray(obj) ? [] : {};
    Object.entries(obj).forEach(([key, value]) => {
        result[key] = value && typeof value === 'object' ? deepClone(value) : value;
    });
    return result;
}
function deepFreeze(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    const stack = [obj];
    while (stack.length > 0) {
        const obj = stack.shift();
        Object.freeze(obj);
        for (const key in obj) {
            if (_hasOwnProperty.call(obj, key)) {
                const prop = obj[key];
                if (typeof prop === 'object' && !Object.isFrozen(prop) && !(0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isTypedArray)(prop)) {
                    stack.push(prop);
                }
            }
        }
    }
    return obj;
}
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function cloneAndChange(obj, changer) {
    return _cloneAndChange(obj, changer, new Set());
}
function _cloneAndChange(obj, changer, seen) {
    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isUndefinedOrNull)(obj)) {
        return obj;
    }
    const changed = changer(obj);
    if (typeof changed !== 'undefined') {
        return changed;
    }
    if (Array.isArray(obj)) {
        const r1 = [];
        for (const e of obj) {
            r1.push(_cloneAndChange(e, changer, seen));
        }
        return r1;
    }
    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(obj)) {
        if (seen.has(obj)) {
            throw new Error('Cannot clone recursive data-structure');
        }
        seen.add(obj);
        const r2 = {};
        for (const i2 in obj) {
            if (_hasOwnProperty.call(obj, i2)) {
                r2[i2] = _cloneAndChange(obj[i2], changer, seen);
            }
        }
        seen.delete(obj);
        return r2;
    }
    return obj;
}
/**
 * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
 * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
 */
function mixin(destination, source, overwrite = true) {
    if (!(0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(destination)) {
        return source;
    }
    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source)) {
        Object.keys(source).forEach(key => {
            if (key in destination) {
                if (overwrite) {
                    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(destination[key]) && (0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source[key])) {
                        mixin(destination[key], source[key], overwrite);
                    }
                    else {
                        destination[key] = source[key];
                    }
                }
            }
            else {
                destination[key] = source[key];
            }
        });
    }
    return destination;
}
function equals(one, other) {
    if (one === other) {
        return true;
    }
    if (one === null || one === undefined || other === null || other === undefined) {
        return false;
    }
    if (typeof one !== typeof other) {
        return false;
    }
    if (typeof one !== 'object') {
        return false;
    }
    if ((Array.isArray(one)) !== (Array.isArray(other))) {
        return false;
    }
    let i;
    let key;
    if (Array.isArray(one)) {
        if (one.length !== other.length) {
            return false;
        }
        for (i = 0; i < one.length; i++) {
            if (!equals(one[i], other[i])) {
                return false;
            }
        }
    }
    else {
        const oneKeys = [];
        for (key in one) {
            oneKeys.push(key);
        }
        oneKeys.sort();
        const otherKeys = [];
        for (key in other) {
            otherKeys.push(key);
        }
        otherKeys.sort();
        if (!equals(oneKeys, otherKeys)) {
            return false;
        }
        for (i = 0; i < oneKeys.length; i++) {
            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                return false;
            }
        }
    }
    return true;
}
function getAllPropertyNames(obj) {
    let res = [];
    while (Object.prototype !== obj) {
        res = res.concat(Object.getOwnPropertyNames(obj));
        obj = Object.getPrototypeOf(obj);
    }
    return res;
}
function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
        if (typeof obj[prop] === 'function') {
            methods.push(prop);
        }
    }
    return methods;
}
function createProxyObject(methodNames, invoke) {
    const createProxyMethod = (method) => {
        return function () {
            const args = Array.prototype.slice.call(arguments, 0);
            return invoke(method, args);
        };
    };
    const result = {};
    for (const methodName of methodNames) {
        result[methodName] = createProxyMethod(methodName);
    }
    return result;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/path.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/path.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basename: () => (/* binding */ basename),
/* harmony export */   dirname: () => (/* binding */ dirname),
/* harmony export */   extname: () => (/* binding */ extname),
/* harmony export */   join: () => (/* binding */ join),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   posix: () => (/* binding */ posix),
/* harmony export */   relative: () => (/* binding */ relative),
/* harmony export */   resolve: () => (/* binding */ resolve),
/* harmony export */   sep: () => (/* binding */ sep),
/* harmony export */   win32: () => (/* binding */ win32)
/* harmony export */ });
/* harmony import */ var _process_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./process.js */ "./node_modules/monaco-editor/esm/vs/base/common/process.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace
// Copied from: https://github.com/nodejs/node/commits/v20.9.0/lib/path.js
// Excluding: the change that adds primordials
// (https://github.com/nodejs/node/commit/187a862d221dec42fa9a5c4214e7034d9092792f and others)
/**
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

const CHAR_UPPERCASE_A = 65; /* A */
const CHAR_LOWERCASE_A = 97; /* a */
const CHAR_UPPERCASE_Z = 90; /* Z */
const CHAR_LOWERCASE_Z = 122; /* z */
const CHAR_DOT = 46; /* . */
const CHAR_FORWARD_SLASH = 47; /* / */
const CHAR_BACKWARD_SLASH = 92; /* \ */
const CHAR_COLON = 58; /* : */
const CHAR_QUESTION_MARK = 63; /* ? */
class ErrorInvalidArgType extends Error {
    constructor(name, expected, actual) {
        // determiner: 'must be' or 'must not be'
        let determiner;
        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {
            determiner = 'must not be';
            expected = expected.replace(/^not /, '');
        }
        else {
            determiner = 'must be';
        }
        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';
        let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
        msg += `. Received type ${typeof actual}`;
        super(msg);
        this.code = 'ERR_INVALID_ARG_TYPE';
    }
}
function validateObject(pathObject, name) {
    if (pathObject === null || typeof pathObject !== 'object') {
        throw new ErrorInvalidArgType(name, 'Object', pathObject);
    }
}
function validateString(value, name) {
    if (typeof value !== 'string') {
        throw new ErrorInvalidArgType(name, 'string', value);
    }
}
const platformIsWin32 = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32');
function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}
function isPosixPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH;
}
function isWindowsDeviceRoot(code) {
    return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||
        (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);
}
// Resolves . and .. elements in a path with directory names
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = '';
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = 0;
    for (let i = 0; i <= path.length; ++i) {
        if (i < path.length) {
            code = path.charCodeAt(i);
        }
        else if (isPathSeparator(code)) {
            break;
        }
        else {
            code = CHAR_FORWARD_SLASH;
        }
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {
                // NOOP
            }
            else if (dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 ||
                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||
                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = '';
                            lastSegmentLength = 0;
                        }
                        else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                    else if (res.length !== 0) {
                        res = '';
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    res += res.length > 0 ? `${separator}..` : '..';
                    lastSegmentLength = 2;
                }
            }
            else {
                if (res.length > 0) {
                    res += `${separator}${path.slice(lastSlash + 1, i)}`;
                }
                else {
                    res = path.slice(lastSlash + 1, i);
                }
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        }
        else if (code === CHAR_DOT && dots !== -1) {
            ++dots;
        }
        else {
            dots = -1;
        }
    }
    return res;
}
function formatExt(ext) {
    return ext ? `${ext[0] === '.' ? '' : '.'}${ext}` : '';
}
function _format(sep, pathObject) {
    validateObject(pathObject, 'pathObject');
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base ||
        `${pathObject.name || ''}${formatExt(pathObject.ext)}`;
    if (!dir) {
        return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;
}
const win32 = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
        let resolvedDevice = '';
        let resolvedTail = '';
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
                path = pathSegments[i];
                validateString(path, `paths[${i}]`);
                // Skip empty entries
                if (path.length === 0) {
                    continue;
                }
            }
            else if (resolvedDevice.length === 0) {
                path = _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();
            }
            else {
                // Windows has the concept of drive-specific current working
                // directories. If we've resolved a drive letter but not yet an
                // absolute path, get cwd for that drive, or the process cwd if
                // the drive cwd is not available. We're sure the device is not
                // a UNC path at this points, because UNC paths are always absolute.
                path = _process_js__WEBPACK_IMPORTED_MODULE_0__.env[`=${resolvedDevice}`] || _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();
                // Verify that a cwd was found and that it actually points
                // to our drive. If not, default to the drive's root.
                if (path === undefined ||
                    (path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&
                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {
                    path = `${resolvedDevice}\\`;
                }
            }
            const len = path.length;
            let rootEnd = 0;
            let device = '';
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            // Try to match a root
            if (len === 1) {
                if (isPathSeparator(code)) {
                    // `path` contains just a path separator
                    rootEnd = 1;
                    isAbsolute = true;
                }
            }
            else if (isPathSeparator(code)) {
                // Possible UNC root
                // If we started with a separator, we know we at least have an
                // absolute path of some kind (UNC or otherwise)
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        while (j < len && isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                                j++;
                            }
                            if (j === len || j !== last) {
                                // We matched a UNC root
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                }
                else {
                    rootEnd = 1;
                }
            }
            else if (isWindowsDeviceRoot(code) &&
                path.charCodeAt(1) === CHAR_COLON) {
                // Possible device root
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
                    // Treat separator following drive name as an absolute path
                    // indicator
                    isAbsolute = true;
                    rootEnd = 3;
                }
            }
            if (device.length > 0) {
                if (resolvedDevice.length > 0) {
                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                        // This path points to another device so it is not applicable
                        continue;
                    }
                }
                else {
                    resolvedDevice = device;
                }
            }
            if (resolvedAbsolute) {
                if (resolvedDevice.length > 0) {
                    break;
                }
            }
            else {
                resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
                resolvedAbsolute = isAbsolute;
                if (isAbsolute && resolvedDevice.length > 0) {
                    break;
                }
            }
        }
        // At this point the path should be resolved to a full absolute path,
        // but handle relative paths to be safe (might happen when process.cwd()
        // fails)
        // Normalize the tail path
        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\', isPathSeparator);
        return resolvedAbsolute ?
            `${resolvedDevice}\\${resolvedTail}` :
            `${resolvedDevice}${resolvedTail}` || '.';
    },
    normalize(path) {
        validateString(path, 'path');
        const len = path.length;
        if (len === 0) {
            return '.';
        }
        let rootEnd = 0;
        let device;
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        // Try to match a root
        if (len === 1) {
            // `path` contains just a single char, exit early to avoid
            // unnecessary work
            return isPosixPathSeparator(code) ? '\\' : path;
        }
        if (isPathSeparator(code)) {
            // Possible UNC root
            // If we started with a separator, we know we at least have an absolute
            // path of some kind (UNC or otherwise)
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                // Matched double path separator at beginning
                let j = 2;
                let last = j;
                // Match 1 or more non-path separators
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    // Matched!
                    last = j;
                    // Match 1 or more path separators
                    while (j < len && isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more non-path separators
                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j === len) {
                            // We matched a UNC root only
                            // Return the normalized version of the UNC root since there
                            // is nothing left to process
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        }
                        if (j !== last) {
                            // We matched a UNC root with leftovers
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            }
            else {
                rootEnd = 1;
            }
        }
        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            // Possible device root
            device = path.slice(0, 2);
            rootEnd = 2;
            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
                // Treat separator following drive name as an absolute path
                // indicator
                isAbsolute = true;
                rootEnd = 3;
            }
        }
        let tail = rootEnd < len ?
            normalizeString(path.slice(rootEnd), !isAbsolute, '\\', isPathSeparator) :
            '';
        if (tail.length === 0 && !isAbsolute) {
            tail = '.';
        }
        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
            tail += '\\';
        }
        if (device === undefined) {
            return isAbsolute ? `\\${tail}` : tail;
        }
        return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`;
    },
    isAbsolute(path) {
        validateString(path, 'path');
        const len = path.length;
        if (len === 0) {
            return false;
        }
        const code = path.charCodeAt(0);
        return isPathSeparator(code) ||
            // Possible device root
            (len > 2 &&
                isWindowsDeviceRoot(code) &&
                path.charCodeAt(1) === CHAR_COLON &&
                isPathSeparator(path.charCodeAt(2)));
    },
    join(...paths) {
        if (paths.length === 0) {
            return '.';
        }
        let joined;
        let firstPart;
        for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, 'path');
            if (arg.length > 0) {
                if (joined === undefined) {
                    joined = firstPart = arg;
                }
                else {
                    joined += `\\${arg}`;
                }
            }
        }
        if (joined === undefined) {
            return '.';
        }
        // Make sure that the joined path doesn't start with two slashes, because
        // normalize() will mistake it for a UNC path then.
        //
        // This step is skipped when it is very clear that the user actually
        // intended to point at a UNC path. This is assumed when the first
        // non-empty string arguments starts with exactly two slashes followed by
        // at least one more non-slash character.
        //
        // Note that for normalize() to treat a path as a UNC path it needs to
        // have at least 2 components, so we don't filter for that here.
        // This means that the user can use join to construct UNC paths from
        // a server name and a share name; for example:
        //   path.join('//server', 'share') -> '\\\\server\\share\\')
        let needsReplace = true;
        let slashCount = 0;
        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) {
                        ++slashCount;
                    }
                    else {
                        // We matched a UNC path in the first part
                        needsReplace = false;
                    }
                }
            }
        }
        if (needsReplace) {
            // Find any more consecutive slashes we need to replace
            while (slashCount < joined.length &&
                isPathSeparator(joined.charCodeAt(slashCount))) {
                slashCount++;
            }
            // Replace the slashes if needed
            if (slashCount >= 2) {
                joined = `\\${joined.slice(slashCount)}`;
            }
        }
        return win32.normalize(joined);
    },
    // It will solve the relative path from `from` to `to`, for instance:
    //  from = 'C:\\orandea\\test\\aaa'
    //  to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    relative(from, to) {
        validateString(from, 'from');
        validateString(to, 'to');
        if (from === to) {
            return '';
        }
        const fromOrig = win32.resolve(from);
        const toOrig = win32.resolve(to);
        if (fromOrig === toOrig) {
            return '';
        }
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to) {
            return '';
        }
        // Trim any leading backslashes
        let fromStart = 0;
        while (fromStart < from.length &&
            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
            fromStart++;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        let fromEnd = from.length;
        while (fromEnd - 1 > fromStart &&
            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
            fromEnd--;
        }
        const fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        let toStart = 0;
        while (toStart < to.length &&
            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            toStart++;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        let toEnd = to.length;
        while (toEnd - 1 > toStart &&
            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
            toEnd--;
        }
        const toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
                break;
            }
            else if (fromCode === CHAR_BACKWARD_SLASH) {
                lastCommonSep = i;
            }
        }
        // We found a mismatch before the first common path separator was seen, so
        // return the original `to`.
        if (i !== length) {
            if (lastCommonSep === -1) {
                return toOrig;
            }
        }
        else {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
                    // We get here if `from` is the exact base path for `to`.
                    // For example: from='C:\\foo\\bar'; to='C:\\foo\\bar\\baz'
                    return toOrig.slice(toStart + i + 1);
                }
                if (i === 2) {
                    // We get here if `from` is the device root.
                    // For example: from='C:\\'; to='C:\\foo'
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
                    // We get here if `to` is the exact base path for `from`.
                    // For example: from='C:\\foo\\bar'; to='C:\\foo'
                    lastCommonSep = i;
                }
                else if (i === 2) {
                    // We get here if `to` is the device root.
                    // For example: from='C:\\foo\\bar'; to='C:\\'
                    lastCommonSep = 3;
                }
            }
            if (lastCommonSep === -1) {
                lastCommonSep = 0;
            }
        }
        let out = '';
        // Generate the relative path based on the path difference between `to` and
        // `from`
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
                out += out.length === 0 ? '..' : '\\..';
            }
        }
        toStart += lastCommonSep;
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) {
            return `${out}${toOrig.slice(toStart, toEnd)}`;
        }
        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            ++toStart;
        }
        return toOrig.slice(toStart, toEnd);
    },
    toNamespacedPath(path) {
        // Note: this will *probably* throw somewhere.
        if (typeof path !== 'string' || path.length === 0) {
            return path;
        }
        const resolvedPath = win32.resolve(path);
        if (resolvedPath.length <= 2) {
            return path;
        }
        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
            // Possible UNC root
            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
                    // Matched non-long UNC root, convert the path to a long UNC path
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        }
        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&
            resolvedPath.charCodeAt(1) === CHAR_COLON &&
            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            // Matched device root, convert the path to a long UNC path
            return `\\\\?\\${resolvedPath}`;
        }
        return path;
    },
    dirname(path) {
        validateString(path, 'path');
        const len = path.length;
        if (len === 0) {
            return '.';
        }
        let rootEnd = -1;
        let offset = 0;
        const code = path.charCodeAt(0);
        if (len === 1) {
            // `path` contains just a path separator, exit early to avoid
            // unnecessary work or a dot.
            return isPathSeparator(code) ? path : '.';
        }
        // Try to match a root
        if (isPathSeparator(code)) {
            // Possible UNC root
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                // Matched double path separator at beginning
                let j = 2;
                let last = j;
                // Match 1 or more non-path separators
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                }
                if (j < len && j !== last) {
                    // Matched!
                    last = j;
                    // Match 1 or more path separators
                    while (j < len && isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more non-path separators
                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j === len) {
                            // We matched a UNC root only
                            return path;
                        }
                        if (j !== last) {
                            // We matched a UNC root with leftovers
                            // Offset by 1 to include the separator after the UNC root to
                            // treat it as a "normal root" on top of a (UNC) root
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
            // Possible device root
        }
        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
            offset = rootEnd;
        }
        let end = -1;
        let matchedSlash = true;
        for (let i = len - 1; i >= offset; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1) {
            if (rootEnd === -1) {
                return '.';
            }
            end = rootEnd;
        }
        return path.slice(0, end);
    },
    basename(path, suffix) {
        if (suffix !== undefined) {
            validateString(suffix, 'suffix');
        }
        validateString(path, 'path');
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2 &&
            isWindowsDeviceRoot(path.charCodeAt(0)) &&
            path.charCodeAt(1) === CHAR_COLON) {
            start = 2;
        }
        if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
            if (suffix === path) {
                return '';
            }
            let extIdx = suffix.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
                const code = path.charCodeAt(i);
                if (isPathSeparator(code)) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === suffix.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) {
                end = firstNonSlashEnd;
            }
            else if (end === -1) {
                end = path.length;
            }
            return path.slice(start, end);
        }
        for (i = path.length - 1; i >= start; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            }
            else if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // path component
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) {
            return '';
        }
        return path.slice(start, end);
    },
    extname(path) {
        validateString(path, 'path');
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2 &&
            path.charCodeAt(1) === CHAR_COLON &&
            isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 &&
                startDot === end - 1 &&
                startDot === startPart + 1)) {
            return '';
        }
        return path.slice(startDot, end);
    },
    format: _format.bind(null, '\\'),
    parse(path) {
        validateString(path, 'path');
        const ret = { root: '', dir: '', base: '', ext: '', name: '' };
        if (path.length === 0) {
            return ret;
        }
        const len = path.length;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        if (len === 1) {
            if (isPathSeparator(code)) {
                // `path` contains just a path separator, exit early to avoid
                // unnecessary work
                ret.root = ret.dir = path;
                return ret;
            }
            ret.base = ret.name = path;
            return ret;
        }
        // Try to match a root
        if (isPathSeparator(code)) {
            // Possible UNC root
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                // Matched double path separator at beginning
                let j = 2;
                let last = j;
                // Match 1 or more non-path separators
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                }
                if (j < len && j !== last) {
                    // Matched!
                    last = j;
                    // Match 1 or more path separators
                    while (j < len && isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more non-path separators
                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j === len) {
                            // We matched a UNC root only
                            rootEnd = j;
                        }
                        else if (j !== last) {
                            // We matched a UNC root with leftovers
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        }
        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            // Possible device root
            if (len <= 2) {
                // `path` contains just a drive root, exit early to avoid
                // unnecessary work
                ret.root = ret.dir = path;
                return ret;
            }
            rootEnd = 2;
            if (isPathSeparator(path.charCodeAt(2))) {
                if (len === 3) {
                    // `path` contains just a drive root, exit early to avoid
                    // unnecessary work
                    ret.root = ret.dir = path;
                    return ret;
                }
                rootEnd = 3;
            }
        }
        if (rootEnd > 0) {
            ret.root = path.slice(0, rootEnd);
        }
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (end !== -1) {
            if (startDot === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)) {
                ret.base = ret.name = path.slice(startPart, end);
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
                ret.ext = path.slice(startDot, end);
            }
        }
        // If the directory is the root, use the entire root as the `dir` including
        // the trailing slash if any (`C:\abc` -> `C:\`). Otherwise, strip out the
        // trailing slash (`C:\abc\def` -> `C:\abc`).
        if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else {
            ret.dir = ret.root;
        }
        return ret;
    },
    sep: '\\',
    delimiter: ';',
    win32: null,
    posix: null
};
const posixCwd = (() => {
    if (platformIsWin32) {
        // Converts Windows' backslash path separators to POSIX forward slashes
        // and truncates any drive indicator
        const regexp = /\\/g;
        return () => {
            const cwd = _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd().replace(regexp, '/');
            return cwd.slice(cwd.indexOf('/'));
        };
    }
    // We're already on POSIX, no need for any transformations
    return () => _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();
})();
const posix = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
        let resolvedPath = '';
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            const path = i >= 0 ? pathSegments[i] : posixCwd();
            validateString(path, `paths[${i}]`);
            // Skip empty entries
            if (path.length === 0) {
                continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);
        if (resolvedAbsolute) {
            return `/${resolvedPath}`;
        }
        return resolvedPath.length > 0 ? resolvedPath : '.';
    },
    normalize(path) {
        validateString(path, 'path');
        if (path.length === 0) {
            return '.';
        }
        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
        // Normalize the path
        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);
        if (path.length === 0) {
            if (isAbsolute) {
                return '/';
            }
            return trailingSeparator ? './' : '.';
        }
        if (trailingSeparator) {
            path += '/';
        }
        return isAbsolute ? `/${path}` : path;
    },
    isAbsolute(path) {
        validateString(path, 'path');
        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    },
    join(...paths) {
        if (paths.length === 0) {
            return '.';
        }
        let joined;
        for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, 'path');
            if (arg.length > 0) {
                if (joined === undefined) {
                    joined = arg;
                }
                else {
                    joined += `/${arg}`;
                }
            }
        }
        if (joined === undefined) {
            return '.';
        }
        return posix.normalize(joined);
    },
    relative(from, to) {
        validateString(from, 'from');
        validateString(to, 'to');
        if (from === to) {
            return '';
        }
        // Trim leading forward slashes.
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) {
            return '';
        }
        const fromStart = 1;
        const fromEnd = from.length;
        const fromLen = fromEnd - fromStart;
        const toStart = 1;
        const toLen = to.length - toStart;
        // Compare paths to find the longest common path from root
        const length = (fromLen < toLen ? fromLen : toLen);
        let lastCommonSep = -1;
        let i = 0;
        for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
                break;
            }
            else if (fromCode === CHAR_FORWARD_SLASH) {
                lastCommonSep = i;
            }
        }
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
                    // We get here if `from` is the exact base path for `to`.
                    // For example: from='/foo/bar'; to='/foo/bar/baz'
                    return to.slice(toStart + i + 1);
                }
                if (i === 0) {
                    // We get here if `from` is the root
                    // For example: from='/'; to='/foo'
                    return to.slice(toStart + i);
                }
            }
            else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
                    // We get here if `to` is the exact base path for `from`.
                    // For example: from='/foo/bar/baz'; to='/foo/bar'
                    lastCommonSep = i;
                }
                else if (i === 0) {
                    // We get here if `to` is the root.
                    // For example: from='/foo/bar'; to='/'
                    lastCommonSep = 0;
                }
            }
        }
        let out = '';
        // Generate the relative path based on the path difference between `to`
        // and `from`.
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                out += out.length === 0 ? '..' : '/..';
            }
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts.
        return `${out}${to.slice(toStart + lastCommonSep)}`;
    },
    toNamespacedPath(path) {
        // Non-op on posix systems
        return path;
    },
    dirname(path) {
        validateString(path, 'path');
        if (path.length === 0) {
            return '.';
        }
        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1) {
            return hasRoot ? '/' : '.';
        }
        if (hasRoot && end === 1) {
            return '//';
        }
        return path.slice(0, end);
    },
    basename(path, suffix) {
        if (suffix !== undefined) {
            validateString(suffix, 'ext');
        }
        validateString(path, 'path');
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
            if (suffix === path) {
                return '';
            }
            let extIdx = suffix.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
                const code = path.charCodeAt(i);
                if (code === CHAR_FORWARD_SLASH) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === suffix.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) {
                end = firstNonSlashEnd;
            }
            else if (end === -1) {
                end = path.length;
            }
            return path.slice(start, end);
        }
        for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            }
            else if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // path component
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) {
            return '';
        }
        return path.slice(start, end);
    },
    extname(path) {
        validateString(path, 'path');
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 &&
                startDot === end - 1 &&
                startDot === startPart + 1)) {
            return '';
        }
        return path.slice(startDot, end);
    },
    format: _format.bind(null, '/'),
    parse(path) {
        validateString(path, 'path');
        const ret = { root: '', dir: '', base: '', ext: '', name: '' };
        if (path.length === 0) {
            return ret;
        }
        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute) {
            ret.root = '/';
            start = 1;
        }
        else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (end !== -1) {
            const start = startPart === 0 && isAbsolute ? 1 : startPart;
            if (startDot === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)) {
                ret.base = ret.name = path.slice(start, end);
            }
            else {
                ret.name = path.slice(start, startDot);
                ret.base = path.slice(start, end);
                ret.ext = path.slice(startDot, end);
            }
        }
        if (startPart > 0) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else if (isAbsolute) {
            ret.dir = '/';
        }
        return ret;
    },
    sep: '/',
    delimiter: ':',
    win32: null,
    posix: null
};
posix.win32 = win32.win32 = win32;
posix.posix = win32.posix = posix;
const normalize = (platformIsWin32 ? win32.normalize : posix.normalize);
const join = (platformIsWin32 ? win32.join : posix.join);
const resolve = (platformIsWin32 ? win32.resolve : posix.resolve);
const relative = (platformIsWin32 ? win32.relative : posix.relative);
const dirname = (platformIsWin32 ? win32.dirname : posix.dirname);
const basename = (platformIsWin32 ? win32.basename : posix.basename);
const extname = (platformIsWin32 ? win32.extname : posix.extname);
const sep = (platformIsWin32 ? win32.sep : posix.sep);


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/platform.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/platform.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LANGUAGE_DEFAULT: () => (/* binding */ LANGUAGE_DEFAULT),
/* harmony export */   OS: () => (/* binding */ OS),
/* harmony export */   isAndroid: () => (/* binding */ isAndroid),
/* harmony export */   isChrome: () => (/* binding */ isChrome),
/* harmony export */   isEdge: () => (/* binding */ isEdge),
/* harmony export */   isFirefox: () => (/* binding */ isFirefox),
/* harmony export */   isIOS: () => (/* binding */ isIOS),
/* harmony export */   isLinux: () => (/* binding */ isLinux),
/* harmony export */   isLittleEndian: () => (/* binding */ isLittleEndian),
/* harmony export */   isMacintosh: () => (/* binding */ isMacintosh),
/* harmony export */   isMobile: () => (/* binding */ isMobile),
/* harmony export */   isNative: () => (/* binding */ isNative),
/* harmony export */   isSafari: () => (/* binding */ isSafari),
/* harmony export */   isWeb: () => (/* binding */ isWeb),
/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),
/* harmony export */   isWindows: () => (/* binding */ isWindows),
/* harmony export */   language: () => (/* binding */ language),
/* harmony export */   setTimeout0: () => (/* binding */ setTimeout0),
/* harmony export */   setTimeout0IsFaster: () => (/* binding */ setTimeout0IsFaster),
/* harmony export */   userAgent: () => (/* binding */ userAgent),
/* harmony export */   webWorkerOrigin: () => (/* binding */ webWorkerOrigin)
/* harmony export */ });
/* harmony import */ var _nls_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nls.js */ "./node_modules/monaco-editor/esm/vs/nls.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const LANGUAGE_DEFAULT = 'en';
let _isWindows = false;
let _isMacintosh = false;
let _isLinux = false;
let _isLinuxSnap = false;
let _isNative = false;
let _isWeb = false;
let _isElectron = false;
let _isIOS = false;
let _isCI = false;
let _isMobile = false;
let _locale = undefined;
let _language = LANGUAGE_DEFAULT;
let _platformLocale = LANGUAGE_DEFAULT;
let _translationsConfigFile = undefined;
let _userAgent = undefined;
const $globalThis = globalThis;
let nodeProcess = undefined;
if (typeof $globalThis.vscode !== 'undefined' && typeof $globalThis.vscode.process !== 'undefined') {
    // Native environment (sandboxed)
    nodeProcess = $globalThis.vscode.process;
}
else if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {
    // Native environment (non-sandboxed)
    nodeProcess = process;
}
const isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';
const isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';
// Native environment
if (typeof nodeProcess === 'object') {
    _isWindows = (nodeProcess.platform === 'win32');
    _isMacintosh = (nodeProcess.platform === 'darwin');
    _isLinux = (nodeProcess.platform === 'linux');
    _isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];
    _isElectron = isElectronProcess;
    _isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'];
    _locale = LANGUAGE_DEFAULT;
    _language = LANGUAGE_DEFAULT;
    const rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];
    if (rawNlsConfig) {
        try {
            const nlsConfig = JSON.parse(rawNlsConfig);
            _locale = nlsConfig.userLocale;
            _platformLocale = nlsConfig.osLocale;
            _language = nlsConfig.resolvedLanguage || LANGUAGE_DEFAULT;
            _translationsConfigFile = nlsConfig.languagePack?.translationsConfigFile;
        }
        catch (e) {
        }
    }
    _isNative = true;
}
// Web environment
else if (typeof navigator === 'object' && !isElectronRenderer) {
    _userAgent = navigator.userAgent;
    _isWindows = _userAgent.indexOf('Windows') >= 0;
    _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;
    _isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
    _isLinux = _userAgent.indexOf('Linux') >= 0;
    _isMobile = _userAgent?.indexOf('Mobi') >= 0;
    _isWeb = true;
    _language = _nls_js__WEBPACK_IMPORTED_MODULE_0__.getNLSLanguage() || LANGUAGE_DEFAULT;
    _locale = navigator.language.toLowerCase();
    _platformLocale = _locale;
}
// Unknown environment
else {
    console.error('Unable to resolve platform.');
}
let _platform = 0 /* Platform.Web */;
if (_isMacintosh) {
    _platform = 1 /* Platform.Mac */;
}
else if (_isWindows) {
    _platform = 3 /* Platform.Windows */;
}
else if (_isLinux) {
    _platform = 2 /* Platform.Linux */;
}
const isWindows = _isWindows;
const isMacintosh = _isMacintosh;
const isLinux = _isLinux;
const isNative = _isNative;
const isWeb = _isWeb;
const isWebWorker = (_isWeb && typeof $globalThis.importScripts === 'function');
const webWorkerOrigin = isWebWorker ? $globalThis.origin : undefined;
const isIOS = _isIOS;
const isMobile = _isMobile;
const userAgent = _userAgent;
/**
 * The language used for the user interface. The format of
 * the string is all lower case (e.g. zh-tw for Traditional
 * Chinese or de for German)
 */
const language = _language;
const setTimeout0IsFaster = (typeof $globalThis.postMessage === 'function' && !$globalThis.importScripts);
/**
 * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.
 *
 * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay
 * that browsers set when the nesting level is > 5.
 */
const setTimeout0 = (() => {
    if (setTimeout0IsFaster) {
        const pending = [];
        $globalThis.addEventListener('message', (e) => {
            if (e.data && e.data.vscodeScheduleAsyncWork) {
                for (let i = 0, len = pending.length; i < len; i++) {
                    const candidate = pending[i];
                    if (candidate.id === e.data.vscodeScheduleAsyncWork) {
                        pending.splice(i, 1);
                        candidate.callback();
                        return;
                    }
                }
            }
        });
        let lastId = 0;
        return (callback) => {
            const myId = ++lastId;
            pending.push({
                id: myId,
                callback: callback
            });
            $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, '*');
        };
    }
    return (callback) => setTimeout(callback);
})();
const OS = (_isMacintosh || _isIOS ? 2 /* OperatingSystem.Macintosh */ : (_isWindows ? 1 /* OperatingSystem.Windows */ : 3 /* OperatingSystem.Linux */));
let _isLittleEndian = true;
let _isLittleEndianComputed = false;
function isLittleEndian() {
    if (!_isLittleEndianComputed) {
        _isLittleEndianComputed = true;
        const test = new Uint8Array(2);
        test[0] = 1;
        test[1] = 2;
        const view = new Uint16Array(test.buffer);
        _isLittleEndian = (view[0] === (2 << 8) + 1);
    }
    return _isLittleEndian;
}
const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);
const isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);
const isSafari = !!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));
const isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);
const isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/process.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/process.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cwd: () => (/* binding */ cwd),
/* harmony export */   env: () => (/* binding */ env),
/* harmony export */   platform: () => (/* binding */ platform)
/* harmony export */ });
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

let safeProcess;
// Native sandbox environment
const vscodeGlobal = globalThis.vscode;
if (typeof vscodeGlobal !== 'undefined' && typeof vscodeGlobal.process !== 'undefined') {
    const sandboxProcess = vscodeGlobal.process;
    safeProcess = {
        get platform() { return sandboxProcess.platform; },
        get arch() { return sandboxProcess.arch; },
        get env() { return sandboxProcess.env; },
        cwd() { return sandboxProcess.cwd(); }
    };
}
// Native node.js environment
else if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {
    safeProcess = {
        get platform() { return process.platform; },
        get arch() { return process.arch; },
        get env() { return process.env; },
        cwd() { return process.env['VSCODE_CWD'] || process.cwd(); }
    };
}
// Web environment
else {
    safeProcess = {
        // Supported
        get platform() { return _platform_js__WEBPACK_IMPORTED_MODULE_0__.isWindows ? 'win32' : _platform_js__WEBPACK_IMPORTED_MODULE_0__.isMacintosh ? 'darwin' : 'linux'; },
        get arch() { return undefined; /* arch is undefined in web */ },
        // Unsupported
        get env() { return {}; },
        cwd() { return '/'; }
    };
}
/**
 * Provides safe access to the `cwd` property in node.js, sandboxed or web
 * environments.
 *
 * Note: in web, this property is hardcoded to be `/`.
 *
 * @skipMangle
 */
const cwd = safeProcess.cwd;
/**
 * Provides safe access to the `env` property in node.js, sandboxed or web
 * environments.
 *
 * Note: in web, this property is hardcoded to be `{}`.
 */
const env = safeProcess.env;
/**
 * Provides safe access to the `platform` property in node.js, sandboxed or web
 * environments.
 */
const platform = safeProcess.platform;


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js":
/*!********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StopWatch: () => (/* binding */ StopWatch)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const hasPerformanceNow = (globalThis.performance && typeof globalThis.performance.now === 'function');
class StopWatch {
    static create(highResolution) {
        return new StopWatch(highResolution);
    }
    constructor(highResolution) {
        this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);
        this._startTime = this._now();
        this._stopTime = -1;
    }
    stop() {
        this._stopTime = this._now();
    }
    reset() {
        this._startTime = this._now();
        this._stopTime = -1;
    }
    elapsed() {
        if (this._stopTime !== -1) {
            return this._stopTime - this._startTime;
        }
        return this._now() - this._startTime;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/strings.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/strings.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AmbiguousCharacters: () => (/* binding */ AmbiguousCharacters),
/* harmony export */   CodePointIterator: () => (/* binding */ CodePointIterator),
/* harmony export */   GraphemeIterator: () => (/* binding */ GraphemeIterator),
/* harmony export */   InvisibleCharacters: () => (/* binding */ InvisibleCharacters),
/* harmony export */   UNUSUAL_LINE_TERMINATORS: () => (/* binding */ UNUSUAL_LINE_TERMINATORS),
/* harmony export */   UTF8_BOM_CHARACTER: () => (/* binding */ UTF8_BOM_CHARACTER),
/* harmony export */   commonPrefixLength: () => (/* binding */ commonPrefixLength),
/* harmony export */   commonSuffixLength: () => (/* binding */ commonSuffixLength),
/* harmony export */   compare: () => (/* binding */ compare),
/* harmony export */   compareIgnoreCase: () => (/* binding */ compareIgnoreCase),
/* harmony export */   compareSubstring: () => (/* binding */ compareSubstring),
/* harmony export */   compareSubstringIgnoreCase: () => (/* binding */ compareSubstringIgnoreCase),
/* harmony export */   computeCodePoint: () => (/* binding */ computeCodePoint),
/* harmony export */   containsRTL: () => (/* binding */ containsRTL),
/* harmony export */   containsUnusualLineTerminators: () => (/* binding */ containsUnusualLineTerminators),
/* harmony export */   containsUppercaseCharacter: () => (/* binding */ containsUppercaseCharacter),
/* harmony export */   convertSimple2RegExpPattern: () => (/* binding */ convertSimple2RegExpPattern),
/* harmony export */   createRegExp: () => (/* binding */ createRegExp),
/* harmony export */   equalsIgnoreCase: () => (/* binding */ equalsIgnoreCase),
/* harmony export */   escape: () => (/* binding */ escape),
/* harmony export */   escapeRegExpCharacters: () => (/* binding */ escapeRegExpCharacters),
/* harmony export */   firstNonWhitespaceIndex: () => (/* binding */ firstNonWhitespaceIndex),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   getCharContainingOffset: () => (/* binding */ getCharContainingOffset),
/* harmony export */   getLeadingWhitespace: () => (/* binding */ getLeadingWhitespace),
/* harmony export */   getLeftDeleteOffset: () => (/* binding */ getLeftDeleteOffset),
/* harmony export */   getNextCodePoint: () => (/* binding */ getNextCodePoint),
/* harmony export */   htmlAttributeEncodeValue: () => (/* binding */ htmlAttributeEncodeValue),
/* harmony export */   isAsciiDigit: () => (/* binding */ isAsciiDigit),
/* harmony export */   isBasicASCII: () => (/* binding */ isBasicASCII),
/* harmony export */   isEmojiImprecise: () => (/* binding */ isEmojiImprecise),
/* harmony export */   isFalsyOrWhitespace: () => (/* binding */ isFalsyOrWhitespace),
/* harmony export */   isFullWidthCharacter: () => (/* binding */ isFullWidthCharacter),
/* harmony export */   isHighSurrogate: () => (/* binding */ isHighSurrogate),
/* harmony export */   isLowSurrogate: () => (/* binding */ isLowSurrogate),
/* harmony export */   isLowerAsciiLetter: () => (/* binding */ isLowerAsciiLetter),
/* harmony export */   isUpperAsciiLetter: () => (/* binding */ isUpperAsciiLetter),
/* harmony export */   lastNonWhitespaceIndex: () => (/* binding */ lastNonWhitespaceIndex),
/* harmony export */   ltrim: () => (/* binding */ ltrim),
/* harmony export */   nextCharLength: () => (/* binding */ nextCharLength),
/* harmony export */   noBreakWhitespace: () => (/* binding */ noBreakWhitespace),
/* harmony export */   prevCharLength: () => (/* binding */ prevCharLength),
/* harmony export */   regExpLeadsToEndlessLoop: () => (/* binding */ regExpLeadsToEndlessLoop),
/* harmony export */   rtrim: () => (/* binding */ rtrim),
/* harmony export */   singleLetterHash: () => (/* binding */ singleLetterHash),
/* harmony export */   splitLines: () => (/* binding */ splitLines),
/* harmony export */   splitLinesIncludeSeparators: () => (/* binding */ splitLinesIncludeSeparators),
/* harmony export */   startsWithIgnoreCase: () => (/* binding */ startsWithIgnoreCase),
/* harmony export */   startsWithUTF8BOM: () => (/* binding */ startsWithUTF8BOM),
/* harmony export */   stripWildcards: () => (/* binding */ stripWildcards),
/* harmony export */   trim: () => (/* binding */ trim)
/* harmony export */ });
/* harmony import */ var _cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache.js */ "./node_modules/monaco-editor/esm/vs/base/common/cache.js");
/* harmony import */ var _lazy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lazy.js */ "./node_modules/monaco-editor/esm/vs/base/common/lazy.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function isFalsyOrWhitespace(str) {
    if (!str || typeof str !== 'string') {
        return true;
    }
    return str.trim().length === 0;
}
const _formatRegexp = /{(\d+)}/g;
/**
 * Helper to produce a string with a variable number of arguments. Insert variable segments
 * into the string using the {n} notation where N is the index of the argument following the string.
 * @param value string to which formatting is applied
 * @param args replacements for {n}-entries
 */
function format(value, ...args) {
    if (args.length === 0) {
        return value;
    }
    return value.replace(_formatRegexp, function (match, group) {
        const idx = parseInt(group, 10);
        return isNaN(idx) || idx < 0 || idx >= args.length ?
            match :
            args[idx];
    });
}
/**
 * Encodes the given value so that it can be used as literal value in html attributes.
 *
 * In other words, computes `$val`, such that `attr` in `<div attr="$val" />` has the runtime value `value`.
 * This prevents XSS injection.
 */
function htmlAttributeEncodeValue(value) {
    return value.replace(/[<>"'&]/g, ch => {
        switch (ch) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '"': return '&quot;';
            case '\'': return '&apos;';
            case '&': return '&amp;';
        }
        return ch;
    });
}
/**
 * Converts HTML characters inside the string to use entities instead. Makes the string safe from
 * being used e.g. in HTMLElement.innerHTML.
 */
function escape(html) {
    return html.replace(/[<>&]/g, function (match) {
        switch (match) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            default: return match;
        }
    });
}
/**
 * Escapes regular expression characters in a given string
 */
function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, '\\$&');
}
/**
 * Removes all occurrences of needle from the beginning and end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim (default is a blank)
 */
function trim(haystack, needle = ' ') {
    const trimmed = ltrim(haystack, needle);
    return rtrim(trimmed, needle);
}
/**
 * Removes all occurrences of needle from the beginning of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */
function ltrim(haystack, needle) {
    if (!haystack || !needle) {
        return haystack;
    }
    const needleLen = needle.length;
    if (needleLen === 0 || haystack.length === 0) {
        return haystack;
    }
    let offset = 0;
    while (haystack.indexOf(needle, offset) === offset) {
        offset = offset + needleLen;
    }
    return haystack.substring(offset);
}
/**
 * Removes all occurrences of needle from the end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */
function rtrim(haystack, needle) {
    if (!haystack || !needle) {
        return haystack;
    }
    const needleLen = needle.length, haystackLen = haystack.length;
    if (needleLen === 0 || haystackLen === 0) {
        return haystack;
    }
    let offset = haystackLen, idx = -1;
    while (true) {
        idx = haystack.lastIndexOf(needle, offset - 1);
        if (idx === -1 || idx + needleLen !== offset) {
            break;
        }
        if (idx === 0) {
            return '';
        }
        offset = idx;
    }
    return haystack.substring(0, offset);
}
function convertSimple2RegExpPattern(pattern) {
    return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
}
function stripWildcards(pattern) {
    return pattern.replace(/\*/g, '');
}
function createRegExp(searchString, isRegex, options = {}) {
    if (!searchString) {
        throw new Error('Cannot create regex from empty string');
    }
    if (!isRegex) {
        searchString = escapeRegExpCharacters(searchString);
    }
    if (options.wholeWord) {
        if (!/\B/.test(searchString.charAt(0))) {
            searchString = '\\b' + searchString;
        }
        if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
            searchString = searchString + '\\b';
        }
    }
    let modifiers = '';
    if (options.global) {
        modifiers += 'g';
    }
    if (!options.matchCase) {
        modifiers += 'i';
    }
    if (options.multiline) {
        modifiers += 'm';
    }
    if (options.unicode) {
        modifiers += 'u';
    }
    return new RegExp(searchString, modifiers);
}
function regExpLeadsToEndlessLoop(regexp) {
    // Exit early if it's one of these special cases which are meant to match
    // against an empty string
    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\s*$') {
        return false;
    }
    // We check against an empty string. If the regular expression doesn't advance
    // (e.g. ends in an endless loop) it will match an empty string.
    const match = regexp.exec('');
    return !!(match && regexp.lastIndex === 0);
}
function splitLines(str) {
    return str.split(/\r\n|\r|\n/);
}
function splitLinesIncludeSeparators(str) {
    const linesWithSeparators = [];
    const splitLinesAndSeparators = str.split(/(\r\n|\r|\n)/);
    for (let i = 0; i < Math.ceil(splitLinesAndSeparators.length / 2); i++) {
        linesWithSeparators.push(splitLinesAndSeparators[2 * i] + (splitLinesAndSeparators[2 * i + 1] ?? ''));
    }
    return linesWithSeparators;
}
/**
 * Returns first index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */
function firstNonWhitespaceIndex(str) {
    for (let i = 0, len = str.length; i < len; i++) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {
            return i;
        }
    }
    return -1;
}
/**
 * Returns the leading whitespace of the string.
 * If the string contains only whitespaces, returns entire string
 */
function getLeadingWhitespace(str, start = 0, end = str.length) {
    for (let i = start; i < end; i++) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {
            return str.substring(start, i);
        }
    }
    return str.substring(start, end);
}
/**
 * Returns last index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */
function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i = startIndex; i >= 0; i--) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {
            return i;
        }
    }
    return -1;
}
function compare(a, b) {
    if (a < b) {
        return -1;
    }
    else if (a > b) {
        return 1;
    }
    else {
        return 0;
    }
}
function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
        const codeA = a.charCodeAt(aStart);
        const codeB = b.charCodeAt(bStart);
        if (codeA < codeB) {
            return -1;
        }
        else if (codeA > codeB) {
            return 1;
        }
    }
    const aLen = aEnd - aStart;
    const bLen = bEnd - bStart;
    if (aLen < bLen) {
        return -1;
    }
    else if (aLen > bLen) {
        return 1;
    }
    return 0;
}
function compareIgnoreCase(a, b) {
    return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);
}
function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
        let codeA = a.charCodeAt(aStart);
        let codeB = b.charCodeAt(bStart);
        if (codeA === codeB) {
            // equal
            continue;
        }
        if (codeA >= 128 || codeB >= 128) {
            // not ASCII letters -> fallback to lower-casing strings
            return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);
        }
        // mapper lower-case ascii letter onto upper-case varinats
        // [97-122] (lower ascii) --> [65-90] (upper ascii)
        if (isLowerAsciiLetter(codeA)) {
            codeA -= 32;
        }
        if (isLowerAsciiLetter(codeB)) {
            codeB -= 32;
        }
        // compare both code points
        const diff = codeA - codeB;
        if (diff === 0) {
            continue;
        }
        return diff;
    }
    const aLen = aEnd - aStart;
    const bLen = bEnd - bStart;
    if (aLen < bLen) {
        return -1;
    }
    else if (aLen > bLen) {
        return 1;
    }
    return 0;
}
function isAsciiDigit(code) {
    return code >= 48 /* CharCode.Digit0 */ && code <= 57 /* CharCode.Digit9 */;
}
function isLowerAsciiLetter(code) {
    return code >= 97 /* CharCode.a */ && code <= 122 /* CharCode.z */;
}
function isUpperAsciiLetter(code) {
    return code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */;
}
function equalsIgnoreCase(a, b) {
    return a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;
}
function startsWithIgnoreCase(str, candidate) {
    const candidateLength = candidate.length;
    if (candidate.length > str.length) {
        return false;
    }
    return compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;
}
/**
 * @returns the length of the common prefix of the two strings.
 */
function commonPrefixLength(a, b) {
    const len = Math.min(a.length, b.length);
    let i;
    for (i = 0; i < len; i++) {
        if (a.charCodeAt(i) !== b.charCodeAt(i)) {
            return i;
        }
    }
    return len;
}
/**
 * @returns the length of the common suffix of the two strings.
 */
function commonSuffixLength(a, b) {
    const len = Math.min(a.length, b.length);
    let i;
    const aLastIndex = a.length - 1;
    const bLastIndex = b.length - 1;
    for (i = 0; i < len; i++) {
        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
            return i;
        }
    }
    return len;
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */
function isHighSurrogate(charCode) {
    return (0xD800 <= charCode && charCode <= 0xDBFF);
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */
function isLowSurrogate(charCode) {
    return (0xDC00 <= charCode && charCode <= 0xDFFF);
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */
function computeCodePoint(highSurrogate, lowSurrogate) {
    return ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;
}
/**
 * get the code point that begins at offset `offset`
 */
function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
        const nextCharCode = str.charCodeAt(offset + 1);
        if (isLowSurrogate(nextCharCode)) {
            return computeCodePoint(charCode, nextCharCode);
        }
    }
    return charCode;
}
/**
 * get the code point that ends right before offset `offset`
 */
function getPrevCodePoint(str, offset) {
    const charCode = str.charCodeAt(offset - 1);
    if (isLowSurrogate(charCode) && offset > 1) {
        const prevCharCode = str.charCodeAt(offset - 2);
        if (isHighSurrogate(prevCharCode)) {
            return computeCodePoint(prevCharCode, charCode);
        }
    }
    return charCode;
}
class CodePointIterator {
    get offset() {
        return this._offset;
    }
    constructor(str, offset = 0) {
        this._str = str;
        this._len = str.length;
        this._offset = offset;
    }
    setOffset(offset) {
        this._offset = offset;
    }
    prevCodePoint() {
        const codePoint = getPrevCodePoint(this._str, this._offset);
        this._offset -= (codePoint >= 65536 /* Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
        return codePoint;
    }
    nextCodePoint() {
        const codePoint = getNextCodePoint(this._str, this._len, this._offset);
        this._offset += (codePoint >= 65536 /* Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
        return codePoint;
    }
    eol() {
        return (this._offset >= this._len);
    }
}
class GraphemeIterator {
    get offset() {
        return this._iterator.offset;
    }
    constructor(str, offset = 0) {
        this._iterator = new CodePointIterator(str, offset);
    }
    nextGraphemeLength() {
        const graphemeBreakTree = GraphemeBreakTree.getInstance();
        const iterator = this._iterator;
        const initialOffset = iterator.offset;
        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
        while (!iterator.eol()) {
            const offset = iterator.offset;
            const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
            if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
                // move iterator back
                iterator.setOffset(offset);
                break;
            }
            graphemeBreakType = nextGraphemeBreakType;
        }
        return (iterator.offset - initialOffset);
    }
    prevGraphemeLength() {
        const graphemeBreakTree = GraphemeBreakTree.getInstance();
        const iterator = this._iterator;
        const initialOffset = iterator.offset;
        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
        while (iterator.offset > 0) {
            const offset = iterator.offset;
            const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
            if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
                // move iterator back
                iterator.setOffset(offset);
                break;
            }
            graphemeBreakType = prevGraphemeBreakType;
        }
        return (initialOffset - iterator.offset);
    }
    eol() {
        return this._iterator.eol();
    }
}
function nextCharLength(str, initialOffset) {
    const iterator = new GraphemeIterator(str, initialOffset);
    return iterator.nextGraphemeLength();
}
function prevCharLength(str, initialOffset) {
    const iterator = new GraphemeIterator(str, initialOffset);
    return iterator.prevGraphemeLength();
}
function getCharContainingOffset(str, offset) {
    if (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {
        offset--;
    }
    const endOffset = offset + nextCharLength(str, offset);
    const startOffset = endOffset - prevCharLength(str, endOffset);
    return [startOffset, endOffset];
}
let CONTAINS_RTL = undefined;
function makeContainsRtl() {
    // Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js
    return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
}
/**
 * Returns true if `str` contains any Unicode character that is classified as "R" or "AL".
 */
function containsRTL(str) {
    if (!CONTAINS_RTL) {
        CONTAINS_RTL = makeContainsRtl();
    }
    return CONTAINS_RTL.test(str);
}
const IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
/**
 * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \n, \r, \t
 */
function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
}
const UNUSUAL_LINE_TERMINATORS = /[\u2028\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)
/**
 * Returns true if `str` contains unusual line terminators, like LS or PS
 */
function containsUnusualLineTerminators(str) {
    return UNUSUAL_LINE_TERMINATORS.test(str);
}
function isFullWidthCharacter(charCode) {
    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
    // http://jrgraphix.net/research/unicode_blocks.php
    //          2E80 - 2EFF   CJK Radicals Supplement
    //          2F00 - 2FDF   Kangxi Radicals
    //          2FF0 - 2FFF   Ideographic Description Characters
    //          3000 - 303F   CJK Symbols and Punctuation
    //          3040 - 309F   Hiragana
    //          30A0 - 30FF   Katakana
    //          3100 - 312F   Bopomofo
    //          3130 - 318F   Hangul Compatibility Jamo
    //          3190 - 319F   Kanbun
    //          31A0 - 31BF   Bopomofo Extended
    //          31F0 - 31FF   Katakana Phonetic Extensions
    //          3200 - 32FF   Enclosed CJK Letters and Months
    //          3300 - 33FF   CJK Compatibility
    //          3400 - 4DBF   CJK Unified Ideographs Extension A
    //          4DC0 - 4DFF   Yijing Hexagram Symbols
    //          4E00 - 9FFF   CJK Unified Ideographs
    //          A000 - A48F   Yi Syllables
    //          A490 - A4CF   Yi Radicals
    //          AC00 - D7AF   Hangul Syllables
    // [IGNORE] D800 - DB7F   High Surrogates
    // [IGNORE] DB80 - DBFF   High Private Use Surrogates
    // [IGNORE] DC00 - DFFF   Low Surrogates
    // [IGNORE] E000 - F8FF   Private Use Area
    //          F900 - FAFF   CJK Compatibility Ideographs
    // [IGNORE] FB00 - FB4F   Alphabetic Presentation Forms
    // [IGNORE] FB50 - FDFF   Arabic Presentation Forms-A
    // [IGNORE] FE00 - FE0F   Variation Selectors
    // [IGNORE] FE20 - FE2F   Combining Half Marks
    // [IGNORE] FE30 - FE4F   CJK Compatibility Forms
    // [IGNORE] FE50 - FE6F   Small Form Variants
    // [IGNORE] FE70 - FEFF   Arabic Presentation Forms-B
    //          FF00 - FFEF   Halfwidth and Fullwidth Forms
    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
    // [IGNORE] FFF0 - FFFF   Specials
    return ((charCode >= 0x2E80 && charCode <= 0xD7AF)
        || (charCode >= 0xF900 && charCode <= 0xFAFF)
        || (charCode >= 0xFF01 && charCode <= 0xFF5E));
}
/**
 * A fast function (therefore imprecise) to check if code points are emojis.
 * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js
 */
function isEmojiImprecise(x) {
    return ((x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)
        || (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)
        || (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)
        || (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)
        || (x >= 129648 && x <= 129782));
}
// -- UTF-8 BOM
const UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* CharCode.UTF8_BOM */);
function startsWithUTF8BOM(str) {
    return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* CharCode.UTF8_BOM */);
}
function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
    if (!target) {
        return false;
    }
    if (ignoreEscapedChars) {
        target = target.replace(/\\./g, '');
    }
    return target.toLowerCase() !== target;
}
/**
 * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.
 */
function singleLetterHash(n) {
    const LETTERS_CNT = (90 /* CharCode.Z */ - 65 /* CharCode.A */ + 1);
    n = n % (2 * LETTERS_CNT);
    if (n < LETTERS_CNT) {
        return String.fromCharCode(97 /* CharCode.a */ + n);
    }
    return String.fromCharCode(65 /* CharCode.A */ + n - LETTERS_CNT);
}
function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
    // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules
    // !!! Let's make the common case a bit faster
    if (breakTypeA === 0 /* GraphemeBreakType.Other */) {
        // see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table
        return (breakTypeB !== 5 /* GraphemeBreakType.Extend */ && breakTypeB !== 7 /* GraphemeBreakType.SpacingMark */);
    }
    // Do not break between a CR and LF. Otherwise, break before and after controls.
    // GB3                                        CR × LF
    // GB4                       (Control | CR | LF) ÷
    // GB5                                           ÷ (Control | CR | LF)
    if (breakTypeA === 2 /* GraphemeBreakType.CR */) {
        if (breakTypeB === 3 /* GraphemeBreakType.LF */) {
            return false; // GB3
        }
    }
    if (breakTypeA === 4 /* GraphemeBreakType.Control */ || breakTypeA === 2 /* GraphemeBreakType.CR */ || breakTypeA === 3 /* GraphemeBreakType.LF */) {
        return true; // GB4
    }
    if (breakTypeB === 4 /* GraphemeBreakType.Control */ || breakTypeB === 2 /* GraphemeBreakType.CR */ || breakTypeB === 3 /* GraphemeBreakType.LF */) {
        return true; // GB5
    }
    // Do not break Hangul syllable sequences.
    // GB6                                         L × (L | V | LV | LVT)
    // GB7                                  (LV | V) × (V | T)
    // GB8                                 (LVT | T) × T
    if (breakTypeA === 8 /* GraphemeBreakType.L */) {
        if (breakTypeB === 8 /* GraphemeBreakType.L */ || breakTypeB === 9 /* GraphemeBreakType.V */ || breakTypeB === 11 /* GraphemeBreakType.LV */ || breakTypeB === 12 /* GraphemeBreakType.LVT */) {
            return false; // GB6
        }
    }
    if (breakTypeA === 11 /* GraphemeBreakType.LV */ || breakTypeA === 9 /* GraphemeBreakType.V */) {
        if (breakTypeB === 9 /* GraphemeBreakType.V */ || breakTypeB === 10 /* GraphemeBreakType.T */) {
            return false; // GB7
        }
    }
    if (breakTypeA === 12 /* GraphemeBreakType.LVT */ || breakTypeA === 10 /* GraphemeBreakType.T */) {
        if (breakTypeB === 10 /* GraphemeBreakType.T */) {
            return false; // GB8
        }
    }
    // Do not break before extending characters or ZWJ.
    // GB9                                           × (Extend | ZWJ)
    if (breakTypeB === 5 /* GraphemeBreakType.Extend */ || breakTypeB === 13 /* GraphemeBreakType.ZWJ */) {
        return false; // GB9
    }
    // The GB9a and GB9b rules only apply to extended grapheme clusters:
    // Do not break before SpacingMarks, or after Prepend characters.
    // GB9a                                          × SpacingMark
    // GB9b                                  Prepend ×
    if (breakTypeB === 7 /* GraphemeBreakType.SpacingMark */) {
        return false; // GB9a
    }
    if (breakTypeA === 1 /* GraphemeBreakType.Prepend */) {
        return false; // GB9b
    }
    // Do not break within emoji modifier sequences or emoji zwj sequences.
    // GB11    \p{Extended_Pictographic} Extend* ZWJ × \p{Extended_Pictographic}
    if (breakTypeA === 13 /* GraphemeBreakType.ZWJ */ && breakTypeB === 14 /* GraphemeBreakType.Extended_Pictographic */) {
        // Note: we are not implementing the rule entirely here to avoid introducing states
        return false; // GB11
    }
    // GB12                          sot (RI RI)* RI × RI
    // GB13                        [^RI] (RI RI)* RI × RI
    if (breakTypeA === 6 /* GraphemeBreakType.Regional_Indicator */ && breakTypeB === 6 /* GraphemeBreakType.Regional_Indicator */) {
        // Note: we are not implementing the rule entirely here to avoid introducing states
        return false; // GB12 & GB13
    }
    // GB999                                     Any ÷ Any
    return true;
}
class GraphemeBreakTree {
    static { this._INSTANCE = null; }
    static getInstance() {
        if (!GraphemeBreakTree._INSTANCE) {
            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
        }
        return GraphemeBreakTree._INSTANCE;
    }
    constructor() {
        this._data = getGraphemeBreakRawData();
    }
    getGraphemeBreakType(codePoint) {
        // !!! Let's make 7bit ASCII a bit faster: 0..31
        if (codePoint < 32) {
            if (codePoint === 10 /* CharCode.LineFeed */) {
                return 3 /* GraphemeBreakType.LF */;
            }
            if (codePoint === 13 /* CharCode.CarriageReturn */) {
                return 2 /* GraphemeBreakType.CR */;
            }
            return 4 /* GraphemeBreakType.Control */;
        }
        // !!! Let's make 7bit ASCII a bit faster: 32..126
        if (codePoint < 127) {
            return 0 /* GraphemeBreakType.Other */;
        }
        const data = this._data;
        const nodeCount = data.length / 3;
        let nodeIndex = 1;
        while (nodeIndex <= nodeCount) {
            if (codePoint < data[3 * nodeIndex]) {
                // go left
                nodeIndex = 2 * nodeIndex;
            }
            else if (codePoint > data[3 * nodeIndex + 1]) {
                // go right
                nodeIndex = 2 * nodeIndex + 1;
            }
            else {
                // hit
                return data[3 * nodeIndex + 2];
            }
        }
        return 0 /* GraphemeBreakType.Other */;
    }
}
function getGraphemeBreakRawData() {
    // generated using https://github.com/alexdima/unicode-utils/blob/main/grapheme-break.js
    return JSON.parse('[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]');
}
//#endregion
/**
 * Computes the offset after performing a left delete on the given string,
 * while considering unicode grapheme/emoji rules.
*/
function getLeftDeleteOffset(offset, str) {
    if (offset === 0) {
        return 0;
    }
    // Try to delete emoji part.
    const emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);
    if (emojiOffset !== undefined) {
        return emojiOffset;
    }
    // Otherwise, just skip a single code point.
    const iterator = new CodePointIterator(str, offset);
    iterator.prevCodePoint();
    return iterator.offset;
}
function getOffsetBeforeLastEmojiComponent(initialOffset, str) {
    // See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the
    // structure of emojis.
    const iterator = new CodePointIterator(str, initialOffset);
    let codePoint = iterator.prevCodePoint();
    // Skip modifiers
    while ((isEmojiModifier(codePoint) || codePoint === 65039 /* CodePoint.emojiVariantSelector */ || codePoint === 8419 /* CodePoint.enclosingKeyCap */)) {
        if (iterator.offset === 0) {
            // Cannot skip modifier, no preceding emoji base.
            return undefined;
        }
        codePoint = iterator.prevCodePoint();
    }
    // Expect base emoji
    if (!isEmojiImprecise(codePoint)) {
        // Unexpected code point, not a valid emoji.
        return undefined;
    }
    let resultOffset = iterator.offset;
    if (resultOffset > 0) {
        // Skip optional ZWJ code points that combine multiple emojis.
        // In theory, we should check if that ZWJ actually combines multiple emojis
        // to prevent deleting ZWJs in situations we didn't account for.
        const optionalZwjCodePoint = iterator.prevCodePoint();
        if (optionalZwjCodePoint === 8205 /* CodePoint.zwj */) {
            resultOffset = iterator.offset;
        }
    }
    return resultOffset;
}
function isEmojiModifier(codePoint) {
    return 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;
}
const noBreakWhitespace = '\xa0';
class AmbiguousCharacters {
    static { this.ambiguousCharacterData = new _lazy_js__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => {
        // Generated using https://github.com/hediet/vscode-unicode-data
        // Stored as key1, value1, key2, value2, ...
        return JSON.parse('{\"_common\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],\"_default\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"cs\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"de\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"es\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"fr\":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"it\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ja\":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],\"ko\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pl\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pt-BR\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"qps-ploc\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ru\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"tr\":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"zh-hans\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],\"zh-hant\":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
    }); }
    static { this.cache = new _cache_js__WEBPACK_IMPORTED_MODULE_0__.LRUCachedFunction({ getCacheKey: JSON.stringify }, (locales) => {
        function arrayToMap(arr) {
            const result = new Map();
            for (let i = 0; i < arr.length; i += 2) {
                result.set(arr[i], arr[i + 1]);
            }
            return result;
        }
        function mergeMaps(map1, map2) {
            const result = new Map(map1);
            for (const [key, value] of map2) {
                result.set(key, value);
            }
            return result;
        }
        function intersectMaps(map1, map2) {
            if (!map1) {
                return map2;
            }
            const result = new Map();
            for (const [key, value] of map1) {
                if (map2.has(key)) {
                    result.set(key, value);
                }
            }
            return result;
        }
        const data = this.ambiguousCharacterData.value;
        let filteredLocales = locales.filter((l) => !l.startsWith('_') && l in data);
        if (filteredLocales.length === 0) {
            filteredLocales = ['_default'];
        }
        let languageSpecificMap = undefined;
        for (const locale of filteredLocales) {
            const map = arrayToMap(data[locale]);
            languageSpecificMap = intersectMaps(languageSpecificMap, map);
        }
        const commonMap = arrayToMap(data['_common']);
        const map = mergeMaps(commonMap, languageSpecificMap);
        return new AmbiguousCharacters(map);
    }); }
    static getInstance(locales) {
        return AmbiguousCharacters.cache.get(Array.from(locales));
    }
    static { this._locales = new _lazy_js__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => Object.keys(AmbiguousCharacters.ambiguousCharacterData.value).filter((k) => !k.startsWith('_'))); }
    static getLocales() {
        return AmbiguousCharacters._locales.value;
    }
    constructor(confusableDictionary) {
        this.confusableDictionary = confusableDictionary;
    }
    isAmbiguous(codePoint) {
        return this.confusableDictionary.has(codePoint);
    }
    /**
     * Returns the non basic ASCII code point that the given code point can be confused,
     * or undefined if such code point does note exist.
     */
    getPrimaryConfusable(codePoint) {
        return this.confusableDictionary.get(codePoint);
    }
    getConfusableCodePoints() {
        return new Set(this.confusableDictionary.keys());
    }
}
class InvisibleCharacters {
    static getRawData() {
        // Generated using https://github.com/hediet/vscode-unicode-data
        return JSON.parse('[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]');
    }
    static { this._data = undefined; }
    static getData() {
        if (!this._data) {
            this._data = new Set(InvisibleCharacters.getRawData());
        }
        return this._data;
    }
    static isInvisibleCharacter(codePoint) {
        return InvisibleCharacters.getData().has(codePoint);
    }
    static get codePoints() {
        return InvisibleCharacters.getData();
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/symbols.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/symbols.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MicrotaskDelay: () => (/* binding */ MicrotaskDelay)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Can be passed into the Delayed to defer using a microtask
 * */
const MicrotaskDelay = Symbol('MicrotaskDelay');


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/types.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assertIsDefined: () => (/* binding */ assertIsDefined),
/* harmony export */   assertType: () => (/* binding */ assertType),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isDefined: () => (/* binding */ isDefined),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isIterable: () => (/* binding */ isIterable),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isTypedArray: () => (/* binding */ isTypedArray),
/* harmony export */   isUndefined: () => (/* binding */ isUndefined),
/* harmony export */   isUndefinedOrNull: () => (/* binding */ isUndefinedOrNull),
/* harmony export */   validateConstraint: () => (/* binding */ validateConstraint),
/* harmony export */   validateConstraints: () => (/* binding */ validateConstraints)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * @returns whether the provided parameter is a JavaScript String or not.
 */
function isString(str) {
    return (typeof str === 'string');
}
/**
 * @returns whether the provided parameter is of type `object` but **not**
 *	`null`, an `array`, a `regexp`, nor a `date`.
 */
function isObject(obj) {
    // The method can't do a type cast since there are type (like strings) which
    // are subclasses of any put not positvely matched by the function. Hence type
    // narrowing results in wrong results.
    return typeof obj === 'object'
        && obj !== null
        && !Array.isArray(obj)
        && !(obj instanceof RegExp)
        && !(obj instanceof Date);
}
/**
 * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type
 */
function isTypedArray(obj) {
    const TypedArray = Object.getPrototypeOf(Uint8Array);
    return typeof obj === 'object'
        && obj instanceof TypedArray;
}
/**
 * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
 * @returns whether the provided parameter is a JavaScript Number or not.
 */
function isNumber(obj) {
    return (typeof obj === 'number' && !isNaN(obj));
}
/**
 * @returns whether the provided parameter is an Iterable, casting to the given generic
 */
function isIterable(obj) {
    return !!obj && typeof obj[Symbol.iterator] === 'function';
}
/**
 * @returns whether the provided parameter is a JavaScript Boolean or not.
 */
function isBoolean(obj) {
    return (obj === true || obj === false);
}
/**
 * @returns whether the provided parameter is undefined.
 */
function isUndefined(obj) {
    return (typeof obj === 'undefined');
}
/**
 * @returns whether the provided parameter is defined.
 */
function isDefined(arg) {
    return !isUndefinedOrNull(arg);
}
/**
 * @returns whether the provided parameter is undefined or null.
 */
function isUndefinedOrNull(obj) {
    return (isUndefined(obj) || obj === null);
}
function assertType(condition, type) {
    if (!condition) {
        throw new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');
    }
}
/**
 * Asserts that the argument passed in is neither undefined nor null.
 */
function assertIsDefined(arg) {
    if (isUndefinedOrNull(arg)) {
        throw new Error('Assertion Failed: argument is undefined or null');
    }
    return arg;
}
/**
 * @returns whether the provided parameter is a JavaScript Function or not.
 */
function isFunction(obj) {
    return (typeof obj === 'function');
}
function validateConstraints(args, constraints) {
    const len = Math.min(args.length, constraints.length);
    for (let i = 0; i < len; i++) {
        validateConstraint(args[i], constraints[i]);
    }
}
function validateConstraint(arg, constraint) {
    if (isString(constraint)) {
        if (typeof arg !== constraint) {
            throw new Error(`argument does not match constraint: typeof ${constraint}`);
        }
    }
    else if (isFunction(constraint)) {
        try {
            if (arg instanceof constraint) {
                return;
            }
        }
        catch {
            // ignore
        }
        if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
            return;
        }
        if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
            return;
        }
        throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/uint.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/uint.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toUint32: () => (/* binding */ toUint32),
/* harmony export */   toUint8: () => (/* binding */ toUint8)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function toUint8(v) {
    if (v < 0) {
        return 0;
    }
    if (v > 255 /* Constants.MAX_UINT_8 */) {
        return 255 /* Constants.MAX_UINT_8 */;
    }
    return v | 0;
}
function toUint32(v) {
    if (v < 0) {
        return 0;
    }
    if (v > 4294967295 /* Constants.MAX_UINT_32 */) {
        return 4294967295 /* Constants.MAX_UINT_32 */;
    }
    return v | 0;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/uri.js":
/*!**************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/uri.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   uriToFsPath: () => (/* binding */ uriToFsPath)
/* harmony export */ });
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.js */ "./node_modules/monaco-editor/esm/vs/base/common/path.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


const _schemePattern = /^\w[\w\d+.-]*$/;
const _singleSlashStart = /^\//;
const _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
    // scheme, must be set
    if (!ret.scheme && _strict) {
        throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
    // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
        throw new Error('[UriError]: Scheme contains illegal characters.');
    }
    // path, http://tools.ietf.org/html/rfc3986#section-3.3
    // If a URI contains an authority component, then the path component
    // must either be empty or begin with a slash ("/") character.  If a URI
    // does not contain an authority component, then the path cannot begin
    // with two slash characters ("//").
    if (ret.path) {
        if (ret.authority) {
            if (!_singleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            }
        }
        else {
            if (_doubleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
        }
    }
}
// for a while we allowed uris *without* schemes and this is the migration
// for them, e.g. an uri without scheme and without strict-mode warns and falls
// back to the file-scheme. that should cause the least carnage and still be a
// clear warning
function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
        return 'file';
    }
    return scheme;
}
// implements a bit of https://tools.ietf.org/html/rfc3986#section-5
function _referenceResolution(scheme, path) {
    // the slash-character is our 'default base' as we don't
    // support constructing URIs relative to other URIs. This
    // also means that we alter and potentially break paths.
    // see https://tools.ietf.org/html/rfc3986#section-5.1.4
    switch (scheme) {
        case 'https':
        case 'http':
        case 'file':
            if (!path) {
                path = _slash;
            }
            else if (path[0] !== _slash) {
                path = _slash + path;
            }
            break;
    }
    return path;
}
const _empty = '';
const _slash = '/';
const _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 * ```txt
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 * ```
 */
class URI {
    static isUri(thing) {
        if (thing instanceof URI) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.authority === 'string'
            && typeof thing.fragment === 'string'
            && typeof thing.path === 'string'
            && typeof thing.query === 'string'
            && typeof thing.scheme === 'string'
            && typeof thing.fsPath === 'string'
            && typeof thing.with === 'function'
            && typeof thing.toString === 'function';
    }
    /**
     * @internal
     */
    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
        if (typeof schemeOrData === 'object') {
            this.scheme = schemeOrData.scheme || _empty;
            this.authority = schemeOrData.authority || _empty;
            this.path = schemeOrData.path || _empty;
            this.query = schemeOrData.query || _empty;
            this.fragment = schemeOrData.fragment || _empty;
            // no validation because it's this URI
            // that creates uri components.
            // _validateUri(this);
        }
        else {
            this.scheme = _schemeFix(schemeOrData, _strict);
            this.authority = authority || _empty;
            this.path = _referenceResolution(this.scheme, path || _empty);
            this.query = query || _empty;
            this.fragment = fragment || _empty;
            _validateUri(this, _strict);
        }
    }
    // ---- filesystem path -----------------------
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath() {
        // if (this.scheme !== 'file') {
        // 	console.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);
        // }
        return uriToFsPath(this, false);
    }
    // ---- modify to new -------------------------
    with(change) {
        if (!change) {
            return this;
        }
        let { scheme, authority, path, query, fragment } = change;
        if (scheme === undefined) {
            scheme = this.scheme;
        }
        else if (scheme === null) {
            scheme = _empty;
        }
        if (authority === undefined) {
            authority = this.authority;
        }
        else if (authority === null) {
            authority = _empty;
        }
        if (path === undefined) {
            path = this.path;
        }
        else if (path === null) {
            path = _empty;
        }
        if (query === undefined) {
            query = this.query;
        }
        else if (query === null) {
            query = _empty;
        }
        if (fragment === undefined) {
            fragment = this.fragment;
        }
        else if (fragment === null) {
            fragment = _empty;
        }
        if (scheme === this.scheme
            && authority === this.authority
            && path === this.path
            && query === this.query
            && fragment === this.fragment) {
            return this;
        }
        return new Uri(scheme, authority, path, query, fragment);
    }
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value, _strict = false) {
        const match = _regexp.exec(value);
        if (!match) {
            return new Uri(_empty, _empty, _empty, _empty, _empty);
        }
        return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
    }
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path) {
        let authority = _empty;
        // normalize to fwd-slashes on windows,
        // on other systems bwd-slashes are valid
        // filename character, eg /f\oo/ba\r.txt
        if (_platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows) {
            path = path.replace(/\\/g, _slash);
        }
        // check for authority as used in UNC shares
        // or use the path as given
        if (path[0] === _slash && path[1] === _slash) {
            const idx = path.indexOf(_slash, 2);
            if (idx === -1) {
                authority = path.substring(2);
                path = _slash;
            }
            else {
                authority = path.substring(2, idx);
                path = path.substring(idx) || _slash;
            }
        }
        return new Uri('file', authority, path, _empty, _empty);
    }
    /**
     * Creates new URI from uri components.
     *
     * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
     * validation and should be used for untrusted uri components retrieved from storage,
     * user input, command arguments etc
     */
    static from(components, strict) {
        const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);
        return result;
    }
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param uri The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    static joinPath(uri, ...pathFragment) {
        if (!uri.path) {
            throw new Error(`[UriError]: cannot call joinPath on URI without path`);
        }
        let newPath;
        if (_platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows && uri.scheme === 'file') {
            newPath = URI.file(_path_js__WEBPACK_IMPORTED_MODULE_0__.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
        }
        else {
            newPath = _path_js__WEBPACK_IMPORTED_MODULE_0__.posix.join(uri.path, ...pathFragment);
        }
        return uri.with({ path: newPath });
    }
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding = false) {
        return _asFormatted(this, skipEncoding);
    }
    toJSON() {
        return this;
    }
    static revive(data) {
        if (!data) {
            return data;
        }
        else if (data instanceof URI) {
            return data;
        }
        else {
            const result = new Uri(data);
            result._formatted = data.external ?? null;
            result._fsPath = data._sep === _pathSepMarker ? data.fsPath ?? null : null;
            return result;
        }
    }
}
const _pathSepMarker = _platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows ? 1 : undefined;
// This class exists so that URI is compatible with vscode.Uri (API).
class Uri extends URI {
    constructor() {
        super(...arguments);
        this._formatted = null;
        this._fsPath = null;
    }
    get fsPath() {
        if (!this._fsPath) {
            this._fsPath = uriToFsPath(this, false);
        }
        return this._fsPath;
    }
    toString(skipEncoding = false) {
        if (!skipEncoding) {
            if (!this._formatted) {
                this._formatted = _asFormatted(this, false);
            }
            return this._formatted;
        }
        else {
            // we don't cache that
            return _asFormatted(this, true);
        }
    }
    toJSON() {
        const res = {
            $mid: 1 /* MarshalledId.Uri */
        };
        // cached state
        if (this._fsPath) {
            res.fsPath = this._fsPath;
            res._sep = _pathSepMarker;
        }
        if (this._formatted) {
            res.external = this._formatted;
        }
        //--- uri components
        if (this.path) {
            res.path = this.path;
        }
        // TODO
        // this isn't correct and can violate the UriComponents contract but
        // this is part of the vscode.Uri API and we shouldn't change how that
        // works anymore
        if (this.scheme) {
            res.scheme = this.scheme;
        }
        if (this.authority) {
            res.authority = this.authority;
        }
        if (this.query) {
            res.query = this.query;
        }
        if (this.fragment) {
            res.fragment = this.fragment;
        }
        return res;
    }
}
// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2
const encodeTable = {
    [58 /* CharCode.Colon */]: '%3A', // gen-delims
    [47 /* CharCode.Slash */]: '%2F',
    [63 /* CharCode.QuestionMark */]: '%3F',
    [35 /* CharCode.Hash */]: '%23',
    [91 /* CharCode.OpenSquareBracket */]: '%5B',
    [93 /* CharCode.CloseSquareBracket */]: '%5D',
    [64 /* CharCode.AtSign */]: '%40',
    [33 /* CharCode.ExclamationMark */]: '%21', // sub-delims
    [36 /* CharCode.DollarSign */]: '%24',
    [38 /* CharCode.Ampersand */]: '%26',
    [39 /* CharCode.SingleQuote */]: '%27',
    [40 /* CharCode.OpenParen */]: '%28',
    [41 /* CharCode.CloseParen */]: '%29',
    [42 /* CharCode.Asterisk */]: '%2A',
    [43 /* CharCode.Plus */]: '%2B',
    [44 /* CharCode.Comma */]: '%2C',
    [59 /* CharCode.Semicolon */]: '%3B',
    [61 /* CharCode.Equals */]: '%3D',
    [32 /* CharCode.Space */]: '%20',
};
function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
    let res = undefined;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
        const code = uriComponent.charCodeAt(pos);
        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3
        if ((code >= 97 /* CharCode.a */ && code <= 122 /* CharCode.z */)
            || (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */)
            || (code >= 48 /* CharCode.Digit0 */ && code <= 57 /* CharCode.Digit9 */)
            || code === 45 /* CharCode.Dash */
            || code === 46 /* CharCode.Period */
            || code === 95 /* CharCode.Underline */
            || code === 126 /* CharCode.Tilde */
            || (isPath && code === 47 /* CharCode.Slash */)
            || (isAuthority && code === 91 /* CharCode.OpenSquareBracket */)
            || (isAuthority && code === 93 /* CharCode.CloseSquareBracket */)
            || (isAuthority && code === 58 /* CharCode.Colon */)) {
            // check if we are delaying native encode
            if (nativeEncodePos !== -1) {
                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                nativeEncodePos = -1;
            }
            // check if we write into a new string (by default we try to return the param)
            if (res !== undefined) {
                res += uriComponent.charAt(pos);
            }
        }
        else {
            // encoding needed, we need to allocate a new string
            if (res === undefined) {
                res = uriComponent.substr(0, pos);
            }
            // check with default table first
            const escaped = encodeTable[code];
            if (escaped !== undefined) {
                // check if we are delaying native encode
                if (nativeEncodePos !== -1) {
                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                    nativeEncodePos = -1;
                }
                // append escaped variant to result
                res += escaped;
            }
            else if (nativeEncodePos === -1) {
                // use native encode only when needed
                nativeEncodePos = pos;
            }
        }
    }
    if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== undefined ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
    let res = undefined;
    for (let pos = 0; pos < path.length; pos++) {
        const code = path.charCodeAt(pos);
        if (code === 35 /* CharCode.Hash */ || code === 63 /* CharCode.QuestionMark */) {
            if (res === undefined) {
                res = path.substr(0, pos);
            }
            res += encodeTable[code];
        }
        else {
            if (res !== undefined) {
                res += path[pos];
            }
        }
    }
    return res !== undefined ? res : path;
}
/**
 * Compute `fsPath` for the given uri
 */
function uriToFsPath(uri, keepDriveLetterCasing) {
    let value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
        // unc path: file://shares/c$/far/boo
        value = `//${uri.authority}${uri.path}`;
    }
    else if (uri.path.charCodeAt(0) === 47 /* CharCode.Slash */
        && (uri.path.charCodeAt(1) >= 65 /* CharCode.A */ && uri.path.charCodeAt(1) <= 90 /* CharCode.Z */ || uri.path.charCodeAt(1) >= 97 /* CharCode.a */ && uri.path.charCodeAt(1) <= 122 /* CharCode.z */)
        && uri.path.charCodeAt(2) === 58 /* CharCode.Colon */) {
        if (!keepDriveLetterCasing) {
            // windows drive letter: file:///c:/far/boo
            value = uri.path[1].toLowerCase() + uri.path.substr(2);
        }
        else {
            value = uri.path.substr(1);
        }
    }
    else {
        // other path
        value = uri.path;
    }
    if (_platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows) {
        value = value.replace(/\//g, '\\');
    }
    return value;
}
/**
 * Create the external version of a uri
 */
function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding
        ? encodeURIComponentFast
        : encodeURIComponentMinimal;
    let res = '';
    let { scheme, authority, path, query, fragment } = uri;
    if (scheme) {
        res += scheme;
        res += ':';
    }
    if (authority || scheme === 'file') {
        res += _slash;
        res += _slash;
    }
    if (authority) {
        let idx = authority.indexOf('@');
        if (idx !== -1) {
            // <user>@<auth>
            const userinfo = authority.substr(0, idx);
            authority = authority.substr(idx + 1);
            idx = userinfo.lastIndexOf(':');
            if (idx === -1) {
                res += encoder(userinfo, false, false);
            }
            else {
                // <user>:<pass>@<auth>
                res += encoder(userinfo.substr(0, idx), false, false);
                res += ':';
                res += encoder(userinfo.substr(idx + 1), false, true);
            }
            res += '@';
        }
        authority = authority.toLowerCase();
        idx = authority.lastIndexOf(':');
        if (idx === -1) {
            res += encoder(authority, false, true);
        }
        else {
            // <auth>:<port>
            res += encoder(authority.substr(0, idx), false, true);
            res += authority.substr(idx);
        }
    }
    if (path) {
        // lower-case windows drive letters in /C:/fff or C:/fff
        if (path.length >= 3 && path.charCodeAt(0) === 47 /* CharCode.Slash */ && path.charCodeAt(2) === 58 /* CharCode.Colon */) {
            const code = path.charCodeAt(1);
            if (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */) {
                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // "/c:".length === 3
            }
        }
        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* CharCode.Colon */) {
            const code = path.charCodeAt(0);
            if (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */) {
                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // "/c:".length === 3
            }
        }
        // encode the rest of the path
        res += encoder(path, true, false);
    }
    if (query) {
        res += '?';
        res += encoder(query, false, false);
    }
    if (fragment) {
        res += '#';
        res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
    }
    return res;
}
// --- decode
function decodeURIComponentGraceful(str) {
    try {
        return decodeURIComponent(str);
    }
    catch {
        if (str.length > 3) {
            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
        }
        else {
            return str;
        }
    }
}
const _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
        return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js":
/*!******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SimpleWorkerClient: () => (/* binding */ SimpleWorkerClient),
/* harmony export */   SimpleWorkerServer: () => (/* binding */ SimpleWorkerServer),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   logOnceWebWorkerWarning: () => (/* binding */ logOnceWebWorkerWarning)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../network.js */ "./node_modules/monaco-editor/esm/vs/base/common/network.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






// ESM-comment-begin
// const isESM = false;
// ESM-comment-end
// ESM-uncomment-begin
const isESM = true;
// ESM-uncomment-end
const DEFAULT_CHANNEL = 'default';
const INITIALIZE = '$initialize';
let webWorkerWarningLogged = false;
function logOnceWebWorkerWarning(err) {
    if (!_platform_js__WEBPACK_IMPORTED_MODULE_4__.isWeb) {
        // running tests
        return;
    }
    if (!webWorkerWarningLogged) {
        webWorkerWarningLogged = true;
        console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');
    }
    console.warn(err.message);
}
class RequestMessage {
    constructor(vsWorker, req, channel, method, args) {
        this.vsWorker = vsWorker;
        this.req = req;
        this.channel = channel;
        this.method = method;
        this.args = args;
        this.type = 0 /* MessageType.Request */;
    }
}
class ReplyMessage {
    constructor(vsWorker, seq, res, err) {
        this.vsWorker = vsWorker;
        this.seq = seq;
        this.res = res;
        this.err = err;
        this.type = 1 /* MessageType.Reply */;
    }
}
class SubscribeEventMessage {
    constructor(vsWorker, req, channel, eventName, arg) {
        this.vsWorker = vsWorker;
        this.req = req;
        this.channel = channel;
        this.eventName = eventName;
        this.arg = arg;
        this.type = 2 /* MessageType.SubscribeEvent */;
    }
}
class EventMessage {
    constructor(vsWorker, req, event) {
        this.vsWorker = vsWorker;
        this.req = req;
        this.event = event;
        this.type = 3 /* MessageType.Event */;
    }
}
class UnsubscribeEventMessage {
    constructor(vsWorker, req) {
        this.vsWorker = vsWorker;
        this.req = req;
        this.type = 4 /* MessageType.UnsubscribeEvent */;
    }
}
class SimpleWorkerProtocol {
    constructor(handler) {
        this._workerId = -1;
        this._handler = handler;
        this._lastSentReq = 0;
        this._pendingReplies = Object.create(null);
        this._pendingEmitters = new Map();
        this._pendingEvents = new Map();
    }
    setWorkerId(workerId) {
        this._workerId = workerId;
    }
    sendMessage(channel, method, args) {
        const req = String(++this._lastSentReq);
        return new Promise((resolve, reject) => {
            this._pendingReplies[req] = {
                resolve: resolve,
                reject: reject
            };
            this._send(new RequestMessage(this._workerId, req, channel, method, args));
        });
    }
    listen(channel, eventName, arg) {
        let req = null;
        const emitter = new _event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter({
            onWillAddFirstListener: () => {
                req = String(++this._lastSentReq);
                this._pendingEmitters.set(req, emitter);
                this._send(new SubscribeEventMessage(this._workerId, req, channel, eventName, arg));
            },
            onDidRemoveLastListener: () => {
                this._pendingEmitters.delete(req);
                this._send(new UnsubscribeEventMessage(this._workerId, req));
                req = null;
            }
        });
        return emitter.event;
    }
    handleMessage(message) {
        if (!message || !message.vsWorker) {
            return;
        }
        if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
            return;
        }
        this._handleMessage(message);
    }
    createProxyToRemoteChannel(channel, sendMessageBarrier) {
        const handler = {
            get: (target, name) => {
                if (typeof name === 'string' && !target[name]) {
                    if (propertyIsDynamicEvent(name)) { // onDynamic...
                        target[name] = (arg) => {
                            return this.listen(channel, name, arg);
                        };
                    }
                    else if (propertyIsEvent(name)) { // on...
                        target[name] = this.listen(channel, name, undefined);
                    }
                    else if (name.charCodeAt(0) === 36 /* CharCode.DollarSign */) { // $...
                        target[name] = async (...myArgs) => {
                            await sendMessageBarrier?.();
                            return this.sendMessage(channel, name, myArgs);
                        };
                    }
                }
                return target[name];
            }
        };
        return new Proxy(Object.create(null), handler);
    }
    _handleMessage(msg) {
        switch (msg.type) {
            case 1 /* MessageType.Reply */:
                return this._handleReplyMessage(msg);
            case 0 /* MessageType.Request */:
                return this._handleRequestMessage(msg);
            case 2 /* MessageType.SubscribeEvent */:
                return this._handleSubscribeEventMessage(msg);
            case 3 /* MessageType.Event */:
                return this._handleEventMessage(msg);
            case 4 /* MessageType.UnsubscribeEvent */:
                return this._handleUnsubscribeEventMessage(msg);
        }
    }
    _handleReplyMessage(replyMessage) {
        if (!this._pendingReplies[replyMessage.seq]) {
            console.warn('Got reply to unknown seq');
            return;
        }
        const reply = this._pendingReplies[replyMessage.seq];
        delete this._pendingReplies[replyMessage.seq];
        if (replyMessage.err) {
            let err = replyMessage.err;
            if (replyMessage.err.$isError) {
                err = new Error();
                err.name = replyMessage.err.name;
                err.message = replyMessage.err.message;
                err.stack = replyMessage.err.stack;
            }
            reply.reject(err);
            return;
        }
        reply.resolve(replyMessage.res);
    }
    _handleRequestMessage(requestMessage) {
        const req = requestMessage.req;
        const result = this._handler.handleMessage(requestMessage.channel, requestMessage.method, requestMessage.args);
        result.then((r) => {
            this._send(new ReplyMessage(this._workerId, req, r, undefined));
        }, (e) => {
            if (e.detail instanceof Error) {
                // Loading errors have a detail property that points to the actual error
                e.detail = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.transformErrorForSerialization)(e.detail);
            }
            this._send(new ReplyMessage(this._workerId, req, undefined, (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.transformErrorForSerialization)(e)));
        });
    }
    _handleSubscribeEventMessage(msg) {
        const req = msg.req;
        const disposable = this._handler.handleEvent(msg.channel, msg.eventName, msg.arg)((event) => {
            this._send(new EventMessage(this._workerId, req, event));
        });
        this._pendingEvents.set(req, disposable);
    }
    _handleEventMessage(msg) {
        if (!this._pendingEmitters.has(msg.req)) {
            console.warn('Got event for unknown req');
            return;
        }
        this._pendingEmitters.get(msg.req).fire(msg.event);
    }
    _handleUnsubscribeEventMessage(msg) {
        if (!this._pendingEvents.has(msg.req)) {
            console.warn('Got unsubscribe for unknown req');
            return;
        }
        this._pendingEvents.get(msg.req).dispose();
        this._pendingEvents.delete(msg.req);
    }
    _send(msg) {
        const transfer = [];
        if (msg.type === 0 /* MessageType.Request */) {
            for (let i = 0; i < msg.args.length; i++) {
                if (msg.args[i] instanceof ArrayBuffer) {
                    transfer.push(msg.args[i]);
                }
            }
        }
        else if (msg.type === 1 /* MessageType.Reply */) {
            if (msg.res instanceof ArrayBuffer) {
                transfer.push(msg.res);
            }
        }
        this._handler.sendMessage(msg, transfer);
    }
}
/**
 * Main thread side
 */
class SimpleWorkerClient extends _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable {
    constructor(workerFactory, workerDescriptor) {
        super();
        this._localChannels = new Map();
        this._worker = this._register(workerFactory.create({
            amdModuleId: 'vs/base/common/worker/simpleWorker',
            esmModuleLocation: workerDescriptor.esmModuleLocation,
            label: workerDescriptor.label
        }, (msg) => {
            this._protocol.handleMessage(msg);
        }, (err) => {
            // in Firefox, web workers fail lazily :(
            // we will reject the proxy
            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(err);
        }));
        this._protocol = new SimpleWorkerProtocol({
            sendMessage: (msg, transfer) => {
                this._worker.postMessage(msg, transfer);
            },
            handleMessage: (channel, method, args) => {
                return this._handleMessage(channel, method, args);
            },
            handleEvent: (channel, eventName, arg) => {
                return this._handleEvent(channel, eventName, arg);
            }
        });
        this._protocol.setWorkerId(this._worker.getId());
        // Gather loader configuration
        let loaderConfiguration = null;
        const globalRequire = globalThis.require;
        if (typeof globalRequire !== 'undefined' && typeof globalRequire.getConfig === 'function') {
            // Get the configuration from the Monaco AMD Loader
            loaderConfiguration = globalRequire.getConfig();
        }
        else if (typeof globalThis.requirejs !== 'undefined') {
            // Get the configuration from requirejs
            loaderConfiguration = globalThis.requirejs.s.contexts._.config;
        }
        // Send initialize message
        this._onModuleLoaded = this._protocol.sendMessage(DEFAULT_CHANNEL, INITIALIZE, [
            this._worker.getId(),
            JSON.parse(JSON.stringify(loaderConfiguration)),
            workerDescriptor.amdModuleId,
        ]);
        this.proxy = this._protocol.createProxyToRemoteChannel(DEFAULT_CHANNEL, async () => { await this._onModuleLoaded; });
        this._onModuleLoaded.catch((e) => {
            this._onError('Worker failed to load ' + workerDescriptor.amdModuleId, e);
        });
    }
    _handleMessage(channelName, method, args) {
        const channel = this._localChannels.get(channelName);
        if (!channel) {
            return Promise.reject(new Error(`Missing channel ${channelName} on main thread`));
        }
        if (typeof channel[method] !== 'function') {
            return Promise.reject(new Error(`Missing method ${method} on main thread channel ${channelName}`));
        }
        try {
            return Promise.resolve(channel[method].apply(channel, args));
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    _handleEvent(channelName, eventName, arg) {
        const channel = this._localChannels.get(channelName);
        if (!channel) {
            throw new Error(`Missing channel ${channelName} on main thread`);
        }
        if (propertyIsDynamicEvent(eventName)) {
            const event = channel[eventName].call(channel, arg);
            if (typeof event !== 'function') {
                throw new Error(`Missing dynamic event ${eventName} on main thread channel ${channelName}.`);
            }
            return event;
        }
        if (propertyIsEvent(eventName)) {
            const event = channel[eventName];
            if (typeof event !== 'function') {
                throw new Error(`Missing event ${eventName} on main thread channel ${channelName}.`);
            }
            return event;
        }
        throw new Error(`Malformed event name ${eventName}`);
    }
    setChannel(channel, handler) {
        this._localChannels.set(channel, handler);
    }
    _onError(message, error) {
        console.error(message);
        console.info(error);
    }
}
function propertyIsEvent(name) {
    // Assume a property is an event if it has a form of "onSomething"
    return name[0] === 'o' && name[1] === 'n' && _strings_js__WEBPACK_IMPORTED_MODULE_5__.isUpperAsciiLetter(name.charCodeAt(2));
}
function propertyIsDynamicEvent(name) {
    // Assume a property is a dynamic event (a method that returns an event) if it has a form of "onDynamicSomething"
    return /^onDynamic/.test(name) && _strings_js__WEBPACK_IMPORTED_MODULE_5__.isUpperAsciiLetter(name.charCodeAt(9));
}
/**
 * Worker side
 */
class SimpleWorkerServer {
    constructor(postMessage, requestHandlerFactory) {
        this._localChannels = new Map();
        this._remoteChannels = new Map();
        this._requestHandlerFactory = requestHandlerFactory;
        this._requestHandler = null;
        this._protocol = new SimpleWorkerProtocol({
            sendMessage: (msg, transfer) => {
                postMessage(msg, transfer);
            },
            handleMessage: (channel, method, args) => this._handleMessage(channel, method, args),
            handleEvent: (channel, eventName, arg) => this._handleEvent(channel, eventName, arg)
        });
    }
    onmessage(msg) {
        this._protocol.handleMessage(msg);
    }
    _handleMessage(channel, method, args) {
        if (channel === DEFAULT_CHANNEL && method === INITIALIZE) {
            return this.initialize(args[0], args[1], args[2]);
        }
        const requestHandler = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));
        if (!requestHandler) {
            return Promise.reject(new Error(`Missing channel ${channel} on worker thread`));
        }
        if (typeof requestHandler[method] !== 'function') {
            return Promise.reject(new Error(`Missing method ${method} on worker thread channel ${channel}`));
        }
        try {
            return Promise.resolve(requestHandler[method].apply(requestHandler, args));
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    _handleEvent(channel, eventName, arg) {
        const requestHandler = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));
        if (!requestHandler) {
            throw new Error(`Missing channel ${channel} on worker thread`);
        }
        if (propertyIsDynamicEvent(eventName)) {
            const event = requestHandler[eventName].call(requestHandler, arg);
            if (typeof event !== 'function') {
                throw new Error(`Missing dynamic event ${eventName} on request handler.`);
            }
            return event;
        }
        if (propertyIsEvent(eventName)) {
            const event = requestHandler[eventName];
            if (typeof event !== 'function') {
                throw new Error(`Missing event ${eventName} on request handler.`);
            }
            return event;
        }
        throw new Error(`Malformed event name ${eventName}`);
    }
    getChannel(channel) {
        if (!this._remoteChannels.has(channel)) {
            const inst = this._protocol.createProxyToRemoteChannel(channel);
            this._remoteChannels.set(channel, inst);
        }
        return this._remoteChannels.get(channel);
    }
    async initialize(workerId, loaderConfig, moduleId) {
        this._protocol.setWorkerId(workerId);
        if (this._requestHandlerFactory) {
            // static request handler
            this._requestHandler = this._requestHandlerFactory(this);
            return;
        }
        if (loaderConfig) {
            // Remove 'baseUrl', handling it is beyond scope for now
            if (typeof loaderConfig.baseUrl !== 'undefined') {
                delete loaderConfig['baseUrl'];
            }
            if (typeof loaderConfig.paths !== 'undefined') {
                if (typeof loaderConfig.paths.vs !== 'undefined') {
                    delete loaderConfig.paths['vs'];
                }
            }
            if (typeof loaderConfig.trustedTypesPolicy !== 'undefined') {
                // don't use, it has been destroyed during serialize
                delete loaderConfig['trustedTypesPolicy'];
            }
            // Since this is in a web worker, enable catching errors
            loaderConfig.catchError = true;
            globalThis.require.config(loaderConfig);
        }
        if (isESM) {
            const url = _network_js__WEBPACK_IMPORTED_MODULE_3__.FileAccess.asBrowserUri(`${moduleId}.js`).toString(true);
            return __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/worker lazy recursive ^.*$")(`${url}`).then((module) => {
                this._requestHandler = module.create(this);
                if (!this._requestHandler) {
                    throw new Error(`No RequestHandler!`);
                }
            });
        }
        return new Promise((resolve, reject) => {
            // Use the global require to be sure to get the global config
            // ESM-comment-begin
            // 			const req = (globalThis.require || require);
            // ESM-comment-end
            // ESM-uncomment-begin
            const req = globalThis.require;
            // ESM-uncomment-end
            req([moduleId], (module) => {
                this._requestHandler = module.create(this);
                if (!this._requestHandler) {
                    reject(new Error(`No RequestHandler!`));
                    return;
                }
                resolve();
            }, reject);
        });
    }
}
/**
 * Defines the worker entry point. Must be exported and named `create`.
 * @skipMangle
 */
function create(postMessage) {
    return new SimpleWorkerServer(postMessage, null);
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/worker lazy recursive ^.*$":
/*!******************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/worker/ lazy ^.*$ namespace object ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./simpleWorker": "./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js",
	"./simpleWorker.js": "./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js"
};

function webpackAsyncContext(req) {
	return Promise.resolve().then(() => {
		if(!__webpack_require__.o(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}

		var id = map[req];
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./node_modules/monaco-editor/esm/vs/base/common/worker lazy recursive ^.*$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CharacterClassifier: () => (/* binding */ CharacterClassifier),
/* harmony export */   CharacterSet: () => (/* binding */ CharacterSet)
/* harmony export */ });
/* harmony import */ var _base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/uint.js */ "./node_modules/monaco-editor/esm/vs/base/common/uint.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * A fast character classifier that uses a compact array for ASCII values.
 */
class CharacterClassifier {
    constructor(_defaultValue) {
        const defaultValue = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(_defaultValue);
        this._defaultValue = defaultValue;
        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
        this._map = new Map();
    }
    static _createAsciiMap(defaultValue) {
        const asciiMap = new Uint8Array(256);
        asciiMap.fill(defaultValue);
        return asciiMap;
    }
    set(charCode, _value) {
        const value = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(_value);
        if (charCode >= 0 && charCode < 256) {
            this._asciiMap[charCode] = value;
        }
        else {
            this._map.set(charCode, value);
        }
    }
    get(charCode) {
        if (charCode >= 0 && charCode < 256) {
            return this._asciiMap[charCode];
        }
        else {
            return (this._map.get(charCode) || this._defaultValue);
        }
    }
    clear() {
        this._asciiMap.fill(this._defaultValue);
        this._map.clear();
    }
}
class CharacterSet {
    constructor() {
        this._actual = new CharacterClassifier(0 /* Boolean.False */);
    }
    add(charCode) {
        this._actual.set(charCode, 1 /* Boolean.True */);
    }
    has(charCode) {
        return (this._actual.get(charCode) === 1 /* Boolean.True */);
    }
    clear() {
        return this._actual.clear();
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js":
/*!***************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineRange: () => (/* binding */ LineRange),
/* harmony export */   LineRangeSet: () => (/* binding */ LineRangeSet)
/* harmony export */ });
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _offsetRange_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./offsetRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js");
/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/arraysFind.js */ "./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




/**
 * A range of lines (1-based).
 */
class LineRange {
    static fromRangeInclusive(range) {
        return new LineRange(range.startLineNumber, range.endLineNumber + 1);
    }
    /**
     * @param lineRanges An array of sorted line ranges.
     */
    static joinMany(lineRanges) {
        if (lineRanges.length === 0) {
            return [];
        }
        let result = new LineRangeSet(lineRanges[0].slice());
        for (let i = 1; i < lineRanges.length; i++) {
            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));
        }
        return result.ranges;
    }
    static join(lineRanges) {
        if (lineRanges.length === 0) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('lineRanges cannot be empty');
        }
        let startLineNumber = lineRanges[0].startLineNumber;
        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;
        for (let i = 1; i < lineRanges.length; i++) {
            startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);
            endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);
        }
        return new LineRange(startLineNumber, endLineNumberExclusive);
    }
    static ofLength(startLineNumber, length) {
        return new LineRange(startLineNumber, startLineNumber + length);
    }
    /**
     * @internal
     */
    static deserialize(lineRange) {
        return new LineRange(lineRange[0], lineRange[1]);
    }
    constructor(startLineNumber, endLineNumberExclusive) {
        if (startLineNumber > endLineNumberExclusive) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
        }
        this.startLineNumber = startLineNumber;
        this.endLineNumberExclusive = endLineNumberExclusive;
    }
    /**
     * Indicates if this line range contains the given line number.
     */
    contains(lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    /**
     * Indicates if this line range is empty.
     */
    get isEmpty() {
        return this.startLineNumber === this.endLineNumberExclusive;
    }
    /**
     * Moves this line range by the given offset of line numbers.
     */
    delta(offset) {
        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
    }
    deltaLength(offset) {
        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);
    }
    /**
     * The number of lines this line range spans.
     */
    get length() {
        return this.endLineNumberExclusive - this.startLineNumber;
    }
    /**
     * Creates a line range that combines this and the given line range.
     */
    join(other) {
        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
    }
    toString() {
        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
    }
    /**
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
        if (startLineNumber <= endLineNumberExclusive) {
            return new LineRange(startLineNumber, endLineNumberExclusive);
        }
        return undefined;
    }
    intersectsStrict(other) {
        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
    }
    overlapOrTouch(other) {
        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
    }
    equals(b) {
        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;
    }
    toInclusiveRange() {
        if (this.isEmpty) {
            return null;
        }
        return new _range_js__WEBPACK_IMPORTED_MODULE_2__.Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
    }
    /**
     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!
    */
    toExclusiveRange() {
        return new _range_js__WEBPACK_IMPORTED_MODULE_2__.Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
    }
    mapToLineArray(f) {
        const result = [];
        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
            result.push(f(lineNumber));
        }
        return result;
    }
    forEach(f) {
        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
            f(lineNumber);
        }
    }
    /**
     * @internal
     */
    serialize() {
        return [this.startLineNumber, this.endLineNumberExclusive];
    }
    includes(lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    /**
     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
     * @internal
     */
    toOffsetRange() {
        return new _offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
    }
}
class LineRangeSet {
    constructor(
    /**
     * Sorted by start line number.
     * No two line ranges are touching or intersecting.
     */
    _normalizedRanges = []) {
        this._normalizedRanges = _normalizedRanges;
    }
    get ranges() {
        return this._normalizedRanges;
    }
    addRange(range) {
        if (range.length === 0) {
            return;
        }
        // Idea: Find joinRange such that:
        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))
        // idx of first element that touches range or that is after range
        const joinRangeStartIdx = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findFirstIdxMonotonousOrArrLen)(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);
        // idx of element after { last element that touches range or that is before range }
        const joinRangeEndIdxExclusive = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastIdxMonotonous)(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;
        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range
            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);
        }
        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {
            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it
            const joinRange = this._normalizedRanges[joinRangeStartIdx];
            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);
        }
        else {
            // First and last element are different - we need to replace the entire range
            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);
            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);
        }
    }
    contains(lineNumber) {
        const rangeThatStartsBeforeEnd = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastMonotonous)(this._normalizedRanges, r => r.startLineNumber <= lineNumber);
        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;
    }
    intersects(range) {
        const rangeThatStartsBeforeEnd = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastMonotonous)(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);
        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;
    }
    getUnion(other) {
        if (this._normalizedRanges.length === 0) {
            return other;
        }
        if (other._normalizedRanges.length === 0) {
            return this;
        }
        const result = [];
        let i1 = 0;
        let i2 = 0;
        let current = null;
        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {
            let next = null;
            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
                const lineRange1 = this._normalizedRanges[i1];
                const lineRange2 = other._normalizedRanges[i2];
                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {
                    next = lineRange1;
                    i1++;
                }
                else {
                    next = lineRange2;
                    i2++;
                }
            }
            else if (i1 < this._normalizedRanges.length) {
                next = this._normalizedRanges[i1];
                i1++;
            }
            else {
                next = other._normalizedRanges[i2];
                i2++;
            }
            if (current === null) {
                current = next;
            }
            else {
                if (current.endLineNumberExclusive >= next.startLineNumber) {
                    // merge
                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));
                }
                else {
                    // push
                    result.push(current);
                    current = next;
                }
            }
        }
        if (current !== null) {
            result.push(current);
        }
        return new LineRangeSet(result);
    }
    /**
     * Subtracts all ranges in this set from `range` and returns the result.
     */
    subtractFrom(range) {
        // idx of first element that touches range or that is after range
        const joinRangeStartIdx = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findFirstIdxMonotonousOrArrLen)(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);
        // idx of element after { last element that touches range or that is before range }
        const joinRangeEndIdxExclusive = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastIdxMonotonous)(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;
        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
            return new LineRangeSet([range]);
        }
        const result = [];
        let startLineNumber = range.startLineNumber;
        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {
            const r = this._normalizedRanges[i];
            if (r.startLineNumber > startLineNumber) {
                result.push(new LineRange(startLineNumber, r.startLineNumber));
            }
            startLineNumber = r.endLineNumberExclusive;
        }
        if (startLineNumber < range.endLineNumberExclusive) {
            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));
        }
        return new LineRangeSet(result);
    }
    toString() {
        return this._normalizedRanges.map(r => r.toString()).join(', ');
    }
    getIntersection(other) {
        const result = [];
        let i1 = 0;
        let i2 = 0;
        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
            const r1 = this._normalizedRanges[i1];
            const r2 = other._normalizedRanges[i2];
            const i = r1.intersect(r2);
            if (i && !i.isEmpty) {
                result.push(i);
            }
            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {
                i1++;
            }
            else {
                i2++;
            }
        }
        return new LineRangeSet(result);
    }
    getWithDelta(value) {
        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OffsetRange: () => (/* binding */ OffsetRange),
/* harmony export */   OffsetRangeSet: () => (/* binding */ OffsetRangeSet)
/* harmony export */ });
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * A range of offsets (0-based).
*/
class OffsetRange {
    static addRange(range, sortedRanges) {
        let i = 0;
        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {
            i++;
        }
        let j = i;
        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {
            j++;
        }
        if (i === j) {
            sortedRanges.splice(i, 0, range);
        }
        else {
            const start = Math.min(range.start, sortedRanges[i].start);
            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);
            sortedRanges.splice(i, j - i, new OffsetRange(start, end));
        }
    }
    static tryCreate(start, endExclusive) {
        if (start > endExclusive) {
            return undefined;
        }
        return new OffsetRange(start, endExclusive);
    }
    static ofLength(length) {
        return new OffsetRange(0, length);
    }
    static ofStartAndLength(start, length) {
        return new OffsetRange(start, start + length);
    }
    constructor(start, endExclusive) {
        this.start = start;
        this.endExclusive = endExclusive;
        if (start > endExclusive) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError(`Invalid range: ${this.toString()}`);
        }
    }
    get isEmpty() {
        return this.start === this.endExclusive;
    }
    delta(offset) {
        return new OffsetRange(this.start + offset, this.endExclusive + offset);
    }
    deltaStart(offset) {
        return new OffsetRange(this.start + offset, this.endExclusive);
    }
    deltaEnd(offset) {
        return new OffsetRange(this.start, this.endExclusive + offset);
    }
    get length() {
        return this.endExclusive - this.start;
    }
    toString() {
        return `[${this.start}, ${this.endExclusive})`;
    }
    contains(offset) {
        return this.start <= offset && offset < this.endExclusive;
    }
    /**
     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
     * The joined range is the smallest range that contains both ranges.
     */
    join(other) {
        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
    }
    /**
     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
     *
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
        const start = Math.max(this.start, other.start);
        const end = Math.min(this.endExclusive, other.endExclusive);
        if (start <= end) {
            return new OffsetRange(start, end);
        }
        return undefined;
    }
    intersects(other) {
        const start = Math.max(this.start, other.start);
        const end = Math.min(this.endExclusive, other.endExclusive);
        return start < end;
    }
    isBefore(other) {
        return this.endExclusive <= other.start;
    }
    isAfter(other) {
        return this.start >= other.endExclusive;
    }
    slice(arr) {
        return arr.slice(this.start, this.endExclusive);
    }
    substring(str) {
        return str.substring(this.start, this.endExclusive);
    }
    /**
     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
     * The range must not be empty.
     */
    clip(value) {
        if (this.isEmpty) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
        }
        return Math.max(this.start, Math.min(this.endExclusive - 1, value));
    }
    /**
     * Returns `r := value + k * length` such that `r` is contained in this range.
     * The range must not be empty.
     *
     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
     */
    clipCyclic(value) {
        if (this.isEmpty) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
        }
        if (value < this.start) {
            return this.endExclusive - ((this.start - value) % this.length);
        }
        if (value >= this.endExclusive) {
            return this.start + ((value - this.start) % this.length);
        }
        return value;
    }
    forEach(f) {
        for (let i = this.start; i < this.endExclusive; i++) {
            f(i);
        }
    }
}
class OffsetRangeSet {
    constructor() {
        this._sortedRanges = [];
    }
    addRange(range) {
        let i = 0;
        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {
            i++;
        }
        let j = i;
        while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {
            j++;
        }
        if (i === j) {
            this._sortedRanges.splice(i, 0, range);
        }
        else {
            const start = Math.min(range.start, this._sortedRanges[i].start);
            const end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);
            this._sortedRanges.splice(i, j - i, new OffsetRange(start, end));
        }
    }
    toString() {
        return this._sortedRanges.map(r => r.toString()).join(', ');
    }
    /**
     * Returns of there is a value that is contained in this instance and the given range.
     */
    intersectsStrict(other) {
        // TODO use binary search
        let i = 0;
        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {
            i++;
        }
        return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;
    }
    intersectWithRange(other) {
        // TODO use binary search + slice
        const result = new OffsetRangeSet();
        for (const range of this._sortedRanges) {
            const intersection = range.intersect(other);
            if (intersection) {
                result.addRange(intersection);
            }
        }
        return result;
    }
    intersectWithRangeLength(other) {
        return this.intersectWithRange(other).length;
    }
    get length() {
        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/position.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Position: () => (/* binding */ Position)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * A position in the editor.
 */
class Position {
    constructor(lineNumber, column) {
        this.lineNumber = lineNumber;
        this.column = column;
    }
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    with(newLineNumber = this.lineNumber, newColumn = this.column) {
        if (newLineNumber === this.lineNumber && newColumn === this.column) {
            return this;
        }
        else {
            return new Position(newLineNumber, newColumn);
        }
    }
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    delta(deltaLineNumber = 0, deltaColumn = 0) {
        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
    }
    /**
     * Test if this position equals other position
     */
    equals(other) {
        return Position.equals(this, other);
    }
    /**
     * Test if position `a` equals position `b`
     */
    static equals(a, b) {
        if (!a && !b) {
            return true;
        }
        return (!!a &&
            !!b &&
            a.lineNumber === b.lineNumber &&
            a.column === b.column);
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    isBefore(other) {
        return Position.isBefore(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    static isBefore(a, b) {
        if (a.lineNumber < b.lineNumber) {
            return true;
        }
        if (b.lineNumber < a.lineNumber) {
            return false;
        }
        return a.column < b.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    isBeforeOrEqual(other) {
        return Position.isBeforeOrEqual(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    static isBeforeOrEqual(a, b) {
        if (a.lineNumber < b.lineNumber) {
            return true;
        }
        if (b.lineNumber < a.lineNumber) {
            return false;
        }
        return a.column <= b.column;
    }
    /**
     * A function that compares positions, useful for sorting
     */
    static compare(a, b) {
        const aLineNumber = a.lineNumber | 0;
        const bLineNumber = b.lineNumber | 0;
        if (aLineNumber === bLineNumber) {
            const aColumn = a.column | 0;
            const bColumn = b.column | 0;
            return aColumn - bColumn;
        }
        return aLineNumber - bLineNumber;
    }
    /**
     * Clone this position.
     */
    clone() {
        return new Position(this.lineNumber, this.column);
    }
    /**
     * Convert to a human-readable representation.
     */
    toString() {
        return '(' + this.lineNumber + ',' + this.column + ')';
    }
    // ---
    /**
     * Create a `Position` from an `IPosition`.
     */
    static lift(pos) {
        return new Position(pos.lineNumber, pos.column);
    }
    /**
     * Test if `obj` is an `IPosition`.
     */
    static isIPosition(obj) {
        return (obj
            && (typeof obj.lineNumber === 'number')
            && (typeof obj.column === 'number'));
    }
    toJSON() {
        return {
            lineNumber: this.lineNumber,
            column: this.column
        };
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PositionOffsetTransformer: () => (/* binding */ PositionOffsetTransformer)
/* harmony export */ });
/* harmony import */ var _offsetRange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./offsetRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js");
/* harmony import */ var _textLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./textLength.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js");


class PositionOffsetTransformer {
    constructor(text) {
        this.text = text;
        this.lineStartOffsetByLineIdx = [];
        this.lineStartOffsetByLineIdx.push(0);
        for (let i = 0; i < text.length; i++) {
            if (text.charAt(i) === '\n') {
                this.lineStartOffsetByLineIdx.push(i + 1);
            }
        }
    }
    getOffset(position) {
        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;
    }
    getOffsetRange(range) {
        return new _offsetRange_js__WEBPACK_IMPORTED_MODULE_0__.OffsetRange(this.getOffset(range.getStartPosition()), this.getOffset(range.getEndPosition()));
    }
    get textLength() {
        const lineIdx = this.lineStartOffsetByLineIdx.length - 1;
        return new _textLength_js__WEBPACK_IMPORTED_MODULE_1__.TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/range.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Range: () => (/* binding */ Range)
/* harmony export */ });
/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
 */
class Range {
    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {
            this.startLineNumber = endLineNumber;
            this.startColumn = endColumn;
            this.endLineNumber = startLineNumber;
            this.endColumn = startColumn;
        }
        else {
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
        }
    }
    /**
     * Test if this range is empty.
     */
    isEmpty() {
        return Range.isEmpty(this);
    }
    /**
     * Test if `range` is empty.
     */
    static isEmpty(range) {
        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);
    }
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    containsPosition(position) {
        return Range.containsPosition(this, position);
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    static containsPosition(range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
            return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return false.
     * @internal
     */
    static strictContainsPosition(range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
            return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    containsRange(range) {
        return Range.containsRange(this, range);
    }
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
            return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    strictContainsRange(range) {
        return Range.strictContainsRange(this, range);
    }
    /**
     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    static strictContainsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
            return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    plusRange(range) {
        return Range.plusRange(this, range);
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    static plusRange(a, b) {
        let startLineNumber;
        let startColumn;
        let endLineNumber;
        let endColumn;
        if (b.startLineNumber < a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = b.startColumn;
        }
        else if (b.startLineNumber === a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = Math.min(b.startColumn, a.startColumn);
        }
        else {
            startLineNumber = a.startLineNumber;
            startColumn = a.startColumn;
        }
        if (b.endLineNumber > a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = b.endColumn;
        }
        else if (b.endLineNumber === a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = Math.max(b.endColumn, a.endColumn);
        }
        else {
            endLineNumber = a.endLineNumber;
            endColumn = a.endColumn;
        }
        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    /**
     * A intersection of the two ranges.
     */
    intersectRanges(range) {
        return Range.intersectRanges(this, range);
    }
    /**
     * A intersection of the two ranges.
     */
    static intersectRanges(a, b) {
        let resultStartLineNumber = a.startLineNumber;
        let resultStartColumn = a.startColumn;
        let resultEndLineNumber = a.endLineNumber;
        let resultEndColumn = a.endColumn;
        const otherStartLineNumber = b.startLineNumber;
        const otherStartColumn = b.startColumn;
        const otherEndLineNumber = b.endLineNumber;
        const otherEndColumn = b.endColumn;
        if (resultStartLineNumber < otherStartLineNumber) {
            resultStartLineNumber = otherStartLineNumber;
            resultStartColumn = otherStartColumn;
        }
        else if (resultStartLineNumber === otherStartLineNumber) {
            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
        }
        if (resultEndLineNumber > otherEndLineNumber) {
            resultEndLineNumber = otherEndLineNumber;
            resultEndColumn = otherEndColumn;
        }
        else if (resultEndLineNumber === otherEndLineNumber) {
            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
        }
        // Check if selection is now empty
        if (resultStartLineNumber > resultEndLineNumber) {
            return null;
        }
        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
            return null;
        }
        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
    }
    /**
     * Test if this range equals other.
     */
    equalsRange(other) {
        return Range.equalsRange(this, other);
    }
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a, b) {
        if (!a && !b) {
            return true;
        }
        return (!!a &&
            !!b &&
            a.startLineNumber === b.startLineNumber &&
            a.startColumn === b.startColumn &&
            a.endLineNumber === b.endLineNumber &&
            a.endColumn === b.endColumn);
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    getEndPosition() {
        return Range.getEndPosition(this);
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    static getEndPosition(range) {
        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(range.endLineNumber, range.endColumn);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    getStartPosition() {
        return Range.getStartPosition(this);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    static getStartPosition(range) {
        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(range.startLineNumber, range.startColumn);
    }
    /**
     * Transform to a user presentable string representation.
     */
    toString() {
        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';
    }
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    setEndPosition(endLineNumber, endColumn) {
        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    setStartPosition(startLineNumber, startColumn) {
        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    collapseToStart() {
        return Range.collapseToStart(this);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    static collapseToStart(range) {
        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    collapseToEnd() {
        return Range.collapseToEnd(this);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    static collapseToEnd(range) {
        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Moves the range by the given amount of lines.
     */
    delta(lineCount) {
        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
    }
    // ---
    static fromPositions(start, end = start) {
        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    static lift(range) {
        if (!range) {
            return null;
        }
        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Test if `obj` is an `IRange`.
     */
    static isIRange(obj) {
        return (obj
            && (typeof obj.startLineNumber === 'number')
            && (typeof obj.startColumn === 'number')
            && (typeof obj.endLineNumber === 'number')
            && (typeof obj.endColumn === 'number'));
    }
    /**
     * Test if the two ranges are touching in any way.
     */
    static areIntersectingOrTouching(a, b) {
        // Check if `a` is before `b`
        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {
            return false;
        }
        // Check if `b` is before `a`
        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {
            return false;
        }
        // These ranges must intersect
        return true;
    }
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    static areIntersecting(a, b) {
        // Check if `a` is before `b`
        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {
            return false;
        }
        // Check if `b` is before `a`
        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {
            return false;
        }
        // These ranges must intersect
        return true;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    static compareRangesUsingStarts(a, b) {
        if (a && b) {
            const aStartLineNumber = a.startLineNumber | 0;
            const bStartLineNumber = b.startLineNumber | 0;
            if (aStartLineNumber === bStartLineNumber) {
                const aStartColumn = a.startColumn | 0;
                const bStartColumn = b.startColumn | 0;
                if (aStartColumn === bStartColumn) {
                    const aEndLineNumber = a.endLineNumber | 0;
                    const bEndLineNumber = b.endLineNumber | 0;
                    if (aEndLineNumber === bEndLineNumber) {
                        const aEndColumn = a.endColumn | 0;
                        const bEndColumn = b.endColumn | 0;
                        return aEndColumn - bEndColumn;
                    }
                    return aEndLineNumber - bEndLineNumber;
                }
                return aStartColumn - bStartColumn;
            }
            return aStartLineNumber - bStartLineNumber;
        }
        const aExists = (a ? 1 : 0);
        const bExists = (b ? 1 : 0);
        return aExists - bExists;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    static compareRangesUsingEnds(a, b) {
        if (a.endLineNumber === b.endLineNumber) {
            if (a.endColumn === b.endColumn) {
                if (a.startLineNumber === b.startLineNumber) {
                    return a.startColumn - b.startColumn;
                }
                return a.startLineNumber - b.startLineNumber;
            }
            return a.endColumn - b.endColumn;
        }
        return a.endLineNumber - b.endLineNumber;
    }
    /**
     * Test if the range spans multiple lines.
     */
    static spansMultipleLines(range) {
        return range.endLineNumber > range.startLineNumber;
    }
    toJSON() {
        return this;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js":
/*!***************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection)
/* harmony export */ });
/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * A selection in the editor.
 * The selection is a range that has an orientation.
 */
class Selection extends _range_js__WEBPACK_IMPORTED_MODULE_1__.Range {
    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
        this.selectionStartLineNumber = selectionStartLineNumber;
        this.selectionStartColumn = selectionStartColumn;
        this.positionLineNumber = positionLineNumber;
        this.positionColumn = positionColumn;
    }
    /**
     * Transform to a human-readable representation.
     */
    toString() {
        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';
    }
    /**
     * Test if equals other selection.
     */
    equalsSelection(other) {
        return (Selection.selectionsEqual(this, other));
    }
    /**
     * Test if the two selections are equal.
     */
    static selectionsEqual(a, b) {
        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&
            a.selectionStartColumn === b.selectionStartColumn &&
            a.positionLineNumber === b.positionLineNumber &&
            a.positionColumn === b.positionColumn);
    }
    /**
     * Get directions (LTR or RTL).
     */
    getDirection() {
        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
            return 0 /* SelectionDirection.LTR */;
        }
        return 1 /* SelectionDirection.RTL */;
    }
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    setEndPosition(endLineNumber, endColumn) {
        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {
            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        }
        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
    }
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    getPosition() {
        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(this.positionLineNumber, this.positionColumn);
    }
    /**
     * Get the position at the start of the selection.
    */
    getSelectionStart() {
        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(this.selectionStartLineNumber, this.selectionStartColumn);
    }
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    setStartPosition(startLineNumber, startColumn) {
        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {
            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        }
        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
    }
    // ----
    /**
     * Create a `Selection` from one or two positions
     */
    static fromPositions(start, end = start) {
        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    /**
     * Creates a `Selection` from a range, given a direction.
     */
    static fromRange(range, direction) {
        if (direction === 0 /* SelectionDirection.LTR */) {
            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        }
        else {
            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
        }
    }
    /**
     * Create a `Selection` from an `ISelection`.
     */
    static liftSelection(sel) {
        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
    }
    /**
     * `a` equals `b`.
     */
    static selectionsArrEqual(a, b) {
        if (a && !b || !a && b) {
            return false;
        }
        if (!a && !b) {
            return true;
        }
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0, len = a.length; i < len; i++) {
            if (!this.selectionsEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Test if `obj` is an `ISelection`.
     */
    static isISelection(obj) {
        return (obj
            && (typeof obj.selectionStartLineNumber === 'number')
            && (typeof obj.selectionStartColumn === 'number')
            && (typeof obj.positionLineNumber === 'number')
            && (typeof obj.positionColumn === 'number'));
    }
    /**
     * Create with a direction.
     */
    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
        if (direction === 0 /* SelectionDirection.LTR */) {
            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractText: () => (/* binding */ AbstractText),
/* harmony export */   SingleTextEdit: () => (/* binding */ SingleTextEdit),
/* harmony export */   StringText: () => (/* binding */ StringText),
/* harmony export */   TextEdit: () => (/* binding */ TextEdit)
/* harmony export */ });
/* harmony import */ var _base_common_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/assert.js */ "./node_modules/monaco-editor/esm/vs/base/common/assert.js");
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _positionToOffset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./positionToOffset.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js");
/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _textLength_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./textLength.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






class TextEdit {
    constructor(edits) {
        this.edits = edits;
        (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertFn)(() => (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_0__.checkAdjacentItems)(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));
    }
    apply(text) {
        let result = '';
        let lastEditEnd = new _position_js__WEBPACK_IMPORTED_MODULE_2__.Position(1, 1);
        for (const edit of this.edits) {
            const editRange = edit.range;
            const editStart = editRange.getStartPosition();
            const editEnd = editRange.getEndPosition();
            const r = rangeFromPositions(lastEditEnd, editStart);
            if (!r.isEmpty()) {
                result += text.getValueOfRange(r);
            }
            result += edit.text;
            lastEditEnd = editEnd;
        }
        const r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);
        if (!r.isEmpty()) {
            result += text.getValueOfRange(r);
        }
        return result;
    }
    applyToString(str) {
        const strText = new StringText(str);
        return this.apply(strText);
    }
    getNewRanges() {
        const newRanges = [];
        let previousEditEndLineNumber = 0;
        let lineOffset = 0;
        let columnOffset = 0;
        for (const edit of this.edits) {
            const textLength = _textLength_js__WEBPACK_IMPORTED_MODULE_5__.TextLength.ofText(edit.text);
            const newRangeStart = _position_js__WEBPACK_IMPORTED_MODULE_2__.Position.lift({
                lineNumber: edit.range.startLineNumber + lineOffset,
                column: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)
            });
            const newRange = textLength.createRange(newRangeStart);
            newRanges.push(newRange);
            lineOffset = newRange.endLineNumber - edit.range.endLineNumber;
            columnOffset = newRange.endColumn - edit.range.endColumn;
            previousEditEndLineNumber = edit.range.endLineNumber;
        }
        return newRanges;
    }
}
class SingleTextEdit {
    constructor(range, text) {
        this.range = range;
        this.text = text;
    }
    toSingleEditOperation() {
        return {
            range: this.range,
            text: this.text,
        };
    }
}
function rangeFromPositions(start, end) {
    if (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {
        return _range_js__WEBPACK_IMPORTED_MODULE_4__.Range.fromPositions(end, end);
    }
    else if (!start.isBeforeOrEqual(end)) {
        throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError('start must be before end');
    }
    return new _range_js__WEBPACK_IMPORTED_MODULE_4__.Range(start.lineNumber, start.column, end.lineNumber, end.column);
}
class AbstractText {
    get endPositionExclusive() {
        return this.length.addToPosition(new _position_js__WEBPACK_IMPORTED_MODULE_2__.Position(1, 1));
    }
}
class StringText extends AbstractText {
    constructor(value) {
        super();
        this.value = value;
        this._t = new _positionToOffset_js__WEBPACK_IMPORTED_MODULE_3__.PositionOffsetTransformer(this.value);
    }
    getValueOfRange(range) {
        return this._t.getOffsetRange(range).substring(this.value);
    }
    get length() {
        return this._t.textLength;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextLength: () => (/* binding */ TextLength)
/* harmony export */ });
/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * Represents a non-negative length of text in terms of line and column count.
*/
class TextLength {
    static { this.zero = new TextLength(0, 0); }
    static betweenPositions(position1, position2) {
        if (position1.lineNumber === position2.lineNumber) {
            return new TextLength(0, position2.column - position1.column);
        }
        else {
            return new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);
        }
    }
    static ofRange(range) {
        return TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());
    }
    static ofText(text) {
        let line = 0;
        let column = 0;
        for (const c of text) {
            if (c === '\n') {
                line++;
                column = 0;
            }
            else {
                column++;
            }
        }
        return new TextLength(line, column);
    }
    constructor(lineCount, columnCount) {
        this.lineCount = lineCount;
        this.columnCount = columnCount;
    }
    isGreaterThanOrEqualTo(other) {
        if (this.lineCount !== other.lineCount) {
            return this.lineCount > other.lineCount;
        }
        return this.columnCount >= other.columnCount;
    }
    createRange(startPosition) {
        if (this.lineCount === 0) {
            return new _range_js__WEBPACK_IMPORTED_MODULE_1__.Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);
        }
        else {
            return new _range_js__WEBPACK_IMPORTED_MODULE_1__.Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);
        }
    }
    addToPosition(position) {
        if (this.lineCount === 0) {
            return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(position.lineNumber, position.column + this.columnCount);
        }
        else {
            return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(position.lineNumber + this.lineCount, this.columnCount + 1);
        }
    }
    toString() {
        return `${this.lineCount},${this.columnCount}`;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WordCharacterClassifier: () => (/* binding */ WordCharacterClassifier),
/* harmony export */   getMapForWordSeparators: () => (/* binding */ getMapForWordSeparators)
/* harmony export */ });
/* harmony import */ var _base_common_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/map.js */ "./node_modules/monaco-editor/esm/vs/base/common/map.js");
/* harmony import */ var _characterClassifier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./characterClassifier.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


class WordCharacterClassifier extends _characterClassifier_js__WEBPACK_IMPORTED_MODULE_1__.CharacterClassifier {
    constructor(wordSeparators, intlSegmenterLocales) {
        super(0 /* WordCharacterClass.Regular */);
        this._segmenter = null;
        this._cachedLine = null;
        this._cachedSegments = [];
        this.intlSegmenterLocales = intlSegmenterLocales;
        if (this.intlSegmenterLocales.length > 0) {
            this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });
        }
        else {
            this._segmenter = null;
        }
        for (let i = 0, len = wordSeparators.length; i < len; i++) {
            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);
        }
        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);
        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);
    }
    findPrevIntlWordBeforeOrAtOffset(line, offset) {
        let candidate = null;
        for (const segment of this._getIntlSegmenterWordsOnLine(line)) {
            if (segment.index > offset) {
                break;
            }
            candidate = segment;
        }
        return candidate;
    }
    findNextIntlWordAtOrAfterOffset(lineContent, offset) {
        for (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {
            if (segment.index < offset) {
                continue;
            }
            return segment;
        }
        return null;
    }
    _getIntlSegmenterWordsOnLine(line) {
        if (!this._segmenter) {
            return [];
        }
        // Check if the line has changed from the previous call
        if (this._cachedLine === line) {
            return this._cachedSegments;
        }
        // Update the cache with the new line
        this._cachedLine = line;
        this._cachedSegments = this._filterWordSegments(this._segmenter.segment(line));
        return this._cachedSegments;
    }
    _filterWordSegments(segments) {
        const result = [];
        for (const segment of segments) {
            if (this._isWordLike(segment)) {
                result.push(segment);
            }
        }
        return result;
    }
    _isWordLike(segment) {
        if (segment.isWordLike) {
            return true;
        }
        return false;
    }
}
const wordClassifierCache = new _base_common_map_js__WEBPACK_IMPORTED_MODULE_0__.LRUCache(10);
function getMapForWordSeparators(wordSeparators, intlSegmenterLocales) {
    const key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;
    let result = wordClassifierCache.get(key);
    if (!result) {
        result = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);
        wordClassifierCache.set(key, result);
    }
    return result;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_WORD_REGEXP: () => (/* binding */ DEFAULT_WORD_REGEXP),
/* harmony export */   USUAL_WORD_SEPARATORS: () => (/* binding */ USUAL_WORD_SEPARATORS),
/* harmony export */   ensureValidWordDefinition: () => (/* binding */ ensureValidWordDefinition),
/* harmony export */   getWordAtText: () => (/* binding */ getWordAtText)
/* harmony export */ });
/* harmony import */ var _base_common_iterator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/iterator.js */ "./node_modules/monaco-editor/esm/vs/base/common/iterator.js");
/* harmony import */ var _base_common_linkedList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/linkedList.js */ "./node_modules/monaco-editor/esm/vs/base/common/linkedList.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
/**
 * Create a word definition regular expression based on default word separators.
 * Optionally provide allowed separators that should be included in words.
 *
 * The default would look like this:
 * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
 */
function createWordRegExp(allowInWords = '') {
    let source = '(-?\\d*\\.\\d\\w*)|([^';
    for (const sep of USUAL_WORD_SEPARATORS) {
        if (allowInWords.indexOf(sep) >= 0) {
            continue;
        }
        source += '\\' + sep;
    }
    source += '\\s]+)';
    return new RegExp(source, 'g');
}
// catches numbers (including floating numbers) in the first group, and alphanum in the second
const DEFAULT_WORD_REGEXP = createWordRegExp();
function ensureValidWordDefinition(wordDefinition) {
    let result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && (wordDefinition instanceof RegExp)) {
        if (!wordDefinition.global) {
            let flags = 'g';
            if (wordDefinition.ignoreCase) {
                flags += 'i';
            }
            if (wordDefinition.multiline) {
                flags += 'm';
            }
            if (wordDefinition.unicode) {
                flags += 'u';
            }
            result = new RegExp(wordDefinition.source, flags);
        }
        else {
            result = wordDefinition;
        }
    }
    result.lastIndex = 0;
    return result;
}
const _defaultConfig = new _base_common_linkedList_js__WEBPACK_IMPORTED_MODULE_1__.LinkedList();
_defaultConfig.unshift({
    maxLen: 1000,
    windowSize: 15,
    timeBudget: 150
});
function getWordAtText(column, wordDefinition, text, textOffset, config) {
    // Ensure the regex has the 'g' flag, otherwise this will loop forever
    wordDefinition = ensureValidWordDefinition(wordDefinition);
    if (!config) {
        config = _base_common_iterator_js__WEBPACK_IMPORTED_MODULE_0__.Iterable.first(_defaultConfig);
    }
    if (text.length > config.maxLen) {
        // don't throw strings that long at the regexp
        // but use a sub-string in which a word must occur
        let start = column - config.maxLen / 2;
        if (start < 0) {
            start = 0;
        }
        else {
            textOffset += start;
        }
        text = text.substring(start, column + config.maxLen / 2);
        return getWordAtText(column, wordDefinition, text, textOffset, config);
    }
    const t1 = Date.now();
    const pos = column - 1 - textOffset;
    let prevRegexIndex = -1;
    let match = null;
    for (let i = 1;; i++) {
        // check time budget
        if (Date.now() - t1 >= config.timeBudget) {
            break;
        }
        // reset the index at which the regexp should start matching, also know where it
        // should stop so that subsequent search don't repeat previous searches
        const regexIndex = pos - config.windowSize * i;
        wordDefinition.lastIndex = Math.max(0, regexIndex);
        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
        if (!thisMatch && match) {
            // stop: we have something
            break;
        }
        match = thisMatch;
        // stop: searched at start
        if (regexIndex <= 0) {
            break;
        }
        prevRegexIndex = regexIndex;
    }
    if (match) {
        const result = {
            word: match[0],
            startColumn: textOffset + 1 + match.index,
            endColumn: textOffset + 1 + match.index + match[0].length
        };
        wordDefinition.lastIndex = 0;
        return result;
    }
    return null;
}
function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
    let match;
    while (match = wordDefinition.exec(text)) {
        const matchIndex = match.index || 0;
        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
            return match;
        }
        else if (stopPos > 0 && matchIndex > stopPos) {
            return null;
        }
    }
    return null;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DateTimeout: () => (/* binding */ DateTimeout),
/* harmony export */   DiffAlgorithmResult: () => (/* binding */ DiffAlgorithmResult),
/* harmony export */   InfiniteTimeout: () => (/* binding */ InfiniteTimeout),
/* harmony export */   OffsetPair: () => (/* binding */ OffsetPair),
/* harmony export */   SequenceDiff: () => (/* binding */ SequenceDiff)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/offsetRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class DiffAlgorithmResult {
    static trivial(seq1, seq2) {
        return new DiffAlgorithmResult([new SequenceDiff(_core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange.ofLength(seq1.length), _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange.ofLength(seq2.length))], false);
    }
    static trivialTimedOut(seq1, seq2) {
        return new DiffAlgorithmResult([new SequenceDiff(_core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange.ofLength(seq1.length), _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange.ofLength(seq2.length))], true);
    }
    constructor(diffs, 
    /**
     * Indicates if the time out was reached.
     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.
     */
    hitTimeout) {
        this.diffs = diffs;
        this.hitTimeout = hitTimeout;
    }
}
class SequenceDiff {
    static invert(sequenceDiffs, doc1Length) {
        const result = [];
        (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.forEachAdjacent)(sequenceDiffs, (a, b) => {
            result.push(SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));
        });
        return result;
    }
    static fromOffsetPairs(start, endExclusive) {
        return new SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange(start.offset1, endExclusive.offset1), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange(start.offset2, endExclusive.offset2));
    }
    static assertSorted(sequenceDiffs) {
        let last = undefined;
        for (const cur of sequenceDiffs) {
            if (last) {
                if (!(last.seq1Range.endExclusive <= cur.seq1Range.start && last.seq2Range.endExclusive <= cur.seq2Range.start)) {
                    throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError('Sequence diffs must be sorted');
                }
            }
            last = cur;
        }
    }
    constructor(seq1Range, seq2Range) {
        this.seq1Range = seq1Range;
        this.seq2Range = seq2Range;
    }
    swap() {
        return new SequenceDiff(this.seq2Range, this.seq1Range);
    }
    toString() {
        return `${this.seq1Range} <-> ${this.seq2Range}`;
    }
    join(other) {
        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));
    }
    delta(offset) {
        if (offset === 0) {
            return this;
        }
        return new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));
    }
    deltaStart(offset) {
        if (offset === 0) {
            return this;
        }
        return new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));
    }
    deltaEnd(offset) {
        if (offset === 0) {
            return this;
        }
        return new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));
    }
    intersect(other) {
        const i1 = this.seq1Range.intersect(other.seq1Range);
        const i2 = this.seq2Range.intersect(other.seq2Range);
        if (!i1 || !i2) {
            return undefined;
        }
        return new SequenceDiff(i1, i2);
    }
    getStarts() {
        return new OffsetPair(this.seq1Range.start, this.seq2Range.start);
    }
    getEndExclusives() {
        return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
    }
}
class OffsetPair {
    static { this.zero = new OffsetPair(0, 0); }
    static { this.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER); }
    constructor(offset1, offset2) {
        this.offset1 = offset1;
        this.offset2 = offset2;
    }
    toString() {
        return `${this.offset1} <-> ${this.offset2}`;
    }
    delta(offset) {
        if (offset === 0) {
            return this;
        }
        return new OffsetPair(this.offset1 + offset, this.offset2 + offset);
    }
    equals(other) {
        return this.offset1 === other.offset1 && this.offset2 === other.offset2;
    }
}
class InfiniteTimeout {
    static { this.instance = new InfiniteTimeout(); }
    isValid() {
        return true;
    }
}
class DateTimeout {
    constructor(timeout) {
        this.timeout = timeout;
        this.startTime = Date.now();
        this.valid = true;
        if (timeout <= 0) {
            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError('timeout must be positive');
        }
    }
    // Recommendation: Set a log-point `{this.disable()}` in the body
    isValid() {
        const valid = Date.now() - this.startTime < this.timeout;
        if (!valid && this.valid) {
            this.valid = false; // timeout reached
            // eslint-disable-next-line no-debugger
            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.
        }
        return this.valid;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DynamicProgrammingDiffing: () => (/* binding */ DynamicProgrammingDiffing)
/* harmony export */ });
/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/offsetRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js");
/* harmony import */ var _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diffAlgorithm.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



/**
 * A O(MN) diffing algorithm that supports a score function.
 * The algorithm can be improved by processing the 2d array diagonally.
*/
class DynamicProgrammingDiffing {
    compute(sequence1, sequence2, timeout = _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.InfiniteTimeout.instance, equalityScore) {
        if (sequence1.length === 0 || sequence2.length === 0) {
            return _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult.trivial(sequence1, sequence2);
        }
        /**
         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).
         */
        const lcsLengths = new _utils_js__WEBPACK_IMPORTED_MODULE_2__.Array2D(sequence1.length, sequence2.length);
        const directions = new _utils_js__WEBPACK_IMPORTED_MODULE_2__.Array2D(sequence1.length, sequence2.length);
        const lengths = new _utils_js__WEBPACK_IMPORTED_MODULE_2__.Array2D(sequence1.length, sequence2.length);
        // ==== Initializing lcsLengths ====
        for (let s1 = 0; s1 < sequence1.length; s1++) {
            for (let s2 = 0; s2 < sequence2.length; s2++) {
                if (!timeout.isValid()) {
                    return _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);
                }
                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);
                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);
                let extendedSeqScore;
                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {
                    if (s1 === 0 || s2 === 0) {
                        extendedSeqScore = 0;
                    }
                    else {
                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);
                    }
                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {
                        // Prefer consecutive diagonals
                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);
                    }
                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);
                }
                else {
                    extendedSeqScore = -1;
                }
                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
                if (newValue === extendedSeqScore) {
                    // Prefer diagonals
                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;
                    lengths.set(s1, s2, prevLen + 1);
                    directions.set(s1, s2, 3);
                }
                else if (newValue === horizontalLen) {
                    lengths.set(s1, s2, 0);
                    directions.set(s1, s2, 1);
                }
                else if (newValue === verticalLen) {
                    lengths.set(s1, s2, 0);
                    directions.set(s1, s2, 2);
                }
                lcsLengths.set(s1, s2, newValue);
            }
        }
        // ==== Backtracking ====
        const result = [];
        let lastAligningPosS1 = sequence1.length;
        let lastAligningPosS2 = sequence2.length;
        function reportDecreasingAligningPositions(s1, s2) {
            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {
                result.push(new _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__.OffsetRange(s1 + 1, lastAligningPosS1), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__.OffsetRange(s2 + 1, lastAligningPosS2)));
            }
            lastAligningPosS1 = s1;
            lastAligningPosS2 = s2;
        }
        let s1 = sequence1.length - 1;
        let s2 = sequence2.length - 1;
        while (s1 >= 0 && s2 >= 0) {
            if (directions.get(s1, s2) === 3) {
                reportDecreasingAligningPositions(s1, s2);
                s1--;
                s2--;
            }
            else {
                if (directions.get(s1, s2) === 1) {
                    s1--;
                }
                else {
                    s2--;
                }
            }
        }
        reportDecreasingAligningPositions(-1, -1);
        result.reverse();
        return new _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult(result, false);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MyersDiffAlgorithm: () => (/* binding */ MyersDiffAlgorithm)
/* harmony export */ });
/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/offsetRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js");
/* harmony import */ var _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diffAlgorithm.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * An O(ND) diff algorithm that has a quadratic space worst-case complexity.
*/
class MyersDiffAlgorithm {
    compute(seq1, seq2, timeout = _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.InfiniteTimeout.instance) {
        // These are common special cases.
        // The early return improves performance dramatically.
        if (seq1.length === 0 || seq2.length === 0) {
            return _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult.trivial(seq1, seq2);
        }
        const seqX = seq1; // Text on the x axis
        const seqY = seq2; // Text on the y axis
        function getXAfterSnake(x, y) {
            while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {
                x++;
                y++;
            }
            return x;
        }
        let d = 0;
        // V[k]: X value of longest d-line that ends in diagonal k.
        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.
        // diagonal k: Set of points (x,y) with x-y = k.
        // k=1 -> (1,0),(2,1)
        const V = new FastInt32Array();
        V.set(0, getXAfterSnake(0, 0));
        const paths = new FastArrayNegativeIndices();
        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));
        let k = 0;
        loop: while (true) {
            d++;
            if (!timeout.isValid()) {
                return _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult.trivialTimedOut(seqX, seqY);
            }
            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.
            const lowerBound = -Math.min(d, seqY.length + (d % 2));
            const upperBound = Math.min(d, seqX.length + (d % 2));
            for (k = lowerBound; k <= upperBound; k += 2) {
                let step = 0;
                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.
                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)
                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)
                step++;
                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);
                const y = x - k;
                step++;
                if (x > seqX.length || y > seqY.length) {
                    // This diagonal is irrelevant for the result.
                    // TODO: Don't pay the cost for this in the next iteration.
                    continue;
                }
                const newMaxX = getXAfterSnake(x, y);
                V.set(k, newMaxX);
                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);
                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);
                if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {
                    break loop;
                }
            }
        }
        let path = paths.get(k);
        const result = [];
        let lastAligningPosS1 = seqX.length;
        let lastAligningPosS2 = seqY.length;
        while (true) {
            const endX = path ? path.x + path.length : 0;
            const endY = path ? path.y + path.length : 0;
            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
                result.push(new _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__.OffsetRange(endX, lastAligningPosS1), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__.OffsetRange(endY, lastAligningPosS2)));
            }
            if (!path) {
                break;
            }
            lastAligningPosS1 = path.x;
            lastAligningPosS2 = path.y;
            path = path.prev;
        }
        result.reverse();
        return new _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult(result, false);
    }
}
class SnakePath {
    constructor(prev, x, y, length) {
        this.prev = prev;
        this.x = x;
        this.y = y;
        this.length = length;
    }
}
/**
 * An array that supports fast negative indices.
*/
class FastInt32Array {
    constructor() {
        this.positiveArr = new Int32Array(10);
        this.negativeArr = new Int32Array(10);
    }
    get(idx) {
        if (idx < 0) {
            idx = -idx - 1;
            return this.negativeArr[idx];
        }
        else {
            return this.positiveArr[idx];
        }
    }
    set(idx, value) {
        if (idx < 0) {
            idx = -idx - 1;
            if (idx >= this.negativeArr.length) {
                const arr = this.negativeArr;
                this.negativeArr = new Int32Array(arr.length * 2);
                this.negativeArr.set(arr);
            }
            this.negativeArr[idx] = value;
        }
        else {
            if (idx >= this.positiveArr.length) {
                const arr = this.positiveArr;
                this.positiveArr = new Int32Array(arr.length * 2);
                this.positiveArr.set(arr);
            }
            this.positiveArr[idx] = value;
        }
    }
}
/**
 * An array that supports fast negative indices.
*/
class FastArrayNegativeIndices {
    constructor() {
        this.positiveArr = [];
        this.negativeArr = [];
    }
    get(idx) {
        if (idx < 0) {
            idx = -idx - 1;
            return this.negativeArr[idx];
        }
        else {
            return this.positiveArr[idx];
        }
    }
    set(idx, value) {
        if (idx < 0) {
            idx = -idx - 1;
            this.negativeArr[idx] = value;
        }
        else {
            this.positiveArr[idx] = value;
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeMovedLines: () => (/* binding */ computeMovedLines)
/* harmony export */ });
/* harmony import */ var _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms/diffAlgorithm.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js");
/* harmony import */ var _rangeMapping_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rangeMapping.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js");
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../base/common/arraysFind.js */ "./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js");
/* harmony import */ var _base_common_map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../base/common/map.js */ "./node_modules/monaco-editor/esm/vs/base/common/map.js");
/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/lineRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js");
/* harmony import */ var _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./linesSliceCharSequence.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js");
/* harmony import */ var _algorithms_myersDiffAlgorithm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./algorithms/myersDiffAlgorithm.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {
    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);
    if (!timeout.isValid()) {
        return [];
    }
    const filteredChanges = changes.filter(c => !excludedChanges.has(c));
    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);
    (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.pushMany)(moves, unchangedMoves);
    moves = joinCloseConsecutiveMoves(moves);
    // Ignore too short moves
    moves = moves.filter(current => {
        const lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());
        const originalText = lines.join('\n');
        return originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;
    });
    moves = removeMovesInSameDiff(changes, moves);
    return moves;
}
function countWhere(arr, predicate) {
    let count = 0;
    for (const t of arr) {
        if (predicate(t)) {
            count++;
        }
    }
    return count;
}
function computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {
    const moves = [];
    const deletions = changes
        .filter(c => c.modified.isEmpty && c.original.length >= 3)
        .map(d => new _utils_js__WEBPACK_IMPORTED_MODULE_7__.LineRangeFragment(d.original, originalLines, d));
    const insertions = new Set(changes
        .filter(c => c.original.isEmpty && c.modified.length >= 3)
        .map(d => new _utils_js__WEBPACK_IMPORTED_MODULE_7__.LineRangeFragment(d.modified, modifiedLines, d)));
    const excludedChanges = new Set();
    for (const deletion of deletions) {
        let highestSimilarity = -1;
        let best;
        for (const insertion of insertions) {
            const similarity = deletion.computeSimilarity(insertion);
            if (similarity > highestSimilarity) {
                highestSimilarity = similarity;
                best = insertion;
            }
        }
        if (highestSimilarity > 0.90 && best) {
            insertions.delete(best);
            moves.push(new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_1__.LineRangeMapping(deletion.range, best.range));
            excludedChanges.add(deletion.source);
            excludedChanges.add(best.source);
        }
        if (!timeout.isValid()) {
            return { moves, excludedChanges };
        }
    }
    return { moves, excludedChanges };
}
function computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {
    const moves = [];
    const original3LineHashes = new _base_common_map_js__WEBPACK_IMPORTED_MODULE_4__.SetMap();
    for (const change of changes) {
        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {
            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;
            original3LineHashes.add(key, { range: new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(i, i + 3) });
        }
    }
    const possibleMappings = [];
    changes.sort((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.compareBy)(c => c.modified.startLineNumber, _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.numberComparator));
    for (const change of changes) {
        let lastMappings = [];
        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {
            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;
            const currentModifiedRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(i, i + 3);
            const nextMappings = [];
            original3LineHashes.forEach(key, ({ range }) => {
                for (const lastMapping of lastMappings) {
                    // does this match extend some last match?
                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&
                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {
                        lastMapping.originalLineRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);
                        lastMapping.modifiedLineRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);
                        nextMappings.push(lastMapping);
                        return;
                    }
                }
                const mapping = {
                    modifiedLineRange: currentModifiedRange,
                    originalLineRange: range,
                };
                possibleMappings.push(mapping);
                nextMappings.push(mapping);
            });
            lastMappings = nextMappings;
        }
        if (!timeout.isValid()) {
            return [];
        }
    }
    possibleMappings.sort((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.reverseOrder)((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.compareBy)(m => m.modifiedLineRange.length, _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.numberComparator)));
    const modifiedSet = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRangeSet();
    const originalSet = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRangeSet();
    for (const mapping of possibleMappings) {
        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;
        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);
        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);
        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);
        for (const s of modifiedIntersectedSections.ranges) {
            if (s.length < 3) {
                continue;
            }
            const modifiedLineRange = s;
            const originalLineRange = s.delta(-diffOrigToMod);
            moves.push(new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_1__.LineRangeMapping(originalLineRange, modifiedLineRange));
            modifiedSet.addRange(modifiedLineRange);
            originalSet.addRange(originalLineRange);
        }
    }
    moves.sort((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.compareBy)(m => m.original.startLineNumber, _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.numberComparator));
    const monotonousChanges = new _base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.MonotonousArray(changes);
    for (let i = 0; i < moves.length; i++) {
        const move = moves[i];
        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);
        const firstTouchingChangeMod = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastMonotonous)(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);
        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);
        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);
        const lastTouchingChangeMod = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastMonotonous)(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);
        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);
        let extendToTop;
        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {
            const origLine = move.original.startLineNumber - extendToTop - 1;
            const modLine = move.modified.startLineNumber - extendToTop - 1;
            if (origLine > originalLines.length || modLine > modifiedLines.length) {
                break;
            }
            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
                break;
            }
            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
                break;
            }
        }
        if (extendToTop > 0) {
            originalSet.addRange(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));
            modifiedSet.addRange(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));
        }
        let extendToBottom;
        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {
            const origLine = move.original.endLineNumberExclusive + extendToBottom;
            const modLine = move.modified.endLineNumberExclusive + extendToBottom;
            if (origLine > originalLines.length || modLine > modifiedLines.length) {
                break;
            }
            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
                break;
            }
            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
                break;
            }
        }
        if (extendToBottom > 0) {
            originalSet.addRange(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));
            modifiedSet.addRange(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));
        }
        if (extendToTop > 0 || extendToBottom > 0) {
            moves[i] = new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_1__.LineRangeMapping(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));
        }
    }
    return moves;
}
function areLinesSimilar(line1, line2, timeout) {
    if (line1.trim() === line2.trim()) {
        return true;
    }
    if (line1.length > 300 && line2.length > 300) {
        return false;
    }
    const myersDiffingAlgorithm = new _algorithms_myersDiffAlgorithm_js__WEBPACK_IMPORTED_MODULE_8__.MyersDiffAlgorithm();
    const result = myersDiffingAlgorithm.compute(new _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_6__.LinesSliceCharSequence([line1], new _core_range_js__WEBPACK_IMPORTED_MODULE_9__.Range(1, 1, 1, line1.length), false), new _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_6__.LinesSliceCharSequence([line2], new _core_range_js__WEBPACK_IMPORTED_MODULE_9__.Range(1, 1, 1, line2.length), false), timeout);
    let commonNonSpaceCharCount = 0;
    const inverted = _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_0__.SequenceDiff.invert(result.diffs, line1.length);
    for (const seq of inverted) {
        seq.seq1Range.forEach(idx => {
            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isSpace)(line1.charCodeAt(idx))) {
                commonNonSpaceCharCount++;
            }
        });
    }
    function countNonWsChars(str) {
        let count = 0;
        for (let i = 0; i < line1.length; i++) {
            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isSpace)(str.charCodeAt(i))) {
                count++;
            }
        }
        return count;
    }
    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);
    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;
    return r;
}
function joinCloseConsecutiveMoves(moves) {
    if (moves.length === 0) {
        return moves;
    }
    moves.sort((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.compareBy)(m => m.original.startLineNumber, _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.numberComparator));
    const result = [moves[0]];
    for (let i = 1; i < moves.length; i++) {
        const last = result[result.length - 1];
        const current = moves[i];
        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;
        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;
        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;
        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {
            result[result.length - 1] = last.join(current);
            continue;
        }
        result.push(current);
    }
    return result;
}
function removeMovesInSameDiff(changes, moves) {
    const changesMonotonous = new _base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.MonotonousArray(changes);
    moves = moves.filter(m => {
        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)
            || new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_1__.LineRangeMapping(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(1, 1), new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(1, 1));
        const diffBeforeEndOfMoveModified = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastMonotonous)(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);
        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;
        return differentDiffs;
    });
    return moves;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultLinesDiffComputer: () => (/* binding */ DefaultLinesDiffComputer),
/* harmony export */   getLineRangeMapping: () => (/* binding */ getLineRangeMapping),
/* harmony export */   lineRangeMappingFromRangeMappings: () => (/* binding */ lineRangeMappingFromRangeMappings)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _base_common_assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../base/common/assert.js */ "./node_modules/monaco-editor/esm/vs/base/common/assert.js");
/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/lineRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js");
/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/offsetRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./algorithms/diffAlgorithm.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js");
/* harmony import */ var _algorithms_dynamicProgrammingDiffing_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./algorithms/dynamicProgrammingDiffing.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js");
/* harmony import */ var _algorithms_myersDiffAlgorithm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./algorithms/myersDiffAlgorithm.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js");
/* harmony import */ var _computeMovedLines_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./computeMovedLines.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js");
/* harmony import */ var _heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./heuristicSequenceOptimizations.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js");
/* harmony import */ var _lineSequence_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lineSequence.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js");
/* harmony import */ var _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./linesSliceCharSequence.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js");
/* harmony import */ var _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../linesDiffComputer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js");
/* harmony import */ var _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../rangeMapping.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














class DefaultLinesDiffComputer {
    constructor() {
        this.dynamicProgrammingDiffing = new _algorithms_dynamicProgrammingDiffing_js__WEBPACK_IMPORTED_MODULE_6__.DynamicProgrammingDiffing();
        this.myersDiffingAlgorithm = new _algorithms_myersDiffAlgorithm_js__WEBPACK_IMPORTED_MODULE_7__.MyersDiffAlgorithm();
    }
    computeDiff(originalLines, modifiedLines, options) {
        if (originalLines.length <= 1 && (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.equals)(originalLines, modifiedLines, (a, b) => a === b)) {
            return new _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_12__.LinesDiff([], [], false);
        }
        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {
            return new _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_12__.LinesDiff([
                new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.DetailedLineRangeMapping(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__.LineRange(1, originalLines.length + 1), new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__.LineRange(1, modifiedLines.length + 1), [
                    new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.RangeMapping(new _core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new _core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))
                ])
            ], [], false);
        }
        const timeout = options.maxComputationTimeMs === 0 ? _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.InfiniteTimeout.instance : new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.DateTimeout(options.maxComputationTimeMs);
        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;
        const perfectHashes = new Map();
        function getOrCreateHash(text) {
            let hash = perfectHashes.get(text);
            if (hash === undefined) {
                hash = perfectHashes.size;
                perfectHashes.set(text, hash);
            }
            return hash;
        }
        const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));
        const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));
        const sequence1 = new _lineSequence_js__WEBPACK_IMPORTED_MODULE_10__.LineSequence(originalLinesHashes, originalLines);
        const sequence2 = new _lineSequence_js__WEBPACK_IMPORTED_MODULE_10__.LineSequence(modifiedLinesHashes, modifiedLines);
        const lineAlignmentResult = (() => {
            if (sequence1.length + sequence2.length < 1700) {
                // Use the improved algorithm for small files
                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]
                    ? modifiedLines[offset2].length === 0
                        ? 0.1
                        : 1 + Math.log(1 + modifiedLines[offset2].length)
                    : 0.99);
            }
            return this.myersDiffingAlgorithm.compute(sequence1, sequence2, timeout);
        })();
        let lineAlignments = lineAlignmentResult.diffs;
        let hitTimeout = lineAlignmentResult.hitTimeout;
        lineAlignments = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.optimizeSequenceDiffs)(sequence1, sequence2, lineAlignments);
        lineAlignments = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.removeVeryShortMatchingLinesBetweenDiffs)(sequence1, sequence2, lineAlignments);
        const alignments = [];
        const scanForWhitespaceChanges = (equalLinesCount) => {
            if (!considerWhitespaceChanges) {
                return;
            }
            for (let i = 0; i < equalLinesCount; i++) {
                const seq1Offset = seq1LastStart + i;
                const seq2Offset = seq2LastStart + i;
                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
                    // This is because of whitespace changes, diff these lines
                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_3__.OffsetRange(seq1Offset, seq1Offset + 1), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_3__.OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);
                    for (const a of characterDiffs.mappings) {
                        alignments.push(a);
                    }
                    if (characterDiffs.hitTimeout) {
                        hitTimeout = true;
                    }
                }
            }
        };
        let seq1LastStart = 0;
        let seq2LastStart = 0;
        for (const diff of lineAlignments) {
            (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_1__.assertFn)(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
            const equalLinesCount = diff.seq1Range.start - seq1LastStart;
            scanForWhitespaceChanges(equalLinesCount);
            seq1LastStart = diff.seq1Range.endExclusive;
            seq2LastStart = diff.seq2Range.endExclusive;
            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);
            if (characterDiffs.hitTimeout) {
                hitTimeout = true;
            }
            for (const a of characterDiffs.mappings) {
                alignments.push(a);
            }
        }
        scanForWhitespaceChanges(originalLines.length - seq1LastStart);
        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
        let moves = [];
        if (options.computeMoves) {
            moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);
        }
        // Make sure all ranges are valid
        (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_1__.assertFn)(() => {
            function validatePosition(pos, lines) {
                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {
                    return false;
                }
                const line = lines[pos.lineNumber - 1];
                if (pos.column < 1 || pos.column > line.length + 1) {
                    return false;
                }
                return true;
            }
            function validateRange(range, lines) {
                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {
                    return false;
                }
                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {
                    return false;
                }
                return true;
            }
            for (const c of changes) {
                if (!c.innerChanges) {
                    return false;
                }
                for (const ic of c.innerChanges) {
                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&
                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);
                    if (!valid) {
                        return false;
                    }
                }
                if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {
                    return false;
                }
            }
            return true;
        });
        return new _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_12__.LinesDiff(changes, moves, hitTimeout);
    }
    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {
        const moves = (0,_computeMovedLines_js__WEBPACK_IMPORTED_MODULE_8__.computeMovedLines)(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);
        const movesWithDiffs = moves.map(m => {
            const moveChanges = this.refineDiff(originalLines, modifiedLines, new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);
            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);
            return new _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_12__.MovedText(m, mappings);
        });
        return movesWithDiffs;
    }
    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {
        const lineRangeMapping = toLineRangeMapping(diff);
        const rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);
        const slice1 = new _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_11__.LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);
        const slice2 = new _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_11__.LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);
        const diffResult = slice1.length + slice2.length < 500
            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)
            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);
        const check = false;
        let diffs = diffResult.diffs;
        if (check) {
            _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.SequenceDiff.assertSorted(diffs);
        }
        diffs = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.optimizeSequenceDiffs)(slice1, slice2, diffs);
        if (check) {
            _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.SequenceDiff.assertSorted(diffs);
        }
        diffs = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.extendDiffsToEntireWordIfAppropriate)(slice1, slice2, diffs);
        if (check) {
            _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.SequenceDiff.assertSorted(diffs);
        }
        diffs = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.removeShortMatches)(slice1, slice2, diffs);
        if (check) {
            _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.SequenceDiff.assertSorted(diffs);
        }
        diffs = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.removeVeryShortMatchingTextBetweenLongDiffs)(slice1, slice2, diffs);
        if (check) {
            _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.SequenceDiff.assertSorted(diffs);
        }
        const result = diffs.map((d) => new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));
        if (check) {
            _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.RangeMapping.assertSorted(result);
        }
        // Assert: result applied on original should be the same as diff applied to original
        return {
            mappings: result,
            hitTimeout: diffResult.hitTimeout,
        };
    }
}
function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {
    const changes = [];
    for (const g of (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.groupAdjacentBy)(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original)
        || a1.modified.overlapOrTouch(a2.modified))) {
        const first = g[0];
        const last = g[g.length - 1];
        changes.push(new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map(a => a.innerChanges[0])));
    }
    (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_1__.assertFn)(() => {
        if (!dontAssertStartLine && changes.length > 0) {
            if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {
                return false;
            }
            if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {
                return false;
            }
        }
        return (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_1__.checkAdjacentItems)(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&
            // There has to be an unchanged line in between (otherwise both diffs should have been joined)
            m1.original.endLineNumberExclusive < m2.original.startLineNumber &&
            m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
    });
    return changes;
}
function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
    let lineStartDelta = 0;
    let lineEndDelta = 0;
    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.
    // original: ]xxx \n <- this line is not modified
    // modified: ]xx  \n
    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1
        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber
        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {
        // We can only do this if the range is not empty yet
        lineEndDelta = -1;
    }
    // original: xxx[ \n <- this line is not modified
    // modified: xxx[ \n
    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length
        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length
        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta
        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {
        // We can only do this if the range is not empty yet
        lineStartDelta = 1;
    }
    const originalLineRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__.LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
    const modifiedLineRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__.LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
    return new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);
}
function toLineRangeMapping(sequenceDiff) {
    return new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.LineRangeMapping(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__.LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1), new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__.LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1));
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extendDiffsToEntireWordIfAppropriate: () => (/* binding */ extendDiffsToEntireWordIfAppropriate),
/* harmony export */   optimizeSequenceDiffs: () => (/* binding */ optimizeSequenceDiffs),
/* harmony export */   removeShortMatches: () => (/* binding */ removeShortMatches),
/* harmony export */   removeVeryShortMatchingLinesBetweenDiffs: () => (/* binding */ removeVeryShortMatchingLinesBetweenDiffs),
/* harmony export */   removeVeryShortMatchingTextBetweenLongDiffs: () => (/* binding */ removeVeryShortMatchingTextBetweenLongDiffs)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/offsetRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js");
/* harmony import */ var _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./algorithms/diffAlgorithm.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    let result = sequenceDiffs;
    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
    // Sometimes, calling this function twice improves the result.
    // Uncomment the second invocation and run the tests to see the difference.
    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
    result = shiftSequenceDiffs(sequence1, sequence2, result);
    return result;
}
/**
 * This function fixes issues like this:
 * ```
 * import { Baz, Bar } from "foo";
 * ```
 * <->
 * ```
 * import { Baz, Bar, Foo } from "foo";
 * ```
 * Computed diff: [ {Add "," after Bar}, {Add "Foo " after space} }
 * Improved diff: [{Add ", Foo" after Bar}]
 */
function joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {
    if (sequenceDiffs.length === 0) {
        return sequenceDiffs;
    }
    const result = [];
    result.push(sequenceDiffs[0]);
    // First move them all to the left as much as possible and join them if possible
    for (let i = 1; i < sequenceDiffs.length; i++) {
        const prevResult = result[result.length - 1];
        let cur = sequenceDiffs[i];
        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;
            let d;
            for (d = 1; d <= length; d++) {
                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||
                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {
                    break;
                }
            }
            d--;
            if (d === length) {
                // Merge previous and current diff
                result[result.length - 1] = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));
                continue;
            }
            cur = cur.delta(-d);
        }
        result.push(cur);
    }
    const result2 = [];
    // Then move them all to the right and join them again if possible
    for (let i = 0; i < result.length - 1; i++) {
        const nextResult = result[i + 1];
        let cur = result[i];
        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;
            let d;
            for (d = 0; d < length; d++) {
                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||
                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {
                    break;
                }
            }
            if (d === length) {
                // Merge previous and current diff, write to result!
                result[i + 1] = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));
                continue;
            }
            if (d > 0) {
                cur = cur.delta(d);
            }
        }
        result2.push(cur);
    }
    if (result.length > 0) {
        result2.push(result[result.length - 1]);
    }
    return result2;
}
// align character level diffs at whitespace characters
// import { IBar } from "foo";
// import { I[Arr, I]Bar } from "foo";
// ->
// import { [IArr, ]IBar } from "foo";
// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';
// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';
// ->
// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';
// collectBrackets(level + 1, levelPerBracketType);
// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);
// ->
// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);
function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
        return sequenceDiffs;
    }
    for (let i = 0; i < sequenceDiffs.length; i++) {
        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);
        const diff = sequenceDiffs[i];
        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);
        const seq1ValidRange = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);
        const seq2ValidRange = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);
        if (diff.seq1Range.isEmpty) {
            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);
        }
        else if (diff.seq2Range.isEmpty) {
            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();
        }
    }
    return sequenceDiffs;
}
function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {
    const maxShiftLimit = 100; // To prevent performance issues
    // don't touch previous or next!
    let deltaBefore = 1;
    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&
        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&
        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
        deltaBefore++;
    }
    deltaBefore--;
    let deltaAfter = 0;
    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&
        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&
        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
        deltaAfter++;
    }
    if (deltaBefore === 0 && deltaAfter === 0) {
        return diff;
    }
    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`
    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`
    let bestDelta = 0;
    let bestScore = -1;
    // find best scored delta
    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
        const seq2OffsetStart = diff.seq2Range.start + delta;
        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
        const seq1Offset = diff.seq1Range.start + delta;
        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
        if (score > bestScore) {
            bestScore = score;
            bestDelta = delta;
        }
    }
    return diff.delta(bestDelta);
}
function removeShortMatches(sequence1, sequence2, sequenceDiffs) {
    const result = [];
    for (const s of sequenceDiffs) {
        const last = result[result.length - 1];
        if (!last) {
            result.push(s);
            continue;
        }
        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {
            result[result.length - 1] = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));
        }
        else {
            result.push(s);
        }
    }
    return result;
}
function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {
    const equalMappings = _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff.invert(sequenceDiffs, sequence1.length);
    const additional = [];
    let lastPoint = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.OffsetPair(0, 0);
    function scanWord(pair, equalMapping) {
        if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {
            return;
        }
        const w1 = sequence1.findWordContaining(pair.offset1);
        const w2 = sequence2.findWordContaining(pair.offset2);
        if (!w1 || !w2) {
            return;
        }
        let w = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff(w1, w2);
        const equalPart = w.intersect(equalMapping);
        let equalChars1 = equalPart.seq1Range.length;
        let equalChars2 = equalPart.seq2Range.length;
        // The words do not touch previous equals mappings, as we would have processed them already.
        // But they might touch the next ones.
        while (equalMappings.length > 0) {
            const next = equalMappings[0];
            const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);
            if (!intersects) {
                break;
            }
            const v1 = sequence1.findWordContaining(next.seq1Range.start);
            const v2 = sequence2.findWordContaining(next.seq2Range.start);
            // Because there is an intersection, we know that the words are not empty.
            const v = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff(v1, v2);
            const equalPart = v.intersect(next);
            equalChars1 += equalPart.seq1Range.length;
            equalChars2 += equalPart.seq2Range.length;
            w = w.join(v);
            if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {
                // The word extends beyond the next equal mapping.
                equalMappings.shift();
            }
            else {
                break;
            }
        }
        if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {
            additional.push(w);
        }
        lastPoint = w.getEndExclusives();
    }
    while (equalMappings.length > 0) {
        const next = equalMappings.shift();
        if (next.seq1Range.isEmpty) {
            continue;
        }
        scanWord(next.getStarts(), next);
        // The equal parts are not empty, so -1 gives us a character that is equal in both parts.
        scanWord(next.getEndExclusives().delta(-1), next);
    }
    const merged = mergeSequenceDiffs(sequenceDiffs, additional);
    return merged;
}
function mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {
    const result = [];
    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {
        const sd1 = sequenceDiffs1[0];
        const sd2 = sequenceDiffs2[0];
        let next;
        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {
            next = sequenceDiffs1.shift();
        }
        else {
            next = sequenceDiffs2.shift();
        }
        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {
            result[result.length - 1] = result[result.length - 1].join(next);
        }
        else {
            result.push(next);
        }
    }
    return result;
}
function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {
    let diffs = sequenceDiffs;
    if (diffs.length === 0) {
        return diffs;
    }
    let counter = 0;
    let shouldRepeat;
    do {
        shouldRepeat = false;
        const result = [
            diffs[0]
        ];
        for (let i = 1; i < diffs.length; i++) {
            const cur = diffs[i];
            const lastResult = result[result.length - 1];
            function shouldJoinDiffs(before, after) {
                const unchangedRange = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
                const unchangedText = sequence1.getText(unchangedRange);
                const unchangedTextWithoutWs = unchangedText.replace(/\s/g, '');
                if (unchangedTextWithoutWs.length <= 4
                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {
                    return true;
                }
                return false;
            }
            const shouldJoin = shouldJoinDiffs(lastResult, cur);
            if (shouldJoin) {
                shouldRepeat = true;
                result[result.length - 1] = result[result.length - 1].join(cur);
            }
            else {
                result.push(cur);
            }
        }
        diffs = result;
    } while (counter++ < 10 && shouldRepeat);
    return diffs;
}
function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {
    let diffs = sequenceDiffs;
    if (diffs.length === 0) {
        return diffs;
    }
    let counter = 0;
    let shouldRepeat;
    do {
        shouldRepeat = false;
        const result = [
            diffs[0]
        ];
        for (let i = 1; i < diffs.length; i++) {
            const cur = diffs[i];
            const lastResult = result[result.length - 1];
            function shouldJoinDiffs(before, after) {
                const unchangedRange = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);
                if (unchangedLineCount > 5 || unchangedRange.length > 500) {
                    return false;
                }
                const unchangedText = sequence1.getText(unchangedRange).trim();
                if (unchangedText.length > 20 || unchangedText.split(/\r\n|\r|\n/).length > 1) {
                    return false;
                }
                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);
                const beforeSeq1Length = before.seq1Range.length;
                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);
                const beforeSeq2Length = before.seq2Range.length;
                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);
                const afterSeq1Length = after.seq1Range.length;
                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);
                const afterSeq2Length = after.seq2Range.length;
                // TODO: Maybe a neural net can be used to derive the result from these numbers
                const max = 2 * 40 + 50;
                function cap(v) {
                    return Math.min(v, max);
                }
                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)
                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {
                    return true;
                }
                return false;
            }
            const shouldJoin = shouldJoinDiffs(lastResult, cur);
            if (shouldJoin) {
                shouldRepeat = true;
                result[result.length - 1] = result[result.length - 1].join(cur);
            }
            else {
                result.push(cur);
            }
        }
        diffs = result;
    } while (counter++ < 10 && shouldRepeat);
    const newDiffs = [];
    // Remove short suffixes/prefixes
    (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.forEachWithNeighbors)(diffs, (prev, cur, next) => {
        let newDiff = cur;
        function shouldMarkAsChanged(text) {
            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;
        }
        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);
        const prefix = sequence1.getText(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(fullRange1.start, cur.seq1Range.start));
        if (shouldMarkAsChanged(prefix)) {
            newDiff = newDiff.deltaStart(-prefix.length);
        }
        const suffix = sequence1.getText(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));
        if (shouldMarkAsChanged(suffix)) {
            newDiff = newDiff.deltaEnd(suffix.length);
        }
        const availableSpace = _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.OffsetPair.zero, next ? next.getStarts() : _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.OffsetPair.max);
        const result = newDiff.intersect(availableSpace);
        if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {
            newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);
        }
        else {
            newDiffs.push(result);
        }
    });
    return newDiffs;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineSequence: () => (/* binding */ LineSequence)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class LineSequence {
    constructor(trimmedHash, lines) {
        this.trimmedHash = trimmedHash;
        this.lines = lines;
    }
    getElement(offset) {
        return this.trimmedHash[offset];
    }
    get length() {
        return this.trimmedHash.length;
    }
    getBoundaryScore(length) {
        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);
        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);
        return 1000 - (indentationBefore + indentationAfter);
    }
    getText(range) {
        return this.lines.slice(range.start, range.endExclusive).join('\n');
    }
    isStronglyEqual(offset1, offset2) {
        return this.lines[offset1] === this.lines[offset2];
    }
}
function getIndentation(str) {
    let i = 0;
    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {
        i++;
    }
    return i;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinesSliceCharSequence: () => (/* binding */ LinesSliceCharSequence)
/* harmony export */ });
/* harmony import */ var _base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/arraysFind.js */ "./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js");
/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/offsetRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





class LinesSliceCharSequence {
    constructor(lines, range, considerWhitespaceChanges) {
        this.lines = lines;
        this.range = range;
        this.considerWhitespaceChanges = considerWhitespaceChanges;
        this.elements = [];
        this.firstElementOffsetByLineIdx = [];
        this.lineStartOffsets = [];
        this.trimmedWsLengthsByLineIdx = [];
        this.firstElementOffsetByLineIdx.push(0);
        for (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {
            let line = lines[lineNumber - 1];
            let lineStartOffset = 0;
            if (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {
                lineStartOffset = this.range.startColumn - 1;
                line = line.substring(lineStartOffset);
            }
            this.lineStartOffsets.push(lineStartOffset);
            let trimmedWsLength = 0;
            if (!considerWhitespaceChanges) {
                const trimmedStartLine = line.trimStart();
                trimmedWsLength = line.length - trimmedStartLine.length;
                line = trimmedStartLine.trimEnd();
            }
            this.trimmedWsLengthsByLineIdx.push(trimmedWsLength);
            const lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;
            for (let i = 0; i < lineLength; i++) {
                this.elements.push(line.charCodeAt(i));
            }
            if (lineNumber < this.range.endLineNumber) {
                this.elements.push('\n'.charCodeAt(0));
                this.firstElementOffsetByLineIdx.push(this.elements.length);
            }
        }
    }
    toString() {
        return `Slice: "${this.text}"`;
    }
    get text() {
        return this.getText(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(0, this.length));
    }
    getText(range) {
        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');
    }
    getElement(offset) {
        return this.elements[offset];
    }
    get length() {
        return this.elements.length;
    }
    getBoundaryScore(length) {
        //   a   b   c   ,           d   e   f
        // 11  0   0   12  15  6   13  0   0   11
        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);
        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);
        if (prevCategory === 7 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {
            // don't break between \r and \n
            return 0;
        }
        if (prevCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {
            // prefer the linebreak before the change
            return 150;
        }
        let score = 0;
        if (prevCategory !== nextCategory) {
            score += 10;
            if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {
                score += 1;
            }
        }
        score += getCategoryBoundaryScore(prevCategory);
        score += getCategoryBoundaryScore(nextCategory);
        return score;
    }
    translateOffset(offset, preference = 'right') {
        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search
        const i = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_0__.findLastIdxMonotonous)(this.firstElementOffsetByLineIdx, (value) => value <= offset);
        const lineOffset = offset - this.firstElementOffsetByLineIdx[i];
        return new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(this.range.startLineNumber + i, 1 + this.lineStartOffsets[i] + lineOffset + ((lineOffset === 0 && preference === 'left') ? 0 : this.trimmedWsLengthsByLineIdx[i]));
    }
    translateRange(range) {
        const pos1 = this.translateOffset(range.start, 'right');
        const pos2 = this.translateOffset(range.endExclusive, 'left');
        if (pos2.isBefore(pos1)) {
            return _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(pos2, pos2);
        }
        return _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(pos1, pos2);
    }
    /**
     * Finds the word that contains the character at the given offset
     */
    findWordContaining(offset) {
        if (offset < 0 || offset >= this.elements.length) {
            return undefined;
        }
        if (!isWordChar(this.elements[offset])) {
            return undefined;
        }
        // find start
        let start = offset;
        while (start > 0 && isWordChar(this.elements[start - 1])) {
            start--;
        }
        // find end
        let end = offset;
        while (end < this.elements.length && isWordChar(this.elements[end])) {
            end++;
        }
        return new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(start, end);
    }
    countLinesIn(range) {
        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;
    }
    isStronglyEqual(offset1, offset2) {
        return this.elements[offset1] === this.elements[offset2];
    }
    extendToFullLines(range) {
        const start = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_0__.findLastMonotonous)(this.firstElementOffsetByLineIdx, x => x <= range.start) ?? 0;
        const end = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_0__.findFirstMonotonous)(this.firstElementOffsetByLineIdx, x => range.endExclusive <= x) ?? this.elements.length;
        return new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(start, end);
    }
}
function isWordChar(charCode) {
    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */
        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */
        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;
}
const score = {
    [0 /* CharBoundaryCategory.WordLower */]: 0,
    [1 /* CharBoundaryCategory.WordUpper */]: 0,
    [2 /* CharBoundaryCategory.WordNumber */]: 0,
    [3 /* CharBoundaryCategory.End */]: 10,
    [4 /* CharBoundaryCategory.Other */]: 2,
    [5 /* CharBoundaryCategory.Separator */]: 30,
    [6 /* CharBoundaryCategory.Space */]: 3,
    [7 /* CharBoundaryCategory.LineBreakCR */]: 10,
    [8 /* CharBoundaryCategory.LineBreakLF */]: 10,
};
function getCategoryBoundaryScore(category) {
    return score[category];
}
function getCategory(charCode) {
    if (charCode === 10 /* CharCode.LineFeed */) {
        return 8 /* CharBoundaryCategory.LineBreakLF */;
    }
    else if (charCode === 13 /* CharCode.CarriageReturn */) {
        return 7 /* CharBoundaryCategory.LineBreakCR */;
    }
    else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isSpace)(charCode)) {
        return 6 /* CharBoundaryCategory.Space */;
    }
    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {
        return 0 /* CharBoundaryCategory.WordLower */;
    }
    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {
        return 1 /* CharBoundaryCategory.WordUpper */;
    }
    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {
        return 2 /* CharBoundaryCategory.WordNumber */;
    }
    else if (charCode === -1) {
        return 3 /* CharBoundaryCategory.End */;
    }
    else if (charCode === 44 /* CharCode.Comma */ || charCode === 59 /* CharCode.Semicolon */) {
        return 5 /* CharBoundaryCategory.Separator */;
    }
    else {
        return 4 /* CharBoundaryCategory.Other */;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Array2D: () => (/* binding */ Array2D),
/* harmony export */   LineRangeFragment: () => (/* binding */ LineRangeFragment),
/* harmony export */   isSpace: () => (/* binding */ isSpace)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class Array2D {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.array = [];
        this.array = new Array(width * height);
    }
    get(x, y) {
        return this.array[x + y * this.width];
    }
    set(x, y, value) {
        this.array[x + y * this.width] = value;
    }
}
function isSpace(charCode) {
    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;
}
class LineRangeFragment {
    static { this.chrKeys = new Map(); }
    static getKey(chr) {
        let key = this.chrKeys.get(chr);
        if (key === undefined) {
            key = this.chrKeys.size;
            this.chrKeys.set(chr, key);
        }
        return key;
    }
    constructor(range, lines, source) {
        this.range = range;
        this.lines = lines;
        this.source = source;
        this.histogram = [];
        let counter = 0;
        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {
            const line = lines[i];
            for (let j = 0; j < line.length; j++) {
                counter++;
                const chr = line[j];
                const key = LineRangeFragment.getKey(chr);
                this.histogram[key] = (this.histogram[key] || 0) + 1;
            }
            counter++;
            const key = LineRangeFragment.getKey('\n');
            this.histogram[key] = (this.histogram[key] || 0) + 1;
        }
        this.totalCount = counter;
    }
    computeSimilarity(other) {
        let sumDifferences = 0;
        const maxLength = Math.max(this.histogram.length, other.histogram.length);
        for (let i = 0; i < maxLength; i++) {
            sumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));
        }
        return 1 - (sumDifferences / (this.totalCount + other.totalCount));
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DiffComputer: () => (/* binding */ DiffComputer),
/* harmony export */   LegacyLinesDiffComputer: () => (/* binding */ LegacyLinesDiffComputer)
/* harmony export */ });
/* harmony import */ var _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/diff/diff.js */ "./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js");
/* harmony import */ var _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linesDiffComputer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js");
/* harmony import */ var _rangeMapping_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rangeMapping.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js");
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _base_common_assert_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../base/common/assert.js */ "./node_modules/monaco-editor/esm/vs/base/common/assert.js");
/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/lineRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/







const MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
class LegacyLinesDiffComputer {
    computeDiff(originalLines, modifiedLines, options) {
        const diffComputer = new DiffComputer(originalLines, modifiedLines, {
            maxComputationTime: options.maxComputationTimeMs,
            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
            shouldComputeCharChanges: true,
            shouldMakePrettyDiff: true,
            shouldPostProcessCharChanges: true,
        });
        const result = diffComputer.computeDiff();
        const changes = [];
        let lastChange = null;
        for (const c of result.changes) {
            let originalRange;
            if (c.originalEndLineNumber === 0) {
                // Insertion
                originalRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_6__.LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);
            }
            else {
                originalRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_6__.LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);
            }
            let modifiedRange;
            if (c.modifiedEndLineNumber === 0) {
                // Deletion
                modifiedRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_6__.LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);
            }
            else {
                modifiedRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_6__.LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
            }
            let change = new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_2__.DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_2__.RangeMapping(new _core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new _core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));
            if (lastChange) {
                if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber
                    || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {
                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.
                    change = new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_2__.DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ?
                        lastChange.innerChanges.concat(change.innerChanges) : undefined);
                    changes.pop();
                }
            }
            changes.push(change);
            lastChange = change;
        }
        (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_5__.assertFn)(() => {
            return (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_5__.checkAdjacentItems)(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&
                // There has to be an unchanged line in between (otherwise both diffs should have been joined)
                m1.original.endLineNumberExclusive < m2.original.startLineNumber &&
                m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
        });
        return new _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_1__.LinesDiff(changes, [], result.quitEarly);
    }
}
function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    const diffAlgo = new _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__.LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
}
class LineSequence {
    constructor(lines) {
        const startColumns = [];
        const endColumns = [];
        for (let i = 0, length = lines.length; i < length; i++) {
            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
            endColumns[i] = getLastNonBlankColumn(lines[i], 1);
        }
        this.lines = lines;
        this._startColumns = startColumns;
        this._endColumns = endColumns;
    }
    getElements() {
        const elements = [];
        for (let i = 0, len = this.lines.length; i < len; i++) {
            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
        }
        return elements;
    }
    getStrictElement(index) {
        return this.lines[index];
    }
    getStartLineNumber(i) {
        return i + 1;
    }
    getEndLineNumber(i) {
        return i + 1;
    }
    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
        const charCodes = [];
        const lineNumbers = [];
        const columns = [];
        let len = 0;
        for (let index = startIndex; index <= endIndex; index++) {
            const lineContent = this.lines[index];
            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);
            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);
            for (let col = startColumn; col < endColumn; col++) {
                charCodes[len] = lineContent.charCodeAt(col - 1);
                lineNumbers[len] = index + 1;
                columns[len] = col;
                len++;
            }
            if (!shouldIgnoreTrimWhitespace && index < endIndex) {
                // Add \n if trim whitespace is not ignored
                charCodes[len] = 10 /* CharCode.LineFeed */;
                lineNumbers[len] = index + 1;
                columns[len] = lineContent.length + 1;
                len++;
            }
        }
        return new CharSequence(charCodes, lineNumbers, columns);
    }
}
class CharSequence {
    constructor(charCodes, lineNumbers, columns) {
        this._charCodes = charCodes;
        this._lineNumbers = lineNumbers;
        this._columns = columns;
    }
    toString() {
        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');
    }
    _assertIndex(index, arr) {
        if (index < 0 || index >= arr.length) {
            throw new Error(`Illegal index`);
        }
    }
    getElements() {
        return this._charCodes;
    }
    getStartLineNumber(i) {
        if (i > 0 && i === this._lineNumbers.length) {
            // the start line number of the element after the last element
            // is the end line number of the last element
            return this.getEndLineNumber(i - 1);
        }
        this._assertIndex(i, this._lineNumbers);
        return this._lineNumbers[i];
    }
    getEndLineNumber(i) {
        if (i === -1) {
            // the end line number of the element before the first element
            // is the start line number of the first element
            return this.getStartLineNumber(i + 1);
        }
        this._assertIndex(i, this._lineNumbers);
        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {
            return this._lineNumbers[i] + 1;
        }
        return this._lineNumbers[i];
    }
    getStartColumn(i) {
        if (i > 0 && i === this._columns.length) {
            // the start column of the element after the last element
            // is the end column of the last element
            return this.getEndColumn(i - 1);
        }
        this._assertIndex(i, this._columns);
        return this._columns[i];
    }
    getEndColumn(i) {
        if (i === -1) {
            // the end column of the element before the first element
            // is the start column of the first element
            return this.getStartColumn(i + 1);
        }
        this._assertIndex(i, this._columns);
        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {
            return 1;
        }
        return this._columns[i] + 1;
    }
}
class CharChange {
    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalStartColumn = originalStartColumn;
        this.originalEndLineNumber = originalEndLineNumber;
        this.originalEndColumn = originalEndColumn;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedStartColumn = modifiedStartColumn;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.modifiedEndColumn = modifiedEndColumn;
    }
    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
    }
}
function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
        return rawChanges;
    }
    const result = [rawChanges[0]];
    let prevChange = result[0];
    for (let i = 1, len = rawChanges.length; i < len; i++) {
        const currChange = rawChanges[i];
        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true
        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
            // Merge the current change into the previous one
            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;
            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;
        }
        else {
            // Add the current change
            result.push(currChange);
            prevChange = currChange;
        }
    }
    return result;
}
class LineChange {
    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalEndLineNumber = originalEndLineNumber;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.charChanges = charChanges;
    }
    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
        let originalStartLineNumber;
        let originalEndLineNumber;
        let modifiedStartLineNumber;
        let modifiedEndLineNumber;
        let charChanges = undefined;
        if (diffChange.originalLength === 0) {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
            originalEndLineNumber = 0;
        }
        else {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
        }
        if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
            modifiedEndLineNumber = 0;
        }
        else {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        }
        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
            // Compute character changes for diff chunks of at most 20 lines...
            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
                if (shouldPostProcessCharChanges) {
                    rawChanges = postProcessCharChanges(rawChanges);
                }
                charChanges = [];
                for (let i = 0, length = rawChanges.length; i < length; i++) {
                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
                }
            }
        }
        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
    }
}
class DiffComputer {
    constructor(originalLines, modifiedLines, opts) {
        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
        this.originalLines = originalLines;
        this.modifiedLines = modifiedLines;
        this.original = new LineSequence(originalLines);
        this.modified = new LineSequence(modifiedLines);
        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...
    }
    computeDiff() {
        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
            // empty original => fast path
            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
                return {
                    quitEarly: false,
                    changes: []
                };
            }
            return {
                quitEarly: false,
                changes: [{
                        originalStartLineNumber: 1,
                        originalEndLineNumber: 1,
                        modifiedStartLineNumber: 1,
                        modifiedEndLineNumber: this.modified.lines.length,
                        charChanges: undefined
                    }]
            };
        }
        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
            // empty modified => fast path
            return {
                quitEarly: false,
                changes: [{
                        originalStartLineNumber: 1,
                        originalEndLineNumber: this.original.lines.length,
                        modifiedStartLineNumber: 1,
                        modifiedEndLineNumber: 1,
                        charChanges: undefined
                    }]
            };
        }
        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
        const rawChanges = diffResult.changes;
        const quitEarly = diffResult.quitEarly;
        // The diff is always computed with ignoring trim whitespace
        // This ensures we get the prettiest diff
        if (this.shouldIgnoreTrimWhitespace) {
            const lineChanges = [];
            for (let i = 0, length = rawChanges.length; i < length; i++) {
                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
            }
            return {
                quitEarly: quitEarly,
                changes: lineChanges
            };
        }
        // Need to post-process and introduce changes where the trim whitespace is different
        // Note that we are looping starting at -1 to also cover the lines before the first change
        const result = [];
        let originalLineIndex = 0;
        let modifiedLineIndex = 0;
        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {
            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);
            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);
            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);
            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
                const originalLine = this.originalLines[originalLineIndex];
                const modifiedLine = this.modifiedLines[modifiedLineIndex];
                if (originalLine !== modifiedLine) {
                    // These lines differ only in trim whitespace
                    // Check the leading whitespace
                    {
                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                            if (originalChar !== modifiedChar) {
                                break;
                            }
                            originalStartColumn--;
                            modifiedStartColumn--;
                        }
                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
                        }
                    }
                    // Check the trailing whitespace
                    {
                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
                        const originalMaxColumn = originalLine.length + 1;
                        const modifiedMaxColumn = modifiedLine.length + 1;
                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                            if (originalChar !== modifiedChar) {
                                break;
                            }
                            originalEndColumn++;
                            modifiedEndColumn++;
                        }
                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
                        }
                    }
                }
                originalLineIndex++;
                modifiedLineIndex++;
            }
            if (nextChange) {
                // Emit the actual change
                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
                originalLineIndex += nextChange.originalLength;
                modifiedLineIndex += nextChange.modifiedLength;
            }
        }
        return {
            quitEarly: quitEarly,
            changes: result
        };
    }
    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
            // Merged into previous
            return;
        }
        let charChanges = undefined;
        if (this.shouldComputeCharChanges) {
            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
        }
        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
    }
    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        const len = result.length;
        if (len === 0) {
            return false;
        }
        const prevChange = result[len - 1];
        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
            // Don't merge with inserts/deletes
            return false;
        }
        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
            if (this.shouldComputeCharChanges && prevChange.charChanges) {
                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
            }
            return true;
        }
        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
            prevChange.originalEndLineNumber = originalLineNumber;
            prevChange.modifiedEndLineNumber = modifiedLineNumber;
            if (this.shouldComputeCharChanges && prevChange.charChanges) {
                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
            }
            return true;
        }
        return false;
    }
}
function getFirstNonBlankColumn(txt, defaultValue) {
    const r = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_3__.firstNonWhitespaceIndex(txt);
    if (r === -1) {
        return defaultValue;
    }
    return r + 1;
}
function getLastNonBlankColumn(txt, defaultValue) {
    const r = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_3__.lastNonWhitespaceIndex(txt);
    if (r === -1) {
        return defaultValue;
    }
    return r + 2;
}
function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
        return () => true;
    }
    const startTime = Date.now();
    return () => {
        return Date.now() - startTime < maximumRuntime;
    };
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinesDiff: () => (/* binding */ LinesDiff),
/* harmony export */   MovedText: () => (/* binding */ MovedText)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class LinesDiff {
    constructor(changes, 
    /**
     * Sorted by original line ranges.
     * The original line ranges and the modified line ranges must be disjoint (but can be touching).
     */
    moves, 
    /**
     * Indicates if the time out was reached.
     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.
     */
    hitTimeout) {
        this.changes = changes;
        this.moves = moves;
        this.hitTimeout = hitTimeout;
    }
}
class MovedText {
    constructor(lineRangeMapping, changes) {
        this.lineRangeMapping = lineRangeMapping;
        this.changes = changes;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js":
/*!************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linesDiffComputers: () => (/* binding */ linesDiffComputers)
/* harmony export */ });
/* harmony import */ var _legacyLinesDiffComputer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legacyLinesDiffComputer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js");
/* harmony import */ var _defaultLinesDiffComputer_defaultLinesDiffComputer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultLinesDiffComputer/defaultLinesDiffComputer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


const linesDiffComputers = {
    getLegacy: () => new _legacyLinesDiffComputer_js__WEBPACK_IMPORTED_MODULE_0__.LegacyLinesDiffComputer(),
    getDefault: () => new _defaultLinesDiffComputer_defaultLinesDiffComputer_js__WEBPACK_IMPORTED_MODULE_1__.DefaultLinesDiffComputer(),
};


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js":
/*!******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DetailedLineRangeMapping: () => (/* binding */ DetailedLineRangeMapping),
/* harmony export */   LineRangeMapping: () => (/* binding */ LineRangeMapping),
/* harmony export */   RangeMapping: () => (/* binding */ RangeMapping)
/* harmony export */ });
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/lineRange.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _core_textEdit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/textEdit.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





/**
 * Maps a line range in the original text model to a line range in the modified text model.
 */
class LineRangeMapping {
    static inverse(mapping, originalLineCount, modifiedLineCount) {
        const result = [];
        let lastOriginalEndLineNumber = 1;
        let lastModifiedEndLineNumber = 1;
        for (const m of mapping) {
            const r = new LineRangeMapping(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));
            if (!r.modified.isEmpty) {
                result.push(r);
            }
            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;
            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;
        }
        const r = new LineRangeMapping(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));
        if (!r.modified.isEmpty) {
            result.push(r);
        }
        return result;
    }
    static clip(mapping, originalRange, modifiedRange) {
        const result = [];
        for (const m of mapping) {
            const original = m.original.intersect(originalRange);
            const modified = m.modified.intersect(modifiedRange);
            if (original && !original.isEmpty && modified && !modified.isEmpty) {
                result.push(new LineRangeMapping(original, modified));
            }
        }
        return result;
    }
    constructor(originalRange, modifiedRange) {
        this.original = originalRange;
        this.modified = modifiedRange;
    }
    toString() {
        return `{${this.original.toString()}->${this.modified.toString()}}`;
    }
    flip() {
        return new LineRangeMapping(this.modified, this.original);
    }
    join(other) {
        return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));
    }
    /**
     * This method assumes that the LineRangeMapping describes a valid diff!
     * I.e. if one range is empty, the other range cannot be the entire document.
     * It avoids various problems when the line range points to non-existing line-numbers.
    */
    toRangeMapping() {
        const origInclusiveRange = this.original.toInclusiveRange();
        const modInclusiveRange = this.modified.toInclusiveRange();
        if (origInclusiveRange && modInclusiveRange) {
            return new RangeMapping(origInclusiveRange, modInclusiveRange);
        }
        else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {
            if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {
                // If one line range starts at 1, the other one must start at 1 as well.
                throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('not a valid diff');
            }
            // Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.
            // Thus, `endLineNumberExclusive` is a valid line number.
            return new RangeMapping(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
        }
        else {
            // We can assume here that both startLineNumbers are greater than 1.
            return new RangeMapping(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));
        }
    }
    /**
     * This method assumes that the LineRangeMapping describes a valid diff!
     * I.e. if one range is empty, the other range cannot be the entire document.
     * It avoids various problems when the line range points to non-existing line-numbers.
    */
    toRangeMapping2(original, modified) {
        if (isValidLineNumber(this.original.endLineNumberExclusive, original)
            && isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {
            return new RangeMapping(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
        }
        if (!this.original.isEmpty && !this.modified.isEmpty) {
            return new RangeMapping(_core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(this.original.startLineNumber, 1), normalizePosition(new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(this.modified.startLineNumber, 1), normalizePosition(new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));
        }
        if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {
            return new RangeMapping(_core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(normalizePosition(new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original), normalizePosition(new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(normalizePosition(new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified), normalizePosition(new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));
        }
        // Situation now: one range is empty and one range touches the last line and one range starts at line 1.
        // I don't think this can happen.
        throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError();
    }
}
function normalizePosition(position, content) {
    if (position.lineNumber < 1) {
        return new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(1, 1);
    }
    if (position.lineNumber > content.length) {
        return new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(content.length, content[content.length - 1].length + 1);
    }
    const line = content[position.lineNumber - 1];
    if (position.column > line.length + 1) {
        return new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(position.lineNumber, line.length + 1);
    }
    return position;
}
function isValidLineNumber(lineNumber, lines) {
    return lineNumber >= 1 && lineNumber <= lines.length;
}
/**
 * Maps a line range in the original text model to a line range in the modified text model.
 * Also contains inner range mappings.
 */
class DetailedLineRangeMapping extends LineRangeMapping {
    static fromRangeMappings(rangeMappings) {
        const originalRange = _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange.join(rangeMappings.map(r => _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange.fromRangeInclusive(r.originalRange)));
        const modifiedRange = _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange.join(rangeMappings.map(r => _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange.fromRangeInclusive(r.modifiedRange)));
        return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);
    }
    constructor(originalRange, modifiedRange, innerChanges) {
        super(originalRange, modifiedRange);
        this.innerChanges = innerChanges;
    }
    flip() {
        return new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));
    }
    withInnerChangesFromLineRanges() {
        return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);
    }
}
/**
 * Maps a range in the original text model to a range in the modified text model.
 */
class RangeMapping {
    static assertSorted(rangeMappings) {
        for (let i = 1; i < rangeMappings.length; i++) {
            const previous = rangeMappings[i - 1];
            const current = rangeMappings[i];
            if (!(previous.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition())
                && previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition()))) {
                throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('Range mappings must be sorted');
            }
        }
    }
    constructor(originalRange, modifiedRange) {
        this.originalRange = originalRange;
        this.modifiedRange = modifiedRange;
    }
    toString() {
        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
    }
    flip() {
        return new RangeMapping(this.modifiedRange, this.originalRange);
    }
    /**
     * Creates a single text edit that describes the change from the original to the modified text.
    */
    toTextEdit(modified) {
        const newText = modified.getValueOfRange(this.modifiedRange);
        return new _core_textEdit_js__WEBPACK_IMPORTED_MODULE_4__.SingleTextEdit(this.originalRange, newText);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages.js":
/*!**********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Command: () => (/* binding */ Command),
/* harmony export */   CompletionItemKinds: () => (/* binding */ CompletionItemKinds),
/* harmony export */   DocumentHighlightKind: () => (/* binding */ DocumentHighlightKind),
/* harmony export */   DocumentPasteTriggerKind: () => (/* binding */ DocumentPasteTriggerKind),
/* harmony export */   EncodedTokenizationResult: () => (/* binding */ EncodedTokenizationResult),
/* harmony export */   FoldingRangeKind: () => (/* binding */ FoldingRangeKind),
/* harmony export */   HoverVerbosityAction: () => (/* binding */ HoverVerbosityAction),
/* harmony export */   InlayHintKind: () => (/* binding */ InlayHintKind),
/* harmony export */   InlineCompletionTriggerKind: () => (/* binding */ InlineCompletionTriggerKind),
/* harmony export */   InlineEditTriggerKind: () => (/* binding */ InlineEditTriggerKind),
/* harmony export */   LazyTokenizationSupport: () => (/* binding */ LazyTokenizationSupport),
/* harmony export */   NewSymbolNameTag: () => (/* binding */ NewSymbolNameTag),
/* harmony export */   NewSymbolNameTriggerKind: () => (/* binding */ NewSymbolNameTriggerKind),
/* harmony export */   SelectedSuggestionInfo: () => (/* binding */ SelectedSuggestionInfo),
/* harmony export */   SignatureHelpTriggerKind: () => (/* binding */ SignatureHelpTriggerKind),
/* harmony export */   SymbolKinds: () => (/* binding */ SymbolKinds),
/* harmony export */   TextEdit: () => (/* binding */ TextEdit),
/* harmony export */   Token: () => (/* binding */ Token),
/* harmony export */   TokenizationRegistry: () => (/* binding */ TokenizationRegistry),
/* harmony export */   TokenizationResult: () => (/* binding */ TokenizationResult),
/* harmony export */   TreeSitterTokenizationRegistry: () => (/* binding */ TreeSitterTokenizationRegistry),
/* harmony export */   getAriaLabelForSymbol: () => (/* binding */ getAriaLabelForSymbol),
/* harmony export */   isLocationLink: () => (/* binding */ isLocationLink),
/* harmony export */   symbolKindNames: () => (/* binding */ symbolKindNames)
/* harmony export */ });
/* harmony import */ var _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/common/codicons.js */ "./node_modules/monaco-editor/esm/vs/base/common/codicons.js");
/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base/common/uri.js */ "./node_modules/monaco-editor/esm/vs/base/common/uri.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _tokenizationRegistry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tokenizationRegistry.js */ "./node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js");
/* harmony import */ var _nls_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../nls.js */ "./node_modules/monaco-editor/esm/vs/nls.js");





class Token {
    constructor(offset, type, language) {
        this.offset = offset;
        this.type = type;
        this.language = language;
        this._tokenBrand = undefined;
    }
    toString() {
        return '(' + this.offset + ', ' + this.type + ')';
    }
}
/**
 * @internal
 */
class TokenizationResult {
    constructor(tokens, endState) {
        this.tokens = tokens;
        this.endState = endState;
        this._tokenizationResultBrand = undefined;
    }
}
/**
 * @internal
 */
class EncodedTokenizationResult {
    constructor(
    /**
     * The tokens in binary format. Each token occupies two array indices. For token i:
     *  - at offset 2*i => startIndex
     *  - at offset 2*i + 1 => metadata
     *
     */
    tokens, endState) {
        this.tokens = tokens;
        this.endState = endState;
        this._encodedTokenizationResultBrand = undefined;
    }
}
var HoverVerbosityAction;
(function (HoverVerbosityAction) {
    /**
     * Increase the verbosity of the hover
     */
    HoverVerbosityAction[HoverVerbosityAction["Increase"] = 0] = "Increase";
    /**
     * Decrease the verbosity of the hover
     */
    HoverVerbosityAction[HoverVerbosityAction["Decrease"] = 1] = "Decrease";
})(HoverVerbosityAction || (HoverVerbosityAction = {}));
/**
 * @internal
 */
var CompletionItemKinds;
(function (CompletionItemKinds) {
    const byKind = new Map();
    byKind.set(0 /* CompletionItemKind.Method */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolMethod);
    byKind.set(1 /* CompletionItemKind.Function */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolFunction);
    byKind.set(2 /* CompletionItemKind.Constructor */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolConstructor);
    byKind.set(3 /* CompletionItemKind.Field */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolField);
    byKind.set(4 /* CompletionItemKind.Variable */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolVariable);
    byKind.set(5 /* CompletionItemKind.Class */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolClass);
    byKind.set(6 /* CompletionItemKind.Struct */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolStruct);
    byKind.set(7 /* CompletionItemKind.Interface */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolInterface);
    byKind.set(8 /* CompletionItemKind.Module */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolModule);
    byKind.set(9 /* CompletionItemKind.Property */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolProperty);
    byKind.set(10 /* CompletionItemKind.Event */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEvent);
    byKind.set(11 /* CompletionItemKind.Operator */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolOperator);
    byKind.set(12 /* CompletionItemKind.Unit */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolUnit);
    byKind.set(13 /* CompletionItemKind.Value */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolValue);
    byKind.set(15 /* CompletionItemKind.Enum */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEnum);
    byKind.set(14 /* CompletionItemKind.Constant */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolConstant);
    byKind.set(15 /* CompletionItemKind.Enum */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEnum);
    byKind.set(16 /* CompletionItemKind.EnumMember */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEnumMember);
    byKind.set(17 /* CompletionItemKind.Keyword */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolKeyword);
    byKind.set(27 /* CompletionItemKind.Snippet */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolSnippet);
    byKind.set(18 /* CompletionItemKind.Text */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolText);
    byKind.set(19 /* CompletionItemKind.Color */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolColor);
    byKind.set(20 /* CompletionItemKind.File */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolFile);
    byKind.set(21 /* CompletionItemKind.Reference */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolReference);
    byKind.set(22 /* CompletionItemKind.Customcolor */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolCustomColor);
    byKind.set(23 /* CompletionItemKind.Folder */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolFolder);
    byKind.set(24 /* CompletionItemKind.TypeParameter */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolTypeParameter);
    byKind.set(25 /* CompletionItemKind.User */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.account);
    byKind.set(26 /* CompletionItemKind.Issue */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.issues);
    /**
     * @internal
     */
    function toIcon(kind) {
        let codicon = byKind.get(kind);
        if (!codicon) {
            console.info('No codicon found for CompletionItemKind ' + kind);
            codicon = _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolProperty;
        }
        return codicon;
    }
    CompletionItemKinds.toIcon = toIcon;
    const data = new Map();
    data.set('method', 0 /* CompletionItemKind.Method */);
    data.set('function', 1 /* CompletionItemKind.Function */);
    data.set('constructor', 2 /* CompletionItemKind.Constructor */);
    data.set('field', 3 /* CompletionItemKind.Field */);
    data.set('variable', 4 /* CompletionItemKind.Variable */);
    data.set('class', 5 /* CompletionItemKind.Class */);
    data.set('struct', 6 /* CompletionItemKind.Struct */);
    data.set('interface', 7 /* CompletionItemKind.Interface */);
    data.set('module', 8 /* CompletionItemKind.Module */);
    data.set('property', 9 /* CompletionItemKind.Property */);
    data.set('event', 10 /* CompletionItemKind.Event */);
    data.set('operator', 11 /* CompletionItemKind.Operator */);
    data.set('unit', 12 /* CompletionItemKind.Unit */);
    data.set('value', 13 /* CompletionItemKind.Value */);
    data.set('constant', 14 /* CompletionItemKind.Constant */);
    data.set('enum', 15 /* CompletionItemKind.Enum */);
    data.set('enum-member', 16 /* CompletionItemKind.EnumMember */);
    data.set('enumMember', 16 /* CompletionItemKind.EnumMember */);
    data.set('keyword', 17 /* CompletionItemKind.Keyword */);
    data.set('snippet', 27 /* CompletionItemKind.Snippet */);
    data.set('text', 18 /* CompletionItemKind.Text */);
    data.set('color', 19 /* CompletionItemKind.Color */);
    data.set('file', 20 /* CompletionItemKind.File */);
    data.set('reference', 21 /* CompletionItemKind.Reference */);
    data.set('customcolor', 22 /* CompletionItemKind.Customcolor */);
    data.set('folder', 23 /* CompletionItemKind.Folder */);
    data.set('type-parameter', 24 /* CompletionItemKind.TypeParameter */);
    data.set('typeParameter', 24 /* CompletionItemKind.TypeParameter */);
    data.set('account', 25 /* CompletionItemKind.User */);
    data.set('issue', 26 /* CompletionItemKind.Issue */);
    /**
     * @internal
     */
    function fromString(value, strict) {
        let res = data.get(value);
        if (typeof res === 'undefined' && !strict) {
            res = 9 /* CompletionItemKind.Property */;
        }
        return res;
    }
    CompletionItemKinds.fromString = fromString;
})(CompletionItemKinds || (CompletionItemKinds = {}));
/**
 * How an {@link InlineCompletionsProvider inline completion provider} was triggered.
 */
var InlineCompletionTriggerKind;
(function (InlineCompletionTriggerKind) {
    /**
     * Completion was triggered automatically while editing.
     * It is sufficient to return a single completion item in this case.
     */
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Automatic"] = 0] = "Automatic";
    /**
     * Completion was triggered explicitly by a user gesture.
     * Return multiple completion items to enable cycling through them.
     */
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
class SelectedSuggestionInfo {
    constructor(range, text, completionKind, isSnippetText) {
        this.range = range;
        this.text = text;
        this.completionKind = completionKind;
        this.isSnippetText = isSnippetText;
    }
    equals(other) {
        return _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range.lift(this.range).equalsRange(other.range)
            && this.text === other.text
            && this.completionKind === other.completionKind
            && this.isSnippetText === other.isSnippetText;
    }
}
/**
 * @internal
 */
var DocumentPasteTriggerKind;
(function (DocumentPasteTriggerKind) {
    DocumentPasteTriggerKind[DocumentPasteTriggerKind["Automatic"] = 0] = "Automatic";
    DocumentPasteTriggerKind[DocumentPasteTriggerKind["PasteAs"] = 1] = "PasteAs";
})(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {}));
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * @internal
 */
function isLocationLink(thing) {
    return thing
        && _base_common_uri_js__WEBPACK_IMPORTED_MODULE_1__.URI.isUri(thing.uri)
        && _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range.isIRange(thing.range)
        && (_core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range.isIRange(thing.originSelectionRange) || _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range.isIRange(thing.targetSelectionRange));
}
/**
 * @internal
 */
const symbolKindNames = {
    [17 /* SymbolKind.Array */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Array', "array"),
    [16 /* SymbolKind.Boolean */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Boolean', "boolean"),
    [4 /* SymbolKind.Class */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Class', "class"),
    [13 /* SymbolKind.Constant */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Constant', "constant"),
    [8 /* SymbolKind.Constructor */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Constructor', "constructor"),
    [9 /* SymbolKind.Enum */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Enum', "enumeration"),
    [21 /* SymbolKind.EnumMember */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('EnumMember', "enumeration member"),
    [23 /* SymbolKind.Event */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Event', "event"),
    [7 /* SymbolKind.Field */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Field', "field"),
    [0 /* SymbolKind.File */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('File', "file"),
    [11 /* SymbolKind.Function */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Function', "function"),
    [10 /* SymbolKind.Interface */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Interface', "interface"),
    [19 /* SymbolKind.Key */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Key', "key"),
    [5 /* SymbolKind.Method */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Method', "method"),
    [1 /* SymbolKind.Module */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Module', "module"),
    [2 /* SymbolKind.Namespace */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Namespace', "namespace"),
    [20 /* SymbolKind.Null */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Null', "null"),
    [15 /* SymbolKind.Number */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Number', "number"),
    [18 /* SymbolKind.Object */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Object', "object"),
    [24 /* SymbolKind.Operator */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Operator', "operator"),
    [3 /* SymbolKind.Package */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Package', "package"),
    [6 /* SymbolKind.Property */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Property', "property"),
    [14 /* SymbolKind.String */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('String', "string"),
    [22 /* SymbolKind.Struct */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Struct', "struct"),
    [25 /* SymbolKind.TypeParameter */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('TypeParameter', "type parameter"),
    [12 /* SymbolKind.Variable */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Variable', "variable"),
};
/**
 * @internal
 */
function getAriaLabelForSymbol(symbolName, kind) {
    return (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('symbolAriaLabel', '{0} ({1})', symbolName, symbolKindNames[kind]);
}
/**
 * @internal
 */
var SymbolKinds;
(function (SymbolKinds) {
    const byKind = new Map();
    byKind.set(0 /* SymbolKind.File */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolFile);
    byKind.set(1 /* SymbolKind.Module */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolModule);
    byKind.set(2 /* SymbolKind.Namespace */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolNamespace);
    byKind.set(3 /* SymbolKind.Package */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolPackage);
    byKind.set(4 /* SymbolKind.Class */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolClass);
    byKind.set(5 /* SymbolKind.Method */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolMethod);
    byKind.set(6 /* SymbolKind.Property */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolProperty);
    byKind.set(7 /* SymbolKind.Field */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolField);
    byKind.set(8 /* SymbolKind.Constructor */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolConstructor);
    byKind.set(9 /* SymbolKind.Enum */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEnum);
    byKind.set(10 /* SymbolKind.Interface */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolInterface);
    byKind.set(11 /* SymbolKind.Function */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolFunction);
    byKind.set(12 /* SymbolKind.Variable */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolVariable);
    byKind.set(13 /* SymbolKind.Constant */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolConstant);
    byKind.set(14 /* SymbolKind.String */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolString);
    byKind.set(15 /* SymbolKind.Number */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolNumber);
    byKind.set(16 /* SymbolKind.Boolean */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolBoolean);
    byKind.set(17 /* SymbolKind.Array */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolArray);
    byKind.set(18 /* SymbolKind.Object */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolObject);
    byKind.set(19 /* SymbolKind.Key */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolKey);
    byKind.set(20 /* SymbolKind.Null */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolNull);
    byKind.set(21 /* SymbolKind.EnumMember */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEnumMember);
    byKind.set(22 /* SymbolKind.Struct */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolStruct);
    byKind.set(23 /* SymbolKind.Event */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEvent);
    byKind.set(24 /* SymbolKind.Operator */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolOperator);
    byKind.set(25 /* SymbolKind.TypeParameter */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolTypeParameter);
    /**
     * @internal
     */
    function toIcon(kind) {
        let icon = byKind.get(kind);
        if (!icon) {
            console.info('No codicon found for SymbolKind ' + kind);
            icon = _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolProperty;
        }
        return icon;
    }
    SymbolKinds.toIcon = toIcon;
})(SymbolKinds || (SymbolKinds = {}));
/** @internal */
class TextEdit {
}
class FoldingRangeKind {
    /**
     * Kind for folding range representing a comment. The value of the kind is 'comment'.
     */
    static { this.Comment = new FoldingRangeKind('comment'); }
    /**
     * Kind for folding range representing a import. The value of the kind is 'imports'.
     */
    static { this.Imports = new FoldingRangeKind('imports'); }
    /**
     * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).
     * The value of the kind is 'region'.
     */
    static { this.Region = new FoldingRangeKind('region'); }
    /**
     * Returns a {@link FoldingRangeKind} for the given value.
     *
     * @param value of the kind.
     */
    static fromValue(value) {
        switch (value) {
            case 'comment': return FoldingRangeKind.Comment;
            case 'imports': return FoldingRangeKind.Imports;
            case 'region': return FoldingRangeKind.Region;
        }
        return new FoldingRangeKind(value);
    }
    /**
     * Creates a new {@link FoldingRangeKind}.
     *
     * @param value of the kind.
     */
    constructor(value) {
        this.value = value;
    }
}
var NewSymbolNameTag;
(function (NewSymbolNameTag) {
    NewSymbolNameTag[NewSymbolNameTag["AIGenerated"] = 1] = "AIGenerated";
})(NewSymbolNameTag || (NewSymbolNameTag = {}));
var NewSymbolNameTriggerKind;
(function (NewSymbolNameTriggerKind) {
    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind["Invoke"] = 0] = "Invoke";
    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind["Automatic"] = 1] = "Automatic";
})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));
/**
 * @internal
 */
var Command;
(function (Command) {
    /**
     * @internal
     */
    function is(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        return typeof obj.id === 'string' &&
            typeof obj.title === 'string';
    }
    Command.is = is;
})(Command || (Command = {}));
var InlayHintKind;
(function (InlayHintKind) {
    InlayHintKind[InlayHintKind["Type"] = 1] = "Type";
    InlayHintKind[InlayHintKind["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (InlayHintKind = {}));
/**
 * @internal
 */
class LazyTokenizationSupport {
    constructor(createSupport) {
        this.createSupport = createSupport;
        this._tokenizationSupport = null;
    }
    dispose() {
        if (this._tokenizationSupport) {
            this._tokenizationSupport.then((support) => {
                if (support) {
                    support.dispose();
                }
            });
        }
    }
    get tokenizationSupport() {
        if (!this._tokenizationSupport) {
            this._tokenizationSupport = this.createSupport();
        }
        return this._tokenizationSupport;
    }
}
/**
 * @internal
 */
const TokenizationRegistry = new _tokenizationRegistry_js__WEBPACK_IMPORTED_MODULE_3__.TokenizationRegistry();
/**
 * @internal
 */
const TreeSitterTokenizationRegistry = new _tokenizationRegistry_js__WEBPACK_IMPORTED_MODULE_3__.TokenizationRegistry();
var InlineEditTriggerKind;
(function (InlineEditTriggerKind) {
    InlineEditTriggerKind[InlineEditTriggerKind["Invoke"] = 0] = "Invoke";
    InlineEditTriggerKind[InlineEditTriggerKind["Automatic"] = 1] = "Automatic";
})(InlineEditTriggerKind || (InlineEditTriggerKind = {}));


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeDefaultDocumentColors: () => (/* binding */ computeDefaultDocumentColors)
/* harmony export */ });
/* harmony import */ var _base_common_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/color.js */ "./node_modules/monaco-editor/esm/vs/base/common/color.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

function _parseCaptureGroups(captureGroups) {
    const values = [];
    for (const captureGroup of captureGroups) {
        const parsedNumber = Number(captureGroup);
        if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\s/g, '') !== '') {
            values.push(parsedNumber);
        }
    }
    return values;
}
function _toIColor(r, g, b, a) {
    return {
        red: r / 255,
        blue: b / 255,
        green: g / 255,
        alpha: a
    };
}
function _findRange(model, match) {
    const index = match.index;
    const length = match[0].length;
    if (!index) {
        return;
    }
    const startPosition = model.positionAt(index);
    const range = {
        startLineNumber: startPosition.lineNumber,
        startColumn: startPosition.column,
        endLineNumber: startPosition.lineNumber,
        endColumn: startPosition.column + length
    };
    return range;
}
function _findHexColorInformation(range, hexValue) {
    if (!range) {
        return;
    }
    const parsedHexColor = _base_common_color_js__WEBPACK_IMPORTED_MODULE_0__.Color.Format.CSS.parseHex(hexValue);
    if (!parsedHexColor) {
        return;
    }
    return {
        range: range,
        color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)
    };
}
function _findRGBColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
        return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    return {
        range: range,
        color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)
    };
}
function _findHSLColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
        return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    const colorEquivalent = new _base_common_color_js__WEBPACK_IMPORTED_MODULE_0__.Color(new _base_common_color_js__WEBPACK_IMPORTED_MODULE_0__.HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));
    return {
        range: range,
        color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)
    };
}
function _findMatches(model, regex) {
    if (typeof model === 'string') {
        return [...model.matchAll(regex)];
    }
    else {
        return model.findMatches(regex);
    }
}
function computeColors(model) {
    const result = [];
    // Early validation for RGB and HSL
    const initialValidationRegex = /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm;
    const initialValidationMatches = _findMatches(model, initialValidationRegex);
    // Potential colors have been found, validate the parameters
    if (initialValidationMatches.length > 0) {
        for (const initialMatch of initialValidationMatches) {
            const initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== undefined);
            const colorScheme = initialCaptureGroups[1];
            const colorParameters = initialCaptureGroups[2];
            if (!colorParameters) {
                continue;
            }
            let colorInformation;
            if (colorScheme === 'rgb') {
                const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
            }
            else if (colorScheme === 'rgba') {
                const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
            }
            else if (colorScheme === 'hsl') {
                const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
            }
            else if (colorScheme === 'hsla') {
                const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
            }
            else if (colorScheme === '#') {
                colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);
            }
            if (colorInformation) {
                result.push(colorInformation);
            }
        }
    }
    return result;
}
/**
 * Returns an array of all default document colors in the provided document
 */
function computeDefaultDocumentColors(model) {
    if (!model || typeof model.getValue !== 'function' || typeof model.positionAt !== 'function') {
        // Unknown caller!
        return [];
    }
    return computeColors(model);
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinkComputer: () => (/* binding */ LinkComputer),
/* harmony export */   StateMachine: () => (/* binding */ StateMachine),
/* harmony export */   computeLinks: () => (/* binding */ computeLinks)
/* harmony export */ });
/* harmony import */ var _core_characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/characterClassifier.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class Uint8Matrix {
    constructor(rows, cols, defaultValue) {
        const data = new Uint8Array(rows * cols);
        for (let i = 0, len = rows * cols; i < len; i++) {
            data[i] = defaultValue;
        }
        this._data = data;
        this.rows = rows;
        this.cols = cols;
    }
    get(row, col) {
        return this._data[row * this.cols + col];
    }
    set(row, col, value) {
        this._data[row * this.cols + col] = value;
    }
}
class StateMachine {
    constructor(edges) {
        let maxCharCode = 0;
        let maxState = 0 /* State.Invalid */;
        for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            if (chCode > maxCharCode) {
                maxCharCode = chCode;
            }
            if (from > maxState) {
                maxState = from;
            }
            if (to > maxState) {
                maxState = to;
            }
        }
        maxCharCode++;
        maxState++;
        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* State.Invalid */);
        for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            states.set(from, chCode, to);
        }
        this._states = states;
        this._maxCharCode = maxCharCode;
    }
    nextState(currentState, chCode) {
        if (chCode < 0 || chCode >= this._maxCharCode) {
            return 0 /* State.Invalid */;
        }
        return this._states.get(currentState, chCode);
    }
}
// State machine for http:// or https:// or file://
let _stateMachine = null;
function getStateMachine() {
    if (_stateMachine === null) {
        _stateMachine = new StateMachine([
            [1 /* State.Start */, 104 /* CharCode.h */, 2 /* State.H */],
            [1 /* State.Start */, 72 /* CharCode.H */, 2 /* State.H */],
            [1 /* State.Start */, 102 /* CharCode.f */, 6 /* State.F */],
            [1 /* State.Start */, 70 /* CharCode.F */, 6 /* State.F */],
            [2 /* State.H */, 116 /* CharCode.t */, 3 /* State.HT */],
            [2 /* State.H */, 84 /* CharCode.T */, 3 /* State.HT */],
            [3 /* State.HT */, 116 /* CharCode.t */, 4 /* State.HTT */],
            [3 /* State.HT */, 84 /* CharCode.T */, 4 /* State.HTT */],
            [4 /* State.HTT */, 112 /* CharCode.p */, 5 /* State.HTTP */],
            [4 /* State.HTT */, 80 /* CharCode.P */, 5 /* State.HTTP */],
            [5 /* State.HTTP */, 115 /* CharCode.s */, 9 /* State.BeforeColon */],
            [5 /* State.HTTP */, 83 /* CharCode.S */, 9 /* State.BeforeColon */],
            [5 /* State.HTTP */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],
            [6 /* State.F */, 105 /* CharCode.i */, 7 /* State.FI */],
            [6 /* State.F */, 73 /* CharCode.I */, 7 /* State.FI */],
            [7 /* State.FI */, 108 /* CharCode.l */, 8 /* State.FIL */],
            [7 /* State.FI */, 76 /* CharCode.L */, 8 /* State.FIL */],
            [8 /* State.FIL */, 101 /* CharCode.e */, 9 /* State.BeforeColon */],
            [8 /* State.FIL */, 69 /* CharCode.E */, 9 /* State.BeforeColon */],
            [9 /* State.BeforeColon */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],
            [10 /* State.AfterColon */, 47 /* CharCode.Slash */, 11 /* State.AlmostThere */],
            [11 /* State.AlmostThere */, 47 /* CharCode.Slash */, 12 /* State.End */],
        ]);
    }
    return _stateMachine;
}
let _classifier = null;
function getClassifier() {
    if (_classifier === null) {
        _classifier = new _core_characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__.CharacterClassifier(0 /* CharacterClass.None */);
        // allow-any-unicode-next-line
        const FORCE_TERMINATION_CHARACTERS = ' \t<>\'\"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…';
        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* CharacterClass.ForceTermination */);
        }
        const CANNOT_END_WITH_CHARACTERS = '.,;:';
        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CharacterClass.CannotEndIn */);
        }
    }
    return _classifier;
}
class LinkComputer {
    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
        // Do not allow to end link in certain characters...
        let lastIncludedCharIndex = linkEndIndex - 1;
        do {
            const chCode = line.charCodeAt(lastIncludedCharIndex);
            const chClass = classifier.get(chCode);
            if (chClass !== 2 /* CharacterClass.CannotEndIn */) {
                break;
            }
            lastIncludedCharIndex--;
        } while (lastIncludedCharIndex > linkBeginIndex);
        // Handle links enclosed in parens, square brackets and curlys.
        if (linkBeginIndex > 0) {
            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
            if ((charCodeBeforeLink === 40 /* CharCode.OpenParen */ && lastCharCodeInLink === 41 /* CharCode.CloseParen */)
                || (charCodeBeforeLink === 91 /* CharCode.OpenSquareBracket */ && lastCharCodeInLink === 93 /* CharCode.CloseSquareBracket */)
                || (charCodeBeforeLink === 123 /* CharCode.OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CharCode.CloseCurlyBrace */)) {
                // Do not end in ) if ( is before the link start
                // Do not end in ] if [ is before the link start
                // Do not end in } if { is before the link start
                lastIncludedCharIndex--;
            }
        }
        return {
            range: {
                startLineNumber: lineNumber,
                startColumn: linkBeginIndex + 1,
                endLineNumber: lineNumber,
                endColumn: lastIncludedCharIndex + 2
            },
            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
        };
    }
    static computeLinks(model, stateMachine = getStateMachine()) {
        const classifier = getClassifier();
        const result = [];
        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
            const line = model.getLineContent(i);
            const len = line.length;
            let j = 0;
            let linkBeginIndex = 0;
            let linkBeginChCode = 0;
            let state = 1 /* State.Start */;
            let hasOpenParens = false;
            let hasOpenSquareBracket = false;
            let inSquareBrackets = false;
            let hasOpenCurlyBracket = false;
            while (j < len) {
                let resetStateMachine = false;
                const chCode = line.charCodeAt(j);
                if (state === 13 /* State.Accept */) {
                    let chClass;
                    switch (chCode) {
                        case 40 /* CharCode.OpenParen */:
                            hasOpenParens = true;
                            chClass = 0 /* CharacterClass.None */;
                            break;
                        case 41 /* CharCode.CloseParen */:
                            chClass = (hasOpenParens ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);
                            break;
                        case 91 /* CharCode.OpenSquareBracket */:
                            inSquareBrackets = true;
                            hasOpenSquareBracket = true;
                            chClass = 0 /* CharacterClass.None */;
                            break;
                        case 93 /* CharCode.CloseSquareBracket */:
                            inSquareBrackets = false;
                            chClass = (hasOpenSquareBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);
                            break;
                        case 123 /* CharCode.OpenCurlyBrace */:
                            hasOpenCurlyBracket = true;
                            chClass = 0 /* CharacterClass.None */;
                            break;
                        case 125 /* CharCode.CloseCurlyBrace */:
                            chClass = (hasOpenCurlyBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);
                            break;
                        // The following three rules make it that ' or " or ` are allowed inside links
                        // only if the link is wrapped by some other quote character
                        case 39 /* CharCode.SingleQuote */:
                        case 34 /* CharCode.DoubleQuote */:
                        case 96 /* CharCode.BackTick */:
                            if (linkBeginChCode === chCode) {
                                chClass = 1 /* CharacterClass.ForceTermination */;
                            }
                            else if (linkBeginChCode === 39 /* CharCode.SingleQuote */ || linkBeginChCode === 34 /* CharCode.DoubleQuote */ || linkBeginChCode === 96 /* CharCode.BackTick */) {
                                chClass = 0 /* CharacterClass.None */;
                            }
                            else {
                                chClass = 1 /* CharacterClass.ForceTermination */;
                            }
                            break;
                        case 42 /* CharCode.Asterisk */:
                            // `*` terminates a link if the link began with `*`
                            chClass = (linkBeginChCode === 42 /* CharCode.Asterisk */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;
                            break;
                        case 124 /* CharCode.Pipe */:
                            // `|` terminates a link if the link began with `|`
                            chClass = (linkBeginChCode === 124 /* CharCode.Pipe */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;
                            break;
                        case 32 /* CharCode.Space */:
                            // ` ` allow space in between [ and ]
                            chClass = (inSquareBrackets ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);
                            break;
                        default:
                            chClass = classifier.get(chCode);
                    }
                    // Check if character terminates link
                    if (chClass === 1 /* CharacterClass.ForceTermination */) {
                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
                        resetStateMachine = true;
                    }
                }
                else if (state === 12 /* State.End */) {
                    let chClass;
                    if (chCode === 91 /* CharCode.OpenSquareBracket */) {
                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]
                        hasOpenSquareBracket = true;
                        chClass = 0 /* CharacterClass.None */;
                    }
                    else {
                        chClass = classifier.get(chCode);
                    }
                    // Check if character terminates link
                    if (chClass === 1 /* CharacterClass.ForceTermination */) {
                        resetStateMachine = true;
                    }
                    else {
                        state = 13 /* State.Accept */;
                    }
                }
                else {
                    state = stateMachine.nextState(state, chCode);
                    if (state === 0 /* State.Invalid */) {
                        resetStateMachine = true;
                    }
                }
                if (resetStateMachine) {
                    state = 1 /* State.Start */;
                    hasOpenParens = false;
                    hasOpenSquareBracket = false;
                    hasOpenCurlyBracket = false;
                    // Record where the link started
                    linkBeginIndex = j + 1;
                    linkBeginChCode = chCode;
                }
                j++;
            }
            if (state === 13 /* State.Accept */) {
                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
            }
        }
        return result;
    }
}
/**
 * Returns an array of all links contains in the provided
 * document. *Note* that this operation is computational
 * expensive and should not run in the UI thread.
 */
function computeLinks(model) {
    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {
        // Unknown caller!
        return [];
    }
    return LinkComputer.computeLinks(model);
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicInplaceReplace: () => (/* binding */ BasicInplaceReplace)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class BasicInplaceReplace {
    constructor() {
        this._defaultValueSet = [
            ['true', 'false'],
            ['True', 'False'],
            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],
            ['public', 'protected', 'private'],
        ];
    }
    static { this.INSTANCE = new BasicInplaceReplace(); }
    navigateValueSet(range1, text1, range2, text2, up) {
        if (range1 && text1) {
            const result = this.doNavigateValueSet(text1, up);
            if (result) {
                return {
                    range: range1,
                    value: result
                };
            }
        }
        if (range2 && text2) {
            const result = this.doNavigateValueSet(text2, up);
            if (result) {
                return {
                    range: range2,
                    value: result
                };
            }
        }
        return null;
    }
    doNavigateValueSet(text, up) {
        const numberResult = this.numberReplace(text, up);
        if (numberResult !== null) {
            return numberResult;
        }
        return this.textReplace(text, up);
    }
    numberReplace(value, up) {
        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));
        let n1 = Number(value);
        const n2 = parseFloat(value);
        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
            if (n1 === 0 && !up) {
                return null; // don't do negative
                //			} else if(n1 === 9 && up) {
                //				return null; // don't insert 10 into a number
            }
            else {
                n1 = Math.floor(n1 * precision);
                n1 += up ? precision : -precision;
                return String(n1 / precision);
            }
        }
        return null;
    }
    textReplace(value, up) {
        return this.valueSetsReplace(this._defaultValueSet, value, up);
    }
    valueSetsReplace(valueSets, value, up) {
        let result = null;
        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
            result = this.valueSetReplace(valueSets[i], value, up);
        }
        return result;
    }
    valueSetReplace(valueSet, value, up) {
        let idx = valueSet.indexOf(value);
        if (idx >= 0) {
            idx += up ? +1 : -1;
            if (idx < 0) {
                idx = valueSet.length - 1;
            }
            else {
                idx %= valueSet.length;
            }
            return valueSet[idx];
        }
        return null;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApplyEditsResult: () => (/* binding */ ApplyEditsResult),
/* harmony export */   FindMatch: () => (/* binding */ FindMatch),
/* harmony export */   GlyphMarginLane: () => (/* binding */ GlyphMarginLane),
/* harmony export */   InjectedTextCursorStops: () => (/* binding */ InjectedTextCursorStops),
/* harmony export */   OverviewRulerLane: () => (/* binding */ OverviewRulerLane),
/* harmony export */   SearchData: () => (/* binding */ SearchData),
/* harmony export */   TextModelResolvedOptions: () => (/* binding */ TextModelResolvedOptions),
/* harmony export */   ValidAnnotatedEditOperation: () => (/* binding */ ValidAnnotatedEditOperation),
/* harmony export */   isITextSnapshot: () => (/* binding */ isITextSnapshot),
/* harmony export */   shouldSynchronizeModel: () => (/* binding */ shouldSynchronizeModel)
/* harmony export */ });
/* harmony import */ var _base_common_objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/common/objects.js */ "./node_modules/monaco-editor/esm/vs/base/common/objects.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Vertical Lane in the overview ruler of the editor.
 */
var OverviewRulerLane;
(function (OverviewRulerLane) {
    OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
    OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
    OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
    OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
})(OverviewRulerLane || (OverviewRulerLane = {}));
/**
 * Vertical Lane in the glyph margin of the editor.
 */
var GlyphMarginLane;
(function (GlyphMarginLane) {
    GlyphMarginLane[GlyphMarginLane["Left"] = 1] = "Left";
    GlyphMarginLane[GlyphMarginLane["Center"] = 2] = "Center";
    GlyphMarginLane[GlyphMarginLane["Right"] = 3] = "Right";
})(GlyphMarginLane || (GlyphMarginLane = {}));
var InjectedTextCursorStops;
(function (InjectedTextCursorStops) {
    InjectedTextCursorStops[InjectedTextCursorStops["Both"] = 0] = "Both";
    InjectedTextCursorStops[InjectedTextCursorStops["Right"] = 1] = "Right";
    InjectedTextCursorStops[InjectedTextCursorStops["Left"] = 2] = "Left";
    InjectedTextCursorStops[InjectedTextCursorStops["None"] = 3] = "None";
})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
class TextModelResolvedOptions {
    get originalIndentSize() {
        return this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;
    }
    /**
     * @internal
     */
    constructor(src) {
        this._textModelResolvedOptionsBrand = undefined;
        this.tabSize = Math.max(1, src.tabSize | 0);
        if (src.indentSize === 'tabSize') {
            this.indentSize = this.tabSize;
            this._indentSizeIsTabSize = true;
        }
        else {
            this.indentSize = Math.max(1, src.indentSize | 0);
            this._indentSizeIsTabSize = false;
        }
        this.insertSpaces = Boolean(src.insertSpaces);
        this.defaultEOL = src.defaultEOL | 0;
        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;
    }
    /**
     * @internal
     */
    equals(other) {
        return (this.tabSize === other.tabSize
            && this._indentSizeIsTabSize === other._indentSizeIsTabSize
            && this.indentSize === other.indentSize
            && this.insertSpaces === other.insertSpaces
            && this.defaultEOL === other.defaultEOL
            && this.trimAutoWhitespace === other.trimAutoWhitespace
            && (0,_base_common_objects_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions));
    }
    /**
     * @internal
     */
    createChangeEvent(newOpts) {
        return {
            tabSize: this.tabSize !== newOpts.tabSize,
            indentSize: this.indentSize !== newOpts.indentSize,
            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,
        };
    }
}
class FindMatch {
    /**
     * @internal
     */
    constructor(range, matches) {
        this._findMatchBrand = undefined;
        this.range = range;
        this.matches = matches;
    }
}
/**
 * @internal
 */
function isITextSnapshot(obj) {
    return (obj && typeof obj.read === 'function');
}
/**
 * @internal
 */
class ValidAnnotatedEditOperation {
    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {
        this.identifier = identifier;
        this.range = range;
        this.text = text;
        this.forceMoveMarkers = forceMoveMarkers;
        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;
        this._isTracked = _isTracked;
    }
}
/**
 * @internal
 */
class SearchData {
    constructor(regex, wordSeparators, simpleSearch) {
        this.regex = regex;
        this.wordSeparators = wordSeparators;
        this.simpleSearch = simpleSearch;
    }
}
/**
 * @internal
 */
class ApplyEditsResult {
    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {
        this.reverseEdits = reverseEdits;
        this.changes = changes;
        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;
    }
}
/**
 * @internal
 */
function shouldSynchronizeModel(model) {
    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MirrorTextModel: () => (/* binding */ MirrorTextModel)
/* harmony export */ });
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _prefixSumComputer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prefixSumComputer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class MirrorTextModel {
    constructor(uri, lines, eol, versionId) {
        this._uri = uri;
        this._lines = lines;
        this._eol = eol;
        this._versionId = versionId;
        this._lineStarts = null;
        this._cachedTextValue = null;
    }
    dispose() {
        this._lines.length = 0;
    }
    get version() {
        return this._versionId;
    }
    getText() {
        if (this._cachedTextValue === null) {
            this._cachedTextValue = this._lines.join(this._eol);
        }
        return this._cachedTextValue;
    }
    onEvents(e) {
        if (e.eol && e.eol !== this._eol) {
            this._eol = e.eol;
            this._lineStarts = null;
        }
        // Update my lines
        const changes = e.changes;
        for (const change of changes) {
            this._acceptDeleteRange(change.range);
            this._acceptInsertText(new _core_position_js__WEBPACK_IMPORTED_MODULE_1__.Position(change.range.startLineNumber, change.range.startColumn), change.text);
        }
        this._versionId = e.versionId;
        this._cachedTextValue = null;
    }
    _ensureLineStarts() {
        if (!this._lineStarts) {
            const eolLength = this._eol.length;
            const linesLength = this._lines.length;
            const lineStartValues = new Uint32Array(linesLength);
            for (let i = 0; i < linesLength; i++) {
                lineStartValues[i] = this._lines[i].length + eolLength;
            }
            this._lineStarts = new _prefixSumComputer_js__WEBPACK_IMPORTED_MODULE_2__.PrefixSumComputer(lineStartValues);
        }
    }
    /**
     * All changes to a line's text go through this method
     */
    _setLineText(lineIndex, newValue) {
        this._lines[lineIndex] = newValue;
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
        }
    }
    _acceptDeleteRange(range) {
        if (range.startLineNumber === range.endLineNumber) {
            if (range.startColumn === range.endColumn) {
                // Nothing to delete
                return;
            }
            // Delete text on the affected line
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
            return;
        }
        // Take remaining text on last line and append it to remaining text on first line
        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
        // Delete middle lines
        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        }
    }
    _acceptInsertText(position, insertText) {
        if (insertText.length === 0) {
            // Nothing to insert
            return;
        }
        const insertLines = (0,_base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitLines)(insertText);
        if (insertLines.length === 1) {
            // Inserting text on one line
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                + insertLines[0]
                + this._lines[position.lineNumber - 1].substring(position.column - 1));
            return;
        }
        // Append overflowing text from first line to the end of text to insert
        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
        // Delete overflowing text from first line and insert text on first line
        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
            + insertLines[0]);
        // Insert new lines & store lengths
        const newLengths = new Uint32Array(insertLines.length - 1);
        for (let i = 1; i < insertLines.length; i++) {
            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
            newLengths[i - 1] = insertLines[i].length + this._eol.length;
        }
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.insertValues(position.lineNumber, newLengths);
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js":
/*!************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConstantTimePrefixSumComputer: () => (/* binding */ ConstantTimePrefixSumComputer),
/* harmony export */   PrefixSumComputer: () => (/* binding */ PrefixSumComputer),
/* harmony export */   PrefixSumIndexOfResult: () => (/* binding */ PrefixSumIndexOfResult)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/uint.js */ "./node_modules/monaco-editor/esm/vs/base/common/uint.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


class PrefixSumComputer {
    constructor(values) {
        this.values = values;
        this.prefixSum = new Uint32Array(values.length);
        this.prefixSumValidIndex = new Int32Array(1);
        this.prefixSumValidIndex[0] = -1;
    }
    insertValues(insertIndex, insertValues) {
        insertIndex = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(insertIndex);
        const oldValues = this.values;
        const oldPrefixSum = this.prefixSum;
        const insertValuesLen = insertValues.length;
        if (insertValuesLen === 0) {
            return false;
        }
        this.values = new Uint32Array(oldValues.length + insertValuesLen);
        this.values.set(oldValues.subarray(0, insertIndex), 0);
        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
        this.values.set(insertValues, insertIndex);
        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = insertIndex - 1;
        }
        this.prefixSum = new Uint32Array(this.values.length);
        if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
        }
        return true;
    }
    setValue(index, value) {
        index = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(index);
        value = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(value);
        if (this.values[index] === value) {
            return false;
        }
        this.values[index] = value;
        if (index - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = index - 1;
        }
        return true;
    }
    removeValues(startIndex, count) {
        startIndex = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(startIndex);
        count = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(count);
        const oldValues = this.values;
        const oldPrefixSum = this.prefixSum;
        if (startIndex >= oldValues.length) {
            return false;
        }
        const maxCount = oldValues.length - startIndex;
        if (count >= maxCount) {
            count = maxCount;
        }
        if (count === 0) {
            return false;
        }
        this.values = new Uint32Array(oldValues.length - count);
        this.values.set(oldValues.subarray(0, startIndex), 0);
        this.values.set(oldValues.subarray(startIndex + count), startIndex);
        this.prefixSum = new Uint32Array(this.values.length);
        if (startIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = startIndex - 1;
        }
        if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
        }
        return true;
    }
    getTotalSum() {
        if (this.values.length === 0) {
            return 0;
        }
        return this._getPrefixSum(this.values.length - 1);
    }
    /**
     * Returns the sum of the first `index + 1` many items.
     * @returns `SUM(0 <= j <= index, values[j])`.
     */
    getPrefixSum(index) {
        if (index < 0) {
            return 0;
        }
        index = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(index);
        return this._getPrefixSum(index);
    }
    _getPrefixSum(index) {
        if (index <= this.prefixSumValidIndex[0]) {
            return this.prefixSum[index];
        }
        let startIndex = this.prefixSumValidIndex[0] + 1;
        if (startIndex === 0) {
            this.prefixSum[0] = this.values[0];
            startIndex++;
        }
        if (index >= this.values.length) {
            index = this.values.length - 1;
        }
        for (let i = startIndex; i <= index; i++) {
            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
        }
        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
        return this.prefixSum[index];
    }
    getIndexOf(sum) {
        sum = Math.floor(sum);
        // Compute all sums (to get a fully valid prefixSum)
        this.getTotalSum();
        let low = 0;
        let high = this.values.length - 1;
        let mid = 0;
        let midStop = 0;
        let midStart = 0;
        while (low <= high) {
            mid = low + ((high - low) / 2) | 0;
            midStop = this.prefixSum[mid];
            midStart = midStop - this.values[mid];
            if (sum < midStart) {
                high = mid - 1;
            }
            else if (sum >= midStop) {
                low = mid + 1;
            }
            else {
                break;
            }
        }
        return new PrefixSumIndexOfResult(mid, sum - midStart);
    }
}
/**
 * {@link getIndexOf} has an amortized runtime complexity of O(1).
 *
 * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))
*/
class ConstantTimePrefixSumComputer {
    constructor(values) {
        this._values = values;
        this._isValid = false;
        this._validEndIndex = -1;
        this._prefixSum = [];
        this._indexBySum = [];
    }
    /**
     * @returns SUM(0 <= j < values.length, values[j])
     */
    getTotalSum() {
        this._ensureValid();
        return this._indexBySum.length;
    }
    /**
     * Returns the sum of the first `count` many items.
     * @returns `SUM(0 <= j < count, values[j])`.
     */
    getPrefixSum(count) {
        this._ensureValid();
        if (count === 0) {
            return 0;
        }
        return this._prefixSum[count - 1];
    }
    /**
     * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`
     */
    getIndexOf(sum) {
        this._ensureValid();
        const idx = this._indexBySum[sum];
        const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;
        return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);
    }
    removeValues(start, deleteCount) {
        this._values.splice(start, deleteCount);
        this._invalidate(start);
    }
    insertValues(insertIndex, insertArr) {
        this._values = (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.arrayInsert)(this._values, insertIndex, insertArr);
        this._invalidate(insertIndex);
    }
    _invalidate(index) {
        this._isValid = false;
        this._validEndIndex = Math.min(this._validEndIndex, index - 1);
    }
    _ensureValid() {
        if (this._isValid) {
            return;
        }
        for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {
            const value = this._values[i];
            const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;
            this._prefixSum[i] = sumAbove + value;
            for (let j = 0; j < value; j++) {
                this._indexBySum[sumAbove + j] = i;
            }
        }
        // trim things
        this._prefixSum.length = this._values.length;
        this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];
        // mark as valid
        this._isValid = true;
        this._validEndIndex = this._values.length - 1;
    }
    setValue(index, value) {
        if (this._values[index] === value) {
            // no change
            return;
        }
        this._values[index] = value;
        this._invalidate(index);
    }
}
class PrefixSumIndexOfResult {
    constructor(index, remainder) {
        this.index = index;
        this.remainder = remainder;
        this._prefixSumIndexOfResultBrand = undefined;
        this.index = index;
        this.remainder = remainder;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SearchParams: () => (/* binding */ SearchParams),
/* harmony export */   Searcher: () => (/* binding */ Searcher),
/* harmony export */   TextModelSearch: () => (/* binding */ TextModelSearch),
/* harmony export */   createFindMatch: () => (/* binding */ createFindMatch),
/* harmony export */   isMultilineRegexSource: () => (/* binding */ isMultilineRegexSource),
/* harmony export */   isValidMatch: () => (/* binding */ isValidMatch)
/* harmony export */ });
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _core_wordCharacterClassifier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/wordCharacterClassifier.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





const LIMIT_FIND_COUNT = 999;
class SearchParams {
    constructor(searchString, isRegex, matchCase, wordSeparators) {
        this.searchString = searchString;
        this.isRegex = isRegex;
        this.matchCase = matchCase;
        this.wordSeparators = wordSeparators;
    }
    parseSearchRequest() {
        if (this.searchString === '') {
            return null;
        }
        // Try to create a RegExp out of the params
        let multiline;
        if (this.isRegex) {
            multiline = isMultilineRegexSource(this.searchString);
        }
        else {
            multiline = (this.searchString.indexOf('\n') >= 0);
        }
        let regex = null;
        try {
            regex = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.createRegExp(this.searchString, this.isRegex, {
                matchCase: this.matchCase,
                wholeWord: false,
                multiline: multiline,
                global: true,
                unicode: true
            });
        }
        catch (err) {
            return null;
        }
        if (!regex) {
            return null;
        }
        let canUseSimpleSearch = (!this.isRegex && !multiline);
        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {
            // casing might make a difference
            canUseSimpleSearch = this.matchCase;
        }
        return new _model_js__WEBPACK_IMPORTED_MODULE_4__.SearchData(regex, this.wordSeparators ? (0,_core_wordCharacterClassifier_js__WEBPACK_IMPORTED_MODULE_1__.getMapForWordSeparators)(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);
    }
}
function isMultilineRegexSource(searchString) {
    if (!searchString || searchString.length === 0) {
        return false;
    }
    for (let i = 0, len = searchString.length; i < len; i++) {
        const chCode = searchString.charCodeAt(i);
        if (chCode === 10 /* CharCode.LineFeed */) {
            return true;
        }
        if (chCode === 92 /* CharCode.Backslash */) {
            // move to next char
            i++;
            if (i >= len) {
                // string ends with a \
                break;
            }
            const nextChCode = searchString.charCodeAt(i);
            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {
                return true;
            }
        }
    }
    return false;
}
function createFindMatch(range, rawMatches, captureMatches) {
    if (!captureMatches) {
        return new _model_js__WEBPACK_IMPORTED_MODULE_4__.FindMatch(range, null);
    }
    const matches = [];
    for (let i = 0, len = rawMatches.length; i < len; i++) {
        matches[i] = rawMatches[i];
    }
    return new _model_js__WEBPACK_IMPORTED_MODULE_4__.FindMatch(range, matches);
}
class LineFeedCounter {
    constructor(text) {
        const lineFeedsOffsets = [];
        let lineFeedsOffsetsLen = 0;
        for (let i = 0, textLen = text.length; i < textLen; i++) {
            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {
                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;
            }
        }
        this._lineFeedsOffsets = lineFeedsOffsets;
    }
    findLineFeedCountBeforeOffset(offset) {
        const lineFeedsOffsets = this._lineFeedsOffsets;
        let min = 0;
        let max = lineFeedsOffsets.length - 1;
        if (max === -1) {
            // no line feeds
            return 0;
        }
        if (offset <= lineFeedsOffsets[0]) {
            // before first line feed
            return 0;
        }
        while (min < max) {
            const mid = min + ((max - min) / 2 >> 0);
            if (lineFeedsOffsets[mid] >= offset) {
                max = mid - 1;
            }
            else {
                if (lineFeedsOffsets[mid + 1] >= offset) {
                    // bingo!
                    min = mid;
                    max = mid;
                }
                else {
                    min = mid + 1;
                }
            }
        }
        return min + 1;
    }
}
class TextModelSearch {
    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return [];
        }
        if (searchData.regex.multiline) {
            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);
        }
        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);
    }
    /**
     * Multiline search always executes on the lines concatenated with \n.
     * We must therefore compensate for the count of \n in case the model is CRLF
     */
    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {
        let startOffset;
        let lineFeedCountBeforeMatch = 0;
        if (lfCounter) {
            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);
            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \r as there were \n */;
        }
        else {
            startOffset = deltaOffset + matchIndex;
        }
        let endOffset;
        if (lfCounter) {
            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);
            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;
            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \r as there were \n */;
        }
        else {
            endOffset = startOffset + match0.length;
        }
        const startPosition = model.getPositionAt(startOffset);
        const endPosition = model.getPositionAt(endOffset);
        return new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
    }
    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {
        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());
        // We always execute multiline search over the lines joined with \n
        // This makes it that \n will match the EOL for both CRLF and LF models
        // We compensate for offset errors in `_getMultilineMatchRange`
        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);
        const lfCounter = (model.getEOL() === '\r\n' ? new LineFeedCounter(text) : null);
        const result = [];
        let counter = 0;
        let m;
        searcher.reset(0);
        while ((m = searcher.next(text))) {
            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
            if (counter >= limitResultCount) {
                return result;
            }
        }
        return result;
    }
    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {
        const result = [];
        let resultLen = 0;
        // Early case for a search range that starts & stops on the same line number
        if (searchRange.startLineNumber === searchRange.endLineNumber) {
            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
            return result;
        }
        // Collect results from first line
        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);
        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
        // Collect results from middle lines
        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {
            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);
        }
        // Collect results from last line
        if (resultLen < limitResultCount) {
            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);
            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);
        }
        return result;
    }
    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
        const wordSeparators = searchData.wordSeparators;
        if (!captureMatches && searchData.simpleSearch) {
            const searchString = searchData.simpleSearch;
            const searchStringLen = searchString.length;
            const textLength = text.length;
            let lastMatchIndex = -searchStringLen;
            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
                    result[resultLen++] = new _model_js__WEBPACK_IMPORTED_MODULE_4__.FindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
                    if (resultLen >= limitResultCount) {
                        return resultLen;
                    }
                }
            }
            return resultLen;
        }
        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        let m;
        // Reset regex to search from the beginning
        searcher.reset(0);
        do {
            m = searcher.next(text);
            if (m) {
                result[resultLen++] = createFindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
                if (resultLen >= limitResultCount) {
                    return resultLen;
                }
            }
        } while (m);
        return resultLen;
    }
    static findNextMatch(model, searchParams, searchStart, captureMatches) {
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return null;
        }
        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        if (searchData.regex.multiline) {
            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);
        }
        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);
    }
    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {
        const searchTextStart = new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(searchStart.lineNumber, 1);
        const deltaOffset = model.getOffsetAt(searchTextStart);
        const lineCount = model.getLineCount();
        // We always execute multiline search over the lines joined with \n
        // This makes it that \n will match the EOL for both CRLF and LF models
        // We compensate for offset errors in `_getMultilineMatchRange`
        const text = model.getValueInRange(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);
        const lfCounter = (model.getEOL() === '\r\n' ? new LineFeedCounter(text) : null);
        searcher.reset(searchStart.column - 1);
        const m = searcher.next(text);
        if (m) {
            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
        }
        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {
            // Try again from the top
            return this._doFindNextMatchMultiline(model, new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(1, 1), searcher, captureMatches);
        }
        return null;
    }
    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {
        const lineCount = model.getLineCount();
        const startLineNumber = searchStart.lineNumber;
        // Look in first line
        const text = model.getLineContent(startLineNumber);
        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);
        if (r) {
            return r;
        }
        for (let i = 1; i <= lineCount; i++) {
            const lineIndex = (startLineNumber + i - 1) % lineCount;
            const text = model.getLineContent(lineIndex + 1);
            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);
            if (r) {
                return r;
            }
        }
        return null;
    }
    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {
        // Set regex to search from column
        searcher.reset(fromColumn - 1);
        const m = searcher.next(text);
        if (m) {
            return createFindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
        }
        return null;
    }
    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return null;
        }
        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        if (searchData.regex.multiline) {
            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);
        }
        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);
    }
    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {
        const matches = this._doFindMatchesMultiline(model, new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);
        if (matches.length > 0) {
            return matches[matches.length - 1];
        }
        const lineCount = model.getLineCount();
        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {
            // Try again with all content
            return this._doFindPreviousMatchMultiline(model, new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);
        }
        return null;
    }
    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {
        const lineCount = model.getLineCount();
        const startLineNumber = searchStart.lineNumber;
        // Look in first line
        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);
        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);
        if (r) {
            return r;
        }
        for (let i = 1; i <= lineCount; i++) {
            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;
            const text = model.getLineContent(lineIndex + 1);
            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);
            if (r) {
                return r;
            }
        }
        return null;
    }
    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {
        let bestResult = null;
        let m;
        searcher.reset(0);
        while ((m = searcher.next(text))) {
            bestResult = createFindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
        }
        return bestResult;
    }
}
function leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex === 0) {
        // Match starts at start of string
        return true;
    }
    const charBefore = text.charCodeAt(matchStartIndex - 1);
    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {
        // The character before the match is a word separator
        return true;
    }
    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {
        // The character before the match is line break or carriage return.
        return true;
    }
    if (matchLength > 0) {
        const firstCharInMatch = text.charCodeAt(matchStartIndex);
        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {
            // The first character inside the match is a word separator
            return true;
        }
    }
    return false;
}
function rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex + matchLength === textLength) {
        // Match ends at end of string
        return true;
    }
    const charAfter = text.charCodeAt(matchStartIndex + matchLength);
    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {
        // The character after the match is a word separator
        return true;
    }
    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {
        // The character after the match is line break or carriage return.
        return true;
    }
    if (matchLength > 0) {
        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {
            // The last character in the match is a word separator
            return true;
        }
    }
    return false;
}
function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)
        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));
}
class Searcher {
    constructor(wordSeparators, searchRegex) {
        this._wordSeparators = wordSeparators;
        this._searchRegex = searchRegex;
        this._prevMatchStartIndex = -1;
        this._prevMatchLength = 0;
    }
    reset(lastIndex) {
        this._searchRegex.lastIndex = lastIndex;
        this._prevMatchStartIndex = -1;
        this._prevMatchLength = 0;
    }
    next(text) {
        const textLength = text.length;
        let m;
        do {
            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
                // Reached the end of the line
                return null;
            }
            m = this._searchRegex.exec(text);
            if (!m) {
                return null;
            }
            const matchStartIndex = m.index;
            const matchLength = m[0].length;
            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
                if (matchLength === 0) {
                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here
                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise
                    if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {
                        this._searchRegex.lastIndex += 2;
                    }
                    else {
                        this._searchRegex.lastIndex += 1;
                    }
                    continue;
                }
                // Exit early if the regex matches the same range twice
                return null;
            }
            this._prevMatchStartIndex = matchStartIndex;
            this._prevMatchLength = matchLength;
            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
                return m;
            }
        } while (m);
        return null;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyMod: () => (/* binding */ KeyMod),
/* harmony export */   createMonacoBaseAPI: () => (/* binding */ createMonacoBaseAPI)
/* harmony export */ });
/* harmony import */ var _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/cancellation.js */ "./node_modules/monaco-editor/esm/vs/base/common/cancellation.js");
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_keyCodes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/keyCodes.js */ "./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js");
/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/uri.js */ "./node_modules/monaco-editor/esm/vs/base/common/uri.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _core_selection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/selection.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js");
/* harmony import */ var _languages_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../languages.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages.js");
/* harmony import */ var _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../standalone/standaloneEnums.js */ "./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









class KeyMod {
    static { this.CtrlCmd = 2048 /* ConstKeyMod.CtrlCmd */; }
    static { this.Shift = 1024 /* ConstKeyMod.Shift */; }
    static { this.Alt = 512 /* ConstKeyMod.Alt */; }
    static { this.WinCtrl = 256 /* ConstKeyMod.WinCtrl */; }
    static chord(firstPart, secondPart) {
        return (0,_base_common_keyCodes_js__WEBPACK_IMPORTED_MODULE_2__.KeyChord)(firstPart, secondPart);
    }
}
function createMonacoBaseAPI() {
    return {
        editor: undefined, // undefined override expected here
        languages: undefined, // undefined override expected here
        CancellationTokenSource: _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource,
        Emitter: _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter,
        KeyCode: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.KeyCode,
        KeyMod: KeyMod,
        Position: _core_position_js__WEBPACK_IMPORTED_MODULE_4__.Position,
        Range: _core_range_js__WEBPACK_IMPORTED_MODULE_5__.Range,
        Selection: _core_selection_js__WEBPACK_IMPORTED_MODULE_6__.Selection,
        SelectionDirection: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.SelectionDirection,
        MarkerSeverity: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.MarkerSeverity,
        MarkerTag: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.MarkerTag,
        Uri: _base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI,
        Token: _languages_js__WEBPACK_IMPORTED_MODULE_7__.Token
    };
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseEditorSimpleWorker: () => (/* binding */ BaseEditorSimpleWorker),
/* harmony export */   EditorSimpleWorker: () => (/* binding */ EditorSimpleWorker),
/* harmony export */   create: () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/diff/diff.js */ "./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _languages_linkComputer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../languages/linkComputer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js");
/* harmony import */ var _languages_supports_inplaceReplaceSupport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../languages/supports/inplaceReplaceSupport.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js");
/* harmony import */ var _editorBaseApi_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editorBaseApi.js */ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js");
/* harmony import */ var _editorWorkerHost_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./editorWorkerHost.js */ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js");
/* harmony import */ var _base_common_stopwatch_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../base/common/stopwatch.js */ "./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js");
/* harmony import */ var _unicodeTextModelHighlighter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./unicodeTextModelHighlighter.js */ "./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js");
/* harmony import */ var _diff_linesDiffComputers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../diff/linesDiffComputers.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js");
/* harmony import */ var _base_common_objects_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../base/common/objects.js */ "./node_modules/monaco-editor/esm/vs/base/common/objects.js");
/* harmony import */ var _base_common_network_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../base/common/network.js */ "./node_modules/monaco-editor/esm/vs/base/common/network.js");
/* harmony import */ var _languages_defaultDocumentColorsComputer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../languages/defaultDocumentColorsComputer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js");
/* harmony import */ var _findSectionHeaders_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./findSectionHeaders.js */ "./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js");
/* harmony import */ var _textModelSync_textModelSync_impl_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textModelSync/textModelSync.impl.js */ "./node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














// ESM-comment-begin
// const isESM = false;
// ESM-comment-end
// ESM-uncomment-begin
const isESM = true;
/**
 * @internal
 */
class BaseEditorSimpleWorker {
    constructor() {
        this._workerTextModelSyncServer = new _textModelSync_textModelSync_impl_js__WEBPACK_IMPORTED_MODULE_13__.WorkerTextModelSyncServer();
    }
    dispose() {
    }
    _getModel(uri) {
        return this._workerTextModelSyncServer.getModel(uri);
    }
    _getModels() {
        return this._workerTextModelSyncServer.getModels();
    }
    $acceptNewModel(data) {
        this._workerTextModelSyncServer.$acceptNewModel(data);
    }
    $acceptModelChanged(uri, e) {
        this._workerTextModelSyncServer.$acceptModelChanged(uri, e);
    }
    $acceptRemovedModel(uri) {
        this._workerTextModelSyncServer.$acceptRemovedModel(uri);
    }
    async $computeUnicodeHighlights(url, options, range) {
        const model = this._getModel(url);
        if (!model) {
            return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
        }
        return _unicodeTextModelHighlighter_js__WEBPACK_IMPORTED_MODULE_7__.UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
    }
    async $findSectionHeaders(url, options) {
        const model = this._getModel(url);
        if (!model) {
            return [];
        }
        return (0,_findSectionHeaders_js__WEBPACK_IMPORTED_MODULE_12__.findSectionHeaders)(model, options);
    }
    // ---- BEGIN diff --------------------------------------------------------------------------
    async $computeDiff(originalUrl, modifiedUrl, options, algorithm) {
        const original = this._getModel(originalUrl);
        const modified = this._getModel(modifiedUrl);
        if (!original || !modified) {
            return null;
        }
        const result = EditorSimpleWorker.computeDiff(original, modified, options, algorithm);
        return result;
    }
    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {
        const diffAlgorithm = algorithm === 'advanced' ? _diff_linesDiffComputers_js__WEBPACK_IMPORTED_MODULE_8__.linesDiffComputers.getDefault() : _diff_linesDiffComputers_js__WEBPACK_IMPORTED_MODULE_8__.linesDiffComputers.getLegacy();
        const originalLines = originalTextModel.getLinesContent();
        const modifiedLines = modifiedTextModel.getLinesContent();
        const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);
        const identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));
        function getLineChanges(changes) {
            return changes.map(m => ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, m.innerChanges?.map(m => [
                    m.originalRange.startLineNumber,
                    m.originalRange.startColumn,
                    m.originalRange.endLineNumber,
                    m.originalRange.endColumn,
                    m.modifiedRange.startLineNumber,
                    m.modifiedRange.startColumn,
                    m.modifiedRange.endLineNumber,
                    m.modifiedRange.endColumn,
                ])]));
        }
        return {
            identical,
            quitEarly: result.hitTimeout,
            changes: getLineChanges(result.changes),
            moves: result.moves.map(m => ([
                m.lineRangeMapping.original.startLineNumber,
                m.lineRangeMapping.original.endLineNumberExclusive,
                m.lineRangeMapping.modified.startLineNumber,
                m.lineRangeMapping.modified.endLineNumberExclusive,
                getLineChanges(m.changes)
            ])),
        };
    }
    static _modelsAreIdentical(original, modified) {
        const originalLineCount = original.getLineCount();
        const modifiedLineCount = modified.getLineCount();
        if (originalLineCount !== modifiedLineCount) {
            return false;
        }
        for (let line = 1; line <= originalLineCount; line++) {
            const originalLine = original.getLineContent(line);
            const modifiedLine = modified.getLineContent(line);
            if (originalLine !== modifiedLine) {
                return false;
            }
        }
        return true;
    }
    // ---- END diff --------------------------------------------------------------------------
    // ---- BEGIN minimal edits ---------------------------------------------------------------
    static { this._diffLimit = 100000; }
    async $computeMoreMinimalEdits(modelUrl, edits, pretty) {
        const model = this._getModel(modelUrl);
        if (!model) {
            return edits;
        }
        const result = [];
        let lastEol = undefined;
        edits = edits.slice(0).sort((a, b) => {
            if (a.range && b.range) {
                return _core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range.compareRangesUsingStarts(a.range, b.range);
            }
            // eol only changes should go to the end
            const aRng = a.range ? 0 : 1;
            const bRng = b.range ? 0 : 1;
            return aRng - bRng;
        });
        // merge adjacent edits
        let writeIndex = 0;
        for (let readIndex = 1; readIndex < edits.length; readIndex++) {
            if (_core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range.getEndPosition(edits[writeIndex].range).equals(_core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range.getStartPosition(edits[readIndex].range))) {
                edits[writeIndex].range = _core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range.fromPositions(_core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range.getStartPosition(edits[writeIndex].range), _core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range.getEndPosition(edits[readIndex].range));
                edits[writeIndex].text += edits[readIndex].text;
            }
            else {
                writeIndex++;
                edits[writeIndex] = edits[readIndex];
            }
        }
        edits.length = writeIndex + 1;
        for (let { range, text, eol } of edits) {
            if (typeof eol === 'number') {
                lastEol = eol;
            }
            if (_core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range.isEmpty(range) && !text) {
                // empty change
                continue;
            }
            const original = model.getValueInRange(range);
            text = text.replace(/\r\n|\n|\r/g, model.eol);
            if (original === text) {
                // noop
                continue;
            }
            // make sure diff won't take too long
            if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
                result.push({ range, text });
                continue;
            }
            // compute diff between original and edit.text
            const changes = (0,_base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__.stringDiff)(original, text, pretty);
            const editOffset = model.offsetAt(_core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range.lift(range).getStartPosition());
            for (const change of changes) {
                const start = model.positionAt(editOffset + change.originalStart);
                const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
                const newEdit = {
                    text: text.substr(change.modifiedStart, change.modifiedLength),
                    range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
                };
                if (model.getValueInRange(newEdit.range) !== newEdit.text) {
                    result.push(newEdit);
                }
            }
        }
        if (typeof lastEol === 'number') {
            result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
        }
        return result;
    }
    // ---- END minimal edits ---------------------------------------------------------------
    async $computeLinks(modelUrl) {
        const model = this._getModel(modelUrl);
        if (!model) {
            return null;
        }
        return (0,_languages_linkComputer_js__WEBPACK_IMPORTED_MODULE_2__.computeLinks)(model);
    }
    // --- BEGIN default document colors -----------------------------------------------------------
    async $computeDefaultDocumentColors(modelUrl) {
        const model = this._getModel(modelUrl);
        if (!model) {
            return null;
        }
        return (0,_languages_defaultDocumentColorsComputer_js__WEBPACK_IMPORTED_MODULE_11__.computeDefaultDocumentColors)(model);
    }
    // ---- BEGIN suggest --------------------------------------------------------------------------
    static { this._suggestionsLimit = 10000; }
    async $textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
        const sw = new _base_common_stopwatch_js__WEBPACK_IMPORTED_MODULE_6__.StopWatch();
        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
        const seen = new Set();
        outer: for (const url of modelUrls) {
            const model = this._getModel(url);
            if (!model) {
                continue;
            }
            for (const word of model.words(wordDefRegExp)) {
                if (word === leadingWord || !isNaN(Number(word))) {
                    continue;
                }
                seen.add(word);
                if (seen.size > EditorSimpleWorker._suggestionsLimit) {
                    break outer;
                }
            }
        }
        return { words: Array.from(seen), duration: sw.elapsed() };
    }
    // ---- END suggest --------------------------------------------------------------------------
    //#region -- word ranges --
    async $computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
        const model = this._getModel(modelUrl);
        if (!model) {
            return Object.create(null);
        }
        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
        const result = Object.create(null);
        for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
            const words = model.getLineWords(line, wordDefRegExp);
            for (const word of words) {
                if (!isNaN(Number(word.word))) {
                    continue;
                }
                let array = result[word.word];
                if (!array) {
                    array = [];
                    result[word.word] = array;
                }
                array.push({
                    startLineNumber: line,
                    startColumn: word.startColumn,
                    endLineNumber: line,
                    endColumn: word.endColumn
                });
            }
        }
        return result;
    }
    //#endregion
    async $navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
        const model = this._getModel(modelUrl);
        if (!model) {
            return null;
        }
        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
        if (range.startColumn === range.endColumn) {
            range = {
                startLineNumber: range.startLineNumber,
                startColumn: range.startColumn,
                endLineNumber: range.endLineNumber,
                endColumn: range.endColumn + 1
            };
        }
        const selectionText = model.getValueInRange(range);
        const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
        if (!wordRange) {
            return null;
        }
        const word = model.getValueInRange(wordRange);
        const result = _languages_supports_inplaceReplaceSupport_js__WEBPACK_IMPORTED_MODULE_3__.BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
        return result;
    }
}
/**
 * @internal
 */
class EditorSimpleWorker extends BaseEditorSimpleWorker {
    constructor(_host, _foreignModuleFactory) {
        super();
        this._host = _host;
        this._foreignModuleFactory = _foreignModuleFactory;
        this._foreignModule = null;
    }
    async $ping() {
        return 'pong';
    }
    // ---- BEGIN foreign module support --------------------------------------------------------------------------
    $loadForeignModule(moduleId, createData, foreignHostMethods) {
        const proxyMethodRequest = (method, args) => {
            return this._host.$fhr(method, args);
        };
        const foreignHost = (0,_base_common_objects_js__WEBPACK_IMPORTED_MODULE_9__.createProxyObject)(foreignHostMethods, proxyMethodRequest);
        const ctx = {
            host: foreignHost,
            getMirrorModels: () => {
                return this._getModels();
            }
        };
        if (this._foreignModuleFactory) {
            this._foreignModule = this._foreignModuleFactory(ctx, createData);
            // static foreing module
            return Promise.resolve((0,_base_common_objects_js__WEBPACK_IMPORTED_MODULE_9__.getAllMethodNames)(this._foreignModule));
        }
        return new Promise((resolve, reject) => {
            const onModuleCallback = (foreignModule) => {
                this._foreignModule = foreignModule.create(ctx, createData);
                resolve((0,_base_common_objects_js__WEBPACK_IMPORTED_MODULE_9__.getAllMethodNames)(this._foreignModule));
            };
            if (!isESM) {
                Promise.all(/*! AMD require */[__webpack_require__.e("vendors-node_modules_monaco-editor_esm_vs_base_common_resources_js-node_modules_monaco-editor-609760"), __webpack_require__.e("vendors-node_modules_monaco-editor_esm_vs_base_common_glob_js"), __webpack_require__.e("vendors-node_modules_monaco-editor_esm_vs_platform_log_common_log_js"), __webpack_require__.e("vendors-node_modules_monaco-editor_esm_vs_editor_common_core_editorColorRegistry_js"), __webpack_require__.e("vendors-node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensProviderStyling_js"), __webpack_require__.e("vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languagesRegistry_js"), __webpack_require__.e("vendors-node_modules_monaco-editor_esm_vs_editor_common_services_modelService_js"), __webpack_require__.e("vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languageService_js"), __webpack_require__.e("vendors-node_modules_monaco-editor_esm_vs_editor_common_services_markerDecorationsService_js"), __webpack_require__.e("vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languageFeaturesService_js"), __webpack_require__.e("vendors-node_modules_monaco-editor_esm_vs_editor_common_services_editorWorker_js-node_modules-4cdb0c"), __webpack_require__.e("node_modules_monaco-editor_esm_vs_editor_common_services_sync_recursive_")]).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/services sync recursive ^.*$")(`${moduleId}`)]; (onModuleCallback).apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);}.bind(this))['catch'](reject.bind(this));
            }
            else {
                const url = _base_common_network_js__WEBPACK_IMPORTED_MODULE_10__.FileAccess.asBrowserUri(`${moduleId}.js`).toString(true);
                __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/services lazy recursive ^.*$")(`${url}`).then(onModuleCallback).catch(reject);
            }
        });
    }
    // foreign method request
    $fmr(method, args) {
        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {
            return Promise.reject(new Error('Missing requestHandler or method: ' + method));
        }
        try {
            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
}
/**
 * Defines the worker entry point. Must be exported and named `create`.
 * @skipMangle
 * @internal
 */
function create(workerServer) {
    return new EditorSimpleWorker(_editorWorkerHost_js__WEBPACK_IMPORTED_MODULE_5__.EditorWorkerHost.getChannel(workerServer), null);
}
if (typeof importScripts === 'function') {
    // Running in a web worker
    globalThis.monaco = (0,_editorBaseApi_js__WEBPACK_IMPORTED_MODULE_4__.createMonacoBaseAPI)();
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EditorWorkerHost: () => (/* binding */ EditorWorkerHost)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class EditorWorkerHost {
    static { this.CHANNEL_NAME = 'editorWorkerHost'; }
    static getChannel(workerServer) {
        return workerServer.getChannel(EditorWorkerHost.CHANNEL_NAME);
    }
    static setChannel(workerClient, obj) {
        workerClient.setChannel(EditorWorkerHost.CHANNEL_NAME, obj);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findSectionHeaders: () => (/* binding */ findSectionHeaders)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const markRegex = new RegExp('\\bMARK:\\s*(.*)$', 'd');
const trimDashesRegex = /^-+|-+$/g;
/**
 * Find section headers in the model.
 *
 * @param model the text model to search in
 * @param options options to search with
 * @returns an array of section headers
 */
function findSectionHeaders(model, options) {
    let headers = [];
    if (options.findRegionSectionHeaders && options.foldingRules?.markers) {
        const regionHeaders = collectRegionHeaders(model, options);
        headers = headers.concat(regionHeaders);
    }
    if (options.findMarkSectionHeaders) {
        const markHeaders = collectMarkHeaders(model);
        headers = headers.concat(markHeaders);
    }
    return headers;
}
function collectRegionHeaders(model, options) {
    const regionHeaders = [];
    const endLineNumber = model.getLineCount();
    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {
        const lineContent = model.getLineContent(lineNumber);
        const match = lineContent.match(options.foldingRules.markers.start);
        if (match) {
            const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };
            if (range.endColumn > range.startColumn) {
                const sectionHeader = {
                    range,
                    ...getHeaderText(lineContent.substring(match[0].length)),
                    shouldBeInComments: false
                };
                if (sectionHeader.text || sectionHeader.hasSeparatorLine) {
                    regionHeaders.push(sectionHeader);
                }
            }
        }
    }
    return regionHeaders;
}
function collectMarkHeaders(model) {
    const markHeaders = [];
    const endLineNumber = model.getLineCount();
    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {
        const lineContent = model.getLineContent(lineNumber);
        addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);
    }
    return markHeaders;
}
function addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {
    markRegex.lastIndex = 0;
    const match = markRegex.exec(lineContent);
    if (match) {
        const column = match.indices[1][0] + 1;
        const endColumn = match.indices[1][1] + 1;
        const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: endColumn };
        if (range.endColumn > range.startColumn) {
            const sectionHeader = {
                range,
                ...getHeaderText(match[1]),
                shouldBeInComments: true
            };
            if (sectionHeader.text || sectionHeader.hasSeparatorLine) {
                sectionHeaders.push(sectionHeader);
            }
        }
    }
}
function getHeaderText(text) {
    text = text.trim();
    const hasSeparatorLine = text.startsWith('-');
    text = text.replace(trimDashesRegex, '');
    return { text, hasSeparatorLine };
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MirrorModel: () => (/* binding */ MirrorModel),
/* harmony export */   STOP_SYNC_MODEL_DELTA_TIME_MS: () => (/* binding */ STOP_SYNC_MODEL_DELTA_TIME_MS),
/* harmony export */   WorkerTextModelSyncClient: () => (/* binding */ WorkerTextModelSyncClient),
/* harmony export */   WorkerTextModelSyncServer: () => (/* binding */ WorkerTextModelSyncServer)
/* harmony export */ });
/* harmony import */ var _base_common_async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/async.js */ "./node_modules/monaco-editor/esm/vs/base/common/async.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../base/common/uri.js */ "./node_modules/monaco-editor/esm/vs/base/common/uri.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/wordHelper.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js");
/* harmony import */ var _model_mirrorTextModel_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../model/mirrorTextModel.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/







/**
 * Stop syncing a model to the worker if it was not needed for 1 min.
 */
const STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1000;
class WorkerTextModelSyncClient extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    constructor(proxy, modelService, keepIdleModels = false) {
        super();
        this._syncedModels = Object.create(null);
        this._syncedModelsLastUsedTime = Object.create(null);
        this._proxy = proxy;
        this._modelService = modelService;
        if (!keepIdleModels) {
            const timer = new _base_common_async_js__WEBPACK_IMPORTED_MODULE_0__.IntervalTimer();
            timer.cancelAndSet(() => this._checkStopModelSync(), Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));
            this._register(timer);
        }
    }
    dispose() {
        for (const modelUrl in this._syncedModels) {
            (0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.dispose)(this._syncedModels[modelUrl]);
        }
        this._syncedModels = Object.create(null);
        this._syncedModelsLastUsedTime = Object.create(null);
        super.dispose();
    }
    ensureSyncedResources(resources, forceLargeModels = false) {
        for (const resource of resources) {
            const resourceStr = resource.toString();
            if (!this._syncedModels[resourceStr]) {
                this._beginModelSync(resource, forceLargeModels);
            }
            if (this._syncedModels[resourceStr]) {
                this._syncedModelsLastUsedTime[resourceStr] = (new Date()).getTime();
            }
        }
    }
    _checkStopModelSync() {
        const currentTime = (new Date()).getTime();
        const toRemove = [];
        for (const modelUrl in this._syncedModelsLastUsedTime) {
            const elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];
            if (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {
                toRemove.push(modelUrl);
            }
        }
        for (const e of toRemove) {
            this._stopModelSync(e);
        }
    }
    _beginModelSync(resource, forceLargeModels) {
        const model = this._modelService.getModel(resource);
        if (!model) {
            return;
        }
        if (!forceLargeModels && model.isTooLargeForSyncing()) {
            return;
        }
        const modelUrl = resource.toString();
        this._proxy.$acceptNewModel({
            url: model.uri.toString(),
            lines: model.getLinesContent(),
            EOL: model.getEOL(),
            versionId: model.getVersionId()
        });
        const toDispose = new _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore();
        toDispose.add(model.onDidChangeContent((e) => {
            this._proxy.$acceptModelChanged(modelUrl.toString(), e);
        }));
        toDispose.add(model.onWillDispose(() => {
            this._stopModelSync(modelUrl);
        }));
        toDispose.add((0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
            this._proxy.$acceptRemovedModel(modelUrl);
        }));
        this._syncedModels[modelUrl] = toDispose;
    }
    _stopModelSync(modelUrl) {
        const toDispose = this._syncedModels[modelUrl];
        delete this._syncedModels[modelUrl];
        delete this._syncedModelsLastUsedTime[modelUrl];
        (0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.dispose)(toDispose);
    }
}
class WorkerTextModelSyncServer {
    constructor() {
        this._models = Object.create(null);
    }
    getModel(uri) {
        return this._models[uri];
    }
    getModels() {
        const all = [];
        Object.keys(this._models).forEach((key) => all.push(this._models[key]));
        return all;
    }
    $acceptNewModel(data) {
        this._models[data.url] = new MirrorModel(_base_common_uri_js__WEBPACK_IMPORTED_MODULE_2__.URI.parse(data.url), data.lines, data.EOL, data.versionId);
    }
    $acceptModelChanged(uri, e) {
        if (!this._models[uri]) {
            return;
        }
        const model = this._models[uri];
        model.onEvents(e);
    }
    $acceptRemovedModel(uri) {
        if (!this._models[uri]) {
            return;
        }
        delete this._models[uri];
    }
}
class MirrorModel extends _model_mirrorTextModel_js__WEBPACK_IMPORTED_MODULE_6__.MirrorTextModel {
    get uri() {
        return this._uri;
    }
    get eol() {
        return this._eol;
    }
    getValue() {
        return this.getText();
    }
    findMatches(regex) {
        const matches = [];
        for (let i = 0; i < this._lines.length; i++) {
            const line = this._lines[i];
            const offsetToAdd = this.offsetAt(new _core_position_js__WEBPACK_IMPORTED_MODULE_3__.Position(i + 1, 1));
            const iteratorOverMatches = line.matchAll(regex);
            for (const match of iteratorOverMatches) {
                if (match.index || match.index === 0) {
                    match.index = match.index + offsetToAdd;
                }
                matches.push(match);
            }
        }
        return matches;
    }
    getLinesContent() {
        return this._lines.slice(0);
    }
    getLineCount() {
        return this._lines.length;
    }
    getLineContent(lineNumber) {
        return this._lines[lineNumber - 1];
    }
    getWordAtPosition(position, wordDefinition) {
        const wordAtText = (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_5__.getWordAtText)(position.column, (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_5__.ensureValidWordDefinition)(wordDefinition), this._lines[position.lineNumber - 1], 0);
        if (wordAtText) {
            return new _core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
        }
        return null;
    }
    words(wordDefinition) {
        const lines = this._lines;
        const wordenize = this._wordenize.bind(this);
        let lineNumber = 0;
        let lineText = '';
        let wordRangesIdx = 0;
        let wordRanges = [];
        return {
            *[Symbol.iterator]() {
                while (true) {
                    if (wordRangesIdx < wordRanges.length) {
                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
                        wordRangesIdx += 1;
                        yield value;
                    }
                    else {
                        if (lineNumber < lines.length) {
                            lineText = lines[lineNumber];
                            wordRanges = wordenize(lineText, wordDefinition);
                            wordRangesIdx = 0;
                            lineNumber += 1;
                        }
                        else {
                            break;
                        }
                    }
                }
            }
        };
    }
    getLineWords(lineNumber, wordDefinition) {
        const content = this._lines[lineNumber - 1];
        const ranges = this._wordenize(content, wordDefinition);
        const words = [];
        for (const range of ranges) {
            words.push({
                word: content.substring(range.start, range.end),
                startColumn: range.start + 1,
                endColumn: range.end + 1
            });
        }
        return words;
    }
    _wordenize(content, wordDefinition) {
        const result = [];
        let match;
        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure
        while (match = wordDefinition.exec(content)) {
            if (match[0].length === 0) {
                // it did match the empty string
                break;
            }
            result.push({ start: match.index, end: match.index + match[0].length });
        }
        return result;
    }
    getValueInRange(range) {
        range = this._validateRange(range);
        if (range.startLineNumber === range.endLineNumber) {
            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
        }
        const lineEnding = this._eol;
        const startLineIndex = range.startLineNumber - 1;
        const endLineIndex = range.endLineNumber - 1;
        const resultLines = [];
        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
        for (let i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._lines[i]);
        }
        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
        return resultLines.join(lineEnding);
    }
    offsetAt(position) {
        position = this._validatePosition(position);
        this._ensureLineStarts();
        return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
    }
    positionAt(offset) {
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        this._ensureLineStarts();
        const out = this._lineStarts.getIndexOf(offset);
        const lineLength = this._lines[out.index].length;
        // Ensure we return a valid position
        return {
            lineNumber: 1 + out.index,
            column: 1 + Math.min(out.remainder, lineLength)
        };
    }
    _validateRange(range) {
        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
        if (start.lineNumber !== range.startLineNumber
            || start.column !== range.startColumn
            || end.lineNumber !== range.endLineNumber
            || end.column !== range.endColumn) {
            return {
                startLineNumber: start.lineNumber,
                startColumn: start.column,
                endLineNumber: end.lineNumber,
                endColumn: end.column
            };
        }
        return range;
    }
    _validatePosition(position) {
        if (!_core_position_js__WEBPACK_IMPORTED_MODULE_3__.Position.isIPosition(position)) {
            throw new Error('bad position');
        }
        let { lineNumber, column } = position;
        let hasChanged = false;
        if (lineNumber < 1) {
            lineNumber = 1;
            column = 1;
            hasChanged = true;
        }
        else if (lineNumber > this._lines.length) {
            lineNumber = this._lines.length;
            column = this._lines[lineNumber - 1].length + 1;
            hasChanged = true;
        }
        else {
            const maxCharacter = this._lines[lineNumber - 1].length + 1;
            if (column < 1) {
                column = 1;
                hasChanged = true;
            }
            else if (column > maxCharacter) {
                column = maxCharacter;
                hasChanged = true;
            }
        }
        if (!hasChanged) {
            return position;
        }
        else {
            return { lineNumber, column };
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnicodeTextModelHighlighter: () => (/* binding */ UnicodeTextModelHighlighter)
/* harmony export */ });
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _model_textModelSearch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/textModelSearch.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js");
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _base_common_assert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/assert.js */ "./node_modules/monaco-editor/esm/vs/base/common/assert.js");
/* harmony import */ var _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/wordHelper.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





class UnicodeTextModelHighlighter {
    static computeUnicodeHighlights(model, options, range) {
        const startLine = range ? range.startLineNumber : 1;
        const endLine = range ? range.endLineNumber : model.getLineCount();
        const codePointHighlighter = new CodePointHighlighter(options);
        const candidates = codePointHighlighter.getCandidateCodePoints();
        let regex;
        if (candidates === 'allNonBasicAscii') {
            regex = new RegExp('[^\\t\\n\\r\\x20-\\x7E]', 'g');
        }
        else {
            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');
        }
        const searcher = new _model_textModelSearch_js__WEBPACK_IMPORTED_MODULE_1__.Searcher(null, regex);
        const ranges = [];
        let hasMore = false;
        let m;
        let ambiguousCharacterCount = 0;
        let invisibleCharacterCount = 0;
        let nonBasicAsciiCharacterCount = 0;
        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
            const lineContent = model.getLineContent(lineNumber);
            const lineLength = lineContent.length;
            // Reset regex to search from the beginning
            searcher.reset(0);
            do {
                m = searcher.next(lineContent);
                if (m) {
                    let startIndex = m.index;
                    let endIndex = m.index + m[0].length;
                    // Extend range to entire code point
                    if (startIndex > 0) {
                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
                        if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.isHighSurrogate(charCodeBefore)) {
                            startIndex--;
                        }
                    }
                    if (endIndex + 1 < lineLength) {
                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
                        if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.isHighSurrogate(charCodeBefore)) {
                            endIndex++;
                        }
                    }
                    const str = lineContent.substring(startIndex, endIndex);
                    let word = (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_4__.getWordAtText)(startIndex + 1, _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_WORD_REGEXP, lineContent, 0);
                    if (word && word.endColumn <= startIndex + 1) {
                        // The word does not include the problematic character, ignore the word
                        word = null;
                    }
                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
                    if (highlightReason !== 0 /* SimpleHighlightReason.None */) {
                        if (highlightReason === 3 /* SimpleHighlightReason.Ambiguous */) {
                            ambiguousCharacterCount++;
                        }
                        else if (highlightReason === 2 /* SimpleHighlightReason.Invisible */) {
                            invisibleCharacterCount++;
                        }
                        else if (highlightReason === 1 /* SimpleHighlightReason.NonBasicASCII */) {
                            nonBasicAsciiCharacterCount++;
                        }
                        else {
                            (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_3__.assertNever)(highlightReason);
                        }
                        const MAX_RESULT_LENGTH = 1000;
                        if (ranges.length >= MAX_RESULT_LENGTH) {
                            hasMore = true;
                            break forLoop;
                        }
                        ranges.push(new _core_range_js__WEBPACK_IMPORTED_MODULE_0__.Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
                    }
                }
            } while (m);
        }
        return {
            ranges,
            hasMore,
            ambiguousCharacterCount,
            invisibleCharacterCount,
            nonBasicAsciiCharacterCount
        };
    }
    static computeUnicodeHighlightReason(char, options) {
        const codePointHighlighter = new CodePointHighlighter(options);
        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
        switch (reason) {
            case 0 /* SimpleHighlightReason.None */:
                return null;
            case 2 /* SimpleHighlightReason.Invisible */:
                return { kind: 1 /* UnicodeHighlighterReasonKind.Invisible */ };
            case 3 /* SimpleHighlightReason.Ambiguous */: {
                const codePoint = char.codePointAt(0);
                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
                const notAmbiguousInLocales = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.AmbiguousCharacters.getLocales().filter((l) => !_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
                return { kind: 0 /* UnicodeHighlighterReasonKind.Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
            }
            case 1 /* SimpleHighlightReason.NonBasicASCII */:
                return { kind: 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */ };
        }
    }
}
function buildRegExpCharClassExpr(codePoints, flags) {
    const src = `[${_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;
    return src;
}
class CodePointHighlighter {
    constructor(options) {
        this.options = options;
        this.allowedCodePoints = new Set(options.allowedCodePoints);
        this.ambiguousCharacters = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
    }
    getCandidateCodePoints() {
        if (this.options.nonBasicASCII) {
            return 'allNonBasicAscii';
        }
        const set = new Set();
        if (this.options.invisibleCharacters) {
            for (const cp of _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.InvisibleCharacters.codePoints) {
                if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
                    set.add(cp);
                }
            }
        }
        if (this.options.ambiguousCharacters) {
            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
                set.add(cp);
            }
        }
        for (const cp of this.allowedCodePoints) {
            set.delete(cp);
        }
        return set;
    }
    shouldHighlightNonBasicASCII(character, wordContext) {
        const codePoint = character.codePointAt(0);
        if (this.allowedCodePoints.has(codePoint)) {
            return 0 /* SimpleHighlightReason.None */;
        }
        if (this.options.nonBasicASCII) {
            return 1 /* SimpleHighlightReason.NonBasicASCII */;
        }
        let hasBasicASCIICharacters = false;
        let hasNonConfusableNonBasicAsciiCharacter = false;
        if (wordContext) {
            for (const char of wordContext) {
                const codePoint = char.codePointAt(0);
                const isBasicASCII = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.isBasicASCII(char);
                hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;
                if (!isBasicASCII &&
                    !this.ambiguousCharacters.isAmbiguous(codePoint) &&
                    !_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.InvisibleCharacters.isInvisibleCharacter(codePoint)) {
                    hasNonConfusableNonBasicAsciiCharacter = true;
                }
            }
        }
        if (
        /* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&
            /* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter) {
            return 0 /* SimpleHighlightReason.None */;
        }
        if (this.options.invisibleCharacters) {
            // TODO check for emojis
            if (!isAllowedInvisibleCharacter(character) && _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.InvisibleCharacters.isInvisibleCharacter(codePoint)) {
                return 2 /* SimpleHighlightReason.Invisible */;
            }
        }
        if (this.options.ambiguousCharacters) {
            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
                return 3 /* SimpleHighlightReason.Ambiguous */;
            }
        }
        return 0 /* SimpleHighlightReason.None */;
    }
}
function isAllowedInvisibleCharacter(character) {
    return character === ' ' || character === '\n' || character === '\t';
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services lazy recursive ^.*$":
/*!**********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/ lazy ^.*$ namespace object ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./editorBaseApi": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js"
	],
	"./editorBaseApi.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js"
	],
	"./editorSimpleWorker": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js"
	],
	"./editorSimpleWorker.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js"
	],
	"./editorWorker": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorker.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_editorWorker_js"
	],
	"./editorWorker.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorker.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_editorWorker_js"
	],
	"./editorWorkerHost": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js"
	],
	"./editorWorkerHost.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js"
	],
	"./findSectionHeaders": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js"
	],
	"./findSectionHeaders.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js"
	],
	"./getIconClasses": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_resources_js-node_modules_monaco-editor-609760",
		"node_modules_monaco-editor_esm_vs_editor_common_services_getIconClasses_js"
	],
	"./getIconClasses.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_resources_js-node_modules_monaco-editor-609760",
		"node_modules_monaco-editor_esm_vs_editor_common_services_getIconClasses_js"
	],
	"./languageFeatureDebounce": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce.js",
		"vendors-node_modules_monaco-editor_esm_vs_platform_log_common_log_js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_languageFeatureDebounce_js"
	],
	"./languageFeatureDebounce.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce.js",
		"vendors-node_modules_monaco-editor_esm_vs_platform_log_common_log_js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_languageFeatureDebounce_js"
	],
	"./languageFeatures": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatures.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_languageFeatures_js"
	],
	"./languageFeatures.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatures.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_languageFeatures_js"
	],
	"./languageFeaturesService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeaturesService.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_glob_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languageFeaturesService_js",
		"node_modules_monaco-editor_esm_vs_base_common_extpath_js-node_modules_monaco-editor_esm_vs_pl-d17c0b"
	],
	"./languageFeaturesService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeaturesService.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_glob_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languageFeaturesService_js",
		"node_modules_monaco-editor_esm_vs_base_common_extpath_js-node_modules_monaco-editor_esm_vs_pl-d17c0b"
	],
	"./languageService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_resources_js-node_modules_monaco-editor-609760",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_glob_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languagesRegistry_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languageService_js"
	],
	"./languageService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_resources_js-node_modules_monaco-editor-609760",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_glob_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languagesRegistry_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languageService_js"
	],
	"./languagesAssociations": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languagesAssociations.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_resources_js-node_modules_monaco-editor-609760",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_glob_js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_languagesAssociations_js"
	],
	"./languagesAssociations.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languagesAssociations.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_resources_js-node_modules_monaco-editor-609760",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_glob_js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_languagesAssociations_js"
	],
	"./languagesRegistry": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_resources_js-node_modules_monaco-editor-609760",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_glob_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languagesRegistry_js"
	],
	"./languagesRegistry.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_resources_js-node_modules_monaco-editor-609760",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_glob_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_languagesRegistry_js"
	],
	"./markerDecorations": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorations.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_markerDecorations_js"
	],
	"./markerDecorations.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorations.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_markerDecorations_js"
	],
	"./markerDecorationsService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorationsService.js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_core_editorColorRegistry_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_markerDecorationsService_js",
		"node_modules_monaco-editor_esm_vs_platform_instantiation_common_instantiation_js-node_modules-640595"
	],
	"./markerDecorationsService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorationsService.js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_core_editorColorRegistry_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_markerDecorationsService_js",
		"node_modules_monaco-editor_esm_vs_platform_instantiation_common_instantiation_js-node_modules-640595"
	],
	"./model": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/model.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_model_js"
	],
	"./model.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/model.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_model_js"
	],
	"./modelService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_resources_js-node_modules_monaco-editor-609760",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_core_editorColorRegistry_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_modelService_js",
		"node_modules_monaco-editor_esm_vs_editor_common_core_eolCounter_js-node_modules_monaco-editor-43a80e"
	],
	"./modelService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js",
		"vendors-node_modules_monaco-editor_esm_vs_base_common_resources_js-node_modules_monaco-editor-609760",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_core_editorColorRegistry_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_modelService_js",
		"node_modules_monaco-editor_esm_vs_editor_common_core_eolCounter_js-node_modules_monaco-editor-43a80e"
	],
	"./resolverService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_resolverService_js"
	],
	"./resolverService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_resolverService_js"
	],
	"./semanticTokensDto": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensDto_js"
	],
	"./semanticTokensDto.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensDto_js"
	],
	"./semanticTokensProviderStyling": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js",
		"vendors-node_modules_monaco-editor_esm_vs_platform_log_common_log_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensProviderStyling_js",
		"node_modules_monaco-editor_esm_vs_platform_theme_common_themeService_js"
	],
	"./semanticTokensProviderStyling.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js",
		"vendors-node_modules_monaco-editor_esm_vs_platform_log_common_log_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensProviderStyling_js",
		"node_modules_monaco-editor_esm_vs_platform_theme_common_themeService_js"
	],
	"./semanticTokensStyling": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStyling.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensStyling_js"
	],
	"./semanticTokensStyling.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStyling.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensStyling_js"
	],
	"./semanticTokensStylingService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStylingService.js",
		"vendors-node_modules_monaco-editor_esm_vs_platform_log_common_log_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensProviderStyling_js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensStylingService_js"
	],
	"./semanticTokensStylingService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStylingService.js",
		"vendors-node_modules_monaco-editor_esm_vs_platform_log_common_log_js",
		"vendors-node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensProviderStyling_js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_semanticTokensStylingService_js"
	],
	"./textModelSync/textModelSync.impl": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl.js"
	],
	"./textModelSync/textModelSync.impl.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl.js"
	],
	"./textModelSync/textModelSync.protocol": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.protocol.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_textModelSync_textModelSync_protocol_js"
	],
	"./textModelSync/textModelSync.protocol.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.protocol.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_textModelSync_textModelSync_protocol_js"
	],
	"./textResourceConfiguration": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_textResourceConfiguration_js"
	],
	"./textResourceConfiguration.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_textResourceConfiguration_js"
	],
	"./treeSitterParserService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_treeSitterParserService_js"
	],
	"./treeSitterParserService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_treeSitterParserService_js"
	],
	"./treeViewsDnd": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDnd.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_treeViewsDnd_js"
	],
	"./treeViewsDnd.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDnd.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_treeViewsDnd_js"
	],
	"./treeViewsDndService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDndService.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_treeViewsDndService_js"
	],
	"./treeViewsDndService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDndService.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_treeViewsDndService_js"
	],
	"./unicodeTextModelHighlighter": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js"
	],
	"./unicodeTextModelHighlighter.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./node_modules/monaco-editor/esm/vs/editor/common/services lazy recursive ^.*$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccessibilitySupport: () => (/* binding */ AccessibilitySupport),
/* harmony export */   CodeActionTriggerType: () => (/* binding */ CodeActionTriggerType),
/* harmony export */   CompletionItemInsertTextRule: () => (/* binding */ CompletionItemInsertTextRule),
/* harmony export */   CompletionItemKind: () => (/* binding */ CompletionItemKind),
/* harmony export */   CompletionItemTag: () => (/* binding */ CompletionItemTag),
/* harmony export */   CompletionTriggerKind: () => (/* binding */ CompletionTriggerKind),
/* harmony export */   ContentWidgetPositionPreference: () => (/* binding */ ContentWidgetPositionPreference),
/* harmony export */   CursorChangeReason: () => (/* binding */ CursorChangeReason),
/* harmony export */   DefaultEndOfLine: () => (/* binding */ DefaultEndOfLine),
/* harmony export */   DocumentHighlightKind: () => (/* binding */ DocumentHighlightKind),
/* harmony export */   EditorAutoIndentStrategy: () => (/* binding */ EditorAutoIndentStrategy),
/* harmony export */   EditorOption: () => (/* binding */ EditorOption),
/* harmony export */   EndOfLinePreference: () => (/* binding */ EndOfLinePreference),
/* harmony export */   EndOfLineSequence: () => (/* binding */ EndOfLineSequence),
/* harmony export */   GlyphMarginLane: () => (/* binding */ GlyphMarginLane),
/* harmony export */   HoverVerbosityAction: () => (/* binding */ HoverVerbosityAction),
/* harmony export */   IndentAction: () => (/* binding */ IndentAction),
/* harmony export */   InjectedTextCursorStops: () => (/* binding */ InjectedTextCursorStops),
/* harmony export */   InlayHintKind: () => (/* binding */ InlayHintKind),
/* harmony export */   InlineCompletionTriggerKind: () => (/* binding */ InlineCompletionTriggerKind),
/* harmony export */   InlineEditTriggerKind: () => (/* binding */ InlineEditTriggerKind),
/* harmony export */   KeyCode: () => (/* binding */ KeyCode),
/* harmony export */   MarkerSeverity: () => (/* binding */ MarkerSeverity),
/* harmony export */   MarkerTag: () => (/* binding */ MarkerTag),
/* harmony export */   MinimapPosition: () => (/* binding */ MinimapPosition),
/* harmony export */   MinimapSectionHeaderStyle: () => (/* binding */ MinimapSectionHeaderStyle),
/* harmony export */   MouseTargetType: () => (/* binding */ MouseTargetType),
/* harmony export */   NewSymbolNameTag: () => (/* binding */ NewSymbolNameTag),
/* harmony export */   NewSymbolNameTriggerKind: () => (/* binding */ NewSymbolNameTriggerKind),
/* harmony export */   OverlayWidgetPositionPreference: () => (/* binding */ OverlayWidgetPositionPreference),
/* harmony export */   OverviewRulerLane: () => (/* binding */ OverviewRulerLane),
/* harmony export */   PartialAcceptTriggerKind: () => (/* binding */ PartialAcceptTriggerKind),
/* harmony export */   PositionAffinity: () => (/* binding */ PositionAffinity),
/* harmony export */   RenderLineNumbersType: () => (/* binding */ RenderLineNumbersType),
/* harmony export */   RenderMinimap: () => (/* binding */ RenderMinimap),
/* harmony export */   ScrollType: () => (/* binding */ ScrollType),
/* harmony export */   ScrollbarVisibility: () => (/* binding */ ScrollbarVisibility),
/* harmony export */   SelectionDirection: () => (/* binding */ SelectionDirection),
/* harmony export */   ShowLightbulbIconMode: () => (/* binding */ ShowLightbulbIconMode),
/* harmony export */   SignatureHelpTriggerKind: () => (/* binding */ SignatureHelpTriggerKind),
/* harmony export */   SymbolKind: () => (/* binding */ SymbolKind),
/* harmony export */   SymbolTag: () => (/* binding */ SymbolTag),
/* harmony export */   TextEditorCursorBlinkingStyle: () => (/* binding */ TextEditorCursorBlinkingStyle),
/* harmony export */   TextEditorCursorStyle: () => (/* binding */ TextEditorCursorStyle),
/* harmony export */   TrackedRangeStickiness: () => (/* binding */ TrackedRangeStickiness),
/* harmony export */   WrappingIndent: () => (/* binding */ WrappingIndent)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// THIS IS A GENERATED FILE. DO NOT EDIT DIRECTLY.
var AccessibilitySupport;
(function (AccessibilitySupport) {
    /**
     * This should be the browser case where it is not known if a screen reader is attached or no.
     */
    AccessibilitySupport[AccessibilitySupport["Unknown"] = 0] = "Unknown";
    AccessibilitySupport[AccessibilitySupport["Disabled"] = 1] = "Disabled";
    AccessibilitySupport[AccessibilitySupport["Enabled"] = 2] = "Enabled";
})(AccessibilitySupport || (AccessibilitySupport = {}));
var CodeActionTriggerType;
(function (CodeActionTriggerType) {
    CodeActionTriggerType[CodeActionTriggerType["Invoke"] = 1] = "Invoke";
    CodeActionTriggerType[CodeActionTriggerType["Auto"] = 2] = "Auto";
})(CodeActionTriggerType || (CodeActionTriggerType = {}));
var CompletionItemInsertTextRule;
(function (CompletionItemInsertTextRule) {
    CompletionItemInsertTextRule[CompletionItemInsertTextRule["None"] = 0] = "None";
    /**
     * Adjust whitespace/indentation of multiline insert texts to
     * match the current line indentation.
     */
    CompletionItemInsertTextRule[CompletionItemInsertTextRule["KeepWhitespace"] = 1] = "KeepWhitespace";
    /**
     * `insertText` is a snippet.
     */
    CompletionItemInsertTextRule[CompletionItemInsertTextRule["InsertAsSnippet"] = 4] = "InsertAsSnippet";
})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Method"] = 0] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 1] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 2] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 3] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 4] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 5] = "Class";
    CompletionItemKind[CompletionItemKind["Struct"] = 6] = "Struct";
    CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
    CompletionItemKind[CompletionItemKind["Event"] = 10] = "Event";
    CompletionItemKind[CompletionItemKind["Operator"] = 11] = "Operator";
    CompletionItemKind[CompletionItemKind["Unit"] = 12] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 13] = "Value";
    CompletionItemKind[CompletionItemKind["Constant"] = 14] = "Constant";
    CompletionItemKind[CompletionItemKind["Enum"] = 15] = "Enum";
    CompletionItemKind[CompletionItemKind["EnumMember"] = 16] = "EnumMember";
    CompletionItemKind[CompletionItemKind["Keyword"] = 17] = "Keyword";
    CompletionItemKind[CompletionItemKind["Text"] = 18] = "Text";
    CompletionItemKind[CompletionItemKind["Color"] = 19] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 20] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 21] = "Reference";
    CompletionItemKind[CompletionItemKind["Customcolor"] = 22] = "Customcolor";
    CompletionItemKind[CompletionItemKind["Folder"] = 23] = "Folder";
    CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind[CompletionItemKind["User"] = 25] = "User";
    CompletionItemKind[CompletionItemKind["Issue"] = 26] = "Issue";
    CompletionItemKind[CompletionItemKind["Snippet"] = 27] = "Snippet";
})(CompletionItemKind || (CompletionItemKind = {}));
var CompletionItemTag;
(function (CompletionItemTag) {
    CompletionItemTag[CompletionItemTag["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * How a suggest provider was triggered.
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
/**
 * A positioning preference for rendering content widgets.
 */
var ContentWidgetPositionPreference;
(function (ContentWidgetPositionPreference) {
    /**
     * Place the content widget exactly at a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["EXACT"] = 0] = "EXACT";
    /**
     * Place the content widget above a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["ABOVE"] = 1] = "ABOVE";
    /**
     * Place the content widget below a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["BELOW"] = 2] = "BELOW";
})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
/**
 * Describes the reason the cursor has changed its position.
 */
var CursorChangeReason;
(function (CursorChangeReason) {
    /**
     * Unknown or not set.
     */
    CursorChangeReason[CursorChangeReason["NotSet"] = 0] = "NotSet";
    /**
     * A `model.setValue()` was called.
     */
    CursorChangeReason[CursorChangeReason["ContentFlush"] = 1] = "ContentFlush";
    /**
     * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
     */
    CursorChangeReason[CursorChangeReason["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
    /**
     * There was an explicit user gesture.
     */
    CursorChangeReason[CursorChangeReason["Explicit"] = 3] = "Explicit";
    /**
     * There was a Paste.
     */
    CursorChangeReason[CursorChangeReason["Paste"] = 4] = "Paste";
    /**
     * There was an Undo.
     */
    CursorChangeReason[CursorChangeReason["Undo"] = 5] = "Undo";
    /**
     * There was a Redo.
     */
    CursorChangeReason[CursorChangeReason["Redo"] = 6] = "Redo";
})(CursorChangeReason || (CursorChangeReason = {}));
/**
 * The default end of line to use when instantiating models.
 */
var DefaultEndOfLine;
(function (DefaultEndOfLine) {
    /**
     * Use line feed (\n) as the end of line character.
     */
    DefaultEndOfLine[DefaultEndOfLine["LF"] = 1] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    DefaultEndOfLine[DefaultEndOfLine["CRLF"] = 2] = "CRLF";
})(DefaultEndOfLine || (DefaultEndOfLine = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * Configuration options for auto indentation in the editor
 */
var EditorAutoIndentStrategy;
(function (EditorAutoIndentStrategy) {
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["None"] = 0] = "None";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Keep"] = 1] = "Keep";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Brackets"] = 2] = "Brackets";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Advanced"] = 3] = "Advanced";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Full"] = 4] = "Full";
})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
var EditorOption;
(function (EditorOption) {
    EditorOption[EditorOption["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
    EditorOption[EditorOption["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
    EditorOption[EditorOption["accessibilitySupport"] = 2] = "accessibilitySupport";
    EditorOption[EditorOption["accessibilityPageSize"] = 3] = "accessibilityPageSize";
    EditorOption[EditorOption["ariaLabel"] = 4] = "ariaLabel";
    EditorOption[EditorOption["ariaRequired"] = 5] = "ariaRequired";
    EditorOption[EditorOption["autoClosingBrackets"] = 6] = "autoClosingBrackets";
    EditorOption[EditorOption["autoClosingComments"] = 7] = "autoClosingComments";
    EditorOption[EditorOption["screenReaderAnnounceInlineSuggestion"] = 8] = "screenReaderAnnounceInlineSuggestion";
    EditorOption[EditorOption["autoClosingDelete"] = 9] = "autoClosingDelete";
    EditorOption[EditorOption["autoClosingOvertype"] = 10] = "autoClosingOvertype";
    EditorOption[EditorOption["autoClosingQuotes"] = 11] = "autoClosingQuotes";
    EditorOption[EditorOption["autoIndent"] = 12] = "autoIndent";
    EditorOption[EditorOption["automaticLayout"] = 13] = "automaticLayout";
    EditorOption[EditorOption["autoSurround"] = 14] = "autoSurround";
    EditorOption[EditorOption["bracketPairColorization"] = 15] = "bracketPairColorization";
    EditorOption[EditorOption["guides"] = 16] = "guides";
    EditorOption[EditorOption["codeLens"] = 17] = "codeLens";
    EditorOption[EditorOption["codeLensFontFamily"] = 18] = "codeLensFontFamily";
    EditorOption[EditorOption["codeLensFontSize"] = 19] = "codeLensFontSize";
    EditorOption[EditorOption["colorDecorators"] = 20] = "colorDecorators";
    EditorOption[EditorOption["colorDecoratorsLimit"] = 21] = "colorDecoratorsLimit";
    EditorOption[EditorOption["columnSelection"] = 22] = "columnSelection";
    EditorOption[EditorOption["comments"] = 23] = "comments";
    EditorOption[EditorOption["contextmenu"] = 24] = "contextmenu";
    EditorOption[EditorOption["copyWithSyntaxHighlighting"] = 25] = "copyWithSyntaxHighlighting";
    EditorOption[EditorOption["cursorBlinking"] = 26] = "cursorBlinking";
    EditorOption[EditorOption["cursorSmoothCaretAnimation"] = 27] = "cursorSmoothCaretAnimation";
    EditorOption[EditorOption["cursorStyle"] = 28] = "cursorStyle";
    EditorOption[EditorOption["cursorSurroundingLines"] = 29] = "cursorSurroundingLines";
    EditorOption[EditorOption["cursorSurroundingLinesStyle"] = 30] = "cursorSurroundingLinesStyle";
    EditorOption[EditorOption["cursorWidth"] = 31] = "cursorWidth";
    EditorOption[EditorOption["disableLayerHinting"] = 32] = "disableLayerHinting";
    EditorOption[EditorOption["disableMonospaceOptimizations"] = 33] = "disableMonospaceOptimizations";
    EditorOption[EditorOption["domReadOnly"] = 34] = "domReadOnly";
    EditorOption[EditorOption["dragAndDrop"] = 35] = "dragAndDrop";
    EditorOption[EditorOption["dropIntoEditor"] = 36] = "dropIntoEditor";
    EditorOption[EditorOption["emptySelectionClipboard"] = 37] = "emptySelectionClipboard";
    EditorOption[EditorOption["experimentalWhitespaceRendering"] = 38] = "experimentalWhitespaceRendering";
    EditorOption[EditorOption["extraEditorClassName"] = 39] = "extraEditorClassName";
    EditorOption[EditorOption["fastScrollSensitivity"] = 40] = "fastScrollSensitivity";
    EditorOption[EditorOption["find"] = 41] = "find";
    EditorOption[EditorOption["fixedOverflowWidgets"] = 42] = "fixedOverflowWidgets";
    EditorOption[EditorOption["folding"] = 43] = "folding";
    EditorOption[EditorOption["foldingStrategy"] = 44] = "foldingStrategy";
    EditorOption[EditorOption["foldingHighlight"] = 45] = "foldingHighlight";
    EditorOption[EditorOption["foldingImportsByDefault"] = 46] = "foldingImportsByDefault";
    EditorOption[EditorOption["foldingMaximumRegions"] = 47] = "foldingMaximumRegions";
    EditorOption[EditorOption["unfoldOnClickAfterEndOfLine"] = 48] = "unfoldOnClickAfterEndOfLine";
    EditorOption[EditorOption["fontFamily"] = 49] = "fontFamily";
    EditorOption[EditorOption["fontInfo"] = 50] = "fontInfo";
    EditorOption[EditorOption["fontLigatures"] = 51] = "fontLigatures";
    EditorOption[EditorOption["fontSize"] = 52] = "fontSize";
    EditorOption[EditorOption["fontWeight"] = 53] = "fontWeight";
    EditorOption[EditorOption["fontVariations"] = 54] = "fontVariations";
    EditorOption[EditorOption["formatOnPaste"] = 55] = "formatOnPaste";
    EditorOption[EditorOption["formatOnType"] = 56] = "formatOnType";
    EditorOption[EditorOption["glyphMargin"] = 57] = "glyphMargin";
    EditorOption[EditorOption["gotoLocation"] = 58] = "gotoLocation";
    EditorOption[EditorOption["hideCursorInOverviewRuler"] = 59] = "hideCursorInOverviewRuler";
    EditorOption[EditorOption["hover"] = 60] = "hover";
    EditorOption[EditorOption["inDiffEditor"] = 61] = "inDiffEditor";
    EditorOption[EditorOption["inlineSuggest"] = 62] = "inlineSuggest";
    EditorOption[EditorOption["inlineEdit"] = 63] = "inlineEdit";
    EditorOption[EditorOption["letterSpacing"] = 64] = "letterSpacing";
    EditorOption[EditorOption["lightbulb"] = 65] = "lightbulb";
    EditorOption[EditorOption["lineDecorationsWidth"] = 66] = "lineDecorationsWidth";
    EditorOption[EditorOption["lineHeight"] = 67] = "lineHeight";
    EditorOption[EditorOption["lineNumbers"] = 68] = "lineNumbers";
    EditorOption[EditorOption["lineNumbersMinChars"] = 69] = "lineNumbersMinChars";
    EditorOption[EditorOption["linkedEditing"] = 70] = "linkedEditing";
    EditorOption[EditorOption["links"] = 71] = "links";
    EditorOption[EditorOption["matchBrackets"] = 72] = "matchBrackets";
    EditorOption[EditorOption["minimap"] = 73] = "minimap";
    EditorOption[EditorOption["mouseStyle"] = 74] = "mouseStyle";
    EditorOption[EditorOption["mouseWheelScrollSensitivity"] = 75] = "mouseWheelScrollSensitivity";
    EditorOption[EditorOption["mouseWheelZoom"] = 76] = "mouseWheelZoom";
    EditorOption[EditorOption["multiCursorMergeOverlapping"] = 77] = "multiCursorMergeOverlapping";
    EditorOption[EditorOption["multiCursorModifier"] = 78] = "multiCursorModifier";
    EditorOption[EditorOption["multiCursorPaste"] = 79] = "multiCursorPaste";
    EditorOption[EditorOption["multiCursorLimit"] = 80] = "multiCursorLimit";
    EditorOption[EditorOption["occurrencesHighlight"] = 81] = "occurrencesHighlight";
    EditorOption[EditorOption["overviewRulerBorder"] = 82] = "overviewRulerBorder";
    EditorOption[EditorOption["overviewRulerLanes"] = 83] = "overviewRulerLanes";
    EditorOption[EditorOption["padding"] = 84] = "padding";
    EditorOption[EditorOption["pasteAs"] = 85] = "pasteAs";
    EditorOption[EditorOption["parameterHints"] = 86] = "parameterHints";
    EditorOption[EditorOption["peekWidgetDefaultFocus"] = 87] = "peekWidgetDefaultFocus";
    EditorOption[EditorOption["placeholder"] = 88] = "placeholder";
    EditorOption[EditorOption["definitionLinkOpensInPeek"] = 89] = "definitionLinkOpensInPeek";
    EditorOption[EditorOption["quickSuggestions"] = 90] = "quickSuggestions";
    EditorOption[EditorOption["quickSuggestionsDelay"] = 91] = "quickSuggestionsDelay";
    EditorOption[EditorOption["readOnly"] = 92] = "readOnly";
    EditorOption[EditorOption["readOnlyMessage"] = 93] = "readOnlyMessage";
    EditorOption[EditorOption["renameOnType"] = 94] = "renameOnType";
    EditorOption[EditorOption["renderControlCharacters"] = 95] = "renderControlCharacters";
    EditorOption[EditorOption["renderFinalNewline"] = 96] = "renderFinalNewline";
    EditorOption[EditorOption["renderLineHighlight"] = 97] = "renderLineHighlight";
    EditorOption[EditorOption["renderLineHighlightOnlyWhenFocus"] = 98] = "renderLineHighlightOnlyWhenFocus";
    EditorOption[EditorOption["renderValidationDecorations"] = 99] = "renderValidationDecorations";
    EditorOption[EditorOption["renderWhitespace"] = 100] = "renderWhitespace";
    EditorOption[EditorOption["revealHorizontalRightPadding"] = 101] = "revealHorizontalRightPadding";
    EditorOption[EditorOption["roundedSelection"] = 102] = "roundedSelection";
    EditorOption[EditorOption["rulers"] = 103] = "rulers";
    EditorOption[EditorOption["scrollbar"] = 104] = "scrollbar";
    EditorOption[EditorOption["scrollBeyondLastColumn"] = 105] = "scrollBeyondLastColumn";
    EditorOption[EditorOption["scrollBeyondLastLine"] = 106] = "scrollBeyondLastLine";
    EditorOption[EditorOption["scrollPredominantAxis"] = 107] = "scrollPredominantAxis";
    EditorOption[EditorOption["selectionClipboard"] = 108] = "selectionClipboard";
    EditorOption[EditorOption["selectionHighlight"] = 109] = "selectionHighlight";
    EditorOption[EditorOption["selectOnLineNumbers"] = 110] = "selectOnLineNumbers";
    EditorOption[EditorOption["showFoldingControls"] = 111] = "showFoldingControls";
    EditorOption[EditorOption["showUnused"] = 112] = "showUnused";
    EditorOption[EditorOption["snippetSuggestions"] = 113] = "snippetSuggestions";
    EditorOption[EditorOption["smartSelect"] = 114] = "smartSelect";
    EditorOption[EditorOption["smoothScrolling"] = 115] = "smoothScrolling";
    EditorOption[EditorOption["stickyScroll"] = 116] = "stickyScroll";
    EditorOption[EditorOption["stickyTabStops"] = 117] = "stickyTabStops";
    EditorOption[EditorOption["stopRenderingLineAfter"] = 118] = "stopRenderingLineAfter";
    EditorOption[EditorOption["suggest"] = 119] = "suggest";
    EditorOption[EditorOption["suggestFontSize"] = 120] = "suggestFontSize";
    EditorOption[EditorOption["suggestLineHeight"] = 121] = "suggestLineHeight";
    EditorOption[EditorOption["suggestOnTriggerCharacters"] = 122] = "suggestOnTriggerCharacters";
    EditorOption[EditorOption["suggestSelection"] = 123] = "suggestSelection";
    EditorOption[EditorOption["tabCompletion"] = 124] = "tabCompletion";
    EditorOption[EditorOption["tabIndex"] = 125] = "tabIndex";
    EditorOption[EditorOption["unicodeHighlighting"] = 126] = "unicodeHighlighting";
    EditorOption[EditorOption["unusualLineTerminators"] = 127] = "unusualLineTerminators";
    EditorOption[EditorOption["useShadowDOM"] = 128] = "useShadowDOM";
    EditorOption[EditorOption["useTabStops"] = 129] = "useTabStops";
    EditorOption[EditorOption["wordBreak"] = 130] = "wordBreak";
    EditorOption[EditorOption["wordSegmenterLocales"] = 131] = "wordSegmenterLocales";
    EditorOption[EditorOption["wordSeparators"] = 132] = "wordSeparators";
    EditorOption[EditorOption["wordWrap"] = 133] = "wordWrap";
    EditorOption[EditorOption["wordWrapBreakAfterCharacters"] = 134] = "wordWrapBreakAfterCharacters";
    EditorOption[EditorOption["wordWrapBreakBeforeCharacters"] = 135] = "wordWrapBreakBeforeCharacters";
    EditorOption[EditorOption["wordWrapColumn"] = 136] = "wordWrapColumn";
    EditorOption[EditorOption["wordWrapOverride1"] = 137] = "wordWrapOverride1";
    EditorOption[EditorOption["wordWrapOverride2"] = 138] = "wordWrapOverride2";
    EditorOption[EditorOption["wrappingIndent"] = 139] = "wrappingIndent";
    EditorOption[EditorOption["wrappingStrategy"] = 140] = "wrappingStrategy";
    EditorOption[EditorOption["showDeprecated"] = 141] = "showDeprecated";
    EditorOption[EditorOption["inlayHints"] = 142] = "inlayHints";
    EditorOption[EditorOption["editorClassName"] = 143] = "editorClassName";
    EditorOption[EditorOption["pixelRatio"] = 144] = "pixelRatio";
    EditorOption[EditorOption["tabFocusMode"] = 145] = "tabFocusMode";
    EditorOption[EditorOption["layoutInfo"] = 146] = "layoutInfo";
    EditorOption[EditorOption["wrappingInfo"] = 147] = "wrappingInfo";
    EditorOption[EditorOption["defaultColorDecorators"] = 148] = "defaultColorDecorators";
    EditorOption[EditorOption["colorDecoratorsActivatedOn"] = 149] = "colorDecoratorsActivatedOn";
    EditorOption[EditorOption["inlineCompletionsAccessibilityVerbose"] = 150] = "inlineCompletionsAccessibilityVerbose";
})(EditorOption || (EditorOption = {}));
/**
 * End of line character preference.
 */
var EndOfLinePreference;
(function (EndOfLinePreference) {
    /**
     * Use the end of line character identified in the text buffer.
     */
    EndOfLinePreference[EndOfLinePreference["TextDefined"] = 0] = "TextDefined";
    /**
     * Use line feed (\n) as the end of line character.
     */
    EndOfLinePreference[EndOfLinePreference["LF"] = 1] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    EndOfLinePreference[EndOfLinePreference["CRLF"] = 2] = "CRLF";
})(EndOfLinePreference || (EndOfLinePreference = {}));
/**
 * End of line character preference.
 */
var EndOfLineSequence;
(function (EndOfLineSequence) {
    /**
     * Use line feed (\n) as the end of line character.
     */
    EndOfLineSequence[EndOfLineSequence["LF"] = 0] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    EndOfLineSequence[EndOfLineSequence["CRLF"] = 1] = "CRLF";
})(EndOfLineSequence || (EndOfLineSequence = {}));
/**
 * Vertical Lane in the glyph margin of the editor.
 */
var GlyphMarginLane;
(function (GlyphMarginLane) {
    GlyphMarginLane[GlyphMarginLane["Left"] = 1] = "Left";
    GlyphMarginLane[GlyphMarginLane["Center"] = 2] = "Center";
    GlyphMarginLane[GlyphMarginLane["Right"] = 3] = "Right";
})(GlyphMarginLane || (GlyphMarginLane = {}));
var HoverVerbosityAction;
(function (HoverVerbosityAction) {
    /**
     * Increase the verbosity of the hover
     */
    HoverVerbosityAction[HoverVerbosityAction["Increase"] = 0] = "Increase";
    /**
     * Decrease the verbosity of the hover
     */
    HoverVerbosityAction[HoverVerbosityAction["Decrease"] = 1] = "Decrease";
})(HoverVerbosityAction || (HoverVerbosityAction = {}));
/**
 * Describes what to do with the indentation when pressing Enter.
 */
var IndentAction;
(function (IndentAction) {
    /**
     * Insert new line and copy the previous line's indentation.
     */
    IndentAction[IndentAction["None"] = 0] = "None";
    /**
     * Insert new line and indent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Indent"] = 1] = "Indent";
    /**
     * Insert two new lines:
     *  - the first one indented which will hold the cursor
     *  - the second one at the same indentation level
     */
    IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
    /**
     * Insert new line and outdent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
var InjectedTextCursorStops;
(function (InjectedTextCursorStops) {
    InjectedTextCursorStops[InjectedTextCursorStops["Both"] = 0] = "Both";
    InjectedTextCursorStops[InjectedTextCursorStops["Right"] = 1] = "Right";
    InjectedTextCursorStops[InjectedTextCursorStops["Left"] = 2] = "Left";
    InjectedTextCursorStops[InjectedTextCursorStops["None"] = 3] = "None";
})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
var InlayHintKind;
(function (InlayHintKind) {
    InlayHintKind[InlayHintKind["Type"] = 1] = "Type";
    InlayHintKind[InlayHintKind["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (InlayHintKind = {}));
/**
 * How an {@link InlineCompletionsProvider inline completion provider} was triggered.
 */
var InlineCompletionTriggerKind;
(function (InlineCompletionTriggerKind) {
    /**
     * Completion was triggered automatically while editing.
     * It is sufficient to return a single completion item in this case.
     */
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Automatic"] = 0] = "Automatic";
    /**
     * Completion was triggered explicitly by a user gesture.
     * Return multiple completion items to enable cycling through them.
     */
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
var InlineEditTriggerKind;
(function (InlineEditTriggerKind) {
    InlineEditTriggerKind[InlineEditTriggerKind["Invoke"] = 0] = "Invoke";
    InlineEditTriggerKind[InlineEditTriggerKind["Automatic"] = 1] = "Automatic";
})(InlineEditTriggerKind || (InlineEditTriggerKind = {}));
/**
 * Virtual Key Codes, the value does not hold any inherent meaning.
 * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
 * But these are "more general", as they should work across browsers & OS`s.
 */
var KeyCode;
(function (KeyCode) {
    KeyCode[KeyCode["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
    /**
     * Placed first to cover the 0 value of the enum.
     */
    KeyCode[KeyCode["Unknown"] = 0] = "Unknown";
    KeyCode[KeyCode["Backspace"] = 1] = "Backspace";
    KeyCode[KeyCode["Tab"] = 2] = "Tab";
    KeyCode[KeyCode["Enter"] = 3] = "Enter";
    KeyCode[KeyCode["Shift"] = 4] = "Shift";
    KeyCode[KeyCode["Ctrl"] = 5] = "Ctrl";
    KeyCode[KeyCode["Alt"] = 6] = "Alt";
    KeyCode[KeyCode["PauseBreak"] = 7] = "PauseBreak";
    KeyCode[KeyCode["CapsLock"] = 8] = "CapsLock";
    KeyCode[KeyCode["Escape"] = 9] = "Escape";
    KeyCode[KeyCode["Space"] = 10] = "Space";
    KeyCode[KeyCode["PageUp"] = 11] = "PageUp";
    KeyCode[KeyCode["PageDown"] = 12] = "PageDown";
    KeyCode[KeyCode["End"] = 13] = "End";
    KeyCode[KeyCode["Home"] = 14] = "Home";
    KeyCode[KeyCode["LeftArrow"] = 15] = "LeftArrow";
    KeyCode[KeyCode["UpArrow"] = 16] = "UpArrow";
    KeyCode[KeyCode["RightArrow"] = 17] = "RightArrow";
    KeyCode[KeyCode["DownArrow"] = 18] = "DownArrow";
    KeyCode[KeyCode["Insert"] = 19] = "Insert";
    KeyCode[KeyCode["Delete"] = 20] = "Delete";
    KeyCode[KeyCode["Digit0"] = 21] = "Digit0";
    KeyCode[KeyCode["Digit1"] = 22] = "Digit1";
    KeyCode[KeyCode["Digit2"] = 23] = "Digit2";
    KeyCode[KeyCode["Digit3"] = 24] = "Digit3";
    KeyCode[KeyCode["Digit4"] = 25] = "Digit4";
    KeyCode[KeyCode["Digit5"] = 26] = "Digit5";
    KeyCode[KeyCode["Digit6"] = 27] = "Digit6";
    KeyCode[KeyCode["Digit7"] = 28] = "Digit7";
    KeyCode[KeyCode["Digit8"] = 29] = "Digit8";
    KeyCode[KeyCode["Digit9"] = 30] = "Digit9";
    KeyCode[KeyCode["KeyA"] = 31] = "KeyA";
    KeyCode[KeyCode["KeyB"] = 32] = "KeyB";
    KeyCode[KeyCode["KeyC"] = 33] = "KeyC";
    KeyCode[KeyCode["KeyD"] = 34] = "KeyD";
    KeyCode[KeyCode["KeyE"] = 35] = "KeyE";
    KeyCode[KeyCode["KeyF"] = 36] = "KeyF";
    KeyCode[KeyCode["KeyG"] = 37] = "KeyG";
    KeyCode[KeyCode["KeyH"] = 38] = "KeyH";
    KeyCode[KeyCode["KeyI"] = 39] = "KeyI";
    KeyCode[KeyCode["KeyJ"] = 40] = "KeyJ";
    KeyCode[KeyCode["KeyK"] = 41] = "KeyK";
    KeyCode[KeyCode["KeyL"] = 42] = "KeyL";
    KeyCode[KeyCode["KeyM"] = 43] = "KeyM";
    KeyCode[KeyCode["KeyN"] = 44] = "KeyN";
    KeyCode[KeyCode["KeyO"] = 45] = "KeyO";
    KeyCode[KeyCode["KeyP"] = 46] = "KeyP";
    KeyCode[KeyCode["KeyQ"] = 47] = "KeyQ";
    KeyCode[KeyCode["KeyR"] = 48] = "KeyR";
    KeyCode[KeyCode["KeyS"] = 49] = "KeyS";
    KeyCode[KeyCode["KeyT"] = 50] = "KeyT";
    KeyCode[KeyCode["KeyU"] = 51] = "KeyU";
    KeyCode[KeyCode["KeyV"] = 52] = "KeyV";
    KeyCode[KeyCode["KeyW"] = 53] = "KeyW";
    KeyCode[KeyCode["KeyX"] = 54] = "KeyX";
    KeyCode[KeyCode["KeyY"] = 55] = "KeyY";
    KeyCode[KeyCode["KeyZ"] = 56] = "KeyZ";
    KeyCode[KeyCode["Meta"] = 57] = "Meta";
    KeyCode[KeyCode["ContextMenu"] = 58] = "ContextMenu";
    KeyCode[KeyCode["F1"] = 59] = "F1";
    KeyCode[KeyCode["F2"] = 60] = "F2";
    KeyCode[KeyCode["F3"] = 61] = "F3";
    KeyCode[KeyCode["F4"] = 62] = "F4";
    KeyCode[KeyCode["F5"] = 63] = "F5";
    KeyCode[KeyCode["F6"] = 64] = "F6";
    KeyCode[KeyCode["F7"] = 65] = "F7";
    KeyCode[KeyCode["F8"] = 66] = "F8";
    KeyCode[KeyCode["F9"] = 67] = "F9";
    KeyCode[KeyCode["F10"] = 68] = "F10";
    KeyCode[KeyCode["F11"] = 69] = "F11";
    KeyCode[KeyCode["F12"] = 70] = "F12";
    KeyCode[KeyCode["F13"] = 71] = "F13";
    KeyCode[KeyCode["F14"] = 72] = "F14";
    KeyCode[KeyCode["F15"] = 73] = "F15";
    KeyCode[KeyCode["F16"] = 74] = "F16";
    KeyCode[KeyCode["F17"] = 75] = "F17";
    KeyCode[KeyCode["F18"] = 76] = "F18";
    KeyCode[KeyCode["F19"] = 77] = "F19";
    KeyCode[KeyCode["F20"] = 78] = "F20";
    KeyCode[KeyCode["F21"] = 79] = "F21";
    KeyCode[KeyCode["F22"] = 80] = "F22";
    KeyCode[KeyCode["F23"] = 81] = "F23";
    KeyCode[KeyCode["F24"] = 82] = "F24";
    KeyCode[KeyCode["NumLock"] = 83] = "NumLock";
    KeyCode[KeyCode["ScrollLock"] = 84] = "ScrollLock";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ';:' key
     */
    KeyCode[KeyCode["Semicolon"] = 85] = "Semicolon";
    /**
     * For any country/region, the '+' key
     * For the US standard keyboard, the '=+' key
     */
    KeyCode[KeyCode["Equal"] = 86] = "Equal";
    /**
     * For any country/region, the ',' key
     * For the US standard keyboard, the ',<' key
     */
    KeyCode[KeyCode["Comma"] = 87] = "Comma";
    /**
     * For any country/region, the '-' key
     * For the US standard keyboard, the '-_' key
     */
    KeyCode[KeyCode["Minus"] = 88] = "Minus";
    /**
     * For any country/region, the '.' key
     * For the US standard keyboard, the '.>' key
     */
    KeyCode[KeyCode["Period"] = 89] = "Period";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '/?' key
     */
    KeyCode[KeyCode["Slash"] = 90] = "Slash";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '`~' key
     */
    KeyCode[KeyCode["Backquote"] = 91] = "Backquote";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '[{' key
     */
    KeyCode[KeyCode["BracketLeft"] = 92] = "BracketLeft";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '\|' key
     */
    KeyCode[KeyCode["Backslash"] = 93] = "Backslash";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ']}' key
     */
    KeyCode[KeyCode["BracketRight"] = 94] = "BracketRight";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ''"' key
     */
    KeyCode[KeyCode["Quote"] = 95] = "Quote";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     */
    KeyCode[KeyCode["OEM_8"] = 96] = "OEM_8";
    /**
     * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
     */
    KeyCode[KeyCode["IntlBackslash"] = 97] = "IntlBackslash";
    KeyCode[KeyCode["Numpad0"] = 98] = "Numpad0";
    KeyCode[KeyCode["Numpad1"] = 99] = "Numpad1";
    KeyCode[KeyCode["Numpad2"] = 100] = "Numpad2";
    KeyCode[KeyCode["Numpad3"] = 101] = "Numpad3";
    KeyCode[KeyCode["Numpad4"] = 102] = "Numpad4";
    KeyCode[KeyCode["Numpad5"] = 103] = "Numpad5";
    KeyCode[KeyCode["Numpad6"] = 104] = "Numpad6";
    KeyCode[KeyCode["Numpad7"] = 105] = "Numpad7";
    KeyCode[KeyCode["Numpad8"] = 106] = "Numpad8";
    KeyCode[KeyCode["Numpad9"] = 107] = "Numpad9";
    KeyCode[KeyCode["NumpadMultiply"] = 108] = "NumpadMultiply";
    KeyCode[KeyCode["NumpadAdd"] = 109] = "NumpadAdd";
    KeyCode[KeyCode["NUMPAD_SEPARATOR"] = 110] = "NUMPAD_SEPARATOR";
    KeyCode[KeyCode["NumpadSubtract"] = 111] = "NumpadSubtract";
    KeyCode[KeyCode["NumpadDecimal"] = 112] = "NumpadDecimal";
    KeyCode[KeyCode["NumpadDivide"] = 113] = "NumpadDivide";
    /**
     * Cover all key codes when IME is processing input.
     */
    KeyCode[KeyCode["KEY_IN_COMPOSITION"] = 114] = "KEY_IN_COMPOSITION";
    KeyCode[KeyCode["ABNT_C1"] = 115] = "ABNT_C1";
    KeyCode[KeyCode["ABNT_C2"] = 116] = "ABNT_C2";
    KeyCode[KeyCode["AudioVolumeMute"] = 117] = "AudioVolumeMute";
    KeyCode[KeyCode["AudioVolumeUp"] = 118] = "AudioVolumeUp";
    KeyCode[KeyCode["AudioVolumeDown"] = 119] = "AudioVolumeDown";
    KeyCode[KeyCode["BrowserSearch"] = 120] = "BrowserSearch";
    KeyCode[KeyCode["BrowserHome"] = 121] = "BrowserHome";
    KeyCode[KeyCode["BrowserBack"] = 122] = "BrowserBack";
    KeyCode[KeyCode["BrowserForward"] = 123] = "BrowserForward";
    KeyCode[KeyCode["MediaTrackNext"] = 124] = "MediaTrackNext";
    KeyCode[KeyCode["MediaTrackPrevious"] = 125] = "MediaTrackPrevious";
    KeyCode[KeyCode["MediaStop"] = 126] = "MediaStop";
    KeyCode[KeyCode["MediaPlayPause"] = 127] = "MediaPlayPause";
    KeyCode[KeyCode["LaunchMediaPlayer"] = 128] = "LaunchMediaPlayer";
    KeyCode[KeyCode["LaunchMail"] = 129] = "LaunchMail";
    KeyCode[KeyCode["LaunchApp2"] = 130] = "LaunchApp2";
    /**
     * VK_CLEAR, 0x0C, CLEAR key
     */
    KeyCode[KeyCode["Clear"] = 131] = "Clear";
    /**
     * Placed last to cover the length of the enum.
     * Please do not depend on this value!
     */
    KeyCode[KeyCode["MAX_VALUE"] = 132] = "MAX_VALUE";
})(KeyCode || (KeyCode = {}));
var MarkerSeverity;
(function (MarkerSeverity) {
    MarkerSeverity[MarkerSeverity["Hint"] = 1] = "Hint";
    MarkerSeverity[MarkerSeverity["Info"] = 2] = "Info";
    MarkerSeverity[MarkerSeverity["Warning"] = 4] = "Warning";
    MarkerSeverity[MarkerSeverity["Error"] = 8] = "Error";
})(MarkerSeverity || (MarkerSeverity = {}));
var MarkerTag;
(function (MarkerTag) {
    MarkerTag[MarkerTag["Unnecessary"] = 1] = "Unnecessary";
    MarkerTag[MarkerTag["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (MarkerTag = {}));
/**
 * Position in the minimap to render the decoration.
 */
var MinimapPosition;
(function (MinimapPosition) {
    MinimapPosition[MinimapPosition["Inline"] = 1] = "Inline";
    MinimapPosition[MinimapPosition["Gutter"] = 2] = "Gutter";
})(MinimapPosition || (MinimapPosition = {}));
/**
 * Section header style.
 */
var MinimapSectionHeaderStyle;
(function (MinimapSectionHeaderStyle) {
    MinimapSectionHeaderStyle[MinimapSectionHeaderStyle["Normal"] = 1] = "Normal";
    MinimapSectionHeaderStyle[MinimapSectionHeaderStyle["Underlined"] = 2] = "Underlined";
})(MinimapSectionHeaderStyle || (MinimapSectionHeaderStyle = {}));
/**
 * Type of hit element with the mouse in the editor.
 */
var MouseTargetType;
(function (MouseTargetType) {
    /**
     * Mouse is on top of an unknown element.
     */
    MouseTargetType[MouseTargetType["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * Mouse is on top of the textarea used for input.
     */
    MouseTargetType[MouseTargetType["TEXTAREA"] = 1] = "TEXTAREA";
    /**
     * Mouse is on top of the glyph margin
     */
    MouseTargetType[MouseTargetType["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
    /**
     * Mouse is on top of the line numbers
     */
    MouseTargetType[MouseTargetType["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
    /**
     * Mouse is on top of the line decorations
     */
    MouseTargetType[MouseTargetType["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
    /**
     * Mouse is on top of the whitespace left in the gutter by a view zone.
     */
    MouseTargetType[MouseTargetType["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
    /**
     * Mouse is on top of text in the content.
     */
    MouseTargetType[MouseTargetType["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
    /**
     * Mouse is on top of empty space in the content (e.g. after line text or below last line)
     */
    MouseTargetType[MouseTargetType["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
    /**
     * Mouse is on top of a view zone in the content.
     */
    MouseTargetType[MouseTargetType["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
    /**
     * Mouse is on top of a content widget.
     */
    MouseTargetType[MouseTargetType["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
    /**
     * Mouse is on top of the decorations overview ruler.
     */
    MouseTargetType[MouseTargetType["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
    /**
     * Mouse is on top of a scrollbar.
     */
    MouseTargetType[MouseTargetType["SCROLLBAR"] = 11] = "SCROLLBAR";
    /**
     * Mouse is on top of an overlay widget.
     */
    MouseTargetType[MouseTargetType["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    /**
     * Mouse is outside of the editor.
     */
    MouseTargetType[MouseTargetType["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
})(MouseTargetType || (MouseTargetType = {}));
var NewSymbolNameTag;
(function (NewSymbolNameTag) {
    NewSymbolNameTag[NewSymbolNameTag["AIGenerated"] = 1] = "AIGenerated";
})(NewSymbolNameTag || (NewSymbolNameTag = {}));
var NewSymbolNameTriggerKind;
(function (NewSymbolNameTriggerKind) {
    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind["Invoke"] = 0] = "Invoke";
    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind["Automatic"] = 1] = "Automatic";
})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));
/**
 * A positioning preference for rendering overlay widgets.
 */
var OverlayWidgetPositionPreference;
(function (OverlayWidgetPositionPreference) {
    /**
     * Position the overlay widget in the top right corner
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
    /**
     * Position the overlay widget in the bottom right corner
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
    /**
     * Position the overlay widget in the top center
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_CENTER"] = 2] = "TOP_CENTER";
})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
/**
 * Vertical Lane in the overview ruler of the editor.
 */
var OverviewRulerLane;
(function (OverviewRulerLane) {
    OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
    OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
    OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
    OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
})(OverviewRulerLane || (OverviewRulerLane = {}));
/**
 * How a partial acceptance was triggered.
 */
var PartialAcceptTriggerKind;
(function (PartialAcceptTriggerKind) {
    PartialAcceptTriggerKind[PartialAcceptTriggerKind["Word"] = 0] = "Word";
    PartialAcceptTriggerKind[PartialAcceptTriggerKind["Line"] = 1] = "Line";
    PartialAcceptTriggerKind[PartialAcceptTriggerKind["Suggest"] = 2] = "Suggest";
})(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {}));
var PositionAffinity;
(function (PositionAffinity) {
    /**
     * Prefers the left most position.
    */
    PositionAffinity[PositionAffinity["Left"] = 0] = "Left";
    /**
     * Prefers the right most position.
    */
    PositionAffinity[PositionAffinity["Right"] = 1] = "Right";
    /**
     * No preference.
    */
    PositionAffinity[PositionAffinity["None"] = 2] = "None";
    /**
     * If the given position is on injected text, prefers the position left of it.
    */
    PositionAffinity[PositionAffinity["LeftOfInjectedText"] = 3] = "LeftOfInjectedText";
    /**
     * If the given position is on injected text, prefers the position right of it.
    */
    PositionAffinity[PositionAffinity["RightOfInjectedText"] = 4] = "RightOfInjectedText";
})(PositionAffinity || (PositionAffinity = {}));
var RenderLineNumbersType;
(function (RenderLineNumbersType) {
    RenderLineNumbersType[RenderLineNumbersType["Off"] = 0] = "Off";
    RenderLineNumbersType[RenderLineNumbersType["On"] = 1] = "On";
    RenderLineNumbersType[RenderLineNumbersType["Relative"] = 2] = "Relative";
    RenderLineNumbersType[RenderLineNumbersType["Interval"] = 3] = "Interval";
    RenderLineNumbersType[RenderLineNumbersType["Custom"] = 4] = "Custom";
})(RenderLineNumbersType || (RenderLineNumbersType = {}));
var RenderMinimap;
(function (RenderMinimap) {
    RenderMinimap[RenderMinimap["None"] = 0] = "None";
    RenderMinimap[RenderMinimap["Text"] = 1] = "Text";
    RenderMinimap[RenderMinimap["Blocks"] = 2] = "Blocks";
})(RenderMinimap || (RenderMinimap = {}));
var ScrollType;
(function (ScrollType) {
    ScrollType[ScrollType["Smooth"] = 0] = "Smooth";
    ScrollType[ScrollType["Immediate"] = 1] = "Immediate";
})(ScrollType || (ScrollType = {}));
var ScrollbarVisibility;
(function (ScrollbarVisibility) {
    ScrollbarVisibility[ScrollbarVisibility["Auto"] = 1] = "Auto";
    ScrollbarVisibility[ScrollbarVisibility["Hidden"] = 2] = "Hidden";
    ScrollbarVisibility[ScrollbarVisibility["Visible"] = 3] = "Visible";
})(ScrollbarVisibility || (ScrollbarVisibility = {}));
/**
 * The direction of a selection.
 */
var SelectionDirection;
(function (SelectionDirection) {
    /**
     * The selection starts above where it ends.
     */
    SelectionDirection[SelectionDirection["LTR"] = 0] = "LTR";
    /**
     * The selection starts below where it ends.
     */
    SelectionDirection[SelectionDirection["RTL"] = 1] = "RTL";
})(SelectionDirection || (SelectionDirection = {}));
var ShowLightbulbIconMode;
(function (ShowLightbulbIconMode) {
    ShowLightbulbIconMode["Off"] = "off";
    ShowLightbulbIconMode["OnCode"] = "onCode";
    ShowLightbulbIconMode["On"] = "on";
})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind[SymbolKind["File"] = 0] = "File";
    SymbolKind[SymbolKind["Module"] = 1] = "Module";
    SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
    SymbolKind[SymbolKind["Package"] = 3] = "Package";
    SymbolKind[SymbolKind["Class"] = 4] = "Class";
    SymbolKind[SymbolKind["Method"] = 5] = "Method";
    SymbolKind[SymbolKind["Property"] = 6] = "Property";
    SymbolKind[SymbolKind["Field"] = 7] = "Field";
    SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
    SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
    SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
    SymbolKind[SymbolKind["Function"] = 11] = "Function";
    SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
    SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
    SymbolKind[SymbolKind["String"] = 14] = "String";
    SymbolKind[SymbolKind["Number"] = 15] = "Number";
    SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
    SymbolKind[SymbolKind["Array"] = 17] = "Array";
    SymbolKind[SymbolKind["Object"] = 18] = "Object";
    SymbolKind[SymbolKind["Key"] = 19] = "Key";
    SymbolKind[SymbolKind["Null"] = 20] = "Null";
    SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
    SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
    SymbolKind[SymbolKind["Event"] = 23] = "Event";
    SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
    SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function (SymbolTag) {
    SymbolTag[SymbolTag["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (SymbolTag = {}));
/**
 * The kind of animation in which the editor's cursor should be rendered.
 */
var TextEditorCursorBlinkingStyle;
(function (TextEditorCursorBlinkingStyle) {
    /**
     * Hidden
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Hidden"] = 0] = "Hidden";
    /**
     * Blinking
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Blink"] = 1] = "Blink";
    /**
     * Blinking with smooth fading
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Smooth"] = 2] = "Smooth";
    /**
     * Blinking with prolonged filled state and smooth fading
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Phase"] = 3] = "Phase";
    /**
     * Expand collapse animation on the y axis
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Expand"] = 4] = "Expand";
    /**
     * No-Blinking
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Solid"] = 5] = "Solid";
})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
/**
 * The style in which the editor's cursor should be rendered.
 */
var TextEditorCursorStyle;
(function (TextEditorCursorStyle) {
    /**
     * As a vertical line (sitting between two characters).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
    /**
     * As a block (sitting on top of a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
    /**
     * As a horizontal line (sitting under a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
    /**
     * As a thin vertical line (sitting between two characters).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["LineThin"] = 4] = "LineThin";
    /**
     * As an outlined block (sitting on top of a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["BlockOutline"] = 5] = "BlockOutline";
    /**
     * As a thin horizontal line (sitting under a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
/**
 * Describes the behavior of decorations when typing/editing near their edges.
 * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
 */
var TrackedRangeStickiness;
(function (TrackedRangeStickiness) {
    TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
/**
 * Describes how to indent wrapped lines.
 */
var WrappingIndent;
(function (WrappingIndent) {
    /**
     * No indentation => wrapped lines begin at column 1.
     */
    WrappingIndent[WrappingIndent["None"] = 0] = "None";
    /**
     * Same => wrapped lines get the same indentation as the parent.
     */
    WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
    /**
     * Indent => wrapped lines get +1 indentation toward the parent.
     */
    WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
    /**
     * DeepIndent => wrapped lines get +2 indentation toward the parent.
     */
    WrappingIndent[WrappingIndent["DeepIndent"] = 3] = "DeepIndent";
})(WrappingIndent || (WrappingIndent = {}));


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TokenizationRegistry: () => (/* binding */ TokenizationRegistry)
/* harmony export */ });
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


class TokenizationRegistry {
    constructor() {
        this._tokenizationSupports = new Map();
        this._factories = new Map();
        this._onDidChange = new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter();
        this.onDidChange = this._onDidChange.event;
        this._colorMap = null;
    }
    handleChange(languageIds) {
        this._onDidChange.fire({
            changedLanguages: languageIds,
            changedColorMap: false
        });
    }
    register(languageId, support) {
        this._tokenizationSupports.set(languageId, support);
        this.handleChange([languageId]);
        return (0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
            if (this._tokenizationSupports.get(languageId) !== support) {
                return;
            }
            this._tokenizationSupports.delete(languageId);
            this.handleChange([languageId]);
        });
    }
    get(languageId) {
        return this._tokenizationSupports.get(languageId) || null;
    }
    registerFactory(languageId, factory) {
        this._factories.get(languageId)?.dispose();
        const myData = new TokenizationSupportFactoryData(this, languageId, factory);
        this._factories.set(languageId, myData);
        return (0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
            const v = this._factories.get(languageId);
            if (!v || v !== myData) {
                return;
            }
            this._factories.delete(languageId);
            v.dispose();
        });
    }
    async getOrCreate(languageId) {
        // check first if the support is already set
        const tokenizationSupport = this.get(languageId);
        if (tokenizationSupport) {
            return tokenizationSupport;
        }
        const factory = this._factories.get(languageId);
        if (!factory || factory.isResolved) {
            // no factory or factory.resolve already finished
            return null;
        }
        await factory.resolve();
        return this.get(languageId);
    }
    isResolved(languageId) {
        const tokenizationSupport = this.get(languageId);
        if (tokenizationSupport) {
            return true;
        }
        const factory = this._factories.get(languageId);
        if (!factory || factory.isResolved) {
            return true;
        }
        return false;
    }
    setColorMap(colorMap) {
        this._colorMap = colorMap;
        this._onDidChange.fire({
            changedLanguages: Array.from(this._tokenizationSupports.keys()),
            changedColorMap: true
        });
    }
    getColorMap() {
        return this._colorMap;
    }
    getDefaultBackground() {
        if (this._colorMap && this._colorMap.length > 2 /* ColorId.DefaultBackground */) {
            return this._colorMap[2 /* ColorId.DefaultBackground */];
        }
        return null;
    }
}
class TokenizationSupportFactoryData extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    get isResolved() {
        return this._isResolved;
    }
    constructor(_registry, _languageId, _factory) {
        super();
        this._registry = _registry;
        this._languageId = _languageId;
        this._factory = _factory;
        this._isDisposed = false;
        this._resolvePromise = null;
        this._isResolved = false;
    }
    dispose() {
        this._isDisposed = true;
        super.dispose();
    }
    async resolve() {
        if (!this._resolvePromise) {
            this._resolvePromise = this._create();
        }
        return this._resolvePromise;
    }
    async _create() {
        const value = await this._factory.tokenizationSupport;
        this._isResolved = true;
        if (value && !this._isDisposed) {
            this._register(this._registry.register(this._languageId, value));
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/nls.js":
/*!**************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/nls.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNLSLanguage: () => (/* reexport safe */ _nls_messages_js__WEBPACK_IMPORTED_MODULE_0__.getNLSLanguage),
/* harmony export */   getNLSMessages: () => (/* reexport safe */ _nls_messages_js__WEBPACK_IMPORTED_MODULE_0__.getNLSMessages),
/* harmony export */   localize: () => (/* binding */ localize),
/* harmony export */   localize2: () => (/* binding */ localize2)
/* harmony export */ });
/* harmony import */ var _nls_messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nls.messages.js */ "./node_modules/monaco-editor/esm/vs/nls.messages.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// eslint-disable-next-line local/code-import-patterns

// eslint-disable-next-line local/code-import-patterns

const isPseudo = (0,_nls_messages_js__WEBPACK_IMPORTED_MODULE_0__.getNLSLanguage)() === 'pseudo' || (typeof document !== 'undefined' && document.location && document.location.hash.indexOf('pseudo=true') >= 0);
function _format(message, args) {
    let result;
    if (args.length === 0) {
        result = message;
    }
    else {
        result = message.replace(/\{(\d+)\}/g, (match, rest) => {
            const index = rest[0];
            const arg = args[index];
            let result = match;
            if (typeof arg === 'string') {
                result = arg;
            }
            else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {
                result = String(arg);
            }
            return result;
        });
    }
    if (isPseudo) {
        // FF3B and FF3D is the Unicode zenkaku representation for [ and ]
        result = '\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\uFF3D';
    }
    return result;
}
/**
 * @skipMangle
 */
function localize(data /* | number when built */, message /* | null when built */, ...args) {
    if (typeof data === 'number') {
        return _format(lookupMessage(data, message), args);
    }
    return _format(message, args);
}
/**
 * Only used when built: Looks up the message in the global NLS table.
 * This table is being made available as a global through bootstrapping
 * depending on the target context.
 */
function lookupMessage(index, fallback) {
    const message = (0,_nls_messages_js__WEBPACK_IMPORTED_MODULE_0__.getNLSMessages)()?.[index];
    if (typeof message !== 'string') {
        if (typeof fallback === 'string') {
            return fallback;
        }
        throw new Error(`!!! NLS MISSING: ${index} !!!`);
    }
    return message;
}
/**
 * @skipMangle
 */
function localize2(data /* | number when built */, originalMessage, ...args) {
    let message;
    if (typeof data === 'number') {
        message = lookupMessage(data, originalMessage);
    }
    else {
        message = originalMessage;
    }
    const value = _format(message, args);
    return {
        value,
        original: originalMessage === message ? value : _format(originalMessage, args)
    };
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/nls.messages.js":
/*!***********************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/nls.messages.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNLSLanguage: () => (/* binding */ getNLSLanguage),
/* harmony export */   getNLSMessages: () => (/* binding */ getNLSMessages)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/*
 * This module exists so that the AMD build of the monaco editor can replace this with an async loader plugin.
 * If you add new functions to this module make sure that they are also provided in the AMD build of the monaco editor.
 */
function getNLSMessages() {
    return globalThis._VSCODE_NLS_MESSAGES;
}
function getNLSLanguage() {
    return globalThis._VSCODE_NLS_LANGUAGE;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "pylinac-yaml-editor:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "./";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"editor.worker": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkpylinac_yaml_editor"] = self["webpackChunkpylinac_yaml_editor"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/editor.worker.js ***!
  \*******************************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initialize: () => (/* binding */ initialize)
/* harmony export */ });
/* harmony import */ var _base_common_worker_simpleWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/common/worker/simpleWorker.js */ "./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js");
/* harmony import */ var _common_services_editorSimpleWorker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common/services/editorSimpleWorker.js */ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js");
/* harmony import */ var _common_services_editorWorkerHost_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common/services/editorWorkerHost.js */ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



let initialized = false;
function initialize(foreignModule) {
    if (initialized) {
        return;
    }
    initialized = true;
    const simpleWorker = new _base_common_worker_simpleWorker_js__WEBPACK_IMPORTED_MODULE_0__.SimpleWorkerServer((msg) => {
        globalThis.postMessage(msg);
    }, (workerServer) => new _common_services_editorSimpleWorker_js__WEBPACK_IMPORTED_MODULE_1__.EditorSimpleWorker(_common_services_editorWorkerHost_js__WEBPACK_IMPORTED_MODULE_2__.EditorWorkerHost.getChannel(workerServer), foreignModule));
    globalThis.onmessage = (e) => {
        simpleWorker.onmessage(e.data);
    };
}
globalThis.onmessage = (e) => {
    // Ignore first message in this case and initialize if not yet initialized
    if (!initialized) {
        initialize(null);
    }
};

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWRpdG9yLndvcmtlci5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzEwQk87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUM1QztBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQUs7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4Q0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhLElBQUksYUFBYSxJQUFJLGFBQWE7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhLElBQUksYUFBYSxJQUFJLGFBQWEsSUFBSSwyQkFBMkI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYSxJQUFJLGdDQUFnQyxLQUFLLGdDQUFnQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWEsSUFBSSxnQ0FBZ0MsS0FBSyxnQ0FBZ0MsS0FBSyx3QkFBd0I7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCLEVBQUUsNkJBQTZCLEVBQUUsNkJBQTZCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2QixFQUFFLDZCQUE2QixFQUFFLDZCQUE2QixFQUFFLCtDQUErQztBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0NBQXNDO0FBQy9DLEtBQUssNkNBQTZDO0FBQ2xELENBQUMsc0JBQXNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdjdkI7QUFDQTtBQUNBO0FBQ0E7QUFDNkM7QUFDTDtBQUNqQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzREFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RCw0QkFBNEIsb0RBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0Q0FBNEM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQ0FBZ0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQ0FBZ0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JELHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0RBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUVBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQixvQkFBb0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbko3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0IsbUNBQW1DO0FBQ25EO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Ysc0JBQXNCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxTQUFTLG1CQUFtQixZQUFZO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7QUFDSTtBQUM0QjtBQUN2QztBQUNJO0FBQzVCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QWE7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRDQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRDQUFXO0FBQzVCLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDhCQUE4QjtBQUM1RTtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUssR0FBRyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxFQUFFLGtDQUFrQztBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdDNDUDtBQUNBO0FBQ0E7QUFDQTtBQUNv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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ08sbURBQW1EO0FBQzFEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QixpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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VUFBVSxnQkFBZ0IsYUFBYSxFQUFFO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFTO0FBQ3JCLCtCQUErQiwyQ0FBVztBQUMxQztBQUNBO0FBQ0Esc0JBQXNCLDJDQUFXO0FBQ2pDO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbURBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjLEVBQUUsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbURBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvWUE7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDTjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNPLHdCQUF3Qiw0Q0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdKQUFnSjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9EO0FBQzlDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDaEQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvRUFBb0U7QUFDOUQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDMUM7QUFDUDtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBFQUEwRTtBQUMzRTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQ3REO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUNwQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9EO0FBQ3JEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDtBQUNwRDtBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0EsV0FBVyw0REFBNEQ7QUFDdkU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtFQUFrRTtBQUM1RDtBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUNwQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUNsQztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhEQUE4RDtBQUMvRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQ3BDO0FBQ1A7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0REFBNEQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEVBQTBFO0FBQzNFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUN0RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDaEQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ2hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDMUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ2hEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUM3RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQzFCO0FBQ1A7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNFQUFzRTtBQUN2RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Y2VzIjpbIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2FycmF5cy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2FycmF5c0ZpbmQuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9hc3luYy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2NhY2hlLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY2FuY2VsbGF0aW9uLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY29kaWNvbnMuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9jb2RpY29uc0xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9jb2RpY29uc1V0aWwuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9jb2xvci5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2RpZmYvZGlmZi5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2RpZmYvZGlmZkNoYW5nZS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2V2ZW50LmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZnVuY3Rpb25hbC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2hhc2guanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2tleUNvZGVzLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGF6eS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2xpZmVjeWNsZS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2xpbmtlZExpc3QuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9tYXAuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9uZXR3b3JrLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vb2JqZWN0cy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3BhdGguanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9wbGF0Zm9ybS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3Byb2Nlc3MuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9zdG9wd2F0Y2guanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vc3ltYm9scy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3R5cGVzLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vdWludC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3VyaS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3dvcmtlci9zaW1wbGVXb3JrZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi93b3JrZXIvIGxhenkgXi4qJCBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL2NoYXJhY3RlckNsYXNzaWZpZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvbGluZVJhbmdlLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL29mZnNldFJhbmdlLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3Bvc2l0aW9uLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3Bvc2l0aW9uVG9PZmZzZXQuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvc2VsZWN0aW9uLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3RleHRFZGl0LmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3RleHRMZW5ndGguanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvd29yZENoYXJhY3RlckNsYXNzaWZpZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvd29yZEhlbHBlci5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIvYWxnb3JpdGhtcy9kaWZmQWxnb3JpdGhtLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9hbGdvcml0aG1zL2R5bmFtaWNQcm9ncmFtbWluZ0RpZmZpbmcuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyL2FsZ29yaXRobXMvbXllcnNEaWZmQWxnb3JpdGhtLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9jb21wdXRlTW92ZWRMaW5lcy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIvZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9oZXVyaXN0aWNTZXF1ZW5jZU9wdGltaXphdGlvbnMuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyL2xpbmVTZXF1ZW5jZS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIvbGluZXNTbGljZUNoYXJTZXF1ZW5jZS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvbGVnYWN5TGluZXNEaWZmQ29tcHV0ZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvbGluZXNEaWZmQ29tcHV0ZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvbGluZXNEaWZmQ29tcHV0ZXJzLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL3JhbmdlTWFwcGluZy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbGFuZ3VhZ2VzLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMvZGVmYXVsdERvY3VtZW50Q29sb3JzQ29tcHV0ZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2xhbmd1YWdlcy9saW5rQ29tcHV0ZXIuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2xhbmd1YWdlcy9zdXBwb3J0cy9pbnBsYWNlUmVwbGFjZVN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC9taXJyb3JUZXh0TW9kZWwuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL3ByZWZpeFN1bUNvbXB1dGVyLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC90ZXh0TW9kZWxTZWFyY2guanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2VkaXRvckJhc2VBcGkuanMiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2VkaXRvclNpbXBsZVdvcmtlci5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZWRpdG9yV29ya2VySG9zdC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZmluZFNlY3Rpb25IZWFkZXJzLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy90ZXh0TW9kZWxTeW5jL3RleHRNb2RlbFN5bmMuaW1wbC5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdW5pY29kZVRleHRNb2RlbEhpZ2hsaWdodGVyLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy8gbGF6eSBeLiokIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3N0YW5kYWxvbmUvc3RhbmRhbG9uZUVudW1zLmpzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi90b2tlbml6YXRpb25SZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL25scy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL25scy5tZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3Ivd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3Ivd2VicGFjay9ydW50aW1lL2Vuc3VyZSBjaHVuayIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci93ZWJwYWNrL3J1bnRpbWUvbG9hZCBzY3JpcHQiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3B5bGluYWMteWFtbC1lZGl0b3Ivd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vcHlsaW5hYy15YW1sLWVkaXRvci93ZWJwYWNrL3J1bnRpbWUvanNvbnAgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9weWxpbmFjLXlhbWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9lZGl0b3Iud29ya2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LlxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheS5cbiAqIEBwYXJhbSBuIFdoaWNoIGVsZW1lbnQgZnJvbSB0aGUgZW5kIChkZWZhdWx0IGlzIHplcm8pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFpbChhcnJheSwgbiA9IDApIHtcbiAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gKDEgKyBuKV07XG59XG5leHBvcnQgZnVuY3Rpb24gdGFpbDIoYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhaWwgY2FsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gW2Fyci5zbGljZSgwLCBhcnIubGVuZ3RoIC0gMSksIGFyclthcnIubGVuZ3RoIC0gMV1dO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhvbmUsIG90aGVyLCBpdGVtRXF1YWxzID0gKGEsIGIpID0+IGEgPT09IGIpIHtcbiAgICBpZiAob25lID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFvbmUgfHwgIW90aGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9uZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvbmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFpdGVtRXF1YWxzKG9uZVtpXSwgb3RoZXJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFJlbW92ZSB0aGUgZWxlbWVudCBhdCBgaW5kZXhgIGJ5IHJlcGxhY2luZyBpdCB3aXRoIHRoZSBsYXN0IGVsZW1lbnQuIFRoaXMgaXMgZmFzdGVyIHRoYW4gYHNwbGljZWBcbiAqIGJ1dCBjaGFuZ2VzIHRoZSBvcmRlciBvZiB0aGUgYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUZhc3RXaXRob3V0S2VlcGluZ09yZGVyKGFycmF5LCBpbmRleCkge1xuICAgIGNvbnN0IGxhc3QgPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIGlmIChpbmRleCA8IGxhc3QpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJyYXlbbGFzdF07XG4gICAgfVxuICAgIGFycmF5LnBvcCgpO1xufVxuLyoqXG4gKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggYWxnb3JpdGhtIG92ZXIgYSBzb3J0ZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBrZXkgVGhlIHZhbHVlIHdlIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0gY29tcGFyYXRvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdHdvIGFycmF5IGVsZW1lbnRzIGFuZCByZXR1cm5zIHplcm9cbiAqICAgaWYgdGhleSBhcmUgZXF1YWwsIGEgbmVnYXRpdmUgbnVtYmVyIGlmIHRoZSBmaXJzdCBlbGVtZW50IHByZWNlZGVzIHRoZVxuICogICBzZWNvbmQgb25lIGluIHRoZSBzb3J0aW5nIG9yZGVyLCBvciBhIHBvc2l0aXZlIG51bWJlciBpZiB0aGUgc2Vjb25kIGVsZW1lbnRcbiAqICAgcHJlY2VkZXMgdGhlIGZpcnN0IG9uZS5cbiAqIEByZXR1cm4gU2VlIHtAbGluayBiaW5hcnlTZWFyY2gyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGFycmF5LCBrZXksIGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoMihhcnJheS5sZW5ndGgsIGkgPT4gY29tcGFyYXRvcihhcnJheVtpXSwga2V5KSk7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBhbGdvcml0aG0gb3ZlciBhIHNvcnRlZCBjb2xsZWN0aW9uLiBVc2VmdWwgZm9yIGNhc2VzXG4gKiB3aGVuIHdlIG5lZWQgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb3ZlciBzb21ldGhpbmcgdGhhdCBpc24ndCBhY3R1YWxseSBhblxuICogYXJyYXksIGFuZCBjb252ZXJ0aW5nIGRhdGEgdG8gYW4gYXJyYXkgd291bGQgZGVmZWF0IHRoZSB1c2Ugb2YgYmluYXJ5IHNlYXJjaFxuICogaW4gdGhlIGZpcnN0IHBsYWNlLlxuICpcbiAqIEBwYXJhbSBsZW5ndGggVGhlIGNvbGxlY3Rpb24gbGVuZ3RoLlxuICogQHBhcmFtIGNvbXBhcmVUb0tleSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gaW5kZXggb2YgYW4gZWxlbWVudCBpbiB0aGVcbiAqICAgY29sbGVjdGlvbiBhbmQgcmV0dXJucyB6ZXJvIGlmIHRoZSB2YWx1ZSBhdCB0aGlzIGluZGV4IGlzIGVxdWFsIHRvIHRoZVxuICogICBzZWFyY2gga2V5LCBhIG5lZ2F0aXZlIG51bWJlciBpZiB0aGUgdmFsdWUgcHJlY2VkZXMgdGhlIHNlYXJjaCBrZXkgaW4gdGhlXG4gKiAgIHNvcnRpbmcgb3JkZXIsIG9yIGEgcG9zaXRpdmUgbnVtYmVyIGlmIHRoZSBzZWFyY2gga2V5IHByZWNlZGVzIHRoZSB2YWx1ZS5cbiAqIEByZXR1cm4gQSBub24tbmVnYXRpdmUgaW5kZXggb2YgYW4gZWxlbWVudCwgaWYgZm91bmQuIElmIG5vdCBmb3VuZCwgdGhlXG4gKiAgIHJlc3VsdCBpcyAtKG4rMSkgKG9yIH5uLCB1c2luZyBiaXR3aXNlIG5vdGF0aW9uKSwgd2hlcmUgbiBpcyB0aGUgaW5kZXhcbiAqICAgd2hlcmUgdGhlIGtleSBzaG91bGQgYmUgaW5zZXJ0ZWQgdG8gbWFpbnRhaW4gdGhlIHNvcnRpbmcgb3JkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2gyKGxlbmd0aCwgY29tcGFyZVRvS2V5KSB7XG4gICAgbGV0IGxvdyA9IDAsIGhpZ2ggPSBsZW5ndGggLSAxO1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICBjb25zdCBtaWQgPSAoKGxvdyArIGhpZ2gpIC8gMikgfCAwO1xuICAgICAgICBjb25zdCBjb21wID0gY29tcGFyZVRvS2V5KG1pZCk7XG4gICAgICAgIGlmIChjb21wIDwgMCkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wID4gMCkge1xuICAgICAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtKGxvdyArIDEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHF1aWNrU2VsZWN0KG50aCwgZGF0YSwgY29tcGFyZSkge1xuICAgIG50aCA9IG50aCB8IDA7XG4gICAgaWYgKG50aCA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGluZGV4Jyk7XG4gICAgfVxuICAgIGNvbnN0IHBpdm90VmFsdWUgPSBkYXRhW01hdGguZmxvb3IoZGF0YS5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKV07XG4gICAgY29uc3QgbG93ZXIgPSBbXTtcbiAgICBjb25zdCBoaWdoZXIgPSBbXTtcbiAgICBjb25zdCBwaXZvdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRhdGEpIHtcbiAgICAgICAgY29uc3QgdmFsID0gY29tcGFyZSh2YWx1ZSwgcGl2b3RWYWx1ZSk7XG4gICAgICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICBsb3dlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgPiAwKSB7XG4gICAgICAgICAgICBoaWdoZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwaXZvdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG50aCA8IGxvd2VyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcXVpY2tTZWxlY3QobnRoLCBsb3dlciwgY29tcGFyZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG50aCA8IGxvd2VyLmxlbmd0aCArIHBpdm90cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBpdm90c1swXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBxdWlja1NlbGVjdChudGggLSAobG93ZXIubGVuZ3RoICsgcGl2b3RzLmxlbmd0aCksIGhpZ2hlciwgY29tcGFyZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQnkoZGF0YSwgY29tcGFyZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBjdXJyZW50R3JvdXAgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEuc2xpY2UoMCkuc29ydChjb21wYXJlKSkge1xuICAgICAgICBpZiAoIWN1cnJlbnRHcm91cCB8fCBjb21wYXJlKGN1cnJlbnRHcm91cFswXSwgZWxlbWVudCkgIT09IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cCA9IFtlbGVtZW50XTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRHcm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50R3JvdXAucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBTcGxpdHMgdGhlIGdpdmVuIGl0ZW1zIGludG8gYSBsaXN0IG9mIChub24tZW1wdHkpIGdyb3Vwcy5cbiAqIGBzaG91bGRCZUdyb3VwZWRgIGlzIHVzZWQgdG8gZGVjaWRlIGlmIHR3byBjb25zZWN1dGl2ZSBpdGVtcyBzaG91bGQgYmUgaW4gdGhlIHNhbWUgZ3JvdXAuXG4gKiBUaGUgb3JkZXIgb2YgdGhlIGl0ZW1zIGlzIHByZXNlcnZlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBncm91cEFkamFjZW50QnkoaXRlbXMsIHNob3VsZEJlR3JvdXBlZCkge1xuICAgIGxldCBjdXJyZW50R3JvdXA7XG4gICAgbGV0IGxhc3Q7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgIGlmIChsYXN0ICE9PSB1bmRlZmluZWQgJiYgc2hvdWxkQmVHcm91cGVkKGxhc3QsIGl0ZW0pKSB7XG4gICAgICAgICAgICBjdXJyZW50R3JvdXAucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjdXJyZW50R3JvdXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBbaXRlbV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdCA9IGl0ZW07XG4gICAgfVxuICAgIGlmIChjdXJyZW50R3JvdXApIHtcbiAgICAgICAgeWllbGQgY3VycmVudEdyb3VwO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoQWRqYWNlbnQoYXJyLCBmKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGYoaSA9PT0gMCA/IHVuZGVmaW5lZCA6IGFycltpIC0gMV0sIGkgPT09IGFyci5sZW5ndGggPyB1bmRlZmluZWQgOiBhcnJbaV0pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoV2l0aE5laWdoYm9ycyhhcnIsIGYpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmKGkgPT09IDAgPyB1bmRlZmluZWQgOiBhcnJbaSAtIDFdLCBhcnJbaV0sIGkgKyAxID09PSBhcnIubGVuZ3RoID8gdW5kZWZpbmVkIDogYXJyW2kgKyAxXSk7XG4gICAgfVxufVxuLyoqXG4gKiBAcmV0dXJucyBOZXcgYXJyYXkgd2l0aCBhbGwgZmFsc3kgdmFsdWVzIHJlbW92ZWQuIFRoZSBvcmlnaW5hbCBhcnJheSBJUyBOT1QgbW9kaWZpZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2FsZXNjZShhcnJheSkge1xuICAgIHJldHVybiBhcnJheS5maWx0ZXIoKGUpID0+ICEhZSk7XG59XG4vKipcbiAqIFJlbW92ZSBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYGFycmF5YC4gVGhlIG9yaWdpbmFsIGFycmF5IElTIG1vZGlmaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29hbGVzY2VJblBsYWNlKGFycmF5KSB7XG4gICAgbGV0IHRvID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghIWFycmF5W2ldKSB7XG4gICAgICAgICAgICBhcnJheVt0b10gPSBhcnJheVtpXTtcbiAgICAgICAgICAgIHRvICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXJyYXkubGVuZ3RoID0gdG87XG59XG4vKipcbiAqIEByZXR1cm5zIGZhbHNlIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgaXMgYW4gYXJyYXkgYW5kIG5vdCBlbXB0eS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmFsc3lPckVtcHR5KG9iaikge1xuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShvYmopIHx8IG9iai5sZW5ndGggPT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOb25FbXB0eUFycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgJiYgb2JqLmxlbmd0aCA+IDA7XG59XG4vKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlcyBmcm9tIHRoZSBnaXZlbiBhcnJheS4gVGhlIG9wdGlvbmFsIGtleUZuIGFsbG93cyB0byBzcGVjaWZ5XG4gKiBob3cgZWxlbWVudHMgYXJlIGNoZWNrZWQgZm9yIGVxdWFsaXR5IGJ5IHJldHVybmluZyBhbiBhbHRlcm5hdGUgdmFsdWUgZm9yIGVhY2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdChhcnJheSwga2V5Rm4gPSB2YWx1ZSA9PiB2YWx1ZSkge1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIGFycmF5LmZpbHRlcihlbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5Rm4oZWxlbWVudCk7XG4gICAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmlyc3RPckRlZmF1bHQoYXJyYXksIG5vdEZvdW5kVmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkubGVuZ3RoID4gMCA/IGFycmF5WzBdIDogbm90Rm91bmRWYWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5nZShhcmcsIHRvKSB7XG4gICAgbGV0IGZyb20gPSB0eXBlb2YgdG8gPT09ICdudW1iZXInID8gYXJnIDogMDtcbiAgICBpZiAodHlwZW9mIHRvID09PSAnbnVtYmVyJykge1xuICAgICAgICBmcm9tID0gYXJnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgIHRvID0gYXJnO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoZnJvbSA8PSB0bykge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA+IHRvOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEluc2VydCBgaW5zZXJ0QXJyYCBpbnNpZGUgYHRhcmdldGAgYXQgYGluc2VydEluZGV4YC5cbiAqIFBsZWFzZSBkb24ndCB0b3VjaCB1bmxlc3MgeW91IHVuZGVyc3RhbmQgaHR0cHM6Ly9qc3BlcmYuY29tL2luc2VydGluZy1hbi1hcnJheS13aXRoaW4tYW4tYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5SW5zZXJ0KHRhcmdldCwgaW5zZXJ0SW5kZXgsIGluc2VydEFycikge1xuICAgIGNvbnN0IGJlZm9yZSA9IHRhcmdldC5zbGljZSgwLCBpbnNlcnRJbmRleCk7XG4gICAgY29uc3QgYWZ0ZXIgPSB0YXJnZXQuc2xpY2UoaW5zZXJ0SW5kZXgpO1xuICAgIHJldHVybiBiZWZvcmUuY29uY2F0KGluc2VydEFyciwgYWZ0ZXIpO1xufVxuLyoqXG4gKiBQdXNoZXMgYW4gZWxlbWVudCB0byB0aGUgc3RhcnQgb2YgdGhlIGFycmF5LCBpZiBmb3VuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1c2hUb1N0YXJ0KGFyciwgdmFsdWUpIHtcbiAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgYXJyLnVuc2hpZnQodmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogUHVzaGVzIGFuIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXksIGlmIGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRvRW5kKGFyciwgdmFsdWUpIHtcbiAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgYXJyLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBwdXNoTWFueShhcnIsIGl0ZW1zKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhc0FycmF5KHgpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh4KSA/IHggOiBbeF07XG59XG4vKipcbiAqIEluc2VydCB0aGUgbmV3IGl0ZW1zIGluIHRoZSBhcnJheS5cbiAqIEBwYXJhbSBhcnJheSBUaGUgb3JpZ2luYWwgYXJyYXkuXG4gKiBAcGFyYW0gc3RhcnQgVGhlIHplcm8tYmFzZWQgbG9jYXRpb24gaW4gdGhlIGFycmF5IGZyb20gd2hpY2ggdG8gc3RhcnQgaW5zZXJ0aW5nIGVsZW1lbnRzLlxuICogQHBhcmFtIG5ld0l0ZW1zIFRoZSBpdGVtcyB0byBiZSBpbnNlcnRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0SW50byhhcnJheSwgc3RhcnQsIG5ld0l0ZW1zKSB7XG4gICAgY29uc3Qgc3RhcnRJZHggPSBnZXRBY3R1YWxTdGFydEluZGV4KGFycmF5LCBzdGFydCk7XG4gICAgY29uc3Qgb3JpZ2luYWxMZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgY29uc3QgbmV3SXRlbXNMZW5ndGggPSBuZXdJdGVtcy5sZW5ndGg7XG4gICAgYXJyYXkubGVuZ3RoID0gb3JpZ2luYWxMZW5ndGggKyBuZXdJdGVtc0xlbmd0aDtcbiAgICAvLyBNb3ZlIHRoZSBpdGVtcyBhZnRlciB0aGUgc3RhcnQgaW5kZXgsIHN0YXJ0IGZyb20gdGhlIGVuZCBzbyB0aGF0IHdlIGRvbid0IG92ZXJ3cml0ZSBhbnkgdmFsdWUuXG4gICAgZm9yIChsZXQgaSA9IG9yaWdpbmFsTGVuZ3RoIC0gMTsgaSA+PSBzdGFydElkeDsgaS0tKSB7XG4gICAgICAgIGFycmF5W2kgKyBuZXdJdGVtc0xlbmd0aF0gPSBhcnJheVtpXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdJdGVtc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgKyBzdGFydElkeF0gPSBuZXdJdGVtc1tpXTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBhbmQgaW5zZXJ0cyBuZXcgZWxlbWVudHMgaW4gdGhlaXIgcGxhY2UsIHJldHVybmluZyB0aGUgZGVsZXRlZCBlbGVtZW50cy4gQWx0ZXJuYXRpdmUgdG8gdGhlIG5hdGl2ZSBBcnJheS5zcGxpY2UgbWV0aG9kLCBpdFxuICogY2FuIG9ubHkgc3VwcG9ydCBsaW1pdGVkIG51bWJlciBvZiBpdGVtcyBkdWUgdG8gdGhlIG1heGltdW0gY2FsbCBzdGFjayBzaXplIGxpbWl0LlxuICogQHBhcmFtIGFycmF5IFRoZSBvcmlnaW5hbCBhcnJheS5cbiAqIEBwYXJhbSBzdGFydCBUaGUgemVyby1iYXNlZCBsb2NhdGlvbiBpbiB0aGUgYXJyYXkgZnJvbSB3aGljaCB0byBzdGFydCByZW1vdmluZyBlbGVtZW50cy5cbiAqIEBwYXJhbSBkZWxldGVDb3VudCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnRzIHRoYXQgd2VyZSBkZWxldGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaWNlKGFycmF5LCBzdGFydCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKSB7XG4gICAgY29uc3QgaW5kZXggPSBnZXRBY3R1YWxTdGFydEluZGV4KGFycmF5LCBzdGFydCk7XG4gICAgbGV0IHJlc3VsdCA9IGFycmF5LnNwbGljZShpbmRleCwgZGVsZXRlQ291bnQpO1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI2MTE0MFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICB9XG4gICAgaW5zZXJ0SW50byhhcnJheSwgaW5kZXgsIG5ld0l0ZW1zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGFjdHVhbCBzdGFydCBpbmRleCAoc2FtZSBsb2dpYyBhcyB0aGUgbmF0aXZlIHNwbGljZSgpIG9yIHNsaWNlKCkpXG4gKiBJZiBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXksIHN0YXJ0IHdpbGwgYmUgc2V0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LiBJbiB0aGlzIGNhc2UsIG5vIGVsZW1lbnQgd2lsbCBiZSBkZWxldGVkIGJ1dCB0aGUgbWV0aG9kIHdpbGwgYmVoYXZlIGFzIGFuIGFkZGluZyBmdW5jdGlvbiwgYWRkaW5nIGFzIG1hbnkgZWxlbWVudCBhcyBpdGVtW24qXSBwcm92aWRlZC5cbiAqIElmIG5lZ2F0aXZlLCBpdCB3aWxsIGJlZ2luIHRoYXQgbWFueSBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LiAoSW4gdGhpcyBjYXNlLCB0aGUgb3JpZ2luIC0xLCBtZWFuaW5nIC1uIGlzIHRoZSBpbmRleCBvZiB0aGUgbnRoIGxhc3QgZWxlbWVudCwgYW5kIGlzIHRoZXJlZm9yZSBlcXVpdmFsZW50IHRvIHRoZSBpbmRleCBvZiBhcnJheS5sZW5ndGggLSBuLikgSWYgYXJyYXkubGVuZ3RoICsgc3RhcnQgaXMgbGVzcyB0aGFuIDAsIGl0IHdpbGwgYmVnaW4gZnJvbSBpbmRleCAwLlxuICogQHBhcmFtIGFycmF5IFRoZSB0YXJnZXQgYXJyYXkuXG4gKiBAcGFyYW0gc3RhcnQgVGhlIG9wZXJhdGlvbiBpbmRleC5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0dWFsU3RhcnRJbmRleChhcnJheSwgc3RhcnQpIHtcbiAgICByZXR1cm4gc3RhcnQgPCAwID8gTWF0aC5tYXgoc3RhcnQgKyBhcnJheS5sZW5ndGgsIDApIDogTWF0aC5taW4oc3RhcnQsIGFycmF5Lmxlbmd0aCk7XG59XG5leHBvcnQgdmFyIENvbXBhcmVSZXN1bHQ7XG4oZnVuY3Rpb24gKENvbXBhcmVSZXN1bHQpIHtcbiAgICBmdW5jdGlvbiBpc0xlc3NUaGFuKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0IDwgMDtcbiAgICB9XG4gICAgQ29tcGFyZVJlc3VsdC5pc0xlc3NUaGFuID0gaXNMZXNzVGhhbjtcbiAgICBmdW5jdGlvbiBpc0xlc3NUaGFuT3JFcXVhbChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA8PSAwO1xuICAgIH1cbiAgICBDb21wYXJlUmVzdWx0LmlzTGVzc1RoYW5PckVxdWFsID0gaXNMZXNzVGhhbk9yRXF1YWw7XG4gICAgZnVuY3Rpb24gaXNHcmVhdGVyVGhhbihyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA+IDA7XG4gICAgfVxuICAgIENvbXBhcmVSZXN1bHQuaXNHcmVhdGVyVGhhbiA9IGlzR3JlYXRlclRoYW47XG4gICAgZnVuY3Rpb24gaXNOZWl0aGVyTGVzc09yR3JlYXRlclRoYW4ocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IDA7XG4gICAgfVxuICAgIENvbXBhcmVSZXN1bHQuaXNOZWl0aGVyTGVzc09yR3JlYXRlclRoYW4gPSBpc05laXRoZXJMZXNzT3JHcmVhdGVyVGhhbjtcbiAgICBDb21wYXJlUmVzdWx0LmdyZWF0ZXJUaGFuID0gMTtcbiAgICBDb21wYXJlUmVzdWx0Lmxlc3NUaGFuID0gLTE7XG4gICAgQ29tcGFyZVJlc3VsdC5uZWl0aGVyTGVzc09yR3JlYXRlclRoYW4gPSAwO1xufSkoQ29tcGFyZVJlc3VsdCB8fCAoQ29tcGFyZVJlc3VsdCA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUJ5KHNlbGVjdG9yLCBjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIChhLCBiKSA9PiBjb21wYXJhdG9yKHNlbGVjdG9yKGEpLCBzZWxlY3RvcihiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdGllQnJlYWtDb21wYXJhdG9ycyguLi5jb21wYXJhdG9ycykge1xuICAgIHJldHVybiAoaXRlbTEsIGl0ZW0yKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgY29tcGFyYXRvciBvZiBjb21wYXJhdG9ycykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyYXRvcihpdGVtMSwgaXRlbTIpO1xuICAgICAgICAgICAgaWYgKCFDb21wYXJlUmVzdWx0LmlzTmVpdGhlckxlc3NPckdyZWF0ZXJUaGFuKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb21wYXJlUmVzdWx0Lm5laXRoZXJMZXNzT3JHcmVhdGVyVGhhbjtcbiAgICB9O1xufVxuLyoqXG4gKiBUaGUgbmF0dXJhbCBvcmRlciBvbiBudW1iZXJzLlxuKi9cbmV4cG9ydCBjb25zdCBudW1iZXJDb21wYXJhdG9yID0gKGEsIGIpID0+IGEgLSBiO1xuZXhwb3J0IGNvbnN0IGJvb2xlYW5Db21wYXJhdG9yID0gKGEsIGIpID0+IG51bWJlckNvbXBhcmF0b3IoYSA/IDEgOiAwLCBiID8gMSA6IDApO1xuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VPcmRlcihjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIChhLCBiKSA9PiAtY29tcGFyYXRvcihhLCBiKTtcbn1cbmV4cG9ydCBjbGFzcyBBcnJheVF1ZXVlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgcXVldWUgdGhhdCBpcyBiYWNrZWQgYnkgdGhlIGdpdmVuIGFycmF5LiBSdW50aW1lIGlzIE8oMSkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuZmlyc3RJZHggPSAwO1xuICAgICAgICB0aGlzLmxhc3RJZHggPSB0aGlzLml0ZW1zLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RJZHggLSB0aGlzLmZpcnN0SWR4ICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3VtZXMgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBxdWV1ZSBhcyBsb25nIGFzIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxuICAgICAqIElmIG5vIGVsZW1lbnRzIHdlcmUgY29uc3VtZWQsIGBudWxsYCBpcyByZXR1cm5lZC4gSGFzIGEgcnVudGltZSBvZiBPKHJlc3VsdC5sZW5ndGgpLlxuICAgICovXG4gICAgdGFrZVdoaWxlKHByZWRpY2F0ZSkge1xuICAgICAgICAvLyBQKGspIDo9IGsgPD0gdGhpcy5sYXN0SWR4ICYmIHByZWRpY2F0ZSh0aGlzLml0ZW1zW2tdKVxuICAgICAgICAvLyBGaW5kIHMgOj0gbWluIHsgayB8IGsgPj0gdGhpcy5maXJzdElkeCAmJiAhUChrKSB9IGFuZCByZXR1cm4gdGhpcy5kYXRhW3RoaXMuZmlyc3RJZHguLi5zKVxuICAgICAgICBsZXQgc3RhcnRJZHggPSB0aGlzLmZpcnN0SWR4O1xuICAgICAgICB3aGlsZSAoc3RhcnRJZHggPCB0aGlzLml0ZW1zLmxlbmd0aCAmJiBwcmVkaWNhdGUodGhpcy5pdGVtc1tzdGFydElkeF0pKSB7XG4gICAgICAgICAgICBzdGFydElkeCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0YXJ0SWR4ID09PSB0aGlzLmZpcnN0SWR4ID8gbnVsbCA6IHRoaXMuaXRlbXMuc2xpY2UodGhpcy5maXJzdElkeCwgc3RhcnRJZHgpO1xuICAgICAgICB0aGlzLmZpcnN0SWR4ID0gc3RhcnRJZHg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN1bWVzIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgcXVldWUgYXMgbG9uZyBhcyB0aGUgcHJlZGljYXRlIHJldHVybnMgdHJ1ZS5cbiAgICAgKiBJZiBubyBlbGVtZW50cyB3ZXJlIGNvbnN1bWVkLCBgbnVsbGAgaXMgcmV0dXJuZWQuXG4gICAgICogVGhlIHJlc3VsdCBoYXMgdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVuZGVybHlpbmcgYXJyYXkhXG4gICAgKi9cbiAgICB0YWtlRnJvbUVuZFdoaWxlKHByZWRpY2F0ZSkge1xuICAgICAgICAvLyBQKGspIDo9IHRoaXMuZmlyc3RJZHggPj0gayAmJiBwcmVkaWNhdGUodGhpcy5pdGVtc1trXSlcbiAgICAgICAgLy8gRmluZCBzIDo9IG1heCB7IGsgfCBrIDw9IHRoaXMubGFzdElkeCAmJiAhUChrKSB9IGFuZCByZXR1cm4gdGhpcy5kYXRhKHMuLi50aGlzLmxhc3RJZHhdXG4gICAgICAgIGxldCBlbmRJZHggPSB0aGlzLmxhc3RJZHg7XG4gICAgICAgIHdoaWxlIChlbmRJZHggPj0gMCAmJiBwcmVkaWNhdGUodGhpcy5pdGVtc1tlbmRJZHhdKSkge1xuICAgICAgICAgICAgZW5kSWR4LS07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZW5kSWR4ID09PSB0aGlzLmxhc3RJZHggPyBudWxsIDogdGhpcy5pdGVtcy5zbGljZShlbmRJZHggKyAxLCB0aGlzLmxhc3RJZHggKyAxKTtcbiAgICAgICAgdGhpcy5sYXN0SWR4ID0gZW5kSWR4O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbdGhpcy5maXJzdElkeF07XG4gICAgfVxuICAgIGRlcXVldWUoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaXRlbXNbdGhpcy5maXJzdElkeF07XG4gICAgICAgIHRoaXMuZmlyc3RJZHgrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGFrZUNvdW50KGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaXRlbXMuc2xpY2UodGhpcy5maXJzdElkeCwgdGhpcy5maXJzdElkeCArIGNvdW50KTtcbiAgICAgICAgdGhpcy5maXJzdElkeCArPSBjb3VudDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgZmFzdGVyIHRoYW4gYW4gaXRlcmF0b3IgYW5kIGFycmF5IGZvciBsYXp5IGNvbXB1dGVkIGRhdGEuXG4qL1xuZXhwb3J0IGNsYXNzIENhbGxiYWNrSXRlcmFibGUge1xuICAgIHN0YXRpYyB7IHRoaXMuZW1wdHkgPSBuZXcgQ2FsbGJhY2tJdGVyYWJsZShfY2FsbGJhY2sgPT4geyB9KTsgfVxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBjYWxsYmFjayBmb3IgZXZlcnkgaXRlbS5cbiAgICAgKiBTdG9wcyB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGZhbHNlLlxuICAgICovXG4gICAgaXRlcmF0ZSkge1xuICAgICAgICB0aGlzLml0ZXJhdGUgPSBpdGVyYXRlO1xuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVyYXRlKGl0ZW0gPT4geyByZXN1bHQucHVzaChpdGVtKTsgcmV0dXJuIHRydWU7IH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tJdGVyYWJsZShjYiA9PiB0aGlzLml0ZXJhdGUoaXRlbSA9PiBwcmVkaWNhdGUoaXRlbSkgPyBjYihpdGVtKSA6IHRydWUpKTtcbiAgICB9XG4gICAgbWFwKG1hcEZuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tJdGVyYWJsZShjYiA9PiB0aGlzLml0ZXJhdGUoaXRlbSA9PiBjYihtYXBGbihpdGVtKSkpKTtcbiAgICB9XG4gICAgZmluZExhc3QocHJlZGljYXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRoaXMuaXRlcmF0ZShpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmaW5kTGFzdE1heEJ5KGNvbXBhcmF0b3IpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pdGVyYXRlKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGZpcnN0IHx8IENvbXBhcmVSZXN1bHQuaXNHcmVhdGVyVGhhbihjb21wYXJhdG9yKGl0ZW0sIHJlc3VsdCkpKSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIHJlLWFycmFuZ2VtZW50IG9mIGl0ZW1zIGluIGFuIGFycmF5LlxuICovXG5leHBvcnQgY2xhc3MgUGVybXV0YXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKF9pbmRleE1hcCkge1xuICAgICAgICB0aGlzLl9pbmRleE1hcCA9IF9pbmRleE1hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBlcm11dGF0aW9uIHRoYXQgc29ydHMgdGhlIGdpdmVuIGFycmF5IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gY29tcGFyZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU29ydFBlcm11dGF0aW9uKGFyciwgY29tcGFyZUZuKSB7XG4gICAgICAgIGNvbnN0IHNvcnRJbmRpY2VzID0gQXJyYXkuZnJvbShhcnIua2V5cygpKS5zb3J0KChpbmRleDEsIGluZGV4MikgPT4gY29tcGFyZUZuKGFycltpbmRleDFdLCBhcnJbaW5kZXgyXSkpO1xuICAgICAgICByZXR1cm4gbmV3IFBlcm11dGF0aW9uKHNvcnRJbmRpY2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXkgcmUtYXJyYW5nZWQgYWNjb3JkaW5nIHRvIHRoaXMgcGVybXV0YXRpb24uXG4gICAgICovXG4gICAgYXBwbHkoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKChfLCBpbmRleCkgPT4gYXJyW3RoaXMuX2luZGV4TWFwW2luZGV4XV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHBlcm11dGF0aW9uIHRoYXQgdW5kb2VzIHRoZSByZS1hcnJhbmdlbWVudCBvZiB0aGlzIHBlcm11dGF0aW9uLlxuICAgICovXG4gICAgaW52ZXJzZSgpIHtcbiAgICAgICAgY29uc3QgaW52ZXJzZUluZGV4TWFwID0gdGhpcy5faW5kZXhNYXAuc2xpY2UoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbmRleE1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW52ZXJzZUluZGV4TWFwW3RoaXMuX2luZGV4TWFwW2ldXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQZXJtdXRhdGlvbihpbnZlcnNlSW5kZXhNYXApO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRMYXN0KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBpZHggPSBmaW5kTGFzdElkeChhcnJheSwgcHJlZGljYXRlKTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbaWR4XTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGFzdElkeChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXggPSBhcnJheS5sZW5ndGggLSAxKSB7XG4gICAgZm9yIChsZXQgaSA9IGZyb21JbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgICAgICBpZiAocHJlZGljYXRlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vKipcbiAqIEZpbmRzIHRoZSBsYXN0IGl0ZW0gd2hlcmUgcHJlZGljYXRlIGlzIHRydWUgdXNpbmcgYmluYXJ5IHNlYXJjaC5cbiAqIGBwcmVkaWNhdGVgIG11c3QgYmUgbW9ub3Rvbm91cywgaS5lLiBgYXJyLm1hcChwcmVkaWNhdGUpYCBtdXN0IGJlIGxpa2UgYFt0cnVlLCAuLi4sIHRydWUsIGZhbHNlLCAuLi4sIGZhbHNlXWAhXG4gKlxuICogQHJldHVybnMgYHVuZGVmaW5lZGAgaWYgbm8gaXRlbSBtYXRjaGVzLCBvdGhlcndpc2UgdGhlIGxhc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRMYXN0TW9ub3Rvbm91cyhhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgY29uc3QgaWR4ID0gZmluZExhc3RJZHhNb25vdG9ub3VzKGFycmF5LCBwcmVkaWNhdGUpO1xuICAgIHJldHVybiBpZHggPT09IC0xID8gdW5kZWZpbmVkIDogYXJyYXlbaWR4XTtcbn1cbi8qKlxuICogRmluZHMgdGhlIGxhc3QgaXRlbSB3aGVyZSBwcmVkaWNhdGUgaXMgdHJ1ZSB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICogYHByZWRpY2F0ZWAgbXVzdCBiZSBtb25vdG9ub3VzLCBpLmUuIGBhcnIubWFwKHByZWRpY2F0ZSlgIG11c3QgYmUgbGlrZSBgW3RydWUsIC4uLiwgdHJ1ZSwgZmFsc2UsIC4uLiwgZmFsc2VdYCFcbiAqXG4gKiBAcmV0dXJucyBgc3RhcnRJZHggLSAxYCBpZiBwcmVkaWNhdGUgaXMgZmFsc2UgZm9yIGFsbCBpdGVtcywgb3RoZXJ3aXNlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBpdGVtIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZExhc3RJZHhNb25vdG9ub3VzKGFycmF5LCBwcmVkaWNhdGUsIHN0YXJ0SWR4ID0gMCwgZW5kSWR4RXggPSBhcnJheS5sZW5ndGgpIHtcbiAgICBsZXQgaSA9IHN0YXJ0SWR4O1xuICAgIGxldCBqID0gZW5kSWR4RXg7XG4gICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgIGNvbnN0IGsgPSBNYXRoLmZsb29yKChpICsgaikgLyAyKTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtrXSkpIHtcbiAgICAgICAgICAgIGkgPSBrICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGogPSBrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpIC0gMTtcbn1cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IGl0ZW0gd2hlcmUgcHJlZGljYXRlIGlzIHRydWUgdXNpbmcgYmluYXJ5IHNlYXJjaC5cbiAqIGBwcmVkaWNhdGVgIG11c3QgYmUgbW9ub3Rvbm91cywgaS5lLiBgYXJyLm1hcChwcmVkaWNhdGUpYCBtdXN0IGJlIGxpa2UgYFtmYWxzZSwgLi4uLCBmYWxzZSwgdHJ1ZSwgLi4uLCB0cnVlXWAhXG4gKlxuICogQHJldHVybnMgYHVuZGVmaW5lZGAgaWYgbm8gaXRlbSBtYXRjaGVzLCBvdGhlcndpc2UgdGhlIGZpcnN0IGl0ZW0gdGhhdCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlyc3RNb25vdG9ub3VzKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBpZHggPSBmaW5kRmlyc3RJZHhNb25vdG9ub3VzT3JBcnJMZW4oYXJyYXksIHByZWRpY2F0ZSk7XG4gICAgcmV0dXJuIGlkeCA9PT0gYXJyYXkubGVuZ3RoID8gdW5kZWZpbmVkIDogYXJyYXlbaWR4XTtcbn1cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IGl0ZW0gd2hlcmUgcHJlZGljYXRlIGlzIHRydWUgdXNpbmcgYmluYXJ5IHNlYXJjaC5cbiAqIGBwcmVkaWNhdGVgIG11c3QgYmUgbW9ub3Rvbm91cywgaS5lLiBgYXJyLm1hcChwcmVkaWNhdGUpYCBtdXN0IGJlIGxpa2UgYFtmYWxzZSwgLi4uLCBmYWxzZSwgdHJ1ZSwgLi4uLCB0cnVlXWAhXG4gKlxuICogQHJldHVybnMgYGVuZElkeEV4YCBpZiBwcmVkaWNhdGUgaXMgZmFsc2UgZm9yIGFsbCBpdGVtcywgb3RoZXJ3aXNlIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdElkeE1vbm90b25vdXNPckFyckxlbihhcnJheSwgcHJlZGljYXRlLCBzdGFydElkeCA9IDAsIGVuZElkeEV4ID0gYXJyYXkubGVuZ3RoKSB7XG4gICAgbGV0IGkgPSBzdGFydElkeDtcbiAgICBsZXQgaiA9IGVuZElkeEV4O1xuICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICBjb25zdCBrID0gTWF0aC5mbG9vcigoaSArIGopIC8gMik7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlba10pKSB7XG4gICAgICAgICAgICBqID0gaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkgPSBrICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbn1cbi8qKlxuICogVXNlIHRoaXMgd2hlblxuICogKiBZb3UgaGF2ZSBhIHNvcnRlZCBhcnJheVxuICogKiBZb3UgcXVlcnkgdGhpcyBhcnJheSB3aXRoIGEgbW9ub3Rvbm91cyBwcmVkaWNhdGUgdG8gZmluZCB0aGUgbGFzdCBpdGVtIHRoYXQgaGFzIGEgY2VydGFpbiBwcm9wZXJ0eS5cbiAqICogWW91IHF1ZXJ5IHRoaXMgYXJyYXkgbXVsdGlwbGUgdGltZXMgd2l0aCBtb25vdG9ub3VzIHByZWRpY2F0ZXMgdGhhdCBnZXQgd2Vha2VyIGFuZCB3ZWFrZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBNb25vdG9ub3VzQXJyYXkge1xuICAgIHN0YXRpYyB7IHRoaXMuYXNzZXJ0SW52YXJpYW50cyA9IGZhbHNlOyB9XG4gICAgY29uc3RydWN0b3IoX2FycmF5KSB7XG4gICAgICAgIHRoaXMuX2FycmF5ID0gX2FycmF5O1xuICAgICAgICB0aGlzLl9maW5kTGFzdE1vbm90b25vdXNMYXN0SWR4ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHByZWRpY2F0ZSBtdXN0IGJlIG1vbm90b25vdXMsIGkuZS4gYGFyci5tYXAocHJlZGljYXRlKWAgbXVzdCBiZSBsaWtlIGBbdHJ1ZSwgLi4uLCB0cnVlLCBmYWxzZSwgLi4uLCBmYWxzZV1gIVxuICAgICAqIEZvciBzdWJzZXF1ZW50IGNhbGxzLCBjdXJyZW50IHByZWRpY2F0ZSBtdXN0IGJlIHdlYWtlciB0aGFuIChvciBlcXVhbCB0bykgdGhlIHByZXZpb3VzIHByZWRpY2F0ZSwgaS5lLiBtb3JlIGVudHJpZXMgbXVzdCBiZSBgdHJ1ZWAuXG4gICAgICovXG4gICAgZmluZExhc3RNb25vdG9ub3VzKHByZWRpY2F0ZSkge1xuICAgICAgICBpZiAoTW9ub3Rvbm91c0FycmF5LmFzc2VydEludmFyaWFudHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2RmluZExhc3RQcmVkaWNhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5fYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZGaW5kTGFzdFByZWRpY2F0ZShpdGVtKSAmJiAhcHJlZGljYXRlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vbm90b25vdXNBcnJheTogY3VycmVudCBwcmVkaWNhdGUgbXVzdCBiZSB3ZWFrZXIgdGhhbiAob3IgZXF1YWwgdG8pIHRoZSBwcmV2aW91cyBwcmVkaWNhdGUuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcmV2RmluZExhc3RQcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWR4ID0gZmluZExhc3RJZHhNb25vdG9ub3VzKHRoaXMuX2FycmF5LCBwcmVkaWNhdGUsIHRoaXMuX2ZpbmRMYXN0TW9ub3Rvbm91c0xhc3RJZHgpO1xuICAgICAgICB0aGlzLl9maW5kTGFzdE1vbm90b25vdXNMYXN0SWR4ID0gaWR4ICsgMTtcbiAgICAgICAgcmV0dXJuIGlkeCA9PT0gLTEgPyB1bmRlZmluZWQgOiB0aGlzLl9hcnJheVtpZHhdO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBldmVyeSBvdGhlciBpdGVtLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlyc3RNYXgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBtYXggPSBhcnJheVswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoaXRlbSwgbWF4KSA+IDApIHtcbiAgICAgICAgICAgIG1heCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBpdGVtIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIGV2ZXJ5IG90aGVyIGl0ZW0uXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRMYXN0TWF4KGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgbWF4ID0gYXJyYXlbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXJyYXlbaV07XG4gICAgICAgIGlmIChjb21wYXJhdG9yKGl0ZW0sIG1heCkgPj0gMCkge1xuICAgICAgICAgICAgbWF4ID0gaXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIHRoYXQgaXMgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIGV2ZXJ5IG90aGVyIGl0ZW0uXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdE1pbihhcnJheSwgY29tcGFyYXRvcikge1xuICAgIHJldHVybiBmaW5kRmlyc3RNYXgoYXJyYXksIChhLCBiKSA9PiAtY29tcGFyYXRvcihhLCBiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZE1heElkeChhcnJheSwgY29tcGFyYXRvcikge1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBsZXQgbWF4SWR4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoaXRlbSwgYXJyYXlbbWF4SWR4XSkgPiAwKSB7XG4gICAgICAgICAgICBtYXhJZHggPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhJZHg7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IG1hcHBlZCB2YWx1ZSBvZiB0aGUgYXJyYXkgd2hpY2ggaXMgbm90IHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEZpbmRGaXJzdChpdGVtcywgbWFwRm4pIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IG1hcEZuKHZhbHVlKTtcbiAgICAgICAgaWYgKG1hcHBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEJ1Z0luZGljYXRpbmdFcnJvciwgb25VbmV4cGVjdGVkRXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG4vKipcbiAqIFRocm93cyBhbiBlcnJvciB3aXRoIHRoZSBwcm92aWRlZCBtZXNzYWdlIGlmIHRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBldmFsdWF0ZSB0byBhIHRydWUgSmF2YXNjcmlwdCB2YWx1ZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGFzc2VydCguLi4pYCBpbnN0ZWFkLlxuICogVGhpcyBtZXRob2QgaXMgdXN1YWxseSB1c2VkIGxpa2UgdGhpczpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSAndnMvYmFzZS9jb21tb24vYXNzZXJ0JztcbiAqIGFzc2VydC5vayguLi4pO1xuICogYGBgXG4gKlxuICogSG93ZXZlciwgYGFzc2VydGAgaW4gdGhhdCBleGFtcGxlIGlzIGEgdXNlciBjaG9zZW4gbmFtZS5cbiAqIFRoZXJlIGlzIG5vIHRvb2xpbmcgZm9yIGdlbmVyYXRpbmcgc3VjaCBhbiBpbXBvcnQgc3RhdGVtZW50LlxuICogVGh1cywgdGhlIGBhc3NlcnQoLi4uKWAgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSA/IGBBc3NlcnRpb24gZmFpbGVkICgke21lc3NhZ2V9KWAgOiAnQXNzZXJ0aW9uIEZhaWxlZCcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROZXZlcih2YWx1ZSwgbWVzc2FnZSA9ICdVbnJlYWNoYWJsZScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG4vKipcbiAqIExpa2UgYXNzZXJ0LCBidXQgZG9lc24ndCB0aHJvdy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvZnRBc3NlcnQoY29uZGl0aW9uKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgb25VbmV4cGVjdGVkRXJyb3IobmV3IEJ1Z0luZGljYXRpbmdFcnJvcignU29mdCBBc3NlcnRpb24gRmFpbGVkJykpO1xuICAgIH1cbn1cbi8qKlxuICogY29uZGl0aW9uIG11c3QgYmUgc2lkZS1lZmZlY3QgZnJlZSFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZuKGNvbmRpdGlvbikge1xuICAgIGlmICghY29uZGl0aW9uKCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAvLyBSZWV2YWx1YXRlIGBjb25kaXRpb25gIGFnYWluIHRvIG1ha2UgZGVidWdnaW5nIGVhc2llclxuICAgICAgICBjb25kaXRpb24oKTtcbiAgICAgICAgb25VbmV4cGVjdGVkRXJyb3IobmV3IEJ1Z0luZGljYXRpbmdFcnJvcignQXNzZXJ0aW9uIEZhaWxlZCcpKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tBZGphY2VudEl0ZW1zKGl0ZW1zLCBwcmVkaWNhdGUpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnN0IGEgPSBpdGVtc1tpXTtcbiAgICAgICAgY29uc3QgYiA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUoYSwgYikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB9IGZyb20gJy4vY2FuY2VsbGF0aW9uLmpzJztcbmltcG9ydCB7IEJ1Z0luZGljYXRpbmdFcnJvciwgQ2FuY2VsbGF0aW9uRXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBFbWl0dGVyLCBFdmVudCB9IGZyb20gJy4vZXZlbnQuanMnO1xuaW1wb3J0IHsgdG9EaXNwb3NhYmxlIH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgc2V0VGltZW91dDAgfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IE1pY3JvdGFza0RlbGF5IH0gZnJvbSAnLi9zeW1ib2xzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpc1RoZW5hYmxlKG9iaikge1xuICAgIHJldHVybiAhIW9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FuY2VsYWJsZVByb21pc2UoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzb3VyY2UgPSBuZXcgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcbiAgICBjb25zdCB0aGVuYWJsZSA9IGNhbGxiYWNrKHNvdXJjZS50b2tlbik7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc291cmNlLnRva2VuLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCgpID0+IHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICByZWplY3QobmV3IENhbmNlbGxhdGlvbkVycm9yKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoZW5hYmxlKS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICBzb3VyY2UuZGlzcG9zZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgc291cmNlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IGNsYXNzIHtcbiAgICAgICAgY2FuY2VsKCkge1xuICAgICAgICAgICAgc291cmNlLmNhbmNlbCgpO1xuICAgICAgICAgICAgc291cmNlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKHJlamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseShvbmZpbmFsbHkpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmZpbmFsbHkob25maW5hbGx5KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcmFjZUNhbmNlbGxhdGlvbihwcm9taXNlLCB0b2tlbiwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVmID0gdG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHJlc29sdmUoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpLmZpbmFsbHkoKCkgPT4gcmVmLmRpc3Bvc2UoKSk7XG4gICAgfSk7XG59XG4vKipcbiAqIEEgaGVscGVyIHRvIHByZXZlbnQgYWNjdW11bGF0aW9uIG9mIHNlcXVlbnRpYWwgYXN5bmMgdGFza3MuXG4gKlxuICogSW1hZ2luZSBhIG1haWwgbWFuIHdpdGggdGhlIHNvbGUgdGFzayBvZiBkZWxpdmVyaW5nIGxldHRlcnMuIEFzIHNvb24gYXNcbiAqIGEgbGV0dGVyIHN1Ym1pdHRlZCBmb3IgZGVsaXZlcnksIGhlIGRyaXZlcyB0byB0aGUgZGVzdGluYXRpb24sIGRlbGl2ZXJzIGl0XG4gKiBhbmQgcmV0dXJucyB0byBoaXMgYmFzZS4gSW1hZ2luZSB0aGF0IGR1cmluZyB0aGUgdHJpcCwgTiBtb3JlIGxldHRlcnMgd2VyZSBzdWJtaXR0ZWQuXG4gKiBXaGVuIHRoZSBtYWlsIG1hbiByZXR1cm5zLCBoZSBwaWNrcyB0aG9zZSBOIGxldHRlcnMgYW5kIGRlbGl2ZXJzIHRoZW0gYWxsIGluIGFcbiAqIHNpbmdsZSB0cmlwLiBFdmVuIHRob3VnaCBOKzEgc3VibWlzc2lvbnMgb2NjdXJyZWQsIG9ubHkgMiBkZWxpdmVyaWVzIHdlcmUgbWFkZS5cbiAqXG4gKiBUaGUgdGhyb3R0bGVyIGltcGxlbWVudHMgdGhpcyB2aWEgdGhlIHF1ZXVlKCkgbWV0aG9kLCBieSBwcm92aWRpbmcgaXQgYSB0YXNrXG4gKiBmYWN0b3J5LiBGb2xsb3dpbmcgdGhlIGV4YW1wbGU6XG4gKlxuICogXHRcdGNvbnN0IHRocm90dGxlciA9IG5ldyBUaHJvdHRsZXIoKTtcbiAqIFx0XHRjb25zdCBsZXR0ZXJzID0gW107XG4gKlxuICogXHRcdGZ1bmN0aW9uIGRlbGl2ZXIoKSB7XG4gKiBcdFx0XHRjb25zdCBsZXR0ZXJzVG9EZWxpdmVyID0gbGV0dGVycztcbiAqIFx0XHRcdGxldHRlcnMgPSBbXTtcbiAqIFx0XHRcdHJldHVybiBtYWtlVGhlVHJpcChsZXR0ZXJzVG9EZWxpdmVyKTtcbiAqIFx0XHR9XG4gKlxuICogXHRcdGZ1bmN0aW9uIG9uTGV0dGVyUmVjZWl2ZWQobCkge1xuICogXHRcdFx0bGV0dGVycy5wdXNoKGwpO1xuICogXHRcdFx0dGhyb3R0bGVyLnF1ZXVlKGRlbGl2ZXIpO1xuICogXHRcdH1cbiAqL1xuZXhwb3J0IGNsYXNzIFRocm90dGxlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFjdGl2ZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnF1ZXVlZFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnF1ZXVlZFByb21pc2VGYWN0b3J5ID0gbnVsbDtcbiAgICB9XG4gICAgcXVldWUocHJvbWlzZUZhY3RvcnkpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVGhyb3R0bGVyIGlzIGRpc3Bvc2VkJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVkUHJvbWlzZUZhY3RvcnkgPSBwcm9taXNlRmFjdG9yeTtcbiAgICAgICAgICAgIGlmICghdGhpcy5xdWV1ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25Db21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucXVldWUodGhpcy5xdWV1ZWRQcm9taXNlRmFjdG9yeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWVkUHJvbWlzZUZhY3RvcnkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZWRQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJvbWlzZS50aGVuKG9uQ29tcGxldGUsIG9uQ29tcGxldGUpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVByb21pc2UgPSBwcm9taXNlRmFjdG9yeSgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVQcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfVxufVxuY29uc3QgdGltZW91dERlZmVycmVkID0gKHRpbWVvdXQsIGZuKSA9PiB7XG4gICAgbGV0IHNjaGVkdWxlZCA9IHRydWU7XG4gICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgIH0sIHRpbWVvdXQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzVHJpZ2dlcmVkOiAoKSA9PiBzY2hlZHVsZWQsXG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5jb25zdCBtaWNyb3Rhc2tEZWZlcnJlZCA9IChmbikgPT4ge1xuICAgIGxldCBzY2hlZHVsZWQgPSB0cnVlO1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgaWYgKHNjaGVkdWxlZCkge1xuICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNUcmlnZ2VyZWQ6ICgpID0+IHNjaGVkdWxlZCxcbiAgICAgICAgZGlzcG9zZTogKCkgPT4geyBzY2hlZHVsZWQgPSBmYWxzZTsgfSxcbiAgICB9O1xufTtcbi8qKlxuICogQSBoZWxwZXIgdG8gZGVsYXkgKGRlYm91bmNlKSBleGVjdXRpb24gb2YgYSB0YXNrIHRoYXQgaXMgYmVpbmcgcmVxdWVzdGVkIG9mdGVuLlxuICpcbiAqIEZvbGxvd2luZyB0aGUgdGhyb3R0bGVyLCBub3cgaW1hZ2luZSB0aGUgbWFpbCBtYW4gd2FudHMgdG8gb3B0aW1pemUgdGhlIG51bWJlciBvZlxuICogdHJpcHMgcHJvYWN0aXZlbHkuIFRoZSB0cmlwIGl0c2VsZiBjYW4gYmUgbG9uZywgc28gaGUgZGVjaWRlcyBub3QgdG8gbWFrZSB0aGUgdHJpcFxuICogYXMgc29vbiBhcyBhIGxldHRlciBpcyBzdWJtaXR0ZWQuIEluc3RlYWQgaGUgd2FpdHMgYSB3aGlsZSwgaW4gY2FzZSBtb3JlXG4gKiBsZXR0ZXJzIGFyZSBzdWJtaXR0ZWQuIEFmdGVyIHNhaWQgd2FpdGluZyBwZXJpb2QsIGlmIG5vIGxldHRlcnMgd2VyZSBzdWJtaXR0ZWQsIGhlXG4gKiBkZWNpZGVzIHRvIG1ha2UgdGhlIHRyaXAuIEltYWdpbmUgdGhhdCBOIG1vcmUgbGV0dGVycyB3ZXJlIHN1Ym1pdHRlZCBhZnRlciB0aGUgZmlyc3RcbiAqIG9uZSwgYWxsIHdpdGhpbiBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIGJldHdlZW4gZWFjaCBvdGhlci4gRXZlbiB0aG91Z2ggTisxXG4gKiBzdWJtaXNzaW9ucyBvY2N1cnJlZCwgb25seSAxIGRlbGl2ZXJ5IHdhcyBtYWRlLlxuICpcbiAqIFRoZSBkZWxheWVyIG9mZmVycyB0aGlzIGJlaGF2aW9yIHZpYSB0aGUgdHJpZ2dlcigpIG1ldGhvZCwgaW50byB3aGljaCBib3RoIHRoZSB0YXNrXG4gKiB0byBiZSBleGVjdXRlZCBhbmQgdGhlIHdhaXRpbmcgcGVyaW9kIChkZWxheSkgbXVzdCBiZSBwYXNzZWQgaW4gYXMgYXJndW1lbnRzLiBGb2xsb3dpbmdcbiAqIHRoZSBleGFtcGxlOlxuICpcbiAqIFx0XHRjb25zdCBkZWxheWVyID0gbmV3IERlbGF5ZXIoV0FJVElOR19QRVJJT0QpO1xuICogXHRcdGNvbnN0IGxldHRlcnMgPSBbXTtcbiAqXG4gKiBcdFx0ZnVuY3Rpb24gbGV0dGVyUmVjZWl2ZWQobCkge1xuICogXHRcdFx0bGV0dGVycy5wdXNoKGwpO1xuICogXHRcdFx0ZGVsYXllci50cmlnZ2VyKCgpID0+IHsgcmV0dXJuIG1ha2VUaGVUcmlwKCk7IH0pO1xuICogXHRcdH1cbiAqL1xuZXhwb3J0IGNsYXNzIERlbGF5ZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlZmF1bHREZWxheSkge1xuICAgICAgICB0aGlzLmRlZmF1bHREZWxheSA9IGRlZmF1bHREZWxheTtcbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcGxldGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmRvUmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9SZWplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgIH1cbiAgICB0cmlnZ2VyKHRhc2ssIGRlbGF5ID0gdGhpcy5kZWZhdWx0RGVsYXkpIHtcbiAgICAgICAgdGhpcy50YXNrID0gdGFzaztcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgIGlmICghdGhpcy5jb21wbGV0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgdGhpcy5kb1JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9SZXNvbHZlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLnRhc2s7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kb1Jlc29sdmU/LihudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IGRlbGF5ID09PSBNaWNyb3Rhc2tEZWxheSA/IG1pY3JvdGFza0RlZmVycmVkKGZuKSA6IHRpbWVvdXREZWZlcnJlZChkZWxheSwgZm4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0aW9uUHJvbWlzZTtcbiAgICB9XG4gICAgaXNUcmlnZ2VyZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZGVmZXJyZWQ/LmlzVHJpZ2dlcmVkKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRpb25Qcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLmRvUmVqZWN0Py4obmV3IENhbmNlbGxhdGlvbkVycm9yKCkpO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsVGltZW91dCgpIHtcbiAgICAgICAgdGhpcy5kZWZlcnJlZD8uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmRlZmVycmVkID0gbnVsbDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICB9XG59XG4vKipcbiAqIEEgaGVscGVyIHRvIGRlbGF5IGV4ZWN1dGlvbiBvZiBhIHRhc2sgdGhhdCBpcyBiZWluZyByZXF1ZXN0ZWQgb2Z0ZW4sIHdoaWxlXG4gKiBwcmV2ZW50aW5nIGFjY3VtdWxhdGlvbiBvZiBjb25zZWN1dGl2ZSBleGVjdXRpb25zLCB3aGlsZSB0aGUgdGFzayBydW5zLlxuICpcbiAqIFRoZSBtYWlsIG1hbiBpcyBjbGV2ZXIgYW5kIHdhaXRzIGZvciBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUsIGJlZm9yZSBnb2luZ1xuICogb3V0IHRvIGRlbGl2ZXIgbGV0dGVycy4gV2hpbGUgdGhlIG1haWwgbWFuIGlzIGdvaW5nIG91dCwgbW9yZSBsZXR0ZXJzIGFycml2ZVxuICogYW5kIGNhbiBvbmx5IGJlIGRlbGl2ZXJlZCBvbmNlIGhlIGlzIGJhY2suIE9uY2UgaGUgaXMgYmFjayB0aGUgbWFpbCBtYW4gd2lsbFxuICogZG8gb25lIG1vcmUgdHJpcCB0byBkZWxpdmVyIHRoZSBsZXR0ZXJzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB3aGlsZSBoZSB3YXMgb3V0LlxuICovXG5leHBvcnQgY2xhc3MgVGhyb3R0bGVkRGVsYXllciB7XG4gICAgY29uc3RydWN0b3IoZGVmYXVsdERlbGF5KSB7XG4gICAgICAgIHRoaXMuZGVsYXllciA9IG5ldyBEZWxheWVyKGRlZmF1bHREZWxheSk7XG4gICAgICAgIHRoaXMudGhyb3R0bGVyID0gbmV3IFRocm90dGxlcigpO1xuICAgIH1cbiAgICB0cmlnZ2VyKHByb21pc2VGYWN0b3J5LCBkZWxheSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxheWVyLnRyaWdnZXIoKCkgPT4gdGhpcy50aHJvdHRsZXIucXVldWUocHJvbWlzZUZhY3RvcnkpLCBkZWxheSk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5kZWxheWVyLmNhbmNlbCgpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmRlbGF5ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnRocm90dGxlci5kaXNwb3NlKCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXQobWlsbGlzLCB0b2tlbikge1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbmNlbGFibGVQcm9taXNlKHRva2VuID0+IHRpbWVvdXQobWlsbGlzLCB0b2tlbikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCBtaWxsaXMpO1xuICAgICAgICBjb25zdCBkaXNwb3NhYmxlID0gdG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICBkaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgdGltZW91dCB0aGF0IGNhbiBiZSBkaXNwb3NlZCB1c2luZyBpdHMgcmV0dXJuZWQgdmFsdWUuXG4gKiBAcGFyYW0gaGFuZGxlciBUaGUgdGltZW91dCBoYW5kbGVyLlxuICogQHBhcmFtIHRpbWVvdXQgQW4gb3B0aW9uYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0gc3RvcmUgQW4gb3B0aW9uYWwge0BsaW5rIERpc3Bvc2FibGVTdG9yZX0gdGhhdCB3aWxsIGhhdmUgdGhlIHRpbWVvdXQgZGlzcG9zYWJsZSBtYW5hZ2VkIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN0b3JlID0gbmV3IERpc3Bvc2FibGVTdG9yZTtcbiAqIC8vIENhbGwgdGhlIHRpbWVvdXQgYWZ0ZXIgMTAwMG1zIGF0IHdoaWNoIHBvaW50IGl0IHdpbGwgYmUgYXV0b21hdGljYWxseVxuICogLy8gZXZpY3RlZCBmcm9tIHRoZSBzdG9yZS5cbiAqIGNvbnN0IHRpbWVvdXREaXNwb3NhYmxlID0gZGlzcG9zYWJsZVRpbWVvdXQoKCkgPT4ge30sIDEwMDAsIHN0b3JlKTtcbiAqXG4gKiBpZiAoZm9vKSB7XG4gKiAgIC8vIENhbmNlbCB0aGUgdGltZW91dCBhbmQgZXZpY3QgaXQgZnJvbSBzdG9yZS5cbiAqICAgdGltZW91dERpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICogfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzcG9zYWJsZVRpbWVvdXQoaGFuZGxlciwgdGltZW91dCA9IDAsIHN0b3JlKSB7XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfSwgdGltZW91dCk7XG4gICAgY29uc3QgZGlzcG9zYWJsZSA9IHRvRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHN0b3JlPy5kZWxldGVBbmRMZWFrKGRpc3Bvc2FibGUpO1xuICAgIH0pO1xuICAgIHN0b3JlPy5hZGQoZGlzcG9zYWJsZSk7XG4gICAgcmV0dXJuIGRpc3Bvc2FibGU7XG59XG5leHBvcnQgZnVuY3Rpb24gZmlyc3QocHJvbWlzZUZhY3Rvcmllcywgc2hvdWxkU3RvcCA9IHQgPT4gISF0LCBkZWZhdWx0VmFsdWUgPSBudWxsKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCBsZW4gPSBwcm9taXNlRmFjdG9yaWVzLmxlbmd0aDtcbiAgICBjb25zdCBsb29wID0gKCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggPj0gbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHByb21pc2VGYWN0b3JpZXNbaW5kZXgrK107XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFjdG9yeSgpKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKHNob3VsZFN0b3AocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb29wKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGxvb3AoKTtcbn1cbmV4cG9ydCBjbGFzcyBUaW1lb3V0VGltZXIge1xuICAgIGNvbnN0cnVjdG9yKHJ1bm5lciwgdGltZW91dCkge1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Rva2VuID0gLTE7XG4gICAgICAgIGlmICh0eXBlb2YgcnVubmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5zZXRJZk5vdFNldChydW5uZXIsIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLl90b2tlbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90b2tlbik7XG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbEFuZFNldChydW5uZXIsIHRpbWVvdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoYENhbGxpbmcgJ2NhbmNlbEFuZFNldCcgb24gYSBkaXNwb3NlZCBUaW1lb3V0VGltZXJgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLl90b2tlbiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSAtMTtcbiAgICAgICAgICAgIHJ1bm5lcigpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICB9XG4gICAgc2V0SWZOb3RTZXQocnVubmVyLCB0aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKGBDYWxsaW5nICdzZXRJZk5vdFNldCcgb24gYSBkaXNwb3NlZCBUaW1lb3V0VGltZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdG9rZW4gIT09IC0xKSB7XG4gICAgICAgICAgICAvLyB0aW1lciBpcyBhbHJlYWR5IHNldFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rva2VuID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IC0xO1xuICAgICAgICAgICAgcnVubmVyKCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbnRlcnZhbFRpbWVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYW5jZWxBbmRTZXQocnVubmVyLCBpbnRlcnZhbCwgY29udGV4dCA9IGdsb2JhbFRoaXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcihgQ2FsbGluZyAnY2FuY2VsQW5kU2V0JyBvbiBhIGRpc3Bvc2VkIEludGVydmFsVGltZXJgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICBjb25zdCBoYW5kbGUgPSBjb250ZXh0LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHJ1bm5lcigpO1xuICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZSA9IHRvRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFySW50ZXJ2YWwoaGFuZGxlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJ1bk9uY2VTY2hlZHVsZXIge1xuICAgIGNvbnN0cnVjdG9yKHJ1bm5lciwgZGVsYXkpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0VG9rZW4gPSAtMTtcbiAgICAgICAgdGhpcy5ydW5uZXIgPSBydW5uZXI7XG4gICAgICAgIHRoaXMudGltZW91dCA9IGRlbGF5O1xuICAgICAgICB0aGlzLnRpbWVvdXRIYW5kbGVyID0gdGhpcy5vblRpbWVvdXQuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBSdW5PbmNlU2NoZWR1bGVyXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5ydW5uZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgY3VycmVudCBzY2hlZHVsZWQgcnVubmVyIChpZiBhbnkpLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTY2hlZHVsZWQoKSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRva2VuKTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dFRva2VuID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHByZXZpb3VzIHJ1bm5lciAoaWYgYW55KSAmIHNjaGVkdWxlIGEgbmV3IHJ1bm5lci5cbiAgICAgKi9cbiAgICBzY2hlZHVsZShkZWxheSA9IHRoaXMudGltZW91dCkge1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLnRpbWVvdXRUb2tlbiA9IHNldFRpbWVvdXQodGhpcy50aW1lb3V0SGFuZGxlciwgZGVsYXkpO1xuICAgIH1cbiAgICBnZXQgZGVsYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVvdXQ7XG4gICAgfVxuICAgIHNldCBkZWxheSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHNjaGVkdWxlZC5cbiAgICAgKi9cbiAgICBpc1NjaGVkdWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZW91dFRva2VuICE9PSAtMTtcbiAgICB9XG4gICAgb25UaW1lb3V0KCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRUb2tlbiA9IC0xO1xuICAgICAgICBpZiAodGhpcy5ydW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9SdW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb1J1bigpIHtcbiAgICAgICAgdGhpcy5ydW5uZXI/LigpO1xuICAgIH1cbn1cbi8qKlxuICogRXhlY3V0ZSB0aGUgY2FsbGJhY2sgdGhlIG5leHQgdGltZSB0aGUgYnJvd3NlciBpcyBpZGxlLCByZXR1cm5pbmcgYW5cbiAqIHtAbGluayBJRGlzcG9zYWJsZX0gdGhhdCB3aWxsIGNhbmNlbCB0aGUgY2FsbGJhY2sgd2hlbiBkaXNwb3NlZC4gVGhpcyB3cmFwc1xuICogW3JlcXVlc3RJZGxlQ2FsbGJhY2tdIHNvIGl0IHdpbGwgZmFsbGJhY2sgdG8gW3NldFRpbWVvdXRdIGlmIHRoZSBlbnZpcm9ubWVudFxuICogZG9lc24ndCBzdXBwb3J0IGl0LlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gcnVuIHdoZW4gaWRsZSwgdGhpcyBpbmNsdWRlcyBhblxuICogW0lkbGVEZWFkbGluZV0gdGhhdCBwcm92aWRlcyB0aGUgdGltZSBhbGxvdGVkIGZvciB0aGUgaWRsZSBjYWxsYmFjayBieSB0aGVcbiAqIGJyb3dzZXIuIE5vdCByZXNwZWN0aW5nIHRoaXMgZGVhZGxpbmUgd2lsbCByZXN1bHQgaW4gYSBkZWdyYWRlZCB1c2VyXG4gKiBleHBlcmllbmNlLlxuICogQHBhcmFtIHRpbWVvdXQgQSB0aW1lb3V0IGF0IHdoaWNoIHBvaW50IHRvIHF1ZXVlIG5vIGxvbmdlciB3YWl0IGZvciBhbiBpZGxlXG4gKiBjYWxsYmFjayBidXQgcXVldWUgaXQgb24gdGhlIHJlZ3VsYXIgZXZlbnQgbG9vcCAobGlrZSBzZXRUaW1lb3V0KS4gVHlwaWNhbGx5XG4gKiB0aGlzIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqXG4gKiBbSWRsZURlYWRsaW5lXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0lkbGVEZWFkbGluZVxuICogW3JlcXVlc3RJZGxlQ2FsbGJhY2tdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3JlcXVlc3RJZGxlQ2FsbGJhY2tcbiAqIFtzZXRUaW1lb3V0XTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9zZXRUaW1lb3V0XG4gKlxuICogKipOb3RlKiogdGhhdCB0aGVyZSBpcyBgZG9tLnRzI3J1bldoZW5XaW5kb3dJZGxlYCB3aGljaCBpcyBiZXR0ZXIgc3VpdGVkIHdoZW4gcnVubmluZyBpbnNpZGUgYSBicm93c2VyXG4gKiBjb250ZXh0XG4gKi9cbmV4cG9ydCBsZXQgcnVuV2hlbkdsb2JhbElkbGU7XG5leHBvcnQgbGV0IF9ydW5XaGVuSWRsZTtcbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLnJlcXVlc3RJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGdsb2JhbFRoaXMuY2FuY2VsSWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIF9ydW5XaGVuSWRsZSA9IChfdGFyZ2V0V2luZG93LCBydW5uZXIpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQwKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpICsgMTU7IC8vIG9uZSBmcmFtZSBhdCA2NGZwc1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lID0ge1xuICAgICAgICAgICAgICAgICAgICBkaWRUaW1lb3V0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW1lUmVtYWluaW5nKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGVuZCAtIERhdGUubm93KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBydW5uZXIoT2JqZWN0LmZyZWV6ZShkZWFkbGluZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfcnVuV2hlbklkbGUgPSAodGFyZ2V0V2luZG93LCBydW5uZXIsIHRpbWVvdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHRhcmdldFdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKHJ1bm5lciwgdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8geyB0aW1lb3V0IH0gOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgbGV0IGRpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0V2luZG93LmNhbmNlbElkbGVDYWxsYmFjayhoYW5kbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bldoZW5HbG9iYWxJZGxlID0gKHJ1bm5lcikgPT4gX3J1bldoZW5JZGxlKGdsb2JhbFRoaXMsIHJ1bm5lcik7XG59KSgpO1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0SWRsZVZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRXaW5kb3csIGV4ZWN1dG9yKSB7XG4gICAgICAgIHRoaXMuX2RpZFJ1biA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9leGVjdXRvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBleGVjdXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlkUnVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faGFuZGxlID0gX3J1bldoZW5JZGxlKHRhcmdldFdpbmRvdywgKCkgPT4gdGhpcy5fZXhlY3V0b3IoKSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kaWRSdW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9leGVjdXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBnZXQgaXNJbml0aWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpZFJ1bjtcbiAgICB9XG59XG4vKipcbiAqIEFuIGBJZGxlVmFsdWVgIHRoYXQgYWx3YXlzIHVzZXMgdGhlIGN1cnJlbnQgd2luZG93ICh3aGljaCBtaWdodCBiZSB0aHJvdHRsZWQgb3IgaW5hY3RpdmUpXG4gKlxuICogKipOb3RlKiogdGhhdCB0aGVyZSBpcyBgZG9tLnRzI1dpbmRvd0lkbGVWYWx1ZWAgd2hpY2ggaXMgYmV0dGVyIHN1aXRlZCB3aGVuIHJ1bm5pbmcgaW5zaWRlIGEgYnJvd3NlclxuICogY29udGV4dFxuICovXG5leHBvcnQgY2xhc3MgR2xvYmFsSWRsZVZhbHVlIGV4dGVuZHMgQWJzdHJhY3RJZGxlVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgICAgIHN1cGVyKGdsb2JhbFRoaXMsIGV4ZWN1dG9yKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcm9taXNlIHdob3NlIHJlc29sdXRpb24gb3IgcmVqZWN0aW9uIGNhbiBiZSBjb250cm9sbGVkIGltcGVyYXRpdmVseS5cbiAqL1xuZXhwb3J0IGNsYXNzIERlZmVycmVkUHJvbWlzZSB7XG4gICAgZ2V0IGlzUmVqZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGNvbWU/Lm91dGNvbWUgPT09IDEgLyogRGVmZXJyZWRPdXRjb21lLlJlamVjdGVkICovO1xuICAgIH1cbiAgICBnZXQgaXNTZXR0bGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLm91dGNvbWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnAgPSBuZXcgUHJvbWlzZSgoYywgZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUNhbGxiYWNrID0gYztcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDYWxsYmFjayA9IGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wbGV0ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5vdXRjb21lID0geyBvdXRjb21lOiAwIC8qIERlZmVycmVkT3V0Y29tZS5SZXNvbHZlZCAqLywgdmFsdWUgfTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVycm9yKGVycikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIHRoaXMub3V0Y29tZSA9IHsgb3V0Y29tZTogMSAvKiBEZWZlcnJlZE91dGNvbWUuUmVqZWN0ZWQgKi8sIHZhbHVlOiBlcnIgfTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IobmV3IENhbmNlbGxhdGlvbkVycm9yKCkpO1xuICAgIH1cbn1cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFByb21pc2VzXG5leHBvcnQgdmFyIFByb21pc2VzO1xuKGZ1bmN0aW9uIChQcm9taXNlcykge1xuICAgIC8qKlxuICAgICAqIEEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgYFByb21pc2UuYWxsYCB3aXRoIHRoZSBvbmx5IGRpZmZlcmVuY2VcbiAgICAgKiB0aGF0IHRoZSBtZXRob2QgYXdhaXRzIGV2ZXJ5IHByb21pc2UgdG8gZWl0aGVyIGZ1bGZpbGwgb3IgcmVqZWN0LlxuICAgICAqXG4gICAgICogU2ltaWxhciB0byBgUHJvbWlzZS5hbGxgLCBvbmx5IHRoZSBmaXJzdCBlcnJvciB3aWxsIGJlIHJldHVybmVkXG4gICAgICogaWYgYW55LlxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHNldHRsZWQocHJvbWlzZXMpIHtcbiAgICAgICAgbGV0IGZpcnN0RXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzLm1hcChwcm9taXNlID0+IHByb21pc2UudGhlbih2YWx1ZSA9PiB2YWx1ZSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaXJzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZG8gbm90IHJldGhyb3cgc28gdGhhdCBvdGhlciBwcm9taXNlcyBjYW4gc2V0dGxlXG4gICAgICAgIH0pKSk7XG4gICAgICAgIGlmICh0eXBlb2YgZmlyc3RFcnJvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IGZpcnN0RXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDsgLy8gY2FzdCBpcyBuZWVkZWQgYW5kIHByb3RlY3RlZCBieSB0aGUgYHRocm93YCBhYm92ZVxuICAgIH1cbiAgICBQcm9taXNlcy5zZXR0bGVkID0gc2V0dGxlZDtcbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYSBuZXcgYFByb21pc2U8VD5gIHdpdGggYSBib2R5IHRoYXQgaXMgYSBwcm9taXNlXG4gICAgICogaXRzZWxmLiBCeSBkZWZhdWx0LCBhbiBlcnJvciB0aGF0IHJhaXNlcyBmcm9tIHRoZSBhc3luYyBib2R5IHdpbGxcbiAgICAgKiBlbmQgdXAgYXMgYSB1bmhhbmRsZWQgcmVqZWN0aW9uLCBzbyB0aGlzIHV0aWxpdHkgcHJvcGVybHkgYXdhaXRzIHRoZVxuICAgICAqIGJvZHkgYW5kIHJlamVjdHMgdGhlIHByb21pc2UgYXMgYSBub3JtYWwgcHJvbWlzZSBkb2VzIHdpdGhvdXQgYXN5bmNcbiAgICAgKiBib2R5LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiByYXJlIGNhc2VzIHdoZXJlIG90aGVyd2lzZSBgYXN5bmNgXG4gICAgICogY2Fubm90IGJlIHVzZWQgKGUuZy4gd2hlbiBjYWxsYmFja3MgYXJlIGludm9sdmVkIHRoYXQgcmVxdWlyZSB0aGlzKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3aXRoQXN5bmNCb2R5KGJvZHlGbikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBib2R5Rm4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBQcm9taXNlcy53aXRoQXN5bmNCb2R5ID0gd2l0aEFzeW5jQm9keTtcbn0pKFByb21pc2VzIHx8IChQcm9taXNlcyA9IHt9KSk7XG4vKipcbiAqIEEgcmljaCBpbXBsZW1lbnRhdGlvbiBmb3IgYW4gYEFzeW5jSXRlcmFibGU8VD5gLlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNJdGVyYWJsZU9iamVjdCB7XG4gICAgc3RhdGljIGZyb21BcnJheShpdGVtcykge1xuICAgICAgICByZXR1cm4gbmV3IEFzeW5jSXRlcmFibGVPYmplY3QoKHdyaXRlcikgPT4ge1xuICAgICAgICAgICAgd3JpdGVyLmVtaXRNYW55KGl0ZW1zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUHJvbWlzZShwcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXN5bmNJdGVyYWJsZU9iamVjdChhc3luYyAoZW1pdHRlcikgPT4ge1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0TWFueShhd2FpdCBwcm9taXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUHJvbWlzZXMocHJvbWlzZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3luY0l0ZXJhYmxlT2JqZWN0KGFzeW5jIChlbWl0dGVyKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcy5tYXAoYXN5bmMgKHApID0+IGVtaXR0ZXIuZW1pdE9uZShhd2FpdCBwKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlKGl0ZXJhYmxlcykge1xuICAgICAgICByZXR1cm4gbmV3IEFzeW5jSXRlcmFibGVPYmplY3QoYXN5bmMgKGVtaXR0ZXIpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGl0ZXJhYmxlcy5tYXAoYXN5bmMgKGl0ZXJhYmxlKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdE9uZShpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLkVNUFRZID0gQXN5bmNJdGVyYWJsZU9iamVjdC5mcm9tQXJyYXkoW10pOyB9XG4gICAgY29uc3RydWN0b3IoZXhlY3V0b3IsIG9uUmV0dXJuKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gMCAvKiBBc3luY0l0ZXJhYmxlU291cmNlU3RhdGUuSW5pdGlhbCAqLztcbiAgICAgICAgdGhpcy5fcmVzdWx0cyA9IFtdO1xuICAgICAgICB0aGlzLl9lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uUmV0dXJuID0gb25SZXR1cm47XG4gICAgICAgIHRoaXMuX29uU3RhdGVDaGFuZ2VkID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0ge1xuICAgICAgICAgICAgICAgIGVtaXRPbmU6IChpdGVtKSA9PiB0aGlzLmVtaXRPbmUoaXRlbSksXG4gICAgICAgICAgICAgICAgZW1pdE1hbnk6IChpdGVtcykgPT4gdGhpcy5lbWl0TWFueShpdGVtcyksXG4gICAgICAgICAgICAgICAgcmVqZWN0OiAoZXJyb3IpID0+IHRoaXMucmVqZWN0KGVycm9yKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGV4ZWN1dG9yKHdyaXRlcikpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuZW1pdE9uZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB3cml0ZXIuZW1pdE1hbnkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnJlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMiAvKiBBc3luY0l0ZXJhYmxlU291cmNlU3RhdGUuRG9uZUVycm9yICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMuX3Jlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMuX3Jlc3VsdHNbaSsrXSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMSAvKiBBc3luY0l0ZXJhYmxlU291cmNlU3RhdGUuRG9uZU9LICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgRXZlbnQudG9Qcm9taXNlKHRoaXMuX29uU3RhdGVDaGFuZ2VkLmV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblJldHVybj8uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgbWFwKGl0ZXJhYmxlLCBtYXBGbikge1xuICAgICAgICByZXR1cm4gbmV3IEFzeW5jSXRlcmFibGVPYmplY3QoYXN5bmMgKGVtaXR0ZXIpID0+IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdE9uZShtYXBGbihpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXAobWFwRm4pIHtcbiAgICAgICAgcmV0dXJuIEFzeW5jSXRlcmFibGVPYmplY3QubWFwKHRoaXMsIG1hcEZuKTtcbiAgICB9XG4gICAgc3RhdGljIGZpbHRlcihpdGVyYWJsZSwgZmlsdGVyRm4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3luY0l0ZXJhYmxlT2JqZWN0KGFzeW5jIChlbWl0dGVyKSA9PiB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRm4oaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0T25lKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbHRlcihmaWx0ZXJGbikge1xuICAgICAgICByZXR1cm4gQXN5bmNJdGVyYWJsZU9iamVjdC5maWx0ZXIodGhpcywgZmlsdGVyRm4pO1xuICAgIH1cbiAgICBzdGF0aWMgY29hbGVzY2UoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIEFzeW5jSXRlcmFibGVPYmplY3QuZmlsdGVyKGl0ZXJhYmxlLCBpdGVtID0+ICEhaXRlbSk7XG4gICAgfVxuICAgIGNvYWxlc2NlKCkge1xuICAgICAgICByZXR1cm4gQXN5bmNJdGVyYWJsZU9iamVjdC5jb2FsZXNjZSh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIHRvUHJvbWlzZShpdGVyYWJsZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b1Byb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBBc3luY0l0ZXJhYmxlT2JqZWN0LnRvUHJvbWlzZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdpbGwgYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIElmIGByZXNvbHZlKClgIG9yIGByZWplY3QoKWAgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkLCB0aGlzIG1ldGhvZCBoYXMgbm8gZWZmZWN0LlxuICAgICAqL1xuICAgIGVtaXRPbmUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSAwIC8qIEFzeW5jSXRlcmFibGVTb3VyY2VTdGF0ZS5Jbml0aWFsICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQgaXMgaW1wb3J0YW50IHRvIGFkZCBuZXcgdmFsdWVzIGF0IHRoZSBlbmQsXG4gICAgICAgIC8vIGFzIHdlIG1heSBoYXZlIGl0ZXJhdG9ycyBhbHJlYWR5IHJ1bm5pbmcgb24gdGhlIGFycmF5XG4gICAgICAgIHRoaXMuX3Jlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX29uU3RhdGVDaGFuZ2VkLmZpcmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlcyB3aWxsIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiBgcmVzb2x2ZSgpYCBvciBgcmVqZWN0KClgIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCwgdGhpcyBtZXRob2QgaGFzIG5vIGVmZmVjdC5cbiAgICAgKi9cbiAgICBlbWl0TWFueSh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSAwIC8qIEFzeW5jSXRlcmFibGVTb3VyY2VTdGF0ZS5Jbml0aWFsICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQgaXMgaW1wb3J0YW50IHRvIGFkZCBuZXcgdmFsdWVzIGF0IHRoZSBlbmQsXG4gICAgICAgIC8vIGFzIHdlIG1heSBoYXZlIGl0ZXJhdG9ycyBhbHJlYWR5IHJ1bm5pbmcgb24gdGhlIGFycmF5XG4gICAgICAgIHRoaXMuX3Jlc3VsdHMgPSB0aGlzLl9yZXN1bHRzLmNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICB0aGlzLl9vblN0YXRlQ2hhbmdlZC5maXJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxpbmcgYHJlc29sdmUoKWAgd2lsbCBtYXJrIHRoZSByZXN1bHQgYXJyYXkgYXMgY29tcGxldGUuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBgcmVzb2x2ZSgpYCBtdXN0IGJlIGNhbGxlZCwgb3RoZXJ3aXNlIGFsbCBjb25zdW1lcnMgb2YgdGhpcyBpdGVyYWJsZSB3aWxsIGhhbmcgaW5kZWZpbml0ZWx5LCBzaW1pbGFyIHRvIGEgbm9uLXJlc29sdmVkIHByb21pc2UuXG4gICAgICogKipOT1RFKiogSWYgYHJlc29sdmUoKWAgb3IgYHJlamVjdCgpYCBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQsIHRoaXMgbWV0aG9kIGhhcyBubyBlZmZlY3QuXG4gICAgICovXG4gICAgcmVzb2x2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSAwIC8qIEFzeW5jSXRlcmFibGVTb3VyY2VTdGF0ZS5Jbml0aWFsICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIEFzeW5jSXRlcmFibGVTb3VyY2VTdGF0ZS5Eb25lT0sgKi87XG4gICAgICAgIHRoaXMuX29uU3RhdGVDaGFuZ2VkLmZpcmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGluZyBhbiBlcnJvciB3aWxsIHBlcm1hbmVudGx5IGludmFsaWRhdGUgdGhpcyBpdGVyYWJsZS5cbiAgICAgKiBUaGUgY3VycmVudCB1c2VycyB3aWxsIHJlY2VpdmUgYW4gZXJyb3IgdGhyb3duLCBhcyB3aWxsIGFsbCBmdXR1cmUgdXNlcnMuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiBgcmVzb2x2ZSgpYCBvciBgcmVqZWN0KClgIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCwgdGhpcyBtZXRob2QgaGFzIG5vIGVmZmVjdC5cbiAgICAgKi9cbiAgICByZWplY3QoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSAwIC8qIEFzeW5jSXRlcmFibGVTb3VyY2VTdGF0ZS5Jbml0aWFsICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUgPSAyIC8qIEFzeW5jSXRlcmFibGVTb3VyY2VTdGF0ZS5Eb25lRXJyb3IgKi87XG4gICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX29uU3RhdGVDaGFuZ2VkLmZpcmUoKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2FuY2VsYWJsZUFzeW5jSXRlcmFibGVPYmplY3QgZXh0ZW5kcyBBc3luY0l0ZXJhYmxlT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihfc291cmNlLCBleGVjdXRvcikge1xuICAgICAgICBzdXBlcihleGVjdXRvcik7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IF9zb3VyY2U7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5fc291cmNlLmNhbmNlbCgpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYW5jZWxhYmxlQXN5bmNJdGVyYWJsZShjYWxsYmFjaykge1xuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgIGNvbnN0IGlubmVySXRlcmFibGUgPSBjYWxsYmFjayhzb3VyY2UudG9rZW4pO1xuICAgIHJldHVybiBuZXcgQ2FuY2VsYWJsZUFzeW5jSXRlcmFibGVPYmplY3Qoc291cmNlLCBhc3luYyAoZW1pdHRlcikgPT4ge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzb3VyY2UudG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHNvdXJjZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICBlbWl0dGVyLnJlamVjdChuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGlubmVySXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnRva2VuLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbmNlbGVkIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdE9uZShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICBzb3VyY2UuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICBzb3VyY2UuZGlzcG9zZSgpO1xuICAgICAgICAgICAgZW1pdHRlci5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8jZW5kcmVnaW9uXG4iLCJleHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkodCkge1xuICAgIHJldHVybiB0O1xufVxuLyoqXG4gKiBVc2VzIGEgTFJVIGNhY2hlIHRvIG1ha2UgYSBnaXZlbiBwYXJhbWV0cml6ZWQgZnVuY3Rpb24gY2FjaGVkLlxuICogQ2FjaGVzIGp1c3QgdGhlIGxhc3Qga2V5L3ZhbHVlLlxuKi9cbmV4cG9ydCBjbGFzcyBMUlVDYWNoZWRGdW5jdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYXJnMSwgYXJnMikge1xuICAgICAgICB0aGlzLmxhc3RDYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYXN0QXJnS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZuID0gYXJnMTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVLZXkgPSBpZGVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZuID0gYXJnMjtcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVLZXkgPSBhcmcxLmdldENhY2hlS2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChhcmcpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5fY29tcHV0ZUtleShhcmcpO1xuICAgICAgICBpZiAodGhpcy5sYXN0QXJnS2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEFyZ0tleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMubGFzdENhY2hlID0gdGhpcy5fZm4oYXJnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q2FjaGU7XG4gICAgfVxufVxuLyoqXG4gKiBVc2VzIGFuIHVuYm91bmRlZCBjYWNoZSB0byBtZW1vaXplIHRoZSByZXN1bHRzIG9mIHRoZSBnaXZlbiBmdW5jdGlvbi5cbiovXG5leHBvcnQgY2xhc3MgQ2FjaGVkRnVuY3Rpb24ge1xuICAgIGdldCBjYWNoZWRWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXA7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9tYXAyID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZuID0gYXJnMTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVLZXkgPSBpZGVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZuID0gYXJnMjtcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVLZXkgPSBhcmcxLmdldENhY2hlS2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChhcmcpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5fY29tcHV0ZUtleShhcmcpO1xuICAgICAgICBpZiAodGhpcy5fbWFwMi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcDIuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9mbihhcmcpO1xuICAgICAgICB0aGlzLl9tYXAuc2V0KGFyZywgdmFsdWUpO1xuICAgICAgICB0aGlzLl9tYXAyLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgRW1pdHRlciwgRXZlbnQgfSBmcm9tICcuL2V2ZW50LmpzJztcbmNvbnN0IHNob3J0Y3V0RXZlbnQgPSBPYmplY3QuZnJlZXplKGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoY2FsbGJhY2suYmluZChjb250ZXh0KSwgMCk7XG4gICAgcmV0dXJuIHsgZGlzcG9zZSgpIHsgY2xlYXJUaW1lb3V0KGhhbmRsZSk7IH0gfTtcbn0pO1xuZXhwb3J0IHZhciBDYW5jZWxsYXRpb25Ub2tlbjtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICBmdW5jdGlvbiBpc0NhbmNlbGxhdGlvblRva2VuKHRoaW5nKSB7XG4gICAgICAgIGlmICh0aGluZyA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSB8fCB0aGluZyA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBNdXRhYmxlVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpbmcgfHwgdHlwZW9mIHRoaW5nICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpbmcuaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5pc0NhbmNlbGxhdGlvblRva2VuID0gaXNDYW5jZWxsYXRpb25Ub2tlbjtcbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBmYWxzZSxcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IEV2ZW50Lk5vbmVcbiAgICB9KTtcbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IHRydWUsXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBzaG9ydGN1dEV2ZW50XG4gICAgfSk7XG59KShDYW5jZWxsYXRpb25Ub2tlbiB8fCAoQ2FuY2VsbGF0aW9uVG9rZW4gPSB7fSkpO1xuY2xhc3MgTXV0YWJsZVRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZW1pdHRlciA9IG51bGw7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENhbmNlbGxhdGlvblRva2VuU291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5fdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3BhcmVudExpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wYXJlbnRMaXN0ZW5lciA9IHBhcmVudCAmJiBwYXJlbnQub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQodGhpcy5jYW5jZWwsIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgdG9rZW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGJlIGxhenkgYW5kIGNyZWF0ZSB0aGUgdG9rZW4gb25seSB3aGVuXG4gICAgICAgICAgICAvLyBhY3R1YWxseSBuZWVkZWRcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gbmV3IE11dGFibGVUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbjtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGFuIG9iamVjdCBieSByZXR1cm5pbmcgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIGNhbmNlbGxlZCB0b2tlbiB3aGVuIGNhbmNlbGxhdGlvbiBoYXBwZW5zXG4gICAgICAgICAgICAvLyBiZWZvcmUgc29tZW9uZSBhc2tzIGZvciB0aGUgdG9rZW5cbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Rva2VuIGluc3RhbmNlb2YgTXV0YWJsZVRva2VuKSB7XG4gICAgICAgICAgICAvLyBhY3R1YWxseSBjYW5jZWxcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoY2FuY2VsID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGNhbmNlbCkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXJlbnRMaXN0ZW5lcj8uZGlzcG9zZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdG8gaW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5IHRva2VuIGlmIHdlIGhhZCBub25lXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fdG9rZW4gaW5zdGFuY2VvZiBNdXRhYmxlVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGRpc3Bvc2VcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxPbkRpc3Bvc2Uoc3RvcmUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBuZXcgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcbiAgICBzdG9yZS5hZGQoeyBkaXNwb3NlKCkgeyBzb3VyY2UuY2FuY2VsKCk7IH0gfSk7XG4gICAgcmV0dXJuIHNvdXJjZS50b2tlbjtcbn1cbiIsImltcG9ydCB7IHJlZ2lzdGVyIH0gZnJvbSAnLi9jb2RpY29uc1V0aWwuanMnO1xuaW1wb3J0IHsgY29kaWNvbnNMaWJyYXJ5IH0gZnJvbSAnLi9jb2RpY29uc0xpYnJhcnkuanMnO1xuLyoqXG4gKiBEZXJpdmVkIGljb25zLCB0aGF0IGNvdWxkIGJlY29tZSBzZXBhcmF0ZSBpY29ucy5cbiAqIFRoZXNlIG1hcHBpbmdzIHNob3VsZCBiZSBtb3ZlZCBpbnRvIHRoZSBtYXBwaW5nIGZpbGUgaW4gdGhlIHZzY29kZS1jb2RpY29ucyByZXBvIGF0IHNvbWUgcG9pbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBjb2RpY29uc0Rlcml2ZWQgPSB7XG4gICAgZGlhbG9nRXJyb3I6IHJlZ2lzdGVyKCdkaWFsb2ctZXJyb3InLCAnZXJyb3InKSxcbiAgICBkaWFsb2dXYXJuaW5nOiByZWdpc3RlcignZGlhbG9nLXdhcm5pbmcnLCAnd2FybmluZycpLFxuICAgIGRpYWxvZ0luZm86IHJlZ2lzdGVyKCdkaWFsb2ctaW5mbycsICdpbmZvJyksXG4gICAgZGlhbG9nQ2xvc2U6IHJlZ2lzdGVyKCdkaWFsb2ctY2xvc2UnLCAnY2xvc2UnKSxcbiAgICB0cmVlSXRlbUV4cGFuZGVkOiByZWdpc3RlcigndHJlZS1pdGVtLWV4cGFuZGVkJywgJ2NoZXZyb24tZG93bicpLCAvLyBjb2xsYXBzZWQgaXMgZG9uZSB3aXRoIHJvdGF0aW9uXG4gICAgdHJlZUZpbHRlck9uVHlwZU9uOiByZWdpc3RlcigndHJlZS1maWx0ZXItb24tdHlwZS1vbicsICdsaXN0LWZpbHRlcicpLFxuICAgIHRyZWVGaWx0ZXJPblR5cGVPZmY6IHJlZ2lzdGVyKCd0cmVlLWZpbHRlci1vbi10eXBlLW9mZicsICdsaXN0LXNlbGVjdGlvbicpLFxuICAgIHRyZWVGaWx0ZXJDbGVhcjogcmVnaXN0ZXIoJ3RyZWUtZmlsdGVyLWNsZWFyJywgJ2Nsb3NlJyksXG4gICAgdHJlZUl0ZW1Mb2FkaW5nOiByZWdpc3RlcigndHJlZS1pdGVtLWxvYWRpbmcnLCAnbG9hZGluZycpLFxuICAgIG1lbnVTZWxlY3Rpb246IHJlZ2lzdGVyKCdtZW51LXNlbGVjdGlvbicsICdjaGVjaycpLFxuICAgIG1lbnVTdWJtZW51OiByZWdpc3RlcignbWVudS1zdWJtZW51JywgJ2NoZXZyb24tcmlnaHQnKSxcbiAgICBtZW51QmFyTW9yZTogcmVnaXN0ZXIoJ21lbnViYXItbW9yZScsICdtb3JlJyksXG4gICAgc2Nyb2xsYmFyQnV0dG9uTGVmdDogcmVnaXN0ZXIoJ3Njcm9sbGJhci1idXR0b24tbGVmdCcsICd0cmlhbmdsZS1sZWZ0JyksXG4gICAgc2Nyb2xsYmFyQnV0dG9uUmlnaHQ6IHJlZ2lzdGVyKCdzY3JvbGxiYXItYnV0dG9uLXJpZ2h0JywgJ3RyaWFuZ2xlLXJpZ2h0JyksXG4gICAgc2Nyb2xsYmFyQnV0dG9uVXA6IHJlZ2lzdGVyKCdzY3JvbGxiYXItYnV0dG9uLXVwJywgJ3RyaWFuZ2xlLXVwJyksXG4gICAgc2Nyb2xsYmFyQnV0dG9uRG93bjogcmVnaXN0ZXIoJ3Njcm9sbGJhci1idXR0b24tZG93bicsICd0cmlhbmdsZS1kb3duJyksXG4gICAgdG9vbEJhck1vcmU6IHJlZ2lzdGVyKCd0b29sYmFyLW1vcmUnLCAnbW9yZScpLFxuICAgIHF1aWNrSW5wdXRCYWNrOiByZWdpc3RlcigncXVpY2staW5wdXQtYmFjaycsICdhcnJvdy1sZWZ0JyksXG4gICAgZHJvcERvd25CdXR0b246IHJlZ2lzdGVyKCdkcm9wLWRvd24tYnV0dG9uJywgMHhlYWI0KSxcbiAgICBzeW1ib2xDdXN0b21Db2xvcjogcmVnaXN0ZXIoJ3N5bWJvbC1jdXN0b21jb2xvcicsIDB4ZWI1YyksXG4gICAgZXhwb3J0SWNvbjogcmVnaXN0ZXIoJ2V4cG9ydCcsIDB4ZWJhYyksXG4gICAgd29ya3NwYWNlVW5zcGVjaWZpZWQ6IHJlZ2lzdGVyKCd3b3Jrc3BhY2UtdW5zcGVjaWZpZWQnLCAweGViYzMpLFxuICAgIG5ld0xpbmU6IHJlZ2lzdGVyKCduZXdsaW5lJywgMHhlYmVhKSxcbiAgICB0aHVtYnNEb3duRmlsbGVkOiByZWdpc3RlcigndGh1bWJzZG93bi1maWxsZWQnLCAweGVjMTMpLFxuICAgIHRodW1ic1VwRmlsbGVkOiByZWdpc3RlcigndGh1bWJzdXAtZmlsbGVkJywgMHhlYzE0KSxcbiAgICBnaXRGZXRjaDogcmVnaXN0ZXIoJ2dpdC1mZXRjaCcsIDB4ZWMxZCksXG4gICAgbGlnaHRidWxiU3BhcmtsZUF1dG9maXg6IHJlZ2lzdGVyKCdsaWdodGJ1bGItc3BhcmtsZS1hdXRvZml4JywgMHhlYzFmKSxcbiAgICBkZWJ1Z0JyZWFrcG9pbnRQZW5kaW5nOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1wZW5kaW5nJywgMHhlYmQ5KSxcbn07XG4vKipcbiAqIFRoZSBDb2RpY29uIGxpYnJhcnkgaXMgYSBzZXQgb2YgZGVmYXVsdCBpY29ucyB0aGF0IGFyZSBidWlsdC1pbiBpbiBWUyBDb2RlLlxuICpcbiAqIEluIHRoZSBwcm9kdWN0IChvdXRzaWRlIG9mIGJhc2UpIENvZGljb25zIHNob3VsZCBvbmx5IGJlIHVzZWQgYXMgZGVmYXVsdHMuIEluIG9yZGVyIHRvIGhhdmUgYWxsIGljb25zIGluIFZTIENvZGVcbiAqIHRoZW1lYWJsZSwgY29tcG9uZW50IHNob3VsZCBkZWZpbmUgbmV3LCBVSSBjb21wb25lbnQgc3BlY2lmaWMgaWNvbnMgdXNpbmcgYGljb25SZWdpc3RyeS5yZWdpc3Rlckljb25gLlxuICogSW4gdGhhdCBjYWxsIGEgQ29kaWNvbiBjYW4gYmUgbmFtZWQgYXMgZGVmYXVsdC5cbiAqL1xuZXhwb3J0IGNvbnN0IENvZGljb24gPSB7XG4gICAgLi4uY29kaWNvbnNMaWJyYXJ5LFxuICAgIC4uLmNvZGljb25zRGVyaXZlZFxufTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuL2NvZGljb25zVXRpbC5qcyc7XG4vLyBUaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgKG1pY3Jvc29mdC92c2NvZGUtY29kaWNvbnMpL3NjcmlwdHMvZXhwb3J0LXRvLXRzLmpzXG4vLyBQbGVhc2UgZG9uJ3QgZWRpdCBpdCwgYXMgeW91ciBjaGFuZ2VzIHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4vLyBJbnN0ZWFkLCBhZGQgbWFwcGluZ3MgdG8gY29kaWNvbnNEZXJpdmVkIGluIGNvZGljb25zLnRzLlxuZXhwb3J0IGNvbnN0IGNvZGljb25zTGlicmFyeSA9IHtcbiAgICBhZGQ6IHJlZ2lzdGVyKCdhZGQnLCAweGVhNjApLFxuICAgIHBsdXM6IHJlZ2lzdGVyKCdwbHVzJywgMHhlYTYwKSxcbiAgICBnaXN0TmV3OiByZWdpc3RlcignZ2lzdC1uZXcnLCAweGVhNjApLFxuICAgIHJlcG9DcmVhdGU6IHJlZ2lzdGVyKCdyZXBvLWNyZWF0ZScsIDB4ZWE2MCksXG4gICAgbGlnaHRidWxiOiByZWdpc3RlcignbGlnaHRidWxiJywgMHhlYTYxKSxcbiAgICBsaWdodEJ1bGI6IHJlZ2lzdGVyKCdsaWdodC1idWxiJywgMHhlYTYxKSxcbiAgICByZXBvOiByZWdpc3RlcigncmVwbycsIDB4ZWE2MiksXG4gICAgcmVwb0RlbGV0ZTogcmVnaXN0ZXIoJ3JlcG8tZGVsZXRlJywgMHhlYTYyKSxcbiAgICBnaXN0Rm9yazogcmVnaXN0ZXIoJ2dpc3QtZm9yaycsIDB4ZWE2MyksXG4gICAgcmVwb0ZvcmtlZDogcmVnaXN0ZXIoJ3JlcG8tZm9ya2VkJywgMHhlYTYzKSxcbiAgICBnaXRQdWxsUmVxdWVzdDogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QnLCAweGVhNjQpLFxuICAgIGdpdFB1bGxSZXF1ZXN0QWJhbmRvbmVkOiByZWdpc3RlcignZ2l0LXB1bGwtcmVxdWVzdC1hYmFuZG9uZWQnLCAweGVhNjQpLFxuICAgIHJlY29yZEtleXM6IHJlZ2lzdGVyKCdyZWNvcmQta2V5cycsIDB4ZWE2NSksXG4gICAga2V5Ym9hcmQ6IHJlZ2lzdGVyKCdrZXlib2FyZCcsIDB4ZWE2NSksXG4gICAgdGFnOiByZWdpc3RlcigndGFnJywgMHhlYTY2KSxcbiAgICBnaXRQdWxsUmVxdWVzdExhYmVsOiByZWdpc3RlcignZ2l0LXB1bGwtcmVxdWVzdC1sYWJlbCcsIDB4ZWE2NiksXG4gICAgdGFnQWRkOiByZWdpc3RlcigndGFnLWFkZCcsIDB4ZWE2NiksXG4gICAgdGFnUmVtb3ZlOiByZWdpc3RlcigndGFnLXJlbW92ZScsIDB4ZWE2NiksXG4gICAgcGVyc29uOiByZWdpc3RlcigncGVyc29uJywgMHhlYTY3KSxcbiAgICBwZXJzb25Gb2xsb3c6IHJlZ2lzdGVyKCdwZXJzb24tZm9sbG93JywgMHhlYTY3KSxcbiAgICBwZXJzb25PdXRsaW5lOiByZWdpc3RlcigncGVyc29uLW91dGxpbmUnLCAweGVhNjcpLFxuICAgIHBlcnNvbkZpbGxlZDogcmVnaXN0ZXIoJ3BlcnNvbi1maWxsZWQnLCAweGVhNjcpLFxuICAgIGdpdEJyYW5jaDogcmVnaXN0ZXIoJ2dpdC1icmFuY2gnLCAweGVhNjgpLFxuICAgIGdpdEJyYW5jaENyZWF0ZTogcmVnaXN0ZXIoJ2dpdC1icmFuY2gtY3JlYXRlJywgMHhlYTY4KSxcbiAgICBnaXRCcmFuY2hEZWxldGU6IHJlZ2lzdGVyKCdnaXQtYnJhbmNoLWRlbGV0ZScsIDB4ZWE2OCksXG4gICAgc291cmNlQ29udHJvbDogcmVnaXN0ZXIoJ3NvdXJjZS1jb250cm9sJywgMHhlYTY4KSxcbiAgICBtaXJyb3I6IHJlZ2lzdGVyKCdtaXJyb3InLCAweGVhNjkpLFxuICAgIG1pcnJvclB1YmxpYzogcmVnaXN0ZXIoJ21pcnJvci1wdWJsaWMnLCAweGVhNjkpLFxuICAgIHN0YXI6IHJlZ2lzdGVyKCdzdGFyJywgMHhlYTZhKSxcbiAgICBzdGFyQWRkOiByZWdpc3Rlcignc3Rhci1hZGQnLCAweGVhNmEpLFxuICAgIHN0YXJEZWxldGU6IHJlZ2lzdGVyKCdzdGFyLWRlbGV0ZScsIDB4ZWE2YSksXG4gICAgc3RhckVtcHR5OiByZWdpc3Rlcignc3Rhci1lbXB0eScsIDB4ZWE2YSksXG4gICAgY29tbWVudDogcmVnaXN0ZXIoJ2NvbW1lbnQnLCAweGVhNmIpLFxuICAgIGNvbW1lbnRBZGQ6IHJlZ2lzdGVyKCdjb21tZW50LWFkZCcsIDB4ZWE2YiksXG4gICAgYWxlcnQ6IHJlZ2lzdGVyKCdhbGVydCcsIDB4ZWE2YyksXG4gICAgd2FybmluZzogcmVnaXN0ZXIoJ3dhcm5pbmcnLCAweGVhNmMpLFxuICAgIHNlYXJjaDogcmVnaXN0ZXIoJ3NlYXJjaCcsIDB4ZWE2ZCksXG4gICAgc2VhcmNoU2F2ZTogcmVnaXN0ZXIoJ3NlYXJjaC1zYXZlJywgMHhlYTZkKSxcbiAgICBsb2dPdXQ6IHJlZ2lzdGVyKCdsb2ctb3V0JywgMHhlYTZlKSxcbiAgICBzaWduT3V0OiByZWdpc3Rlcignc2lnbi1vdXQnLCAweGVhNmUpLFxuICAgIGxvZ0luOiByZWdpc3RlcignbG9nLWluJywgMHhlYTZmKSxcbiAgICBzaWduSW46IHJlZ2lzdGVyKCdzaWduLWluJywgMHhlYTZmKSxcbiAgICBleWU6IHJlZ2lzdGVyKCdleWUnLCAweGVhNzApLFxuICAgIGV5ZVVud2F0Y2g6IHJlZ2lzdGVyKCdleWUtdW53YXRjaCcsIDB4ZWE3MCksXG4gICAgZXllV2F0Y2g6IHJlZ2lzdGVyKCdleWUtd2F0Y2gnLCAweGVhNzApLFxuICAgIGNpcmNsZUZpbGxlZDogcmVnaXN0ZXIoJ2NpcmNsZS1maWxsZWQnLCAweGVhNzEpLFxuICAgIHByaW1pdGl2ZURvdDogcmVnaXN0ZXIoJ3ByaW1pdGl2ZS1kb3QnLCAweGVhNzEpLFxuICAgIGNsb3NlRGlydHk6IHJlZ2lzdGVyKCdjbG9zZS1kaXJ0eScsIDB4ZWE3MSksXG4gICAgZGVidWdCcmVha3BvaW50OiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludCcsIDB4ZWE3MSksXG4gICAgZGVidWdCcmVha3BvaW50RGlzYWJsZWQ6IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWRpc2FibGVkJywgMHhlYTcxKSxcbiAgICBkZWJ1Z0hpbnQ6IHJlZ2lzdGVyKCdkZWJ1Zy1oaW50JywgMHhlYTcxKSxcbiAgICB0ZXJtaW5hbERlY29yYXRpb25TdWNjZXNzOiByZWdpc3RlcigndGVybWluYWwtZGVjb3JhdGlvbi1zdWNjZXNzJywgMHhlYTcxKSxcbiAgICBwcmltaXRpdmVTcXVhcmU6IHJlZ2lzdGVyKCdwcmltaXRpdmUtc3F1YXJlJywgMHhlYTcyKSxcbiAgICBlZGl0OiByZWdpc3RlcignZWRpdCcsIDB4ZWE3MyksXG4gICAgcGVuY2lsOiByZWdpc3RlcigncGVuY2lsJywgMHhlYTczKSxcbiAgICBpbmZvOiByZWdpc3RlcignaW5mbycsIDB4ZWE3NCksXG4gICAgaXNzdWVPcGVuZWQ6IHJlZ2lzdGVyKCdpc3N1ZS1vcGVuZWQnLCAweGVhNzQpLFxuICAgIGdpc3RQcml2YXRlOiByZWdpc3RlcignZ2lzdC1wcml2YXRlJywgMHhlYTc1KSxcbiAgICBnaXRGb3JrUHJpdmF0ZTogcmVnaXN0ZXIoJ2dpdC1mb3JrLXByaXZhdGUnLCAweGVhNzUpLFxuICAgIGxvY2s6IHJlZ2lzdGVyKCdsb2NrJywgMHhlYTc1KSxcbiAgICBtaXJyb3JQcml2YXRlOiByZWdpc3RlcignbWlycm9yLXByaXZhdGUnLCAweGVhNzUpLFxuICAgIGNsb3NlOiByZWdpc3RlcignY2xvc2UnLCAweGVhNzYpLFxuICAgIHJlbW92ZUNsb3NlOiByZWdpc3RlcigncmVtb3ZlLWNsb3NlJywgMHhlYTc2KSxcbiAgICB4OiByZWdpc3RlcigneCcsIDB4ZWE3NiksXG4gICAgcmVwb1N5bmM6IHJlZ2lzdGVyKCdyZXBvLXN5bmMnLCAweGVhNzcpLFxuICAgIHN5bmM6IHJlZ2lzdGVyKCdzeW5jJywgMHhlYTc3KSxcbiAgICBjbG9uZTogcmVnaXN0ZXIoJ2Nsb25lJywgMHhlYTc4KSxcbiAgICBkZXNrdG9wRG93bmxvYWQ6IHJlZ2lzdGVyKCdkZXNrdG9wLWRvd25sb2FkJywgMHhlYTc4KSxcbiAgICBiZWFrZXI6IHJlZ2lzdGVyKCdiZWFrZXInLCAweGVhNzkpLFxuICAgIG1pY3Jvc2NvcGU6IHJlZ2lzdGVyKCdtaWNyb3Njb3BlJywgMHhlYTc5KSxcbiAgICB2bTogcmVnaXN0ZXIoJ3ZtJywgMHhlYTdhKSxcbiAgICBkZXZpY2VEZXNrdG9wOiByZWdpc3RlcignZGV2aWNlLWRlc2t0b3AnLCAweGVhN2EpLFxuICAgIGZpbGU6IHJlZ2lzdGVyKCdmaWxlJywgMHhlYTdiKSxcbiAgICBmaWxlVGV4dDogcmVnaXN0ZXIoJ2ZpbGUtdGV4dCcsIDB4ZWE3YiksXG4gICAgbW9yZTogcmVnaXN0ZXIoJ21vcmUnLCAweGVhN2MpLFxuICAgIGVsbGlwc2lzOiByZWdpc3RlcignZWxsaXBzaXMnLCAweGVhN2MpLFxuICAgIGtlYmFiSG9yaXpvbnRhbDogcmVnaXN0ZXIoJ2tlYmFiLWhvcml6b250YWwnLCAweGVhN2MpLFxuICAgIG1haWxSZXBseTogcmVnaXN0ZXIoJ21haWwtcmVwbHknLCAweGVhN2QpLFxuICAgIHJlcGx5OiByZWdpc3RlcigncmVwbHknLCAweGVhN2QpLFxuICAgIG9yZ2FuaXphdGlvbjogcmVnaXN0ZXIoJ29yZ2FuaXphdGlvbicsIDB4ZWE3ZSksXG4gICAgb3JnYW5pemF0aW9uRmlsbGVkOiByZWdpc3Rlcignb3JnYW5pemF0aW9uLWZpbGxlZCcsIDB4ZWE3ZSksXG4gICAgb3JnYW5pemF0aW9uT3V0bGluZTogcmVnaXN0ZXIoJ29yZ2FuaXphdGlvbi1vdXRsaW5lJywgMHhlYTdlKSxcbiAgICBuZXdGaWxlOiByZWdpc3RlcignbmV3LWZpbGUnLCAweGVhN2YpLFxuICAgIGZpbGVBZGQ6IHJlZ2lzdGVyKCdmaWxlLWFkZCcsIDB4ZWE3ZiksXG4gICAgbmV3Rm9sZGVyOiByZWdpc3RlcignbmV3LWZvbGRlcicsIDB4ZWE4MCksXG4gICAgZmlsZURpcmVjdG9yeUNyZWF0ZTogcmVnaXN0ZXIoJ2ZpbGUtZGlyZWN0b3J5LWNyZWF0ZScsIDB4ZWE4MCksXG4gICAgdHJhc2g6IHJlZ2lzdGVyKCd0cmFzaCcsIDB4ZWE4MSksXG4gICAgdHJhc2hjYW46IHJlZ2lzdGVyKCd0cmFzaGNhbicsIDB4ZWE4MSksXG4gICAgaGlzdG9yeTogcmVnaXN0ZXIoJ2hpc3RvcnknLCAweGVhODIpLFxuICAgIGNsb2NrOiByZWdpc3RlcignY2xvY2snLCAweGVhODIpLFxuICAgIGZvbGRlcjogcmVnaXN0ZXIoJ2ZvbGRlcicsIDB4ZWE4MyksXG4gICAgZmlsZURpcmVjdG9yeTogcmVnaXN0ZXIoJ2ZpbGUtZGlyZWN0b3J5JywgMHhlYTgzKSxcbiAgICBzeW1ib2xGb2xkZXI6IHJlZ2lzdGVyKCdzeW1ib2wtZm9sZGVyJywgMHhlYTgzKSxcbiAgICBsb2dvR2l0aHViOiByZWdpc3RlcignbG9nby1naXRodWInLCAweGVhODQpLFxuICAgIG1hcmtHaXRodWI6IHJlZ2lzdGVyKCdtYXJrLWdpdGh1YicsIDB4ZWE4NCksXG4gICAgZ2l0aHViOiByZWdpc3RlcignZ2l0aHViJywgMHhlYTg0KSxcbiAgICB0ZXJtaW5hbDogcmVnaXN0ZXIoJ3Rlcm1pbmFsJywgMHhlYTg1KSxcbiAgICBjb25zb2xlOiByZWdpc3RlcignY29uc29sZScsIDB4ZWE4NSksXG4gICAgcmVwbDogcmVnaXN0ZXIoJ3JlcGwnLCAweGVhODUpLFxuICAgIHphcDogcmVnaXN0ZXIoJ3phcCcsIDB4ZWE4NiksXG4gICAgc3ltYm9sRXZlbnQ6IHJlZ2lzdGVyKCdzeW1ib2wtZXZlbnQnLCAweGVhODYpLFxuICAgIGVycm9yOiByZWdpc3RlcignZXJyb3InLCAweGVhODcpLFxuICAgIHN0b3A6IHJlZ2lzdGVyKCdzdG9wJywgMHhlYTg3KSxcbiAgICB2YXJpYWJsZTogcmVnaXN0ZXIoJ3ZhcmlhYmxlJywgMHhlYTg4KSxcbiAgICBzeW1ib2xWYXJpYWJsZTogcmVnaXN0ZXIoJ3N5bWJvbC12YXJpYWJsZScsIDB4ZWE4OCksXG4gICAgYXJyYXk6IHJlZ2lzdGVyKCdhcnJheScsIDB4ZWE4YSksXG4gICAgc3ltYm9sQXJyYXk6IHJlZ2lzdGVyKCdzeW1ib2wtYXJyYXknLCAweGVhOGEpLFxuICAgIHN5bWJvbE1vZHVsZTogcmVnaXN0ZXIoJ3N5bWJvbC1tb2R1bGUnLCAweGVhOGIpLFxuICAgIHN5bWJvbFBhY2thZ2U6IHJlZ2lzdGVyKCdzeW1ib2wtcGFja2FnZScsIDB4ZWE4YiksXG4gICAgc3ltYm9sTmFtZXNwYWNlOiByZWdpc3Rlcignc3ltYm9sLW5hbWVzcGFjZScsIDB4ZWE4YiksXG4gICAgc3ltYm9sT2JqZWN0OiByZWdpc3Rlcignc3ltYm9sLW9iamVjdCcsIDB4ZWE4YiksXG4gICAgc3ltYm9sTWV0aG9kOiByZWdpc3Rlcignc3ltYm9sLW1ldGhvZCcsIDB4ZWE4YyksXG4gICAgc3ltYm9sRnVuY3Rpb246IHJlZ2lzdGVyKCdzeW1ib2wtZnVuY3Rpb24nLCAweGVhOGMpLFxuICAgIHN5bWJvbENvbnN0cnVjdG9yOiByZWdpc3Rlcignc3ltYm9sLWNvbnN0cnVjdG9yJywgMHhlYThjKSxcbiAgICBzeW1ib2xCb29sZWFuOiByZWdpc3Rlcignc3ltYm9sLWJvb2xlYW4nLCAweGVhOGYpLFxuICAgIHN5bWJvbE51bGw6IHJlZ2lzdGVyKCdzeW1ib2wtbnVsbCcsIDB4ZWE4ZiksXG4gICAgc3ltYm9sTnVtZXJpYzogcmVnaXN0ZXIoJ3N5bWJvbC1udW1lcmljJywgMHhlYTkwKSxcbiAgICBzeW1ib2xOdW1iZXI6IHJlZ2lzdGVyKCdzeW1ib2wtbnVtYmVyJywgMHhlYTkwKSxcbiAgICBzeW1ib2xTdHJ1Y3R1cmU6IHJlZ2lzdGVyKCdzeW1ib2wtc3RydWN0dXJlJywgMHhlYTkxKSxcbiAgICBzeW1ib2xTdHJ1Y3Q6IHJlZ2lzdGVyKCdzeW1ib2wtc3RydWN0JywgMHhlYTkxKSxcbiAgICBzeW1ib2xQYXJhbWV0ZXI6IHJlZ2lzdGVyKCdzeW1ib2wtcGFyYW1ldGVyJywgMHhlYTkyKSxcbiAgICBzeW1ib2xUeXBlUGFyYW1ldGVyOiByZWdpc3Rlcignc3ltYm9sLXR5cGUtcGFyYW1ldGVyJywgMHhlYTkyKSxcbiAgICBzeW1ib2xLZXk6IHJlZ2lzdGVyKCdzeW1ib2wta2V5JywgMHhlYTkzKSxcbiAgICBzeW1ib2xUZXh0OiByZWdpc3Rlcignc3ltYm9sLXRleHQnLCAweGVhOTMpLFxuICAgIHN5bWJvbFJlZmVyZW5jZTogcmVnaXN0ZXIoJ3N5bWJvbC1yZWZlcmVuY2UnLCAweGVhOTQpLFxuICAgIGdvVG9GaWxlOiByZWdpc3RlcignZ28tdG8tZmlsZScsIDB4ZWE5NCksXG4gICAgc3ltYm9sRW51bTogcmVnaXN0ZXIoJ3N5bWJvbC1lbnVtJywgMHhlYTk1KSxcbiAgICBzeW1ib2xWYWx1ZTogcmVnaXN0ZXIoJ3N5bWJvbC12YWx1ZScsIDB4ZWE5NSksXG4gICAgc3ltYm9sUnVsZXI6IHJlZ2lzdGVyKCdzeW1ib2wtcnVsZXInLCAweGVhOTYpLFxuICAgIHN5bWJvbFVuaXQ6IHJlZ2lzdGVyKCdzeW1ib2wtdW5pdCcsIDB4ZWE5NiksXG4gICAgYWN0aXZhdGVCcmVha3BvaW50czogcmVnaXN0ZXIoJ2FjdGl2YXRlLWJyZWFrcG9pbnRzJywgMHhlYTk3KSxcbiAgICBhcmNoaXZlOiByZWdpc3RlcignYXJjaGl2ZScsIDB4ZWE5OCksXG4gICAgYXJyb3dCb3RoOiByZWdpc3RlcignYXJyb3ctYm90aCcsIDB4ZWE5OSksXG4gICAgYXJyb3dEb3duOiByZWdpc3RlcignYXJyb3ctZG93bicsIDB4ZWE5YSksXG4gICAgYXJyb3dMZWZ0OiByZWdpc3RlcignYXJyb3ctbGVmdCcsIDB4ZWE5YiksXG4gICAgYXJyb3dSaWdodDogcmVnaXN0ZXIoJ2Fycm93LXJpZ2h0JywgMHhlYTljKSxcbiAgICBhcnJvd1NtYWxsRG93bjogcmVnaXN0ZXIoJ2Fycm93LXNtYWxsLWRvd24nLCAweGVhOWQpLFxuICAgIGFycm93U21hbGxMZWZ0OiByZWdpc3RlcignYXJyb3ctc21hbGwtbGVmdCcsIDB4ZWE5ZSksXG4gICAgYXJyb3dTbWFsbFJpZ2h0OiByZWdpc3RlcignYXJyb3ctc21hbGwtcmlnaHQnLCAweGVhOWYpLFxuICAgIGFycm93U21hbGxVcDogcmVnaXN0ZXIoJ2Fycm93LXNtYWxsLXVwJywgMHhlYWEwKSxcbiAgICBhcnJvd1VwOiByZWdpc3RlcignYXJyb3ctdXAnLCAweGVhYTEpLFxuICAgIGJlbGw6IHJlZ2lzdGVyKCdiZWxsJywgMHhlYWEyKSxcbiAgICBib2xkOiByZWdpc3RlcignYm9sZCcsIDB4ZWFhMyksXG4gICAgYm9vazogcmVnaXN0ZXIoJ2Jvb2snLCAweGVhYTQpLFxuICAgIGJvb2ttYXJrOiByZWdpc3RlcignYm9va21hcmsnLCAweGVhYTUpLFxuICAgIGRlYnVnQnJlYWtwb2ludENvbmRpdGlvbmFsVW52ZXJpZmllZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtY29uZGl0aW9uYWwtdW52ZXJpZmllZCcsIDB4ZWFhNiksXG4gICAgZGVidWdCcmVha3BvaW50Q29uZGl0aW9uYWw6IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWNvbmRpdGlvbmFsJywgMHhlYWE3KSxcbiAgICBkZWJ1Z0JyZWFrcG9pbnRDb25kaXRpb25hbERpc2FibGVkOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1jb25kaXRpb25hbC1kaXNhYmxlZCcsIDB4ZWFhNyksXG4gICAgZGVidWdCcmVha3BvaW50RGF0YVVudmVyaWZpZWQ6IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWRhdGEtdW52ZXJpZmllZCcsIDB4ZWFhOCksXG4gICAgZGVidWdCcmVha3BvaW50RGF0YTogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtZGF0YScsIDB4ZWFhOSksXG4gICAgZGVidWdCcmVha3BvaW50RGF0YURpc2FibGVkOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1kYXRhLWRpc2FibGVkJywgMHhlYWE5KSxcbiAgICBkZWJ1Z0JyZWFrcG9pbnRMb2dVbnZlcmlmaWVkOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1sb2ctdW52ZXJpZmllZCcsIDB4ZWFhYSksXG4gICAgZGVidWdCcmVha3BvaW50TG9nOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1sb2cnLCAweGVhYWIpLFxuICAgIGRlYnVnQnJlYWtwb2ludExvZ0Rpc2FibGVkOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1sb2ctZGlzYWJsZWQnLCAweGVhYWIpLFxuICAgIGJyaWVmY2FzZTogcmVnaXN0ZXIoJ2JyaWVmY2FzZScsIDB4ZWFhYyksXG4gICAgYnJvYWRjYXN0OiByZWdpc3RlcignYnJvYWRjYXN0JywgMHhlYWFkKSxcbiAgICBicm93c2VyOiByZWdpc3RlcignYnJvd3NlcicsIDB4ZWFhZSksXG4gICAgYnVnOiByZWdpc3RlcignYnVnJywgMHhlYWFmKSxcbiAgICBjYWxlbmRhcjogcmVnaXN0ZXIoJ2NhbGVuZGFyJywgMHhlYWIwKSxcbiAgICBjYXNlU2Vuc2l0aXZlOiByZWdpc3RlcignY2FzZS1zZW5zaXRpdmUnLCAweGVhYjEpLFxuICAgIGNoZWNrOiByZWdpc3RlcignY2hlY2snLCAweGVhYjIpLFxuICAgIGNoZWNrbGlzdDogcmVnaXN0ZXIoJ2NoZWNrbGlzdCcsIDB4ZWFiMyksXG4gICAgY2hldnJvbkRvd246IHJlZ2lzdGVyKCdjaGV2cm9uLWRvd24nLCAweGVhYjQpLFxuICAgIGNoZXZyb25MZWZ0OiByZWdpc3RlcignY2hldnJvbi1sZWZ0JywgMHhlYWI1KSxcbiAgICBjaGV2cm9uUmlnaHQ6IHJlZ2lzdGVyKCdjaGV2cm9uLXJpZ2h0JywgMHhlYWI2KSxcbiAgICBjaGV2cm9uVXA6IHJlZ2lzdGVyKCdjaGV2cm9uLXVwJywgMHhlYWI3KSxcbiAgICBjaHJvbWVDbG9zZTogcmVnaXN0ZXIoJ2Nocm9tZS1jbG9zZScsIDB4ZWFiOCksXG4gICAgY2hyb21lTWF4aW1pemU6IHJlZ2lzdGVyKCdjaHJvbWUtbWF4aW1pemUnLCAweGVhYjkpLFxuICAgIGNocm9tZU1pbmltaXplOiByZWdpc3RlcignY2hyb21lLW1pbmltaXplJywgMHhlYWJhKSxcbiAgICBjaHJvbWVSZXN0b3JlOiByZWdpc3RlcignY2hyb21lLXJlc3RvcmUnLCAweGVhYmIpLFxuICAgIGNpcmNsZU91dGxpbmU6IHJlZ2lzdGVyKCdjaXJjbGUtb3V0bGluZScsIDB4ZWFiYyksXG4gICAgY2lyY2xlOiByZWdpc3RlcignY2lyY2xlJywgMHhlYWJjKSxcbiAgICBkZWJ1Z0JyZWFrcG9pbnRVbnZlcmlmaWVkOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC11bnZlcmlmaWVkJywgMHhlYWJjKSxcbiAgICB0ZXJtaW5hbERlY29yYXRpb25JbmNvbXBsZXRlOiByZWdpc3RlcigndGVybWluYWwtZGVjb3JhdGlvbi1pbmNvbXBsZXRlJywgMHhlYWJjKSxcbiAgICBjaXJjbGVTbGFzaDogcmVnaXN0ZXIoJ2NpcmNsZS1zbGFzaCcsIDB4ZWFiZCksXG4gICAgY2lyY3VpdEJvYXJkOiByZWdpc3RlcignY2lyY3VpdC1ib2FyZCcsIDB4ZWFiZSksXG4gICAgY2xlYXJBbGw6IHJlZ2lzdGVyKCdjbGVhci1hbGwnLCAweGVhYmYpLFxuICAgIGNsaXBweTogcmVnaXN0ZXIoJ2NsaXBweScsIDB4ZWFjMCksXG4gICAgY2xvc2VBbGw6IHJlZ2lzdGVyKCdjbG9zZS1hbGwnLCAweGVhYzEpLFxuICAgIGNsb3VkRG93bmxvYWQ6IHJlZ2lzdGVyKCdjbG91ZC1kb3dubG9hZCcsIDB4ZWFjMiksXG4gICAgY2xvdWRVcGxvYWQ6IHJlZ2lzdGVyKCdjbG91ZC11cGxvYWQnLCAweGVhYzMpLFxuICAgIGNvZGU6IHJlZ2lzdGVyKCdjb2RlJywgMHhlYWM0KSxcbiAgICBjb2xsYXBzZUFsbDogcmVnaXN0ZXIoJ2NvbGxhcHNlLWFsbCcsIDB4ZWFjNSksXG4gICAgY29sb3JNb2RlOiByZWdpc3RlcignY29sb3ItbW9kZScsIDB4ZWFjNiksXG4gICAgY29tbWVudERpc2N1c3Npb246IHJlZ2lzdGVyKCdjb21tZW50LWRpc2N1c3Npb24nLCAweGVhYzcpLFxuICAgIGNyZWRpdENhcmQ6IHJlZ2lzdGVyKCdjcmVkaXQtY2FyZCcsIDB4ZWFjOSksXG4gICAgZGFzaDogcmVnaXN0ZXIoJ2Rhc2gnLCAweGVhY2MpLFxuICAgIGRhc2hib2FyZDogcmVnaXN0ZXIoJ2Rhc2hib2FyZCcsIDB4ZWFjZCksXG4gICAgZGF0YWJhc2U6IHJlZ2lzdGVyKCdkYXRhYmFzZScsIDB4ZWFjZSksXG4gICAgZGVidWdDb250aW51ZTogcmVnaXN0ZXIoJ2RlYnVnLWNvbnRpbnVlJywgMHhlYWNmKSxcbiAgICBkZWJ1Z0Rpc2Nvbm5lY3Q6IHJlZ2lzdGVyKCdkZWJ1Zy1kaXNjb25uZWN0JywgMHhlYWQwKSxcbiAgICBkZWJ1Z1BhdXNlOiByZWdpc3RlcignZGVidWctcGF1c2UnLCAweGVhZDEpLFxuICAgIGRlYnVnUmVzdGFydDogcmVnaXN0ZXIoJ2RlYnVnLXJlc3RhcnQnLCAweGVhZDIpLFxuICAgIGRlYnVnU3RhcnQ6IHJlZ2lzdGVyKCdkZWJ1Zy1zdGFydCcsIDB4ZWFkMyksXG4gICAgZGVidWdTdGVwSW50bzogcmVnaXN0ZXIoJ2RlYnVnLXN0ZXAtaW50bycsIDB4ZWFkNCksXG4gICAgZGVidWdTdGVwT3V0OiByZWdpc3RlcignZGVidWctc3RlcC1vdXQnLCAweGVhZDUpLFxuICAgIGRlYnVnU3RlcE92ZXI6IHJlZ2lzdGVyKCdkZWJ1Zy1zdGVwLW92ZXInLCAweGVhZDYpLFxuICAgIGRlYnVnU3RvcDogcmVnaXN0ZXIoJ2RlYnVnLXN0b3AnLCAweGVhZDcpLFxuICAgIGRlYnVnOiByZWdpc3RlcignZGVidWcnLCAweGVhZDgpLFxuICAgIGRldmljZUNhbWVyYVZpZGVvOiByZWdpc3RlcignZGV2aWNlLWNhbWVyYS12aWRlbycsIDB4ZWFkOSksXG4gICAgZGV2aWNlQ2FtZXJhOiByZWdpc3RlcignZGV2aWNlLWNhbWVyYScsIDB4ZWFkYSksXG4gICAgZGV2aWNlTW9iaWxlOiByZWdpc3RlcignZGV2aWNlLW1vYmlsZScsIDB4ZWFkYiksXG4gICAgZGlmZkFkZGVkOiByZWdpc3RlcignZGlmZi1hZGRlZCcsIDB4ZWFkYyksXG4gICAgZGlmZklnbm9yZWQ6IHJlZ2lzdGVyKCdkaWZmLWlnbm9yZWQnLCAweGVhZGQpLFxuICAgIGRpZmZNb2RpZmllZDogcmVnaXN0ZXIoJ2RpZmYtbW9kaWZpZWQnLCAweGVhZGUpLFxuICAgIGRpZmZSZW1vdmVkOiByZWdpc3RlcignZGlmZi1yZW1vdmVkJywgMHhlYWRmKSxcbiAgICBkaWZmUmVuYW1lZDogcmVnaXN0ZXIoJ2RpZmYtcmVuYW1lZCcsIDB4ZWFlMCksXG4gICAgZGlmZjogcmVnaXN0ZXIoJ2RpZmYnLCAweGVhZTEpLFxuICAgIGRpZmZTaWRlYnlzaWRlOiByZWdpc3RlcignZGlmZi1zaWRlYnlzaWRlJywgMHhlYWUxKSxcbiAgICBkaXNjYXJkOiByZWdpc3RlcignZGlzY2FyZCcsIDB4ZWFlMiksXG4gICAgZWRpdG9yTGF5b3V0OiByZWdpc3RlcignZWRpdG9yLWxheW91dCcsIDB4ZWFlMyksXG4gICAgZW1wdHlXaW5kb3c6IHJlZ2lzdGVyKCdlbXB0eS13aW5kb3cnLCAweGVhZTQpLFxuICAgIGV4Y2x1ZGU6IHJlZ2lzdGVyKCdleGNsdWRlJywgMHhlYWU1KSxcbiAgICBleHRlbnNpb25zOiByZWdpc3RlcignZXh0ZW5zaW9ucycsIDB4ZWFlNiksXG4gICAgZXllQ2xvc2VkOiByZWdpc3RlcignZXllLWNsb3NlZCcsIDB4ZWFlNyksXG4gICAgZmlsZUJpbmFyeTogcmVnaXN0ZXIoJ2ZpbGUtYmluYXJ5JywgMHhlYWU4KSxcbiAgICBmaWxlQ29kZTogcmVnaXN0ZXIoJ2ZpbGUtY29kZScsIDB4ZWFlOSksXG4gICAgZmlsZU1lZGlhOiByZWdpc3RlcignZmlsZS1tZWRpYScsIDB4ZWFlYSksXG4gICAgZmlsZVBkZjogcmVnaXN0ZXIoJ2ZpbGUtcGRmJywgMHhlYWViKSxcbiAgICBmaWxlU3VibW9kdWxlOiByZWdpc3RlcignZmlsZS1zdWJtb2R1bGUnLCAweGVhZWMpLFxuICAgIGZpbGVTeW1saW5rRGlyZWN0b3J5OiByZWdpc3RlcignZmlsZS1zeW1saW5rLWRpcmVjdG9yeScsIDB4ZWFlZCksXG4gICAgZmlsZVN5bWxpbmtGaWxlOiByZWdpc3RlcignZmlsZS1zeW1saW5rLWZpbGUnLCAweGVhZWUpLFxuICAgIGZpbGVaaXA6IHJlZ2lzdGVyKCdmaWxlLXppcCcsIDB4ZWFlZiksXG4gICAgZmlsZXM6IHJlZ2lzdGVyKCdmaWxlcycsIDB4ZWFmMCksXG4gICAgZmlsdGVyOiByZWdpc3RlcignZmlsdGVyJywgMHhlYWYxKSxcbiAgICBmbGFtZTogcmVnaXN0ZXIoJ2ZsYW1lJywgMHhlYWYyKSxcbiAgICBmb2xkRG93bjogcmVnaXN0ZXIoJ2ZvbGQtZG93bicsIDB4ZWFmMyksXG4gICAgZm9sZFVwOiByZWdpc3RlcignZm9sZC11cCcsIDB4ZWFmNCksXG4gICAgZm9sZDogcmVnaXN0ZXIoJ2ZvbGQnLCAweGVhZjUpLFxuICAgIGZvbGRlckFjdGl2ZTogcmVnaXN0ZXIoJ2ZvbGRlci1hY3RpdmUnLCAweGVhZjYpLFxuICAgIGZvbGRlck9wZW5lZDogcmVnaXN0ZXIoJ2ZvbGRlci1vcGVuZWQnLCAweGVhZjcpLFxuICAgIGdlYXI6IHJlZ2lzdGVyKCdnZWFyJywgMHhlYWY4KSxcbiAgICBnaWZ0OiByZWdpc3RlcignZ2lmdCcsIDB4ZWFmOSksXG4gICAgZ2lzdFNlY3JldDogcmVnaXN0ZXIoJ2dpc3Qtc2VjcmV0JywgMHhlYWZhKSxcbiAgICBnaXN0OiByZWdpc3RlcignZ2lzdCcsIDB4ZWFmYiksXG4gICAgZ2l0Q29tbWl0OiByZWdpc3RlcignZ2l0LWNvbW1pdCcsIDB4ZWFmYyksXG4gICAgZ2l0Q29tcGFyZTogcmVnaXN0ZXIoJ2dpdC1jb21wYXJlJywgMHhlYWZkKSxcbiAgICBjb21wYXJlQ2hhbmdlczogcmVnaXN0ZXIoJ2NvbXBhcmUtY2hhbmdlcycsIDB4ZWFmZCksXG4gICAgZ2l0TWVyZ2U6IHJlZ2lzdGVyKCdnaXQtbWVyZ2UnLCAweGVhZmUpLFxuICAgIGdpdGh1YkFjdGlvbjogcmVnaXN0ZXIoJ2dpdGh1Yi1hY3Rpb24nLCAweGVhZmYpLFxuICAgIGdpdGh1YkFsdDogcmVnaXN0ZXIoJ2dpdGh1Yi1hbHQnLCAweGViMDApLFxuICAgIGdsb2JlOiByZWdpc3RlcignZ2xvYmUnLCAweGViMDEpLFxuICAgIGdyYWJiZXI6IHJlZ2lzdGVyKCdncmFiYmVyJywgMHhlYjAyKSxcbiAgICBncmFwaDogcmVnaXN0ZXIoJ2dyYXBoJywgMHhlYjAzKSxcbiAgICBncmlwcGVyOiByZWdpc3RlcignZ3JpcHBlcicsIDB4ZWIwNCksXG4gICAgaGVhcnQ6IHJlZ2lzdGVyKCdoZWFydCcsIDB4ZWIwNSksXG4gICAgaG9tZTogcmVnaXN0ZXIoJ2hvbWUnLCAweGViMDYpLFxuICAgIGhvcml6b250YWxSdWxlOiByZWdpc3RlcignaG9yaXpvbnRhbC1ydWxlJywgMHhlYjA3KSxcbiAgICBodWJvdDogcmVnaXN0ZXIoJ2h1Ym90JywgMHhlYjA4KSxcbiAgICBpbmJveDogcmVnaXN0ZXIoJ2luYm94JywgMHhlYjA5KSxcbiAgICBpc3N1ZVJlb3BlbmVkOiByZWdpc3RlcignaXNzdWUtcmVvcGVuZWQnLCAweGViMGIpLFxuICAgIGlzc3VlczogcmVnaXN0ZXIoJ2lzc3VlcycsIDB4ZWIwYyksXG4gICAgaXRhbGljOiByZWdpc3RlcignaXRhbGljJywgMHhlYjBkKSxcbiAgICBqZXJzZXk6IHJlZ2lzdGVyKCdqZXJzZXknLCAweGViMGUpLFxuICAgIGpzb246IHJlZ2lzdGVyKCdqc29uJywgMHhlYjBmKSxcbiAgICBrZWJhYlZlcnRpY2FsOiByZWdpc3Rlcigna2ViYWItdmVydGljYWwnLCAweGViMTApLFxuICAgIGtleTogcmVnaXN0ZXIoJ2tleScsIDB4ZWIxMSksXG4gICAgbGF3OiByZWdpc3RlcignbGF3JywgMHhlYjEyKSxcbiAgICBsaWdodGJ1bGJBdXRvZml4OiByZWdpc3RlcignbGlnaHRidWxiLWF1dG9maXgnLCAweGViMTMpLFxuICAgIGxpbmtFeHRlcm5hbDogcmVnaXN0ZXIoJ2xpbmstZXh0ZXJuYWwnLCAweGViMTQpLFxuICAgIGxpbms6IHJlZ2lzdGVyKCdsaW5rJywgMHhlYjE1KSxcbiAgICBsaXN0T3JkZXJlZDogcmVnaXN0ZXIoJ2xpc3Qtb3JkZXJlZCcsIDB4ZWIxNiksXG4gICAgbGlzdFVub3JkZXJlZDogcmVnaXN0ZXIoJ2xpc3QtdW5vcmRlcmVkJywgMHhlYjE3KSxcbiAgICBsaXZlU2hhcmU6IHJlZ2lzdGVyKCdsaXZlLXNoYXJlJywgMHhlYjE4KSxcbiAgICBsb2FkaW5nOiByZWdpc3RlcignbG9hZGluZycsIDB4ZWIxOSksXG4gICAgbG9jYXRpb246IHJlZ2lzdGVyKCdsb2NhdGlvbicsIDB4ZWIxYSksXG4gICAgbWFpbFJlYWQ6IHJlZ2lzdGVyKCdtYWlsLXJlYWQnLCAweGViMWIpLFxuICAgIG1haWw6IHJlZ2lzdGVyKCdtYWlsJywgMHhlYjFjKSxcbiAgICBtYXJrZG93bjogcmVnaXN0ZXIoJ21hcmtkb3duJywgMHhlYjFkKSxcbiAgICBtZWdhcGhvbmU6IHJlZ2lzdGVyKCdtZWdhcGhvbmUnLCAweGViMWUpLFxuICAgIG1lbnRpb246IHJlZ2lzdGVyKCdtZW50aW9uJywgMHhlYjFmKSxcbiAgICBtaWxlc3RvbmU6IHJlZ2lzdGVyKCdtaWxlc3RvbmUnLCAweGViMjApLFxuICAgIGdpdFB1bGxSZXF1ZXN0TWlsZXN0b25lOiByZWdpc3RlcignZ2l0LXB1bGwtcmVxdWVzdC1taWxlc3RvbmUnLCAweGViMjApLFxuICAgIG1vcnRhckJvYXJkOiByZWdpc3RlcignbW9ydGFyLWJvYXJkJywgMHhlYjIxKSxcbiAgICBtb3ZlOiByZWdpc3RlcignbW92ZScsIDB4ZWIyMiksXG4gICAgbXVsdGlwbGVXaW5kb3dzOiByZWdpc3RlcignbXVsdGlwbGUtd2luZG93cycsIDB4ZWIyMyksXG4gICAgbXV0ZTogcmVnaXN0ZXIoJ211dGUnLCAweGViMjQpLFxuICAgIG5vTmV3bGluZTogcmVnaXN0ZXIoJ25vLW5ld2xpbmUnLCAweGViMjUpLFxuICAgIG5vdGU6IHJlZ2lzdGVyKCdub3RlJywgMHhlYjI2KSxcbiAgICBvY3RvZmFjZTogcmVnaXN0ZXIoJ29jdG9mYWNlJywgMHhlYjI3KSxcbiAgICBvcGVuUHJldmlldzogcmVnaXN0ZXIoJ29wZW4tcHJldmlldycsIDB4ZWIyOCksXG4gICAgcGFja2FnZTogcmVnaXN0ZXIoJ3BhY2thZ2UnLCAweGViMjkpLFxuICAgIHBhaW50Y2FuOiByZWdpc3RlcigncGFpbnRjYW4nLCAweGViMmEpLFxuICAgIHBpbjogcmVnaXN0ZXIoJ3BpbicsIDB4ZWIyYiksXG4gICAgcGxheTogcmVnaXN0ZXIoJ3BsYXknLCAweGViMmMpLFxuICAgIHJ1bjogcmVnaXN0ZXIoJ3J1bicsIDB4ZWIyYyksXG4gICAgcGx1ZzogcmVnaXN0ZXIoJ3BsdWcnLCAweGViMmQpLFxuICAgIHByZXNlcnZlQ2FzZTogcmVnaXN0ZXIoJ3ByZXNlcnZlLWNhc2UnLCAweGViMmUpLFxuICAgIHByZXZpZXc6IHJlZ2lzdGVyKCdwcmV2aWV3JywgMHhlYjJmKSxcbiAgICBwcm9qZWN0OiByZWdpc3RlcigncHJvamVjdCcsIDB4ZWIzMCksXG4gICAgcHVsc2U6IHJlZ2lzdGVyKCdwdWxzZScsIDB4ZWIzMSksXG4gICAgcXVlc3Rpb246IHJlZ2lzdGVyKCdxdWVzdGlvbicsIDB4ZWIzMiksXG4gICAgcXVvdGU6IHJlZ2lzdGVyKCdxdW90ZScsIDB4ZWIzMyksXG4gICAgcmFkaW9Ub3dlcjogcmVnaXN0ZXIoJ3JhZGlvLXRvd2VyJywgMHhlYjM0KSxcbiAgICByZWFjdGlvbnM6IHJlZ2lzdGVyKCdyZWFjdGlvbnMnLCAweGViMzUpLFxuICAgIHJlZmVyZW5jZXM6IHJlZ2lzdGVyKCdyZWZlcmVuY2VzJywgMHhlYjM2KSxcbiAgICByZWZyZXNoOiByZWdpc3RlcigncmVmcmVzaCcsIDB4ZWIzNyksXG4gICAgcmVnZXg6IHJlZ2lzdGVyKCdyZWdleCcsIDB4ZWIzOCksXG4gICAgcmVtb3RlRXhwbG9yZXI6IHJlZ2lzdGVyKCdyZW1vdGUtZXhwbG9yZXInLCAweGViMzkpLFxuICAgIHJlbW90ZTogcmVnaXN0ZXIoJ3JlbW90ZScsIDB4ZWIzYSksXG4gICAgcmVtb3ZlOiByZWdpc3RlcigncmVtb3ZlJywgMHhlYjNiKSxcbiAgICByZXBsYWNlQWxsOiByZWdpc3RlcigncmVwbGFjZS1hbGwnLCAweGViM2MpLFxuICAgIHJlcGxhY2U6IHJlZ2lzdGVyKCdyZXBsYWNlJywgMHhlYjNkKSxcbiAgICByZXBvQ2xvbmU6IHJlZ2lzdGVyKCdyZXBvLWNsb25lJywgMHhlYjNlKSxcbiAgICByZXBvRm9yY2VQdXNoOiByZWdpc3RlcigncmVwby1mb3JjZS1wdXNoJywgMHhlYjNmKSxcbiAgICByZXBvUHVsbDogcmVnaXN0ZXIoJ3JlcG8tcHVsbCcsIDB4ZWI0MCksXG4gICAgcmVwb1B1c2g6IHJlZ2lzdGVyKCdyZXBvLXB1c2gnLCAweGViNDEpLFxuICAgIHJlcG9ydDogcmVnaXN0ZXIoJ3JlcG9ydCcsIDB4ZWI0MiksXG4gICAgcmVxdWVzdENoYW5nZXM6IHJlZ2lzdGVyKCdyZXF1ZXN0LWNoYW5nZXMnLCAweGViNDMpLFxuICAgIHJvY2tldDogcmVnaXN0ZXIoJ3JvY2tldCcsIDB4ZWI0NCksXG4gICAgcm9vdEZvbGRlck9wZW5lZDogcmVnaXN0ZXIoJ3Jvb3QtZm9sZGVyLW9wZW5lZCcsIDB4ZWI0NSksXG4gICAgcm9vdEZvbGRlcjogcmVnaXN0ZXIoJ3Jvb3QtZm9sZGVyJywgMHhlYjQ2KSxcbiAgICByc3M6IHJlZ2lzdGVyKCdyc3MnLCAweGViNDcpLFxuICAgIHJ1Ynk6IHJlZ2lzdGVyKCdydWJ5JywgMHhlYjQ4KSxcbiAgICBzYXZlQWxsOiByZWdpc3Rlcignc2F2ZS1hbGwnLCAweGViNDkpLFxuICAgIHNhdmVBczogcmVnaXN0ZXIoJ3NhdmUtYXMnLCAweGViNGEpLFxuICAgIHNhdmU6IHJlZ2lzdGVyKCdzYXZlJywgMHhlYjRiKSxcbiAgICBzY3JlZW5GdWxsOiByZWdpc3Rlcignc2NyZWVuLWZ1bGwnLCAweGViNGMpLFxuICAgIHNjcmVlbk5vcm1hbDogcmVnaXN0ZXIoJ3NjcmVlbi1ub3JtYWwnLCAweGViNGQpLFxuICAgIHNlYXJjaFN0b3A6IHJlZ2lzdGVyKCdzZWFyY2gtc3RvcCcsIDB4ZWI0ZSksXG4gICAgc2VydmVyOiByZWdpc3Rlcignc2VydmVyJywgMHhlYjUwKSxcbiAgICBzZXR0aW5nc0dlYXI6IHJlZ2lzdGVyKCdzZXR0aW5ncy1nZWFyJywgMHhlYjUxKSxcbiAgICBzZXR0aW5nczogcmVnaXN0ZXIoJ3NldHRpbmdzJywgMHhlYjUyKSxcbiAgICBzaGllbGQ6IHJlZ2lzdGVyKCdzaGllbGQnLCAweGViNTMpLFxuICAgIHNtaWxleTogcmVnaXN0ZXIoJ3NtaWxleScsIDB4ZWI1NCksXG4gICAgc29ydFByZWNlZGVuY2U6IHJlZ2lzdGVyKCdzb3J0LXByZWNlZGVuY2UnLCAweGViNTUpLFxuICAgIHNwbGl0SG9yaXpvbnRhbDogcmVnaXN0ZXIoJ3NwbGl0LWhvcml6b250YWwnLCAweGViNTYpLFxuICAgIHNwbGl0VmVydGljYWw6IHJlZ2lzdGVyKCdzcGxpdC12ZXJ0aWNhbCcsIDB4ZWI1NyksXG4gICAgc3F1aXJyZWw6IHJlZ2lzdGVyKCdzcXVpcnJlbCcsIDB4ZWI1OCksXG4gICAgc3RhckZ1bGw6IHJlZ2lzdGVyKCdzdGFyLWZ1bGwnLCAweGViNTkpLFxuICAgIHN0YXJIYWxmOiByZWdpc3Rlcignc3Rhci1oYWxmJywgMHhlYjVhKSxcbiAgICBzeW1ib2xDbGFzczogcmVnaXN0ZXIoJ3N5bWJvbC1jbGFzcycsIDB4ZWI1YiksXG4gICAgc3ltYm9sQ29sb3I6IHJlZ2lzdGVyKCdzeW1ib2wtY29sb3InLCAweGViNWMpLFxuICAgIHN5bWJvbENvbnN0YW50OiByZWdpc3Rlcignc3ltYm9sLWNvbnN0YW50JywgMHhlYjVkKSxcbiAgICBzeW1ib2xFbnVtTWVtYmVyOiByZWdpc3Rlcignc3ltYm9sLWVudW0tbWVtYmVyJywgMHhlYjVlKSxcbiAgICBzeW1ib2xGaWVsZDogcmVnaXN0ZXIoJ3N5bWJvbC1maWVsZCcsIDB4ZWI1ZiksXG4gICAgc3ltYm9sRmlsZTogcmVnaXN0ZXIoJ3N5bWJvbC1maWxlJywgMHhlYjYwKSxcbiAgICBzeW1ib2xJbnRlcmZhY2U6IHJlZ2lzdGVyKCdzeW1ib2wtaW50ZXJmYWNlJywgMHhlYjYxKSxcbiAgICBzeW1ib2xLZXl3b3JkOiByZWdpc3Rlcignc3ltYm9sLWtleXdvcmQnLCAweGViNjIpLFxuICAgIHN5bWJvbE1pc2M6IHJlZ2lzdGVyKCdzeW1ib2wtbWlzYycsIDB4ZWI2MyksXG4gICAgc3ltYm9sT3BlcmF0b3I6IHJlZ2lzdGVyKCdzeW1ib2wtb3BlcmF0b3InLCAweGViNjQpLFxuICAgIHN5bWJvbFByb3BlcnR5OiByZWdpc3Rlcignc3ltYm9sLXByb3BlcnR5JywgMHhlYjY1KSxcbiAgICB3cmVuY2g6IHJlZ2lzdGVyKCd3cmVuY2gnLCAweGViNjUpLFxuICAgIHdyZW5jaFN1YmFjdGlvbjogcmVnaXN0ZXIoJ3dyZW5jaC1zdWJhY3Rpb24nLCAweGViNjUpLFxuICAgIHN5bWJvbFNuaXBwZXQ6IHJlZ2lzdGVyKCdzeW1ib2wtc25pcHBldCcsIDB4ZWI2NiksXG4gICAgdGFza2xpc3Q6IHJlZ2lzdGVyKCd0YXNrbGlzdCcsIDB4ZWI2NyksXG4gICAgdGVsZXNjb3BlOiByZWdpc3RlcigndGVsZXNjb3BlJywgMHhlYjY4KSxcbiAgICB0ZXh0U2l6ZTogcmVnaXN0ZXIoJ3RleHQtc2l6ZScsIDB4ZWI2OSksXG4gICAgdGhyZWVCYXJzOiByZWdpc3RlcigndGhyZWUtYmFycycsIDB4ZWI2YSksXG4gICAgdGh1bWJzZG93bjogcmVnaXN0ZXIoJ3RodW1ic2Rvd24nLCAweGViNmIpLFxuICAgIHRodW1ic3VwOiByZWdpc3RlcigndGh1bWJzdXAnLCAweGViNmMpLFxuICAgIHRvb2xzOiByZWdpc3RlcigndG9vbHMnLCAweGViNmQpLFxuICAgIHRyaWFuZ2xlRG93bjogcmVnaXN0ZXIoJ3RyaWFuZ2xlLWRvd24nLCAweGViNmUpLFxuICAgIHRyaWFuZ2xlTGVmdDogcmVnaXN0ZXIoJ3RyaWFuZ2xlLWxlZnQnLCAweGViNmYpLFxuICAgIHRyaWFuZ2xlUmlnaHQ6IHJlZ2lzdGVyKCd0cmlhbmdsZS1yaWdodCcsIDB4ZWI3MCksXG4gICAgdHJpYW5nbGVVcDogcmVnaXN0ZXIoJ3RyaWFuZ2xlLXVwJywgMHhlYjcxKSxcbiAgICB0d2l0dGVyOiByZWdpc3RlcigndHdpdHRlcicsIDB4ZWI3MiksXG4gICAgdW5mb2xkOiByZWdpc3RlcigndW5mb2xkJywgMHhlYjczKSxcbiAgICB1bmxvY2s6IHJlZ2lzdGVyKCd1bmxvY2snLCAweGViNzQpLFxuICAgIHVubXV0ZTogcmVnaXN0ZXIoJ3VubXV0ZScsIDB4ZWI3NSksXG4gICAgdW52ZXJpZmllZDogcmVnaXN0ZXIoJ3VudmVyaWZpZWQnLCAweGViNzYpLFxuICAgIHZlcmlmaWVkOiByZWdpc3RlcigndmVyaWZpZWQnLCAweGViNzcpLFxuICAgIHZlcnNpb25zOiByZWdpc3RlcigndmVyc2lvbnMnLCAweGViNzgpLFxuICAgIHZtQWN0aXZlOiByZWdpc3Rlcigndm0tYWN0aXZlJywgMHhlYjc5KSxcbiAgICB2bU91dGxpbmU6IHJlZ2lzdGVyKCd2bS1vdXRsaW5lJywgMHhlYjdhKSxcbiAgICB2bVJ1bm5pbmc6IHJlZ2lzdGVyKCd2bS1ydW5uaW5nJywgMHhlYjdiKSxcbiAgICB3YXRjaDogcmVnaXN0ZXIoJ3dhdGNoJywgMHhlYjdjKSxcbiAgICB3aGl0ZXNwYWNlOiByZWdpc3Rlcignd2hpdGVzcGFjZScsIDB4ZWI3ZCksXG4gICAgd2hvbGVXb3JkOiByZWdpc3Rlcignd2hvbGUtd29yZCcsIDB4ZWI3ZSksXG4gICAgd2luZG93OiByZWdpc3Rlcignd2luZG93JywgMHhlYjdmKSxcbiAgICB3b3JkV3JhcDogcmVnaXN0ZXIoJ3dvcmQtd3JhcCcsIDB4ZWI4MCksXG4gICAgem9vbUluOiByZWdpc3Rlcignem9vbS1pbicsIDB4ZWI4MSksXG4gICAgem9vbU91dDogcmVnaXN0ZXIoJ3pvb20tb3V0JywgMHhlYjgyKSxcbiAgICBsaXN0RmlsdGVyOiByZWdpc3RlcignbGlzdC1maWx0ZXInLCAweGViODMpLFxuICAgIGxpc3RGbGF0OiByZWdpc3RlcignbGlzdC1mbGF0JywgMHhlYjg0KSxcbiAgICBsaXN0U2VsZWN0aW9uOiByZWdpc3RlcignbGlzdC1zZWxlY3Rpb24nLCAweGViODUpLFxuICAgIHNlbGVjdGlvbjogcmVnaXN0ZXIoJ3NlbGVjdGlvbicsIDB4ZWI4NSksXG4gICAgbGlzdFRyZWU6IHJlZ2lzdGVyKCdsaXN0LXRyZWUnLCAweGViODYpLFxuICAgIGRlYnVnQnJlYWtwb2ludEZ1bmN0aW9uVW52ZXJpZmllZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtZnVuY3Rpb24tdW52ZXJpZmllZCcsIDB4ZWI4NyksXG4gICAgZGVidWdCcmVha3BvaW50RnVuY3Rpb246IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWZ1bmN0aW9uJywgMHhlYjg4KSxcbiAgICBkZWJ1Z0JyZWFrcG9pbnRGdW5jdGlvbkRpc2FibGVkOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1mdW5jdGlvbi1kaXNhYmxlZCcsIDB4ZWI4OCksXG4gICAgZGVidWdTdGFja2ZyYW1lQWN0aXZlOiByZWdpc3RlcignZGVidWctc3RhY2tmcmFtZS1hY3RpdmUnLCAweGViODkpLFxuICAgIGNpcmNsZVNtYWxsRmlsbGVkOiByZWdpc3RlcignY2lyY2xlLXNtYWxsLWZpbGxlZCcsIDB4ZWI4YSksXG4gICAgZGVidWdTdGFja2ZyYW1lRG90OiByZWdpc3RlcignZGVidWctc3RhY2tmcmFtZS1kb3QnLCAweGViOGEpLFxuICAgIHRlcm1pbmFsRGVjb3JhdGlvbk1hcms6IHJlZ2lzdGVyKCd0ZXJtaW5hbC1kZWNvcmF0aW9uLW1hcmsnLCAweGViOGEpLFxuICAgIGRlYnVnU3RhY2tmcmFtZTogcmVnaXN0ZXIoJ2RlYnVnLXN0YWNrZnJhbWUnLCAweGViOGIpLFxuICAgIGRlYnVnU3RhY2tmcmFtZUZvY3VzZWQ6IHJlZ2lzdGVyKCdkZWJ1Zy1zdGFja2ZyYW1lLWZvY3VzZWQnLCAweGViOGIpLFxuICAgIGRlYnVnQnJlYWtwb2ludFVuc3VwcG9ydGVkOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC11bnN1cHBvcnRlZCcsIDB4ZWI4YyksXG4gICAgc3ltYm9sU3RyaW5nOiByZWdpc3Rlcignc3ltYm9sLXN0cmluZycsIDB4ZWI4ZCksXG4gICAgZGVidWdSZXZlcnNlQ29udGludWU6IHJlZ2lzdGVyKCdkZWJ1Zy1yZXZlcnNlLWNvbnRpbnVlJywgMHhlYjhlKSxcbiAgICBkZWJ1Z1N0ZXBCYWNrOiByZWdpc3RlcignZGVidWctc3RlcC1iYWNrJywgMHhlYjhmKSxcbiAgICBkZWJ1Z1Jlc3RhcnRGcmFtZTogcmVnaXN0ZXIoJ2RlYnVnLXJlc3RhcnQtZnJhbWUnLCAweGViOTApLFxuICAgIGRlYnVnQWx0OiByZWdpc3RlcignZGVidWctYWx0JywgMHhlYjkxKSxcbiAgICBjYWxsSW5jb21pbmc6IHJlZ2lzdGVyKCdjYWxsLWluY29taW5nJywgMHhlYjkyKSxcbiAgICBjYWxsT3V0Z29pbmc6IHJlZ2lzdGVyKCdjYWxsLW91dGdvaW5nJywgMHhlYjkzKSxcbiAgICBtZW51OiByZWdpc3RlcignbWVudScsIDB4ZWI5NCksXG4gICAgZXhwYW5kQWxsOiByZWdpc3RlcignZXhwYW5kLWFsbCcsIDB4ZWI5NSksXG4gICAgZmVlZGJhY2s6IHJlZ2lzdGVyKCdmZWVkYmFjaycsIDB4ZWI5NiksXG4gICAgZ2l0UHVsbFJlcXVlc3RSZXZpZXdlcjogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtcmV2aWV3ZXInLCAweGViOTYpLFxuICAgIGdyb3VwQnlSZWZUeXBlOiByZWdpc3RlcignZ3JvdXAtYnktcmVmLXR5cGUnLCAweGViOTcpLFxuICAgIHVuZ3JvdXBCeVJlZlR5cGU6IHJlZ2lzdGVyKCd1bmdyb3VwLWJ5LXJlZi10eXBlJywgMHhlYjk4KSxcbiAgICBhY2NvdW50OiByZWdpc3RlcignYWNjb3VudCcsIDB4ZWI5OSksXG4gICAgZ2l0UHVsbFJlcXVlc3RBc3NpZ25lZTogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtYXNzaWduZWUnLCAweGViOTkpLFxuICAgIGJlbGxEb3Q6IHJlZ2lzdGVyKCdiZWxsLWRvdCcsIDB4ZWI5YSksXG4gICAgZGVidWdDb25zb2xlOiByZWdpc3RlcignZGVidWctY29uc29sZScsIDB4ZWI5YiksXG4gICAgbGlicmFyeTogcmVnaXN0ZXIoJ2xpYnJhcnknLCAweGViOWMpLFxuICAgIG91dHB1dDogcmVnaXN0ZXIoJ291dHB1dCcsIDB4ZWI5ZCksXG4gICAgcnVuQWxsOiByZWdpc3RlcigncnVuLWFsbCcsIDB4ZWI5ZSksXG4gICAgc3luY0lnbm9yZWQ6IHJlZ2lzdGVyKCdzeW5jLWlnbm9yZWQnLCAweGViOWYpLFxuICAgIHBpbm5lZDogcmVnaXN0ZXIoJ3Bpbm5lZCcsIDB4ZWJhMCksXG4gICAgZ2l0aHViSW52ZXJ0ZWQ6IHJlZ2lzdGVyKCdnaXRodWItaW52ZXJ0ZWQnLCAweGViYTEpLFxuICAgIHNlcnZlclByb2Nlc3M6IHJlZ2lzdGVyKCdzZXJ2ZXItcHJvY2VzcycsIDB4ZWJhMiksXG4gICAgc2VydmVyRW52aXJvbm1lbnQ6IHJlZ2lzdGVyKCdzZXJ2ZXItZW52aXJvbm1lbnQnLCAweGViYTMpLFxuICAgIHBhc3M6IHJlZ2lzdGVyKCdwYXNzJywgMHhlYmE0KSxcbiAgICBpc3N1ZUNsb3NlZDogcmVnaXN0ZXIoJ2lzc3VlLWNsb3NlZCcsIDB4ZWJhNCksXG4gICAgc3RvcENpcmNsZTogcmVnaXN0ZXIoJ3N0b3AtY2lyY2xlJywgMHhlYmE1KSxcbiAgICBwbGF5Q2lyY2xlOiByZWdpc3RlcigncGxheS1jaXJjbGUnLCAweGViYTYpLFxuICAgIHJlY29yZDogcmVnaXN0ZXIoJ3JlY29yZCcsIDB4ZWJhNyksXG4gICAgZGVidWdBbHRTbWFsbDogcmVnaXN0ZXIoJ2RlYnVnLWFsdC1zbWFsbCcsIDB4ZWJhOCksXG4gICAgdm1Db25uZWN0OiByZWdpc3Rlcigndm0tY29ubmVjdCcsIDB4ZWJhOSksXG4gICAgY2xvdWQ6IHJlZ2lzdGVyKCdjbG91ZCcsIDB4ZWJhYSksXG4gICAgbWVyZ2U6IHJlZ2lzdGVyKCdtZXJnZScsIDB4ZWJhYiksXG4gICAgZXhwb3J0OiByZWdpc3RlcignZXhwb3J0JywgMHhlYmFjKSxcbiAgICBncmFwaExlZnQ6IHJlZ2lzdGVyKCdncmFwaC1sZWZ0JywgMHhlYmFkKSxcbiAgICBtYWduZXQ6IHJlZ2lzdGVyKCdtYWduZXQnLCAweGViYWUpLFxuICAgIG5vdGVib29rOiByZWdpc3Rlcignbm90ZWJvb2snLCAweGViYWYpLFxuICAgIHJlZG86IHJlZ2lzdGVyKCdyZWRvJywgMHhlYmIwKSxcbiAgICBjaGVja0FsbDogcmVnaXN0ZXIoJ2NoZWNrLWFsbCcsIDB4ZWJiMSksXG4gICAgcGlubmVkRGlydHk6IHJlZ2lzdGVyKCdwaW5uZWQtZGlydHknLCAweGViYjIpLFxuICAgIHBhc3NGaWxsZWQ6IHJlZ2lzdGVyKCdwYXNzLWZpbGxlZCcsIDB4ZWJiMyksXG4gICAgY2lyY2xlTGFyZ2VGaWxsZWQ6IHJlZ2lzdGVyKCdjaXJjbGUtbGFyZ2UtZmlsbGVkJywgMHhlYmI0KSxcbiAgICBjaXJjbGVMYXJnZTogcmVnaXN0ZXIoJ2NpcmNsZS1sYXJnZScsIDB4ZWJiNSksXG4gICAgY2lyY2xlTGFyZ2VPdXRsaW5lOiByZWdpc3RlcignY2lyY2xlLWxhcmdlLW91dGxpbmUnLCAweGViYjUpLFxuICAgIGNvbWJpbmU6IHJlZ2lzdGVyKCdjb21iaW5lJywgMHhlYmI2KSxcbiAgICBnYXRoZXI6IHJlZ2lzdGVyKCdnYXRoZXInLCAweGViYjYpLFxuICAgIHRhYmxlOiByZWdpc3RlcigndGFibGUnLCAweGViYjcpLFxuICAgIHZhcmlhYmxlR3JvdXA6IHJlZ2lzdGVyKCd2YXJpYWJsZS1ncm91cCcsIDB4ZWJiOCksXG4gICAgdHlwZUhpZXJhcmNoeTogcmVnaXN0ZXIoJ3R5cGUtaGllcmFyY2h5JywgMHhlYmI5KSxcbiAgICB0eXBlSGllcmFyY2h5U3ViOiByZWdpc3RlcigndHlwZS1oaWVyYXJjaHktc3ViJywgMHhlYmJhKSxcbiAgICB0eXBlSGllcmFyY2h5U3VwZXI6IHJlZ2lzdGVyKCd0eXBlLWhpZXJhcmNoeS1zdXBlcicsIDB4ZWJiYiksXG4gICAgZ2l0UHVsbFJlcXVlc3RDcmVhdGU6IHJlZ2lzdGVyKCdnaXQtcHVsbC1yZXF1ZXN0LWNyZWF0ZScsIDB4ZWJiYyksXG4gICAgcnVuQWJvdmU6IHJlZ2lzdGVyKCdydW4tYWJvdmUnLCAweGViYmQpLFxuICAgIHJ1bkJlbG93OiByZWdpc3RlcigncnVuLWJlbG93JywgMHhlYmJlKSxcbiAgICBub3RlYm9va1RlbXBsYXRlOiByZWdpc3Rlcignbm90ZWJvb2stdGVtcGxhdGUnLCAweGViYmYpLFxuICAgIGRlYnVnUmVydW46IHJlZ2lzdGVyKCdkZWJ1Zy1yZXJ1bicsIDB4ZWJjMCksXG4gICAgd29ya3NwYWNlVHJ1c3RlZDogcmVnaXN0ZXIoJ3dvcmtzcGFjZS10cnVzdGVkJywgMHhlYmMxKSxcbiAgICB3b3Jrc3BhY2VVbnRydXN0ZWQ6IHJlZ2lzdGVyKCd3b3Jrc3BhY2UtdW50cnVzdGVkJywgMHhlYmMyKSxcbiAgICB3b3Jrc3BhY2VVbmtub3duOiByZWdpc3Rlcignd29ya3NwYWNlLXVua25vd24nLCAweGViYzMpLFxuICAgIHRlcm1pbmFsQ21kOiByZWdpc3RlcigndGVybWluYWwtY21kJywgMHhlYmM0KSxcbiAgICB0ZXJtaW5hbERlYmlhbjogcmVnaXN0ZXIoJ3Rlcm1pbmFsLWRlYmlhbicsIDB4ZWJjNSksXG4gICAgdGVybWluYWxMaW51eDogcmVnaXN0ZXIoJ3Rlcm1pbmFsLWxpbnV4JywgMHhlYmM2KSxcbiAgICB0ZXJtaW5hbFBvd2Vyc2hlbGw6IHJlZ2lzdGVyKCd0ZXJtaW5hbC1wb3dlcnNoZWxsJywgMHhlYmM3KSxcbiAgICB0ZXJtaW5hbFRtdXg6IHJlZ2lzdGVyKCd0ZXJtaW5hbC10bXV4JywgMHhlYmM4KSxcbiAgICB0ZXJtaW5hbFVidW50dTogcmVnaXN0ZXIoJ3Rlcm1pbmFsLXVidW50dScsIDB4ZWJjOSksXG4gICAgdGVybWluYWxCYXNoOiByZWdpc3RlcigndGVybWluYWwtYmFzaCcsIDB4ZWJjYSksXG4gICAgYXJyb3dTd2FwOiByZWdpc3RlcignYXJyb3ctc3dhcCcsIDB4ZWJjYiksXG4gICAgY29weTogcmVnaXN0ZXIoJ2NvcHknLCAweGViY2MpLFxuICAgIHBlcnNvbkFkZDogcmVnaXN0ZXIoJ3BlcnNvbi1hZGQnLCAweGViY2QpLFxuICAgIGZpbHRlckZpbGxlZDogcmVnaXN0ZXIoJ2ZpbHRlci1maWxsZWQnLCAweGViY2UpLFxuICAgIHdhbmQ6IHJlZ2lzdGVyKCd3YW5kJywgMHhlYmNmKSxcbiAgICBkZWJ1Z0xpbmVCeUxpbmU6IHJlZ2lzdGVyKCdkZWJ1Zy1saW5lLWJ5LWxpbmUnLCAweGViZDApLFxuICAgIGluc3BlY3Q6IHJlZ2lzdGVyKCdpbnNwZWN0JywgMHhlYmQxKSxcbiAgICBsYXllcnM6IHJlZ2lzdGVyKCdsYXllcnMnLCAweGViZDIpLFxuICAgIGxheWVyc0RvdDogcmVnaXN0ZXIoJ2xheWVycy1kb3QnLCAweGViZDMpLFxuICAgIGxheWVyc0FjdGl2ZTogcmVnaXN0ZXIoJ2xheWVycy1hY3RpdmUnLCAweGViZDQpLFxuICAgIGNvbXBhc3M6IHJlZ2lzdGVyKCdjb21wYXNzJywgMHhlYmQ1KSxcbiAgICBjb21wYXNzRG90OiByZWdpc3RlcignY29tcGFzcy1kb3QnLCAweGViZDYpLFxuICAgIGNvbXBhc3NBY3RpdmU6IHJlZ2lzdGVyKCdjb21wYXNzLWFjdGl2ZScsIDB4ZWJkNyksXG4gICAgYXp1cmU6IHJlZ2lzdGVyKCdhenVyZScsIDB4ZWJkOCksXG4gICAgaXNzdWVEcmFmdDogcmVnaXN0ZXIoJ2lzc3VlLWRyYWZ0JywgMHhlYmQ5KSxcbiAgICBnaXRQdWxsUmVxdWVzdENsb3NlZDogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtY2xvc2VkJywgMHhlYmRhKSxcbiAgICBnaXRQdWxsUmVxdWVzdERyYWZ0OiByZWdpc3RlcignZ2l0LXB1bGwtcmVxdWVzdC1kcmFmdCcsIDB4ZWJkYiksXG4gICAgZGVidWdBbGw6IHJlZ2lzdGVyKCdkZWJ1Zy1hbGwnLCAweGViZGMpLFxuICAgIGRlYnVnQ292ZXJhZ2U6IHJlZ2lzdGVyKCdkZWJ1Zy1jb3ZlcmFnZScsIDB4ZWJkZCksXG4gICAgcnVuRXJyb3JzOiByZWdpc3RlcigncnVuLWVycm9ycycsIDB4ZWJkZSksXG4gICAgZm9sZGVyTGlicmFyeTogcmVnaXN0ZXIoJ2ZvbGRlci1saWJyYXJ5JywgMHhlYmRmKSxcbiAgICBkZWJ1Z0NvbnRpbnVlU21hbGw6IHJlZ2lzdGVyKCdkZWJ1Zy1jb250aW51ZS1zbWFsbCcsIDB4ZWJlMCksXG4gICAgYmVha2VyU3RvcDogcmVnaXN0ZXIoJ2JlYWtlci1zdG9wJywgMHhlYmUxKSxcbiAgICBncmFwaExpbmU6IHJlZ2lzdGVyKCdncmFwaC1saW5lJywgMHhlYmUyKSxcbiAgICBncmFwaFNjYXR0ZXI6IHJlZ2lzdGVyKCdncmFwaC1zY2F0dGVyJywgMHhlYmUzKSxcbiAgICBwaWVDaGFydDogcmVnaXN0ZXIoJ3BpZS1jaGFydCcsIDB4ZWJlNCksXG4gICAgYnJhY2tldDogcmVnaXN0ZXIoJ2JyYWNrZXQnLCAweGViMGYpLFxuICAgIGJyYWNrZXREb3Q6IHJlZ2lzdGVyKCdicmFja2V0LWRvdCcsIDB4ZWJlNSksXG4gICAgYnJhY2tldEVycm9yOiByZWdpc3RlcignYnJhY2tldC1lcnJvcicsIDB4ZWJlNiksXG4gICAgbG9ja1NtYWxsOiByZWdpc3RlcignbG9jay1zbWFsbCcsIDB4ZWJlNyksXG4gICAgYXp1cmVEZXZvcHM6IHJlZ2lzdGVyKCdhenVyZS1kZXZvcHMnLCAweGViZTgpLFxuICAgIHZlcmlmaWVkRmlsbGVkOiByZWdpc3RlcigndmVyaWZpZWQtZmlsbGVkJywgMHhlYmU5KSxcbiAgICBuZXdsaW5lOiByZWdpc3RlcignbmV3bGluZScsIDB4ZWJlYSksXG4gICAgbGF5b3V0OiByZWdpc3RlcignbGF5b3V0JywgMHhlYmViKSxcbiAgICBsYXlvdXRBY3Rpdml0eWJhckxlZnQ6IHJlZ2lzdGVyKCdsYXlvdXQtYWN0aXZpdHliYXItbGVmdCcsIDB4ZWJlYyksXG4gICAgbGF5b3V0QWN0aXZpdHliYXJSaWdodDogcmVnaXN0ZXIoJ2xheW91dC1hY3Rpdml0eWJhci1yaWdodCcsIDB4ZWJlZCksXG4gICAgbGF5b3V0UGFuZWxMZWZ0OiByZWdpc3RlcignbGF5b3V0LXBhbmVsLWxlZnQnLCAweGViZWUpLFxuICAgIGxheW91dFBhbmVsQ2VudGVyOiByZWdpc3RlcignbGF5b3V0LXBhbmVsLWNlbnRlcicsIDB4ZWJlZiksXG4gICAgbGF5b3V0UGFuZWxKdXN0aWZ5OiByZWdpc3RlcignbGF5b3V0LXBhbmVsLWp1c3RpZnknLCAweGViZjApLFxuICAgIGxheW91dFBhbmVsUmlnaHQ6IHJlZ2lzdGVyKCdsYXlvdXQtcGFuZWwtcmlnaHQnLCAweGViZjEpLFxuICAgIGxheW91dFBhbmVsOiByZWdpc3RlcignbGF5b3V0LXBhbmVsJywgMHhlYmYyKSxcbiAgICBsYXlvdXRTaWRlYmFyTGVmdDogcmVnaXN0ZXIoJ2xheW91dC1zaWRlYmFyLWxlZnQnLCAweGViZjMpLFxuICAgIGxheW91dFNpZGViYXJSaWdodDogcmVnaXN0ZXIoJ2xheW91dC1zaWRlYmFyLXJpZ2h0JywgMHhlYmY0KSxcbiAgICBsYXlvdXRTdGF0dXNiYXI6IHJlZ2lzdGVyKCdsYXlvdXQtc3RhdHVzYmFyJywgMHhlYmY1KSxcbiAgICBsYXlvdXRNZW51YmFyOiByZWdpc3RlcignbGF5b3V0LW1lbnViYXInLCAweGViZjYpLFxuICAgIGxheW91dENlbnRlcmVkOiByZWdpc3RlcignbGF5b3V0LWNlbnRlcmVkJywgMHhlYmY3KSxcbiAgICB0YXJnZXQ6IHJlZ2lzdGVyKCd0YXJnZXQnLCAweGViZjgpLFxuICAgIGluZGVudDogcmVnaXN0ZXIoJ2luZGVudCcsIDB4ZWJmOSksXG4gICAgcmVjb3JkU21hbGw6IHJlZ2lzdGVyKCdyZWNvcmQtc21hbGwnLCAweGViZmEpLFxuICAgIGVycm9yU21hbGw6IHJlZ2lzdGVyKCdlcnJvci1zbWFsbCcsIDB4ZWJmYiksXG4gICAgdGVybWluYWxEZWNvcmF0aW9uRXJyb3I6IHJlZ2lzdGVyKCd0ZXJtaW5hbC1kZWNvcmF0aW9uLWVycm9yJywgMHhlYmZiKSxcbiAgICBhcnJvd0NpcmNsZURvd246IHJlZ2lzdGVyKCdhcnJvdy1jaXJjbGUtZG93bicsIDB4ZWJmYyksXG4gICAgYXJyb3dDaXJjbGVMZWZ0OiByZWdpc3RlcignYXJyb3ctY2lyY2xlLWxlZnQnLCAweGViZmQpLFxuICAgIGFycm93Q2lyY2xlUmlnaHQ6IHJlZ2lzdGVyKCdhcnJvdy1jaXJjbGUtcmlnaHQnLCAweGViZmUpLFxuICAgIGFycm93Q2lyY2xlVXA6IHJlZ2lzdGVyKCdhcnJvdy1jaXJjbGUtdXAnLCAweGViZmYpLFxuICAgIGxheW91dFNpZGViYXJSaWdodE9mZjogcmVnaXN0ZXIoJ2xheW91dC1zaWRlYmFyLXJpZ2h0LW9mZicsIDB4ZWMwMCksXG4gICAgbGF5b3V0UGFuZWxPZmY6IHJlZ2lzdGVyKCdsYXlvdXQtcGFuZWwtb2ZmJywgMHhlYzAxKSxcbiAgICBsYXlvdXRTaWRlYmFyTGVmdE9mZjogcmVnaXN0ZXIoJ2xheW91dC1zaWRlYmFyLWxlZnQtb2ZmJywgMHhlYzAyKSxcbiAgICBibGFuazogcmVnaXN0ZXIoJ2JsYW5rJywgMHhlYzAzKSxcbiAgICBoZWFydEZpbGxlZDogcmVnaXN0ZXIoJ2hlYXJ0LWZpbGxlZCcsIDB4ZWMwNCksXG4gICAgbWFwOiByZWdpc3RlcignbWFwJywgMHhlYzA1KSxcbiAgICBtYXBIb3Jpem9udGFsOiByZWdpc3RlcignbWFwLWhvcml6b250YWwnLCAweGVjMDUpLFxuICAgIGZvbGRIb3Jpem9udGFsOiByZWdpc3RlcignZm9sZC1ob3Jpem9udGFsJywgMHhlYzA1KSxcbiAgICBtYXBGaWxsZWQ6IHJlZ2lzdGVyKCdtYXAtZmlsbGVkJywgMHhlYzA2KSxcbiAgICBtYXBIb3Jpem9udGFsRmlsbGVkOiByZWdpc3RlcignbWFwLWhvcml6b250YWwtZmlsbGVkJywgMHhlYzA2KSxcbiAgICBmb2xkSG9yaXpvbnRhbEZpbGxlZDogcmVnaXN0ZXIoJ2ZvbGQtaG9yaXpvbnRhbC1maWxsZWQnLCAweGVjMDYpLFxuICAgIGNpcmNsZVNtYWxsOiByZWdpc3RlcignY2lyY2xlLXNtYWxsJywgMHhlYzA3KSxcbiAgICBiZWxsU2xhc2g6IHJlZ2lzdGVyKCdiZWxsLXNsYXNoJywgMHhlYzA4KSxcbiAgICBiZWxsU2xhc2hEb3Q6IHJlZ2lzdGVyKCdiZWxsLXNsYXNoLWRvdCcsIDB4ZWMwOSksXG4gICAgY29tbWVudFVucmVzb2x2ZWQ6IHJlZ2lzdGVyKCdjb21tZW50LXVucmVzb2x2ZWQnLCAweGVjMGEpLFxuICAgIGdpdFB1bGxSZXF1ZXN0R29Ub0NoYW5nZXM6IHJlZ2lzdGVyKCdnaXQtcHVsbC1yZXF1ZXN0LWdvLXRvLWNoYW5nZXMnLCAweGVjMGIpLFxuICAgIGdpdFB1bGxSZXF1ZXN0TmV3Q2hhbmdlczogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtbmV3LWNoYW5nZXMnLCAweGVjMGMpLFxuICAgIHNlYXJjaEZ1enp5OiByZWdpc3Rlcignc2VhcmNoLWZ1enp5JywgMHhlYzBkKSxcbiAgICBjb21tZW50RHJhZnQ6IHJlZ2lzdGVyKCdjb21tZW50LWRyYWZ0JywgMHhlYzBlKSxcbiAgICBzZW5kOiByZWdpc3Rlcignc2VuZCcsIDB4ZWMwZiksXG4gICAgc3BhcmtsZTogcmVnaXN0ZXIoJ3NwYXJrbGUnLCAweGVjMTApLFxuICAgIGluc2VydDogcmVnaXN0ZXIoJ2luc2VydCcsIDB4ZWMxMSksXG4gICAgbWljOiByZWdpc3RlcignbWljJywgMHhlYzEyKSxcbiAgICB0aHVtYnNkb3duRmlsbGVkOiByZWdpc3RlcigndGh1bWJzZG93bi1maWxsZWQnLCAweGVjMTMpLFxuICAgIHRodW1ic3VwRmlsbGVkOiByZWdpc3RlcigndGh1bWJzdXAtZmlsbGVkJywgMHhlYzE0KSxcbiAgICBjb2ZmZWU6IHJlZ2lzdGVyKCdjb2ZmZWUnLCAweGVjMTUpLFxuICAgIHNuYWtlOiByZWdpc3Rlcignc25ha2UnLCAweGVjMTYpLFxuICAgIGdhbWU6IHJlZ2lzdGVyKCdnYW1lJywgMHhlYzE3KSxcbiAgICB2cjogcmVnaXN0ZXIoJ3ZyJywgMHhlYzE4KSxcbiAgICBjaGlwOiByZWdpc3RlcignY2hpcCcsIDB4ZWMxOSksXG4gICAgcGlhbm86IHJlZ2lzdGVyKCdwaWFubycsIDB4ZWMxYSksXG4gICAgbXVzaWM6IHJlZ2lzdGVyKCdtdXNpYycsIDB4ZWMxYiksXG4gICAgbWljRmlsbGVkOiByZWdpc3RlcignbWljLWZpbGxlZCcsIDB4ZWMxYyksXG4gICAgcmVwb0ZldGNoOiByZWdpc3RlcigncmVwby1mZXRjaCcsIDB4ZWMxZCksXG4gICAgY29waWxvdDogcmVnaXN0ZXIoJ2NvcGlsb3QnLCAweGVjMWUpLFxuICAgIGxpZ2h0YnVsYlNwYXJrbGU6IHJlZ2lzdGVyKCdsaWdodGJ1bGItc3BhcmtsZScsIDB4ZWMxZiksXG4gICAgcm9ib3Q6IHJlZ2lzdGVyKCdyb2JvdCcsIDB4ZWMyMCksXG4gICAgc3BhcmtsZUZpbGxlZDogcmVnaXN0ZXIoJ3NwYXJrbGUtZmlsbGVkJywgMHhlYzIxKSxcbiAgICBkaWZmU2luZ2xlOiByZWdpc3RlcignZGlmZi1zaW5nbGUnLCAweGVjMjIpLFxuICAgIGRpZmZNdWx0aXBsZTogcmVnaXN0ZXIoJ2RpZmYtbXVsdGlwbGUnLCAweGVjMjMpLFxuICAgIHN1cnJvdW5kV2l0aDogcmVnaXN0ZXIoJ3N1cnJvdW5kLXdpdGgnLCAweGVjMjQpLFxuICAgIHNoYXJlOiByZWdpc3Rlcignc2hhcmUnLCAweGVjMjUpLFxuICAgIGdpdFN0YXNoOiByZWdpc3RlcignZ2l0LXN0YXNoJywgMHhlYzI2KSxcbiAgICBnaXRTdGFzaEFwcGx5OiByZWdpc3RlcignZ2l0LXN0YXNoLWFwcGx5JywgMHhlYzI3KSxcbiAgICBnaXRTdGFzaFBvcDogcmVnaXN0ZXIoJ2dpdC1zdGFzaC1wb3AnLCAweGVjMjgpLFxuICAgIHZzY29kZTogcmVnaXN0ZXIoJ3ZzY29kZScsIDB4ZWMyOSksXG4gICAgdnNjb2RlSW5zaWRlcnM6IHJlZ2lzdGVyKCd2c2NvZGUtaW5zaWRlcnMnLCAweGVjMmEpLFxuICAgIGNvZGVPc3M6IHJlZ2lzdGVyKCdjb2RlLW9zcycsIDB4ZWMyYiksXG4gICAgcnVuQ292ZXJhZ2U6IHJlZ2lzdGVyKCdydW4tY292ZXJhZ2UnLCAweGVjMmMpLFxuICAgIHJ1bkFsbENvdmVyYWdlOiByZWdpc3RlcigncnVuLWFsbC1jb3ZlcmFnZScsIDB4ZWMyZCksXG4gICAgY292ZXJhZ2U6IHJlZ2lzdGVyKCdjb3ZlcmFnZScsIDB4ZWMyZSksXG4gICAgZ2l0aHViUHJvamVjdDogcmVnaXN0ZXIoJ2dpdGh1Yi1wcm9qZWN0JywgMHhlYzJmKSxcbiAgICBtYXBWZXJ0aWNhbDogcmVnaXN0ZXIoJ21hcC12ZXJ0aWNhbCcsIDB4ZWMzMCksXG4gICAgZm9sZFZlcnRpY2FsOiByZWdpc3RlcignZm9sZC12ZXJ0aWNhbCcsIDB4ZWMzMCksXG4gICAgbWFwVmVydGljYWxGaWxsZWQ6IHJlZ2lzdGVyKCdtYXAtdmVydGljYWwtZmlsbGVkJywgMHhlYzMxKSxcbiAgICBmb2xkVmVydGljYWxGaWxsZWQ6IHJlZ2lzdGVyKCdmb2xkLXZlcnRpY2FsLWZpbGxlZCcsIDB4ZWMzMSksXG4gICAgZ29Ub1NlYXJjaDogcmVnaXN0ZXIoJ2dvLXRvLXNlYXJjaCcsIDB4ZWMzMiksXG4gICAgcGVyY2VudGFnZTogcmVnaXN0ZXIoJ3BlcmNlbnRhZ2UnLCAweGVjMzMpLFxuICAgIHNvcnRQZXJjZW50YWdlOiByZWdpc3Rlcignc29ydC1wZXJjZW50YWdlJywgMHhlYzMzKSxcbiAgICBhdHRhY2g6IHJlZ2lzdGVyKCdhdHRhY2gnLCAweGVjMzQpLFxufTtcbiIsImltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5jb25zdCBfY29kaWNvbkZvbnRDaGFyYWN0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlcihpZCwgZm9udENoYXJhY3Rlcikge1xuICAgIGlmIChpc1N0cmluZyhmb250Q2hhcmFjdGVyKSkge1xuICAgICAgICBjb25zdCB2YWwgPSBfY29kaWNvbkZvbnRDaGFyYWN0ZXJzW2ZvbnRDaGFyYWN0ZXJdO1xuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtpZH0gcmVmZXJlbmNlcyBhbiB1bmtub3duIGNvZGljb246ICR7Zm9udENoYXJhY3Rlcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBmb250Q2hhcmFjdGVyID0gdmFsO1xuICAgIH1cbiAgICBfY29kaWNvbkZvbnRDaGFyYWN0ZXJzW2lkXSA9IGZvbnRDaGFyYWN0ZXI7XG4gICAgcmV0dXJuIHsgaWQgfTtcbn1cbi8qKlxuICogT25seSB0byBiZSB1c2VkIGJ5IHRoZSBpY29uUmVnaXN0cnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2RpY29uRm9udENoYXJhY3RlcnMoKSB7XG4gICAgcmV0dXJuIF9jb2RpY29uRm9udENoYXJhY3RlcnM7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHJvdW5kRmxvYXQobnVtYmVyLCBkZWNpbWFsUG9pbnRzKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IE1hdGgucG93KDEwLCBkZWNpbWFsUG9pbnRzKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBkZWNpbWFsKSAvIGRlY2ltYWw7XG59XG5leHBvcnQgY2xhc3MgUkdCQSB7XG4gICAgY29uc3RydWN0b3IociwgZywgYiwgYSA9IDEpIHtcbiAgICAgICAgdGhpcy5fcmdiYUJyYW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnIgPSBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIHIpKSB8IDA7XG4gICAgICAgIHRoaXMuZyA9IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgZykpIHwgMDtcbiAgICAgICAgdGhpcy5iID0gTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCBiKSkgfCAwO1xuICAgICAgICB0aGlzLmEgPSByb3VuZEZsb2F0KE1hdGgubWF4KE1hdGgubWluKDEsIGEpLCAwKSwgMyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5yID09PSBiLnIgJiYgYS5nID09PSBiLmcgJiYgYS5iID09PSBiLmIgJiYgYS5hID09PSBiLmE7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEhTTEEge1xuICAgIGNvbnN0cnVjdG9yKGgsIHMsIGwsIGEpIHtcbiAgICAgICAgdGhpcy5faHNsYUJyYW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmggPSBNYXRoLm1heChNYXRoLm1pbigzNjAsIGgpLCAwKSB8IDA7XG4gICAgICAgIHRoaXMucyA9IHJvdW5kRmxvYXQoTWF0aC5tYXgoTWF0aC5taW4oMSwgcyksIDApLCAzKTtcbiAgICAgICAgdGhpcy5sID0gcm91bmRGbG9hdChNYXRoLm1heChNYXRoLm1pbigxLCBsKSwgMCksIDMpO1xuICAgICAgICB0aGlzLmEgPSByb3VuZEZsb2F0KE1hdGgubWF4KE1hdGgubWluKDEsIGEpLCAwKSwgMyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5oID09PSBiLmggJiYgYS5zID09PSBiLnMgJiYgYS5sID09PSBiLmwgJiYgYS5hID09PSBiLmE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU0wuIENvbnZlcnNpb24gZm9ybXVsYVxuICAgICAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9jb2xvcl9zcGFjZS5cbiAgICAgKiBBc3N1bWVzIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XSBhbmRcbiAgICAgKiByZXR1cm5zIGggaW4gdGhlIHNldCBbMCwgMzYwXSwgcywgYW5kIGwgaW4gdGhlIHNldCBbMCwgMV0uXG4gICAgICovXG4gICAgc3RhdGljIGZyb21SR0JBKHJnYmEpIHtcbiAgICAgICAgY29uc3QgciA9IHJnYmEuciAvIDI1NTtcbiAgICAgICAgY29uc3QgZyA9IHJnYmEuZyAvIDI1NTtcbiAgICAgICAgY29uc3QgYiA9IHJnYmEuYiAvIDI1NTtcbiAgICAgICAgY29uc3QgYSA9IHJnYmEuYTtcbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgICAgICBsZXQgaCA9IDA7XG4gICAgICAgIGxldCBzID0gMDtcbiAgICAgICAgY29uc3QgbCA9IChtaW4gKyBtYXgpIC8gMjtcbiAgICAgICAgY29uc3QgY2hyb21hID0gbWF4IC0gbWluO1xuICAgICAgICBpZiAoY2hyb21hID4gMCkge1xuICAgICAgICAgICAgcyA9IE1hdGgubWluKChsIDw9IDAuNSA/IGNocm9tYSAvICgyICogbCkgOiBjaHJvbWEgLyAoMiAtICgyICogbCkpKSwgMSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICAgICAgICAgIGNhc2UgcjpcbiAgICAgICAgICAgICAgICAgICAgaCA9IChnIC0gYikgLyBjaHJvbWEgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgICAgICAgICAgaCA9IChiIC0gcikgLyBjaHJvbWEgKyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgICAgICAgICAgIGggPSAociAtIGcpIC8gY2hyb21hICsgNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoICo9IDYwO1xuICAgICAgICAgICAgaCA9IE1hdGgucm91bmQoaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIU0xBKGgsIHMsIGwsIGEpO1xuICAgIH1cbiAgICBzdGF0aWMgX2h1ZTJyZ2IocCwgcSwgdCkge1xuICAgICAgICBpZiAodCA8IDApIHtcbiAgICAgICAgICAgIHQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICAgIHQgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCA8IDEgLyA2KSB7XG4gICAgICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCA8IDEgLyAyKSB7XG4gICAgICAgICAgICByZXR1cm4gcTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCA8IDIgLyAzKSB7XG4gICAgICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIEhTTCBjb2xvciB2YWx1ZSB0byBSR0IuIENvbnZlcnNpb24gZm9ybXVsYVxuICAgICAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9jb2xvcl9zcGFjZS5cbiAgICAgKiBBc3N1bWVzIGggaW4gdGhlIHNldCBbMCwgMzYwXSBzLCBhbmQgbCBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDFdIGFuZFxuICAgICAqIHJldHVybnMgciwgZywgYW5kIGIgaW4gdGhlIHNldCBbMCwgMjU1XS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdG9SR0JBKGhzbGEpIHtcbiAgICAgICAgY29uc3QgaCA9IGhzbGEuaCAvIDM2MDtcbiAgICAgICAgY29uc3QgeyBzLCBsLCBhIH0gPSBoc2xhO1xuICAgICAgICBsZXQgciwgZywgYjtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIHIgPSBnID0gYiA9IGw7IC8vIGFjaHJvbWF0aWNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICAgICAgY29uc3QgcCA9IDIgKiBsIC0gcTtcbiAgICAgICAgICAgIHIgPSBIU0xBLl9odWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gICAgICAgICAgICBnID0gSFNMQS5faHVlMnJnYihwLCBxLCBoKTtcbiAgICAgICAgICAgIGIgPSBIU0xBLl9odWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSR0JBKE1hdGgucm91bmQociAqIDI1NSksIE1hdGgucm91bmQoZyAqIDI1NSksIE1hdGgucm91bmQoYiAqIDI1NSksIGEpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBIU1ZBIHtcbiAgICBjb25zdHJ1Y3RvcihoLCBzLCB2LCBhKSB7XG4gICAgICAgIHRoaXMuX2hzdmFCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oID0gTWF0aC5tYXgoTWF0aC5taW4oMzYwLCBoKSwgMCkgfCAwO1xuICAgICAgICB0aGlzLnMgPSByb3VuZEZsb2F0KE1hdGgubWF4KE1hdGgubWluKDEsIHMpLCAwKSwgMyk7XG4gICAgICAgIHRoaXMudiA9IHJvdW5kRmxvYXQoTWF0aC5tYXgoTWF0aC5taW4oMSwgdiksIDApLCAzKTtcbiAgICAgICAgdGhpcy5hID0gcm91bmRGbG9hdChNYXRoLm1heChNYXRoLm1pbigxLCBhKSwgMCksIDMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuaCA9PT0gYi5oICYmIGEucyA9PT0gYi5zICYmIGEudiA9PT0gYi52ICYmIGEuYSA9PT0gYi5hO1xuICAgIH1cbiAgICAvLyBmcm9tIGh0dHA6Ly93d3cucmFwaWR0YWJsZXMuY29tL2NvbnZlcnQvY29sb3IvcmdiLXRvLWhzdi5odG1cbiAgICBzdGF0aWMgZnJvbVJHQkEocmdiYSkge1xuICAgICAgICBjb25zdCByID0gcmdiYS5yIC8gMjU1O1xuICAgICAgICBjb25zdCBnID0gcmdiYS5nIC8gMjU1O1xuICAgICAgICBjb25zdCBiID0gcmdiYS5iIC8gMjU1O1xuICAgICAgICBjb25zdCBjbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgICAgIGNvbnN0IGNtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBjbWF4IC0gY21pbjtcbiAgICAgICAgY29uc3QgcyA9IGNtYXggPT09IDAgPyAwIDogKGRlbHRhIC8gY21heCk7XG4gICAgICAgIGxldCBtO1xuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgIG0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtYXggPT09IHIpIHtcbiAgICAgICAgICAgIG0gPSAoKCgoZyAtIGIpIC8gZGVsdGEpICUgNikgKyA2KSAlIDY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY21heCA9PT0gZykge1xuICAgICAgICAgICAgbSA9ICgoYiAtIHIpIC8gZGVsdGEpICsgMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG0gPSAoKHIgLSBnKSAvIGRlbHRhKSArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIU1ZBKE1hdGgucm91bmQobSAqIDYwKSwgcywgY21heCwgcmdiYS5hKTtcbiAgICB9XG4gICAgLy8gZnJvbSBodHRwOi8vd3d3LnJhcGlkdGFibGVzLmNvbS9jb252ZXJ0L2NvbG9yL2hzdi10by1yZ2IuaHRtXG4gICAgc3RhdGljIHRvUkdCQShoc3ZhKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgcywgdiwgYSB9ID0gaHN2YTtcbiAgICAgICAgY29uc3QgYyA9IHYgKiBzO1xuICAgICAgICBjb25zdCB4ID0gYyAqICgxIC0gTWF0aC5hYnMoKGggLyA2MCkgJSAyIC0gMSkpO1xuICAgICAgICBjb25zdCBtID0gdiAtIGM7XG4gICAgICAgIGxldCBbciwgZywgYl0gPSBbMCwgMCwgMF07XG4gICAgICAgIGlmIChoIDwgNjApIHtcbiAgICAgICAgICAgIHIgPSBjO1xuICAgICAgICAgICAgZyA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaCA8IDEyMCkge1xuICAgICAgICAgICAgciA9IHg7XG4gICAgICAgICAgICBnID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoIDwgMTgwKSB7XG4gICAgICAgICAgICBnID0gYztcbiAgICAgICAgICAgIGIgPSB4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGggPCAyNDApIHtcbiAgICAgICAgICAgIGcgPSB4O1xuICAgICAgICAgICAgYiA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaCA8IDMwMCkge1xuICAgICAgICAgICAgciA9IHg7XG4gICAgICAgICAgICBiID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoIDw9IDM2MCkge1xuICAgICAgICAgICAgciA9IGM7XG4gICAgICAgICAgICBiID0geDtcbiAgICAgICAgfVxuICAgICAgICByID0gTWF0aC5yb3VuZCgociArIG0pICogMjU1KTtcbiAgICAgICAgZyA9IE1hdGgucm91bmQoKGcgKyBtKSAqIDI1NSk7XG4gICAgICAgIGIgPSBNYXRoLnJvdW5kKChiICsgbSkgKiAyNTUpO1xuICAgICAgICByZXR1cm4gbmV3IFJHQkEociwgZywgYiwgYSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbG9yIHtcbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yLkZvcm1hdC5DU1MucGFyc2VIZXgoaGV4KSB8fCBDb2xvci5yZWQ7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLmVxdWFscyhiKTtcbiAgICB9XG4gICAgZ2V0IGhzbGEoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oc2xhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faHNsYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBIU0xBLmZyb21SR0JBKHRoaXMucmdiYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhzdmEoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oc3ZhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faHN2YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSFNWQS5mcm9tUkdCQSh0aGlzLnJnYmEpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihhcmcpIHtcbiAgICAgICAgaWYgKCFhcmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sb3IgbmVlZHMgYSB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIFJHQkEpIHtcbiAgICAgICAgICAgIHRoaXMucmdiYSA9IGFyZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBIU0xBKSB7XG4gICAgICAgICAgICB0aGlzLl9oc2xhID0gYXJnO1xuICAgICAgICAgICAgdGhpcy5yZ2JhID0gSFNMQS50b1JHQkEoYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBIU1ZBKSB7XG4gICAgICAgICAgICB0aGlzLl9oc3ZhID0gYXJnO1xuICAgICAgICAgICAgdGhpcy5yZ2JhID0gSFNWQS50b1JHQkEoYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2xvciBjdG9yIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAhIW90aGVyICYmIFJHQkEuZXF1YWxzKHRoaXMucmdiYSwgb3RoZXIucmdiYSkgJiYgSFNMQS5lcXVhbHModGhpcy5oc2xhLCBvdGhlci5oc2xhKSAmJiBIU1ZBLmVxdWFscyh0aGlzLmhzdmEsIG90aGVyLmhzdmEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIGluIHRoZSBzZXQgWzAsIDFdLiBPID0+IERhcmtlc3QgQmxhY2suIDEgPT4gTGlnaHRlc3Qgd2hpdGUuXG4gICAgICovXG4gICAgZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKSB7XG4gICAgICAgIGNvbnN0IFIgPSBDb2xvci5fcmVsYXRpdmVMdW1pbmFuY2VGb3JDb21wb25lbnQodGhpcy5yZ2JhLnIpO1xuICAgICAgICBjb25zdCBHID0gQ29sb3IuX3JlbGF0aXZlTHVtaW5hbmNlRm9yQ29tcG9uZW50KHRoaXMucmdiYS5nKTtcbiAgICAgICAgY29uc3QgQiA9IENvbG9yLl9yZWxhdGl2ZUx1bWluYW5jZUZvckNvbXBvbmVudCh0aGlzLnJnYmEuYik7XG4gICAgICAgIGNvbnN0IGx1bWluYW5jZSA9IDAuMjEyNiAqIFIgKyAwLjcxNTIgKiBHICsgMC4wNzIyICogQjtcbiAgICAgICAgcmV0dXJuIHJvdW5kRmxvYXQobHVtaW5hbmNlLCA0KTtcbiAgICB9XG4gICAgc3RhdGljIF9yZWxhdGl2ZUx1bWluYW5jZUZvckNvbXBvbmVudChjb2xvcikge1xuICAgICAgICBjb25zdCBjID0gY29sb3IgLyAyNTU7XG4gICAgICAgIHJldHVybiAoYyA8PSAwLjAzOTI4KSA/IGMgLyAxMi45MiA6IE1hdGgucG93KCgoYyArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcdGh0dHA6Ly8yNHdheXMub3JnLzIwMTAvY2FsY3VsYXRpbmctY29sb3ItY29udHJhc3RcbiAgICAgKiAgUmV0dXJuICd0cnVlJyBpZiBsaWdodGVyIGNvbG9yIG90aGVyd2lzZSAnZmFsc2UnXG4gICAgICovXG4gICAgaXNMaWdodGVyKCkge1xuICAgICAgICBjb25zdCB5aXEgPSAodGhpcy5yZ2JhLnIgKiAyOTkgKyB0aGlzLnJnYmEuZyAqIDU4NyArIHRoaXMucmdiYS5iICogMTE0KSAvIDEwMDA7XG4gICAgICAgIHJldHVybiB5aXEgPj0gMTI4O1xuICAgIH1cbiAgICBpc0xpZ2h0ZXJUaGFuKGFub3RoZXIpIHtcbiAgICAgICAgY29uc3QgbHVtMSA9IHRoaXMuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtcbiAgICAgICAgY29uc3QgbHVtMiA9IGFub3RoZXIuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIGx1bTEgPiBsdW0yO1xuICAgIH1cbiAgICBpc0RhcmtlclRoYW4oYW5vdGhlcikge1xuICAgICAgICBjb25zdCBsdW0xID0gdGhpcy5nZXRSZWxhdGl2ZUx1bWluYW5jZSgpO1xuICAgICAgICBjb25zdCBsdW0yID0gYW5vdGhlci5nZXRSZWxhdGl2ZUx1bWluYW5jZSgpO1xuICAgICAgICByZXR1cm4gbHVtMSA8IGx1bTI7XG4gICAgfVxuICAgIGxpZ2h0ZW4oZmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3IEhTTEEodGhpcy5oc2xhLmgsIHRoaXMuaHNsYS5zLCB0aGlzLmhzbGEubCArIHRoaXMuaHNsYS5sICogZmFjdG9yLCB0aGlzLmhzbGEuYSkpO1xuICAgIH1cbiAgICBkYXJrZW4oZmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3IEhTTEEodGhpcy5oc2xhLmgsIHRoaXMuaHNsYS5zLCB0aGlzLmhzbGEubCAtIHRoaXMuaHNsYS5sICogZmFjdG9yLCB0aGlzLmhzbGEuYSkpO1xuICAgIH1cbiAgICB0cmFuc3BhcmVudChmYWN0b3IpIHtcbiAgICAgICAgY29uc3QgeyByLCBnLCBiLCBhIH0gPSB0aGlzLnJnYmE7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3IFJHQkEociwgZywgYiwgYSAqIGZhY3RvcikpO1xuICAgIH1cbiAgICBpc1RyYW5zcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZ2JhLmEgPT09IDA7XG4gICAgfVxuICAgIGlzT3BhcXVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZ2JhLmEgPT09IDE7XG4gICAgfVxuICAgIG9wcG9zaXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ldyBSR0JBKDI1NSAtIHRoaXMucmdiYS5yLCAyNTUgLSB0aGlzLnJnYmEuZywgMjU1IC0gdGhpcy5yZ2JhLmIsIHRoaXMucmdiYS5hKSk7XG4gICAgfVxuICAgIG1ha2VPcGFxdWUob3BhcXVlQmFja2dyb3VuZCkge1xuICAgICAgICBpZiAodGhpcy5pc09wYXF1ZSgpIHx8IG9wYXF1ZUJhY2tncm91bmQucmdiYS5hICE9PSAxKSB7XG4gICAgICAgICAgICAvLyBvbmx5IGFsbG93IHRvIGJsZW5kIG9udG8gYSBub24tb3BhcXVlIGNvbG9yIG9udG8gYSBvcGFxdWUgY29sb3JcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgciwgZywgYiwgYSB9ID0gdGhpcy5yZ2JhO1xuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjIyODU0OC9maW5kaW5nLWVxdWl2YWxlbnQtY29sb3Itd2l0aC1vcGFjaXR5XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3IFJHQkEob3BhcXVlQmFja2dyb3VuZC5yZ2JhLnIgLSBhICogKG9wYXF1ZUJhY2tncm91bmQucmdiYS5yIC0gciksIG9wYXF1ZUJhY2tncm91bmQucmdiYS5nIC0gYSAqIChvcGFxdWVCYWNrZ3JvdW5kLnJnYmEuZyAtIGcpLCBvcGFxdWVCYWNrZ3JvdW5kLnJnYmEuYiAtIGEgKiAob3BhcXVlQmFja2dyb3VuZC5yZ2JhLmIgLSBiKSwgMSkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b1N0cmluZykge1xuICAgICAgICAgICAgdGhpcy5fdG9TdHJpbmcgPSBDb2xvci5Gb3JtYXQuQ1NTLmZvcm1hdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9TdHJpbmc7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRMaWdodGVyQ29sb3Iob2YsIHJlbGF0aXZlLCBmYWN0b3IpIHtcbiAgICAgICAgaWYgKG9mLmlzTGlnaHRlclRoYW4ocmVsYXRpdmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gb2Y7XG4gICAgICAgIH1cbiAgICAgICAgZmFjdG9yID0gZmFjdG9yID8gZmFjdG9yIDogMC41O1xuICAgICAgICBjb25zdCBsdW0xID0gb2YuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtcbiAgICAgICAgY29uc3QgbHVtMiA9IHJlbGF0aXZlLmdldFJlbGF0aXZlTHVtaW5hbmNlKCk7XG4gICAgICAgIGZhY3RvciA9IGZhY3RvciAqIChsdW0yIC0gbHVtMSkgLyBsdW0yO1xuICAgICAgICByZXR1cm4gb2YubGlnaHRlbihmYWN0b3IpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGFya2VyQ29sb3Iob2YsIHJlbGF0aXZlLCBmYWN0b3IpIHtcbiAgICAgICAgaWYgKG9mLmlzRGFya2VyVGhhbihyZWxhdGl2ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBvZjtcbiAgICAgICAgfVxuICAgICAgICBmYWN0b3IgPSBmYWN0b3IgPyBmYWN0b3IgOiAwLjU7XG4gICAgICAgIGNvbnN0IGx1bTEgPSBvZi5nZXRSZWxhdGl2ZUx1bWluYW5jZSgpO1xuICAgICAgICBjb25zdCBsdW0yID0gcmVsYXRpdmUuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtcbiAgICAgICAgZmFjdG9yID0gZmFjdG9yICogKGx1bTEgLSBsdW0yKSAvIGx1bTE7XG4gICAgICAgIHJldHVybiBvZi5kYXJrZW4oZmFjdG9yKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy53aGl0ZSA9IG5ldyBDb2xvcihuZXcgUkdCQSgyNTUsIDI1NSwgMjU1LCAxKSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmJsYWNrID0gbmV3IENvbG9yKG5ldyBSR0JBKDAsIDAsIDAsIDEpKTsgfVxuICAgIHN0YXRpYyB7IHRoaXMucmVkID0gbmV3IENvbG9yKG5ldyBSR0JBKDI1NSwgMCwgMCwgMSkpOyB9XG4gICAgc3RhdGljIHsgdGhpcy5ibHVlID0gbmV3IENvbG9yKG5ldyBSR0JBKDAsIDAsIDI1NSwgMSkpOyB9XG4gICAgc3RhdGljIHsgdGhpcy5ncmVlbiA9IG5ldyBDb2xvcihuZXcgUkdCQSgwLCAyNTUsIDAsIDEpKTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuY3lhbiA9IG5ldyBDb2xvcihuZXcgUkdCQSgwLCAyNTUsIDI1NSwgMSkpOyB9XG4gICAgc3RhdGljIHsgdGhpcy5saWdodGdyZXkgPSBuZXcgQ29sb3IobmV3IFJHQkEoMjExLCAyMTEsIDIxMSwgMSkpOyB9XG4gICAgc3RhdGljIHsgdGhpcy50cmFuc3BhcmVudCA9IG5ldyBDb2xvcihuZXcgUkdCQSgwLCAwLCAwLCAwKSk7IH1cbn1cbihmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICBsZXQgRm9ybWF0O1xuICAgIChmdW5jdGlvbiAoRm9ybWF0KSB7XG4gICAgICAgIGxldCBDU1M7XG4gICAgICAgIChmdW5jdGlvbiAoQ1NTKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRSR0IoY29sb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3IucmdiYS5hID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgcmdiKCR7Y29sb3IucmdiYS5yfSwgJHtjb2xvci5yZ2JhLmd9LCAke2NvbG9yLnJnYmEuYn0pYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yLkZvcm1hdC5DU1MuZm9ybWF0UkdCQShjb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDU1MuZm9ybWF0UkdCID0gZm9ybWF0UkdCO1xuICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0UkdCQShjb2xvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgcmdiYSgke2NvbG9yLnJnYmEucn0sICR7Y29sb3IucmdiYS5nfSwgJHtjb2xvci5yZ2JhLmJ9LCAkeysoY29sb3IucmdiYS5hKS50b0ZpeGVkKDIpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ1NTLmZvcm1hdFJHQkEgPSBmb3JtYXRSR0JBO1xuICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0SFNMKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yLmhzbGEuYSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYGhzbCgke2NvbG9yLmhzbGEuaH0sICR7KGNvbG9yLmhzbGEucyAqIDEwMCkudG9GaXhlZCgyKX0lLCAkeyhjb2xvci5oc2xhLmwgKiAxMDApLnRvRml4ZWQoMil9JSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sb3IuRm9ybWF0LkNTUy5mb3JtYXRIU0xBKGNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENTUy5mb3JtYXRIU0wgPSBmb3JtYXRIU0w7XG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRIU0xBKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBoc2xhKCR7Y29sb3IuaHNsYS5ofSwgJHsoY29sb3IuaHNsYS5zICogMTAwKS50b0ZpeGVkKDIpfSUsICR7KGNvbG9yLmhzbGEubCAqIDEwMCkudG9GaXhlZCgyKX0lLCAke2NvbG9yLmhzbGEuYS50b0ZpeGVkKDIpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ1NTLmZvcm1hdEhTTEEgPSBmb3JtYXRIU0xBO1xuICAgICAgICAgICAgZnVuY3Rpb24gX3RvVHdvRGlnaXRIZXgobikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBuLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gci5sZW5ndGggIT09IDIgPyAnMCcgKyByIDogcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9ybWF0cyB0aGUgY29sb3IgYXMgI1JSR0dCQlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRIZXgoY29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCMke190b1R3b0RpZ2l0SGV4KGNvbG9yLnJnYmEucil9JHtfdG9Ud29EaWdpdEhleChjb2xvci5yZ2JhLmcpfSR7X3RvVHdvRGlnaXRIZXgoY29sb3IucmdiYS5iKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ1NTLmZvcm1hdEhleCA9IGZvcm1hdEhleDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9ybWF0cyB0aGUgY29sb3IgYXMgI1JSR0dCQkFBXG4gICAgICAgICAgICAgKiBJZiAnY29tcGFjdCcgaXMgc2V0LCBjb2xvcnMgd2l0aG91dCB0cmFuc3BhcmFuY3kgd2lsbCBiZSBwcmludGVkIGFzICNSUkdHQkJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0SGV4QShjb2xvciwgY29tcGFjdCA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhY3QgJiYgY29sb3IucmdiYS5hID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb2xvci5Gb3JtYXQuQ1NTLmZvcm1hdEhleChjb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBgIyR7X3RvVHdvRGlnaXRIZXgoY29sb3IucmdiYS5yKX0ke190b1R3b0RpZ2l0SGV4KGNvbG9yLnJnYmEuZyl9JHtfdG9Ud29EaWdpdEhleChjb2xvci5yZ2JhLmIpfSR7X3RvVHdvRGlnaXRIZXgoTWF0aC5yb3VuZChjb2xvci5yZ2JhLmEgKiAyNTUpKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ1NTLmZvcm1hdEhleEEgPSBmb3JtYXRIZXhBO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZGVmYXVsdCBmb3JtYXQgd2lsbCB1c2UgSEVYIGlmIG9wYXF1ZSBhbmQgUkdCQSBvdGhlcndpc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdChjb2xvcikge1xuICAgICAgICAgICAgICAgIGlmIChjb2xvci5pc09wYXF1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb2xvci5Gb3JtYXQuQ1NTLmZvcm1hdEhleChjb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xvci5Gb3JtYXQuQ1NTLmZvcm1hdFJHQkEoY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ1NTLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydHMgYW4gSGV4IGNvbG9yIHZhbHVlIHRvIGEgQ29sb3IuXG4gICAgICAgICAgICAgKiByZXR1cm5zIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XVxuICAgICAgICAgICAgICogQHBhcmFtIGhleCBzdHJpbmcgKCNSR0IsICNSR0JBLCAjUlJHR0JCIG9yICNSUkdHQkJBQSkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlSGV4KGhleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGhleC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGV4LmNoYXJDb2RlQXQoMCkgIT09IDM1IC8qIENoYXJDb2RlLkhhc2ggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9lcyBub3QgYmVnaW4gd2l0aCBhICNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gI1JSR0dCQiBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IDE2ICogX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMSkpICsgX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMikpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnID0gMTYgKiBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgzKSkgKyBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSAxNiAqIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDUpKSArIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDYpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXcgUkdCQShyLCBnLCBiLCAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gI1JSR0dCQkFBIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gMTYgKiBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgxKSkgKyBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgyKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGcgPSAxNiAqIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDMpKSArIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDQpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IDE2ICogX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoNSkpICsgX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoNikpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gMTYgKiBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCg3KSkgKyBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCg4KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3IFJHQkEociwgZywgYiwgYSAvIDI1NSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICNSR0IgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgyKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3IFJHQkEoMTYgKiByICsgciwgMTYgKiBnICsgZywgMTYgKiBiICsgYikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICNSR0JBIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnID0gX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMikpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoNCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ldyBSR0JBKDE2ICogciArIHIsIDE2ICogZyArIGcsIDE2ICogYiArIGIsICgxNiAqIGEgKyBhKSAvIDI1NSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGNvbG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDU1MucGFyc2VIZXggPSBwYXJzZUhleDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9wYXJzZUhleERpZ2l0KGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ4IC8qIENoYXJDb2RlLkRpZ2l0MCAqLzogcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDkgLyogQ2hhckNvZGUuRGlnaXQxICovOiByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MCAvKiBDaGFyQ29kZS5EaWdpdDIgKi86IHJldHVybiAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDUxIC8qIENoYXJDb2RlLkRpZ2l0MyAqLzogcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTIgLyogQ2hhckNvZGUuRGlnaXQ0ICovOiByZXR1cm4gNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MyAvKiBDaGFyQ29kZS5EaWdpdDUgKi86IHJldHVybiA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU0IC8qIENoYXJDb2RlLkRpZ2l0NiAqLzogcmV0dXJuIDY7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTUgLyogQ2hhckNvZGUuRGlnaXQ3ICovOiByZXR1cm4gNztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1NiAvKiBDaGFyQ29kZS5EaWdpdDggKi86IHJldHVybiA4O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU3IC8qIENoYXJDb2RlLkRpZ2l0OSAqLzogcmV0dXJuIDk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTcgLyogQ2hhckNvZGUuYSAqLzogcmV0dXJuIDEwO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY1IC8qIENoYXJDb2RlLkEgKi86IHJldHVybiAxMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OCAvKiBDaGFyQ29kZS5iICovOiByZXR1cm4gMTE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjYgLyogQ2hhckNvZGUuQiAqLzogcmV0dXJuIDExO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk5IC8qIENoYXJDb2RlLmMgKi86IHJldHVybiAxMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2NyAvKiBDaGFyQ29kZS5DICovOiByZXR1cm4gMTI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAwIC8qIENoYXJDb2RlLmQgKi86IHJldHVybiAxMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OCAvKiBDaGFyQ29kZS5EICovOiByZXR1cm4gMTM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAxIC8qIENoYXJDb2RlLmUgKi86IHJldHVybiAxNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OSAvKiBDaGFyQ29kZS5FICovOiByZXR1cm4gMTQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAyIC8qIENoYXJDb2RlLmYgKi86IHJldHVybiAxNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3MCAvKiBDaGFyQ29kZS5GICovOiByZXR1cm4gMTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KShDU1MgPSBGb3JtYXQuQ1NTIHx8IChGb3JtYXQuQ1NTID0ge30pKTtcbiAgICB9KShGb3JtYXQgPSBDb2xvci5Gb3JtYXQgfHwgKENvbG9yLkZvcm1hdCA9IHt9KSk7XG59KShDb2xvciB8fCAoQ29sb3IgPSB7fSkpO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBEaWZmQ2hhbmdlIH0gZnJvbSAnLi9kaWZmQ2hhbmdlLmpzJztcbmltcG9ydCB7IHN0cmluZ0hhc2ggfSBmcm9tICcuLi9oYXNoLmpzJztcbmV4cG9ydCBjbGFzcyBTdHJpbmdEaWZmU2VxdWVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgZ2V0RWxlbWVudHMoKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBjb25zdCBjaGFyYWN0ZXJzID0gbmV3IEludDMyQXJyYXkoc291cmNlLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoYXJhY3RlcnNbaV0gPSBzb3VyY2UuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhcmFjdGVycztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRGlmZihvcmlnaW5hbCwgbW9kaWZpZWQsIHByZXR0eSkge1xuICAgIHJldHVybiBuZXcgTGNzRGlmZihuZXcgU3RyaW5nRGlmZlNlcXVlbmNlKG9yaWdpbmFsKSwgbmV3IFN0cmluZ0RpZmZTZXF1ZW5jZShtb2RpZmllZCkpLkNvbXB1dGVEaWZmKHByZXR0eSkuY2hhbmdlcztcbn1cbi8vXG4vLyBUaGUgY29kZSBiZWxvdyBoYXMgYmVlbiBwb3J0ZWQgZnJvbSBhIEMjIGltcGxlbWVudGF0aW9uIGluIFZTXG4vL1xuY2xhc3MgRGVidWcge1xuICAgIHN0YXRpYyBBc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBNeUFycmF5IHtcbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSByYW5nZSBvZiBlbGVtZW50cyBmcm9tIGFuIEFycmF5IHN0YXJ0aW5nIGF0IHRoZSBzcGVjaWZpZWQgc291cmNlIGluZGV4IGFuZCBwYXN0ZXNcbiAgICAgKiB0aGVtIHRvIGFub3RoZXIgQXJyYXkgc3RhcnRpbmcgYXQgdGhlIHNwZWNpZmllZCBkZXN0aW5hdGlvbiBpbmRleC4gVGhlIGxlbmd0aCBhbmQgdGhlIGluZGV4ZXNcbiAgICAgKiBhcmUgc3BlY2lmaWVkIGFzIDY0LWJpdCBpbnRlZ2Vycy5cbiAgICAgKiBzb3VyY2VBcnJheTpcbiAgICAgKlx0XHRUaGUgQXJyYXkgdGhhdCBjb250YWlucyB0aGUgZGF0YSB0byBjb3B5LlxuICAgICAqIHNvdXJjZUluZGV4OlxuICAgICAqXHRcdEEgNjQtYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBpbiB0aGUgc291cmNlQXJyYXkgYXQgd2hpY2ggY29weWluZyBiZWdpbnMuXG4gICAgICogZGVzdGluYXRpb25BcnJheTpcbiAgICAgKlx0XHRUaGUgQXJyYXkgdGhhdCByZWNlaXZlcyB0aGUgZGF0YS5cbiAgICAgKiBkZXN0aW5hdGlvbkluZGV4OlxuICAgICAqXHRcdEEgNjQtYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBpbiB0aGUgZGVzdGluYXRpb25BcnJheSBhdCB3aGljaCBzdG9yaW5nIGJlZ2lucy5cbiAgICAgKiBsZW5ndGg6XG4gICAgICpcdFx0QSA2NC1iaXQgaW50ZWdlciB0aGF0IHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjb3B5LlxuICAgICAqL1xuICAgIHN0YXRpYyBDb3B5KHNvdXJjZUFycmF5LCBzb3VyY2VJbmRleCwgZGVzdGluYXRpb25BcnJheSwgZGVzdGluYXRpb25JbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uQXJyYXlbZGVzdGluYXRpb25JbmRleCArIGldID0gc291cmNlQXJyYXlbc291cmNlSW5kZXggKyBpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgQ29weTIoc291cmNlQXJyYXksIHNvdXJjZUluZGV4LCBkZXN0aW5hdGlvbkFycmF5LCBkZXN0aW5hdGlvbkluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVzdGluYXRpb25BcnJheVtkZXN0aW5hdGlvbkluZGV4ICsgaV0gPSBzb3VyY2VBcnJheVtzb3VyY2VJbmRleCArIGldO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3Mgd2hpY2ggaGVscHMgdG8gY3JlYXRlIHRoZSBzZXQgb2YgRGlmZkNoYW5nZXMgZnJvbVxuICogYSBkaWZmZXJlbmNlIG9wZXJhdGlvbi4gVGhpcyBjbGFzcyBhY2NlcHRzIG9yaWdpbmFsIERpZmZFbGVtZW50cyBhbmRcbiAqIG1vZGlmaWVkIERpZmZFbGVtZW50cyB0aGF0IGFyZSBpbnZvbHZlZCBpbiBhIHBhcnRpY3VsYXIgY2hhbmdlLiBUaGVcbiAqIE1hcmtOZXh0Q2hhbmdlKCkgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gbWFyayB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuXG4gKiBkaXN0aW5jdCBjaGFuZ2VzLiBBdCB0aGUgZW5kLCB0aGUgQ2hhbmdlcyBwcm9wZXJ0eSBjYW4gYmUgY2FsbGVkIHRvIHJldHJpZXZlXG4gKiB0aGUgY29uc3RydWN0ZWQgY2hhbmdlcy5cbiAqL1xuY2xhc3MgRGlmZkNoYW5nZUhlbHBlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBEaWZmQ2hhbmdlSGVscGVyIGZvciB0aGUgZ2l2ZW4gRGlmZlNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tX2NoYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSAxMDczNzQxODI0IC8qIENvbnN0YW50cy5NQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovO1xuICAgICAgICB0aGlzLm1fbW9kaWZpZWRTdGFydCA9IDEwNzM3NDE4MjQgLyogQ29uc3RhbnRzLk1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XG4gICAgICAgIHRoaXMubV9vcmlnaW5hbENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkQ291bnQgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGNoYW5nZSBpbiB0aGUgc2V0IG9mIGRpZmZlcmVuY2VzLlxuICAgICAqL1xuICAgIE1hcmtOZXh0Q2hhbmdlKCkge1xuICAgICAgICAvLyBPbmx5IGFkZCB0byB0aGUgbGlzdCBpZiB0aGVyZSBpcyBzb21ldGhpbmcgdG8gYWRkXG4gICAgICAgIGlmICh0aGlzLm1fb3JpZ2luYWxDb3VudCA+IDAgfHwgdGhpcy5tX21vZGlmaWVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5ldyBjaGFuZ2UgdG8gb3VyIGxpc3RcbiAgICAgICAgICAgIHRoaXMubV9jaGFuZ2VzLnB1c2gobmV3IERpZmZDaGFuZ2UodGhpcy5tX29yaWdpbmFsU3RhcnQsIHRoaXMubV9vcmlnaW5hbENvdW50LCB0aGlzLm1fbW9kaWZpZWRTdGFydCwgdGhpcy5tX21vZGlmaWVkQ291bnQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCBmb3IgdGhlIG5leHQgY2hhbmdlXG4gICAgICAgIHRoaXMubV9vcmlnaW5hbENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkQ291bnQgPSAwO1xuICAgICAgICB0aGlzLm1fb3JpZ2luYWxTdGFydCA9IDEwNzM3NDE4MjQgLyogQ29uc3RhbnRzLk1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XG4gICAgICAgIHRoaXMubV9tb2RpZmllZFN0YXJ0ID0gMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUFYX1NBRkVfU01BTExfSU5URUdFUiAqLztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgb3JpZ2luYWwgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gdG8gdGhlIGVsZW1lbnRzXG4gICAgICogYWZmZWN0ZWQgYnkgdGhlIGN1cnJlbnQgY2hhbmdlLiBUaGUgbW9kaWZpZWQgaW5kZXggZ2l2ZXMgY29udGV4dFxuICAgICAqIHRvIHRoZSBjaGFuZ2UgcG9zaXRpb24gd2l0aCByZXNwZWN0IHRvIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxJbmRleCBUaGUgaW5kZXggb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdG8gYWRkLlxuICAgICAqIEBwYXJhbSBtb2RpZmllZEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbW9kaWZpZWQgZWxlbWVudCB0aGF0IHByb3ZpZGVzIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24gaW4gdGhlIG1vZGlmaWVkIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIEFkZE9yaWdpbmFsRWxlbWVudChvcmlnaW5hbEluZGV4LCBtb2RpZmllZEluZGV4KSB7XG4gICAgICAgIC8vIFRoZSAndHJ1ZScgc3RhcnQgaW5kZXggaXMgdGhlIHNtYWxsZXN0IG9mIHRoZSBvbmVzIHdlJ3ZlIHNlZW5cbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSBNYXRoLm1pbih0aGlzLm1fb3JpZ2luYWxTdGFydCwgb3JpZ2luYWxJbmRleCk7XG4gICAgICAgIHRoaXMubV9tb2RpZmllZFN0YXJ0ID0gTWF0aC5taW4odGhpcy5tX21vZGlmaWVkU3RhcnQsIG1vZGlmaWVkSW5kZXgpO1xuICAgICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCsrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBtb2RpZmllZCBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiB0byB0aGUgZWxlbWVudHNcbiAgICAgKiBhZmZlY3RlZCBieSB0aGUgY3VycmVudCBjaGFuZ2UuIFRoZSBvcmlnaW5hbCBpbmRleCBnaXZlcyBjb250ZXh0XG4gICAgICogdG8gdGhlIGNoYW5nZSBwb3NpdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG1vZGlmaWVkIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudCB0aGF0IHByb3ZpZGVzIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24gaW4gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSBtb2RpZmllZEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbW9kaWZpZWQgZWxlbWVudCB0byBhZGQuXG4gICAgICovXG4gICAgQWRkTW9kaWZpZWRFbGVtZW50KG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhlICd0cnVlJyBzdGFydCBpbmRleCBpcyB0aGUgc21hbGxlc3Qgb2YgdGhlIG9uZXMgd2UndmUgc2VlblxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxTdGFydCA9IE1hdGgubWluKHRoaXMubV9vcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEluZGV4KTtcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkU3RhcnQgPSBNYXRoLm1pbih0aGlzLm1fbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRJbmRleCk7XG4gICAgICAgIHRoaXMubV9tb2RpZmllZENvdW50Kys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgb2YgdGhlIGNoYW5nZXMgbWFya2VkIGJ5IHRoZSBjbGFzcy5cbiAgICAgKi9cbiAgICBnZXRDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5tX29yaWdpbmFsQ291bnQgPiAwIHx8IHRoaXMubV9tb2RpZmllZENvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8gRmluaXNoIHVwIG9uIHdoYXRldmVyIGlzIGxlZnRcbiAgICAgICAgICAgIHRoaXMuTWFya05leHRDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tX2NoYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgb2YgdGhlIGNoYW5nZXMgbWFya2VkIGJ5IHRoZSBjbGFzcyBpbiB0aGUgcmV2ZXJzZSBvcmRlclxuICAgICAqL1xuICAgIGdldFJldmVyc2VDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5tX29yaWdpbmFsQ291bnQgPiAwIHx8IHRoaXMubV9tb2RpZmllZENvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8gRmluaXNoIHVwIG9uIHdoYXRldmVyIGlzIGxlZnRcbiAgICAgICAgICAgIHRoaXMuTWFya05leHRDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1fY2hhbmdlcy5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm1fY2hhbmdlcztcbiAgICB9XG59XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBkaWZmZXJlbmNlIGFsZ29yaXRobSBkZXNjcmliZWQgaW5cbiAqIFwiQW4gTyhORCkgRGlmZmVyZW5jZSBBbGdvcml0aG0gYW5kIGl0cyB2YXJpYXRpb25zXCIgYnkgRXVnZW5lIFcuIE15ZXJzXG4gKi9cbmV4cG9ydCBjbGFzcyBMY3NEaWZmIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIHRoZSBEaWZmRmluZGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWxTZXF1ZW5jZSwgbW9kaWZpZWRTZXF1ZW5jZSwgY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlID0gbnVsbCkge1xuICAgICAgICB0aGlzLkNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSA9IGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxTZXF1ZW5jZSA9IG9yaWdpbmFsU2VxdWVuY2U7XG4gICAgICAgIHRoaXMuX21vZGlmaWVkU2VxdWVuY2UgPSBtb2RpZmllZFNlcXVlbmNlO1xuICAgICAgICBjb25zdCBbb3JpZ2luYWxTdHJpbmdFbGVtZW50cywgb3JpZ2luYWxFbGVtZW50c09ySGFzaCwgb3JpZ2luYWxIYXNTdHJpbmdzXSA9IExjc0RpZmYuX2dldEVsZW1lbnRzKG9yaWdpbmFsU2VxdWVuY2UpO1xuICAgICAgICBjb25zdCBbbW9kaWZpZWRTdHJpbmdFbGVtZW50cywgbW9kaWZpZWRFbGVtZW50c09ySGFzaCwgbW9kaWZpZWRIYXNTdHJpbmdzXSA9IExjc0RpZmYuX2dldEVsZW1lbnRzKG1vZGlmaWVkU2VxdWVuY2UpO1xuICAgICAgICB0aGlzLl9oYXNTdHJpbmdzID0gKG9yaWdpbmFsSGFzU3RyaW5ncyAmJiBtb2RpZmllZEhhc1N0cmluZ3MpO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzID0gb3JpZ2luYWxTdHJpbmdFbGVtZW50cztcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaCA9IG9yaWdpbmFsRWxlbWVudHNPckhhc2g7XG4gICAgICAgIHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHMgPSBtb2RpZmllZFN0cmluZ0VsZW1lbnRzO1xuICAgICAgICB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoID0gbW9kaWZpZWRFbGVtZW50c09ySGFzaDtcbiAgICAgICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeSA9IFtdO1xuICAgIH1cbiAgICBzdGF0aWMgX2lzU3RyaW5nQXJyYXkoYXJyKSB7XG4gICAgICAgIHJldHVybiAoYXJyLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyclswXSA9PT0gJ3N0cmluZycpO1xuICAgIH1cbiAgICBzdGF0aWMgX2dldEVsZW1lbnRzKHNlcXVlbmNlKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gc2VxdWVuY2UuZ2V0RWxlbWVudHMoKTtcbiAgICAgICAgaWYgKExjc0RpZmYuX2lzU3RyaW5nQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoZXMgPSBuZXcgSW50MzJBcnJheShlbGVtZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaGFzaGVzW2ldID0gc3RyaW5nSGFzaChlbGVtZW50c1tpXSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnRzLCBoYXNoZXMsIHRydWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50cyBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbW10sIGVsZW1lbnRzLCBmYWxzZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtbXSwgbmV3IEludDMyQXJyYXkoZWxlbWVudHMpLCBmYWxzZV07XG4gICAgfVxuICAgIEVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxJbmRleCwgbmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2hbb3JpZ2luYWxJbmRleF0gIT09IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2hbbmV3SW5kZXhdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNTdHJpbmdzID8gdGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tvcmlnaW5hbEluZGV4XSA9PT0gdGhpcy5fbW9kaWZpZWRTdHJpbmdFbGVtZW50c1tuZXdJbmRleF0gOiB0cnVlKTtcbiAgICB9XG4gICAgRWxlbWVudHNBcmVTdHJpY3RFcXVhbChvcmlnaW5hbEluZGV4LCBuZXdJbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbEluZGV4LCBuZXdJbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbEVsZW1lbnQgPSBMY3NEaWZmLl9nZXRTdHJpY3RFbGVtZW50KHRoaXMuX29yaWdpbmFsU2VxdWVuY2UsIG9yaWdpbmFsSW5kZXgpO1xuICAgICAgICBjb25zdCBtb2RpZmllZEVsZW1lbnQgPSBMY3NEaWZmLl9nZXRTdHJpY3RFbGVtZW50KHRoaXMuX21vZGlmaWVkU2VxdWVuY2UsIG5ld0luZGV4KTtcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbEVsZW1lbnQgPT09IG1vZGlmaWVkRWxlbWVudCk7XG4gICAgfVxuICAgIHN0YXRpYyBfZ2V0U3RyaWN0RWxlbWVudChzZXF1ZW5jZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXF1ZW5jZS5nZXRTdHJpY3RFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VxdWVuY2UuZ2V0U3RyaWN0RWxlbWVudChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIE9yaWdpbmFsRWxlbWVudHNBcmVFcXVhbChpbmRleDEsIGluZGV4Mikge1xuICAgICAgICBpZiAodGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaFtpbmRleDFdICE9PSB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoW2luZGV4Ml0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc1N0cmluZ3MgPyB0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzW2luZGV4MV0gPT09IHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbaW5kZXgyXSA6IHRydWUpO1xuICAgIH1cbiAgICBNb2RpZmllZEVsZW1lbnRzQXJlRXF1YWwoaW5kZXgxLCBpbmRleDIpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2hbaW5kZXgxXSAhPT0gdGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaFtpbmRleDJdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNTdHJpbmdzID8gdGhpcy5fbW9kaWZpZWRTdHJpbmdFbGVtZW50c1tpbmRleDFdID09PSB0aGlzLl9tb2RpZmllZFN0cmluZ0VsZW1lbnRzW2luZGV4Ml0gOiB0cnVlKTtcbiAgICB9XG4gICAgQ29tcHV0ZURpZmYocHJldHR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9Db21wdXRlRGlmZigwLCB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoLmxlbmd0aCAtIDEsIDAsIHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2gubGVuZ3RoIC0gMSwgcHJldHR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIG9yaWdpbmFsIGFuZCBtb2RpZmllZCBpbnB1dFxuICAgICAqIHNlcXVlbmNlcyBvbiB0aGUgYm91bmRlZCByYW5nZS5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgdHdvIGlucHV0IHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBfQ29tcHV0ZURpZmYob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBwcmV0dHkpIHtcbiAgICAgICAgY29uc3QgcXVpdEVhcmx5QXJyID0gW2ZhbHNlXTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSB0aGlzLkNvbXB1dGVEaWZmUmVjdXJzaXZlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCwgcXVpdEVhcmx5QXJyKTtcbiAgICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBjbGVhbiB1cCB0aGUgY29tcHV0ZWQgZGlmZiB0byBiZSBtb3JlIGludHVpdGl2ZVxuICAgICAgICAgICAgLy8gYnV0IGl0IHR1cm5zIG91dCB0aGlzIGNhbm5vdCBiZSBkb25lIGNvcnJlY3RseSB1bnRpbCB0aGUgZW50aXJlIHNldFxuICAgICAgICAgICAgLy8gb2YgZGlmZnMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gICAgICAgICAgICBjaGFuZ2VzID0gdGhpcy5QcmV0dGlmeUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHF1aXRFYXJseTogcXVpdEVhcmx5QXJyWzBdLFxuICAgICAgICAgICAgY2hhbmdlczogY2hhbmdlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGhlbHBlciBtZXRob2Qgd2hpY2ggY29tcHV0ZXMgdGhlIGRpZmZlcmVuY2VzIG9uIHRoZSBib3VuZGVkIHJhbmdlXG4gICAgICogcmVjdXJzaXZlbHkuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIHR3byBpbnB1dCBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgQ29tcHV0ZURpZmZSZWN1cnNpdmUob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBxdWl0RWFybHlBcnIpIHtcbiAgICAgICAgcXVpdEVhcmx5QXJyWzBdID0gZmFsc2U7XG4gICAgICAgIC8vIEZpbmQgdGhlIHN0YXJ0IG9mIHRoZSBkaWZmZXJlbmNlc1xuICAgICAgICB3aGlsZSAob3JpZ2luYWxTdGFydCA8PSBvcmlnaW5hbEVuZCAmJiBtb2RpZmllZFN0YXJ0IDw9IG1vZGlmaWVkRW5kICYmIHRoaXMuRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbFN0YXJ0LCBtb2RpZmllZFN0YXJ0KSkge1xuICAgICAgICAgICAgb3JpZ2luYWxTdGFydCsrO1xuICAgICAgICAgICAgbW9kaWZpZWRTdGFydCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGVuZCBvZiB0aGUgZGlmZmVyZW5jZXNcbiAgICAgICAgd2hpbGUgKG9yaWdpbmFsRW5kID49IG9yaWdpbmFsU3RhcnQgJiYgbW9kaWZpZWRFbmQgPj0gbW9kaWZpZWRTdGFydCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKSkge1xuICAgICAgICAgICAgb3JpZ2luYWxFbmQtLTtcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kLS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gdGhlIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBlaXRoZXIgaGF2ZSBhbGwgaW5zZXJ0aW9ucyBvciBhbGwgZGVsZXRpb25zIG9yIHRoZSBzZXF1ZW5jZXMgYXJlIGlkZW50aWNhbFxuICAgICAgICBpZiAob3JpZ2luYWxTdGFydCA+IG9yaWdpbmFsRW5kIHx8IG1vZGlmaWVkU3RhcnQgPiBtb2RpZmllZEVuZCkge1xuICAgICAgICAgICAgbGV0IGNoYW5nZXM7XG4gICAgICAgICAgICBpZiAobW9kaWZpZWRTdGFydCA8PSBtb2RpZmllZEVuZCkge1xuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChvcmlnaW5hbFN0YXJ0ID09PSBvcmlnaW5hbEVuZCArIDEsICdvcmlnaW5hbFN0YXJ0IHNob3VsZCBvbmx5IGJlIG9uZSBtb3JlIHRoYW4gb3JpZ2luYWxFbmQnKTtcbiAgICAgICAgICAgICAgICAvLyBBbGwgaW5zZXJ0aW9uc1xuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIDAsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCArIDEpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWdpbmFsU3RhcnQgPD0gb3JpZ2luYWxFbmQpIHtcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQobW9kaWZpZWRTdGFydCA9PT0gbW9kaWZpZWRFbmQgKyAxLCAnbW9kaWZpZWRTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG1vZGlmaWVkRW5kJyk7XG4gICAgICAgICAgICAgICAgLy8gQWxsIGRlbGV0aW9uc1xuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCArIDEsIG1vZGlmaWVkU3RhcnQsIDApXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChvcmlnaW5hbFN0YXJ0ID09PSBvcmlnaW5hbEVuZCArIDEsICdvcmlnaW5hbFN0YXJ0IHNob3VsZCBvbmx5IGJlIG9uZSBtb3JlIHRoYW4gb3JpZ2luYWxFbmQnKTtcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQobW9kaWZpZWRTdGFydCA9PT0gbW9kaWZpZWRFbmQgKyAxLCAnbW9kaWZpZWRTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG1vZGlmaWVkRW5kJyk7XG4gICAgICAgICAgICAgICAgLy8gSWRlbnRpY2FsIHNlcXVlbmNlcyAtIE5vIGRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBwcm9ibGVtIGNhbiBiZSBzb2x2ZWQgdXNpbmcgdGhlIERpdmlkZS1BbmQtQ29ucXVlciB0ZWNobmlxdWUuXG4gICAgICAgIGNvbnN0IG1pZE9yaWdpbmFsQXJyID0gWzBdO1xuICAgICAgICBjb25zdCBtaWRNb2RpZmllZEFyciA9IFswXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5Db21wdXRlUmVjdXJzaW9uUG9pbnQob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBtaWRPcmlnaW5hbEFyciwgbWlkTW9kaWZpZWRBcnIsIHF1aXRFYXJseUFycik7XG4gICAgICAgIGNvbnN0IG1pZE9yaWdpbmFsID0gbWlkT3JpZ2luYWxBcnJbMF07XG4gICAgICAgIGNvbnN0IG1pZE1vZGlmaWVkID0gbWlkTW9kaWZpZWRBcnJbMF07XG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFJlc3VsdCBpcyBub3QtbnVsbCB3aGVuIHRoZXJlIHdhcyBlbm91Z2ggbWVtb3J5IHRvIGNvbXB1dGUgdGhlIGNoYW5nZXMgd2hpbGVcbiAgICAgICAgICAgIC8vIHNlYXJjaGluZyBmb3IgdGhlIHJlY3Vyc2lvbiBwb2ludFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcXVpdEVhcmx5QXJyWzBdKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4gYnJlYWsgdGhlIHByb2JsZW0gZG93biByZWN1cnNpdmVseSBieSBmaW5kaW5nIHRoZSBjaGFuZ2VzIGluIHRoZVxuICAgICAgICAgICAgLy8gRmlyc3QgSGFsZjogICAob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydCkgdG8gKG1pZE9yaWdpbmFsLCBtaWRNb2RpZmllZClcbiAgICAgICAgICAgIC8vIFNlY29uZCBIYWxmOiAgKG1pZE9yaWdpbmFsICsgMSwgbWluTW9kaWZpZWQgKyAxKSB0byAob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKVxuICAgICAgICAgICAgLy8gTk9URTogQ29tcHV0ZURpZmYoKSBpcyBpbmNsdXNpdmUsIHRoZXJlZm9yZSB0aGUgc2Vjb25kIHJhbmdlIHN0YXJ0cyBvbiB0aGUgbmV4dCBwb2ludFxuICAgICAgICAgICAgY29uc3QgbGVmdENoYW5nZXMgPSB0aGlzLkNvbXB1dGVEaWZmUmVjdXJzaXZlKG9yaWdpbmFsU3RhcnQsIG1pZE9yaWdpbmFsLCBtb2RpZmllZFN0YXJ0LCBtaWRNb2RpZmllZCwgcXVpdEVhcmx5QXJyKTtcbiAgICAgICAgICAgIGxldCByaWdodENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGlmICghcXVpdEVhcmx5QXJyWzBdKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRDaGFuZ2VzID0gdGhpcy5Db21wdXRlRGlmZlJlY3Vyc2l2ZShtaWRPcmlnaW5hbCArIDEsIG9yaWdpbmFsRW5kLCBtaWRNb2RpZmllZCArIDEsIG1vZGlmaWVkRW5kLCBxdWl0RWFybHlBcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZGlkbid0IGhhdmUgdGltZSB0byBmaW5pc2ggdGhlIGZpcnN0IGhhbGYsIHNvIHdlIGRvbid0IGhhdmUgdGltZSB0byBjb21wdXRlIHRoaXMgaGFsZi5cbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciB0aGUgZW50aXJlIHJlc3Qgb2YgdGhlIHNlcXVlbmNlIGRpZmZlcmVudC5cbiAgICAgICAgICAgICAgICByaWdodENoYW5nZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG1pZE9yaWdpbmFsICsgMSwgb3JpZ2luYWxFbmQgLSAobWlkT3JpZ2luYWwgKyAxKSArIDEsIG1pZE1vZGlmaWVkICsgMSwgbW9kaWZpZWRFbmQgLSAobWlkTW9kaWZpZWQgKyAxKSArIDEpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNvbmNhdGVuYXRlQ2hhbmdlcyhsZWZ0Q2hhbmdlcywgcmlnaHRDaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoaXQgaGVyZSwgd2UgcXVpdCBlYXJseSwgYW5kIHNvIGNhbid0IHJldHVybiBhbnl0aGluZyBtZWFuaW5nZnVsXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCAtIG9yaWdpbmFsU3RhcnQgKyAxLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQgKyAxKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBXQUxLVFJBQ0UoZGlhZ29uYWxGb3J3YXJkQmFzZSwgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIGRpYWdvbmFsRm9yd2FyZEVuZCwgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0LCBkaWFnb25hbFJldmVyc2VCYXNlLCBkaWFnb25hbFJldmVyc2VTdGFydCwgZGlhZ29uYWxSZXZlcnNlRW5kLCBkaWFnb25hbFJldmVyc2VPZmZzZXQsIGZvcndhcmRQb2ludHMsIHJldmVyc2VQb2ludHMsIG9yaWdpbmFsSW5kZXgsIG9yaWdpbmFsRW5kLCBtaWRPcmlnaW5hbEFyciwgbW9kaWZpZWRJbmRleCwgbW9kaWZpZWRFbmQsIG1pZE1vZGlmaWVkQXJyLCBkZWx0YUlzRXZlbiwgcXVpdEVhcmx5QXJyKSB7XG4gICAgICAgIGxldCBmb3J3YXJkQ2hhbmdlcyA9IG51bGw7XG4gICAgICAgIGxldCByZXZlcnNlQ2hhbmdlcyA9IG51bGw7XG4gICAgICAgIC8vIEZpcnN0LCB3YWxrIGJhY2t3YXJkIHRocm91Z2ggdGhlIGZvcndhcmQgZGlhZ29uYWxzIGhpc3RvcnlcbiAgICAgICAgbGV0IGNoYW5nZUhlbHBlciA9IG5ldyBEaWZmQ2hhbmdlSGVscGVyKCk7XG4gICAgICAgIGxldCBkaWFnb25hbE1pbiA9IGRpYWdvbmFsRm9yd2FyZFN0YXJ0O1xuICAgICAgICBsZXQgZGlhZ29uYWxNYXggPSBkaWFnb25hbEZvcndhcmRFbmQ7XG4gICAgICAgIGxldCBkaWFnb25hbFJlbGF0aXZlID0gKG1pZE9yaWdpbmFsQXJyWzBdIC0gbWlkTW9kaWZpZWRBcnJbMF0pIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0O1xuICAgICAgICBsZXQgbGFzdE9yaWdpbmFsSW5kZXggPSAtMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUlOX1NBRkVfU01BTExfSU5URUdFUiAqLztcbiAgICAgICAgbGV0IGhpc3RvcnlJbmRleCA9IHRoaXMubV9mb3J3YXJkSGlzdG9yeS5sZW5ndGggLSAxO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGRpYWdvbmFsIGluZGV4IGZyb20gdGhlIHJlbGF0aXZlIGRpYWdvbmFsIG51bWJlclxuICAgICAgICAgICAgY29uc3QgZGlhZ29uYWwgPSBkaWFnb25hbFJlbGF0aXZlICsgZGlhZ29uYWxGb3J3YXJkQmFzZTtcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hlcmUgd2UgY2FtZSBmcm9tXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWwgPT09IGRpYWdvbmFsTWluIHx8IChkaWFnb25hbCA8IGRpYWdvbmFsTWF4ICYmIGZvcndhcmRQb2ludHNbZGlhZ29uYWwgLSAxXSA8IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBsaW5lICh0aGUgZWxlbWVudCBpcyBhbiBpbnNlcnQpXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXTtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIGRpYWdvbmFsUmVsYXRpdmUgLSBkaWFnb25hbEZvcndhcmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPCBsYXN0T3JpZ2luYWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuTWFya05leHRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRNb2RpZmllZEVsZW1lbnQob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAoZGlhZ29uYWwgKyAxKSAtIGRpYWdvbmFsRm9yd2FyZEJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBsaW5lICh0aGUgZWxlbWVudCBpcyBhIGRlbGV0aW9uKVxuICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gKyAxO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsRm9yd2FyZE9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCA8IGxhc3RPcmlnaW5hbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5NYXJrTmV4dENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXggLSAxO1xuICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRPcmlnaW5hbEVsZW1lbnQob3JpZ2luYWxJbmRleCwgbW9kaWZpZWRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAoZGlhZ29uYWwgLSAxKSAtIGRpYWdvbmFsRm9yd2FyZEJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhpc3RvcnlJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yd2FyZFBvaW50cyA9IHRoaXMubV9mb3J3YXJkSGlzdG9yeVtoaXN0b3J5SW5kZXhdO1xuICAgICAgICAgICAgICAgIGRpYWdvbmFsRm9yd2FyZEJhc2UgPSBmb3J3YXJkUG9pbnRzWzBdOyAvL1dlIHN0b3JlZCB0aGlzIGluIHRoZSBmaXJzdCBzcG90XG4gICAgICAgICAgICAgICAgZGlhZ29uYWxNaW4gPSAxO1xuICAgICAgICAgICAgICAgIGRpYWdvbmFsTWF4ID0gZm9yd2FyZFBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgtLWhpc3RvcnlJbmRleCA+PSAtMSk7XG4gICAgICAgIC8vIElyb25pY2FsbHksIHdlIGdldCB0aGUgZm9yd2FyZCBjaGFuZ2VzIGFzIHRoZSByZXZlcnNlIG9mIHRoZVxuICAgICAgICAvLyBvcmRlciB3ZSBhZGRlZCB0aGVtIHNpbmNlIHdlIHRlY2huaWNhbGx5IGFkZGVkIHRoZW0gYmFja3dhcmRzXG4gICAgICAgIGZvcndhcmRDaGFuZ2VzID0gY2hhbmdlSGVscGVyLmdldFJldmVyc2VDaGFuZ2VzKCk7XG4gICAgICAgIGlmIChxdWl0RWFybHlBcnJbMF0pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IENhbGN1bGF0ZSBhIHBhcnRpYWwgZnJvbSB0aGUgcmV2ZXJzZSBkaWFnb25hbHMuXG4gICAgICAgICAgICAvLyAgICAgICBGb3Igbm93LCBqdXN0IGFzc3VtZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBtaWRPcmlnaW5hbC9taWRNb2RpZmllZCBwb2ludCBpcyBhIGRpZmZcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFN0YXJ0UG9pbnQgPSBtaWRPcmlnaW5hbEFyclswXSArIDE7XG4gICAgICAgICAgICBsZXQgbW9kaWZpZWRTdGFydFBvaW50ID0gbWlkTW9kaWZpZWRBcnJbMF0gKyAxO1xuICAgICAgICAgICAgaWYgKGZvcndhcmRDaGFuZ2VzICE9PSBudWxsICYmIGZvcndhcmRDaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Rm9yd2FyZENoYW5nZSA9IGZvcndhcmRDaGFuZ2VzW2ZvcndhcmRDaGFuZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRQb2ludCA9IE1hdGgubWF4KG9yaWdpbmFsU3RhcnRQb2ludCwgbGFzdEZvcndhcmRDaGFuZ2UuZ2V0T3JpZ2luYWxFbmQoKSk7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydFBvaW50ID0gTWF0aC5tYXgobW9kaWZpZWRTdGFydFBvaW50LCBsYXN0Rm9yd2FyZENoYW5nZS5nZXRNb2RpZmllZEVuZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldmVyc2VDaGFuZ2VzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnRQb2ludCwgb3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0UG9pbnQgKyAxLCBtb2RpZmllZFN0YXJ0UG9pbnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydFBvaW50ICsgMSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3cgd2FsayBiYWNrd2FyZCB0aHJvdWdoIHRoZSByZXZlcnNlIGRpYWdvbmFscyBoaXN0b3J5XG4gICAgICAgICAgICBjaGFuZ2VIZWxwZXIgPSBuZXcgRGlmZkNoYW5nZUhlbHBlcigpO1xuICAgICAgICAgICAgZGlhZ29uYWxNaW4gPSBkaWFnb25hbFJldmVyc2VTdGFydDtcbiAgICAgICAgICAgIGRpYWdvbmFsTWF4ID0gZGlhZ29uYWxSZXZlcnNlRW5kO1xuICAgICAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IChtaWRPcmlnaW5hbEFyclswXSAtIG1pZE1vZGlmaWVkQXJyWzBdKSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDtcbiAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUFYX1NBRkVfU01BTExfSU5URUdFUiAqLztcbiAgICAgICAgICAgIGhpc3RvcnlJbmRleCA9IChkZWx0YUlzRXZlbikgPyB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkubGVuZ3RoIC0gMSA6IHRoaXMubV9yZXZlcnNlSGlzdG9yeS5sZW5ndGggLSAyO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGlhZ29uYWwgaW5kZXggZnJvbSB0aGUgcmVsYXRpdmUgZGlhZ29uYWwgbnVtYmVyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlhZ29uYWwgPSBkaWFnb25hbFJlbGF0aXZlICsgZGlhZ29uYWxSZXZlcnNlQmFzZTtcbiAgICAgICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoZXJlIHdlIGNhbWUgZnJvbVxuICAgICAgICAgICAgICAgIGlmIChkaWFnb25hbCA9PT0gZGlhZ29uYWxNaW4gfHwgKGRpYWdvbmFsIDwgZGlhZ29uYWxNYXggJiYgcmV2ZXJzZVBvaW50c1tkaWFnb25hbCAtIDFdID49IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBsaW5lICh0aGUgZWxlbWVudCBpcyBhIGRlbGV0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPiBsYXN0T3JpZ2luYWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLkFkZE9yaWdpbmFsRWxlbWVudChvcmlnaW5hbEluZGV4ICsgMSwgbW9kaWZpZWRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gKGRpYWdvbmFsICsgMSkgLSBkaWFnb25hbFJldmVyc2VCYXNlOyAvL1NldHVwIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcnRpY2FsIGxpbmUgKHRoZSBlbGVtZW50IGlzIGFuIGluc2VydGlvbilcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSBkaWFnb25hbFJlbGF0aXZlIC0gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCA+IGxhc3RPcmlnaW5hbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuTWFya05leHRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRNb2RpZmllZEVsZW1lbnQob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IChkaWFnb25hbCAtIDEpIC0gZGlhZ29uYWxSZXZlcnNlQmFzZTsgLy9TZXR1cCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoaXN0b3J5SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlUG9pbnRzID0gdGhpcy5tX3JldmVyc2VIaXN0b3J5W2hpc3RvcnlJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsUmV2ZXJzZUJhc2UgPSByZXZlcnNlUG9pbnRzWzBdOyAvL1dlIHN0b3JlZCB0aGlzIGluIHRoZSBmaXJzdCBzcG90XG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsTWluID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxNYXggPSByZXZlcnNlUG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoLS1oaXN0b3J5SW5kZXggPj0gLTEpO1xuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoZSByZXZlcnNlIGhpc3Rvcnkgd2lsbCBmaW5kIGRpZmZzIHRoYXRcbiAgICAgICAgICAgIC8vIGFyZSBjb3JyZWN0LCBidXQgbm90IGludHVpdGl2ZSwgc28gd2UgbmVlZCBzaGlmdCB0aGVtLlxuICAgICAgICAgICAgcmV2ZXJzZUNoYW5nZXMgPSBjaGFuZ2VIZWxwZXIuZ2V0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLkNvbmNhdGVuYXRlQ2hhbmdlcyhmb3J3YXJkQ2hhbmdlcywgcmV2ZXJzZUNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgcmFuZ2UgdG8gY29tcHV0ZSB0aGUgZGlmZiBvbiwgdGhpcyBtZXRob2QgZmluZHMgdGhlIHBvaW50OlxuICAgICAqIChtaWRPcmlnaW5hbCwgbWlkTW9kaWZpZWQpXG4gICAgICogdGhhdCBleGlzdHMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgTENTIG9mIHRoZSB0d28gc2VxdWVuY2VzIGFuZFxuICAgICAqIGlzIHRoZSBwb2ludCBhdCB3aGljaCB0aGUgTENTIHByb2JsZW0gbWF5IGJlIGJyb2tlbiBkb3duIHJlY3Vyc2l2ZWx5LlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgdHJ5IHRvIGtlZXAgdGhlIExDUyB0cmFjZSBpbiBtZW1vcnkuIElmIHRoZSBMQ1MgcmVjdXJzaW9uXG4gICAgICogcG9pbnQgaXMgY2FsY3VsYXRlZCBhbmQgdGhlIGZ1bGwgdHJhY2UgaXMgYXZhaWxhYmxlIGluIG1lbW9yeSwgdGhlbiB0aGlzIG1ldGhvZFxuICAgICAqIHdpbGwgcmV0dXJuIHRoZSBjaGFuZ2UgbGlzdC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxTdGFydCBUaGUgc3RhcnQgYm91bmQgb2YgdGhlIG9yaWdpbmFsIHNlcXVlbmNlIHJhbmdlXG4gICAgICogQHBhcmFtIG9yaWdpbmFsRW5kIFRoZSBlbmQgYm91bmQgb2YgdGhlIG9yaWdpbmFsIHNlcXVlbmNlIHJhbmdlXG4gICAgICogQHBhcmFtIG1vZGlmaWVkU3RhcnQgVGhlIHN0YXJ0IGJvdW5kIG9mIHRoZSBtb2RpZmllZCBzZXF1ZW5jZSByYW5nZVxuICAgICAqIEBwYXJhbSBtb2RpZmllZEVuZCBUaGUgZW5kIGJvdW5kIG9mIHRoZSBtb2RpZmllZCBzZXF1ZW5jZSByYW5nZVxuICAgICAqIEBwYXJhbSBtaWRPcmlnaW5hbCBUaGUgbWlkZGxlIHBvaW50IG9mIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSByYW5nZVxuICAgICAqIEBwYXJhbSBtaWRNb2RpZmllZCBUaGUgbWlkZGxlIHBvaW50IG9mIHRoZSBtb2RpZmllZCBzZXF1ZW5jZSByYW5nZVxuICAgICAqIEByZXR1cm5zIFRoZSBkaWZmIGNoYW5nZXMsIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIG51bGxcbiAgICAgKi9cbiAgICBDb21wdXRlUmVjdXJzaW9uUG9pbnQob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBtaWRPcmlnaW5hbEFyciwgbWlkTW9kaWZpZWRBcnIsIHF1aXRFYXJseUFycikge1xuICAgICAgICBsZXQgb3JpZ2luYWxJbmRleCA9IDAsIG1vZGlmaWVkSW5kZXggPSAwO1xuICAgICAgICBsZXQgZGlhZ29uYWxGb3J3YXJkU3RhcnQgPSAwLCBkaWFnb25hbEZvcndhcmRFbmQgPSAwO1xuICAgICAgICBsZXQgZGlhZ29uYWxSZXZlcnNlU3RhcnQgPSAwLCBkaWFnb25hbFJldmVyc2VFbmQgPSAwO1xuICAgICAgICAvLyBUbyB0cmF2ZXJzZSB0aGUgZWRpdCBncmFwaCBhbmQgcHJvZHVjZSB0aGUgcHJvcGVyIExDUywgb3VyIGFjdHVhbFxuICAgICAgICAvLyBzdGFydCBwb3NpdGlvbiBpcyBqdXN0IG91dHNpZGUgdGhlIGdpdmVuIGJvdW5kYXJ5XG4gICAgICAgIG9yaWdpbmFsU3RhcnQtLTtcbiAgICAgICAgbW9kaWZpZWRTdGFydC0tO1xuICAgICAgICAvLyBXZSBzZXQgdGhlc2UgdXAgdG8gbWFrZSB0aGUgY29tcGlsZXIgaGFwcHksIGJ1dCB0aGV5IHdpbGxcbiAgICAgICAgLy8gYmUgcmVwbGFjZWQgYmVmb3JlIHdlIHJldHVybiB3aXRoIHRoZSBhY3R1YWwgcmVjdXJzaW9uIHBvaW50XG4gICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gMDtcbiAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSAwO1xuICAgICAgICAvLyBDbGVhciBvdXQgdGhlIGhpc3RvcnlcbiAgICAgICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeSA9IFtdO1xuICAgICAgICAvLyBFYWNoIGNlbGwgaW4gdGhlIHR3byBhcnJheXMgY29ycmVzcG9uZHMgdG8gYSBkaWFnb25hbCBpbiB0aGUgZWRpdCBncmFwaC5cbiAgICAgICAgLy8gVGhlIGludGVnZXIgdmFsdWUgaW4gdGhlIGNlbGwgcmVwcmVzZW50cyB0aGUgb3JpZ2luYWxJbmRleCBvZiB0aGUgZnVydGhlc3RcbiAgICAgICAgLy8gcmVhY2hpbmcgcG9pbnQgZm91bmQgc28gZmFyIHRoYXQgZW5kcyBpbiB0aGF0IGRpYWdvbmFsLlxuICAgICAgICAvLyBUaGUgbW9kaWZpZWRJbmRleCBjYW4gYmUgY29tcHV0ZWQgbWF0aGVtYXRpY2FsbHkgZnJvbSB0aGUgb3JpZ2luYWxJbmRleCBhbmQgdGhlIGRpYWdvbmFsIG51bWJlci5cbiAgICAgICAgY29uc3QgbWF4RGlmZmVyZW5jZXMgPSAob3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0KSArIChtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQpO1xuICAgICAgICBjb25zdCBudW1EaWFnb25hbHMgPSBtYXhEaWZmZXJlbmNlcyArIDE7XG4gICAgICAgIGNvbnN0IGZvcndhcmRQb2ludHMgPSBuZXcgSW50MzJBcnJheShudW1EaWFnb25hbHMpO1xuICAgICAgICBjb25zdCByZXZlcnNlUG9pbnRzID0gbmV3IEludDMyQXJyYXkobnVtRGlhZ29uYWxzKTtcbiAgICAgICAgLy8gZGlhZ29uYWxGb3J3YXJkQmFzZTogSW5kZXggaW50byBmb3J3YXJkUG9pbnRzIG9mIHRoZSBkaWFnb25hbCB3aGljaCBwYXNzZXMgdGhyb3VnaCAob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydClcbiAgICAgICAgLy8gZGlhZ29uYWxSZXZlcnNlQmFzZTogSW5kZXggaW50byByZXZlcnNlUG9pbnRzIG9mIHRoZSBkaWFnb25hbCB3aGljaCBwYXNzZXMgdGhyb3VnaCAob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKVxuICAgICAgICBjb25zdCBkaWFnb25hbEZvcndhcmRCYXNlID0gKG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCk7XG4gICAgICAgIGNvbnN0IGRpYWdvbmFsUmV2ZXJzZUJhc2UgPSAob3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0KTtcbiAgICAgICAgLy8gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0OiBHZW9tZXRyaWMgb2Zmc2V0IHdoaWNoIGFsbG93cyBtb2RpZmllZEluZGV4IHRvIGJlIGNvbXB1dGVkIGZyb20gb3JpZ2luYWxJbmRleCBhbmQgdGhlXG4gICAgICAgIC8vICAgIGRpYWdvbmFsIG51bWJlciAocmVsYXRpdmUgdG8gZGlhZ29uYWxGb3J3YXJkQmFzZSlcbiAgICAgICAgLy8gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0OiBHZW9tZXRyaWMgb2Zmc2V0IHdoaWNoIGFsbG93cyBtb2RpZmllZEluZGV4IHRvIGJlIGNvbXB1dGVkIGZyb20gb3JpZ2luYWxJbmRleCBhbmQgdGhlXG4gICAgICAgIC8vICAgIGRpYWdvbmFsIG51bWJlciAocmVsYXRpdmUgdG8gZGlhZ29uYWxSZXZlcnNlQmFzZSlcbiAgICAgICAgY29uc3QgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0ID0gKG9yaWdpbmFsU3RhcnQgLSBtb2RpZmllZFN0YXJ0KTtcbiAgICAgICAgY29uc3QgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0ID0gKG9yaWdpbmFsRW5kIC0gbW9kaWZpZWRFbmQpO1xuICAgICAgICAvLyBkZWx0YTogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZW5kIGRpYWdvbmFsIGFuZCB0aGUgc3RhcnQgZGlhZ29uYWwuIFRoaXMgaXMgdXNlZCB0byByZWxhdGUgZGlhZ29uYWwgbnVtYmVyc1xuICAgICAgICAvLyAgIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBkaWFnb25hbCB3aXRoIGRpYWdvbmFsIG51bWJlcnMgcmVsYXRpdmUgdG8gdGhlIGVuZCBkaWFnb25hbC5cbiAgICAgICAgLy8gVGhlIEV2ZW4vT2Rkbi1uZXNzIG9mIHRoaXMgZGVsdGEgaXMgaW1wb3J0YW50IGZvciBkZXRlcm1pbmluZyB3aGVuIHdlIHNob3VsZCBjaGVjayBmb3Igb3ZlcmxhcFxuICAgICAgICBjb25zdCBkZWx0YSA9IGRpYWdvbmFsUmV2ZXJzZUJhc2UgLSBkaWFnb25hbEZvcndhcmRCYXNlO1xuICAgICAgICBjb25zdCBkZWx0YUlzRXZlbiA9IChkZWx0YSAlIDIgPT09IDApO1xuICAgICAgICAvLyBIZXJlIHdlIHNldCB1cCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXMgdGhlIGZ1cnRoZXN0IHBvaW50cyBmb3VuZCBzbyBmYXJcbiAgICAgICAgLy8gaW4gYm90aCB0aGUgZm9yd2FyZCBhbmQgcmV2ZXJzZSBkaXJlY3Rpb25zLCByZXNwZWN0aXZlbHlcbiAgICAgICAgZm9yd2FyZFBvaW50c1tkaWFnb25hbEZvcndhcmRCYXNlXSA9IG9yaWdpbmFsU3RhcnQ7XG4gICAgICAgIHJldmVyc2VQb2ludHNbZGlhZ29uYWxSZXZlcnNlQmFzZV0gPSBvcmlnaW5hbEVuZDtcbiAgICAgICAgLy8gUmVtZW1iZXIgaWYgd2UgcXVpdCBlYXJseSwgYW5kIHRodXMgbmVlZCB0byBkbyBhIGJlc3QtZWZmb3J0IHJlc3VsdCBpbnN0ZWFkIG9mIGEgcmVhbCByZXN1bHQuXG4gICAgICAgIHF1aXRFYXJseUFyclswXSA9IGZhbHNlO1xuICAgICAgICAvLyBBIGNvdXBsZSBvZiBwb2ludHM6XG4gICAgICAgIC8vIC0tV2l0aCB0aGlzIG1ldGhvZCwgd2UgaXRlcmF0ZSBvbiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIHR3byBzZXF1ZW5jZXMuXG4gICAgICAgIC8vICAgVGhlIG1vcmUgZGlmZmVyZW5jZXMgdGhlcmUgYWN0dWFsbHkgYXJlLCB0aGUgbG9uZ2VyIHRoaXMgd2lsbCB0YWtlLlxuICAgICAgICAvLyAtLUFsc28sIGFzIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXMgaW5jcmVhc2VzLCB3ZSBoYXZlIHRvIHNlYXJjaCBvbiBkaWFnb25hbHMgZnVydGhlclxuICAgICAgICAvLyAgIGF3YXkgZnJvbSB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsICh3aGljaCBpcyBkaWFnb25hbEZvcndhcmRCYXNlIGZvciBmb3J3YXJkLCBkaWFnb25hbFJldmVyc2VCYXNlIGZvciByZXZlcnNlKS5cbiAgICAgICAgLy8gLS1XZSBleHRlbmQgb24gZXZlbiBkaWFnb25hbHMgKHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2UgZGlhZ29uYWwpIG9ubHkgd2hlbiBudW1EaWZmZXJlbmNlc1xuICAgICAgICAvLyAgIGlzIGV2ZW4gYW5kIG9kZCBkaWFnb25hbHMgb25seSB3aGVuIG51bURpZmZlcmVuY2VzIGlzIG9kZC5cbiAgICAgICAgZm9yIChsZXQgbnVtRGlmZmVyZW5jZXMgPSAxOyBudW1EaWZmZXJlbmNlcyA8PSAobWF4RGlmZmVyZW5jZXMgLyAyKSArIDE7IG51bURpZmZlcmVuY2VzKyspIHtcbiAgICAgICAgICAgIGxldCBmdXJ0aGVzdE9yaWdpbmFsSW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IGZ1cnRoZXN0TW9kaWZpZWRJbmRleCA9IDA7XG4gICAgICAgICAgICAvLyBSdW4gdGhlIGFsZ29yaXRobSBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb25cbiAgICAgICAgICAgIGRpYWdvbmFsRm9yd2FyZFN0YXJ0ID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbEZvcndhcmRCYXNlIC0gbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbEZvcndhcmRCYXNlLCBudW1EaWFnb25hbHMpO1xuICAgICAgICAgICAgZGlhZ29uYWxGb3J3YXJkRW5kID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbEZvcndhcmRCYXNlICsgbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbEZvcndhcmRCYXNlLCBudW1EaWFnb25hbHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGlhZ29uYWwgPSBkaWFnb25hbEZvcndhcmRTdGFydDsgZGlhZ29uYWwgPD0gZGlhZ29uYWxGb3J3YXJkRW5kOyBkaWFnb25hbCArPSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAxOiBXZSBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgLy8gYnkgbG9va2luZyBhdCB0aGUgZGlhZ29uYWxzIGFib3ZlIGFuZCBiZWxvdyBhbmQgcGlja2luZyB0aGUgb25lIHdob3NlIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gaXMgZnVydGhlciBhd2F5IGZyb20gdGhlIHN0YXJ0IHBvaW50IChvcmlnaW5hbFN0YXJ0LCBtb2RpZmllZFN0YXJ0KVxuICAgICAgICAgICAgICAgIGlmIChkaWFnb25hbCA9PT0gZGlhZ29uYWxGb3J3YXJkU3RhcnQgfHwgKGRpYWdvbmFsIDwgZGlhZ29uYWxGb3J3YXJkRW5kICYmIGZvcndhcmRQb2ludHNbZGlhZ29uYWwgLSAxXSA8IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIChkaWFnb25hbCAtIGRpYWdvbmFsRm9yd2FyZEJhc2UpIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgb3JpZ2luYWxJbmRleCBzbyB3ZSBjYW4gdGVzdCBmb3IgZmFsc2Ugb3ZlcmxhcCBpbiBzdGVwIDNcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wT3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAyOiBXZSBjYW4gY29udGludWUgdG8gZXh0ZW5kIHRoZSBmdXJ0aGVzdCByZWFjaGluZyBwb2ludCBpbiB0aGUgcHJlc2VudCBkaWFnb25hbFxuICAgICAgICAgICAgICAgIC8vIHNvIGxvbmcgYXMgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbC5cbiAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxJbmRleCA8IG9yaWdpbmFsRW5kICYmIG1vZGlmaWVkSW5kZXggPCBtb2RpZmllZEVuZCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXggKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yd2FyZFBvaW50c1tkaWFnb25hbF0gPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ICsgbW9kaWZpZWRJbmRleCA+IGZ1cnRoZXN0T3JpZ2luYWxJbmRleCArIGZ1cnRoZXN0TW9kaWZpZWRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBmdXJ0aGVzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBmdXJ0aGVzdE1vZGlmaWVkSW5kZXggPSBtb2RpZmllZEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTVEVQIDM6IElmIGRlbHRhIGlzIG9kZCAob3ZlcmxhcCBmaXJzdCBoYXBwZW5zIG9uIGZvcndhcmQgd2hlbiBkZWx0YSBpcyBvZGQpXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRpYWdvbmFsIGlzIGluIHRoZSByYW5nZSBvZiByZXZlcnNlIGRpYWdvbmFscyBjb21wdXRlZCBmb3IgbnVtRGlmZmVyZW5jZXMtMVxuICAgICAgICAgICAgICAgIC8vICh0aGUgcHJldmlvdXMgaXRlcmF0aW9uOyB3ZSBoYXZlbid0IGNvbXB1dGVkIHJldmVyc2UgZGlhZ29uYWxzIGZvciBudW1EaWZmZXJlbmNlcyB5ZXQpXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBjaGVjayBmb3Igb3ZlcmxhcC5cbiAgICAgICAgICAgICAgICBpZiAoIWRlbHRhSXNFdmVuICYmIE1hdGguYWJzKGRpYWdvbmFsIC0gZGlhZ29uYWxSZXZlcnNlQmFzZSkgPD0gKG51bURpZmZlcmVuY2VzIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPj0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gbW9kaWZpZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wT3JpZ2luYWxJbmRleCA8PSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsXSAmJiAxNDQ3IC8qIExvY2FsQ29uc3RhbnRzLk1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyA+IDAgJiYgbnVtRGlmZmVyZW5jZXMgPD0gKDE0NDcgLyogTG9jYWxDb25zdGFudHMuTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCSU5HTyEgV2Ugb3ZlcmxhcHBlZCwgYW5kIHdlIGhhdmUgdGhlIGZ1bGwgdHJhY2UgaW4gbWVtb3J5IVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIGZhbHNlIG92ZXJsYXAsIG9yIHdlIGRpZG4ndCBoYXZlIGVub3VnaCBtZW1vcnkgZm9yIHRoZSBmdWxsIHRyYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHJlY3Vyc2lvbiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBiZSBxdWl0dGluZyBlYXJseSwgYmVmb3JlIG1vdmluZyBvbiB0byB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICAgICAgICBjb25zdCBtYXRjaExlbmd0aE9mTG9uZ2VzdCA9ICgoZnVydGhlc3RPcmlnaW5hbEluZGV4IC0gb3JpZ2luYWxTdGFydCkgKyAoZnVydGhlc3RNb2RpZmllZEluZGV4IC0gbW9kaWZpZWRTdGFydCkgLSBudW1EaWZmZXJlbmNlcykgLyAyO1xuICAgICAgICAgICAgaWYgKHRoaXMuQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlICE9PSBudWxsICYmICF0aGlzLkNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZShmdXJ0aGVzdE9yaWdpbmFsSW5kZXgsIG1hdGNoTGVuZ3RoT2ZMb25nZXN0KSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IGZpbmlzaCwgc28gc2tpcCBhaGVhZCB0byBnZW5lcmF0aW5nIGEgcmVzdWx0IGZyb20gd2hhdCB3ZSBoYXZlLlxuICAgICAgICAgICAgICAgIHF1aXRFYXJseUFyclswXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBmdXJ0aGVzdCBkaXN0YW5jZSB3ZSBnb3QgaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gZnVydGhlc3RPcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gZnVydGhlc3RNb2RpZmllZEluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaExlbmd0aE9mTG9uZ2VzdCA+IDAgJiYgMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gPiAwICYmIG51bURpZmZlcmVuY2VzIDw9ICgxNDQ3IC8qIExvY2FsQ29uc3RhbnRzLk1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVub3VnaCBvZiB0aGUgaGlzdG9yeSBpcyBpbiBtZW1vcnkgdG8gd2FsayBpdCBiYWNrd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkaWRuJ3QgYWN0dWFsbHkgcmVtZW1iZXIgZW5vdWdoIG9mIHRoZSBoaXN0b3J5LlxuICAgICAgICAgICAgICAgICAgICAvL1NpbmNlIHdlIGFyZSBxdWl0dGluZyB0aGUgZGlmZiBlYXJseSwgd2UgbmVlZCB0byBzaGlmdCBiYWNrIHRoZSBvcmlnaW5hbFN0YXJ0IGFuZCBtb2RpZmllZCBzdGFydFxuICAgICAgICAgICAgICAgICAgICAvL2JhY2sgaW50byB0aGUgYm91bmRhcnkgbGltaXRzIHNpbmNlIHdlIGRlY3JlbWVudGVkIHRoZWlyIHZhbHVlIGFib3ZlIGJleW9uZCB0aGUgYm91bmRhcnkgbGltaXQuXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQrKztcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0ICsgMSwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSdW4gdGhlIGFsZ29yaXRobSBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0ID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbFJldmVyc2VCYXNlIC0gbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbFJldmVyc2VCYXNlLCBudW1EaWFnb25hbHMpO1xuICAgICAgICAgICAgZGlhZ29uYWxSZXZlcnNlRW5kID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbFJldmVyc2VCYXNlICsgbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbFJldmVyc2VCYXNlLCBudW1EaWFnb25hbHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGlhZ29uYWwgPSBkaWFnb25hbFJldmVyc2VTdGFydDsgZGlhZ29uYWwgPD0gZGlhZ29uYWxSZXZlcnNlRW5kOyBkaWFnb25hbCArPSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAxOiBXZSBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgLy8gYnkgbG9va2luZyBhdCB0aGUgZGlhZ29uYWxzIGFib3ZlIGFuZCBiZWxvdyBhbmQgcGlja2luZyB0aGUgb25lIHdob3NlIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gaXMgZnVydGhlciBhd2F5IGZyb20gdGhlIHN0YXJ0IHBvaW50IChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpXG4gICAgICAgICAgICAgICAgaWYgKGRpYWdvbmFsID09PSBkaWFnb25hbFJldmVyc2VTdGFydCB8fCAoZGlhZ29uYWwgPCBkaWFnb25hbFJldmVyc2VFbmQgJiYgcmV2ZXJzZVBvaW50c1tkaWFnb25hbCAtIDFdID49IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIChkaWFnb25hbCAtIGRpYWdvbmFsUmV2ZXJzZUJhc2UpIC0gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgb3JpZ2luYWxJbmRleCBzbyB3ZSBjYW4gdGVzdCBmb3IgZmFsc2Ugb3ZlcmxhcFxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDI6IFdlIGNhbiBjb250aW51ZSB0byBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgLy8gYXMgbG9uZyBhcyB0aGUgZWxlbWVudHMgYXJlIGVxdWFsLlxuICAgICAgICAgICAgICAgIHdoaWxlIChvcmlnaW5hbEluZGV4ID4gb3JpZ2luYWxTdGFydCAmJiBtb2RpZmllZEluZGV4ID4gbW9kaWZpZWRTdGFydCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxJbmRleCwgbW9kaWZpZWRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldmVyc2VQb2ludHNbZGlhZ29uYWxdID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDQ6IElmIGRlbHRhIGlzIGV2ZW4gKG92ZXJsYXAgZmlyc3QgaGFwcGVucyBvbiByZXZlcnNlIHdoZW4gZGVsdGEgaXMgZXZlbilcbiAgICAgICAgICAgICAgICAvLyBhbmQgZGlhZ29uYWwgaXMgaW4gdGhlIHJhbmdlIG9mIGZvcndhcmQgZGlhZ29uYWxzIGNvbXB1dGVkIGZvciBudW1EaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gY2hlY2sgZm9yIG92ZXJsYXAuXG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhSXNFdmVuICYmIE1hdGguYWJzKGRpYWdvbmFsIC0gZGlhZ29uYWxGb3J3YXJkQmFzZSkgPD0gbnVtRGlmZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPD0gZm9yd2FyZFBvaW50c1tkaWFnb25hbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gbW9kaWZpZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wT3JpZ2luYWxJbmRleCA+PSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsXSAmJiAxNDQ3IC8qIExvY2FsQ29uc3RhbnRzLk1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyA+IDAgJiYgbnVtRGlmZmVyZW5jZXMgPD0gKDE0NDcgLyogTG9jYWxDb25zdGFudHMuTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCSU5HTyEgV2Ugb3ZlcmxhcHBlZCwgYW5kIHdlIGhhdmUgdGhlIGZ1bGwgdHJhY2UgaW4gbWVtb3J5IVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIGZhbHNlIG92ZXJsYXAsIG9yIHdlIGRpZG4ndCBoYXZlIGVub3VnaCBtZW1vcnkgZm9yIHRoZSBmdWxsIHRyYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHJlY3Vyc2lvbiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2F2ZSBjdXJyZW50IHZlY3RvcnMgdG8gaGlzdG9yeSBiZWZvcmUgdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICBpZiAobnVtRGlmZmVyZW5jZXMgPD0gMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgYWxsb2NhdGluZyBzcGFjZSBmb3Igb25lIGV4dHJhIGludCwgd2hpY2ggd2UgZmlsbCB3aXRoXG4gICAgICAgICAgICAgICAgLy8gdGhlIGluZGV4IG9mIHRoZSBkaWFnb25hbCBiYXNlIGluZGV4XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBuZXcgSW50MzJBcnJheShkaWFnb25hbEZvcndhcmRFbmQgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDIpO1xuICAgICAgICAgICAgICAgIHRlbXBbMF0gPSBkaWFnb25hbEZvcndhcmRCYXNlIC0gZGlhZ29uYWxGb3J3YXJkU3RhcnQgKyAxO1xuICAgICAgICAgICAgICAgIE15QXJyYXkuQ29weTIoZm9yd2FyZFBvaW50cywgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIHRlbXAsIDEsIGRpYWdvbmFsRm9yd2FyZEVuZCAtIGRpYWdvbmFsRm9yd2FyZFN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5LnB1c2godGVtcCk7XG4gICAgICAgICAgICAgICAgdGVtcCA9IG5ldyBJbnQzMkFycmF5KGRpYWdvbmFsUmV2ZXJzZUVuZCAtIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0ICsgMik7XG4gICAgICAgICAgICAgICAgdGVtcFswXSA9IGRpYWdvbmFsUmV2ZXJzZUJhc2UgLSBkaWFnb25hbFJldmVyc2VTdGFydCArIDE7XG4gICAgICAgICAgICAgICAgTXlBcnJheS5Db3B5MihyZXZlcnNlUG9pbnRzLCBkaWFnb25hbFJldmVyc2VTdGFydCwgdGVtcCwgMSwgZGlhZ29uYWxSZXZlcnNlRW5kIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgdGhlbiB3ZSBoYXZlIHRoZSBmdWxsIHRyYWNlIGluIGhpc3RvcnkuIFdlIGp1c3QgaGF2ZSB0byBjb252ZXJ0IGl0IHRvIGEgY2hhbmdlIGxpc3RcbiAgICAgICAgLy8gTk9URTogVGhpcyBwYXJ0IGlzIGEgYml0IG1lc3N5XG4gICAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgdGhlIGdpdmVuIGNoYW5nZXMgdG8gcHJvdmlkZSBhIG1vcmUgaW50dWl0aXZlIGRpZmYuXG4gICAgICogV2hpbGUgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBkaWZmIG1hdGNoZXMgdGhlIGZpcnN0IGVsZW1lbnQgYWZ0ZXIgdGhlIGRpZmYsXG4gICAgICogd2Ugc2hpZnQgdGhlIGRpZmYgZG93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIFRoZSBsaXN0IG9mIGNoYW5nZXMgdG8gc2hpZnRcbiAgICAgKiBAcmV0dXJucyBUaGUgc2hpZnRlZCBjaGFuZ2VzXG4gICAgICovXG4gICAgUHJldHRpZnlDaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgLy8gU2hpZnQgYWxsIHRoZSBjaGFuZ2VzIGRvd24gZmlyc3RcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gKGkgPCBjaGFuZ2VzLmxlbmd0aCAtIDEpID8gY2hhbmdlc1tpICsgMV0ub3JpZ2luYWxTdGFydCA6IHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2gubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRTdG9wID0gKGkgPCBjaGFuZ2VzLmxlbmd0aCAtIDEpID8gY2hhbmdlc1tpICsgMV0ubW9kaWZpZWRTdGFydCA6IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2gubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tPcmlnaW5hbCA9IGNoYW5nZS5vcmlnaW5hbExlbmd0aCA+IDA7XG4gICAgICAgICAgICBjb25zdCBjaGVja01vZGlmaWVkID0gY2hhbmdlLm1vZGlmaWVkTGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHdoaWxlIChjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCA8IG9yaWdpbmFsU3RvcFxuICAgICAgICAgICAgICAgICYmIGNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoIDwgbW9kaWZpZWRTdG9wXG4gICAgICAgICAgICAgICAgJiYgKCFjaGVja09yaWdpbmFsIHx8IHRoaXMuT3JpZ2luYWxFbGVtZW50c0FyZUVxdWFsKGNoYW5nZS5vcmlnaW5hbFN0YXJ0LCBjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCkpXG4gICAgICAgICAgICAgICAgJiYgKCFjaGVja01vZGlmaWVkIHx8IHRoaXMuTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKGNoYW5nZS5tb2RpZmllZFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRTdHJpY3RFcXVhbCA9IHRoaXMuRWxlbWVudHNBcmVTdHJpY3RFcXVhbChjaGFuZ2Uub3JpZ2luYWxTdGFydCwgY2hhbmdlLm1vZGlmaWVkU3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZFN0cmljdEVxdWFsID0gdGhpcy5FbGVtZW50c0FyZVN0cmljdEVxdWFsKGNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoLCBjaGFuZ2UubW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZFN0cmljdEVxdWFsICYmICFzdGFydFN0cmljdEVxdWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmluZyB0aGUgY2hhbmdlIGRvd24gd291bGQgY3JlYXRlIGFuIGVxdWFsIGNoYW5nZSwgYnV0IHRoZSBlbGVtZW50cyBhcmUgbm90IHN0cmljdCBlcXVhbFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlLm9yaWdpbmFsU3RhcnQrKztcbiAgICAgICAgICAgICAgICBjaGFuZ2UubW9kaWZpZWRTdGFydCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkQ2hhbmdlQXJyID0gW251bGxdO1xuICAgICAgICAgICAgaWYgKGkgPCBjaGFuZ2VzLmxlbmd0aCAtIDEgJiYgdGhpcy5DaGFuZ2VzT3ZlcmxhcChjaGFuZ2VzW2ldLCBjaGFuZ2VzW2kgKyAxXSwgbWVyZ2VkQ2hhbmdlQXJyKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXNbaV0gPSBtZXJnZWRDaGFuZ2VBcnJbMF07XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5zcGxpY2UoaSArIDEsIDEpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTaGlmdCBjaGFuZ2VzIGJhY2sgdXAgdW50aWwgd2UgaGl0IGVtcHR5IG9yIHdoaXRlc3BhY2Utb25seSBsaW5lc1xuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFN0b3AgPSAwO1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkU3RvcCA9IDA7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hhbmdlID0gY2hhbmdlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTdG9wID0gcHJldkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgcHJldkNoYW5nZS5vcmlnaW5hbExlbmd0aDtcbiAgICAgICAgICAgICAgICBtb2RpZmllZFN0b3AgPSBwcmV2Q2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBwcmV2Q2hhbmdlLm1vZGlmaWVkTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hlY2tPcmlnaW5hbCA9IGNoYW5nZS5vcmlnaW5hbExlbmd0aCA+IDA7XG4gICAgICAgICAgICBjb25zdCBjaGVja01vZGlmaWVkID0gY2hhbmdlLm1vZGlmaWVkTGVuZ3RoID4gMDtcbiAgICAgICAgICAgIGxldCBiZXN0RGVsdGEgPSAwO1xuICAgICAgICAgICAgbGV0IGJlc3RTY29yZSA9IHRoaXMuX2JvdW5kYXJ5U2NvcmUoY2hhbmdlLm9yaWdpbmFsU3RhcnQsIGNoYW5nZS5vcmlnaW5hbExlbmd0aCwgY2hhbmdlLm1vZGlmaWVkU3RhcnQsIGNoYW5nZS5tb2RpZmllZExlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkZWx0YSA9IDE7OyBkZWx0YSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFydCA9IGNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gZGVsdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRTdGFydCA9IGNoYW5nZS5tb2RpZmllZFN0YXJ0IC0gZGVsdGE7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsU3RhcnQgPCBvcmlnaW5hbFN0b3AgfHwgbW9kaWZpZWRTdGFydCA8IG1vZGlmaWVkU3RvcCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrT3JpZ2luYWwgJiYgIXRoaXMuT3JpZ2luYWxFbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsU3RhcnQgKyBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tNb2RpZmllZCAmJiAhdGhpcy5Nb2RpZmllZEVsZW1lbnRzQXJlRXF1YWwobW9kaWZpZWRTdGFydCwgbW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRvdWNoaW5nUHJldmlvdXNDaGFuZ2UgPSAob3JpZ2luYWxTdGFydCA9PT0gb3JpZ2luYWxTdG9wICYmIG1vZGlmaWVkU3RhcnQgPT09IG1vZGlmaWVkU3RvcCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSAoKHRvdWNoaW5nUHJldmlvdXNDaGFuZ2UgPyA1IDogMClcbiAgICAgICAgICAgICAgICAgICAgKyB0aGlzLl9ib3VuZGFyeVNjb3JlKG9yaWdpbmFsU3RhcnQsIGNoYW5nZS5vcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3JlID4gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0RGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2Uub3JpZ2luYWxTdGFydCAtPSBiZXN0RGVsdGE7XG4gICAgICAgICAgICBjaGFuZ2UubW9kaWZpZWRTdGFydCAtPSBiZXN0RGVsdGE7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRDaGFuZ2VBcnIgPSBbbnVsbF07XG4gICAgICAgICAgICBpZiAoaSA+IDAgJiYgdGhpcy5DaGFuZ2VzT3ZlcmxhcChjaGFuZ2VzW2kgLSAxXSwgY2hhbmdlc1tpXSwgbWVyZ2VkQ2hhbmdlQXJyKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXNbaSAtIDFdID0gbWVyZ2VkQ2hhbmdlQXJyWzBdO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBsb25nZXN0IGNvbW1vbiBzdWJzdHJpbmdzLlxuICAgICAgICAvLyBHaXZlIHByZWZlcmVuY2UgdG8gdGhlIG9uZXMgY29udGFpbmluZyBsb25nZXIgbGluZXNcbiAgICAgICAgaWYgKHRoaXMuX2hhc1N0cmluZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSBjaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYUNoYW5nZSA9IGNoYW5nZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJDaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRMZW5ndGggPSBiQ2hhbmdlLm9yaWdpbmFsU3RhcnQgLSBhQ2hhbmdlLm9yaWdpbmFsU3RhcnQgLSBhQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFPcmlnaW5hbFN0YXJ0ID0gYUNoYW5nZS5vcmlnaW5hbFN0YXJ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGJPcmlnaW5hbEVuZCA9IGJDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGJDaGFuZ2Uub3JpZ2luYWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgYWJPcmlnaW5hbExlbmd0aCA9IGJPcmlnaW5hbEVuZCAtIGFPcmlnaW5hbFN0YXJ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFNb2RpZmllZFN0YXJ0ID0gYUNoYW5nZS5tb2RpZmllZFN0YXJ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGJNb2RpZmllZEVuZCA9IGJDaGFuZ2UubW9kaWZpZWRTdGFydCArIGJDaGFuZ2UubW9kaWZpZWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgYWJNb2RpZmllZExlbmd0aCA9IGJNb2RpZmllZEVuZCAtIGFNb2RpZmllZFN0YXJ0O1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHdhc3RpbmcgYSBsb3Qgb2YgdGltZSB3aXRoIHRoZXNlIHNlYXJjaGVzXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRMZW5ndGggPCA1ICYmIGFiT3JpZ2luYWxMZW5ndGggPCAyMCAmJiBhYk1vZGlmaWVkTGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuX2ZpbmRCZXR0ZXJDb250aWd1b3VzU2VxdWVuY2UoYU9yaWdpbmFsU3RhcnQsIGFiT3JpZ2luYWxMZW5ndGgsIGFNb2RpZmllZFN0YXJ0LCBhYk1vZGlmaWVkTGVuZ3RoLCBtYXRjaGVkTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvcmlnaW5hbE1hdGNoU3RhcnQsIG1vZGlmaWVkTWF0Y2hTdGFydF0gPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsTWF0Y2hTdGFydCAhPT0gYUNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgYUNoYW5nZS5vcmlnaW5hbExlbmd0aCB8fCBtb2RpZmllZE1hdGNoU3RhcnQgIT09IGFDaGFuZ2UubW9kaWZpZWRTdGFydCArIGFDaGFuZ2UubW9kaWZpZWRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggdG8gYW5vdGhlciBzZXF1ZW5jZSB0aGF0IGhhcyBhIGJldHRlciBzY29yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPSBvcmlnaW5hbE1hdGNoU3RhcnQgLSBhQ2hhbmdlLm9yaWdpbmFsU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNoYW5nZS5tb2RpZmllZExlbmd0aCA9IG1vZGlmaWVkTWF0Y2hTdGFydCAtIGFDaGFuZ2UubW9kaWZpZWRTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlLm9yaWdpbmFsU3RhcnQgPSBvcmlnaW5hbE1hdGNoU3RhcnQgKyBtYXRjaGVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJDaGFuZ2UubW9kaWZpZWRTdGFydCA9IG1vZGlmaWVkTWF0Y2hTdGFydCArIG1hdGNoZWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZS5vcmlnaW5hbExlbmd0aCA9IGJPcmlnaW5hbEVuZCAtIGJDaGFuZ2Uub3JpZ2luYWxTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoID0gYk1vZGlmaWVkRW5kIC0gYkNoYW5nZS5tb2RpZmllZFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH1cbiAgICBfZmluZEJldHRlckNvbnRpZ3VvdXNTZXF1ZW5jZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgsIGRlc2lyZWRMZW5ndGgpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsTGVuZ3RoIDwgZGVzaXJlZExlbmd0aCB8fCBtb2RpZmllZExlbmd0aCA8IGRlc2lyZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTWF4ID0gb3JpZ2luYWxTdGFydCArIG9yaWdpbmFsTGVuZ3RoIC0gZGVzaXJlZExlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTWF4ID0gbW9kaWZpZWRTdGFydCArIG1vZGlmaWVkTGVuZ3RoIC0gZGVzaXJlZExlbmd0aCArIDE7XG4gICAgICAgIGxldCBiZXN0U2NvcmUgPSAwO1xuICAgICAgICBsZXQgYmVzdE9yaWdpbmFsU3RhcnQgPSAwO1xuICAgICAgICBsZXQgYmVzdE1vZGlmaWVkU3RhcnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gb3JpZ2luYWxTdGFydDsgaSA8IG9yaWdpbmFsTWF4OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBtb2RpZmllZFN0YXJ0OyBqIDwgbW9kaWZpZWRNYXg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gdGhpcy5fY29udGlndW91c1NlcXVlbmNlU2NvcmUoaSwgaiwgZGVzaXJlZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3JlID4gMCAmJiBzY29yZSA+IGJlc3RTY29yZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE9yaWdpbmFsU3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TW9kaWZpZWRTdGFydCA9IGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0U2NvcmUgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Jlc3RPcmlnaW5hbFN0YXJ0LCBiZXN0TW9kaWZpZWRTdGFydF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9jb250aWd1b3VzU2VxdWVuY2VTY29yZShvcmlnaW5hbFN0YXJ0LCBtb2RpZmllZFN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IHNjb3JlID0gMDtcbiAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBsZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxTdGFydCArIGwsIG1vZGlmaWVkU3RhcnQgKyBsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NvcmUgKz0gdGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tvcmlnaW5hbFN0YXJ0ICsgbF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29yZTtcbiAgICB9XG4gICAgX09yaWdpbmFsSXNCb3VuZGFyeShpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPD0gMCB8fCBpbmRleCA+PSB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5faGFzU3RyaW5ncyAmJiAvXlxccyokLy50ZXN0KHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbaW5kZXhdKSk7XG4gICAgfVxuICAgIF9PcmlnaW5hbFJlZ2lvbklzQm91bmRhcnkob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX09yaWdpbmFsSXNCb3VuZGFyeShvcmlnaW5hbFN0YXJ0KSB8fCB0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxTdGFydCAtIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luYWxMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEVuZCA9IG9yaWdpbmFsU3RhcnQgKyBvcmlnaW5hbExlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxFbmQgLSAxKSB8fCB0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxFbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfTW9kaWZpZWRJc0JvdW5kYXJ5KGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8PSAwIHx8IGluZGV4ID49IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2gubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNTdHJpbmdzICYmIC9eXFxzKiQvLnRlc3QodGhpcy5fbW9kaWZpZWRTdHJpbmdFbGVtZW50c1tpbmRleF0pKTtcbiAgICB9XG4gICAgX01vZGlmaWVkUmVnaW9uSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fTW9kaWZpZWRJc0JvdW5kYXJ5KG1vZGlmaWVkU3RhcnQpIHx8IHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0IC0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RpZmllZExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkRW5kID0gbW9kaWZpZWRTdGFydCArIG1vZGlmaWVkTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZEVuZCAtIDEpIHx8IHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZEVuZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9ib3VuZGFyeVNjb3JlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFNjb3JlID0gKHRoaXMuX09yaWdpbmFsUmVnaW9uSXNCb3VuZGFyeShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCkgPyAxIDogMCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkU2NvcmUgPSAodGhpcy5fTW9kaWZpZWRSZWdpb25Jc0JvdW5kYXJ5KG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkTGVuZ3RoKSA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbFNjb3JlICsgbW9kaWZpZWRTY29yZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmNhdGVuYXRlcyB0aGUgdHdvIGlucHV0IERpZmZDaGFuZ2UgbGlzdHMgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZ1xuICAgICAqIGxpc3QuXG4gICAgICogQHBhcmFtIFRoZSBsZWZ0IGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gVGhlIHJpZ2h0IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIGxpc3RcbiAgICAgKi9cbiAgICBDb25jYXRlbmF0ZUNoYW5nZXMobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkQ2hhbmdlQXJyID0gW107XG4gICAgICAgIGlmIChsZWZ0Lmxlbmd0aCA9PT0gMCB8fCByaWdodC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAocmlnaHQubGVuZ3RoID4gMCkgPyByaWdodCA6IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5DaGFuZ2VzT3ZlcmxhcChsZWZ0W2xlZnQubGVuZ3RoIC0gMV0sIHJpZ2h0WzBdLCBtZXJnZWRDaGFuZ2VBcnIpKSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBicmVhayB0aGUgcHJvYmxlbSBkb3duIHJlY3Vyc2l2ZWx5LCBpdCBpcyBwb3NzaWJsZSB0aGF0IHdlXG4gICAgICAgICAgICAvLyBtaWdodCByZWN1cnNlIGluIHRoZSBtaWRkbGUgb2YgYSBjaGFuZ2UgdGhlcmVieSBzcGxpdHRpbmcgaXQgaW50b1xuICAgICAgICAgICAgLy8gdHdvIGNoYW5nZXMuIEhlcmUgaW4gdGhlIGNvbWJpbmluZyBzdGFnZSwgd2UgZGV0ZWN0IGFuZCBmdXNlIHRob3NlXG4gICAgICAgICAgICAvLyBjaGFuZ2VzIGJhY2sgdG9nZXRoZXJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgTXlBcnJheS5Db3B5KGxlZnQsIDAsIHJlc3VsdCwgMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJlc3VsdFtsZWZ0Lmxlbmd0aCAtIDFdID0gbWVyZ2VkQ2hhbmdlQXJyWzBdO1xuICAgICAgICAgICAgTXlBcnJheS5Db3B5KHJpZ2h0LCAxLCByZXN1bHQsIGxlZnQubGVuZ3RoLCByaWdodC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobGVmdC5sZW5ndGggKyByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgTXlBcnJheS5Db3B5KGxlZnQsIDAsIHJlc3VsdCwgMCwgbGVmdC5sZW5ndGgpO1xuICAgICAgICAgICAgTXlBcnJheS5Db3B5KHJpZ2h0LCAwLCByZXN1bHQsIGxlZnQubGVuZ3RoLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBjaGFuZ2VzIG92ZXJsYXAgYW5kIGNhbiBiZSBtZXJnZWQgaW50byBhIHNpbmdsZVxuICAgICAqIGNoYW5nZVxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IGNoYW5nZVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgY2hhbmdlXG4gICAgICogQHBhcmFtIG1lcmdlZENoYW5nZSBUaGUgbWVyZ2VkIGNoYW5nZSBpZiB0aGUgdHdvIG92ZXJsYXAsIG51bGwgb3RoZXJ3aXNlXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHdvIGNoYW5nZXMgb3ZlcmxhcFxuICAgICAqL1xuICAgIENoYW5nZXNPdmVybGFwKGxlZnQsIHJpZ2h0LCBtZXJnZWRDaGFuZ2VBcnIpIHtcbiAgICAgICAgRGVidWcuQXNzZXJ0KGxlZnQub3JpZ2luYWxTdGFydCA8PSByaWdodC5vcmlnaW5hbFN0YXJ0LCAnTGVmdCBjaGFuZ2UgaXMgbm90IGxlc3MgdGhhbiBvciBlcXVhbCB0byByaWdodCBjaGFuZ2UnKTtcbiAgICAgICAgRGVidWcuQXNzZXJ0KGxlZnQubW9kaWZpZWRTdGFydCA8PSByaWdodC5tb2RpZmllZFN0YXJ0LCAnTGVmdCBjaGFuZ2UgaXMgbm90IGxlc3MgdGhhbiBvciBlcXVhbCB0byByaWdodCBjaGFuZ2UnKTtcbiAgICAgICAgaWYgKGxlZnQub3JpZ2luYWxTdGFydCArIGxlZnQub3JpZ2luYWxMZW5ndGggPj0gcmlnaHQub3JpZ2luYWxTdGFydCB8fCBsZWZ0Lm1vZGlmaWVkU3RhcnQgKyBsZWZ0Lm1vZGlmaWVkTGVuZ3RoID49IHJpZ2h0Lm1vZGlmaWVkU3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhcnQgPSBsZWZ0Lm9yaWdpbmFsU3RhcnQ7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxMZW5ndGggPSBsZWZ0Lm9yaWdpbmFsTGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRTdGFydCA9IGxlZnQubW9kaWZpZWRTdGFydDtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZExlbmd0aCA9IGxlZnQubW9kaWZpZWRMZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVmdC5vcmlnaW5hbFN0YXJ0ICsgbGVmdC5vcmlnaW5hbExlbmd0aCA+PSByaWdodC5vcmlnaW5hbFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxMZW5ndGggPSByaWdodC5vcmlnaW5hbFN0YXJ0ICsgcmlnaHQub3JpZ2luYWxMZW5ndGggLSBsZWZ0Lm9yaWdpbmFsU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdC5tb2RpZmllZFN0YXJ0ICsgbGVmdC5tb2RpZmllZExlbmd0aCA+PSByaWdodC5tb2RpZmllZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRMZW5ndGggPSByaWdodC5tb2RpZmllZFN0YXJ0ICsgcmlnaHQubW9kaWZpZWRMZW5ndGggLSBsZWZ0Lm1vZGlmaWVkU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZWRDaGFuZ2VBcnJbMF0gPSBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXJnZWRDaGFuZ2VBcnJbMF0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdXNlZCB0byBjbGlwIGEgZGlhZ29uYWwgaW5kZXggdG8gdGhlIHJhbmdlIG9mIHZhbGlkXG4gICAgICogZGlhZ29uYWxzLiBUaGlzIGFsc28gZGVjaWRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgZGlhZ29uYWwgaW5kZXgsXG4gICAgICogaWYgaXQgZXhjZWVkcyB0aGUgYm91bmRhcnksIHNob3VsZCBiZSBjbGlwcGVkIHRvIHRoZSBib3VuZGFyeSBvciBjbGlwcGVkXG4gICAgICogb25lIGluc2lkZSB0aGUgYm91bmRhcnkgZGVwZW5kaW5nIG9uIHRoZSBFdmVuL09kZCBzdGF0dXMgb2YgdGhlIGJvdW5kYXJ5XG4gICAgICogYW5kIG51bURpZmZlcmVuY2VzLlxuICAgICAqIEBwYXJhbSBkaWFnb25hbCBUaGUgaW5kZXggb2YgdGhlIGRpYWdvbmFsIHRvIGNsaXAuXG4gICAgICogQHBhcmFtIG51bURpZmZlcmVuY2VzIFRoZSBjdXJyZW50IG51bWJlciBvZiBkaWZmZXJlbmNlcyBiZWluZyBpdGVyYXRlZCB1cG9uLlxuICAgICAqIEBwYXJhbSBkaWFnb25hbEJhc2VJbmRleCBUaGUgYmFzZSByZWZlcmVuY2UgZGlhZ29uYWwuXG4gICAgICogQHBhcmFtIG51bURpYWdvbmFscyBUaGUgdG90YWwgbnVtYmVyIG9mIGRpYWdvbmFscy5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2xpcHBlZCBkaWFnb25hbCBpbmRleC5cbiAgICAgKi9cbiAgICBDbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbCwgbnVtRGlmZmVyZW5jZXMsIGRpYWdvbmFsQmFzZUluZGV4LCBudW1EaWFnb25hbHMpIHtcbiAgICAgICAgaWYgKGRpYWdvbmFsID49IDAgJiYgZGlhZ29uYWwgPCBudW1EaWFnb25hbHMpIHtcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gY2xpcCwgaXRzIGluIHJhbmdlXG4gICAgICAgICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlhZ29uYWxzQmVsb3c6IFRoZSBudW1iZXIgb2YgZGlhZ29uYWxzIGJlbG93IHRoZSByZWZlcmVuY2UgZGlhZ29uYWxcbiAgICAgICAgLy8gZGlhZ29uYWxzQWJvdmU6IFRoZSBudW1iZXIgb2YgZGlhZ29uYWxzIGFib3ZlIHRoZSByZWZlcmVuY2UgZGlhZ29uYWxcbiAgICAgICAgY29uc3QgZGlhZ29uYWxzQmVsb3cgPSBkaWFnb25hbEJhc2VJbmRleDtcbiAgICAgICAgY29uc3QgZGlhZ29uYWxzQWJvdmUgPSBudW1EaWFnb25hbHMgLSBkaWFnb25hbEJhc2VJbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGRpZmZFdmVuID0gKG51bURpZmZlcmVuY2VzICUgMiA9PT0gMCk7XG4gICAgICAgIGlmIChkaWFnb25hbCA8IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmRFdmVuID0gKGRpYWdvbmFsc0JlbG93ICUgMiA9PT0gMCk7XG4gICAgICAgICAgICByZXR1cm4gKGRpZmZFdmVuID09PSBsb3dlckJvdW5kRXZlbikgPyAwIDogMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyQm91bmRFdmVuID0gKGRpYWdvbmFsc0Fib3ZlICUgMiA9PT0gMCk7XG4gICAgICAgICAgICByZXR1cm4gKGRpZmZFdmVuID09PSB1cHBlckJvdW5kRXZlbikgPyBudW1EaWFnb25hbHMgLSAxIDogbnVtRGlhZ29uYWxzIC0gMjtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBSZXByZXNlbnRzIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBzZXF1ZW5jZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEaWZmQ2hhbmdlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IERpZmZDaGFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gc2VxdWVuY2UgaW5mb3JtYXRpb25cbiAgICAgKiBhbmQgY29udGVudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpIHtcbiAgICAgICAgLy9EZWJ1Zy5Bc3NlcnQob3JpZ2luYWxMZW5ndGggPiAwIHx8IG1vZGlmaWVkTGVuZ3RoID4gMCwgXCJvcmlnaW5hbExlbmd0aCBhbmQgbW9kaWZpZWRMZW5ndGggY2Fubm90IGJvdGggYmUgPD0gMFwiKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFN0YXJ0ID0gb3JpZ2luYWxTdGFydDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbExlbmd0aCA9IG9yaWdpbmFsTGVuZ3RoO1xuICAgICAgICB0aGlzLm1vZGlmaWVkU3RhcnQgPSBtb2RpZmllZFN0YXJ0O1xuICAgICAgICB0aGlzLm1vZGlmaWVkTGVuZ3RoID0gbW9kaWZpZWRMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgcG9pbnQgKGV4Y2x1c2l2ZSkgb2YgdGhlIGNoYW5nZSBpbiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UuXG4gICAgICovXG4gICAgZ2V0T3JpZ2luYWxFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsU3RhcnQgKyB0aGlzLm9yaWdpbmFsTGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZW5kIHBvaW50IChleGNsdXNpdmUpIG9mIHRoZSBjaGFuZ2UgaW4gdGhlIG1vZGlmaWVkIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIGdldE1vZGlmaWVkRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RpZmllZFN0YXJ0ICsgdGhpcy5tb2RpZmllZExlbmd0aDtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIEF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgb24gRXZlbnRFbWl0dGVyIGJ5IGltcGxlbWVudGluZyBhIHN1YnNldCBvZiB0aGUgaW50ZXJmYWNlLlxuZXhwb3J0IGNsYXNzIEVycm9ySGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMudW5leHBlY3RlZEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS5zdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRXJyb3JOb1RlbGVtZXRyeS5pc0Vycm9yTm9UZWxlbWV0cnkoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvck5vVGVsZW1ldHJ5KGUubWVzc2FnZSArICdcXG5cXG4nICsgZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUubWVzc2FnZSArICdcXG5cXG4nICsgZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZW1pdChlKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lcihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uVW5leHBlY3RlZEVycm9yKGUpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkRXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICB0aGlzLmVtaXQoZSk7XG4gICAgfVxuICAgIC8vIEZvciBleHRlcm5hbCBlcnJvcnMsIHdlIGRvbid0IHdhbnQgdGhlIGxpc3RlbmVycyB0byBiZSBjYWxsZWRcbiAgICBvblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yKGUpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkRXJyb3JIYW5kbGVyKGUpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBlcnJvckhhbmRsZXIgPSBuZXcgRXJyb3JIYW5kbGVyKCk7XG5leHBvcnQgZnVuY3Rpb24gb25VbmV4cGVjdGVkRXJyb3IoZSkge1xuICAgIC8vIGlnbm9yZSBlcnJvcnMgZnJvbSBjYW5jZWxsZWQgcHJvbWlzZXNcbiAgICBpZiAoIWlzQ2FuY2VsbGF0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgZXJyb3JIYW5kbGVyLm9uVW5leHBlY3RlZEVycm9yKGUpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9uVW5leHBlY3RlZEV4dGVybmFsRXJyb3IoZSkge1xuICAgIC8vIGlnbm9yZSBlcnJvcnMgZnJvbSBjYW5jZWxsZWQgcHJvbWlzZXNcbiAgICBpZiAoIWlzQ2FuY2VsbGF0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgZXJyb3JIYW5kbGVyLm9uVW5leHBlY3RlZEV4dGVybmFsRXJyb3IoZSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRXJyb3JGb3JTZXJpYWxpemF0aW9uKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBtZXNzYWdlIH0gPSBlcnJvcjtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBlcnJvci5zdGFja3RyYWNlIHx8IGVycm9yLnN0YWNrO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGlzRXJyb3I6IHRydWUsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgbm9UZWxlbWV0cnk6IEVycm9yTm9UZWxlbWV0cnkuaXNFcnJvck5vVGVsZW1ldHJ5KGVycm9yKVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyByZXR1cm4gYXMgaXNcbiAgICByZXR1cm4gZXJyb3I7XG59XG5jb25zdCBjYW5jZWxlZE5hbWUgPSAnQ2FuY2VsZWQnO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGEgcHJvbWlzZSBpbiBjYW5jZWxlZCBzdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDYW5jZWxsYXRpb25FcnJvcihlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENhbmNlbGxhdGlvbkVycm9yKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBjYW5jZWxlZE5hbWUgJiYgZXJyb3IubWVzc2FnZSA9PT0gY2FuY2VsZWROYW1lO1xufVxuLy8gISEhSU1QT1JUQU5UISEhXG4vLyBEbyBOT1QgY2hhbmdlIHRoaXMgY2xhc3MgYmVjYXVzZSBpdCBpcyBhbHNvIHVzZWQgYXMgYW4gQVBJLXR5cGUuXG5leHBvcnQgY2xhc3MgQ2FuY2VsbGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGNhbmNlbGVkTmFtZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMubWVzc2FnZTtcbiAgICB9XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgQ2FuY2VsbGF0aW9uRXJyb3IgYG5ldyBDYW5jZWxsYXRpb25FcnJvcigpYH0gaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsZWQoKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoY2FuY2VsZWROYW1lKTtcbiAgICBlcnJvci5uYW1lID0gZXJyb3IubWVzc2FnZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnQgZnVuY3Rpb24gaWxsZWdhbEFyZ3VtZW50KG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBJbGxlZ2FsIGFyZ3VtZW50OiAke25hbWV9YCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbGxlZ2FsIGFyZ3VtZW50Jyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlsbGVnYWxTdGF0ZShuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgSWxsZWdhbCBzdGF0ZTogJHtuYW1lfWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSWxsZWdhbCBzdGF0ZScpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCdOb3RTdXBwb3J0ZWQnKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRoYXQgd2hlbiB0aHJvd24gd29uJ3QgYmUgbG9nZ2VkIGluIHRlbGVtZXRyeSBhcyBhbiB1bmhhbmRsZWQgZXJyb3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvck5vVGVsZW1ldHJ5IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQ29kZUV4cGVjdGVkRXJyb3InO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUVycm9yKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3JOb1RlbGVtZXRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRXJyb3JOb1RlbGVtZXRyeSgpO1xuICAgICAgICByZXN1bHQubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICByZXN1bHQuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Vycm9yTm9UZWxlbWV0cnkoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnIubmFtZSA9PT0gJ0NvZGVFeHBlY3RlZEVycm9yJztcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgZXJyb3IgaW5kaWNhdGVzIGEgYnVnLlxuICogRG8gbm90IHRocm93IHRoaXMgZm9yIGludmFsaWQgdXNlciBpbnB1dC5cbiAqIE9ubHkgY2F0Y2ggdGhpcyBlcnJvciB0byByZWNvdmVyIGdyYWNlZnVsbHkgZnJvbSBidWdzLlxuICovXG5leHBvcnQgY2xhc3MgQnVnSW5kaWNhdGluZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSB8fCAnQW4gdW5leHBlY3RlZCBidWcgb2NjdXJyZWQuJyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBCdWdJbmRpY2F0aW5nRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgLy8gQmVjYXVzZSB3ZSBrbm93IGZvciBzdXJlIG9ubHkgYnVnZ3kgY29kZSB0aHJvd3MgdGhpcyxcbiAgICAgICAgLy8gd2UgZGVmaW5pdGVseSB3YW50IHRvIGJyZWFrIGhlcmUgYW5kIGZpeCB0aGUgYnVnLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZGVidWdnZXJcbiAgICAgICAgLy8gZGVidWdnZXI7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgb25VbmV4cGVjdGVkRXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTaW5nbGVDYWxsRnVuY3Rpb24gfSBmcm9tICcuL2Z1bmN0aW9uYWwuanMnO1xuaW1wb3J0IHsgY29tYmluZWREaXNwb3NhYmxlLCBEaXNwb3NhYmxlLCBEaXNwb3NhYmxlU3RvcmUsIHRvRGlzcG9zYWJsZSB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IExpbmtlZExpc3QgfSBmcm9tICcuL2xpbmtlZExpc3QuanMnO1xuaW1wb3J0IHsgU3RvcFdhdGNoIH0gZnJvbSAnLi9zdG9wd2F0Y2guanMnO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFVuY29tbWVudCB0aGUgbmV4dCBsaW5lIHRvIHByaW50IHdhcm5pbmdzIHdoZW5ldmVyIGEgbGlzdGVuZXIgaXMgR0MnZWQgd2l0aG91dCBoYXZpbmcgYmVlbiBkaXNwb3NlZC4gVGhpcyBpcyBhIExFQUsuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgX2VuYWJsZUxpc3RlbmVyR0NlZFdhcm5pbmcgPSBmYWxzZTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBVbmNvbW1lbnQgdGhlIG5leHQgbGluZSB0byBwcmludCB3YXJuaW5ncyB3aGVuZXZlciBhbiBlbWl0dGVyIHdpdGggbGlzdGVuZXJzIGlzIGRpc3Bvc2VkLiBUaGF0IGlzIGEgc2lnbiBvZiBjb2RlIHNtZWxsLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IF9lbmFibGVEaXNwb3NlV2l0aExpc3RlbmVyV2FybmluZyA9IGZhbHNlO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFVuY29tbWVudCB0aGUgbmV4dCBsaW5lIHRvIHByaW50IHdhcm5pbmdzIHdoZW5ldmVyIGEgc25hcHNob3R0ZWQgZXZlbnQgaXMgdXNlZCByZXBlYXRlZGx5IHdpdGhvdXQgY2xlYW51cC5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L3ZzY29kZS9pc3N1ZXMvMTQyODUxXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgX2VuYWJsZVNuYXBzaG90UG90ZW50aWFsTGVha1dhcm5pbmcgPSBmYWxzZTtcbmV4cG9ydCB2YXIgRXZlbnQ7XG4oZnVuY3Rpb24gKEV2ZW50KSB7XG4gICAgRXZlbnQuTm9uZSA9ICgpID0+IERpc3Bvc2FibGUuTm9uZTtcbiAgICBmdW5jdGlvbiBfYWRkTGVha2FnZVRyYWNlTG9naWMob3B0aW9ucykge1xuICAgICAgICBpZiAoX2VuYWJsZVNuYXBzaG90UG90ZW50aWFsTGVha1dhcm5pbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25EaWRBZGRMaXN0ZW5lcjogb3JpZ0xpc3RlbmVyRGlkQWRkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBTdGFja3RyYWNlLmNyZWF0ZSgpO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIG9wdGlvbnMub25EaWRBZGRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NuYXBzaG90dGVkIGVtaXR0ZXIgTElLRUxZIHVzZWQgcHVibGljIGFuZCBTSE9VTEQgSEFWRSBCRUVOIGNyZWF0ZWQgd2l0aCBEaXNwb3NhYmxlU3RvcmUuIHNuYXBzaG90dGVkIGhlcmUnKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHJpbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3JpZ0xpc3RlbmVyRGlkQWRkPy4oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gZXZlbnQsIHJldHVybnMgYW5vdGhlciBldmVudCB3aGljaCBkZWJvdW5jZXMgY2FsbHMgYW5kIGRlZmVycyB0aGUgbGlzdGVuZXJzIHRvIGEgbGF0ZXIgdGFzayB2aWEgYSBzaGFyZWRcbiAgICAgKiBgc2V0VGltZW91dGAuIFRoZSBldmVudCBpcyBjb252ZXJ0ZWQgaW50byBhIHNpZ25hbCAoYEV2ZW50PHZvaWQ+YCkgdG8gYXZvaWQgYWRkaXRpb25hbCBvYmplY3QgY3JlYXRpb24gYXMgYVxuICAgICAqIHJlc3VsdCBvZiBtZXJnaW5nIGV2ZW50cyBhbmQgdG8gdHJ5IHByZXZlbnQgcmFjZSBjb25kaXRpb25zIHRoYXQgY291bGQgYXJpc2Ugd2hlbiB1c2luZyByZWxhdGVkIGRlZmVycmVkIGFuZFxuICAgICAqIG5vbi1kZWZlcnJlZCBldmVudHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgZGVmZXJyaW5nIG5vbi1jcml0aWNhbCB3b3JrIChlZy4gZ2VuZXJhbCBVSSB1cGRhdGVzKSB0byBlbnN1cmUgaXQgZG9lcyBub3QgYmxvY2sgY3JpdGljYWwgd29ya1xuICAgICAqIChlZy4gbGF0ZW5jeSBvZiBrZXlwcmVzcyB0byB0ZXh0IHJlbmRlcmVkKS5cbiAgICAgKlxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgc291cmNlIGZvciB0aGUgbmV3IGV2ZW50LlxuICAgICAqIEBwYXJhbSBkaXNwb3NhYmxlIEEgZGlzcG9zYWJsZSBzdG9yZSB0byBhZGQgdGhlIG5ldyBFdmVudEVtaXR0ZXIgdG8uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmZXIoZXZlbnQsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlKGV2ZW50LCAoKSA9PiB2b2lkIDAsIDAsIHVuZGVmaW5lZCwgdHJ1ZSwgdW5kZWZpbmVkLCBkaXNwb3NhYmxlKTtcbiAgICB9XG4gICAgRXZlbnQuZGVmZXIgPSBkZWZlcjtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgcmV0dXJucyBhbm90aGVyIGV2ZW50IHdoaWNoIG9ubHkgZmlyZXMgb25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgc291cmNlIGZvciB0aGUgbmV3IGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIChsaXN0ZW5lciwgdGhpc0FyZ3MgPSBudWxsLCBkaXNwb3NhYmxlcykgPT4ge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzLCBpbiBjYXNlIHRoZSBldmVudCBmaXJlcyBkdXJpbmcgdGhlIGxpc3RlbmVyIGNhbGxcbiAgICAgICAgICAgIGxldCBkaWRGaXJlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzdWx0ID0gZXZlbnQoZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpZEZpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZEZpcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgZSk7XG4gICAgICAgICAgICB9LCBudWxsLCBkaXNwb3NhYmxlcyk7XG4gICAgICAgICAgICBpZiAoZGlkRmlyZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBFdmVudC5vbmNlID0gb25jZTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgcmV0dXJucyBhbm90aGVyIGV2ZW50IHdoaWNoIG9ubHkgZmlyZXMgb25jZSwgYW5kIG9ubHkgd2hlbiB0aGUgY29uZGl0aW9uIGlzIG1ldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgc291cmNlIGZvciB0aGUgbmV3IGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2VJZihldmVudCwgY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiBFdmVudC5vbmNlKEV2ZW50LmZpbHRlcihldmVudCwgY29uZGl0aW9uKSk7XG4gICAgfVxuICAgIEV2ZW50Lm9uY2VJZiA9IG9uY2VJZjtcbiAgICAvKipcbiAgICAgKiBNYXBzIGFuIGV2ZW50IG9mIG9uZSB0eXBlIGludG8gYW4gZXZlbnQgb2YgYW5vdGhlciB0eXBlIHVzaW5nIGEgbWFwcGluZyBmdW5jdGlvbiwgc2ltaWxhciB0byBob3dcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLm1hcGAgd29ya3MuXG4gICAgICpcbiAgICAgKiAqTk9URSogdGhhdCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYEV2ZW50YCBhbmQgaXQgTVVTVCBiZSBjYWxsZWQgd2l0aCBhIGBEaXNwb3NhYmxlU3RvcmVgIHdoZW5ldmVyIHRoZSByZXR1cm5lZFxuICAgICAqIGV2ZW50IGlzIGFjY2Vzc2libGUgdG8gXCJ0aGlyZCBwYXJ0aWVzXCIsIGUuZyB0aGUgZXZlbnQgaXMgYSBwdWJsaWMgcHJvcGVydHkuIE90aGVyd2lzZSBhIGxlYWtlZCBsaXN0ZW5lciBvbiB0aGVcbiAgICAgKiByZXR1cm5lZCBldmVudCBjYXVzZXMgdGhpcyB1dGlsaXR5IHRvIGxlYWsgYSBsaXN0ZW5lciBvbiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBmb3IgdGhlIG5ldyBldmVudC5cbiAgICAgKiBAcGFyYW0gbWFwIFRoZSBtYXBwaW5nIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBkaXNwb3NhYmxlIEEgZGlzcG9zYWJsZSBzdG9yZSB0byBhZGQgdGhlIG5ldyBFdmVudEVtaXR0ZXIgdG8uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGV2ZW50LCBtYXAsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90KChsaXN0ZW5lciwgdGhpc0FyZ3MgPSBudWxsLCBkaXNwb3NhYmxlcykgPT4gZXZlbnQoaSA9PiBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBtYXAoaSkpLCBudWxsLCBkaXNwb3NhYmxlcyksIGRpc3Bvc2FibGUpO1xuICAgIH1cbiAgICBFdmVudC5tYXAgPSBtYXA7XG4gICAgLyoqXG4gICAgICogV3JhcHMgYW4gZXZlbnQgaW4gYW5vdGhlciBldmVudCB0aGF0IHBlcmZvcm1zIHNvbWUgZnVuY3Rpb24gb24gdGhlIGV2ZW50IG9iamVjdCBiZWZvcmUgZmlyaW5nLlxuICAgICAqXG4gICAgICogKk5PVEUqIHRoYXQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGBFdmVudGAgYW5kIGl0IE1VU1QgYmUgY2FsbGVkIHdpdGggYSBgRGlzcG9zYWJsZVN0b3JlYCB3aGVuZXZlciB0aGUgcmV0dXJuZWRcbiAgICAgKiBldmVudCBpcyBhY2Nlc3NpYmxlIHRvIFwidGhpcmQgcGFydGllc1wiLCBlLmcgdGhlIGV2ZW50IGlzIGEgcHVibGljIHByb3BlcnR5LiBPdGhlcndpc2UgYSBsZWFrZWQgbGlzdGVuZXIgb24gdGhlXG4gICAgICogcmV0dXJuZWQgZXZlbnQgY2F1c2VzIHRoaXMgdXRpbGl0eSB0byBsZWFrIGEgbGlzdGVuZXIgb24gdGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBzb3VyY2UgZm9yIHRoZSBuZXcgZXZlbnQuXG4gICAgICogQHBhcmFtIGVhY2ggVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gb24gdGhlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gZGlzcG9zYWJsZSBBIGRpc3Bvc2FibGUgc3RvcmUgdG8gYWRkIHRoZSBuZXcgRXZlbnRFbWl0dGVyIHRvLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goZXZlbnQsIGVhY2gsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90KChsaXN0ZW5lciwgdGhpc0FyZ3MgPSBudWxsLCBkaXNwb3NhYmxlcykgPT4gZXZlbnQoaSA9PiB7IGVhY2goaSk7IGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGkpOyB9LCBudWxsLCBkaXNwb3NhYmxlcyksIGRpc3Bvc2FibGUpO1xuICAgIH1cbiAgICBFdmVudC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBmdW5jdGlvbiBmaWx0ZXIoZXZlbnQsIGZpbHRlciwgZGlzcG9zYWJsZSkge1xuICAgICAgICByZXR1cm4gc25hcHNob3QoKGxpc3RlbmVyLCB0aGlzQXJncyA9IG51bGwsIGRpc3Bvc2FibGVzKSA9PiBldmVudChlID0+IGZpbHRlcihlKSAmJiBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBlKSwgbnVsbCwgZGlzcG9zYWJsZXMpLCBkaXNwb3NhYmxlKTtcbiAgICB9XG4gICAgRXZlbnQuZmlsdGVyID0gZmlsdGVyO1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGV2ZW50LCByZXR1cm5zIHRoZSBzYW1lIGV2ZW50IGJ1dCB0eXBlZCBhcyBgRXZlbnQ8dm9pZD5gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ25hbChldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIEV2ZW50LnNpZ25hbCA9IHNpZ25hbDtcbiAgICBmdW5jdGlvbiBhbnkoLi4uZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiAobGlzdGVuZXIsIHRoaXNBcmdzID0gbnVsbCwgZGlzcG9zYWJsZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3Bvc2FibGUgPSBjb21iaW5lZERpc3Bvc2FibGUoLi4uZXZlbnRzLm1hcChldmVudCA9PiBldmVudChlID0+IGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGUpKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEFuZFJldHVybkRpc3Bvc2FibGUoZGlzcG9zYWJsZSwgZGlzcG9zYWJsZXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBFdmVudC5hbnkgPSBhbnk7XG4gICAgLyoqXG4gICAgICogKk5PVEUqIHRoYXQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGBFdmVudGAgYW5kIGl0IE1VU1QgYmUgY2FsbGVkIHdpdGggYSBgRGlzcG9zYWJsZVN0b3JlYCB3aGVuZXZlciB0aGUgcmV0dXJuZWRcbiAgICAgKiBldmVudCBpcyBhY2Nlc3NpYmxlIHRvIFwidGhpcmQgcGFydGllc1wiLCBlLmcgdGhlIGV2ZW50IGlzIGEgcHVibGljIHByb3BlcnR5LiBPdGhlcndpc2UgYSBsZWFrZWQgbGlzdGVuZXIgb24gdGhlXG4gICAgICogcmV0dXJuZWQgZXZlbnQgY2F1c2VzIHRoaXMgdXRpbGl0eSB0byBsZWFrIGEgbGlzdGVuZXIgb24gdGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShldmVudCwgbWVyZ2UsIGluaXRpYWwsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IGluaXRpYWw7XG4gICAgICAgIHJldHVybiBtYXAoZXZlbnQsIGUgPT4ge1xuICAgICAgICAgICAgb3V0cHV0ID0gbWVyZ2Uob3V0cHV0LCBlKTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sIGRpc3Bvc2FibGUpO1xuICAgIH1cbiAgICBFdmVudC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgZnVuY3Rpb24gc25hcHNob3QoZXZlbnQsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgbGV0IGxpc3RlbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgb25XaWxsQWRkRmlyc3RMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGV2ZW50KGVtaXR0ZXIuZmlyZSwgZW1pdHRlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EaWRSZW1vdmVMYXN0TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXI/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFkaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICBfYWRkTGVha2FnZVRyYWNlTG9naWMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKG9wdGlvbnMpO1xuICAgICAgICBkaXNwb3NhYmxlPy5hZGQoZW1pdHRlcik7XG4gICAgICAgIHJldHVybiBlbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBJRGlzcG9zYWJsZSB0byB0aGUgc3RvcmUgaWYgaXQncyBzZXQsIGFuZCByZXR1cm5zIGl0LiBVc2VmdWwgdG9cbiAgICAgKiBFdmVudCBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRBbmRSZXR1cm5EaXNwb3NhYmxlKGQsIHN0b3JlKSB7XG4gICAgICAgIGlmIChzdG9yZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBzdG9yZS5wdXNoKGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICBzdG9yZS5hZGQoZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGV2ZW50LCBtZXJnZSwgZGVsYXkgPSAxMDAsIGxlYWRpbmcgPSBmYWxzZSwgZmx1c2hPbkxpc3RlbmVyUmVtb3ZlID0gZmFsc2UsIGxlYWtXYXJuaW5nVGhyZXNob2xkLCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb247XG4gICAgICAgIGxldCBvdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBoYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBudW1EZWJvdW5jZWRDYWxscyA9IDA7XG4gICAgICAgIGxldCBkb0ZpcmU7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBsZWFrV2FybmluZ1RocmVzaG9sZCxcbiAgICAgICAgICAgIG9uV2lsbEFkZEZpcnN0TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gZXZlbnQoY3VyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbnVtRGVib3VuY2VkQ2FsbHMrKztcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbWVyZ2Uob3V0cHV0LCBjdXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVhZGluZyAmJiAhaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmZpcmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb0ZpcmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfb3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWFkaW5nIHx8IG51bURlYm91bmNlZENhbGxzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZmlyZShfb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG51bURlYm91bmNlZENhbGxzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gc2V0VGltZW91dChkb0ZpcmUsIGRlbGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soZG9GaXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uV2lsbFJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICAgICAgICAgIGlmIChmbHVzaE9uTGlzdGVuZXJSZW1vdmUgJiYgbnVtRGVib3VuY2VkQ2FsbHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvRmlyZT8uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyKCkge1xuICAgICAgICAgICAgICAgIGRvRmlyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWRpc3Bvc2FibGUpIHtcbiAgICAgICAgICAgIF9hZGRMZWFrYWdlVHJhY2VMb2dpYyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gbmV3IEVtaXR0ZXIob3B0aW9ucyk7XG4gICAgICAgIGRpc3Bvc2FibGU/LmFkZChlbWl0dGVyKTtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIEV2ZW50LmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgLyoqXG4gICAgICogRGVib3VuY2VzIGFuIGV2ZW50LCBmaXJpbmcgYWZ0ZXIgc29tZSBkZWxheSAoZGVmYXVsdD0wKSB3aXRoIGFuIGFycmF5IG9mIGFsbCBldmVudCBvcmlnaW5hbCBvYmplY3RzLlxuICAgICAqXG4gICAgICogKk5PVEUqIHRoYXQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGBFdmVudGAgYW5kIGl0IE1VU1QgYmUgY2FsbGVkIHdpdGggYSBgRGlzcG9zYWJsZVN0b3JlYCB3aGVuZXZlciB0aGUgcmV0dXJuZWRcbiAgICAgKiBldmVudCBpcyBhY2Nlc3NpYmxlIHRvIFwidGhpcmQgcGFydGllc1wiLCBlLmcgdGhlIGV2ZW50IGlzIGEgcHVibGljIHByb3BlcnR5LiBPdGhlcndpc2UgYSBsZWFrZWQgbGlzdGVuZXIgb24gdGhlXG4gICAgICogcmV0dXJuZWQgZXZlbnQgY2F1c2VzIHRoaXMgdXRpbGl0eSB0byBsZWFrIGEgbGlzdGVuZXIgb24gdGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFjY3VtdWxhdGUoZXZlbnQsIGRlbGF5ID0gMCwgZGlzcG9zYWJsZSkge1xuICAgICAgICByZXR1cm4gRXZlbnQuZGVib3VuY2UoZXZlbnQsIChsYXN0LCBlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdC5wdXNoKGUpO1xuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgIH0sIGRlbGF5LCB1bmRlZmluZWQsIHRydWUsIHVuZGVmaW5lZCwgZGlzcG9zYWJsZSk7XG4gICAgfVxuICAgIEV2ZW50LmFjY3VtdWxhdGUgPSBhY2N1bXVsYXRlO1xuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgYW4gZXZlbnQgc3VjaCB0aGF0IHNvbWUgY29uZGl0aW9uIGlzIF9ub3RfIG1ldCBtb3JlIHRoYW4gb25jZSBpbiBhIHJvdywgZWZmZWN0aXZlbHkgZW5zdXJpbmcgZHVwbGljYXRlXG4gICAgICogZXZlbnQgb2JqZWN0cyBmcm9tIGRpZmZlcmVudCBzb3VyY2VzIGRvIG5vdCBmaXJlIHRoZSBzYW1lIGV2ZW50IG9iamVjdC5cbiAgICAgKlxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgc291cmNlIGZvciB0aGUgbmV3IGV2ZW50LlxuICAgICAqIEBwYXJhbSBlcXVhbHMgVGhlIGVxdWFsaXR5IGNvbmRpdGlvbi5cbiAgICAgKiBAcGFyYW0gZGlzcG9zYWJsZSBBIGRpc3Bvc2FibGUgc3RvcmUgdG8gYWRkIHRoZSBuZXcgRXZlbnRFbWl0dGVyIHRvLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBGaXJlIG9ubHkgb25lIHRpbWUgd2hlbiBhIHNpbmdsZSB3aW5kb3cgaXMgb3BlbmVkIG9yIGZvY3VzZWRcbiAgICAgKiBFdmVudC5sYXRjaChFdmVudC5hbnkob25EaWRPcGVuV2luZG93LCBvbkRpZEZvY3VzV2luZG93KSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXRjaChldmVudCwgZXF1YWxzID0gKGEsIGIpID0+IGEgPT09IGIsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgbGV0IGZpcnN0Q2FsbCA9IHRydWU7XG4gICAgICAgIGxldCBjYWNoZTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcihldmVudCwgdmFsdWUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkRW1pdCA9IGZpcnN0Q2FsbCB8fCAhZXF1YWxzKHZhbHVlLCBjYWNoZSk7XG4gICAgICAgICAgICBmaXJzdENhbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIGNhY2hlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gc2hvdWxkRW1pdDtcbiAgICAgICAgfSwgZGlzcG9zYWJsZSk7XG4gICAgfVxuICAgIEV2ZW50LmxhdGNoID0gbGF0Y2g7XG4gICAgLyoqXG4gICAgICogU3BsaXRzIGFuIGV2ZW50IHdob3NlIHBhcmFtZXRlciBpcyBhIHVuaW9uIHR5cGUgaW50byAyIHNlcGFyYXRlIGV2ZW50cyBmb3IgZWFjaCB0eXBlIGluIHRoZSB1bmlvbi5cbiAgICAgKlxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlciB8IHVuZGVmaW5lZD4oKS5ldmVudDtcbiAgICAgKiBjb25zdCBbbnVtYmVyRXZlbnQsIHVuZGVmaW5lZEV2ZW50XSA9IEV2ZW50LnNwbGl0KGV2ZW50LCBpc1VuZGVmaW5lZCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBmb3IgdGhlIG5ldyBldmVudC5cbiAgICAgKiBAcGFyYW0gaXNUIEEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoYXQgZXZlbnQgaXMgb2YgdGhlIGZpcnN0IHR5cGUuXG4gICAgICogQHBhcmFtIGRpc3Bvc2FibGUgQSBkaXNwb3NhYmxlIHN0b3JlIHRvIGFkZCB0aGUgbmV3IEV2ZW50RW1pdHRlciB0by5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChldmVudCwgaXNULCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBFdmVudC5maWx0ZXIoZXZlbnQsIGlzVCwgZGlzcG9zYWJsZSksXG4gICAgICAgICAgICBFdmVudC5maWx0ZXIoZXZlbnQsIGUgPT4gIWlzVChlKSwgZGlzcG9zYWJsZSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIEV2ZW50LnNwbGl0ID0gc3BsaXQ7XG4gICAgLyoqXG4gICAgICogQnVmZmVycyBhbiBldmVudCB1bnRpbCBpdCBoYXMgYSBsaXN0ZW5lciBhdHRhY2hlZC5cbiAgICAgKlxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgc291cmNlIGZvciB0aGUgbmV3IGV2ZW50LlxuICAgICAqIEBwYXJhbSBmbHVzaEFmdGVyVGltZW91dCBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZmx1c2ggdGhlIGJ1ZmZlciBhZnRlciBhIHRpbWVvdXQgaW1tZWRpYXRlbHkgb3IgYWZ0ZXIgYVxuICAgICAqIGBzZXRUaW1lb3V0YCB3aGVuIHRoZSBmaXJzdCBldmVudCBsaXN0ZW5lciBpcyBhZGRlZC5cbiAgICAgKiBAcGFyYW0gX2J1ZmZlciBJbnRlcm5hbDogQSBzb3VyY2UgZXZlbnQgYXJyYXkgdXNlZCBmb3IgdGVzdHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIC8vIFN0YXJ0IGFjY3VtdWxhdGluZyBldmVudHMsIHdoZW4gdGhlIGZpcnN0IGxpc3RlbmVyIGlzIGF0dGFjaGVkLCBmbHVzaFxuICAgICAqIC8vIHRoZSBldmVudCBhZnRlciBhIHRpbWVvdXQgc3VjaCB0aGF0IG11bHRpcGxlIGxpc3RlbmVycyBhdHRhY2hlZCBiZWZvcmVcbiAgICAgKiAvLyB0aGUgdGltZW91dCB3b3VsZCByZWNlaXZlIHRoZSBldmVudFxuICAgICAqIHRoaXMub25JbnN0YWxsRXh0ZW5zaW9uID0gRXZlbnQuYnVmZmVyKHNlcnZpY2Uub25JbnN0YWxsRXh0ZW5zaW9uLCB0cnVlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBidWZmZXIoZXZlbnQsIGZsdXNoQWZ0ZXJUaW1lb3V0ID0gZmFsc2UsIF9idWZmZXIgPSBbXSwgZGlzcG9zYWJsZSkge1xuICAgICAgICBsZXQgYnVmZmVyID0gX2J1ZmZlci5zbGljZSgpO1xuICAgICAgICBsZXQgbGlzdGVuZXIgPSBldmVudChlID0+IHtcbiAgICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZmlyZShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICBkaXNwb3NhYmxlLmFkZChsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgICAgICAgICBidWZmZXI/LmZvckVhY2goZSA9PiBlbWl0dGVyLmZpcmUoZSkpO1xuICAgICAgICAgICAgYnVmZmVyID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcbiAgICAgICAgICAgIG9uV2lsbEFkZEZpcnN0TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGV2ZW50KGUgPT4gZW1pdHRlci5maXJlKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGUuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRpZEFkZEZpcnN0TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmx1c2hBZnRlclRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRpZFJlbW92ZUxhc3RMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgZGlzcG9zYWJsZS5hZGQoZW1pdHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIEV2ZW50LmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAvKipcbiAgICAgKiBXcmFwcyB0aGUgZXZlbnQgaW4gYW4ge0BsaW5rIElDaGFpbmFibGVFdmVudH0sIGFsbG93aW5nIGEgbW9yZSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIHN0eWxlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBOb3JtYWxcbiAgICAgKiBjb25zdCBvbkVudGVyUHJlc3NOb3JtYWwgPSBFdmVudC5maWx0ZXIoXG4gICAgICogICBFdmVudC5tYXAob25LZXlQcmVzcy5ldmVudCwgZSA9PiBuZXcgU3RhbmRhcmRLZXlib2FyZEV2ZW50KGUpKSxcbiAgICAgKiAgIGUua2V5Q29kZSA9PT0gS2V5Q29kZS5FbnRlclxuICAgICAqICkuZXZlbnQ7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBjaGFpblxuICAgICAqIGNvbnN0IG9uRW50ZXJQcmVzc0NoYWluID0gRXZlbnQuY2hhaW4ob25LZXlQcmVzcy5ldmVudCwgJCA9PiAkXG4gICAgICogICAubWFwKGUgPT4gbmV3IFN0YW5kYXJkS2V5Ym9hcmRFdmVudChlKSlcbiAgICAgKiAgIC5maWx0ZXIoZSA9PiBlLmtleUNvZGUgPT09IEtleUNvZGUuRW50ZXIpXG4gICAgICogKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbihldmVudCwgc3l0aGVuc2l6ZSkge1xuICAgICAgICBjb25zdCBmbiA9IChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjcyA9IHN5dGhlbnNpemUobmV3IENoYWluYWJsZVN5bnRoZXNpcygpKTtcbiAgICAgICAgICAgIHJldHVybiBldmVudChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjcy5ldmFsdWF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gSGFsdENoYWluYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgZGlzcG9zYWJsZXMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIEV2ZW50LmNoYWluID0gY2hhaW47XG4gICAgY29uc3QgSGFsdENoYWluYWJsZSA9IFN5bWJvbCgnSGFsdENoYWluYWJsZScpO1xuICAgIGNsYXNzIENoYWluYWJsZVN5bnRoZXNpcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1hcChmbikge1xuICAgICAgICAgICAgdGhpcy5zdGVwcy5wdXNoKGZuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZvckVhY2goZm4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcHMucHVzaCh2ID0+IHtcbiAgICAgICAgICAgICAgICBmbih2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyKGZuKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBzLnB1c2godiA9PiBmbih2KSA/IHYgOiBIYWx0Q2hhaW5hYmxlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJlZHVjZShtZXJnZSwgaW5pdGlhbCkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpbml0aWFsO1xuICAgICAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHYgPT4ge1xuICAgICAgICAgICAgICAgIGxhc3QgPSBtZXJnZShsYXN0LCB2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGF0Y2goZXF1YWxzID0gKGEsIGIpID0+IGEgPT09IGIpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdENhbGwgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGNhY2hlO1xuICAgICAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRFbWl0ID0gZmlyc3RDYWxsIHx8ICFlcXVhbHModmFsdWUsIGNhY2hlKTtcbiAgICAgICAgICAgICAgICBmaXJzdENhbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRFbWl0ID8gdmFsdWUgOiBIYWx0Q2hhaW5hYmxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBldmFsdWF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIHRoaXMuc3RlcHMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0ZXAodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSGFsdENoYWluYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiB7QGxpbmsgRXZlbnR9IGZyb20gYSBub2RlIGV2ZW50IGVtaXR0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbU5vZGVFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXZlbnROYW1lLCBtYXAgPSBpZCA9PiBpZCkge1xuICAgICAgICBjb25zdCBmbiA9ICguLi5hcmdzKSA9PiByZXN1bHQuZmlyZShtYXAoLi4uYXJncykpO1xuICAgICAgICBjb25zdCBvbkZpcnN0TGlzdGVuZXJBZGQgPSAoKSA9PiBlbWl0dGVyLm9uKGV2ZW50TmFtZSwgZm4pO1xuICAgICAgICBjb25zdCBvbkxhc3RMaXN0ZW5lclJlbW92ZSA9ICgpID0+IGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBmbik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBFbWl0dGVyKHsgb25XaWxsQWRkRmlyc3RMaXN0ZW5lcjogb25GaXJzdExpc3RlbmVyQWRkLCBvbkRpZFJlbW92ZUxhc3RMaXN0ZW5lcjogb25MYXN0TGlzdGVuZXJSZW1vdmUgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuZXZlbnQ7XG4gICAgfVxuICAgIEV2ZW50LmZyb21Ob2RlRXZlbnRFbWl0dGVyID0gZnJvbU5vZGVFdmVudEVtaXR0ZXI7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiB7QGxpbmsgRXZlbnR9IGZyb20gYSBET00gZXZlbnQgZW1pdHRlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tRE9NRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGV2ZW50TmFtZSwgbWFwID0gaWQgPT4gaWQpIHtcbiAgICAgICAgY29uc3QgZm4gPSAoLi4uYXJncykgPT4gcmVzdWx0LmZpcmUobWFwKC4uLmFyZ3MpKTtcbiAgICAgICAgY29uc3Qgb25GaXJzdExpc3RlbmVyQWRkID0gKCkgPT4gZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4pO1xuICAgICAgICBjb25zdCBvbkxhc3RMaXN0ZW5lclJlbW92ZSA9ICgpID0+IGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEVtaXR0ZXIoeyBvbldpbGxBZGRGaXJzdExpc3RlbmVyOiBvbkZpcnN0TGlzdGVuZXJBZGQsIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyOiBvbkxhc3RMaXN0ZW5lclJlbW92ZSB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ldmVudDtcbiAgICB9XG4gICAgRXZlbnQuZnJvbURPTUV2ZW50RW1pdHRlciA9IGZyb21ET01FdmVudEVtaXR0ZXI7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHByb21pc2Ugb3V0IG9mIGFuIGV2ZW50LCB1c2luZyB0aGUge0BsaW5rIEV2ZW50Lm9uY2V9IGhlbHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1Byb21pc2UoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gb25jZShldmVudCkocmVzb2x2ZSkpO1xuICAgIH1cbiAgICBFdmVudC50b1Byb21pc2UgPSB0b1Byb21pc2U7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBldmVudCBvdXQgb2YgYSBwcm9taXNlIHRoYXQgZmlyZXMgb25jZSB3aGVuIHRoZSBwcm9taXNlIGlzXG4gICAgICogcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBwcm9taXNlIG9yIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21Qcm9taXNlKHByb21pc2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICByZXN1bHQuZmlyZShyZXMpO1xuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICByZXN1bHQuZmlyZSh1bmRlZmluZWQpO1xuICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmV2ZW50O1xuICAgIH1cbiAgICBFdmVudC5mcm9tUHJvbWlzZSA9IGZyb21Qcm9taXNlO1xuICAgIC8qKlxuICAgICAqIEEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGZvcndhcmRpbmcgYW4gZXZlbnQgdG8gYW5vdGhlciBlbWl0dGVyIHdoaWNoXG4gICAgICogaW1wcm92ZXMgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHNpbWlsYXIgdG8ge0BsaW5rIFJlbGF5fSBidXQgYWxsb3dzIGluc3RhbnRpYXRpbmcgYW5kIGZvcndhcmRpbmdcbiAgICAgKiBvbiBhIHNpbmdsZSBsaW5lIGFuZCBhbHNvIGFsbG93cyBmb3IgbXVsdGlwbGUgc291cmNlIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gZnJvbSBUaGUgZXZlbnQgdG8gZm9yd2FyZC5cbiAgICAgKiBAcGFyYW0gdG8gVGhlIGVtaXR0ZXIgdG8gZm9yd2FyZCB0aGUgZXZlbnQgdG8uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBFdmVudC5mb3J3YXJkKGV2ZW50LCBlbWl0dGVyKTtcbiAgICAgKiAvLyBlcXVpdmFsZW50IHRvXG4gICAgICogZXZlbnQoZSA9PiBlbWl0dGVyLmZpcmUoZSkpO1xuICAgICAqIC8vIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBldmVudChlbWl0dGVyLmZpcmUsIGVtaXR0ZXIpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcndhcmQoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIGZyb20oZSA9PiB0by5maXJlKGUpKTtcbiAgICB9XG4gICAgRXZlbnQuZm9yd2FyZCA9IGZvcndhcmQ7XG4gICAgZnVuY3Rpb24gcnVuQW5kU3Vic2NyaWJlKGV2ZW50LCBoYW5kbGVyLCBpbml0aWFsKSB7XG4gICAgICAgIGhhbmRsZXIoaW5pdGlhbCk7XG4gICAgICAgIHJldHVybiBldmVudChlID0+IGhhbmRsZXIoZSkpO1xuICAgIH1cbiAgICBFdmVudC5ydW5BbmRTdWJzY3JpYmUgPSBydW5BbmRTdWJzY3JpYmU7XG4gICAgY2xhc3MgRW1pdHRlck9ic2VydmVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoX29ic2VydmFibGUsIHN0b3JlKSB7XG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZhYmxlID0gX29ic2VydmFibGU7XG4gICAgICAgICAgICB0aGlzLl9jb3VudGVyID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2hhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgb25XaWxsQWRkRmlyc3RMaXN0ZW5lcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBfb2JzZXJ2YWJsZS5hZGRPYnNlcnZlcih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tbXVuaWNhdGUgdG8gdGhlIG9ic2VydmFibGUgdGhhdCB3ZSByZWNlaXZlZCBpdHMgY3VycmVudCB2YWx1ZSBhbmQgd291bGQgbGlrZSB0byBiZSBub3RpZmllZCBhYm91dCBmdXR1cmUgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZS5yZXBvcnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkRpZFJlbW92ZUxhc3RMaXN0ZW5lcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBfb2JzZXJ2YWJsZS5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFzdG9yZSkge1xuICAgICAgICAgICAgICAgIF9hZGRMZWFrYWdlVHJhY2VMb2dpYyhvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuYWRkKHRoaXMuZW1pdHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmVnaW5VcGRhdGUoX29ic2VydmFibGUpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydChfb2JzZXJ2YWJsZSA9PT0gdGhpcy5vYnMpO1xuICAgICAgICAgICAgdGhpcy5fY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVBvc3NpYmxlQ2hhbmdlKF9vYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAvLyBhc3NlcnQoX29ic2VydmFibGUgPT09IHRoaXMub2JzKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVDaGFuZ2UoX29ic2VydmFibGUsIF9jaGFuZ2UpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydChfb2JzZXJ2YWJsZSA9PT0gdGhpcy5vYnMpO1xuICAgICAgICAgICAgdGhpcy5faGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZW5kVXBkYXRlKF9vYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAvLyBhc3NlcnQoX29ic2VydmFibGUgPT09IHRoaXMub2JzKTtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50ZXItLTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudGVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZS5yZXBvcnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZSh0aGlzLl9vYnNlcnZhYmxlLmdldCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBldmVudCBlbWl0dGVyIHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgb2JzZXJ2YWJsZSBjaGFuZ2VzLlxuICAgICAqIEVhY2ggbGlzdGVuZXJzIHN1YnNjcmliZXMgdG8gdGhlIGVtaXR0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbU9ic2VydmFibGUob2JzLCBzdG9yZSkge1xuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBFbWl0dGVyT2JzZXJ2ZXIob2JzLCBzdG9yZSk7XG4gICAgICAgIHJldHVybiBvYnNlcnZlci5lbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBFdmVudC5mcm9tT2JzZXJ2YWJsZSA9IGZyb21PYnNlcnZhYmxlO1xuICAgIC8qKlxuICAgICAqIEVhY2ggbGlzdGVuZXIgaXMgYXR0YWNoZWQgdG8gdGhlIG9ic2VydmFibGUgZGlyZWN0bHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbU9ic2VydmFibGVMaWdodChvYnNlcnZhYmxlKSB7XG4gICAgICAgIHJldHVybiAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBkaWRDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0ge1xuICAgICAgICAgICAgICAgIGJlZ2luVXBkYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kVXBkYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGUucmVwb3J0Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZENoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYW5kbGVQb3NzaWJsZUNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGFuZGxlQ2hhbmdlKCkge1xuICAgICAgICAgICAgICAgICAgICBkaWRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvYnNlcnZhYmxlLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgICAgIG9ic2VydmFibGUucmVwb3J0Q2hhbmdlcygpO1xuICAgICAgICAgICAgY29uc3QgZGlzcG9zYWJsZSA9IHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlLnJlbW92ZU9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRpc3Bvc2FibGVzIGluc3RhbmNlb2YgRGlzcG9zYWJsZVN0b3JlKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMuYWRkKGRpc3Bvc2FibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkaXNwb3NhYmxlcykpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKGRpc3Bvc2FibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIEV2ZW50LmZyb21PYnNlcnZhYmxlTGlnaHQgPSBmcm9tT2JzZXJ2YWJsZUxpZ2h0O1xufSkoRXZlbnQgfHwgKEV2ZW50ID0ge30pKTtcbmV4cG9ydCBjbGFzcyBFdmVudFByb2ZpbGluZyB7XG4gICAgc3RhdGljIHsgdGhpcy5hbGwgPSBuZXcgU2V0KCk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLl9pZFBvb2wgPSAwOyB9XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmludm9jYXRpb25Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuZWxhcHNlZE92ZXJhbGwgPSAwO1xuICAgICAgICB0aGlzLmR1cmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLm5hbWUgPSBgJHtuYW1lfV8ke0V2ZW50UHJvZmlsaW5nLl9pZFBvb2wrK31gO1xuICAgICAgICBFdmVudFByb2ZpbGluZy5hbGwuYWRkKHRoaXMpO1xuICAgIH1cbiAgICBzdGFydChsaXN0ZW5lckNvdW50KSB7XG4gICAgICAgIHRoaXMuX3N0b3BXYXRjaCA9IG5ldyBTdG9wV2F0Y2goKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0b3BXYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuX3N0b3BXYXRjaC5lbGFwc2VkKCk7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9ucy5wdXNoKGVsYXBzZWQpO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkT3ZlcmFsbCArPSBlbGFwc2VkO1xuICAgICAgICAgICAgdGhpcy5pbnZvY2F0aW9uQ291bnQgKz0gMTtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BXYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBfZ2xvYmFsTGVha1dhcm5pbmdUaHJlc2hvbGQgPSAtMTtcbmNsYXNzIExlYWthZ2VNb25pdG9yIHtcbiAgICBzdGF0aWMgeyB0aGlzLl9pZFBvb2wgPSAxOyB9XG4gICAgY29uc3RydWN0b3IoX2Vycm9ySGFuZGxlciwgdGhyZXNob2xkLCBuYW1lID0gKExlYWthZ2VNb25pdG9yLl9pZFBvb2wrKykudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDMsICcwJykpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JIYW5kbGVyID0gX2Vycm9ySGFuZGxlcjtcbiAgICAgICAgdGhpcy50aHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3dhcm5Db3VudGRvd24gPSAwO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9zdGFja3M/LmNsZWFyKCk7XG4gICAgfVxuICAgIGNoZWNrKHN0YWNrLCBsaXN0ZW5lckNvdW50KSB7XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkO1xuICAgICAgICBpZiAodGhyZXNob2xkIDw9IDAgfHwgbGlzdGVuZXJDb3VudCA8IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3N0YWNrcykge1xuICAgICAgICAgICAgdGhpcy5fc3RhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvdW50ID0gKHRoaXMuX3N0YWNrcy5nZXQoc3RhY2sudmFsdWUpIHx8IDApO1xuICAgICAgICB0aGlzLl9zdGFja3Muc2V0KHN0YWNrLnZhbHVlLCBjb3VudCArIDEpO1xuICAgICAgICB0aGlzLl93YXJuQ291bnRkb3duIC09IDE7XG4gICAgICAgIGlmICh0aGlzLl93YXJuQ291bnRkb3duIDw9IDApIHtcbiAgICAgICAgICAgIC8vIG9ubHkgd2FybiBvbiBmaXJzdCBleGNlZWQgYW5kIHRoZW4gZXZlcnkgdGltZSB0aGUgbGltaXRcbiAgICAgICAgICAgIC8vIGlzIGV4Y2VlZGVkIGJ5IDUwJSBhZ2FpblxuICAgICAgICAgICAgdGhpcy5fd2FybkNvdW50ZG93biA9IHRocmVzaG9sZCAqIDAuNTtcbiAgICAgICAgICAgIGNvbnN0IFt0b3BTdGFjaywgdG9wQ291bnRdID0gdGhpcy5nZXRNb3N0RnJlcXVlbnRTdGFjaygpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBbJHt0aGlzLm5hbWV9XSBwb3RlbnRpYWwgbGlzdGVuZXIgTEVBSyBkZXRlY3RlZCwgaGF2aW5nICR7bGlzdGVuZXJDb3VudH0gbGlzdGVuZXJzIGFscmVhZHkuIE1PU1QgZnJlcXVlbnQgbGlzdGVuZXIgKCR7dG9wQ291bnR9KTpgO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKHRvcFN0YWNrKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IExpc3RlbmVyTGVha0Vycm9yKG1lc3NhZ2UsIHRvcFN0YWNrKTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ySGFuZGxlcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gKHRoaXMuX3N0YWNrcy5nZXQoc3RhY2sudmFsdWUpIHx8IDApO1xuICAgICAgICAgICAgdGhpcy5fc3RhY2tzLnNldChzdGFjay52YWx1ZSwgY291bnQgLSAxKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0TW9zdEZyZXF1ZW50U3RhY2soKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3BTdGFjaztcbiAgICAgICAgbGV0IHRvcENvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBbc3RhY2ssIGNvdW50XSBvZiB0aGlzLl9zdGFja3MpIHtcbiAgICAgICAgICAgIGlmICghdG9wU3RhY2sgfHwgdG9wQ291bnQgPCBjb3VudCkge1xuICAgICAgICAgICAgICAgIHRvcFN0YWNrID0gW3N0YWNrLCBjb3VudF07XG4gICAgICAgICAgICAgICAgdG9wQ291bnQgPSBjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wU3RhY2s7XG4gICAgfVxufVxuY2xhc3MgU3RhY2t0cmFjZSB7XG4gICAgc3RhdGljIGNyZWF0ZSgpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2t0cmFjZShlcnIuc3RhY2sgPz8gJycpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHByaW50KCkge1xuICAgICAgICBjb25zb2xlLndhcm4odGhpcy52YWx1ZS5zcGxpdCgnXFxuJykuc2xpY2UoMikuam9pbignXFxuJykpO1xuICAgIH1cbn1cbi8vIGVycm9yIHRoYXQgaXMgbG9nZ2VkIHdoZW4gZ29pbmcgb3ZlciB0aGUgY29uZmlndXJlZCBsaXN0ZW5lciB0aHJlc2hvbGRcbmV4cG9ydCBjbGFzcyBMaXN0ZW5lckxlYWtFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFjaykge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0xpc3RlbmVyTGVha0Vycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgIH1cbn1cbi8vIFNFVkVSRSBlcnJvciB0aGF0IGlzIGxvZ2dlZCB3aGVuIGhhdmluZyBnb25lIHdheSBvdmVyIHRoZSBjb25maWd1cmVkIGxpc3RlbmVyXG4vLyB0aHJlc2hvbGQgc28gdGhhdCB0aGUgZW1pdHRlciByZWZ1c2VzIHRvIGFjY2VwdCBtb3JlIGxpc3RlbmVyc1xuZXhwb3J0IGNsYXNzIExpc3RlbmVyUmVmdXNhbEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnTGlzdGVuZXJSZWZ1c2FsRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgfVxufVxuY2xhc3MgVW5pcXVlQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY29uc3QgY29tcGFjdGlvblRocmVzaG9sZCA9IDI7XG5jb25zdCBmb3JFYWNoTGlzdGVuZXIgPSAobGlzdGVuZXJzLCBmbikgPT4ge1xuICAgIGlmIChsaXN0ZW5lcnMgaW5zdGFuY2VvZiBVbmlxdWVDb250YWluZXIpIHtcbiAgICAgICAgZm4obGlzdGVuZXJzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICAgICAgICBmbihsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5sZXQgX2xpc3RlbmVyRmluYWxpemVycztcbmlmIChfZW5hYmxlTGlzdGVuZXJHQ2VkV2FybmluZykge1xuICAgIGNvbnN0IGxlYWtzID0gW107XG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAobGVha3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKCdbTEVBS0lORyBMSVNURU5FUlNdIEdDXFwnZWQgdGhlc2UgbGlzdGVuZXJzIHRoYXQgd2VyZSBOT1QgeWV0IGRpc3Bvc2VkOicpO1xuICAgICAgICBjb25zb2xlLndhcm4obGVha3Muam9pbignXFxuJykpO1xuICAgICAgICBsZWFrcy5sZW5ndGggPSAwO1xuICAgIH0sIDMwMDApO1xuICAgIF9saXN0ZW5lckZpbmFsaXplcnMgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoaGVsZFZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBoZWxkVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZWFrcy5wdXNoKGhlbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogVGhlIEVtaXR0ZXIgY2FuIGJlIHVzZWQgdG8gZXhwb3NlIGFuIEV2ZW50IHRvIHRoZSBwdWJsaWNcbiAqIHRvIGZpcmUgaXQgZnJvbSB0aGUgaW5zaWRlcy5cbiAqIFNhbXBsZTpcbiAgICBjbGFzcyBEb2N1bWVudCB7XG5cbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfb25EaWRDaGFuZ2UgPSBuZXcgRW1pdHRlcjwodmFsdWU6c3RyaW5nKT0+YW55PigpO1xuXG4gICAgICAgIHB1YmxpYyBvbkRpZENoYW5nZSA9IHRoaXMuX29uRGlkQ2hhbmdlLmV2ZW50O1xuXG4gICAgICAgIC8vIGdldHRlci1zdHlsZVxuICAgICAgICAvLyBnZXQgb25EaWRDaGFuZ2UoKTogRXZlbnQ8KHZhbHVlOnN0cmluZyk9PmFueT4ge1xuICAgICAgICAvLyBcdHJldHVybiB0aGlzLl9vbkRpZENoYW5nZS5ldmVudDtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHByaXZhdGUgX2RvSXQoKSB7XG4gICAgICAgICAgICAvLy4uLlxuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2UuZmlyZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gKi9cbmV4cG9ydCBjbGFzcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fbGVha2FnZU1vbiA9IChfZ2xvYmFsTGVha1dhcm5pbmdUaHJlc2hvbGQgPiAwIHx8IHRoaXMuX29wdGlvbnM/LmxlYWtXYXJuaW5nVGhyZXNob2xkKVxuICAgICAgICAgICAgPyBuZXcgTGVha2FnZU1vbml0b3Iob3B0aW9ucz8ub25MaXN0ZW5lckVycm9yID8/IG9uVW5leHBlY3RlZEVycm9yLCB0aGlzLl9vcHRpb25zPy5sZWFrV2FybmluZ1RocmVzaG9sZCA/PyBfZ2xvYmFsTGVha1dhcm5pbmdUaHJlc2hvbGQpIDpcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcGVyZk1vbiA9IHRoaXMuX29wdGlvbnM/Ll9wcm9mTmFtZSA/IG5ldyBFdmVudFByb2ZpbGluZyh0aGlzLl9vcHRpb25zLl9wcm9mTmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2RlbGl2ZXJ5UXVldWUgPSB0aGlzLl9vcHRpb25zPy5kZWxpdmVyeVF1ZXVlO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBJdCBpcyBiYWQgdG8gaGF2ZSBsaXN0ZW5lcnMgYXQgdGhlIHRpbWUgb2YgZGlzcG9zaW5nIGFuIGVtaXR0ZXIsIGl0IGlzIHdvcnN0IHRvIGhhdmUgbGlzdGVuZXJzIGtlZXAgdGhlIGVtaXR0ZXJcbiAgICAgICAgICAgIC8vIGFsaXZlIHZpYSB0aGUgcmVmZXJlbmNlIHRoYXQncyBlbWJlZGRlZCBpbiB0aGVpciBkaXNwb3NhYmxlcy4gVGhlcmVmb3JlIHdlIGxvb3Agb3ZlciBhbGwgcmVtYWluaW5nIGxpc3RlbmVycyBhbmRcbiAgICAgICAgICAgIC8vIHVuc2V0IHRoZWlyIHN1YnNjcmlwdGlvbnMvZGlzcG9zYWJsZXMuIExvb3BpbmcgYW5kIGJsYW1pbmcgcmVtYWluaW5nIGxpc3RlbmVycyBpcyBkb25lIG9uIG5leHQgdGljayBiZWNhdXNlIHRoZVxuICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBwcm9ncmFtbWluZyBwYXR0ZXJuIGlzIHZlcnkgcG9wdWxhcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjb25zdCBzb21lTW9kZWwgPSB0aGlzLl9kaXNwb3NhYmxlcy5hZGQobmV3IE1vZGVsT2JqZWN0KCkpOyAvLyAoMSkgY3JlYXRlIGFuZCByZWdpc3RlciBtb2RlbFxuICAgICAgICAgICAgLy8gdGhpcy5fZGlzcG9zYWJsZXMuYWRkKHNvbWVNb2RlbC5vbkRpZENoYW5nZSgoKSA9PiB7IC4uLiB9KTsgLy8gKDIpIHN1YnNjcmliZSBhbmQgcmVnaXN0ZXIgbW9kZWwtZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIC8vIC4uLmxhdGVyLi4uXG4gICAgICAgICAgICAvLyB0aGlzLl9kaXNwb3NhYmxlcy5kaXNwb3NlKCk7IGRpc3Bvc2VzICgxKSB0aGVuICgyKTogZG9uJ3Qgd2FybiBhZnRlciAoMSkgYnV0IGFmdGVyIHRoZSBcIm92ZXJhbGwgZGlzcG9zZVwiIGlzIGRvbmVcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWxpdmVyeVF1ZXVlPy5jdXJyZW50ID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsaXZlcnlRdWV1ZS5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGlmIChfZW5hYmxlRGlzcG9zZVdpdGhMaXN0ZW5lcldhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JFYWNoTGlzdGVuZXIobGlzdGVuZXJzLCBsID0+IGwuc3RhY2s/LnByaW50KCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucz8ub25EaWRSZW1vdmVMYXN0TGlzdGVuZXI/LigpO1xuICAgICAgICAgICAgdGhpcy5fbGVha2FnZU1vbj8uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciB0aGUgcHVibGljIHRvIGFsbG93IHRvIHN1YnNjcmliZVxuICAgICAqIHRvIGV2ZW50cyBmcm9tIHRoaXMgRW1pdHRlclxuICAgICAqL1xuICAgIGdldCBldmVudCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnQgPz89IChjYWxsYmFjaywgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGVha2FnZU1vbiAmJiB0aGlzLl9zaXplID4gdGhpcy5fbGVha2FnZU1vbi50aHJlc2hvbGQgKiogMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgWyR7dGhpcy5fbGVha2FnZU1vbi5uYW1lfV0gUkVGVVNFUyB0byBhY2NlcHQgbmV3IGxpc3RlbmVycyBiZWNhdXNlIGl0IGV4Y2VlZGVkIGl0cyB0aHJlc2hvbGQgYnkgZmFyICgke3RoaXMuX3NpemV9IHZzICR7dGhpcy5fbGVha2FnZU1vbi50aHJlc2hvbGR9KWA7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR1cGxlID0gdGhpcy5fbGVha2FnZU1vbi5nZXRNb3N0RnJlcXVlbnRTdGFjaygpID8/IFsnVU5LTk9XTiBzdGFjaycsIC0xXTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBMaXN0ZW5lclJlZnVzYWxFcnJvcihgJHttZXNzYWdlfS4gSElOVDogU3RhY2sgc2hvd3MgbW9zdCBmcmVxdWVudCBsaXN0ZW5lciAoJHt0dXBsZVsxXX0tdGltZXMpYCwgdHVwbGVbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IHRoaXMuX29wdGlvbnM/Lm9uTGlzdGVuZXJFcnJvciB8fCBvblVuZXhwZWN0ZWRFcnJvcjtcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBEaXNwb3NhYmxlLk5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBzaG91bGQgd2Ugd2FybiBpZiBhIGxpc3RlbmVyIGlzIGFkZGVkIHRvIGEgZGlzcG9zZWQgZW1pdHRlcj8gVGhpcyBoYXBwZW5zIG9mdGVuXG4gICAgICAgICAgICAgICAgcmV0dXJuIERpc3Bvc2FibGUuTm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzQXJncykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2suYmluZCh0aGlzQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250YWluZWQgPSBuZXcgVW5pcXVlQ29udGFpbmVyKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGxldCByZW1vdmVNb25pdG9yO1xuICAgICAgICAgICAgbGV0IHN0YWNrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xlYWthZ2VNb24gJiYgdGhpcy5fc2l6ZSA+PSBNYXRoLmNlaWwodGhpcy5fbGVha2FnZU1vbi50aHJlc2hvbGQgKiAwLjIpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgYW5kIHJlY29yZCB0aGlzIGVtaXR0ZXIgZm9yIHBvdGVudGlhbCBsZWFrYWdlXG4gICAgICAgICAgICAgICAgY29udGFpbmVkLnN0YWNrID0gU3RhY2t0cmFjZS5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICByZW1vdmVNb25pdG9yID0gdGhpcy5fbGVha2FnZU1vbi5jaGVjayhjb250YWluZWQuc3RhY2ssIHRoaXMuX3NpemUgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfZW5hYmxlRGlzcG9zZVdpdGhMaXN0ZW5lcldhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZWQuc3RhY2sgPSBzdGFjayA/PyBTdGFja3RyYWNlLmNyZWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zPy5vbldpbGxBZGRGaXJzdExpc3RlbmVyPy4odGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gY29udGFpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnM/Lm9uRGlkQWRkRmlyc3RMaXN0ZW5lcj8uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fbGlzdGVuZXJzIGluc3RhbmNlb2YgVW5pcXVlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsaXZlcnlRdWV1ZSA/Pz0gbmV3IEV2ZW50RGVsaXZlcnlRdWV1ZVByaXZhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbdGhpcy5fbGlzdGVuZXJzLCBjb250YWluZWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goY29udGFpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NpemUrKztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRvRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgX2xpc3RlbmVyRmluYWxpemVycz8udW5yZWdpc3RlcihyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlbW92ZU1vbml0b3I/LigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyKGNvbnRhaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkaXNwb3NhYmxlcyBpbnN0YW5jZW9mIERpc3Bvc2FibGVTdG9yZSkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLmFkZChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkaXNwb3NhYmxlcykpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2xpc3RlbmVyRmluYWxpemVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDIsIDMpLmpvaW4oJ1xcbicpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IC8oZmlsZTp8dnNjb2RlLWZpbGU6XFwvXFwvdnNjb2RlLWFwcCk/KFxcL1teOl0qOlxcZCs6XFxkKykvLmV4ZWMoc3RhY2spO1xuICAgICAgICAgICAgICAgIF9saXN0ZW5lckZpbmFsaXplcnMucmVnaXN0ZXIocmVzdWx0LCBtYXRjaD8uWzJdID8/IHN0YWNrLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50O1xuICAgIH1cbiAgICBfcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucz8ub25XaWxsUmVtb3ZlTGlzdGVuZXI/Lih0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gZXhwZWN0ZWQgaWYgYSBsaXN0ZW5lciBnZXRzIGRpc3Bvc2VkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NpemUgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnM/Lm9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyPy4odGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaXplID4gMSB3aGljaCByZXF1aXJlcyB0aGF0IGxpc3RlbmVycyBiZSBhIGxpc3Q6XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdkaXNwb3NlZD8nLCB0aGlzLl9kaXNwb3NlZCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnc2l6ZT8nLCB0aGlzLl9zaXplKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhcnI/JywgSlNPTi5zdHJpbmdpZnkodGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBkaXNwb3NlIHVua25vd24gbGlzdGVuZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIGxpc3RlbmVyc1tpbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGFkanVzdERlbGl2ZXJ5UXVldWUgPSB0aGlzLl9kZWxpdmVyeVF1ZXVlLmN1cnJlbnQgPT09IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9zaXplICogY29tcGFjdGlvblRocmVzaG9sZCA8PSBsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW24rK10gPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFkanVzdERlbGl2ZXJ5UXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsaXZlcnlRdWV1ZS5lbmQtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPCB0aGlzLl9kZWxpdmVyeVF1ZXVlLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGl2ZXJ5UXVldWUuaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXJzLmxlbmd0aCA9IG47XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2RlbGl2ZXIobGlzdGVuZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSB0aGlzLl9vcHRpb25zPy5vbkxpc3RlbmVyRXJyb3IgfHwgb25VbmV4cGVjdGVkRXJyb3I7XG4gICAgICAgIGlmICghZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci52YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBEZWxpdmVycyBpdGVtcyBpbiB0aGUgcXVldWUuIEFzc3VtZXMgdGhlIHF1ZXVlIGlzIHJlYWR5IHRvIGdvLiAqL1xuICAgIF9kZWxpdmVyUXVldWUoZHEpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZHEuY3VycmVudC5fbGlzdGVuZXJzO1xuICAgICAgICB3aGlsZSAoZHEuaSA8IGRxLmVuZCkge1xuICAgICAgICAgICAgLy8gaW1wb3J0YW50OiBkcS5pIGlzIGluY3JlbWVudGVkIGJlZm9yZSBjYWxsaW5nIGRlbGl2ZXIoKSBiZWNhdXNlIGl0IG1pZ2h0IHJlZW50ZXIgZGVsaXZlclF1ZXVlKClcbiAgICAgICAgICAgIHRoaXMuX2RlbGl2ZXIobGlzdGVuZXJzW2RxLmkrK10sIGRxLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBkcS5yZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBrZXB0IHByaXZhdGUgdG8gZmlyZSBhbiBldmVudCB0b1xuICAgICAqIHN1YnNjcmliZXJzXG4gICAgICovXG4gICAgZmlyZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fZGVsaXZlcnlRdWV1ZT8uY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZGVsaXZlclF1ZXVlKHRoaXMuX2RlbGl2ZXJ5UXVldWUpO1xuICAgICAgICAgICAgdGhpcy5fcGVyZk1vbj8uc3RvcCgpOyAvLyBsYXN0IGZpcmUoKSB3aWxsIGhhdmUgc3RhcnRpbmcgcGVyZm1vbiwgc3RvcCBpdCBiZWZvcmUgc3RhcnRpbmcgdGhlIG5leHQgZGlzcGF0Y2hcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZXJmTW9uPy5zdGFydCh0aGlzLl9zaXplKTtcbiAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIC8vIG5vLW9wXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbGlzdGVuZXJzIGluc3RhbmNlb2YgVW5pcXVlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxpdmVyKHRoaXMuX2xpc3RlbmVycywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZHEgPSB0aGlzLl9kZWxpdmVyeVF1ZXVlO1xuICAgICAgICAgICAgZHEuZW5xdWV1ZSh0aGlzLCBldmVudCwgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLl9kZWxpdmVyUXVldWUoZHEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BlcmZNb24/LnN0b3AoKTtcbiAgICB9XG4gICAgaGFzTGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSA+IDA7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGNyZWF0ZUV2ZW50RGVsaXZlcnlRdWV1ZSA9ICgpID0+IG5ldyBFdmVudERlbGl2ZXJ5UXVldWVQcml2YXRlKCk7XG5jbGFzcyBFdmVudERlbGl2ZXJ5UXVldWVQcml2YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IGluIGN1cnJlbnQncyBsaXN0ZW5lciBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFzdCBpbmRleCBpbiB0aGUgbGlzdGVuZXIncyBsaXN0IHRvIGRlbGl2ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuZCA9IDA7XG4gICAgfVxuICAgIGVucXVldWUoZW1pdHRlciwgdmFsdWUsIGVuZCkge1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gZW1pdHRlcjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pID0gdGhpcy5lbmQ7IC8vIGZvcmNlIGFueSBjdXJyZW50IGVtaXNzaW9uIGxvb3AgdG8gc3RvcCwgbWFpbmx5IGZvciBkdXJpbmcgZGlzcG9zZVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFBhdXNlYWJsZUVtaXR0ZXIgZXh0ZW5kcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IDA7XG4gICAgICAgIHRoaXMuX2V2ZW50UXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgICAgICB0aGlzLl9tZXJnZUZuID0gb3B0aW9ucz8ubWVyZ2U7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCsrO1xuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCAhPT0gMCAmJiAtLXRoaXMuX2lzUGF1c2VkID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWVyZ2VGbikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgbWVyZ2UgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc2luZ2xlIGNvbXBvc2l0ZVxuICAgICAgICAgICAgICAgIC8vIGV2ZW50LiBtYWtlIGEgY29weSBpbiBjYXNlIGZpcmluZyBwYXVzZXMgdGhpcyBlbWl0dGVyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gQXJyYXkuZnJvbSh0aGlzLl9ldmVudFF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5maXJlKHRoaXMuX21lcmdlRm4oZXZlbnRzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbWVyZ2luZywgZmlyZSBlYWNoIGV2ZW50IGluZGl2aWR1YWxseSBhbmQgdGVzdFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhpcyBlbWl0dGVyIGlzbid0IHBhdXNlZCBoYWxmd2F5IHRocm91Z2hcbiAgICAgICAgICAgICAgICB3aGlsZSAoIXRoaXMuX2lzUGF1c2VkICYmIHRoaXMuX2V2ZW50UXVldWUuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5maXJlKHRoaXMuX2V2ZW50UXVldWUuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50UXVldWUucHVzaChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdXBlci5maXJlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEZWJvdW5jZUVtaXR0ZXIgZXh0ZW5kcyBQYXVzZWFibGVFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9kZWxheSA9IG9wdGlvbnMuZGVsYXkgPz8gMTAwO1xuICAgIH1cbiAgICBmaXJlKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5faGFuZGxlKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIH0sIHRoaXMuX2RlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5maXJlKGV2ZW50KTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGVtaXR0ZXIgd2hpY2ggcXVldWUgYWxsIGV2ZW50cyBhbmQgdGhlbiBwcm9jZXNzIHRoZW0gYXQgdGhlXG4gKiBlbmQgb2YgdGhlIGV2ZW50IGxvb3AuXG4gKi9cbmV4cG9ydCBjbGFzcyBNaWNyb3Rhc2tFbWl0dGVyIGV4dGVuZHMgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcXVldWVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuX21lcmdlRm4gPSBvcHRpb25zPy5tZXJnZTtcbiAgICB9XG4gICAgZmlyZShldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9xdWV1ZWRFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZWRFdmVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21lcmdlRm4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZmlyZSh0aGlzLl9tZXJnZUZuKHRoaXMuX3F1ZXVlZEV2ZW50cykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWVkRXZlbnRzLmZvckVhY2goZSA9PiBzdXBlci5maXJlKGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVkRXZlbnRzID0gW107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgZW1pdHRlciB0aGF0IG11bHRpcGxleGVzIG1hbnkgZXZlbnRzIGludG8gYSBzaW5nbGUgZXZlbnQuXG4gKlxuICogQGV4YW1wbGUgTGlzdGVuIHRvIHRoZSBgb25EYXRhYCBldmVudCBvZiBhbGwgYFRoaW5nYHMsIGR5bmFtaWNhbGx5IGFkZGluZyBhbmQgcmVtb3ZpbmcgYFRoaW5nYHNcbiAqIHRvIHRoZSBtdWx0aXBsZXhlciBhcyBuZWVkZWQuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYW55dGhpbmdEYXRhTXVsdGlwbGV4ZXIgPSBuZXcgRXZlbnRNdWx0aXBsZXhlcjx7IGRhdGE6IHN0cmluZyB9PigpO1xuICpcbiAqIGNvbnN0IHRoaW5nTGlzdGVuZXJzID0gRGlzcG9zYWJsZU1hcDxUaGluZywgSURpc3Bvc2FibGU+KCk7XG4gKlxuICogdGhpbmdTZXJ2aWNlLm9uRGlkQWRkVGhpbmcodGhpbmcgPT4ge1xuICogICB0aGluZ0xpc3RlbmVycy5zZXQodGhpbmcsIGFueXRoaW5nRGF0YU11bHRpcGxleGVyLmFkZCh0aGluZy5vbkRhdGEpO1xuICogfSk7XG4gKiB0aGluZ1NlcnZpY2Uub25EaWRSZW1vdmVUaGluZyh0aGluZyA9PiB7XG4gKiAgIHRoaW5nTGlzdGVuZXJzLmRlbGV0ZUFuZERpc3Bvc2UodGhpbmcpO1xuICogfSk7XG4gKlxuICogYW55dGhpbmdEYXRhTXVsdGlwbGV4ZXIuZXZlbnQoZSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdTb21ldGhpbmcgZmlyZWQgZGF0YSAnICsgZS5kYXRhKVxuICogfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50TXVsdGlwbGV4ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhhc0xpc3RlbmVycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcih7XG4gICAgICAgICAgICBvbldpbGxBZGRGaXJzdExpc3RlbmVyOiAoKSA9PiB0aGlzLm9uRmlyc3RMaXN0ZW5lckFkZCgpLFxuICAgICAgICAgICAgb25EaWRSZW1vdmVMYXN0TGlzdGVuZXI6ICgpID0+IHRoaXMub25MYXN0TGlzdGVuZXJSZW1vdmUoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBhZGQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZSA9IHsgZXZlbnQ6IGV2ZW50LCBsaXN0ZW5lcjogbnVsbCB9O1xuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKGUpO1xuICAgICAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMuaG9vayhlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNwb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmhvb2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLmV2ZW50cy5pbmRleE9mKGUpO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0b0Rpc3Bvc2FibGUoY3JlYXRlU2luZ2xlQ2FsbEZ1bmN0aW9uKGRpc3Bvc2UpKTtcbiAgICB9XG4gICAgb25GaXJzdExpc3RlbmVyQWRkKCkge1xuICAgICAgICB0aGlzLmhhc0xpc3RlbmVycyA9IHRydWU7XG4gICAgICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZSA9PiB0aGlzLmhvb2soZSkpO1xuICAgIH1cbiAgICBvbkxhc3RMaXN0ZW5lclJlbW92ZSgpIHtcbiAgICAgICAgdGhpcy5oYXNMaXN0ZW5lcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChlID0+IHRoaXMudW5ob29rKGUpKTtcbiAgICB9XG4gICAgaG9vayhlKSB7XG4gICAgICAgIGUubGlzdGVuZXIgPSBlLmV2ZW50KHIgPT4gdGhpcy5lbWl0dGVyLmZpcmUocikpO1xuICAgIH1cbiAgICB1bmhvb2soZSkge1xuICAgICAgICBlLmxpc3RlbmVyPy5kaXNwb3NlKCk7XG4gICAgICAgIGUubGlzdGVuZXIgPSBudWxsO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgIGUubGlzdGVuZXI/LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIEV2ZW50QnVmZmVyZXIgaXMgdXNlZnVsIGluIHNpdHVhdGlvbnMgaW4gd2hpY2ggeW91IHdhbnRcbiAqIHRvIGRlbGF5IGZpcmluZyB5b3VyIGV2ZW50cyBkdXJpbmcgc29tZSBjb2RlLlxuICogWW91IGNhbiB3cmFwIHRoYXQgY29kZSBhbmQgYmUgc3VyZSB0aGF0IHRoZSBldmVudCB3aWxsIG5vdFxuICogYmUgZmlyZWQgZHVyaW5nIHRoYXQgd3JhcC5cbiAqXG4gKiBgYGBcbiAqIGNvbnN0IGVtaXR0ZXI6IEVtaXR0ZXI7XG4gKiBjb25zdCBkZWxheWVyID0gbmV3IEV2ZW50RGVsYXllcigpO1xuICogY29uc3QgZGVsYXllZEV2ZW50ID0gZGVsYXllci53cmFwRXZlbnQoZW1pdHRlci5ldmVudCk7XG4gKlxuICogZGVsYXllZEV2ZW50KGNvbnNvbGUubG9nKTtcbiAqXG4gKiBkZWxheWVyLmJ1ZmZlckV2ZW50cygoKSA9PiB7XG4gKiAgIGVtaXR0ZXIuZmlyZSgpOyAvLyBldmVudCB3aWxsIG5vdCBiZSBmaXJlZCB5ZXRcbiAqIH0pO1xuICpcbiAqIC8vIGV2ZW50IHdpbGwgb25seSBiZSBmaXJlZCBhdCB0aGlzIHBvaW50XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50QnVmZmVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG4gICAgd3JhcEV2ZW50KGV2ZW50LCByZWR1Y2UsIGluaXRpYWwpIHtcbiAgICAgICAgcmV0dXJuIChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQoaSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgLy8gTm9uLXJlZHVjZSBzY2VuYXJpb1xuICAgICAgICAgICAgICAgIGlmICghcmVkdWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1ZmZlcmluZyBjYXNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmJ1ZmZlcnMucHVzaCgoKSA9PiBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYnVmZmVyaW5nIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVkdWNlIHNjZW5hcmlvXG4gICAgICAgICAgICAgICAgY29uc3QgcmVkdWNlRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgLy8gTm90IGJ1ZmZlcmluZyBjYXNlXG4gICAgICAgICAgICAgICAgaWYgKCFyZWR1Y2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IElzIHRoZXJlIGEgd2F5IHRvIGNhY2hlIHRoaXMgcmVkdWNlIGNhbGwgZm9yIGFsbCBsaXN0ZW5lcnM/XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIHJlZHVjZShpbml0aWFsLCBpKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQnVmZmVyaW5nIGNhc2VcbiAgICAgICAgICAgICAgICByZWR1Y2VEYXRhLml0ZW1zID8/PSBbXTtcbiAgICAgICAgICAgICAgICByZWR1Y2VEYXRhLml0ZW1zLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZURhdGEuYnVmZmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jbHVkZSBhIHNpbmdsZSBidWZmZXJlZCBmdW5jdGlvbiB0aGF0IHdpbGwgcmVkdWNlIGFsbCBldmVudHMgd2hlbiB3ZSdyZSBkb25lIGJ1ZmZlcmluZyBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5idWZmZXJzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FjaGUgdGhlIHJlZHVjZWQgcmVzdWx0IHNvIHRoYXQgdGhlIHZhbHVlIGNhbiBiZSBzaGFyZWQgYWNyb3NzIGFsbCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZHVjZURhdGEucmVkdWNlZFJlc3VsdCA/Pz0gaW5pdGlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVkdWNlRGF0YS5pdGVtcy5yZWR1Y2UocmVkdWNlLCBpbml0aWFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVkdWNlRGF0YS5pdGVtcy5yZWR1Y2UocmVkdWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIHJlZHVjZURhdGEucmVkdWNlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgZGlzcG9zYWJsZXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBidWZmZXJFdmVudHMoZm4pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgYnVmZmVyczogbmV3IEFycmF5KCkgfTtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIGNvbnN0IHIgPSBmbigpO1xuICAgICAgICB0aGlzLmRhdGEucG9wKCk7XG4gICAgICAgIGRhdGEuYnVmZmVycy5mb3JFYWNoKGZsdXNoID0+IGZsdXNoKCkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG59XG4vKipcbiAqIEEgUmVsYXkgaXMgYW4gZXZlbnQgZm9yd2FyZGVyIHdoaWNoIGZ1bmN0aW9ucyBhcyBhIHJlcGx1Z2FiYmxlIGV2ZW50IHBpcGUuXG4gKiBPbmNlIGNyZWF0ZWQsIHlvdSBjYW4gY29ubmVjdCBhbiBpbnB1dCBldmVudCB0byBpdCBhbmQgaXQgd2lsbCBzaW1wbHkgZm9yd2FyZFxuICogZXZlbnRzIGZyb20gdGhhdCBpbnB1dCBldmVudCB0aHJvdWdoIGl0cyBvd24gYGV2ZW50YCBwcm9wZXJ0eS4gVGhlIGBpbnB1dGBcbiAqIGNhbiBiZSBjaGFuZ2VkIGF0IGFueSBwb2ludCBpbiB0aW1lLlxuICovXG5leHBvcnQgY2xhc3MgUmVsYXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlucHV0RXZlbnQgPSBFdmVudC5Ob25lO1xuICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lciA9IERpc3Bvc2FibGUuTm9uZTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoe1xuICAgICAgICAgICAgb25EaWRBZGRGaXJzdExpc3RlbmVyOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRFdmVudExpc3RlbmVyID0gdGhpcy5pbnB1dEV2ZW50KHRoaXMuZW1pdHRlci5maXJlLCB0aGlzLmVtaXR0ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50ID0gdGhpcy5lbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBzZXQgaW5wdXQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5pbnB1dEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmluZykge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIgPSBldmVudCh0aGlzLmVtaXR0ZXIuZmlyZSwgdGhpcy5lbWl0dGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIEdpdmVuIGEgZnVuY3Rpb24sIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIG9ubHkgY2FsbGluZyB0aGF0IGZ1bmN0aW9uIG9uY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaW5nbGVDYWxsRnVuY3Rpb24oZm4sIGZuRGlkUnVuQ2FsbGJhY2spIHtcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgbGV0IGRpZENhbGwgPSBmYWxzZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkaWRDYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGRpZENhbGwgPSB0cnVlO1xuICAgICAgICBpZiAoZm5EaWRSdW5DYWxsYmFjaykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbi5hcHBseShfdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGZuRGlkUnVuQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KF90aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuL3N0cmluZ3MuanMnO1xuLyoqXG4gKiBSZXR1cm4gYSBoYXNoIHZhbHVlIGZvciBhbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKG9iaikge1xuICAgIHJldHVybiBkb0hhc2gob2JqLCAwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkb0hhc2gob2JqLCBoYXNoVmFsKSB7XG4gICAgc3dpdGNoICh0eXBlb2Ygb2JqKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlckhhc2goMzQ5LCBoYXNoVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUhhc2gob2JqLCBoYXNoVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3RIYXNoKG9iaiwgaGFzaFZhbCk7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nSGFzaChvYmosIGhhc2hWYWwpO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiBib29sZWFuSGFzaChvYmosIGhhc2hWYWwpO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgcmV0dXJuIG51bWJlckhhc2gob2JqLCBoYXNoVmFsKTtcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJIYXNoKDkzNywgaGFzaFZhbCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVySGFzaCg2MTcsIGhhc2hWYWwpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJIYXNoKHZhbCwgaW5pdGlhbEhhc2hWYWwpIHtcbiAgICByZXR1cm4gKCgoaW5pdGlhbEhhc2hWYWwgPDwgNSkgLSBpbml0aWFsSGFzaFZhbCkgKyB2YWwpIHwgMDsgLy8gaGFzaFZhbCAqIDMxICsgY2gsIGtlZXAgYXMgaW50MzJcbn1cbmZ1bmN0aW9uIGJvb2xlYW5IYXNoKGIsIGluaXRpYWxIYXNoVmFsKSB7XG4gICAgcmV0dXJuIG51bWJlckhhc2goYiA/IDQzMyA6IDg2MywgaW5pdGlhbEhhc2hWYWwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0hhc2gocywgaGFzaFZhbCkge1xuICAgIGhhc2hWYWwgPSBudW1iZXJIYXNoKDE0OTQxNywgaGFzaFZhbCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGFzaFZhbCA9IG51bWJlckhhc2gocy5jaGFyQ29kZUF0KGkpLCBoYXNoVmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2hWYWw7XG59XG5mdW5jdGlvbiBhcnJheUhhc2goYXJyLCBpbml0aWFsSGFzaFZhbCkge1xuICAgIGluaXRpYWxIYXNoVmFsID0gbnVtYmVySGFzaCgxMDQ1NzksIGluaXRpYWxIYXNoVmFsKTtcbiAgICByZXR1cm4gYXJyLnJlZHVjZSgoaGFzaFZhbCwgaXRlbSkgPT4gZG9IYXNoKGl0ZW0sIGhhc2hWYWwpLCBpbml0aWFsSGFzaFZhbCk7XG59XG5mdW5jdGlvbiBvYmplY3RIYXNoKG9iaiwgaW5pdGlhbEhhc2hWYWwpIHtcbiAgICBpbml0aWFsSGFzaFZhbCA9IG51bWJlckhhc2goMTgxMzg3LCBpbml0aWFsSGFzaFZhbCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikuc29ydCgpLnJlZHVjZSgoaGFzaFZhbCwga2V5KSA9PiB7XG4gICAgICAgIGhhc2hWYWwgPSBzdHJpbmdIYXNoKGtleSwgaGFzaFZhbCk7XG4gICAgICAgIHJldHVybiBkb0hhc2gob2JqW2tleV0sIGhhc2hWYWwpO1xuICAgIH0sIGluaXRpYWxIYXNoVmFsKTtcbn1cbmZ1bmN0aW9uIGxlZnRSb3RhdGUodmFsdWUsIGJpdHMsIHRvdGFsQml0cyA9IDMyKSB7XG4gICAgLy8gZGVsdGEgKyBiaXRzID0gdG90YWxCaXRzXG4gICAgY29uc3QgZGVsdGEgPSB0b3RhbEJpdHMgLSBiaXRzO1xuICAgIC8vIEFsbCBvbmVzLCBleHBlY3QgYGRlbHRhYCB6ZXJvcyBhbGlnbmVkIHRvIHRoZSByaWdodFxuICAgIGNvbnN0IG1hc2sgPSB+KCgxIDw8IGRlbHRhKSAtIDEpO1xuICAgIC8vIEpvaW4gKHZhbHVlIGxlZnQtc2hpZnRlZCBgYml0c2AgYml0cykgd2l0aCAobWFza2VkIHZhbHVlIHJpZ2h0LXNoaWZ0ZWQgYGRlbHRhYCBiaXRzKVxuICAgIHJldHVybiAoKHZhbHVlIDw8IGJpdHMpIHwgKChtYXNrICYgdmFsdWUpID4+PiBkZWx0YSkpID4+PiAwO1xufVxuZnVuY3Rpb24gZmlsbChkZXN0LCBpbmRleCA9IDAsIGNvdW50ID0gZGVzdC5ieXRlTGVuZ3RoLCB2YWx1ZSA9IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgZGVzdFtpbmRleCArIGldID0gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gbGVmdFBhZCh2YWx1ZSwgbGVuZ3RoLCBjaGFyID0gJzAnKSB7XG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IGNoYXIgKyB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4U3RyaW5nKGJ1ZmZlck9yVmFsdWUsIGJpdHNpemUgPSAzMikge1xuICAgIGlmIChidWZmZXJPclZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoYnVmZmVyT3JWYWx1ZSkpLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdFBhZCgoYnVmZmVyT3JWYWx1ZSA+Pj4gMCkudG9TdHJpbmcoMTYpLCBiaXRzaXplIC8gNCk7XG59XG4vKipcbiAqIEEgU0hBMSBpbXBsZW1lbnRhdGlvbiB0aGF0IHdvcmtzIHdpdGggc3RyaW5ncyBhbmQgZG9lcyBub3QgYWxsb2NhdGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJpbmdTSEExIHtcbiAgICBzdGF0aWMgeyB0aGlzLl9iaWdCbG9jazMyID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigzMjApKTsgfSAvLyA4MCAqIDQgPSAzMjBcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faDAgPSAweDY3NDUyMzAxO1xuICAgICAgICB0aGlzLl9oMSA9IDB4RUZDREFCODk7XG4gICAgICAgIHRoaXMuX2gyID0gMHg5OEJBRENGRTtcbiAgICAgICAgdGhpcy5faDMgPSAweDEwMzI1NDc2O1xuICAgICAgICB0aGlzLl9oNCA9IDB4QzNEMkUxRjA7XG4gICAgICAgIHRoaXMuX2J1ZmYgPSBuZXcgVWludDhBcnJheSg2NCAvKiBTSEExQ29uc3RhbnQuQkxPQ0tfU0laRSAqLyArIDMgLyogdG8gZml0IGFueSB1dGYtOCAqLyk7XG4gICAgICAgIHRoaXMuX2J1ZmZEViA9IG5ldyBEYXRhVmlldyh0aGlzLl9idWZmLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2J1ZmZMZW4gPSAwO1xuICAgICAgICB0aGlzLl90b3RhbExlbiA9IDA7XG4gICAgICAgIHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IDA7XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZShzdHIpIHtcbiAgICAgICAgY29uc3Qgc3RyTGVuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKHN0ckxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSB0aGlzLl9idWZmO1xuICAgICAgICBsZXQgYnVmZkxlbiA9IHRoaXMuX2J1ZmZMZW47XG4gICAgICAgIGxldCBsZWZ0b3ZlckhpZ2hTdXJyb2dhdGUgPSB0aGlzLl9sZWZ0b3ZlckhpZ2hTdXJyb2dhdGU7XG4gICAgICAgIGxldCBjaGFyQ29kZTtcbiAgICAgICAgbGV0IG9mZnNldDtcbiAgICAgICAgaWYgKGxlZnRvdmVySGlnaFN1cnJvZ2F0ZSAhPT0gMCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBsZWZ0b3ZlckhpZ2hTdXJyb2dhdGU7XG4gICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIGxlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGNvZGVQb2ludCA9IGNoYXJDb2RlO1xuICAgICAgICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgKyAxIDwgc3RyTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5ncy5pc0xvd1N1cnJvZ2F0ZShuZXh0Q2hhckNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHN0cmluZ3MuY29tcHV0ZUNvZGVQb2ludChjaGFyQ29kZSwgbmV4dENoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlsbGVnYWwgPT4gdW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IDY1NTMzIC8qIFNIQTFDb25zdGFudC5VTklDT0RFX1JFUExBQ0VNRU5UICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYXN0IGNoYXJhY3RlciBpcyBhIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IGNoYXJDb2RlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHJpbmdzLmlzTG93U3Vycm9nYXRlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIGlsbGVnYWwgPT4gdW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSA2NTUzMyAvKiBTSEExQ29uc3RhbnQuVU5JQ09ERV9SRVBMQUNFTUVOVCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZMZW4gPSB0aGlzLl9wdXNoKGJ1ZmYsIGJ1ZmZMZW4sIGNvZGVQb2ludCk7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCBzdHJMZW4pIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9idWZmTGVuID0gYnVmZkxlbjtcbiAgICAgICAgdGhpcy5fbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gbGVmdG92ZXJIaWdoU3Vycm9nYXRlO1xuICAgIH1cbiAgICBfcHVzaChidWZmLCBidWZmTGVuLCBjb2RlUG9pbnQpIHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MDA4MCkge1xuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gY29kZVBvaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MDgwMCkge1xuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMTAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTAwMDAwMCkgPj4+IDYpO1xuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMSkgPj4+IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTExMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDExMTEwMDAwMDAwMDAwMDApID4+PiAxMik7XG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjEwMDAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTExMDAwMDAwKSA+Pj4gNik7XG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjEwMDAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTExKSA+Pj4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjExMTEwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMTExMDAwMDAwMDAwMDAwMDAwMDAwKSA+Pj4gMTgpO1xuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDExMTExMTAwMDAwMDAwMDAwMCkgPj4+IDEyKTtcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTEwMDAwMDApID4+PiA2KTtcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTEpID4+PiAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZkxlbiA+PSA2NCAvKiBTSEExQ29uc3RhbnQuQkxPQ0tfU0laRSAqLykge1xuICAgICAgICAgICAgdGhpcy5fc3RlcCgpO1xuICAgICAgICAgICAgYnVmZkxlbiAtPSA2NCAvKiBTSEExQ29uc3RhbnQuQkxPQ0tfU0laRSAqLztcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuICs9IDY0IC8qIFNIQTFDb25zdGFudC5CTE9DS19TSVpFICovO1xuICAgICAgICAgICAgLy8gdGFrZSBsYXN0IDMgaW4gY2FzZSBvZiBVVEY4IG92ZXJmbG93XG4gICAgICAgICAgICBidWZmWzBdID0gYnVmZls2NCAvKiBTSEExQ29uc3RhbnQuQkxPQ0tfU0laRSAqLyArIDBdO1xuICAgICAgICAgICAgYnVmZlsxXSA9IGJ1ZmZbNjQgLyogU0hBMUNvbnN0YW50LkJMT0NLX1NJWkUgKi8gKyAxXTtcbiAgICAgICAgICAgIGJ1ZmZbMl0gPSBidWZmWzY0IC8qIFNIQTFDb25zdGFudC5CTE9DS19TSVpFICovICsgMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZMZW47XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZSkge1xuICAgICAgICAgICAgICAgIC8vIGlsbGVnYWwgPT4gdW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0b3ZlckhpZ2hTdXJyb2dhdGUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZMZW4gPSB0aGlzLl9wdXNoKHRoaXMuX2J1ZmYsIHRoaXMuX2J1ZmZMZW4sIDY1NTMzIC8qIFNIQTFDb25zdGFudC5VTklDT0RFX1JFUExBQ0VNRU5UICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuICs9IHRoaXMuX2J1ZmZMZW47XG4gICAgICAgICAgICB0aGlzLl93cmFwVXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9IZXhTdHJpbmcodGhpcy5faDApICsgdG9IZXhTdHJpbmcodGhpcy5faDEpICsgdG9IZXhTdHJpbmcodGhpcy5faDIpICsgdG9IZXhTdHJpbmcodGhpcy5faDMpICsgdG9IZXhTdHJpbmcodGhpcy5faDQpO1xuICAgIH1cbiAgICBfd3JhcFVwKCkge1xuICAgICAgICB0aGlzLl9idWZmW3RoaXMuX2J1ZmZMZW4rK10gPSAweDgwO1xuICAgICAgICBmaWxsKHRoaXMuX2J1ZmYsIHRoaXMuX2J1ZmZMZW4pO1xuICAgICAgICBpZiAodGhpcy5fYnVmZkxlbiA+IDU2KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGVwKCk7XG4gICAgICAgICAgICBmaWxsKHRoaXMuX2J1ZmYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgd2lsbCBmaXQgYmVjYXVzZSB0aGUgbWFudGlzc2EgY2FuIGNvdmVyIHVwIHRvIDUyIGJpdHNcbiAgICAgICAgY29uc3QgbWwgPSA4ICogdGhpcy5fdG90YWxMZW47XG4gICAgICAgIHRoaXMuX2J1ZmZEVi5zZXRVaW50MzIoNTYsIE1hdGguZmxvb3IobWwgLyA0Mjk0OTY3Mjk2KSwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9idWZmRFYuc2V0VWludDMyKDYwLCBtbCAlIDQyOTQ5NjcyOTYsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc3RlcCgpO1xuICAgIH1cbiAgICBfc3RlcCgpIHtcbiAgICAgICAgY29uc3QgYmlnQmxvY2szMiA9IFN0cmluZ1NIQTEuX2JpZ0Jsb2NrMzI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9idWZmRFY7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjQgLyogMTYqNCAqLzsgaiArPSA0KSB7XG4gICAgICAgICAgICBiaWdCbG9jazMyLnNldFVpbnQzMihqLCBkYXRhLmdldFVpbnQzMihqLCBmYWxzZSksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gNjQ7IGogPCAzMjAgLyogODAqNCAqLzsgaiArPSA0KSB7XG4gICAgICAgICAgICBiaWdCbG9jazMyLnNldFVpbnQzMihqLCBsZWZ0Um90YXRlKChiaWdCbG9jazMyLmdldFVpbnQzMihqIC0gMTIsIGZhbHNlKSBeIGJpZ0Jsb2NrMzIuZ2V0VWludDMyKGogLSAzMiwgZmFsc2UpIF4gYmlnQmxvY2szMi5nZXRVaW50MzIoaiAtIDU2LCBmYWxzZSkgXiBiaWdCbG9jazMyLmdldFVpbnQzMihqIC0gNjQsIGZhbHNlKSksIDEpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGEgPSB0aGlzLl9oMDtcbiAgICAgICAgbGV0IGIgPSB0aGlzLl9oMTtcbiAgICAgICAgbGV0IGMgPSB0aGlzLl9oMjtcbiAgICAgICAgbGV0IGQgPSB0aGlzLl9oMztcbiAgICAgICAgbGV0IGUgPSB0aGlzLl9oNDtcbiAgICAgICAgbGV0IGYsIGs7XG4gICAgICAgIGxldCB0ZW1wO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqIDwgMjApIHtcbiAgICAgICAgICAgICAgICBmID0gKGIgJiBjKSB8ICgofmIpICYgZCk7XG4gICAgICAgICAgICAgICAgayA9IDB4NUE4Mjc5OTk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChqIDwgNDApIHtcbiAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICAgICAgICAgIGsgPSAweDZFRDlFQkExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaiA8IDYwKSB7XG4gICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcbiAgICAgICAgICAgICAgICBrID0gMHg4RjFCQkNEQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgayA9IDB4Q0E2MkMxRDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wID0gKGxlZnRSb3RhdGUoYSwgNSkgKyBmICsgZSArIGsgKyBiaWdCbG9jazMyLmdldFVpbnQzMihqICogNCwgZmFsc2UpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgICAgYyA9IGxlZnRSb3RhdGUoYiwgMzApO1xuICAgICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgICBhID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oMCA9ICh0aGlzLl9oMCArIGEpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5faDEgPSAodGhpcy5faDEgKyBiKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuX2gyID0gKHRoaXMuX2gyICsgYykgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLl9oMyA9ICh0aGlzLl9oMyArIGQpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5faDQgPSAodGhpcy5faDQgKyBlKSAmIDB4ZmZmZmZmZmY7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgdmFyIEl0ZXJhYmxlO1xuKGZ1bmN0aW9uIChJdGVyYWJsZSkge1xuICAgIGZ1bmN0aW9uIGlzKHRoaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aGluZ1tTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICBJdGVyYWJsZS5pcyA9IGlzO1xuICAgIGNvbnN0IF9lbXB0eSA9IE9iamVjdC5mcmVlemUoW10pO1xuICAgIGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gX2VtcHR5O1xuICAgIH1cbiAgICBJdGVyYWJsZS5lbXB0eSA9IGVtcHR5O1xuICAgIGZ1bmN0aW9uKiBzaW5nbGUoZWxlbWVudCkge1xuICAgICAgICB5aWVsZCBlbGVtZW50O1xuICAgIH1cbiAgICBJdGVyYWJsZS5zaW5nbGUgPSBzaW5nbGU7XG4gICAgZnVuY3Rpb24gd3JhcChpdGVyYWJsZU9yRWxlbWVudCkge1xuICAgICAgICBpZiAoaXMoaXRlcmFibGVPckVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmFibGVPckVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2luZ2xlKGl0ZXJhYmxlT3JFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBJdGVyYWJsZS53cmFwID0gd3JhcDtcbiAgICBmdW5jdGlvbiBmcm9tKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZSB8fCBfZW1wdHk7XG4gICAgfVxuICAgIEl0ZXJhYmxlLmZyb20gPSBmcm9tO1xuICAgIGZ1bmN0aW9uKiByZXZlcnNlKGFycmF5KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgeWllbGQgYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgSXRlcmFibGUucmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgZnVuY3Rpb24gaXNFbXB0eShpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gIWl0ZXJhYmxlIHx8IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkuZG9uZSA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgSXRlcmFibGUuaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgZnVuY3Rpb24gZmlyc3QoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkudmFsdWU7XG4gICAgfVxuICAgIEl0ZXJhYmxlLmZpcnN0ID0gZmlyc3Q7XG4gICAgZnVuY3Rpb24gc29tZShpdGVyYWJsZSwgcHJlZGljYXRlKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGVsZW1lbnQsIGkrKykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIEl0ZXJhYmxlLnNvbWUgPSBzb21lO1xuICAgIGZ1bmN0aW9uIGZpbmQoaXRlcmFibGUsIHByZWRpY2F0ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBJdGVyYWJsZS5maW5kID0gZmluZDtcbiAgICBmdW5jdGlvbiogZmlsdGVyKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBJdGVyYWJsZS5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgZnVuY3Rpb24qIG1hcChpdGVyYWJsZSwgZm4pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICB5aWVsZCBmbihlbGVtZW50LCBpbmRleCsrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBJdGVyYWJsZS5tYXAgPSBtYXA7XG4gICAgZnVuY3Rpb24qIGZsYXRNYXAoaXRlcmFibGUsIGZuKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgeWllbGQqIGZuKGVsZW1lbnQsIGluZGV4KyspO1xuICAgICAgICB9XG4gICAgfVxuICAgIEl0ZXJhYmxlLmZsYXRNYXAgPSBmbGF0TWFwO1xuICAgIGZ1bmN0aW9uKiBjb25jYXQoLi4uaXRlcmFibGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlcmFibGUgb2YgaXRlcmFibGVzKSB7XG4gICAgICAgICAgICB5aWVsZCogaXRlcmFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSXRlcmFibGUuY29uY2F0ID0gY29uY2F0O1xuICAgIGZ1bmN0aW9uIHJlZHVjZShpdGVyYWJsZSwgcmVkdWNlciwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlZHVjZXIodmFsdWUsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgSXRlcmFibGUucmVkdWNlID0gcmVkdWNlO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaXRlcmFibGUgc2xpY2Ugb2YgdGhlIGFycmF5LCB3aXRoIHRoZSBzYW1lIHNlbWFudGljcyBhcyBgYXJyYXkuc2xpY2UoKWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24qIHNsaWNlKGFyciwgZnJvbSwgdG8gPSBhcnIubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgICAgZnJvbSArPSBhcnIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgICAgIHRvICs9IGFyci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG8gPiBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0byA9IGFyci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGZyb20gPCB0bzsgZnJvbSsrKSB7XG4gICAgICAgICAgICB5aWVsZCBhcnJbZnJvbV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgSXRlcmFibGUuc2xpY2UgPSBzbGljZTtcbiAgICAvKipcbiAgICAgKiBDb25zdW1lcyBgYXRNb3N0YCBlbGVtZW50cyBmcm9tIGl0ZXJhYmxlIGFuZCByZXR1cm5zIHRoZSBjb25zdW1lZCBlbGVtZW50cyxcbiAgICAgKiBhbmQgYW4gaXRlcmFibGUgZm9yIHRoZSByZXN0IG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdW1lKGl0ZXJhYmxlLCBhdE1vc3QgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgY29uc3QgY29uc3VtZWQgPSBbXTtcbiAgICAgICAgaWYgKGF0TW9zdCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtjb25zdW1lZCwgaXRlcmFibGVdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0TW9zdDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbY29uc3VtZWQsIEl0ZXJhYmxlLmVtcHR5KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3VtZWQucHVzaChuZXh0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2NvbnN1bWVkLCB7IFtTeW1ib2wuaXRlcmF0b3JdKCkgeyByZXR1cm4gaXRlcmF0b3I7IH0gfV07XG4gICAgfVxuICAgIEl0ZXJhYmxlLmNvbnN1bWUgPSBjb25zdW1lO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGFzeW5jVG9BcnJheShpdGVyYWJsZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIEl0ZXJhYmxlLmFzeW5jVG9BcnJheSA9IGFzeW5jVG9BcnJheTtcbn0pKEl0ZXJhYmxlIHx8IChJdGVyYWJsZSA9IHt9KSk7XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmNsYXNzIEtleUNvZGVTdHJNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9rZXlDb2RlVG9TdHIgPSBbXTtcbiAgICAgICAgdGhpcy5fc3RyVG9LZXlDb2RlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgZGVmaW5lKGtleUNvZGUsIHN0cikge1xuICAgICAgICB0aGlzLl9rZXlDb2RlVG9TdHJba2V5Q29kZV0gPSBzdHI7XG4gICAgICAgIHRoaXMuX3N0clRvS2V5Q29kZVtzdHIudG9Mb3dlckNhc2UoKV0gPSBrZXlDb2RlO1xuICAgIH1cbiAgICBrZXlDb2RlVG9TdHIoa2V5Q29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5Q29kZVRvU3RyW2tleUNvZGVdO1xuICAgIH1cbiAgICBzdHJUb0tleUNvZGUoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJUb0tleUNvZGVbc3RyLnRvTG93ZXJDYXNlKCldIHx8IDAgLyogS2V5Q29kZS5Vbmtub3duICovO1xuICAgIH1cbn1cbmNvbnN0IHVpTWFwID0gbmV3IEtleUNvZGVTdHJNYXAoKTtcbmNvbnN0IHVzZXJTZXR0aW5nc1VTTWFwID0gbmV3IEtleUNvZGVTdHJNYXAoKTtcbmNvbnN0IHVzZXJTZXR0aW5nc0dlbmVyYWxNYXAgPSBuZXcgS2V5Q29kZVN0ck1hcCgpO1xuZXhwb3J0IGNvbnN0IEVWRU5UX0tFWV9DT0RFX01BUCA9IG5ldyBBcnJheSgyMzApO1xuZXhwb3J0IGNvbnN0IE5BVElWRV9XSU5ET1dTX0tFWV9DT0RFX1RPX0tFWV9DT0RFID0ge307XG5jb25zdCBzY2FuQ29kZUludFRvU3RyID0gW107XG5jb25zdCBzY2FuQ29kZVN0clRvSW50ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IHNjYW5Db2RlTG93ZXJDYXNlU3RyVG9JbnQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG4gKiAtMSBpZiBhIFNjYW5Db2RlID0+IEtleUNvZGUgbWFwcGluZyBkZXBlbmRzIG9uIGtiIGxheW91dC5cbiAqL1xuZXhwb3J0IGNvbnN0IElNTVVUQUJMRV9DT0RFX1RPX0tFWV9DT0RFID0gW107XG4vKipcbiAqIC0xIGlmIGEgS2V5Q29kZSA9PiBTY2FuQ29kZSBtYXBwaW5nIGRlcGVuZHMgb24ga2IgbGF5b3V0LlxuICovXG5leHBvcnQgY29uc3QgSU1NVVRBQkxFX0tFWV9DT0RFX1RPX0NPREUgPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDw9IDE5MyAvKiBTY2FuQ29kZS5NQVhfVkFMVUUgKi87IGkrKykge1xuICAgIElNTVVUQUJMRV9DT0RFX1RPX0tFWV9DT0RFW2ldID0gLTEgLyogS2V5Q29kZS5EZXBlbmRzT25LYkxheW91dCAqLztcbn1cbmZvciAobGV0IGkgPSAwOyBpIDw9IDEzMiAvKiBLZXlDb2RlLk1BWF9WQUxVRSAqLzsgaSsrKSB7XG4gICAgSU1NVVRBQkxFX0tFWV9DT0RFX1RPX0NPREVbaV0gPSAtMSAvKiBTY2FuQ29kZS5EZXBlbmRzT25LYkxheW91dCAqLztcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2VlIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2RkMzc1NzMxKHY9dnMuODUpLmFzcHhcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9ub2RlLW5hdGl2ZS1rZXltYXAvYmxvYi84OGMwYjBlNS9kZXBzL2Nocm9taXVtL2tleWJvYXJkX2NvZGVzX3dpbi5oXG4gICAgY29uc3QgZW1wdHkgPSAnJztcbiAgICBjb25zdCBtYXBwaW5ncyA9IFtcbiAgICAgICAgLy8gaW1tdXRhYmxlLCBzY2FuQ29kZSwgc2NhbkNvZGVTdHIsIGtleUNvZGUsIGtleUNvZGVTdHIsIGV2ZW50S2V5Q29kZSwgdmtleSwgdXNVc2VyU2V0dGluZ3NMYWJlbCwgZ2VuZXJhbFVzZXJTZXR0aW5nc0xhYmVsXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sICdOb25lJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sICd1bmtub3duJywgMCwgJ1ZLX1VOS05PV04nLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMSAvKiBTY2FuQ29kZS5IeXBlciAqLywgJ0h5cGVyJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDIgLyogU2NhbkNvZGUuU3VwZXIgKi8sICdTdXBlcicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAzIC8qIFNjYW5Db2RlLkZuICovLCAnRm4nLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNCAvKiBTY2FuQ29kZS5GbkxvY2sgKi8sICdGbkxvY2snLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNSAvKiBTY2FuQ29kZS5TdXNwZW5kICovLCAnU3VzcGVuZCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA2IC8qIFNjYW5Db2RlLlJlc3VtZSAqLywgJ1Jlc3VtZScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA3IC8qIFNjYW5Db2RlLlR1cmJvICovLCAnVHVyYm8nLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgOCAvKiBTY2FuQ29kZS5TbGVlcCAqLywgJ1NsZWVwJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfU0xFRVAnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgOSAvKiBTY2FuQ29kZS5XYWtlVXAgKi8sICdXYWtlVXAnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMTAgLyogU2NhbkNvZGUuS2V5QSAqLywgJ0tleUEnLCAzMSAvKiBLZXlDb2RlLktleUEgKi8sICdBJywgNjUsICdWS19BJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDExIC8qIFNjYW5Db2RlLktleUIgKi8sICdLZXlCJywgMzIgLyogS2V5Q29kZS5LZXlCICovLCAnQicsIDY2LCAnVktfQicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxMiAvKiBTY2FuQ29kZS5LZXlDICovLCAnS2V5QycsIDMzIC8qIEtleUNvZGUuS2V5QyAqLywgJ0MnLCA2NywgJ1ZLX0MnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMTMgLyogU2NhbkNvZGUuS2V5RCAqLywgJ0tleUQnLCAzNCAvKiBLZXlDb2RlLktleUQgKi8sICdEJywgNjgsICdWS19EJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDE0IC8qIFNjYW5Db2RlLktleUUgKi8sICdLZXlFJywgMzUgLyogS2V5Q29kZS5LZXlFICovLCAnRScsIDY5LCAnVktfRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxNSAvKiBTY2FuQ29kZS5LZXlGICovLCAnS2V5RicsIDM2IC8qIEtleUNvZGUuS2V5RiAqLywgJ0YnLCA3MCwgJ1ZLX0YnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMTYgLyogU2NhbkNvZGUuS2V5RyAqLywgJ0tleUcnLCAzNyAvKiBLZXlDb2RlLktleUcgKi8sICdHJywgNzEsICdWS19HJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDE3IC8qIFNjYW5Db2RlLktleUggKi8sICdLZXlIJywgMzggLyogS2V5Q29kZS5LZXlIICovLCAnSCcsIDcyLCAnVktfSCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxOCAvKiBTY2FuQ29kZS5LZXlJICovLCAnS2V5SScsIDM5IC8qIEtleUNvZGUuS2V5SSAqLywgJ0knLCA3MywgJ1ZLX0knLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMTkgLyogU2NhbkNvZGUuS2V5SiAqLywgJ0tleUonLCA0MCAvKiBLZXlDb2RlLktleUogKi8sICdKJywgNzQsICdWS19KJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDIwIC8qIFNjYW5Db2RlLktleUsgKi8sICdLZXlLJywgNDEgLyogS2V5Q29kZS5LZXlLICovLCAnSycsIDc1LCAnVktfSycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAyMSAvKiBTY2FuQ29kZS5LZXlMICovLCAnS2V5TCcsIDQyIC8qIEtleUNvZGUuS2V5TCAqLywgJ0wnLCA3NiwgJ1ZLX0wnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMjIgLyogU2NhbkNvZGUuS2V5TSAqLywgJ0tleU0nLCA0MyAvKiBLZXlDb2RlLktleU0gKi8sICdNJywgNzcsICdWS19NJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDIzIC8qIFNjYW5Db2RlLktleU4gKi8sICdLZXlOJywgNDQgLyogS2V5Q29kZS5LZXlOICovLCAnTicsIDc4LCAnVktfTicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAyNCAvKiBTY2FuQ29kZS5LZXlPICovLCAnS2V5TycsIDQ1IC8qIEtleUNvZGUuS2V5TyAqLywgJ08nLCA3OSwgJ1ZLX08nLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMjUgLyogU2NhbkNvZGUuS2V5UCAqLywgJ0tleVAnLCA0NiAvKiBLZXlDb2RlLktleVAgKi8sICdQJywgODAsICdWS19QJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDI2IC8qIFNjYW5Db2RlLktleVEgKi8sICdLZXlRJywgNDcgLyogS2V5Q29kZS5LZXlRICovLCAnUScsIDgxLCAnVktfUScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAyNyAvKiBTY2FuQ29kZS5LZXlSICovLCAnS2V5UicsIDQ4IC8qIEtleUNvZGUuS2V5UiAqLywgJ1InLCA4MiwgJ1ZLX1InLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMjggLyogU2NhbkNvZGUuS2V5UyAqLywgJ0tleVMnLCA0OSAvKiBLZXlDb2RlLktleVMgKi8sICdTJywgODMsICdWS19TJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDI5IC8qIFNjYW5Db2RlLktleVQgKi8sICdLZXlUJywgNTAgLyogS2V5Q29kZS5LZXlUICovLCAnVCcsIDg0LCAnVktfVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAzMCAvKiBTY2FuQ29kZS5LZXlVICovLCAnS2V5VScsIDUxIC8qIEtleUNvZGUuS2V5VSAqLywgJ1UnLCA4NSwgJ1ZLX1UnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMzEgLyogU2NhbkNvZGUuS2V5ViAqLywgJ0tleVYnLCA1MiAvKiBLZXlDb2RlLktleVYgKi8sICdWJywgODYsICdWS19WJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDMyIC8qIFNjYW5Db2RlLktleVcgKi8sICdLZXlXJywgNTMgLyogS2V5Q29kZS5LZXlXICovLCAnVycsIDg3LCAnVktfVycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAzMyAvKiBTY2FuQ29kZS5LZXlYICovLCAnS2V5WCcsIDU0IC8qIEtleUNvZGUuS2V5WCAqLywgJ1gnLCA4OCwgJ1ZLX1gnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMzQgLyogU2NhbkNvZGUuS2V5WSAqLywgJ0tleVknLCA1NSAvKiBLZXlDb2RlLktleVkgKi8sICdZJywgODksICdWS19ZJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDM1IC8qIFNjYW5Db2RlLktleVogKi8sICdLZXlaJywgNTYgLyogS2V5Q29kZS5LZXlaICovLCAnWicsIDkwLCAnVktfWicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAzNiAvKiBTY2FuQ29kZS5EaWdpdDEgKi8sICdEaWdpdDEnLCAyMiAvKiBLZXlDb2RlLkRpZ2l0MSAqLywgJzEnLCA0OSwgJ1ZLXzEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMzcgLyogU2NhbkNvZGUuRGlnaXQyICovLCAnRGlnaXQyJywgMjMgLyogS2V5Q29kZS5EaWdpdDIgKi8sICcyJywgNTAsICdWS18yJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDM4IC8qIFNjYW5Db2RlLkRpZ2l0MyAqLywgJ0RpZ2l0MycsIDI0IC8qIEtleUNvZGUuRGlnaXQzICovLCAnMycsIDUxLCAnVktfMycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAzOSAvKiBTY2FuQ29kZS5EaWdpdDQgKi8sICdEaWdpdDQnLCAyNSAvKiBLZXlDb2RlLkRpZ2l0NCAqLywgJzQnLCA1MiwgJ1ZLXzQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgNDAgLyogU2NhbkNvZGUuRGlnaXQ1ICovLCAnRGlnaXQ1JywgMjYgLyogS2V5Q29kZS5EaWdpdDUgKi8sICc1JywgNTMsICdWS181JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDQxIC8qIFNjYW5Db2RlLkRpZ2l0NiAqLywgJ0RpZ2l0NicsIDI3IC8qIEtleUNvZGUuRGlnaXQ2ICovLCAnNicsIDU0LCAnVktfNicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCA0MiAvKiBTY2FuQ29kZS5EaWdpdDcgKi8sICdEaWdpdDcnLCAyOCAvKiBLZXlDb2RlLkRpZ2l0NyAqLywgJzcnLCA1NSwgJ1ZLXzcnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgNDMgLyogU2NhbkNvZGUuRGlnaXQ4ICovLCAnRGlnaXQ4JywgMjkgLyogS2V5Q29kZS5EaWdpdDggKi8sICc4JywgNTYsICdWS184JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDQ0IC8qIFNjYW5Db2RlLkRpZ2l0OSAqLywgJ0RpZ2l0OScsIDMwIC8qIEtleUNvZGUuRGlnaXQ5ICovLCAnOScsIDU3LCAnVktfOScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCA0NSAvKiBTY2FuQ29kZS5EaWdpdDAgKi8sICdEaWdpdDAnLCAyMSAvKiBLZXlDb2RlLkRpZ2l0MCAqLywgJzAnLCA0OCwgJ1ZLXzAnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNDYgLyogU2NhbkNvZGUuRW50ZXIgKi8sICdFbnRlcicsIDMgLyogS2V5Q29kZS5FbnRlciAqLywgJ0VudGVyJywgMTMsICdWS19SRVRVUk4nLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNDcgLyogU2NhbkNvZGUuRXNjYXBlICovLCAnRXNjYXBlJywgOSAvKiBLZXlDb2RlLkVzY2FwZSAqLywgJ0VzY2FwZScsIDI3LCAnVktfRVNDQVBFJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDQ4IC8qIFNjYW5Db2RlLkJhY2tzcGFjZSAqLywgJ0JhY2tzcGFjZScsIDEgLyogS2V5Q29kZS5CYWNrc3BhY2UgKi8sICdCYWNrc3BhY2UnLCA4LCAnVktfQkFDSycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA0OSAvKiBTY2FuQ29kZS5UYWIgKi8sICdUYWInLCAyIC8qIEtleUNvZGUuVGFiICovLCAnVGFiJywgOSwgJ1ZLX1RBQicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA1MCAvKiBTY2FuQ29kZS5TcGFjZSAqLywgJ1NwYWNlJywgMTAgLyogS2V5Q29kZS5TcGFjZSAqLywgJ1NwYWNlJywgMzIsICdWS19TUEFDRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCA1MSAvKiBTY2FuQ29kZS5NaW51cyAqLywgJ01pbnVzJywgODggLyogS2V5Q29kZS5NaW51cyAqLywgJy0nLCAxODksICdWS19PRU1fTUlOVVMnLCAnLScsICdPRU1fTUlOVVMnXSxcbiAgICAgICAgWzAsIDUyIC8qIFNjYW5Db2RlLkVxdWFsICovLCAnRXF1YWwnLCA4NiAvKiBLZXlDb2RlLkVxdWFsICovLCAnPScsIDE4NywgJ1ZLX09FTV9QTFVTJywgJz0nLCAnT0VNX1BMVVMnXSxcbiAgICAgICAgWzAsIDUzIC8qIFNjYW5Db2RlLkJyYWNrZXRMZWZ0ICovLCAnQnJhY2tldExlZnQnLCA5MiAvKiBLZXlDb2RlLkJyYWNrZXRMZWZ0ICovLCAnWycsIDIxOSwgJ1ZLX09FTV80JywgJ1snLCAnT0VNXzQnXSxcbiAgICAgICAgWzAsIDU0IC8qIFNjYW5Db2RlLkJyYWNrZXRSaWdodCAqLywgJ0JyYWNrZXRSaWdodCcsIDk0IC8qIEtleUNvZGUuQnJhY2tldFJpZ2h0ICovLCAnXScsIDIyMSwgJ1ZLX09FTV82JywgJ10nLCAnT0VNXzYnXSxcbiAgICAgICAgWzAsIDU1IC8qIFNjYW5Db2RlLkJhY2tzbGFzaCAqLywgJ0JhY2tzbGFzaCcsIDkzIC8qIEtleUNvZGUuQmFja3NsYXNoICovLCAnXFxcXCcsIDIyMCwgJ1ZLX09FTV81JywgJ1xcXFwnLCAnT0VNXzUnXSxcbiAgICAgICAgWzAsIDU2IC8qIFNjYW5Db2RlLkludGxIYXNoICovLCAnSW50bEhhc2gnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLCAvLyBoYXMgYmVlbiBkcm9wcGVkIGZyb20gdGhlIHczYyBzcGVjXG4gICAgICAgIFswLCA1NyAvKiBTY2FuQ29kZS5TZW1pY29sb24gKi8sICdTZW1pY29sb24nLCA4NSAvKiBLZXlDb2RlLlNlbWljb2xvbiAqLywgJzsnLCAxODYsICdWS19PRU1fMScsICc7JywgJ09FTV8xJ10sXG4gICAgICAgIFswLCA1OCAvKiBTY2FuQ29kZS5RdW90ZSAqLywgJ1F1b3RlJywgOTUgLyogS2V5Q29kZS5RdW90ZSAqLywgJ1xcJycsIDIyMiwgJ1ZLX09FTV83JywgJ1xcJycsICdPRU1fNyddLFxuICAgICAgICBbMCwgNTkgLyogU2NhbkNvZGUuQmFja3F1b3RlICovLCAnQmFja3F1b3RlJywgOTEgLyogS2V5Q29kZS5CYWNrcXVvdGUgKi8sICdgJywgMTkyLCAnVktfT0VNXzMnLCAnYCcsICdPRU1fMyddLFxuICAgICAgICBbMCwgNjAgLyogU2NhbkNvZGUuQ29tbWEgKi8sICdDb21tYScsIDg3IC8qIEtleUNvZGUuQ29tbWEgKi8sICcsJywgMTg4LCAnVktfT0VNX0NPTU1BJywgJywnLCAnT0VNX0NPTU1BJ10sXG4gICAgICAgIFswLCA2MSAvKiBTY2FuQ29kZS5QZXJpb2QgKi8sICdQZXJpb2QnLCA4OSAvKiBLZXlDb2RlLlBlcmlvZCAqLywgJy4nLCAxOTAsICdWS19PRU1fUEVSSU9EJywgJy4nLCAnT0VNX1BFUklPRCddLFxuICAgICAgICBbMCwgNjIgLyogU2NhbkNvZGUuU2xhc2ggKi8sICdTbGFzaCcsIDkwIC8qIEtleUNvZGUuU2xhc2ggKi8sICcvJywgMTkxLCAnVktfT0VNXzInLCAnLycsICdPRU1fMiddLFxuICAgICAgICBbMSwgNjMgLyogU2NhbkNvZGUuQ2Fwc0xvY2sgKi8sICdDYXBzTG9jaycsIDggLyogS2V5Q29kZS5DYXBzTG9jayAqLywgJ0NhcHNMb2NrJywgMjAsICdWS19DQVBJVEFMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDY0IC8qIFNjYW5Db2RlLkYxICovLCAnRjEnLCA1OSAvKiBLZXlDb2RlLkYxICovLCAnRjEnLCAxMTIsICdWS19GMScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA2NSAvKiBTY2FuQ29kZS5GMiAqLywgJ0YyJywgNjAgLyogS2V5Q29kZS5GMiAqLywgJ0YyJywgMTEzLCAnVktfRjInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNjYgLyogU2NhbkNvZGUuRjMgKi8sICdGMycsIDYxIC8qIEtleUNvZGUuRjMgKi8sICdGMycsIDExNCwgJ1ZLX0YzJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDY3IC8qIFNjYW5Db2RlLkY0ICovLCAnRjQnLCA2MiAvKiBLZXlDb2RlLkY0ICovLCAnRjQnLCAxMTUsICdWS19GNCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA2OCAvKiBTY2FuQ29kZS5GNSAqLywgJ0Y1JywgNjMgLyogS2V5Q29kZS5GNSAqLywgJ0Y1JywgMTE2LCAnVktfRjUnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNjkgLyogU2NhbkNvZGUuRjYgKi8sICdGNicsIDY0IC8qIEtleUNvZGUuRjYgKi8sICdGNicsIDExNywgJ1ZLX0Y2JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDcwIC8qIFNjYW5Db2RlLkY3ICovLCAnRjcnLCA2NSAvKiBLZXlDb2RlLkY3ICovLCAnRjcnLCAxMTgsICdWS19GNycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA3MSAvKiBTY2FuQ29kZS5GOCAqLywgJ0Y4JywgNjYgLyogS2V5Q29kZS5GOCAqLywgJ0Y4JywgMTE5LCAnVktfRjgnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNzIgLyogU2NhbkNvZGUuRjkgKi8sICdGOScsIDY3IC8qIEtleUNvZGUuRjkgKi8sICdGOScsIDEyMCwgJ1ZLX0Y5JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDczIC8qIFNjYW5Db2RlLkYxMCAqLywgJ0YxMCcsIDY4IC8qIEtleUNvZGUuRjEwICovLCAnRjEwJywgMTIxLCAnVktfRjEwJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDc0IC8qIFNjYW5Db2RlLkYxMSAqLywgJ0YxMScsIDY5IC8qIEtleUNvZGUuRjExICovLCAnRjExJywgMTIyLCAnVktfRjExJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDc1IC8qIFNjYW5Db2RlLkYxMiAqLywgJ0YxMicsIDcwIC8qIEtleUNvZGUuRjEyICovLCAnRjEyJywgMTIzLCAnVktfRjEyJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDc2IC8qIFNjYW5Db2RlLlByaW50U2NyZWVuICovLCAnUHJpbnRTY3JlZW4nLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNzcgLyogU2NhbkNvZGUuU2Nyb2xsTG9jayAqLywgJ1Njcm9sbExvY2snLCA4NCAvKiBLZXlDb2RlLlNjcm9sbExvY2sgKi8sICdTY3JvbGxMb2NrJywgMTQ1LCAnVktfU0NST0xMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDc4IC8qIFNjYW5Db2RlLlBhdXNlICovLCAnUGF1c2UnLCA3IC8qIEtleUNvZGUuUGF1c2VCcmVhayAqLywgJ1BhdXNlQnJlYWsnLCAxOSwgJ1ZLX1BBVVNFJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDc5IC8qIFNjYW5Db2RlLkluc2VydCAqLywgJ0luc2VydCcsIDE5IC8qIEtleUNvZGUuSW5zZXJ0ICovLCAnSW5zZXJ0JywgNDUsICdWS19JTlNFUlQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgODAgLyogU2NhbkNvZGUuSG9tZSAqLywgJ0hvbWUnLCAxNCAvKiBLZXlDb2RlLkhvbWUgKi8sICdIb21lJywgMzYsICdWS19IT01FJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDgxIC8qIFNjYW5Db2RlLlBhZ2VVcCAqLywgJ1BhZ2VVcCcsIDExIC8qIEtleUNvZGUuUGFnZVVwICovLCAnUGFnZVVwJywgMzMsICdWS19QUklPUicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA4MiAvKiBTY2FuQ29kZS5EZWxldGUgKi8sICdEZWxldGUnLCAyMCAvKiBLZXlDb2RlLkRlbGV0ZSAqLywgJ0RlbGV0ZScsIDQ2LCAnVktfREVMRVRFJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDgzIC8qIFNjYW5Db2RlLkVuZCAqLywgJ0VuZCcsIDEzIC8qIEtleUNvZGUuRW5kICovLCAnRW5kJywgMzUsICdWS19FTkQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgODQgLyogU2NhbkNvZGUuUGFnZURvd24gKi8sICdQYWdlRG93bicsIDEyIC8qIEtleUNvZGUuUGFnZURvd24gKi8sICdQYWdlRG93bicsIDM0LCAnVktfTkVYVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA4NSAvKiBTY2FuQ29kZS5BcnJvd1JpZ2h0ICovLCAnQXJyb3dSaWdodCcsIDE3IC8qIEtleUNvZGUuUmlnaHRBcnJvdyAqLywgJ1JpZ2h0QXJyb3cnLCAzOSwgJ1ZLX1JJR0hUJywgJ1JpZ2h0JywgZW1wdHldLFxuICAgICAgICBbMSwgODYgLyogU2NhbkNvZGUuQXJyb3dMZWZ0ICovLCAnQXJyb3dMZWZ0JywgMTUgLyogS2V5Q29kZS5MZWZ0QXJyb3cgKi8sICdMZWZ0QXJyb3cnLCAzNywgJ1ZLX0xFRlQnLCAnTGVmdCcsIGVtcHR5XSxcbiAgICAgICAgWzEsIDg3IC8qIFNjYW5Db2RlLkFycm93RG93biAqLywgJ0Fycm93RG93bicsIDE4IC8qIEtleUNvZGUuRG93bkFycm93ICovLCAnRG93bkFycm93JywgNDAsICdWS19ET1dOJywgJ0Rvd24nLCBlbXB0eV0sXG4gICAgICAgIFsxLCA4OCAvKiBTY2FuQ29kZS5BcnJvd1VwICovLCAnQXJyb3dVcCcsIDE2IC8qIEtleUNvZGUuVXBBcnJvdyAqLywgJ1VwQXJyb3cnLCAzOCwgJ1ZLX1VQJywgJ1VwJywgZW1wdHldLFxuICAgICAgICBbMSwgODkgLyogU2NhbkNvZGUuTnVtTG9jayAqLywgJ051bUxvY2snLCA4MyAvKiBLZXlDb2RlLk51bUxvY2sgKi8sICdOdW1Mb2NrJywgMTQ0LCAnVktfTlVNTE9DSycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA5MCAvKiBTY2FuQ29kZS5OdW1wYWREaXZpZGUgKi8sICdOdW1wYWREaXZpZGUnLCAxMTMgLyogS2V5Q29kZS5OdW1wYWREaXZpZGUgKi8sICdOdW1QYWRfRGl2aWRlJywgMTExLCAnVktfRElWSURFJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDkxIC8qIFNjYW5Db2RlLk51bXBhZE11bHRpcGx5ICovLCAnTnVtcGFkTXVsdGlwbHknLCAxMDggLyogS2V5Q29kZS5OdW1wYWRNdWx0aXBseSAqLywgJ051bVBhZF9NdWx0aXBseScsIDEwNiwgJ1ZLX01VTFRJUExZJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDkyIC8qIFNjYW5Db2RlLk51bXBhZFN1YnRyYWN0ICovLCAnTnVtcGFkU3VidHJhY3QnLCAxMTEgLyogS2V5Q29kZS5OdW1wYWRTdWJ0cmFjdCAqLywgJ051bVBhZF9TdWJ0cmFjdCcsIDEwOSwgJ1ZLX1NVQlRSQUNUJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDkzIC8qIFNjYW5Db2RlLk51bXBhZEFkZCAqLywgJ051bXBhZEFkZCcsIDEwOSAvKiBLZXlDb2RlLk51bXBhZEFkZCAqLywgJ051bVBhZF9BZGQnLCAxMDcsICdWS19BREQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgOTQgLyogU2NhbkNvZGUuTnVtcGFkRW50ZXIgKi8sICdOdW1wYWRFbnRlcicsIDMgLyogS2V5Q29kZS5FbnRlciAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgOTUgLyogU2NhbkNvZGUuTnVtcGFkMSAqLywgJ051bXBhZDEnLCA5OSAvKiBLZXlDb2RlLk51bXBhZDEgKi8sICdOdW1QYWQxJywgOTcsICdWS19OVU1QQUQxJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDk2IC8qIFNjYW5Db2RlLk51bXBhZDIgKi8sICdOdW1wYWQyJywgMTAwIC8qIEtleUNvZGUuTnVtcGFkMiAqLywgJ051bVBhZDInLCA5OCwgJ1ZLX05VTVBBRDInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgOTcgLyogU2NhbkNvZGUuTnVtcGFkMyAqLywgJ051bXBhZDMnLCAxMDEgLyogS2V5Q29kZS5OdW1wYWQzICovLCAnTnVtUGFkMycsIDk5LCAnVktfTlVNUEFEMycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA5OCAvKiBTY2FuQ29kZS5OdW1wYWQ0ICovLCAnTnVtcGFkNCcsIDEwMiAvKiBLZXlDb2RlLk51bXBhZDQgKi8sICdOdW1QYWQ0JywgMTAwLCAnVktfTlVNUEFENCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA5OSAvKiBTY2FuQ29kZS5OdW1wYWQ1ICovLCAnTnVtcGFkNScsIDEwMyAvKiBLZXlDb2RlLk51bXBhZDUgKi8sICdOdW1QYWQ1JywgMTAxLCAnVktfTlVNUEFENScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMDAgLyogU2NhbkNvZGUuTnVtcGFkNiAqLywgJ051bXBhZDYnLCAxMDQgLyogS2V5Q29kZS5OdW1wYWQ2ICovLCAnTnVtUGFkNicsIDEwMiwgJ1ZLX05VTVBBRDYnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTAxIC8qIFNjYW5Db2RlLk51bXBhZDcgKi8sICdOdW1wYWQ3JywgMTA1IC8qIEtleUNvZGUuTnVtcGFkNyAqLywgJ051bVBhZDcnLCAxMDMsICdWS19OVU1QQUQ3JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEwMiAvKiBTY2FuQ29kZS5OdW1wYWQ4ICovLCAnTnVtcGFkOCcsIDEwNiAvKiBLZXlDb2RlLk51bXBhZDggKi8sICdOdW1QYWQ4JywgMTA0LCAnVktfTlVNUEFEOCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMDMgLyogU2NhbkNvZGUuTnVtcGFkOSAqLywgJ051bXBhZDknLCAxMDcgLyogS2V5Q29kZS5OdW1wYWQ5ICovLCAnTnVtUGFkOScsIDEwNSwgJ1ZLX05VTVBBRDknLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTA0IC8qIFNjYW5Db2RlLk51bXBhZDAgKi8sICdOdW1wYWQwJywgOTggLyogS2V5Q29kZS5OdW1wYWQwICovLCAnTnVtUGFkMCcsIDk2LCAnVktfTlVNUEFEMCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMDUgLyogU2NhbkNvZGUuTnVtcGFkRGVjaW1hbCAqLywgJ051bXBhZERlY2ltYWwnLCAxMTIgLyogS2V5Q29kZS5OdW1wYWREZWNpbWFsICovLCAnTnVtUGFkX0RlY2ltYWwnLCAxMTAsICdWS19ERUNJTUFMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEwNiAvKiBTY2FuQ29kZS5JbnRsQmFja3NsYXNoICovLCAnSW50bEJhY2tzbGFzaCcsIDk3IC8qIEtleUNvZGUuSW50bEJhY2tzbGFzaCAqLywgJ09FTV8xMDInLCAyMjYsICdWS19PRU1fMTAyJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEwNyAvKiBTY2FuQ29kZS5Db250ZXh0TWVudSAqLywgJ0NvbnRleHRNZW51JywgNTggLyogS2V5Q29kZS5Db250ZXh0TWVudSAqLywgJ0NvbnRleHRNZW51JywgOTMsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTA4IC8qIFNjYW5Db2RlLlBvd2VyICovLCAnUG93ZXInLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTA5IC8qIFNjYW5Db2RlLk51bXBhZEVxdWFsICovLCAnTnVtcGFkRXF1YWwnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTEwIC8qIFNjYW5Db2RlLkYxMyAqLywgJ0YxMycsIDcxIC8qIEtleUNvZGUuRjEzICovLCAnRjEzJywgMTI0LCAnVktfRjEzJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDExMSAvKiBTY2FuQ29kZS5GMTQgKi8sICdGMTQnLCA3MiAvKiBLZXlDb2RlLkYxNCAqLywgJ0YxNCcsIDEyNSwgJ1ZLX0YxNCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMTIgLyogU2NhbkNvZGUuRjE1ICovLCAnRjE1JywgNzMgLyogS2V5Q29kZS5GMTUgKi8sICdGMTUnLCAxMjYsICdWS19GMTUnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTEzIC8qIFNjYW5Db2RlLkYxNiAqLywgJ0YxNicsIDc0IC8qIEtleUNvZGUuRjE2ICovLCAnRjE2JywgMTI3LCAnVktfRjE2JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDExNCAvKiBTY2FuQ29kZS5GMTcgKi8sICdGMTcnLCA3NSAvKiBLZXlDb2RlLkYxNyAqLywgJ0YxNycsIDEyOCwgJ1ZLX0YxNycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMTUgLyogU2NhbkNvZGUuRjE4ICovLCAnRjE4JywgNzYgLyogS2V5Q29kZS5GMTggKi8sICdGMTgnLCAxMjksICdWS19GMTgnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTE2IC8qIFNjYW5Db2RlLkYxOSAqLywgJ0YxOScsIDc3IC8qIEtleUNvZGUuRjE5ICovLCAnRjE5JywgMTMwLCAnVktfRjE5JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDExNyAvKiBTY2FuQ29kZS5GMjAgKi8sICdGMjAnLCA3OCAvKiBLZXlDb2RlLkYyMCAqLywgJ0YyMCcsIDEzMSwgJ1ZLX0YyMCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMTggLyogU2NhbkNvZGUuRjIxICovLCAnRjIxJywgNzkgLyogS2V5Q29kZS5GMjEgKi8sICdGMjEnLCAxMzIsICdWS19GMjEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTE5IC8qIFNjYW5Db2RlLkYyMiAqLywgJ0YyMicsIDgwIC8qIEtleUNvZGUuRjIyICovLCAnRjIyJywgMTMzLCAnVktfRjIyJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEyMCAvKiBTY2FuQ29kZS5GMjMgKi8sICdGMjMnLCA4MSAvKiBLZXlDb2RlLkYyMyAqLywgJ0YyMycsIDEzNCwgJ1ZLX0YyMycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMjEgLyogU2NhbkNvZGUuRjI0ICovLCAnRjI0JywgODIgLyogS2V5Q29kZS5GMjQgKi8sICdGMjQnLCAxMzUsICdWS19GMjQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTIyIC8qIFNjYW5Db2RlLk9wZW4gKi8sICdPcGVuJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEyMyAvKiBTY2FuQ29kZS5IZWxwICovLCAnSGVscCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMjQgLyogU2NhbkNvZGUuU2VsZWN0ICovLCAnU2VsZWN0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEyNSAvKiBTY2FuQ29kZS5BZ2FpbiAqLywgJ0FnYWluJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEyNiAvKiBTY2FuQ29kZS5VbmRvICovLCAnVW5kbycsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMjcgLyogU2NhbkNvZGUuQ3V0ICovLCAnQ3V0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEyOCAvKiBTY2FuQ29kZS5Db3B5ICovLCAnQ29weScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMjkgLyogU2NhbkNvZGUuUGFzdGUgKi8sICdQYXN0ZScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMzAgLyogU2NhbkNvZGUuRmluZCAqLywgJ0ZpbmQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTMxIC8qIFNjYW5Db2RlLkF1ZGlvVm9sdW1lTXV0ZSAqLywgJ0F1ZGlvVm9sdW1lTXV0ZScsIDExNyAvKiBLZXlDb2RlLkF1ZGlvVm9sdW1lTXV0ZSAqLywgJ0F1ZGlvVm9sdW1lTXV0ZScsIDE3MywgJ1ZLX1ZPTFVNRV9NVVRFJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEzMiAvKiBTY2FuQ29kZS5BdWRpb1ZvbHVtZVVwICovLCAnQXVkaW9Wb2x1bWVVcCcsIDExOCAvKiBLZXlDb2RlLkF1ZGlvVm9sdW1lVXAgKi8sICdBdWRpb1ZvbHVtZVVwJywgMTc1LCAnVktfVk9MVU1FX1VQJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEzMyAvKiBTY2FuQ29kZS5BdWRpb1ZvbHVtZURvd24gKi8sICdBdWRpb1ZvbHVtZURvd24nLCAxMTkgLyogS2V5Q29kZS5BdWRpb1ZvbHVtZURvd24gKi8sICdBdWRpb1ZvbHVtZURvd24nLCAxNzQsICdWS19WT0xVTUVfRE9XTicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMzQgLyogU2NhbkNvZGUuTnVtcGFkQ29tbWEgKi8sICdOdW1wYWRDb21tYScsIDExMCAvKiBLZXlDb2RlLk5VTVBBRF9TRVBBUkFUT1IgKi8sICdOdW1QYWRfU2VwYXJhdG9yJywgMTA4LCAnVktfU0VQQVJBVE9SJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEzNSAvKiBTY2FuQ29kZS5JbnRsUm8gKi8sICdJbnRsUm8nLCAxMTUgLyogS2V5Q29kZS5BQk5UX0MxICovLCAnQUJOVF9DMScsIDE5MywgJ1ZLX0FCTlRfQzEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTM2IC8qIFNjYW5Db2RlLkthbmFNb2RlICovLCAnS2FuYU1vZGUnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMTM3IC8qIFNjYW5Db2RlLkludGxZZW4gKi8sICdJbnRsWWVuJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEzOCAvKiBTY2FuQ29kZS5Db252ZXJ0ICovLCAnQ29udmVydCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMzkgLyogU2NhbkNvZGUuTm9uQ29udmVydCAqLywgJ05vbkNvbnZlcnQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTQwIC8qIFNjYW5Db2RlLkxhbmcxICovLCAnTGFuZzEnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTQxIC8qIFNjYW5Db2RlLkxhbmcyICovLCAnTGFuZzInLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTQyIC8qIFNjYW5Db2RlLkxhbmczICovLCAnTGFuZzMnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTQzIC8qIFNjYW5Db2RlLkxhbmc0ICovLCAnTGFuZzQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTQ0IC8qIFNjYW5Db2RlLkxhbmc1ICovLCAnTGFuZzUnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTQ1IC8qIFNjYW5Db2RlLkFib3J0ICovLCAnQWJvcnQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTQ2IC8qIFNjYW5Db2RlLlByb3BzICovLCAnUHJvcHMnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTQ3IC8qIFNjYW5Db2RlLk51bXBhZFBhcmVuTGVmdCAqLywgJ051bXBhZFBhcmVuTGVmdCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNDggLyogU2NhbkNvZGUuTnVtcGFkUGFyZW5SaWdodCAqLywgJ051bXBhZFBhcmVuUmlnaHQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTQ5IC8qIFNjYW5Db2RlLk51bXBhZEJhY2tzcGFjZSAqLywgJ051bXBhZEJhY2tzcGFjZScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNTAgLyogU2NhbkNvZGUuTnVtcGFkTWVtb3J5U3RvcmUgKi8sICdOdW1wYWRNZW1vcnlTdG9yZScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNTEgLyogU2NhbkNvZGUuTnVtcGFkTWVtb3J5UmVjYWxsICovLCAnTnVtcGFkTWVtb3J5UmVjYWxsJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE1MiAvKiBTY2FuQ29kZS5OdW1wYWRNZW1vcnlDbGVhciAqLywgJ051bXBhZE1lbW9yeUNsZWFyJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE1MyAvKiBTY2FuQ29kZS5OdW1wYWRNZW1vcnlBZGQgKi8sICdOdW1wYWRNZW1vcnlBZGQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTU0IC8qIFNjYW5Db2RlLk51bXBhZE1lbW9yeVN1YnRyYWN0ICovLCAnTnVtcGFkTWVtb3J5U3VidHJhY3QnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTU1IC8qIFNjYW5Db2RlLk51bXBhZENsZWFyICovLCAnTnVtcGFkQ2xlYXInLCAxMzEgLyogS2V5Q29kZS5DbGVhciAqLywgJ0NsZWFyJywgMTIsICdWS19DTEVBUicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNTYgLyogU2NhbkNvZGUuTnVtcGFkQ2xlYXJFbnRyeSAqLywgJ051bXBhZENsZWFyRW50cnknLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgNSAvKiBLZXlDb2RlLkN0cmwgKi8sICdDdHJsJywgMTcsICdWS19DT05UUk9MJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDQgLyogS2V5Q29kZS5TaGlmdCAqLywgJ1NoaWZ0JywgMTYsICdWS19TSElGVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCA2IC8qIEtleUNvZGUuQWx0ICovLCAnQWx0JywgMTgsICdWS19NRU5VJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDU3IC8qIEtleUNvZGUuTWV0YSAqLywgJ01ldGEnLCA5MSwgJ1ZLX0NPTU1BTkQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTU3IC8qIFNjYW5Db2RlLkNvbnRyb2xMZWZ0ICovLCAnQ29udHJvbExlZnQnLCA1IC8qIEtleUNvZGUuQ3RybCAqLywgZW1wdHksIDAsICdWS19MQ09OVFJPTCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNTggLyogU2NhbkNvZGUuU2hpZnRMZWZ0ICovLCAnU2hpZnRMZWZ0JywgNCAvKiBLZXlDb2RlLlNoaWZ0ICovLCBlbXB0eSwgMCwgJ1ZLX0xTSElGVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNTkgLyogU2NhbkNvZGUuQWx0TGVmdCAqLywgJ0FsdExlZnQnLCA2IC8qIEtleUNvZGUuQWx0ICovLCBlbXB0eSwgMCwgJ1ZLX0xNRU5VJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE2MCAvKiBTY2FuQ29kZS5NZXRhTGVmdCAqLywgJ01ldGFMZWZ0JywgNTcgLyogS2V5Q29kZS5NZXRhICovLCBlbXB0eSwgMCwgJ1ZLX0xXSU4nLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTYxIC8qIFNjYW5Db2RlLkNvbnRyb2xSaWdodCAqLywgJ0NvbnRyb2xSaWdodCcsIDUgLyogS2V5Q29kZS5DdHJsICovLCBlbXB0eSwgMCwgJ1ZLX1JDT05UUk9MJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE2MiAvKiBTY2FuQ29kZS5TaGlmdFJpZ2h0ICovLCAnU2hpZnRSaWdodCcsIDQgLyogS2V5Q29kZS5TaGlmdCAqLywgZW1wdHksIDAsICdWS19SU0hJRlQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTYzIC8qIFNjYW5Db2RlLkFsdFJpZ2h0ICovLCAnQWx0UmlnaHQnLCA2IC8qIEtleUNvZGUuQWx0ICovLCBlbXB0eSwgMCwgJ1ZLX1JNRU5VJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE2NCAvKiBTY2FuQ29kZS5NZXRhUmlnaHQgKi8sICdNZXRhUmlnaHQnLCA1NyAvKiBLZXlDb2RlLk1ldGEgKi8sIGVtcHR5LCAwLCAnVktfUldJTicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNjUgLyogU2NhbkNvZGUuQnJpZ2h0bmVzc1VwICovLCAnQnJpZ2h0bmVzc1VwJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE2NiAvKiBTY2FuQ29kZS5CcmlnaHRuZXNzRG93biAqLywgJ0JyaWdodG5lc3NEb3duJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE2NyAvKiBTY2FuQ29kZS5NZWRpYVBsYXkgKi8sICdNZWRpYVBsYXknLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTY4IC8qIFNjYW5Db2RlLk1lZGlhUmVjb3JkICovLCAnTWVkaWFSZWNvcmQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTY5IC8qIFNjYW5Db2RlLk1lZGlhRmFzdEZvcndhcmQgKi8sICdNZWRpYUZhc3RGb3J3YXJkJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE3MCAvKiBTY2FuQ29kZS5NZWRpYVJld2luZCAqLywgJ01lZGlhUmV3aW5kJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE3MSAvKiBTY2FuQ29kZS5NZWRpYVRyYWNrTmV4dCAqLywgJ01lZGlhVHJhY2tOZXh0JywgMTI0IC8qIEtleUNvZGUuTWVkaWFUcmFja05leHQgKi8sICdNZWRpYVRyYWNrTmV4dCcsIDE3NiwgJ1ZLX01FRElBX05FWFRfVFJBQ0snLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTcyIC8qIFNjYW5Db2RlLk1lZGlhVHJhY2tQcmV2aW91cyAqLywgJ01lZGlhVHJhY2tQcmV2aW91cycsIDEyNSAvKiBLZXlDb2RlLk1lZGlhVHJhY2tQcmV2aW91cyAqLywgJ01lZGlhVHJhY2tQcmV2aW91cycsIDE3NywgJ1ZLX01FRElBX1BSRVZfVFJBQ0snLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTczIC8qIFNjYW5Db2RlLk1lZGlhU3RvcCAqLywgJ01lZGlhU3RvcCcsIDEyNiAvKiBLZXlDb2RlLk1lZGlhU3RvcCAqLywgJ01lZGlhU3RvcCcsIDE3OCwgJ1ZLX01FRElBX1NUT1AnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTc0IC8qIFNjYW5Db2RlLkVqZWN0ICovLCAnRWplY3QnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTc1IC8qIFNjYW5Db2RlLk1lZGlhUGxheVBhdXNlICovLCAnTWVkaWFQbGF5UGF1c2UnLCAxMjcgLyogS2V5Q29kZS5NZWRpYVBsYXlQYXVzZSAqLywgJ01lZGlhUGxheVBhdXNlJywgMTc5LCAnVktfTUVESUFfUExBWV9QQVVTRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNzYgLyogU2NhbkNvZGUuTWVkaWFTZWxlY3QgKi8sICdNZWRpYVNlbGVjdCcsIDEyOCAvKiBLZXlDb2RlLkxhdW5jaE1lZGlhUGxheWVyICovLCAnTGF1bmNoTWVkaWFQbGF5ZXInLCAxODEsICdWS19NRURJQV9MQVVOQ0hfTUVESUFfU0VMRUNUJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE3NyAvKiBTY2FuQ29kZS5MYXVuY2hNYWlsICovLCAnTGF1bmNoTWFpbCcsIDEyOSAvKiBLZXlDb2RlLkxhdW5jaE1haWwgKi8sICdMYXVuY2hNYWlsJywgMTgwLCAnVktfTUVESUFfTEFVTkNIX01BSUwnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTc4IC8qIFNjYW5Db2RlLkxhdW5jaEFwcDIgKi8sICdMYXVuY2hBcHAyJywgMTMwIC8qIEtleUNvZGUuTGF1bmNoQXBwMiAqLywgJ0xhdW5jaEFwcDInLCAxODMsICdWS19NRURJQV9MQVVOQ0hfQVBQMicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNzkgLyogU2NhbkNvZGUuTGF1bmNoQXBwMSAqLywgJ0xhdW5jaEFwcDEnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19NRURJQV9MQVVOQ0hfQVBQMScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxODAgLyogU2NhbkNvZGUuU2VsZWN0VGFzayAqLywgJ1NlbGVjdFRhc2snLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTgxIC8qIFNjYW5Db2RlLkxhdW5jaFNjcmVlblNhdmVyICovLCAnTGF1bmNoU2NyZWVuU2F2ZXInLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTgyIC8qIFNjYW5Db2RlLkJyb3dzZXJTZWFyY2ggKi8sICdCcm93c2VyU2VhcmNoJywgMTIwIC8qIEtleUNvZGUuQnJvd3NlclNlYXJjaCAqLywgJ0Jyb3dzZXJTZWFyY2gnLCAxNzAsICdWS19CUk9XU0VSX1NFQVJDSCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxODMgLyogU2NhbkNvZGUuQnJvd3NlckhvbWUgKi8sICdCcm93c2VySG9tZScsIDEyMSAvKiBLZXlDb2RlLkJyb3dzZXJIb21lICovLCAnQnJvd3NlckhvbWUnLCAxNzIsICdWS19CUk9XU0VSX0hPTUUnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTg0IC8qIFNjYW5Db2RlLkJyb3dzZXJCYWNrICovLCAnQnJvd3NlckJhY2snLCAxMjIgLyogS2V5Q29kZS5Ccm93c2VyQmFjayAqLywgJ0Jyb3dzZXJCYWNrJywgMTY2LCAnVktfQlJPV1NFUl9CQUNLJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE4NSAvKiBTY2FuQ29kZS5Ccm93c2VyRm9yd2FyZCAqLywgJ0Jyb3dzZXJGb3J3YXJkJywgMTIzIC8qIEtleUNvZGUuQnJvd3NlckZvcndhcmQgKi8sICdCcm93c2VyRm9yd2FyZCcsIDE2NywgJ1ZLX0JST1dTRVJfRk9SV0FSRCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxODYgLyogU2NhbkNvZGUuQnJvd3NlclN0b3AgKi8sICdCcm93c2VyU3RvcCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0JST1dTRVJfU1RPUCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxODcgLyogU2NhbkNvZGUuQnJvd3NlclJlZnJlc2ggKi8sICdCcm93c2VyUmVmcmVzaCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0JST1dTRVJfUkVGUkVTSCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxODggLyogU2NhbkNvZGUuQnJvd3NlckZhdm9yaXRlcyAqLywgJ0Jyb3dzZXJGYXZvcml0ZXMnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19CUk9XU0VSX0ZBVk9SSVRFUycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxODkgLyogU2NhbkNvZGUuWm9vbVRvZ2dsZSAqLywgJ1pvb21Ub2dnbGUnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTkwIC8qIFNjYW5Db2RlLk1haWxSZXBseSAqLywgJ01haWxSZXBseScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxOTEgLyogU2NhbkNvZGUuTWFpbEZvcndhcmQgKi8sICdNYWlsRm9yd2FyZCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxOTIgLyogU2NhbkNvZGUuTWFpbFNlbmQgKi8sICdNYWlsU2VuZCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIC8vIFNlZSBodHRwczovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvd3d3LWRvbS8yMDEwSnVsU2VwL2F0dC0wMTgyL2tleUNvZGUtc3BlYy5odG1sXG4gICAgICAgIC8vIElmIGFuIElucHV0IE1ldGhvZCBFZGl0b3IgaXMgcHJvY2Vzc2luZyBrZXkgaW5wdXQgYW5kIHRoZSBldmVudCBpcyBrZXlkb3duLCByZXR1cm4gMjI5LlxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMTE0IC8qIEtleUNvZGUuS0VZX0lOX0NPTVBPU0lUSU9OICovLCAnS2V5SW5Db21wb3NpdGlvbicsIDIyOSwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAxMTYgLyogS2V5Q29kZS5BQk5UX0MyICovLCAnQUJOVF9DMicsIDE5NCwgJ1ZLX0FCTlRfQzInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgOTYgLyogS2V5Q29kZS5PRU1fOCAqLywgJ09FTV84JywgMjIzLCAnVktfT0VNXzgnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfS0FOQScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19IQU5HVUwnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfSlVOSkEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfRklOQUwnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfSEFOSkEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfS0FOSkknLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfQ09OVkVSVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19OT05DT05WRVJUJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0FDQ0VQVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19NT0RFQ0hBTkdFJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX1NFTEVDVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19QUklOVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19FWEVDVVRFJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX1NOQVBTSE9UJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0hFTFAnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfQVBQUycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19QUk9DRVNTS0VZJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX1BBQ0tFVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19EQkVfU0JDU0NIQVInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfREJFX0RCQ1NDSEFSJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0FUVE4nLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfQ1JTRUwnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfRVhTRUwnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfRVJFT0YnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfUExBWScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19aT09NJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX05PTkFNRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19QQTEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfT0VNX0NMRUFSJywgZW1wdHksIGVtcHR5XSxcbiAgICBdO1xuICAgIGNvbnN0IHNlZW5LZXlDb2RlID0gW107XG4gICAgY29uc3Qgc2VlblNjYW5Db2RlID0gW107XG4gICAgZm9yIChjb25zdCBtYXBwaW5nIG9mIG1hcHBpbmdzKSB7XG4gICAgICAgIGNvbnN0IFtpbW11dGFibGUsIHNjYW5Db2RlLCBzY2FuQ29kZVN0ciwga2V5Q29kZSwga2V5Q29kZVN0ciwgZXZlbnRLZXlDb2RlLCB2a2V5LCB1c1VzZXJTZXR0aW5nc0xhYmVsLCBnZW5lcmFsVXNlclNldHRpbmdzTGFiZWxdID0gbWFwcGluZztcbiAgICAgICAgaWYgKCFzZWVuU2NhbkNvZGVbc2NhbkNvZGVdKSB7XG4gICAgICAgICAgICBzZWVuU2NhbkNvZGVbc2NhbkNvZGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHNjYW5Db2RlSW50VG9TdHJbc2NhbkNvZGVdID0gc2NhbkNvZGVTdHI7XG4gICAgICAgICAgICBzY2FuQ29kZVN0clRvSW50W3NjYW5Db2RlU3RyXSA9IHNjYW5Db2RlO1xuICAgICAgICAgICAgc2NhbkNvZGVMb3dlckNhc2VTdHJUb0ludFtzY2FuQ29kZVN0ci50b0xvd2VyQ2FzZSgpXSA9IHNjYW5Db2RlO1xuICAgICAgICAgICAgaWYgKGltbXV0YWJsZSkge1xuICAgICAgICAgICAgICAgIElNTVVUQUJMRV9DT0RFX1RPX0tFWV9DT0RFW3NjYW5Db2RlXSA9IGtleUNvZGU7XG4gICAgICAgICAgICAgICAgaWYgKChrZXlDb2RlICE9PSAwIC8qIEtleUNvZGUuVW5rbm93biAqLylcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleUNvZGUgIT09IDMgLyogS2V5Q29kZS5FbnRlciAqLylcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleUNvZGUgIT09IDUgLyogS2V5Q29kZS5DdHJsICovKVxuICAgICAgICAgICAgICAgICAgICAmJiAoa2V5Q29kZSAhPT0gNCAvKiBLZXlDb2RlLlNoaWZ0ICovKVxuICAgICAgICAgICAgICAgICAgICAmJiAoa2V5Q29kZSAhPT0gNiAvKiBLZXlDb2RlLkFsdCAqLylcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleUNvZGUgIT09IDU3IC8qIEtleUNvZGUuTWV0YSAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgSU1NVVRBQkxFX0tFWV9DT0RFX1RPX0NPREVba2V5Q29kZV0gPSBzY2FuQ29kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWVuS2V5Q29kZVtrZXlDb2RlXSkge1xuICAgICAgICAgICAgc2VlbktleUNvZGVba2V5Q29kZV0gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFrZXlDb2RlU3RyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpbmcgcmVwcmVzZW50YXRpb24gbWlzc2luZyBmb3Iga2V5IGNvZGUgJHtrZXlDb2RlfSBhcm91bmQgc2NhbiBjb2RlICR7c2NhbkNvZGVTdHJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1aU1hcC5kZWZpbmUoa2V5Q29kZSwga2V5Q29kZVN0cik7XG4gICAgICAgICAgICB1c2VyU2V0dGluZ3NVU01hcC5kZWZpbmUoa2V5Q29kZSwgdXNVc2VyU2V0dGluZ3NMYWJlbCB8fCBrZXlDb2RlU3RyKTtcbiAgICAgICAgICAgIHVzZXJTZXR0aW5nc0dlbmVyYWxNYXAuZGVmaW5lKGtleUNvZGUsIGdlbmVyYWxVc2VyU2V0dGluZ3NMYWJlbCB8fCB1c1VzZXJTZXR0aW5nc0xhYmVsIHx8IGtleUNvZGVTdHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudEtleUNvZGUpIHtcbiAgICAgICAgICAgIEVWRU5UX0tFWV9DT0RFX01BUFtldmVudEtleUNvZGVdID0ga2V5Q29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmtleSkge1xuICAgICAgICAgICAgTkFUSVZFX1dJTkRPV1NfS0VZX0NPREVfVE9fS0VZX0NPREVbdmtleV0gPSBrZXlDb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1hbnVhbGx5IGFkZGVkIGR1ZSB0byB0aGUgZXhjbHVzaW9uIGFib3ZlIChkdWUgdG8gZHVwbGljYXRpb24gd2l0aCBOdW1wYWRFbnRlcilcbiAgICBJTU1VVEFCTEVfS0VZX0NPREVfVE9fQ09ERVszIC8qIEtleUNvZGUuRW50ZXIgKi9dID0gNDYgLyogU2NhbkNvZGUuRW50ZXIgKi87XG59KSgpO1xuZXhwb3J0IHZhciBLZXlDb2RlVXRpbHM7XG4oZnVuY3Rpb24gKEtleUNvZGVVdGlscykge1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKGtleUNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHVpTWFwLmtleUNvZGVUb1N0cihrZXlDb2RlKTtcbiAgICB9XG4gICAgS2V5Q29kZVV0aWxzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHVpTWFwLnN0clRvS2V5Q29kZShrZXkpO1xuICAgIH1cbiAgICBLZXlDb2RlVXRpbHMuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG4gICAgZnVuY3Rpb24gdG9Vc2VyU2V0dGluZ3NVUyhrZXlDb2RlKSB7XG4gICAgICAgIHJldHVybiB1c2VyU2V0dGluZ3NVU01hcC5rZXlDb2RlVG9TdHIoa2V5Q29kZSk7XG4gICAgfVxuICAgIEtleUNvZGVVdGlscy50b1VzZXJTZXR0aW5nc1VTID0gdG9Vc2VyU2V0dGluZ3NVUztcbiAgICBmdW5jdGlvbiB0b1VzZXJTZXR0aW5nc0dlbmVyYWwoa2V5Q29kZSkge1xuICAgICAgICByZXR1cm4gdXNlclNldHRpbmdzR2VuZXJhbE1hcC5rZXlDb2RlVG9TdHIoa2V5Q29kZSk7XG4gICAgfVxuICAgIEtleUNvZGVVdGlscy50b1VzZXJTZXR0aW5nc0dlbmVyYWwgPSB0b1VzZXJTZXR0aW5nc0dlbmVyYWw7XG4gICAgZnVuY3Rpb24gZnJvbVVzZXJTZXR0aW5ncyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJTZXR0aW5nc1VTTWFwLnN0clRvS2V5Q29kZShrZXkpIHx8IHVzZXJTZXR0aW5nc0dlbmVyYWxNYXAuc3RyVG9LZXlDb2RlKGtleSk7XG4gICAgfVxuICAgIEtleUNvZGVVdGlscy5mcm9tVXNlclNldHRpbmdzID0gZnJvbVVzZXJTZXR0aW5ncztcbiAgICBmdW5jdGlvbiB0b0VsZWN0cm9uQWNjZWxlcmF0b3Ioa2V5Q29kZSkge1xuICAgICAgICBpZiAoa2V5Q29kZSA+PSA5OCAvKiBLZXlDb2RlLk51bXBhZDAgKi8gJiYga2V5Q29kZSA8PSAxMTMgLyogS2V5Q29kZS5OdW1wYWREaXZpZGUgKi8pIHtcbiAgICAgICAgICAgIC8vIFtFbGVjdHJvbiBBY2NlbGVyYXRvcnNdIEVsZWN0cm9uIGlzIGFibGUgdG8gcGFyc2UgbnVtcGFkIGtleXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0XG4gICAgICAgICAgICAvLyByZW5kZXJzIHRoZW0ganVzdCBhcyByZWd1bGFyIGtleXMgaW4gbWVudXMuIEZvciBleGFtcGxlLCBudW0wIGlzIHJlbmRlcmVkIGFzIFwiMFwiLFxuICAgICAgICAgICAgLy8gbnVtZGl2IGlzIHJlbmRlcmVkIGFzIFwiL1wiLCBudW1zdWIgaXMgcmVuZGVyZWQgYXMgXCItXCIuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gbGVhZCB0byBpbmNyZWRpYmxlIGNvbmZ1c2lvbiwgYXMgaXQgbWFrZXMgbnVtcGFkIGJhc2VkIGtleWJpbmRpbmdzIGluZGlzdGluZ3Vpc2hhYmxlXG4gICAgICAgICAgICAvLyBmcm9tIGtleWJpbmRpbmdzIGJhc2VkIG9uIHJlZ3VsYXIga2V5cy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBXZSB0aGVyZWZvcmUgbmVlZCB0byBmYWxsIGJhY2sgdG8gY3VzdG9tIHJlbmRlcmluZyBmb3IgbnVtcGFkIGtleXMuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMTYgLyogS2V5Q29kZS5VcEFycm93ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnVXAnO1xuICAgICAgICAgICAgY2FzZSAxOCAvKiBLZXlDb2RlLkRvd25BcnJvdyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Rvd24nO1xuICAgICAgICAgICAgY2FzZSAxNSAvKiBLZXlDb2RlLkxlZnRBcnJvdyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0xlZnQnO1xuICAgICAgICAgICAgY2FzZSAxNyAvKiBLZXlDb2RlLlJpZ2h0QXJyb3cgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICdSaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVpTWFwLmtleUNvZGVUb1N0cihrZXlDb2RlKTtcbiAgICB9XG4gICAgS2V5Q29kZVV0aWxzLnRvRWxlY3Ryb25BY2NlbGVyYXRvciA9IHRvRWxlY3Ryb25BY2NlbGVyYXRvcjtcbn0pKEtleUNvZGVVdGlscyB8fCAoS2V5Q29kZVV0aWxzID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBLZXlDaG9yZChmaXJzdFBhcnQsIHNlY29uZFBhcnQpIHtcbiAgICBjb25zdCBjaG9yZFBhcnQgPSAoKHNlY29uZFBhcnQgJiAweDAwMDBGRkZGKSA8PCAxNikgPj4+IDA7XG4gICAgcmV0dXJuIChmaXJzdFBhcnQgfCBjaG9yZFBhcnQpID4+PiAwO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgY2xhc3MgTGF6eSB7XG4gICAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICAgICAgdGhpcy5leGVjdXRvciA9IGV4ZWN1dG9yO1xuICAgICAgICB0aGlzLl9kaWRSdW4gPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGZvcmNlIGV2YWx1YXRpb24gb2YgdGhlIGxhenkgdmFsdWUgaWYgaXQgaGFzIG5vdCBiZWVuIHJlc29sdmVkIHlldC4gTGF6eSB2YWx1ZXMgYXJlIG9ubHlcbiAgICAgKiByZXNvbHZlZCBvbmNlLiBgZ2V0VmFsdWVgIHdpbGwgcmUtdGhyb3cgZXhjZXB0aW9ucyB0aGF0IGFyZSBoaXQgd2hpbGUgcmVzb2x2aW5nIHRoZSB2YWx1ZVxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kaWRSdW4pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLmV4ZWN1dG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWRSdW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdyYXBwZWQgdmFsdWUgd2l0aG91dCBmb3JjaW5nIGV2YWx1YXRpb24uXG4gICAgICovXG4gICAgZ2V0IHJhd1ZhbHVlKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZVNpbmdsZUNhbGxGdW5jdGlvbiB9IGZyb20gJy4vZnVuY3Rpb25hbC5qcyc7XG5pbXBvcnQgeyBJdGVyYWJsZSB9IGZyb20gJy4vaXRlcmF0b3IuanMnO1xuLy8gI3JlZ2lvbiBEaXNwb3NhYmxlIFRyYWNraW5nXG4vKipcbiAqIEVuYWJsZXMgbG9nZ2luZyBvZiBwb3RlbnRpYWxseSBsZWFrZWQgZGlzcG9zYWJsZXMuXG4gKlxuICogQSBkaXNwb3NhYmxlIGlzIGNvbnNpZGVyZWQgbGVha2VkIGlmIGl0IGlzIG5vdCBkaXNwb3NlZCBvciBub3QgcmVnaXN0ZXJlZCBhcyB0aGUgY2hpbGQgb2ZcbiAqIGFub3RoZXIgZGlzcG9zYWJsZS4gVGhpcyB0cmFja2luZyBpcyB2ZXJ5IHNpbXBsZSBhbiBvbmx5IHdvcmtzIGZvciBjbGFzc2VzIHRoYXQgZWl0aGVyXG4gKiBleHRlbmQgRGlzcG9zYWJsZSBvciB1c2UgYSBEaXNwb3NhYmxlU3RvcmUuIFRoaXMgbWVhbnMgdGhlcmUgYXJlIGEgbG90IG9mIGZhbHNlIHBvc2l0aXZlcy5cbiAqL1xuY29uc3QgVFJBQ0tfRElTUE9TQUJMRVMgPSBmYWxzZTtcbmxldCBkaXNwb3NhYmxlVHJhY2tlciA9IG51bGw7XG5leHBvcnQgZnVuY3Rpb24gc2V0RGlzcG9zYWJsZVRyYWNrZXIodHJhY2tlcikge1xuICAgIGRpc3Bvc2FibGVUcmFja2VyID0gdHJhY2tlcjtcbn1cbmlmIChUUkFDS19ESVNQT1NBQkxFUykge1xuICAgIGNvbnN0IF9faXNfZGlzcG9zYWJsZV90cmFja2VkX18gPSAnX19pc19kaXNwb3NhYmxlX3RyYWNrZWRfXyc7XG4gICAgc2V0RGlzcG9zYWJsZVRyYWNrZXIobmV3IGNsYXNzIHtcbiAgICAgICAgdHJhY2tEaXNwb3NhYmxlKHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCdQb3RlbnRpYWxseSBsZWFrZWQgZGlzcG9zYWJsZScpLnN0YWNrO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF4W19faXNfZGlzcG9zYWJsZV90cmFja2VkX19dKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRQYXJlbnQoY2hpbGQsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSBEaXNwb3NhYmxlLk5vbmUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFtfX2lzX2Rpc3Bvc2FibGVfdHJhY2tlZF9fXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXJrQXNEaXNwb3NlZChkaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICBpZiAoZGlzcG9zYWJsZSAmJiBkaXNwb3NhYmxlICE9PSBEaXNwb3NhYmxlLk5vbmUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlW19faXNfZGlzcG9zYWJsZV90cmFja2VkX19dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hcmtBc1NpbmdsZXRvbihkaXNwb3NhYmxlKSB7IH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0Rpc3Bvc2FibGUoeCkge1xuICAgIGRpc3Bvc2FibGVUcmFja2VyPy50cmFja0Rpc3Bvc2FibGUoeCk7XG4gICAgcmV0dXJuIHg7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFya0FzRGlzcG9zZWQoZGlzcG9zYWJsZSkge1xuICAgIGRpc3Bvc2FibGVUcmFja2VyPy5tYXJrQXNEaXNwb3NlZChkaXNwb3NhYmxlKTtcbn1cbmZ1bmN0aW9uIHNldFBhcmVudE9mRGlzcG9zYWJsZShjaGlsZCwgcGFyZW50KSB7XG4gICAgZGlzcG9zYWJsZVRyYWNrZXI/LnNldFBhcmVudChjaGlsZCwgcGFyZW50KTtcbn1cbmZ1bmN0aW9uIHNldFBhcmVudE9mRGlzcG9zYWJsZXMoY2hpbGRyZW4sIHBhcmVudCkge1xuICAgIGlmICghZGlzcG9zYWJsZVRyYWNrZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGRpc3Bvc2FibGVUcmFja2VyLnNldFBhcmVudChjaGlsZCwgcGFyZW50KTtcbiAgICB9XG59XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IHRoZSBnaXZlbiBvYmplY3QgaXMgYSBzaW5nbGV0b24gd2hpY2ggZG9lcyBub3QgbmVlZCB0byBiZSBkaXNwb3NlZC5cbiovXG5leHBvcnQgZnVuY3Rpb24gbWFya0FzU2luZ2xldG9uKHNpbmdsZXRvbikge1xuICAgIGRpc3Bvc2FibGVUcmFja2VyPy5tYXJrQXNTaW5nbGV0b24oc2luZ2xldG9uKTtcbiAgICByZXR1cm4gc2luZ2xldG9uO1xufVxuLyoqXG4gKiBDaGVjayBpZiBgdGhpbmdgIGlzIHtAbGluayBJRGlzcG9zYWJsZSBkaXNwb3NhYmxlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGlzcG9zYWJsZSh0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnICYmIHRoaW5nICE9PSBudWxsICYmIHR5cGVvZiB0aGluZy5kaXNwb3NlID09PSAnZnVuY3Rpb24nICYmIHRoaW5nLmRpc3Bvc2UubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRpc3Bvc2UoYXJnKSB7XG4gICAgaWYgKEl0ZXJhYmxlLmlzKGFyZykpIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZCBvZiBhcmcpIHtcbiAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycm9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZXJyb3JzLCAnRW5jb3VudGVyZWQgZXJyb3JzIHdoaWxlIGRpc3Bvc2luZyBvZiBzdG9yZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZykgPyBbXSA6IGFyZztcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJnKSB7XG4gICAgICAgIGFyZy5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxufVxuLyoqXG4gKiBDb21iaW5lIG11bHRpcGxlIGRpc3Bvc2FibGUgdmFsdWVzIGludG8gYSBzaW5nbGUge0BsaW5rIElEaXNwb3NhYmxlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVkRGlzcG9zYWJsZSguLi5kaXNwb3NhYmxlcykge1xuICAgIGNvbnN0IHBhcmVudCA9IHRvRGlzcG9zYWJsZSgoKSA9PiBkaXNwb3NlKGRpc3Bvc2FibGVzKSk7XG4gICAgc2V0UGFyZW50T2ZEaXNwb3NhYmxlcyhkaXNwb3NhYmxlcywgcGFyZW50KTtcbiAgICByZXR1cm4gcGFyZW50O1xufVxuLyoqXG4gKiBUdXJuIGEgZnVuY3Rpb24gdGhhdCBpbXBsZW1lbnRzIGRpc3Bvc2UgaW50byBhbiB7QGxpbmsgSURpc3Bvc2FibGV9LlxuICpcbiAqIEBwYXJhbSBmbiBDbGVhbiB1cCBmdW5jdGlvbiwgZ3VhcmFudGVlZCB0byBiZSBjYWxsZWQgb25seSAqKm9uY2UqKi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGlzcG9zYWJsZShmbikge1xuICAgIGNvbnN0IHNlbGYgPSB0cmFja0Rpc3Bvc2FibGUoe1xuICAgICAgICBkaXNwb3NlOiBjcmVhdGVTaW5nbGVDYWxsRnVuY3Rpb24oKCkgPT4ge1xuICAgICAgICAgICAgbWFya0FzRGlzcG9zZWQoc2VsZik7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xufVxuLyoqXG4gKiBNYW5hZ2VzIGEgY29sbGVjdGlvbiBvZiBkaXNwb3NhYmxlIHZhbHVlcy5cbiAqXG4gKiBUaGlzIGlzIHRoZSBwcmVmZXJyZWQgd2F5IHRvIG1hbmFnZSBtdWx0aXBsZSBkaXNwb3NhYmxlcy4gQSBgRGlzcG9zYWJsZVN0b3JlYCBpcyBzYWZlciB0byB3b3JrIHdpdGggdGhhbiBhblxuICogYElEaXNwb3NhYmxlW11gIGFzIGl0IGNvbnNpZGVycyBlZGdlIGNhc2VzLCBzdWNoIGFzIHJlZ2lzdGVyaW5nIHRoZSBzYW1lIHZhbHVlIG11bHRpcGxlIHRpbWVzIG9yIGFkZGluZyBhbiBpdGVtIHRvIGFcbiAqIHN0b3JlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCBvZi5cbiAqL1xuZXhwb3J0IGNsYXNzIERpc3Bvc2FibGVTdG9yZSB7XG4gICAgc3RhdGljIHsgdGhpcy5ESVNBQkxFX0RJU1BPU0VEX1dBUk5JTkcgPSBmYWxzZTsgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl90b0Rpc3Bvc2UgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdHJhY2tEaXNwb3NhYmxlKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIGFsbCByZWdpc3RlcmVkIGRpc3Bvc2FibGVzIGFuZCBtYXJrIHRoaXMgb2JqZWN0IGFzIGRpc3Bvc2VkLlxuICAgICAqXG4gICAgICogQW55IGZ1dHVyZSBkaXNwb3NhYmxlcyBhZGRlZCB0byB0aGlzIG9iamVjdCB3aWxsIGJlIGRpc3Bvc2VkIG9mIG9uIGBhZGRgLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWFya0FzRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gYHRydWVgIGlmIHRoaXMgb2JqZWN0IGhhcyBiZWVuIGRpc3Bvc2VkIG9mLlxuICAgICAqL1xuICAgIGdldCBpc0Rpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXNwb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiBhbGwgcmVnaXN0ZXJlZCBkaXNwb3NhYmxlcyBidXQgZG8gbm90IG1hcmsgdGhpcyBvYmplY3QgYXMgZGlzcG9zZWQuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl90b0Rpc3Bvc2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaXNwb3NlKHRoaXMuX3RvRGlzcG9zZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl90b0Rpc3Bvc2UuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcge0BsaW5rIElEaXNwb3NhYmxlIGRpc3Bvc2FibGV9IHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIGFkZChvKSB7XG4gICAgICAgIGlmICghbykge1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZ2lzdGVyIGEgZGlzcG9zYWJsZSBvbiBpdHNlbGYhJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UGFyZW50T2ZEaXNwb3NhYmxlKG8sIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgaWYgKCFEaXNwb3NhYmxlU3RvcmUuRElTQUJMRV9ESVNQT1NFRF9XQVJOSU5HKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcignVHJ5aW5nIHRvIGFkZCBhIGRpc3Bvc2FibGUgdG8gYSBEaXNwb3NhYmxlU3RvcmUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkIG9mLiBUaGUgYWRkZWQgb2JqZWN0IHdpbGwgYmUgbGVha2VkIScpLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RvRGlzcG9zZS5hZGQobyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIHZhbHVlIGZyb20gdGhlIHN0b3JlLCBidXQgZG9lcyBub3QgZGlzcG9zZSBpdC5cbiAgICAgKi9cbiAgICBkZWxldGVBbmRMZWFrKG8pIHtcbiAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RvRGlzcG9zZS5oYXMobykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvRGlzcG9zZS5kZWxldGUobyk7XG4gICAgICAgICAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGUobywgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGEge0BsaW5rIElEaXNwb3NhYmxlIGRpc3Bvc2FibGV9IG9iamVjdC5cbiAqXG4gKiBTdWJjbGFzc2VzIGNhbiB7QGxpbmtjb2RlIF9yZWdpc3Rlcn0gZGlzcG9zYWJsZXMgdGhhdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2xlYW5lZCB1cCB3aGVuIHRoaXMgb2JqZWN0IGlzIGRpc3Bvc2VkIG9mLlxuICovXG5leHBvcnQgY2xhc3MgRGlzcG9zYWJsZSB7XG4gICAgLyoqXG4gICAgICogQSBkaXNwb3NhYmxlIHRoYXQgZG9lcyBub3RoaW5nIHdoZW4gaXQgaXMgZGlzcG9zZWQgb2YuXG4gICAgICpcbiAgICAgKiBUT0RPOiBUaGlzIHNob3VsZCBub3QgYmUgYSBzdGF0aWMgcHJvcGVydHkuXG4gICAgICovXG4gICAgc3RhdGljIHsgdGhpcy5Ob25lID0gT2JqZWN0LmZyZWV6ZSh7IGRpc3Bvc2UoKSB7IH0gfSk7IH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fc3RvcmUgPSBuZXcgRGlzcG9zYWJsZVN0b3JlKCk7XG4gICAgICAgIHRyYWNrRGlzcG9zYWJsZSh0aGlzKTtcbiAgICAgICAgc2V0UGFyZW50T2ZEaXNwb3NhYmxlKHRoaXMuX3N0b3JlLCB0aGlzKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgbWFya0FzRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIHRoaXMuX3N0b3JlLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBgb2AgdG8gdGhlIGNvbGxlY3Rpb24gb2YgZGlzcG9zYWJsZXMgbWFuYWdlZCBieSB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBfcmVnaXN0ZXIobykge1xuICAgICAgICBpZiAobyA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVnaXN0ZXIgYSBkaXNwb3NhYmxlIG9uIGl0c2VsZiEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmUuYWRkKG8pO1xuICAgIH1cbn1cbi8qKlxuICogTWFuYWdlcyB0aGUgbGlmZWN5Y2xlIG9mIGEgZGlzcG9zYWJsZSB2YWx1ZSB0aGF0IG1heSBiZSBjaGFuZ2VkLlxuICpcbiAqIFRoaXMgZW5zdXJlcyB0aGF0IHdoZW4gdGhlIGRpc3Bvc2FibGUgdmFsdWUgaXMgY2hhbmdlZCwgdGhlIHByZXZpb3VzbHkgaGVsZCBkaXNwb3NhYmxlIGlzIGRpc3Bvc2VkIG9mLiBZb3UgY2FuXG4gKiBhbHNvIHJlZ2lzdGVyIGEgYE11dGFibGVEaXNwb3NhYmxlYCBvbiBhIGBEaXNwb3NhYmxlYCB0byBlbnN1cmUgaXQgaXMgYXV0b21hdGljYWxseSBjbGVhbmVkIHVwLlxuICovXG5leHBvcnQgY2xhc3MgTXV0YWJsZURpc3Bvc2FibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRyYWNrRGlzcG9zYWJsZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXNwb3NlZCA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQgfHwgdmFsdWUgPT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmFsdWU/LmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGUodmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgc3RvcmVkIHZhbHVlIGFuZCBkaXNwb3NlZCBvZiB0aGUgcHJldmlvdXNseSBzdG9yZWQgdmFsdWUuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICBtYXJrQXNEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdmFsdWU/LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJlZkNvdW50ZWREaXNwb3NhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihfZGlzcG9zYWJsZSkge1xuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlID0gX2Rpc3Bvc2FibGU7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSAxO1xuICAgIH1cbiAgICBhY3F1aXJlKCkge1xuICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWxlYXNlKCkge1xuICAgICAgICBpZiAoLS10aGlzLl9jb3VudGVyID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW1tb3J0YWxSZWZlcmVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKG9iamVjdCkge1xuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHsgfVxufVxuLyoqXG4gKiBBIG1hcCB0aGUgbWFuYWdlcyB0aGUgbGlmZWN5Y2xlIG9mIHRoZSB2YWx1ZXMgdGhhdCBpdCBzdG9yZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXNwb3NhYmxlTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fc3RvcmUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdHJhY2tEaXNwb3NhYmxlKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBvZiBhbGwgc3RvcmVkIHZhbHVlcyBhbmQgbWFyayB0aGlzIG9iamVjdCBhcyBkaXNwb3NlZC5cbiAgICAgKlxuICAgICAqIFRyeWluZyB0byB1c2UgdGhpcyBvYmplY3QgYWZ0ZXIgaXQgaGFzIGJlZW4gZGlzcG9zZWQgb2YgaXMgYW4gZXJyb3IuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgbWFya0FzRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFyQW5kRGlzcG9zZUFsbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBvZiBhbGwgc3RvcmVkIHZhbHVlcyBhbmQgY2xlYXIgdGhlIG1hcCwgYnV0IERPIE5PVCBtYXJrIHRoaXMgb2JqZWN0IGFzIGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIGNsZWFyQW5kRGlzcG9zZUFsbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdG9yZS5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRpc3Bvc2UodGhpcy5fc3RvcmUudmFsdWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcmUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUsIHNraXBEaXNwb3NlT25PdmVyd3JpdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcignVHJ5aW5nIHRvIGFkZCBhIGRpc3Bvc2FibGUgdG8gYSBEaXNwb3NhYmxlTWFwIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCBvZi4gVGhlIGFkZGVkIG9iamVjdCB3aWxsIGJlIGxlYWtlZCEnKS5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFza2lwRGlzcG9zZU9uT3ZlcndyaXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9yZS5nZXQoa2V5KT8uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3JlLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSB2YWx1ZSBzdG9yZWQgZm9yIGBrZXlgIGZyb20gdGhpcyBtYXAgYW5kIGFsc28gZGlzcG9zZSBvZiBpdC5cbiAgICAgKi9cbiAgICBkZWxldGVBbmREaXNwb3NlKGtleSkge1xuICAgICAgICB0aGlzLl9zdG9yZS5nZXQoa2V5KT8uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9zdG9yZS5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5jbGFzcyBOb2RlIHtcbiAgICBzdGF0aWMgeyB0aGlzLlVuZGVmaW5lZCA9IG5ldyBOb2RlKHVuZGVmaW5lZCk7IH1cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmV4dCA9IE5vZGUuVW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnByZXYgPSBOb2RlLlVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTGlua2VkTGlzdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2xhc3QgPSBOb2RlLlVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0ID09PSBOb2RlLlVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fZmlyc3Q7XG4gICAgICAgIHdoaWxlIChub2RlICE9PSBOb2RlLlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIG5vZGUucHJldiA9IE5vZGUuVW5kZWZpbmVkO1xuICAgICAgICAgICAgbm9kZS5uZXh0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXJzdCA9IE5vZGUuVW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9sYXN0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIH1cbiAgICB1bnNoaWZ0KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydChlbGVtZW50LCBmYWxzZSk7XG4gICAgfVxuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KGVsZW1lbnQsIHRydWUpO1xuICAgIH1cbiAgICBfaW5zZXJ0KGVsZW1lbnQsIGF0VGhlRW5kKSB7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgTm9kZShlbGVtZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0ID09PSBOb2RlLlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBuZXdOb2RlO1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXRUaGVFbmQpIHtcbiAgICAgICAgICAgIC8vIHB1c2hcbiAgICAgICAgICAgIGNvbnN0IG9sZExhc3QgPSB0aGlzLl9sYXN0O1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IG5ld05vZGU7XG4gICAgICAgICAgICBuZXdOb2RlLnByZXYgPSBvbGRMYXN0O1xuICAgICAgICAgICAgb2xkTGFzdC5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVuc2hpZnRcbiAgICAgICAgICAgIGNvbnN0IG9sZEZpcnN0ID0gdGhpcy5fZmlyc3Q7XG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IG5ld05vZGU7XG4gICAgICAgICAgICBuZXdOb2RlLm5leHQgPSBvbGRGaXJzdDtcbiAgICAgICAgICAgIG9sZEZpcnN0LnByZXYgPSBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpemUgKz0gMTtcbiAgICAgICAgbGV0IGRpZFJlbW92ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkaWRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBkaWRSZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZShuZXdOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2hpZnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9maXJzdCA9PT0gTm9kZS5VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9maXJzdC5lbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHRoaXMuX2ZpcnN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9wKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdCA9PT0gTm9kZS5VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9sYXN0LmVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUodGhpcy5fbGFzdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZW1vdmUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5wcmV2ICE9PSBOb2RlLlVuZGVmaW5lZCAmJiBub2RlLm5leHQgIT09IE5vZGUuVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBtaWRkbGVcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5vZGUucHJldjtcbiAgICAgICAgICAgIGFuY2hvci5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBhbmNob3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wcmV2ID09PSBOb2RlLlVuZGVmaW5lZCAmJiBub2RlLm5leHQgPT09IE5vZGUuVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBvbmx5IG5vZGVcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5uZXh0ID09PSBOb2RlLlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbGFzdFxuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IHRoaXMuX2xhc3QucHJldjtcbiAgICAgICAgICAgIHRoaXMuX2xhc3QubmV4dCA9IE5vZGUuVW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucHJldiA9PT0gTm9kZS5VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0XG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IHRoaXMuX2ZpcnN0Lm5leHQ7XG4gICAgICAgICAgICB0aGlzLl9maXJzdC5wcmV2ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uZVxuICAgICAgICB0aGlzLl9zaXplIC09IDE7XG4gICAgfVxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9maXJzdDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IE5vZGUuVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB5aWVsZCBub2RlLmVsZW1lbnQ7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgX2EsIF9iO1xuY2xhc3MgUmVzb3VyY2VNYXBFbnRyeSB7XG4gICAgY29uc3RydWN0b3IodXJpLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRW50cmllcyhhcmcpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xufVxuZXhwb3J0IGNsYXNzIFJlc291cmNlTWFwIHtcbiAgICBzdGF0aWMgeyB0aGlzLmRlZmF1bHRUb0tleSA9IChyZXNvdXJjZSkgPT4gcmVzb3VyY2UudG9TdHJpbmcoKTsgfVxuICAgIGNvbnN0cnVjdG9yKGFyZywgdG9LZXkpIHtcbiAgICAgICAgdGhpc1tfYV0gPSAnUmVzb3VyY2VNYXAnO1xuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgUmVzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcChhcmcubWFwKTtcbiAgICAgICAgICAgIHRoaXMudG9LZXkgPSB0b0tleSA/PyBSZXNvdXJjZU1hcC5kZWZhdWx0VG9LZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFbnRyaWVzKGFyZykpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy50b0tleSA9IHRvS2V5ID8/IFJlc291cmNlTWFwLmRlZmF1bHRUb0tleTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCB2YWx1ZV0gb2YgYXJnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQocmVzb3VyY2UsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy50b0tleSA9IGFyZyA/PyBSZXNvdXJjZU1hcC5kZWZhdWx0VG9LZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHJlc291cmNlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1hcC5zZXQodGhpcy50b0tleShyZXNvdXJjZSksIG5ldyBSZXNvdXJjZU1hcEVudHJ5KHJlc291cmNlLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0KHJlc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXQodGhpcy50b0tleShyZXNvdXJjZSkpPy52YWx1ZTtcbiAgICB9XG4gICAgaGFzKHJlc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXModGhpcy50b0tleShyZXNvdXJjZSkpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLnNpemU7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLm1hcC5jbGVhcigpO1xuICAgIH1cbiAgICBkZWxldGUocmVzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmRlbGV0ZSh0aGlzLnRvS2V5KHJlc291cmNlKSk7XG4gICAgfVxuICAgIGZvckVhY2goY2xiLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNsYiA9IGNsYi5iaW5kKHRoaXNBcmcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW18sIGVudHJ5XSBvZiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgY2xiKGVudHJ5LnZhbHVlLCBlbnRyeS51cmksIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgICp2YWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5tYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHlpZWxkIGVudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgICprZXlzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMubWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB5aWVsZCBlbnRyeS51cmk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKmVudHJpZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5tYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHlpZWxkIFtlbnRyeS51cmksIGVudHJ5LnZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqWyhfYSA9IFN5bWJvbC50b1N0cmluZ1RhZywgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIGZvciAoY29uc3QgWywgZW50cnldIG9mIHRoaXMubWFwKSB7XG4gICAgICAgICAgICB5aWVsZCBbZW50cnkudXJpLCBlbnRyeS52YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTGlua2VkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpc1tfYl0gPSAnTGlua2VkTWFwJztcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWw7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZD8udmFsdWU7XG4gICAgfVxuICAgIGdldCBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFpbD8udmFsdWU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9XG4gICAgZ2V0KGtleSwgdG91Y2ggPSAwIC8qIFRvdWNoLk5vbmUgKi8pIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCAhPT0gMCAvKiBUb3VjaC5Ob25lICovKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKGl0ZW0sIHRvdWNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUsIHRvdWNoID0gMCAvKiBUb3VjaC5Ob25lICovKSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvdWNoICE9PSAwIC8qIFRvdWNoLk5vbmUgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoKGl0ZW0sIHRvdWNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSB7IGtleSwgdmFsdWUsIG5leHQ6IHVuZGVmaW5lZCwgcHJldmlvdXM6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgc3dpdGNoICh0b3VjaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBUb3VjaC5Ob25lICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogVG91Y2guQXNPbGQgKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUZpcnN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogVG91Y2guQXNOZXcgKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faGVhZDtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShpdGVtLmtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5iaW5kKHRoaXNBcmcpKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBjdXJyZW50LmtleSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBjdXJyZW50LnZhbHVlLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBbY3VycmVudC5rZXksIGN1cnJlbnQudmFsdWVdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBbKF9iID0gU3ltYm9sLnRvU3RyaW5nVGFnLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICB0cmltT2xkKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5ld1NpemUgPj0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudFNpemUgPiBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGN1cnJlbnQua2V5KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZS0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLl9zaXplID0gY3VycmVudFNpemU7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIHRyaW1OZXcobmV3U2l6ZSkge1xuICAgICAgICBpZiAobmV3U2l6ZSA+PSB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5fdGFpbDtcbiAgICAgICAgbGV0IGN1cnJlbnRTaXplID0gdGhpcy5zaXplO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50U2l6ZSA+IG5ld1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoY3VycmVudC5rZXkpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucHJldmlvdXM7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZS0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhaWwgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLl9zaXplID0gY3VycmVudFNpemU7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50Lm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgYWRkSXRlbUZpcnN0KGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ubmV4dCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXZpb3VzID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgYWRkSXRlbUxhc3QoaXRlbSkge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIEluc2VydFxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5wcmV2aW91cyA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICByZW1vdmVJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQgJiYgaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgc2l6ZSA9PT0gMSB3aGljaCBpcyBoYW5kbGVkXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ubmV4dC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgc2l6ZSA9PT0gMSB3aGljaCBpcyBoYW5kbGVkXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgIXByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaXRlbS5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgdG91Y2goaXRlbSwgdG91Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodG91Y2ggIT09IDEgLyogVG91Y2guQXNPbGQgKi8gJiYgdG91Y2ggIT09IDIgLyogVG91Y2guQXNOZXcgKi8pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdWNoID09PSAxIC8qIFRvdWNoLkFzT2xkICovKSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICAvLyBVbmxpbmsgdGhlIGl0ZW1cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5vdCBoZWFkIGJ1dCBpcyB0YWlsXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbiBpdGVtIGluIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBwcmV2aW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggbmV4dCBhbmQgcHJldmlvdXMgYXJlIG5vdCB1bmRlZmluZWQgc2luY2UgaXRlbSB3YXMgbmVpdGhlciBoZWFkIG5vciB0YWlsLlxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbm9kZSBhdCBoZWFkXG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdGhpcy5faGVhZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldmlvdXMgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSAyIC8qIFRvdWNoLkFzTmV3ICovKSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICAvLyBVbmxpbmsgdGhlIGl0ZW0uXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgICAgIC8vIG5leHQgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5vdCB0YWlsIGJ1dCBpcyBoZWFkXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbiBpdGVtIGluIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaXRlbS5wcmV2aW91cyA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGZyb21KU09OKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENhY2hlIGV4dGVuZHMgTGlua2VkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsaW1pdCwgcmF0aW8gPSAxKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgcmF0aW8pLCAxKTtcbiAgICB9XG4gICAgZ2V0IGxpbWl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGltaXQ7XG4gICAgfVxuICAgIHNldCBsaW1pdChsaW1pdCkge1xuICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLmNoZWNrVHJpbSgpO1xuICAgIH1cbiAgICBnZXQoa2V5LCB0b3VjaCA9IDIgLyogVG91Y2guQXNOZXcgKi8pIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIHRvdWNoKTtcbiAgICB9XG4gICAgcGVlayhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIDAgLyogVG91Y2guTm9uZSAqLyk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlLCAyIC8qIFRvdWNoLkFzTmV3ICovKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNoZWNrVHJpbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA+IHRoaXMuX2xpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLnRyaW0oTWF0aC5yb3VuZCh0aGlzLl9saW1pdCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTFJVQ2FjaGUgZXh0ZW5kcyBDYWNoZSB7XG4gICAgY29uc3RydWN0b3IobGltaXQsIHJhdGlvID0gMSkge1xuICAgICAgICBzdXBlcihsaW1pdCwgcmF0aW8pO1xuICAgIH1cbiAgICB0cmltKG5ld1NpemUpIHtcbiAgICAgICAgdGhpcy50cmltT2xkKG5ld1NpemUpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8qKlxuICogQSBtYXAgdGhhdCBhbGxvd3MgYWNjZXNzIGJvdGggYnkga2V5cyBhbmQgdmFsdWVzLlxuICogKipOT1RFKio6IHZhbHVlcyBuZWVkIHRvIGJlIHVuaXF1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlyZWN0aW9uYWxNYXAge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgdGhpcy5fbTEgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX20yID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoZW50cmllcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9tMS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9tMi5jbGVhcigpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tMS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX20yLnNldCh2YWx1ZSwga2V5KTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbTEuZ2V0KGtleSk7XG4gICAgfVxuICAgIGdldEtleSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbTIuZ2V0KHZhbHVlKTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX20xLmdldChrZXkpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX20xLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aGlzLl9tMi5kZWxldGUodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX20xLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbTEudmFsdWVzKCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNldE1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgdmFsdWVzID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghdmFsdWVzKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5hZGQodmFsdWUpO1xuICAgIH1cbiAgICBkZWxldGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoKGtleSwgZm4pIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghdmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLmZvckVhY2goZm4pO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIXZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgZXJyb3JzIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIHBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uanMnO1xuaW1wb3J0IHsgZXF1YWxzSWdub3JlQ2FzZSwgc3RhcnRzV2l0aElnbm9yZUNhc2UgfSBmcm9tICcuL3N0cmluZ3MuanMnO1xuaW1wb3J0IHsgVVJJIH0gZnJvbSAnLi91cmkuanMnO1xuaW1wb3J0ICogYXMgcGF0aHMgZnJvbSAnLi9wYXRoLmpzJztcbmV4cG9ydCB2YXIgU2NoZW1hcztcbihmdW5jdGlvbiAoU2NoZW1hcykge1xuICAgIC8qKlxuICAgICAqIEEgc2NoZW1hIHRoYXQgaXMgdXNlZCBmb3IgbW9kZWxzIHRoYXQgZXhpc3QgaW4gbWVtb3J5XG4gICAgICogb25seSBhbmQgdGhhdCBoYXZlIG5vIGNvcnJlc3BvbmRlbmNlIG9uIGEgc2VydmVyIG9yIHN1Y2guXG4gICAgICovXG4gICAgU2NoZW1hcy5pbk1lbW9yeSA9ICdpbm1lbW9yeSc7XG4gICAgLyoqXG4gICAgICogQSBzY2hlbWEgdGhhdCBpcyB1c2VkIGZvciBzZXR0aW5nIGZpbGVzXG4gICAgICovXG4gICAgU2NoZW1hcy52c2NvZGUgPSAndnNjb2RlJztcbiAgICAvKipcbiAgICAgKiBBIHNjaGVtYSB0aGF0IGlzIHVzZWQgZm9yIGludGVybmFsIHByaXZhdGUgZmlsZXNcbiAgICAgKi9cbiAgICBTY2hlbWFzLmludGVybmFsID0gJ3ByaXZhdGUnO1xuICAgIC8qKlxuICAgICAqIEEgd2Fsay10aHJvdWdoIGRvY3VtZW50LlxuICAgICAqL1xuICAgIFNjaGVtYXMud2Fsa1Rocm91Z2ggPSAnd2Fsa1Rocm91Z2gnO1xuICAgIC8qKlxuICAgICAqIEFuIGVtYmVkZGVkIGNvZGUgc25pcHBldC5cbiAgICAgKi9cbiAgICBTY2hlbWFzLndhbGtUaHJvdWdoU25pcHBldCA9ICd3YWxrVGhyb3VnaFNuaXBwZXQnO1xuICAgIFNjaGVtYXMuaHR0cCA9ICdodHRwJztcbiAgICBTY2hlbWFzLmh0dHBzID0gJ2h0dHBzJztcbiAgICBTY2hlbWFzLmZpbGUgPSAnZmlsZSc7XG4gICAgU2NoZW1hcy5tYWlsdG8gPSAnbWFpbHRvJztcbiAgICBTY2hlbWFzLnVudGl0bGVkID0gJ3VudGl0bGVkJztcbiAgICBTY2hlbWFzLmRhdGEgPSAnZGF0YSc7XG4gICAgU2NoZW1hcy5jb21tYW5kID0gJ2NvbW1hbmQnO1xuICAgIFNjaGVtYXMudnNjb2RlUmVtb3RlID0gJ3ZzY29kZS1yZW1vdGUnO1xuICAgIFNjaGVtYXMudnNjb2RlUmVtb3RlUmVzb3VyY2UgPSAndnNjb2RlLXJlbW90ZS1yZXNvdXJjZSc7XG4gICAgU2NoZW1hcy52c2NvZGVNYW5hZ2VkUmVtb3RlUmVzb3VyY2UgPSAndnNjb2RlLW1hbmFnZWQtcmVtb3RlLXJlc291cmNlJztcbiAgICBTY2hlbWFzLnZzY29kZVVzZXJEYXRhID0gJ3ZzY29kZS11c2VyZGF0YSc7XG4gICAgU2NoZW1hcy52c2NvZGVDdXN0b21FZGl0b3IgPSAndnNjb2RlLWN1c3RvbS1lZGl0b3InO1xuICAgIFNjaGVtYXMudnNjb2RlTm90ZWJvb2tDZWxsID0gJ3ZzY29kZS1ub3RlYm9vay1jZWxsJztcbiAgICBTY2hlbWFzLnZzY29kZU5vdGVib29rQ2VsbE1ldGFkYXRhID0gJ3ZzY29kZS1ub3RlYm9vay1jZWxsLW1ldGFkYXRhJztcbiAgICBTY2hlbWFzLnZzY29kZU5vdGVib29rQ2VsbE1ldGFkYXRhRGlmZiA9ICd2c2NvZGUtbm90ZWJvb2stY2VsbC1tZXRhZGF0YS1kaWZmJztcbiAgICBTY2hlbWFzLnZzY29kZU5vdGVib29rQ2VsbE91dHB1dCA9ICd2c2NvZGUtbm90ZWJvb2stY2VsbC1vdXRwdXQnO1xuICAgIFNjaGVtYXMudnNjb2RlTm90ZWJvb2tDZWxsT3V0cHV0RGlmZiA9ICd2c2NvZGUtbm90ZWJvb2stY2VsbC1vdXRwdXQtZGlmZic7XG4gICAgU2NoZW1hcy52c2NvZGVOb3RlYm9va01ldGFkYXRhID0gJ3ZzY29kZS1ub3RlYm9vay1tZXRhZGF0YSc7XG4gICAgU2NoZW1hcy52c2NvZGVJbnRlcmFjdGl2ZUlucHV0ID0gJ3ZzY29kZS1pbnRlcmFjdGl2ZS1pbnB1dCc7XG4gICAgU2NoZW1hcy52c2NvZGVTZXR0aW5ncyA9ICd2c2NvZGUtc2V0dGluZ3MnO1xuICAgIFNjaGVtYXMudnNjb2RlV29ya3NwYWNlVHJ1c3QgPSAndnNjb2RlLXdvcmtzcGFjZS10cnVzdCc7XG4gICAgU2NoZW1hcy52c2NvZGVUZXJtaW5hbCA9ICd2c2NvZGUtdGVybWluYWwnO1xuICAgIC8qKiBTY2hlbWUgdXNlZCBmb3IgY29kZSBibG9ja3MgaW4gY2hhdC4gKi9cbiAgICBTY2hlbWFzLnZzY29kZUNoYXRDb2RlQmxvY2sgPSAndnNjb2RlLWNoYXQtY29kZS1ibG9jayc7XG4gICAgLyoqIFNjaGVtZSB1c2VkIGZvciBMSFMgb2YgY29kZSBjb21wYXJlIChha2EgZGlmZikgYmxvY2tzIGluIGNoYXQuICovXG4gICAgU2NoZW1hcy52c2NvZGVDaGF0Q29kZUNvbXBhcmVCbG9jayA9ICd2c2NvZGUtY2hhdC1jb2RlLWNvbXBhcmUtYmxvY2snO1xuICAgIC8qKiBTY2hlbWUgdXNlZCBmb3IgdGhlIGNoYXQgaW5wdXQgZWRpdG9yLiAqL1xuICAgIFNjaGVtYXMudnNjb2RlQ2hhdFNlc3NzaW9uID0gJ3ZzY29kZS1jaGF0LWVkaXRvcic7XG4gICAgLyoqXG4gICAgICogU2NoZW1lIHVzZWQgaW50ZXJuYWxseSBmb3Igd2Vidmlld3MgdGhhdCBhcmVuJ3QgbGlua2VkIHRvIGEgcmVzb3VyY2UgKGkuZS4gbm90IGN1c3RvbSBlZGl0b3JzKVxuICAgICAqL1xuICAgIFNjaGVtYXMud2Vidmlld1BhbmVsID0gJ3dlYnZpZXctcGFuZWwnO1xuICAgIC8qKlxuICAgICAqIFNjaGVtZSB1c2VkIGZvciBsb2FkaW5nIHRoZSB3cmFwcGVyIGh0bWwgYW5kIHNjcmlwdCBpbiB3ZWJ2aWV3cy5cbiAgICAgKi9cbiAgICBTY2hlbWFzLnZzY29kZVdlYnZpZXcgPSAndnNjb2RlLXdlYnZpZXcnO1xuICAgIC8qKlxuICAgICAqIFNjaGVtZSB1c2VkIGZvciBleHRlbnNpb24gcGFnZXNcbiAgICAgKi9cbiAgICBTY2hlbWFzLmV4dGVuc2lvbiA9ICdleHRlbnNpb24nO1xuICAgIC8qKlxuICAgICAqIFNjaGVtZSB1c2VkIGFzIGEgcmVwbGFjZW1lbnQgb2YgYGZpbGVgIHNjaGVtZSB0byBsb2FkXG4gICAgICogZmlsZXMgd2l0aCBvdXIgY3VzdG9tIHByb3RvY29sIGhhbmRsZXIgKGRlc2t0b3Agb25seSkuXG4gICAgICovXG4gICAgU2NoZW1hcy52c2NvZGVGaWxlUmVzb3VyY2UgPSAndnNjb2RlLWZpbGUnO1xuICAgIC8qKlxuICAgICAqIFNjaGVtZSB1c2VkIGZvciB0ZW1wb3JhcnkgcmVzb3VyY2VzXG4gICAgICovXG4gICAgU2NoZW1hcy50bXAgPSAndG1wJztcbiAgICAvKipcbiAgICAgKiBTY2hlbWUgdXNlZCB2cyBsaXZlIHNoYXJlXG4gICAgICovXG4gICAgU2NoZW1hcy52c2xzID0gJ3ZzbHMnO1xuICAgIC8qKlxuICAgICAqIFNjaGVtZSB1c2VkIGZvciB0aGUgU291cmNlIENvbnRyb2wgY29tbWl0IGlucHV0J3MgdGV4dCBkb2N1bWVudFxuICAgICAqL1xuICAgIFNjaGVtYXMudnNjb2RlU291cmNlQ29udHJvbCA9ICd2c2NvZGUtc2NtJztcbiAgICAvKipcbiAgICAgKiBTY2hlbWUgdXNlZCBmb3IgaW5wdXQgYm94IGZvciBjcmVhdGluZyBjb21tZW50cy5cbiAgICAgKi9cbiAgICBTY2hlbWFzLmNvbW1lbnRzSW5wdXQgPSAnY29tbWVudCc7XG4gICAgLyoqXG4gICAgICogU2NoZW1lIHVzZWQgZm9yIHNwZWNpYWwgcmVuZGVyaW5nIG9mIHNldHRpbmdzIGluIHRoZSByZWxlYXNlIG5vdGVzXG4gICAgICovXG4gICAgU2NoZW1hcy5jb2RlU2V0dGluZyA9ICdjb2RlLXNldHRpbmcnO1xuICAgIC8qKlxuICAgICAqIFNjaGVtZSB1c2VkIGZvciBvdXRwdXQgcGFuZWwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgU2NoZW1hcy5vdXRwdXRDaGFubmVsID0gJ291dHB1dCc7XG59KShTY2hlbWFzIHx8IChTY2hlbWFzID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzU2NoZW1lKHRhcmdldCwgc2NoZW1lKSB7XG4gICAgaWYgKFVSSS5pc1VyaSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBlcXVhbHNJZ25vcmVDYXNlKHRhcmdldC5zY2hlbWUsIHNjaGVtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RhcnRzV2l0aElnbm9yZUNhc2UodGFyZ2V0LCBzY2hlbWUgKyAnOicpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzU29tZVNjaGVtZSh0YXJnZXQsIC4uLnNjaGVtZXMpIHtcbiAgICByZXR1cm4gc2NoZW1lcy5zb21lKHNjaGVtZSA9PiBtYXRjaGVzU2NoZW1lKHRhcmdldCwgc2NoZW1lKSk7XG59XG5leHBvcnQgY29uc3QgY29ubmVjdGlvblRva2VuUXVlcnlOYW1lID0gJ3Rrbic7XG5jbGFzcyBSZW1vdGVBdXRob3JpdGllc0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9ob3N0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX3BvcnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblRva2VucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX3ByZWZlcnJlZFdlYlNjaGVtYSA9ICdodHRwJztcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZXJ2ZXJSb290UGF0aCA9ICcvJztcbiAgICB9XG4gICAgc2V0UHJlZmVycmVkV2ViU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICB0aGlzLl9wcmVmZXJyZWRXZWJTY2hlbWEgPSBzY2hlbWE7XG4gICAgfVxuICAgIGdldCBfcmVtb3RlUmVzb3VyY2VzUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhzLnBvc2l4LmpvaW4odGhpcy5fc2VydmVyUm9vdFBhdGgsIFNjaGVtYXMudnNjb2RlUmVtb3RlUmVzb3VyY2UpO1xuICAgIH1cbiAgICByZXdyaXRlKHVyaSkge1xuICAgICAgICBpZiAodGhpcy5fZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlKHVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLm9uVW5leHBlY3RlZEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5O1xuICAgICAgICBsZXQgaG9zdCA9IHRoaXMuX2hvc3RzW2F1dGhvcml0eV07XG4gICAgICAgIGlmIChob3N0ICYmIGhvc3QuaW5kZXhPZignOicpICE9PSAtMSAmJiBob3N0LmluZGV4T2YoJ1snKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGhvc3QgPSBgWyR7aG9zdH1dYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3J0ID0gdGhpcy5fcG9ydHNbYXV0aG9yaXR5XTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvblRva2VuID0gdGhpcy5fY29ubmVjdGlvblRva2Vuc1thdXRob3JpdHldO1xuICAgICAgICBsZXQgcXVlcnkgPSBgcGF0aD0ke2VuY29kZVVSSUNvbXBvbmVudCh1cmkucGF0aCl9YDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0aW9uVG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBxdWVyeSArPSBgJiR7Y29ubmVjdGlvblRva2VuUXVlcnlOYW1lfT0ke2VuY29kZVVSSUNvbXBvbmVudChjb25uZWN0aW9uVG9rZW4pfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVSSS5mcm9tKHtcbiAgICAgICAgICAgIHNjaGVtZTogcGxhdGZvcm0uaXNXZWIgPyB0aGlzLl9wcmVmZXJyZWRXZWJTY2hlbWEgOiBTY2hlbWFzLnZzY29kZVJlbW90ZVJlc291cmNlLFxuICAgICAgICAgICAgYXV0aG9yaXR5OiBgJHtob3N0fToke3BvcnR9YCxcbiAgICAgICAgICAgIHBhdGg6IHRoaXMuX3JlbW90ZVJlc291cmNlc1BhdGgsXG4gICAgICAgICAgICBxdWVyeVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgUmVtb3RlQXV0aG9yaXRpZXMgPSBuZXcgUmVtb3RlQXV0aG9yaXRpZXNJbXBsKCk7XG5leHBvcnQgY29uc3QgVlNDT0RFX0FVVEhPUklUWSA9ICd2c2NvZGUtYXBwJztcbmNsYXNzIEZpbGVBY2Nlc3NJbXBsIHtcbiAgICBzdGF0aWMgeyB0aGlzLkZBTExCQUNLX0FVVEhPUklUWSA9IFZTQ09ERV9BVVRIT1JJVFk7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgVVJJIHRvIHVzZSBpbiBjb250ZXh0cyB3aGVyZSB0aGUgYnJvd3NlciBpcyByZXNwb25zaWJsZVxuICAgICAqIGZvciBsb2FkaW5nIChlLmcuIGZldGNoKCkpIG9yIHdoZW4gdXNlZCB3aXRoaW4gdGhlIERPTS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiB1c2UgYGRvbS50cyNhc0NTU1VybGAgd2hlbmV2ZXIgdGhlIFVSTCBpcyB0byBiZSB1c2VkIGluIENTUyBjb250ZXh0LlxuICAgICAqL1xuICAgIGFzQnJvd3NlclVyaShyZXNvdXJjZVBhdGgpIHtcbiAgICAgICAgLy8gRVNNLWNvbW1lbnQtYmVnaW5cbiAgICAgICAgLy8gXHRcdGNvbnN0IHVyaSA9IHRoaXMudG9VcmkocmVzb3VyY2VQYXRoLCByZXF1aXJlKTtcbiAgICAgICAgLy8gRVNNLWNvbW1lbnQtZW5kXG4gICAgICAgIC8vIEVTTS11bmNvbW1lbnQtYmVnaW5cbiAgICAgICAgY29uc3QgdXJpID0gdGhpcy50b1VyaShyZXNvdXJjZVBhdGgpO1xuICAgICAgICAvLyBFU00tdW5jb21tZW50LWVuZFxuICAgICAgICByZXR1cm4gdGhpcy51cmlUb0Jyb3dzZXJVcmkodXJpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFVSSSB0byB1c2UgaW4gY29udGV4dHMgd2hlcmUgdGhlIGJyb3dzZXIgaXMgcmVzcG9uc2libGVcbiAgICAgKiBmb3IgbG9hZGluZyAoZS5nLiBmZXRjaCgpKSBvciB3aGVuIHVzZWQgd2l0aGluIHRoZSBET00uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogdXNlIGBkb20udHMjYXNDU1NVcmxgIHdoZW5ldmVyIHRoZSBVUkwgaXMgdG8gYmUgdXNlZCBpbiBDU1MgY29udGV4dC5cbiAgICAgKi9cbiAgICB1cmlUb0Jyb3dzZXJVcmkodXJpKSB7XG4gICAgICAgIC8vIEhhbmRsZSByZW1vdGUgVVJJcyB2aWEgYFJlbW90ZUF1dGhvcml0aWVzYFxuICAgICAgICBpZiAodXJpLnNjaGVtZSA9PT0gU2NoZW1hcy52c2NvZGVSZW1vdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBSZW1vdGVBdXRob3JpdGllcy5yZXdyaXRlKHVyaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydCB0byBgdnNjb2RlLWZpbGVgIHJlc291cmNlLi5cbiAgICAgICAgaWYgKFxuICAgICAgICAvLyAuLi5vbmx5IGV2ZXIgZm9yIGBmaWxlYCByZXNvdXJjZXNcbiAgICAgICAgdXJpLnNjaGVtZSA9PT0gU2NoZW1hcy5maWxlICYmXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAvLyAuLi5hbmQgd2UgcnVuIGluIG5hdGl2ZSBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIHBsYXRmb3JtLmlzTmF0aXZlIHx8XG4gICAgICAgICAgICAgICAgLy8gLi4ub3Igd2ViIHdvcmtlciBleHRlbnNpb25zIG9uIGRlc2t0b3BcbiAgICAgICAgICAgICAgICAocGxhdGZvcm0ud2ViV29ya2VyT3JpZ2luID09PSBgJHtTY2hlbWFzLnZzY29kZUZpbGVSZXNvdXJjZX06Ly8ke0ZpbGVBY2Nlc3NJbXBsLkZBTExCQUNLX0FVVEhPUklUWX1gKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmkud2l0aCh7XG4gICAgICAgICAgICAgICAgc2NoZW1lOiBTY2hlbWFzLnZzY29kZUZpbGVSZXNvdXJjZSxcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHByb3ZpZGUgYW4gYXV0aG9yaXR5IGhlcmUgc28gdGhhdCBpdCBjYW4gc2VydmVcbiAgICAgICAgICAgICAgICAvLyBhcyBvcmlnaW4gZm9yIG5ldHdvcmsgYW5kIGxvYWRpbmcgbWF0dGVycyBpbiBjaHJvbWl1bS5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgVVJJIGlzIG5vdCBjb21pbmcgd2l0aCBhbiBhdXRob3JpdHkgYWxyZWFkeSwgd2VcbiAgICAgICAgICAgICAgICAvLyBhZGQgb3VyIG93blxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogdXJpLmF1dGhvcml0eSB8fCBGaWxlQWNjZXNzSW1wbC5GQUxMQkFDS19BVVRIT1JJVFksXG4gICAgICAgICAgICAgICAgcXVlcnk6IG51bGwsXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQ6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgfVxuICAgIHRvVXJpKHVyaU9yTW9kdWxlLCBtb2R1bGVJZFRvVXJsKSB7XG4gICAgICAgIGlmIChVUkkuaXNVcmkodXJpT3JNb2R1bGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJpT3JNb2R1bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuX1ZTQ09ERV9GSUxFX1JPT1QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RVcmlPclBhdGggPSBnbG9iYWxUaGlzLl9WU0NPREVfRklMRV9ST09UO1xuICAgICAgICAgICAgLy8gRmlsZSBVUkwgKHdpdGggc2NoZW1lKVxuICAgICAgICAgICAgaWYgKC9eXFx3W1xcd1xcZCsuLV0qOlxcL1xcLy8udGVzdChyb290VXJpT3JQYXRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVUkkuam9pblBhdGgoVVJJLnBhcnNlKHJvb3RVcmlPclBhdGgsIHRydWUpLCB1cmlPck1vZHVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaWxlIFBhdGggKG5vIHNjaGVtZSlcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVBhdGggPSBwYXRocy5qb2luKHJvb3RVcmlPclBhdGgsIHVyaU9yTW9kdWxlKTtcbiAgICAgICAgICAgIHJldHVybiBVUkkuZmlsZShtb2R1bGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVVJJLnBhcnNlKG1vZHVsZUlkVG9VcmwudG9VcmwodXJpT3JNb2R1bGUpKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgRmlsZUFjY2VzcyA9IG5ldyBGaWxlQWNjZXNzSW1wbCgpO1xuZXhwb3J0IHZhciBDT0k7XG4oZnVuY3Rpb24gKENPSSkge1xuICAgIGNvbnN0IGNvaUhlYWRlcnMgPSBuZXcgTWFwKFtcbiAgICAgICAgWycxJywgeyAnQ3Jvc3MtT3JpZ2luLU9wZW5lci1Qb2xpY3knOiAnc2FtZS1vcmlnaW4nIH1dLFxuICAgICAgICBbJzInLCB7ICdDcm9zcy1PcmlnaW4tRW1iZWRkZXItUG9saWN5JzogJ3JlcXVpcmUtY29ycCcgfV0sXG4gICAgICAgIFsnMycsIHsgJ0Nyb3NzLU9yaWdpbi1PcGVuZXItUG9saWN5JzogJ3NhbWUtb3JpZ2luJywgJ0Nyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3knOiAncmVxdWlyZS1jb3JwJyB9XSxcbiAgICBdKTtcbiAgICBDT0kuQ29vcEFuZENvZXAgPSBPYmplY3QuZnJlZXplKGNvaUhlYWRlcnMuZ2V0KCczJykpO1xuICAgIGNvbnN0IGNvaVNlYXJjaFBhcmFtTmFtZSA9ICd2c2NvZGUtY29pJztcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGRlc2lyZWQgaGVhZGVycyBmcm9tIGB2c2NvZGUtY29pYCBpbnZvY2F0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SGVhZGVyc0Zyb21RdWVyeSh1cmwpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBuZXcgVVJMKHVybCkuc2VhcmNoUGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVybCBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgcGFyYW1zID0gdXJsLnNlYXJjaFBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChVUkkuaXNVcmkodXJsKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gbmV3IFVSTCh1cmwudG9TdHJpbmcodHJ1ZSkpLnNlYXJjaFBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtcz8uZ2V0KGNvaVNlYXJjaFBhcmFtTmFtZSk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvaUhlYWRlcnMuZ2V0KHZhbHVlKTtcbiAgICB9XG4gICAgQ09JLmdldEhlYWRlcnNGcm9tUXVlcnkgPSBnZXRIZWFkZXJzRnJvbVF1ZXJ5O1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgYHZzY29kZS1jb2lgIHF1ZXJ5IGF0dHJpYnV0ZSBiYXNlZCBvbiB3YW50aW5nIGBDT09QYCBhbmQgYENPRVBgLiBXaWxsIGJlIGEgbm9vcCB3aGVuIGBjcm9zc09yaWdpbklzb2xhdGVkYFxuICAgICAqIGlzbid0IGVuYWJsZWQgdGhlIGN1cnJlbnQgY29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFNlYXJjaFBhcmFtKHVybE9yU2VhcmNoLCBjb29wLCBjb2VwKSB7XG4gICAgICAgIGlmICghZ2xvYmFsVGhpcy5jcm9zc09yaWdpbklzb2xhdGVkKSB7XG4gICAgICAgICAgICAvLyBkZXBlbmRzIG9uIHRoZSBjdXJyZW50IGNvbnRleHQgYmVpbmcgQ09JXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb29wICYmIGNvZXAgPyAnMycgOiBjb2VwID8gJzInIDogJzEnO1xuICAgICAgICBpZiAodXJsT3JTZWFyY2ggaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgICAgIHVybE9yU2VhcmNoLnNldChjb2lTZWFyY2hQYXJhbU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVybE9yU2VhcmNoW2NvaVNlYXJjaFBhcmFtTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDT0kuYWRkU2VhcmNoUGFyYW0gPSBhZGRTZWFyY2hQYXJhbTtcbn0pKENPSSB8fCAoQ09JID0ge30pKTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgaXNUeXBlZEFycmF5LCBpc09iamVjdCwgaXNVbmRlZmluZWRPck51bGwgfSBmcm9tICcuL3R5cGVzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKG9iaikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IGRlZXBDbG9uZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBGcmVlemUob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBbb2JqXTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBvYmogPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICBPYmplY3QuZnJlZXplKG9iaik7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdvYmplY3QnICYmICFPYmplY3QuaXNGcm96ZW4ocHJvcCkgJiYgIWlzVHlwZWRBcnJheShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuY29uc3QgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUFuZENoYW5nZShvYmosIGNoYW5nZXIpIHtcbiAgICByZXR1cm4gX2Nsb25lQW5kQ2hhbmdlKG9iaiwgY2hhbmdlciwgbmV3IFNldCgpKTtcbn1cbmZ1bmN0aW9uIF9jbG9uZUFuZENoYW5nZShvYmosIGNoYW5nZXIsIHNlZW4pIHtcbiAgICBpZiAoaXNVbmRlZmluZWRPck51bGwob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gY2hhbmdlcihvYmopO1xuICAgIGlmICh0eXBlb2YgY2hhbmdlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgY29uc3QgcjEgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iaikge1xuICAgICAgICAgICAgcjEucHVzaChfY2xvbmVBbmRDaGFuZ2UoZSwgY2hhbmdlciwgc2VlbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByMTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgaWYgKHNlZW4uaGFzKG9iaikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNsb25lIHJlY3Vyc2l2ZSBkYXRhLXN0cnVjdHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uYWRkKG9iaik7XG4gICAgICAgIGNvbnN0IHIyID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaTIgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBpMikpIHtcbiAgICAgICAgICAgICAgICByMltpMl0gPSBfY2xvbmVBbmRDaGFuZ2Uob2JqW2kyXSwgY2hhbmdlciwgc2Vlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5kZWxldGUob2JqKTtcbiAgICAgICAgcmV0dXJuIHIyO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgb2Ygc291cmNlIGludG8gZGVzdGluYXRpb24uIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgXCJvdmVyd3JpdGVcIiBhbGxvd3MgdG8gY29udHJvbFxuICogaWYgZXhpc3RpbmcgcHJvcGVydGllcyBvbiB0aGUgZGVzdGluYXRpb24gc2hvdWxkIGJlIG92ZXJ3cml0dGVuIG9yIG5vdC4gRGVmYXVsdHMgdG8gdHJ1ZSAob3ZlcndyaXRlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1peGluKGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJ3cml0ZSA9IHRydWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGRlc3RpbmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChkZXN0aW5hdGlvbltrZXldKSAmJiBpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1peGluKGRlc3RpbmF0aW9uW2tleV0sIHNvdXJjZVtrZXldLCBvdmVyd3JpdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhvbmUsIG90aGVyKSB7XG4gICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb25lICE9PSB0eXBlb2Ygb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKEFycmF5LmlzQXJyYXkob25lKSkgIT09IChBcnJheS5pc0FycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaTtcbiAgICBsZXQga2V5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9uZSkpIHtcbiAgICAgICAgaWYgKG9uZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG9uZVtpXSwgb3RoZXJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBvbmVLZXlzID0gW107XG4gICAgICAgIGZvciAoa2V5IGluIG9uZSkge1xuICAgICAgICAgICAgb25lS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgb25lS2V5cy5zb3J0KCk7XG4gICAgICAgIGNvbnN0IG90aGVyS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBvdGhlcikge1xuICAgICAgICAgICAgb3RoZXJLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlcktleXMuc29ydCgpO1xuICAgICAgICBpZiAoIWVxdWFscyhvbmVLZXlzLCBvdGhlcktleXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9uZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG9uZVtvbmVLZXlzW2ldXSwgb3RoZXJbb25lS2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFByb3BlcnR5TmFtZXMob2JqKSB7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIHdoaWxlIChPYmplY3QucHJvdG90eXBlICE9PSBvYmopIHtcbiAgICAgICAgcmVzID0gcmVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopKTtcbiAgICAgICAgb2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTWV0aG9kTmFtZXMob2JqKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBnZXRBbGxQcm9wZXJ0eU5hbWVzKG9iaikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1ldGhvZHMucHVzaChwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm94eU9iamVjdChtZXRob2ROYW1lcywgaW52b2tlKSB7XG4gICAgY29uc3QgY3JlYXRlUHJveHlNZXRob2QgPSAobWV0aG9kKSA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2UobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBtZXRob2ROYW1lcykge1xuICAgICAgICByZXN1bHRbbWV0aG9kTmFtZV0gPSBjcmVhdGVQcm94eU1ldGhvZChtZXRob2ROYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gTk9URTogVlNDb2RlJ3MgY29weSBvZiBub2RlanMgcGF0aCBsaWJyYXJ5IHRvIGJlIHVzYWJsZSBpbiBjb21tb24gKG5vbi1ub2RlKSBuYW1lc3BhY2Vcbi8vIENvcGllZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0cy92MjAuOS4wL2xpYi9wYXRoLmpzXG4vLyBFeGNsdWRpbmc6IHRoZSBjaGFuZ2UgdGhhdCBhZGRzIHByaW1vcmRpYWxzXG4vLyAoaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xODdhODYyZDIyMWRlYzQyZmE5YTVjNDIxNGU3MDM0ZDkwOTI3OTJmIGFuZCBvdGhlcnMpXG4vKipcbiAqIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbiAqIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuICogZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbiAqIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuICogREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4gKiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4gKiBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5pbXBvcnQgKiBhcyBwcm9jZXNzIGZyb20gJy4vcHJvY2Vzcy5qcyc7XG5jb25zdCBDSEFSX1VQUEVSQ0FTRV9BID0gNjU7IC8qIEEgKi9cbmNvbnN0IENIQVJfTE9XRVJDQVNFX0EgPSA5NzsgLyogYSAqL1xuY29uc3QgQ0hBUl9VUFBFUkNBU0VfWiA9IDkwOyAvKiBaICovXG5jb25zdCBDSEFSX0xPV0VSQ0FTRV9aID0gMTIyOyAvKiB6ICovXG5jb25zdCBDSEFSX0RPVCA9IDQ2OyAvKiAuICovXG5jb25zdCBDSEFSX0ZPUldBUkRfU0xBU0ggPSA0NzsgLyogLyAqL1xuY29uc3QgQ0hBUl9CQUNLV0FSRF9TTEFTSCA9IDkyOyAvKiBcXCAqL1xuY29uc3QgQ0hBUl9DT0xPTiA9IDU4OyAvKiA6ICovXG5jb25zdCBDSEFSX1FVRVNUSU9OX01BUksgPSA2MzsgLyogPyAqL1xuY2xhc3MgRXJyb3JJbnZhbGlkQXJnVHlwZSBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gICAgICAgIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG4gICAgICAgIGxldCBkZXRlcm1pbmVyO1xuICAgICAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBleHBlY3RlZC5pbmRleE9mKCdub3QgJykgPT09IDApIHtcbiAgICAgICAgICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgICAgICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IG5hbWUuaW5kZXhPZignLicpICE9PSAtMSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgICAgICBsZXQgbXNnID0gYFRoZSBcIiR7bmFtZX1cIiAke3R5cGV9ICR7ZGV0ZXJtaW5lcn0gb2YgdHlwZSAke2V4cGVjdGVkfWA7XG4gICAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gO1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRVJSX0lOVkFMSURfQVJHX1RZUEUnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KHBhdGhPYmplY3QsIG5hbWUpIHtcbiAgICBpZiAocGF0aE9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2YgcGF0aE9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW52YWxpZEFyZ1R5cGUobmFtZSwgJ09iamVjdCcsIHBhdGhPYmplY3QpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW52YWxpZEFyZ1R5cGUobmFtZSwgJ3N0cmluZycsIHZhbHVlKTtcbiAgICB9XG59XG5jb25zdCBwbGF0Zm9ybUlzV2luMzIgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5mdW5jdGlvbiBpc1BhdGhTZXBhcmF0b3IoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0ggfHwgY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSDtcbn1cbmZ1bmN0aW9uIGlzUG9zaXhQYXRoU2VwYXJhdG9yKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xufVxuZnVuY3Rpb24gaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSB7XG4gICAgcmV0dXJuIChjb2RlID49IENIQVJfVVBQRVJDQVNFX0EgJiYgY29kZSA8PSBDSEFSX1VQUEVSQ0FTRV9aKSB8fFxuICAgICAgICAoY29kZSA+PSBDSEFSX0xPV0VSQ0FTRV9BICYmIGNvZGUgPD0gQ0hBUl9MT1dFUkNBU0VfWik7XG59XG4vLyBSZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggd2l0aCBkaXJlY3RvcnkgbmFtZXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZyhwYXRoLCBhbGxvd0Fib3ZlUm9vdCwgc2VwYXJhdG9yLCBpc1BhdGhTZXBhcmF0b3IpIHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgbGV0IGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICBsZXQgbGFzdFNsYXNoID0gLTE7XG4gICAgbGV0IGRvdHMgPSAwO1xuICAgIGxldCBjb2RlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpIDwgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSBDSEFSX0ZPUldBUkRfU0xBU0g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xuICAgICAgICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIE5PT1BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvdHMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA8IDIgfHwgbGFzdFNlZ21lbnRMZW5ndGggIT09IDIgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDEpICE9PSBDSEFSX0RPVCB8fFxuICAgICAgICAgICAgICAgICAgICByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IENIQVJfRE9UKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFNsYXNoSW5kZXggPSByZXMubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuc2xpY2UoMCwgbGFzdFNsYXNoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSByZXMubGVuZ3RoID4gMCA/IGAke3NlcGFyYXRvcn0uLmAgOiAnLi4nO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9JHtwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IGkgLSBsYXN0U2xhc2ggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGUgPT09IENIQVJfRE9UICYmIGRvdHMgIT09IC0xKSB7XG4gICAgICAgICAgICArK2RvdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb3RzID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGZvcm1hdEV4dChleHQpIHtcbiAgICByZXR1cm4gZXh0ID8gYCR7ZXh0WzBdID09PSAnLicgPyAnJyA6ICcuJ30ke2V4dH1gIDogJyc7XG59XG5mdW5jdGlvbiBfZm9ybWF0KHNlcCwgcGF0aE9iamVjdCkge1xuICAgIHZhbGlkYXRlT2JqZWN0KHBhdGhPYmplY3QsICdwYXRoT2JqZWN0Jyk7XG4gICAgY29uc3QgZGlyID0gcGF0aE9iamVjdC5kaXIgfHwgcGF0aE9iamVjdC5yb290O1xuICAgIGNvbnN0IGJhc2UgPSBwYXRoT2JqZWN0LmJhc2UgfHxcbiAgICAgICAgYCR7cGF0aE9iamVjdC5uYW1lIHx8ICcnfSR7Zm9ybWF0RXh0KHBhdGhPYmplY3QuZXh0KX1gO1xuICAgIGlmICghZGlyKSB7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICByZXR1cm4gZGlyID09PSBwYXRoT2JqZWN0LnJvb3QgPyBgJHtkaXJ9JHtiYXNlfWAgOiBgJHtkaXJ9JHtzZXB9JHtiYXNlfWA7XG59XG5leHBvcnQgY29uc3Qgd2luMzIgPSB7XG4gICAgLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuICAgIHJlc29sdmUoLi4ucGF0aFNlZ21lbnRzKSB7XG4gICAgICAgIGxldCByZXNvbHZlZERldmljZSA9ICcnO1xuICAgICAgICBsZXQgcmVzb2x2ZWRUYWlsID0gJyc7XG4gICAgICAgIGxldCByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRoU2VnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMTsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcGF0aDtcbiAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aFNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsIGBwYXRoc1ske2l9XWApO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgZW1wdHkgZW50cmllc1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXNvbHZlZERldmljZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgaGFzIHRoZSBjb25jZXB0IG9mIGRyaXZlLXNwZWNpZmljIGN1cnJlbnQgd29ya2luZ1xuICAgICAgICAgICAgICAgIC8vIGRpcmVjdG9yaWVzLiBJZiB3ZSd2ZSByZXNvbHZlZCBhIGRyaXZlIGxldHRlciBidXQgbm90IHlldCBhblxuICAgICAgICAgICAgICAgIC8vIGFic29sdXRlIHBhdGgsIGdldCBjd2QgZm9yIHRoYXQgZHJpdmUsIG9yIHRoZSBwcm9jZXNzIGN3ZCBpZlxuICAgICAgICAgICAgICAgIC8vIHRoZSBkcml2ZSBjd2QgaXMgbm90IGF2YWlsYWJsZS4gV2UncmUgc3VyZSB0aGUgZGV2aWNlIGlzIG5vdFxuICAgICAgICAgICAgICAgIC8vIGEgVU5DIHBhdGggYXQgdGhpcyBwb2ludHMsIGJlY2F1c2UgVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGUuXG4gICAgICAgICAgICAgICAgcGF0aCA9IHByb2Nlc3MuZW52W2A9JHtyZXNvbHZlZERldmljZX1gXSB8fCBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IGEgY3dkIHdhcyBmb3VuZCBhbmQgdGhhdCBpdCBhY3R1YWxseSBwb2ludHNcbiAgICAgICAgICAgICAgICAvLyB0byBvdXIgZHJpdmUuIElmIG5vdCwgZGVmYXVsdCB0byB0aGUgZHJpdmUncyByb290LlxuICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhdGguc2xpY2UoMCwgMikudG9Mb3dlckNhc2UoKSAhPT0gcmVzb2x2ZWREZXZpY2UudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jaGFyQ29kZUF0KDIpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gYCR7cmVzb2x2ZWREZXZpY2V9XFxcXGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcm9vdEVuZCA9IDA7XG4gICAgICAgICAgICBsZXQgZGV2aWNlID0gJyc7XG4gICAgICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIHJvb3RcbiAgICAgICAgICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgcGF0aCBzZXBhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XG4gICAgICAgICAgICAgICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIGEgc2VwYXJhdG9yLCB3ZSBrbm93IHdlIGF0IGxlYXN0IGhhdmUgYW5cbiAgICAgICAgICAgICAgICAvLyBhYnNvbHV0ZSBwYXRoIG9mIHNvbWUga2luZCAoVU5DIG9yIG90aGVyd2lzZSlcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nXG4gICAgICAgICAgICAgICAgICAgIGxldCBqID0gMjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXRoLnNsaWNlKGxhc3QsIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBsZW4gfHwgaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlID0gYFxcXFxcXFxcJHtmaXJzdFBhcnR9XFxcXCR7cGF0aC5zbGljZShsYXN0LCBqKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RW5kID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzV2luZG93c0RldmljZVJvb3QoY29kZSkgJiZcbiAgICAgICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04pIHtcbiAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSBkZXZpY2Ugcm9vdFxuICAgICAgICAgICAgICAgIGRldmljZSA9IHBhdGguc2xpY2UoMCwgMik7XG4gICAgICAgICAgICAgICAgcm9vdEVuZCA9IDI7XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDIgJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJlYXQgc2VwYXJhdG9yIGZvbGxvd2luZyBkcml2ZSBuYW1lIGFzIGFuIGFic29sdXRlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByb290RW5kID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGV2aWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWREZXZpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlLnRvTG93ZXJDYXNlKCkgIT09IHJlc29sdmVkRGV2aWNlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcGF0aCBwb2ludHMgdG8gYW5vdGhlciBkZXZpY2Ugc28gaXQgaXMgbm90IGFwcGxpY2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZERldmljZSA9IGRldmljZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZERldmljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkVGFpbCA9IGAke3BhdGguc2xpY2Uocm9vdEVuZCl9XFxcXCR7cmVzb2x2ZWRUYWlsfWA7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGlzQWJzb2x1dGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUgJiYgcmVzb2x2ZWREZXZpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsXG4gICAgICAgIC8vIGJ1dCBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKVxuICAgICAgICAvLyBmYWlscylcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSB0YWlsIHBhdGhcbiAgICAgICAgcmVzb2x2ZWRUYWlsID0gbm9ybWFsaXplU3RyaW5nKHJlc29sdmVkVGFpbCwgIXJlc29sdmVkQWJzb2x1dGUsICdcXFxcJywgaXNQYXRoU2VwYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkQWJzb2x1dGUgP1xuICAgICAgICAgICAgYCR7cmVzb2x2ZWREZXZpY2V9XFxcXCR7cmVzb2x2ZWRUYWlsfWAgOlxuICAgICAgICAgICAgYCR7cmVzb2x2ZWREZXZpY2V9JHtyZXNvbHZlZFRhaWx9YCB8fCAnLic7XG4gICAgfSxcbiAgICBub3JtYWxpemUocGF0aCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm9vdEVuZCA9IDA7XG4gICAgICAgIGxldCBkZXZpY2U7XG4gICAgICAgIGxldCBpc0Fic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIHJvb3RcbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBzaW5nbGUgY2hhciwgZXhpdCBlYXJseSB0byBhdm9pZFxuICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICAgICAgcmV0dXJuIGlzUG9zaXhQYXRoU2VwYXJhdG9yKGNvZGUpID8gJ1xcXFwnIDogcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICAvLyBQb3NzaWJsZSBVTkMgcm9vdFxuICAgICAgICAgICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIGEgc2VwYXJhdG9yLCB3ZSBrbm93IHdlIGF0IGxlYXN0IGhhdmUgYW4gYWJzb2x1dGVcbiAgICAgICAgICAgIC8vIHBhdGggb2Ygc29tZSBraW5kIChVTkMgb3Igb3RoZXJ3aXNlKVxuICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgxKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIGRvdWJsZSBwYXRoIHNlcGFyYXRvciBhdCBiZWdpbm5pbmdcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDI7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXRoLnNsaWNlKGxhc3QsIGopO1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgVU5DIHJvb3Qgc2luY2UgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBub3RoaW5nIGxlZnQgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgXFxcXFxcXFwke2ZpcnN0UGFydH1cXFxcJHtwYXRoLnNsaWNlKGxhc3QpfVxcXFxgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgd2l0aCBsZWZ0b3ZlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2UgPSBgXFxcXFxcXFwke2ZpcnN0UGFydH1cXFxcJHtwYXRoLnNsaWNlKGxhc3QsIGopfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb290RW5kID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcbiAgICAgICAgICAgIGRldmljZSA9IHBhdGguc2xpY2UoMCwgMik7XG4gICAgICAgICAgICByb290RW5kID0gMjtcbiAgICAgICAgICAgIGlmIChsZW4gPiAyICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgc2VwYXJhdG9yIGZvbGxvd2luZyBkcml2ZSBuYW1lIGFzIGFuIGFic29sdXRlIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByb290RW5kID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFpbCA9IHJvb3RFbmQgPCBsZW4gP1xuICAgICAgICAgICAgbm9ybWFsaXplU3RyaW5nKHBhdGguc2xpY2Uocm9vdEVuZCksICFpc0Fic29sdXRlLCAnXFxcXCcsIGlzUGF0aFNlcGFyYXRvcikgOlxuICAgICAgICAgICAgJyc7XG4gICAgICAgIGlmICh0YWlsLmxlbmd0aCA9PT0gMCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgdGFpbCA9ICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFpbC5sZW5ndGggPiAwICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQobGVuIC0gMSkpKSB7XG4gICAgICAgICAgICB0YWlsICs9ICdcXFxcJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV2aWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Fic29sdXRlID8gYFxcXFwke3RhaWx9YCA6IHRhaWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQWJzb2x1dGUgPyBgJHtkZXZpY2V9XFxcXCR7dGFpbH1gIDogYCR7ZGV2aWNlfSR7dGFpbH1gO1xuICAgIH0sXG4gICAgaXNBYnNvbHV0ZShwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICAgICAgcmV0dXJuIGlzUGF0aFNlcGFyYXRvcihjb2RlKSB8fFxuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcbiAgICAgICAgICAgIChsZW4gPiAyICYmXG4gICAgICAgICAgICAgICAgaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSAmJlxuICAgICAgICAgICAgICAgIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTiAmJlxuICAgICAgICAgICAgICAgIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpKTtcbiAgICB9LFxuICAgIGpvaW4oLi4ucGF0aHMpIHtcbiAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgam9pbmVkO1xuICAgICAgICBsZXQgZmlyc3RQYXJ0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBwYXRoc1tpXTtcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKGFyZywgJ3BhdGgnKTtcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBqb2luZWQgPSBmaXJzdFBhcnQgPSBhcmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqb2luZWQgKz0gYFxcXFwke2FyZ31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGpvaW5lZCBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCB0d28gc2xhc2hlcywgYmVjYXVzZVxuICAgICAgICAvLyBub3JtYWxpemUoKSB3aWxsIG1pc3Rha2UgaXQgZm9yIGEgVU5DIHBhdGggdGhlbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBzdGVwIGlzIHNraXBwZWQgd2hlbiBpdCBpcyB2ZXJ5IGNsZWFyIHRoYXQgdGhlIHVzZXIgYWN0dWFsbHlcbiAgICAgICAgLy8gaW50ZW5kZWQgdG8gcG9pbnQgYXQgYSBVTkMgcGF0aC4gVGhpcyBpcyBhc3N1bWVkIHdoZW4gdGhlIGZpcnN0XG4gICAgICAgIC8vIG5vbi1lbXB0eSBzdHJpbmcgYXJndW1lbnRzIHN0YXJ0cyB3aXRoIGV4YWN0bHkgdHdvIHNsYXNoZXMgZm9sbG93ZWQgYnlcbiAgICAgICAgLy8gYXQgbGVhc3Qgb25lIG1vcmUgbm9uLXNsYXNoIGNoYXJhY3Rlci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZSB0aGF0IGZvciBub3JtYWxpemUoKSB0byB0cmVhdCBhIHBhdGggYXMgYSBVTkMgcGF0aCBpdCBuZWVkcyB0b1xuICAgICAgICAvLyBoYXZlIGF0IGxlYXN0IDIgY29tcG9uZW50cywgc28gd2UgZG9uJ3QgZmlsdGVyIGZvciB0aGF0IGhlcmUuXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgdXNlciBjYW4gdXNlIGpvaW4gdG8gY29uc3RydWN0IFVOQyBwYXRocyBmcm9tXG4gICAgICAgIC8vIGEgc2VydmVyIG5hbWUgYW5kIGEgc2hhcmUgbmFtZTsgZm9yIGV4YW1wbGU6XG4gICAgICAgIC8vICAgcGF0aC5qb2luKCcvL3NlcnZlcicsICdzaGFyZScpIC0+ICdcXFxcXFxcXHNlcnZlclxcXFxzaGFyZVxcXFwnKVxuICAgICAgICBsZXQgbmVlZHNSZXBsYWNlID0gdHJ1ZTtcbiAgICAgICAgbGV0IHNsYXNoQ291bnQgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGZpcnN0UGFydCA9PT0gJ3N0cmluZycgJiYgaXNQYXRoU2VwYXJhdG9yKGZpcnN0UGFydC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgKytzbGFzaENvdW50O1xuICAgICAgICAgICAgY29uc3QgZmlyc3RMZW4gPSBmaXJzdFBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGZpcnN0TGVuID4gMSAmJiBpc1BhdGhTZXBhcmF0b3IoZmlyc3RQYXJ0LmNoYXJDb2RlQXQoMSkpKSB7XG4gICAgICAgICAgICAgICAgKytzbGFzaENvdW50O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdExlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihmaXJzdFBhcnQuY2hhckNvZGVBdCgyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrc2xhc2hDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcGF0aCBpbiB0aGUgZmlyc3QgcGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNSZXBsYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzUmVwbGFjZSkge1xuICAgICAgICAgICAgLy8gRmluZCBhbnkgbW9yZSBjb25zZWN1dGl2ZSBzbGFzaGVzIHdlIG5lZWQgdG8gcmVwbGFjZVxuICAgICAgICAgICAgd2hpbGUgKHNsYXNoQ291bnQgPCBqb2luZWQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgaXNQYXRoU2VwYXJhdG9yKGpvaW5lZC5jaGFyQ29kZUF0KHNsYXNoQ291bnQpKSkge1xuICAgICAgICAgICAgICAgIHNsYXNoQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHNsYXNoZXMgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAoc2xhc2hDb3VudCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgam9pbmVkID0gYFxcXFwke2pvaW5lZC5zbGljZShzbGFzaENvdW50KX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aW4zMi5ub3JtYWxpemUoam9pbmVkKTtcbiAgICB9LFxuICAgIC8vIEl0IHdpbGwgc29sdmUgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSBgZnJvbWAgdG8gYHRvYCwgZm9yIGluc3RhbmNlOlxuICAgIC8vICBmcm9tID0gJ0M6XFxcXG9yYW5kZWFcXFxcdGVzdFxcXFxhYWEnXG4gICAgLy8gIHRvID0gJ0M6XFxcXG9yYW5kZWFcXFxcaW1wbFxcXFxiYmInXG4gICAgLy8gVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlOiAnLi5cXFxcLi5cXFxcaW1wbFxcXFxiYmInXG4gICAgcmVsYXRpdmUoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcoZnJvbSwgJ2Zyb20nKTtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcodG8sICd0bycpO1xuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tT3JpZyA9IHdpbjMyLnJlc29sdmUoZnJvbSk7XG4gICAgICAgIGNvbnN0IHRvT3JpZyA9IHdpbjMyLnJlc29sdmUodG8pO1xuICAgICAgICBpZiAoZnJvbU9yaWcgPT09IHRvT3JpZykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGZyb20gPSBmcm9tT3JpZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0byA9IHRvT3JpZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgICAgIGxldCBmcm9tU3RhcnQgPSAwO1xuICAgICAgICB3aGlsZSAoZnJvbVN0YXJ0IDwgZnJvbS5sZW5ndGggJiZcbiAgICAgICAgICAgIGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICBmcm9tU3RhcnQrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmltIHRyYWlsaW5nIGJhY2tzbGFzaGVzIChhcHBsaWNhYmxlIHRvIFVOQyBwYXRocyBvbmx5KVxuICAgICAgICBsZXQgZnJvbUVuZCA9IGZyb20ubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoZnJvbUVuZCAtIDEgPiBmcm9tU3RhcnQgJiZcbiAgICAgICAgICAgIGZyb20uY2hhckNvZGVBdChmcm9tRW5kIC0gMSkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgIGZyb21FbmQtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tTGVuID0gZnJvbUVuZCAtIGZyb21TdGFydDtcbiAgICAgICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlc1xuICAgICAgICBsZXQgdG9TdGFydCA9IDA7XG4gICAgICAgIHdoaWxlICh0b1N0YXJ0IDwgdG8ubGVuZ3RoICYmXG4gICAgICAgICAgICB0by5jaGFyQ29kZUF0KHRvU3RhcnQpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICB0b1N0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpbSB0cmFpbGluZyBiYWNrc2xhc2hlcyAoYXBwbGljYWJsZSB0byBVTkMgcGF0aHMgb25seSlcbiAgICAgICAgbGV0IHRvRW5kID0gdG8ubGVuZ3RoO1xuICAgICAgICB3aGlsZSAodG9FbmQgLSAxID4gdG9TdGFydCAmJlxuICAgICAgICAgICAgdG8uY2hhckNvZGVBdCh0b0VuZCAtIDEpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICB0b0VuZC0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvTGVuID0gdG9FbmQgLSB0b1N0YXJ0O1xuICAgICAgICAvLyBDb21wYXJlIHBhdGhzIHRvIGZpbmQgdGhlIGxvbmdlc3QgY29tbW9uIHBhdGggZnJvbSByb290XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGZyb21MZW4gPCB0b0xlbiA/IGZyb21MZW4gOiB0b0xlbjtcbiAgICAgICAgbGV0IGxhc3RDb21tb25TZXAgPSAtMTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tQ29kZSA9IGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKTtcbiAgICAgICAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21Db2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgZm91bmQgYSBtaXNtYXRjaCBiZWZvcmUgdGhlIGZpcnN0IGNvbW1vbiBwYXRoIHNlcGFyYXRvciB3YXMgc2Vlbiwgc29cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBvcmlnaW5hbCBgdG9gLlxuICAgICAgICBpZiAoaSAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobGFzdENvbW1vblNlcCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9PcmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgdG9gLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXFxcZm9vXFxcXGJhcic7IHRvPSdDOlxcXFxmb29cXFxcYmFyXFxcXGJheidcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvT3JpZy5zbGljZSh0b1N0YXJ0ICsgaSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGRldmljZSByb290LlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXFxcJzsgdG89J0M6XFxcXGZvbydcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvT3JpZy5zbGljZSh0b1N0YXJ0ICsgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYGZyb21gLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXFxcZm9vXFxcXGJhcic7IHRvPSdDOlxcXFxmb28nXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGRldmljZSByb290LlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXFxcZm9vXFxcXGJhcic7IHRvPSdDOlxcXFwnXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0Q29tbW9uU2VwID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIHJlbGF0aXZlIHBhdGggYmFzZWQgb24gdGhlIHBhdGggZGlmZmVyZW5jZSBiZXR3ZWVuIGB0b2AgYW5kXG4gICAgICAgIC8vIGBmcm9tYFxuICAgICAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIG91dCArPSBvdXQubGVuZ3RoID09PSAwID8gJy4uJyA6ICdcXFxcLi4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvU3RhcnQgKz0gbGFzdENvbW1vblNlcDtcbiAgICAgICAgLy8gTGFzdGx5LCBhcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGRlc3RpbmF0aW9uIChgdG9gKSBwYXRoIHRoYXQgY29tZXMgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIGNvbW1vbiBwYXRoIHBhcnRzXG4gICAgICAgIGlmIChvdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke291dH0ke3RvT3JpZy5zbGljZSh0b1N0YXJ0LCB0b0VuZCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9PcmlnLmNoYXJDb2RlQXQodG9TdGFydCkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICsrdG9TdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9PcmlnLnNsaWNlKHRvU3RhcnQsIHRvRW5kKTtcbiAgICB9LFxuICAgIHRvTmFtZXNwYWNlZFBhdGgocGF0aCkge1xuICAgICAgICAvLyBOb3RlOiB0aGlzIHdpbGwgKnByb2JhYmx5KiB0aHJvdyBzb21ld2hlcmUuXG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycgfHwgcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IHdpbjMyLnJlc29sdmUocGF0aCk7XG4gICAgICAgIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlZFBhdGguY2hhckNvZGVBdCgwKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSByZXNvbHZlZFBhdGguY2hhckNvZGVBdCgyKTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gQ0hBUl9RVUVTVElPTl9NQVJLICYmIGNvZGUgIT09IENIQVJfRE9UKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgbm9uLWxvbmcgVU5DIHJvb3QsIGNvbnZlcnQgdGhlIHBhdGggdG8gYSBsb25nIFVOQyBwYXRoXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgXFxcXFxcXFw/XFxcXFVOQ1xcXFwke3Jlc29sdmVkUGF0aC5zbGljZSgyKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDApKSAmJlxuICAgICAgICAgICAgcmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04gJiZcbiAgICAgICAgICAgIHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDIpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAvLyBNYXRjaGVkIGRldmljZSByb290LCBjb252ZXJ0IHRoZSBwYXRoIHRvIGEgbG9uZyBVTkMgcGF0aFxuICAgICAgICAgICAgcmV0dXJuIGBcXFxcXFxcXD9cXFxcJHtyZXNvbHZlZFBhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuICAgIGRpcm5hbWUocGF0aCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm9vdEVuZCA9IC0xO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBwYXRoIHNlcGFyYXRvciwgZXhpdCBlYXJseSB0byBhdm9pZFxuICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29yayBvciBhIGRvdC5cbiAgICAgICAgICAgIHJldHVybiBpc1BhdGhTZXBhcmF0b3IoY29kZSkgPyBwYXRoIDogJy4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIHJvb3RcbiAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xuICAgICAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcbiAgICAgICAgICAgIHJvb3RFbmQgPSBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nXG4gICAgICAgICAgICAgICAgbGV0IGogPSAyO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBwYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCB3aXRoIGxlZnRvdmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9mZnNldCBieSAxIHRvIGluY2x1ZGUgdGhlIHNlcGFyYXRvciBhZnRlciB0aGUgVU5DIHJvb3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdCBpdCBhcyBhIFwibm9ybWFsIHJvb3RcIiBvbiB0b3Agb2YgYSAoVU5DKSByb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IG9mZnNldCA9IGogKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xuICAgICAgICAgICAgcm9vdEVuZCA9IGxlbiA+IDIgJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgyKSkgPyAzIDogMjtcbiAgICAgICAgICAgIG9mZnNldCA9IHJvb3RFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuZCA9IC0xO1xuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbiAtIDE7IGkgPj0gb2Zmc2V0OyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChyb290RW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmQgPSByb290RW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG4gICAgfSxcbiAgICBiYXNlbmFtZShwYXRoLCBzdWZmaXgpIHtcbiAgICAgICAgaWYgKHN1ZmZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhzdWZmaXgsICdzdWZmaXgnKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gLTE7XG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgZHJpdmUgbGV0dGVyIHByZWZpeCBzbyBhcyBub3QgdG8gbWlzdGFrZSB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIHBhdGggc2VwYXJhdG9yIGFzIGFuIGV4dHJhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoIHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGRpc3JlZ2FyZGVkXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICAgICBpc1dpbmRvd3NEZXZpY2VSb290KHBhdGguY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgICAgICAgIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xuICAgICAgICAgICAgc3RhcnQgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWZmaXggIT09IHVuZGVmaW5lZCAmJiBzdWZmaXgubGVuZ3RoID4gMCAmJiBzdWZmaXgubGVuZ3RoIDw9IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc3VmZml4ID09PSBwYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV4dElkeCA9IHN1ZmZpeC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IGZpcnN0Tm9uU2xhc2hFbmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCByZW1lbWJlciB0aGlzIGluZGV4IGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgaXQgaWYgdGhlIGV4dGVuc2lvbiBlbmRzIHVwIG5vdCBtYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGV4cGxpY2l0IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IHN1ZmZpeC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIGV4dGVuc2lvbiwgc28gbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5zaW9uIGRvZXMgbm90IG1hdGNoLCBzbyBvdXIgcmVzdWx0IGlzIHRoZSBlbnRpcmUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAgICAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9LFxuICAgIGV4dG5hbWUocGF0aCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgc3RhcnREb3QgPSAtMTtcbiAgICAgICAgbGV0IHN0YXJ0UGFydCA9IDA7XG4gICAgICAgIGxldCBlbmQgPSAtMTtcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAgICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICAgICAgbGV0IHByZURvdFN0YXRlID0gMDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgZHJpdmUgbGV0dGVyIHByZWZpeCBzbyBhcyBub3QgdG8gbWlzdGFrZSB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIHBhdGggc2VwYXJhdG9yIGFzIGFuIGV4dHJhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoIHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGRpc3JlZ2FyZGVkXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04gJiZcbiAgICAgICAgICAgIGlzV2luZG93c0RldmljZVJvb3QocGF0aC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydFBhcnQgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0RPVCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fFxuICAgICAgICAgICAgZW5kID09PSAtMSB8fFxuICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICAgICAgICAocHJlRG90U3RhdGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gZW5kIC0gMSAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH0sXG4gICAgZm9ybWF0OiBfZm9ybWF0LmJpbmQobnVsbCwgJ1xcXFwnKSxcbiAgICBwYXJzZShwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHsgcm9vdDogJycsIGRpcjogJycsIGJhc2U6ICcnLCBleHQ6ICcnLCBuYW1lOiAnJyB9O1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIGxldCByb290RW5kID0gMDtcbiAgICAgICAgbGV0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIHBhdGggc2VwYXJhdG9yLCBleGl0IGVhcmx5IHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICAgICAgICAgIHJldC5yb290ID0gcmV0LmRpciA9IHBhdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYSByb290XG4gICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XG4gICAgICAgICAgICByb290RW5kID0gMTtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDEpKSkge1xuICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgZG91YmxlIHBhdGggc2VwYXJhdG9yIGF0IGJlZ2lubmluZ1xuICAgICAgICAgICAgICAgIGxldCBqID0gMjtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGo7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCB3aXRoIGxlZnRvdmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSBqICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcbiAgICAgICAgICAgIGlmIChsZW4gPD0gMikge1xuICAgICAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgZHJpdmUgcm9vdCwgZXhpdCBlYXJseSB0byBhdm9pZFxuICAgICAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmtcbiAgICAgICAgICAgICAgICByZXQucm9vdCA9IHJldC5kaXIgPSBwYXRoO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb290RW5kID0gMjtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDIpKSkge1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBkcml2ZSByb290LCBleGl0IGVhcmx5IHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnJvb3QgPSByZXQuZGlyID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm9vdEVuZCA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3RFbmQgPiAwKSB7XG4gICAgICAgICAgICByZXQucm9vdCA9IHBhdGguc2xpY2UoMCwgcm9vdEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0RG90ID0gLTE7XG4gICAgICAgIGxldCBzdGFydFBhcnQgPSByb290RW5kO1xuICAgICAgICBsZXQgZW5kID0gLTE7XG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgICAgICBsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgICAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgICAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xuICAgICAgICAvLyBHZXQgbm9uLWRpciBpbmZvXG4gICAgICAgIGZvciAoOyBpID49IHJvb3RFbmQ7IC0taSkge1xuICAgICAgICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0RPVCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHxcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAgICAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgICAgICAgICAgIChwcmVEb3RTdGF0ZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gZW5kIC0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkpIHtcbiAgICAgICAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBzdGFydERvdCk7XG4gICAgICAgICAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICByZXQuZXh0ID0gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZGlyZWN0b3J5IGlzIHRoZSByb290LCB1c2UgdGhlIGVudGlyZSByb290IGFzIHRoZSBgZGlyYCBpbmNsdWRpbmdcbiAgICAgICAgLy8gdGhlIHRyYWlsaW5nIHNsYXNoIGlmIGFueSAoYEM6XFxhYmNgIC0+IGBDOlxcYCkuIE90aGVyd2lzZSwgc3RyaXAgb3V0IHRoZVxuICAgICAgICAvLyB0cmFpbGluZyBzbGFzaCAoYEM6XFxhYmNcXGRlZmAgLT4gYEM6XFxhYmNgKS5cbiAgICAgICAgaWYgKHN0YXJ0UGFydCA+IDAgJiYgc3RhcnRQYXJ0ICE9PSByb290RW5kKSB7XG4gICAgICAgICAgICByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldC5kaXIgPSByZXQucm9vdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgc2VwOiAnXFxcXCcsXG4gICAgZGVsaW1pdGVyOiAnOycsXG4gICAgd2luMzI6IG51bGwsXG4gICAgcG9zaXg6IG51bGxcbn07XG5jb25zdCBwb3NpeEN3ZCA9ICgoKSA9PiB7XG4gICAgaWYgKHBsYXRmb3JtSXNXaW4zMikge1xuICAgICAgICAvLyBDb252ZXJ0cyBXaW5kb3dzJyBiYWNrc2xhc2ggcGF0aCBzZXBhcmF0b3JzIHRvIFBPU0lYIGZvcndhcmQgc2xhc2hlc1xuICAgICAgICAvLyBhbmQgdHJ1bmNhdGVzIGFueSBkcml2ZSBpbmRpY2F0b3JcbiAgICAgICAgY29uc3QgcmVnZXhwID0gL1xcXFwvZztcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN3ZCA9IHByb2Nlc3MuY3dkKCkucmVwbGFjZShyZWdleHAsICcvJyk7XG4gICAgICAgICAgICByZXR1cm4gY3dkLnNsaWNlKGN3ZC5pbmRleE9mKCcvJykpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBXZSdyZSBhbHJlYWR5IG9uIFBPU0lYLCBubyBuZWVkIGZvciBhbnkgdHJhbnNmb3JtYXRpb25zXG4gICAgcmV0dXJuICgpID0+IHByb2Nlc3MuY3dkKCk7XG59KSgpO1xuZXhwb3J0IGNvbnN0IHBvc2l4ID0ge1xuICAgIC8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbiAgICByZXNvbHZlKC4uLnBhdGhTZWdtZW50cykge1xuICAgICAgICBsZXQgcmVzb2x2ZWRQYXRoID0gJyc7XG4gICAgICAgIGxldCByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRoU2VnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gaSA+PSAwID8gcGF0aFNlZ21lbnRzW2ldIDogcG9zaXhDd2QoKTtcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsIGBwYXRoc1ske2l9XWApO1xuICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSBlbnRyaWVzXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkUGF0aCA9IGAke3BhdGh9LyR7cmVzb2x2ZWRQYXRofWA7XG4gICAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAgICAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgICAgIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZVN0cmluZyhyZXNvbHZlZFBhdGgsICFyZXNvbHZlZEFic29sdXRlLCAnLycsIGlzUG9zaXhQYXRoU2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBgLyR7cmVzb2x2ZWRQYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUGF0aC5sZW5ndGggPiAwID8gcmVzb2x2ZWRQYXRoIDogJy4nO1xuICAgIH0sXG4gICAgbm9ybWFsaXplKHBhdGgpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICAgICAgcGF0aCA9IG5vcm1hbGl6ZVN0cmluZyhwYXRoLCAhaXNBYnNvbHV0ZSwgJy8nLCBpc1Bvc2l4UGF0aFNlcGFyYXRvcik7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYWlsaW5nU2VwYXJhdG9yID8gJy4vJyA6ICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhaWxpbmdTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHBhdGggKz0gJy8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0Fic29sdXRlID8gYC8ke3BhdGh9YCA6IHBhdGg7XG4gICAgfSxcbiAgICBpc0Fic29sdXRlKHBhdGgpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcbiAgICB9LFxuICAgIGpvaW4oLi4ucGF0aHMpIHtcbiAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgam9pbmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBwYXRoc1tpXTtcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKGFyZywgJ3BhdGgnKTtcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBqb2luZWQgPSBhcmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqb2luZWQgKz0gYC8ke2FyZ31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2l4Lm5vcm1hbGl6ZShqb2luZWQpO1xuICAgIH0sXG4gICAgcmVsYXRpdmUoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcoZnJvbSwgJ2Zyb20nKTtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcodG8sICd0bycpO1xuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmltIGxlYWRpbmcgZm9yd2FyZCBzbGFzaGVzLlxuICAgICAgICBmcm9tID0gcG9zaXgucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgdG8gPSBwb3NpeC5yZXNvbHZlKHRvKTtcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJvbVN0YXJ0ID0gMTtcbiAgICAgICAgY29uc3QgZnJvbUVuZCA9IGZyb20ubGVuZ3RoO1xuICAgICAgICBjb25zdCBmcm9tTGVuID0gZnJvbUVuZCAtIGZyb21TdGFydDtcbiAgICAgICAgY29uc3QgdG9TdGFydCA9IDE7XG4gICAgICAgIGNvbnN0IHRvTGVuID0gdG8ubGVuZ3RoIC0gdG9TdGFydDtcbiAgICAgICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdFxuICAgICAgICBjb25zdCBsZW5ndGggPSAoZnJvbUxlbiA8IHRvTGVuID8gZnJvbUxlbiA6IHRvTGVuKTtcbiAgICAgICAgbGV0IGxhc3RDb21tb25TZXAgPSAtMTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tQ29kZSA9IGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKTtcbiAgICAgICAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21Db2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodG9MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYHRvYC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyJzsgdG89Jy9mb28vYmFyL2JheidcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgcm9vdFxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nLyc7IHRvPScvZm9vJ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhci9iYXonOyB0bz0nL2Zvby9iYXInXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIHJvb3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhcic7IHRvPScvJ1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBiYXNlZCBvbiB0aGUgcGF0aCBkaWZmZXJlbmNlIGJldHdlZW4gYHRvYFxuICAgICAgICAvLyBhbmQgYGZyb21gLlxuICAgICAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IG91dC5sZW5ndGggPT09IDAgPyAnLi4nIDogJy8uLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGFzdGx5LCBhcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGRlc3RpbmF0aW9uIChgdG9gKSBwYXRoIHRoYXQgY29tZXMgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIGNvbW1vbiBwYXRoIHBhcnRzLlxuICAgICAgICByZXR1cm4gYCR7b3V0fSR7dG8uc2xpY2UodG9TdGFydCArIGxhc3RDb21tb25TZXApfWA7XG4gICAgfSxcbiAgICB0b05hbWVzcGFjZWRQYXRoKHBhdGgpIHtcbiAgICAgICAgLy8gTm9uLW9wIG9uIHBvc2l4IHN5c3RlbXNcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcbiAgICBkaXJuYW1lKHBhdGgpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1Jvb3QgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuICcvLyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbiAgICB9LFxuICAgIGJhc2VuYW1lKHBhdGgsIHN1ZmZpeCkge1xuICAgICAgICBpZiAoc3VmZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKHN1ZmZpeCwgJ2V4dCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGxldCBlbmQgPSAtMTtcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAoc3VmZml4ICE9PSB1bmRlZmluZWQgJiYgc3VmZml4Lmxlbmd0aCA+IDAgJiYgc3VmZml4Lmxlbmd0aCA8PSBwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHN1ZmZpeCA9PT0gcGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBleHRJZHggPSBzdWZmaXgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCBmaXJzdE5vblNsYXNoRW5kID0gLTE7XG4gICAgICAgICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCByZW1lbWJlciB0aGlzIGluZGV4IGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgaXQgaWYgdGhlIGV4dGVuc2lvbiBlbmRzIHVwIG5vdCBtYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGV4cGxpY2l0IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IHN1ZmZpeC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIGV4dGVuc2lvbiwgc28gbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5zaW9uIGRvZXMgbm90IG1hdGNoLCBzbyBvdXIgcmVzdWx0IGlzIHRoZSBlbnRpcmUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgICAgICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH0sXG4gICAgZXh0bmFtZShwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGxldCBzdGFydERvdCA9IC0xO1xuICAgICAgICBsZXQgc3RhcnRQYXJ0ID0gMDtcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgICAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgICAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0RPVCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fFxuICAgICAgICAgICAgZW5kID09PSAtMSB8fFxuICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICAgICAgICAocHJlRG90U3RhdGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gZW5kIC0gMSAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH0sXG4gICAgZm9ybWF0OiBfZm9ybWF0LmJpbmQobnVsbCwgJy8nKSxcbiAgICBwYXJzZShwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHsgcm9vdDogJycsIGRpcjogJycsIGJhc2U6ICcnLCBleHQ6ICcnLCBuYW1lOiAnJyB9O1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xuICAgICAgICBsZXQgc3RhcnQ7XG4gICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICByZXQucm9vdCA9ICcvJztcbiAgICAgICAgICAgIHN0YXJ0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnREb3QgPSAtMTtcbiAgICAgICAgbGV0IHN0YXJ0UGFydCA9IDA7XG4gICAgICAgIGxldCBlbmQgPSAtMTtcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgICAgIGxldCBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gICAgICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gICAgICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgICAgIC8vIEdldCBub24tZGlyIGluZm9cbiAgICAgICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0RPVCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUgPyAxIDogc3RhcnRQYXJ0O1xuICAgICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fFxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICAgICAgICAgICAgKHByZURvdFN0YXRlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSkge1xuICAgICAgICAgICAgICAgIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0LCBzdGFydERvdCk7XG4gICAgICAgICAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIHJldC5leHQgPSBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFBhcnQgPiAwKSB7XG4gICAgICAgICAgICByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICByZXQuZGlyID0gJy8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICBzZXA6ICcvJyxcbiAgICBkZWxpbWl0ZXI6ICc6JyxcbiAgICB3aW4zMjogbnVsbCxcbiAgICBwb3NpeDogbnVsbFxufTtcbnBvc2l4LndpbjMyID0gd2luMzIud2luMzIgPSB3aW4zMjtcbnBvc2l4LnBvc2l4ID0gd2luMzIucG9zaXggPSBwb3NpeDtcbmV4cG9ydCBjb25zdCBub3JtYWxpemUgPSAocGxhdGZvcm1Jc1dpbjMyID8gd2luMzIubm9ybWFsaXplIDogcG9zaXgubm9ybWFsaXplKTtcbmV4cG9ydCBjb25zdCBqb2luID0gKHBsYXRmb3JtSXNXaW4zMiA/IHdpbjMyLmpvaW4gOiBwb3NpeC5qb2luKTtcbmV4cG9ydCBjb25zdCByZXNvbHZlID0gKHBsYXRmb3JtSXNXaW4zMiA/IHdpbjMyLnJlc29sdmUgOiBwb3NpeC5yZXNvbHZlKTtcbmV4cG9ydCBjb25zdCByZWxhdGl2ZSA9IChwbGF0Zm9ybUlzV2luMzIgPyB3aW4zMi5yZWxhdGl2ZSA6IHBvc2l4LnJlbGF0aXZlKTtcbmV4cG9ydCBjb25zdCBkaXJuYW1lID0gKHBsYXRmb3JtSXNXaW4zMiA/IHdpbjMyLmRpcm5hbWUgOiBwb3NpeC5kaXJuYW1lKTtcbmV4cG9ydCBjb25zdCBiYXNlbmFtZSA9IChwbGF0Zm9ybUlzV2luMzIgPyB3aW4zMi5iYXNlbmFtZSA6IHBvc2l4LmJhc2VuYW1lKTtcbmV4cG9ydCBjb25zdCBleHRuYW1lID0gKHBsYXRmb3JtSXNXaW4zMiA/IHdpbjMyLmV4dG5hbWUgOiBwb3NpeC5leHRuYW1lKTtcbmV4cG9ydCBjb25zdCBzZXAgPSAocGxhdGZvcm1Jc1dpbjMyID8gd2luMzIuc2VwIDogcG9zaXguc2VwKTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgbmxzIGZyb20gJy4uLy4uL25scy5qcyc7XG5leHBvcnQgY29uc3QgTEFOR1VBR0VfREVGQVVMVCA9ICdlbic7XG5sZXQgX2lzV2luZG93cyA9IGZhbHNlO1xubGV0IF9pc01hY2ludG9zaCA9IGZhbHNlO1xubGV0IF9pc0xpbnV4ID0gZmFsc2U7XG5sZXQgX2lzTGludXhTbmFwID0gZmFsc2U7XG5sZXQgX2lzTmF0aXZlID0gZmFsc2U7XG5sZXQgX2lzV2ViID0gZmFsc2U7XG5sZXQgX2lzRWxlY3Ryb24gPSBmYWxzZTtcbmxldCBfaXNJT1MgPSBmYWxzZTtcbmxldCBfaXNDSSA9IGZhbHNlO1xubGV0IF9pc01vYmlsZSA9IGZhbHNlO1xubGV0IF9sb2NhbGUgPSB1bmRlZmluZWQ7XG5sZXQgX2xhbmd1YWdlID0gTEFOR1VBR0VfREVGQVVMVDtcbmxldCBfcGxhdGZvcm1Mb2NhbGUgPSBMQU5HVUFHRV9ERUZBVUxUO1xubGV0IF90cmFuc2xhdGlvbnNDb25maWdGaWxlID0gdW5kZWZpbmVkO1xubGV0IF91c2VyQWdlbnQgPSB1bmRlZmluZWQ7XG5jb25zdCAkZ2xvYmFsVGhpcyA9IGdsb2JhbFRoaXM7XG5sZXQgbm9kZVByb2Nlc3MgPSB1bmRlZmluZWQ7XG5pZiAodHlwZW9mICRnbG9iYWxUaGlzLnZzY29kZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mICRnbG9iYWxUaGlzLnZzY29kZS5wcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5hdGl2ZSBlbnZpcm9ubWVudCAoc2FuZGJveGVkKVxuICAgIG5vZGVQcm9jZXNzID0gJGdsb2JhbFRoaXMudnNjb2RlLnByb2Nlc3M7XG59XG5lbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3M/LnZlcnNpb25zPy5ub2RlID09PSAnc3RyaW5nJykge1xuICAgIC8vIE5hdGl2ZSBlbnZpcm9ubWVudCAobm9uLXNhbmRib3hlZClcbiAgICBub2RlUHJvY2VzcyA9IHByb2Nlc3M7XG59XG5jb25zdCBpc0VsZWN0cm9uUHJvY2VzcyA9IHR5cGVvZiBub2RlUHJvY2Vzcz8udmVyc2lvbnM/LmVsZWN0cm9uID09PSAnc3RyaW5nJztcbmNvbnN0IGlzRWxlY3Ryb25SZW5kZXJlciA9IGlzRWxlY3Ryb25Qcm9jZXNzICYmIG5vZGVQcm9jZXNzPy50eXBlID09PSAncmVuZGVyZXInO1xuLy8gTmF0aXZlIGVudmlyb25tZW50XG5pZiAodHlwZW9mIG5vZGVQcm9jZXNzID09PSAnb2JqZWN0Jykge1xuICAgIF9pc1dpbmRvd3MgPSAobm9kZVByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpO1xuICAgIF9pc01hY2ludG9zaCA9IChub2RlUHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuICAgIF9pc0xpbnV4ID0gKG5vZGVQcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKTtcbiAgICBfaXNMaW51eFNuYXAgPSBfaXNMaW51eCAmJiAhIW5vZGVQcm9jZXNzLmVudlsnU05BUCddICYmICEhbm9kZVByb2Nlc3MuZW52WydTTkFQX1JFVklTSU9OJ107XG4gICAgX2lzRWxlY3Ryb24gPSBpc0VsZWN0cm9uUHJvY2VzcztcbiAgICBfaXNDSSA9ICEhbm9kZVByb2Nlc3MuZW52WydDSSddIHx8ICEhbm9kZVByb2Nlc3MuZW52WydCVUlMRF9BUlRJRkFDVFNUQUdJTkdESVJFQ1RPUlknXTtcbiAgICBfbG9jYWxlID0gTEFOR1VBR0VfREVGQVVMVDtcbiAgICBfbGFuZ3VhZ2UgPSBMQU5HVUFHRV9ERUZBVUxUO1xuICAgIGNvbnN0IHJhd05sc0NvbmZpZyA9IG5vZGVQcm9jZXNzLmVudlsnVlNDT0RFX05MU19DT05GSUcnXTtcbiAgICBpZiAocmF3TmxzQ29uZmlnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBubHNDb25maWcgPSBKU09OLnBhcnNlKHJhd05sc0NvbmZpZyk7XG4gICAgICAgICAgICBfbG9jYWxlID0gbmxzQ29uZmlnLnVzZXJMb2NhbGU7XG4gICAgICAgICAgICBfcGxhdGZvcm1Mb2NhbGUgPSBubHNDb25maWcub3NMb2NhbGU7XG4gICAgICAgICAgICBfbGFuZ3VhZ2UgPSBubHNDb25maWcucmVzb2x2ZWRMYW5ndWFnZSB8fCBMQU5HVUFHRV9ERUZBVUxUO1xuICAgICAgICAgICAgX3RyYW5zbGF0aW9uc0NvbmZpZ0ZpbGUgPSBubHNDb25maWcubGFuZ3VhZ2VQYWNrPy50cmFuc2xhdGlvbnNDb25maWdGaWxlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2lzTmF0aXZlID0gdHJ1ZTtcbn1cbi8vIFdlYiBlbnZpcm9ubWVudFxuZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgIWlzRWxlY3Ryb25SZW5kZXJlcikge1xuICAgIF91c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIF9pc1dpbmRvd3MgPSBfdXNlckFnZW50LmluZGV4T2YoJ1dpbmRvd3MnKSA+PSAwO1xuICAgIF9pc01hY2ludG9zaCA9IF91c2VyQWdlbnQuaW5kZXhPZignTWFjaW50b3NoJykgPj0gMDtcbiAgICBfaXNJT1MgPSAoX3VzZXJBZ2VudC5pbmRleE9mKCdNYWNpbnRvc2gnKSA+PSAwIHx8IF91c2VyQWdlbnQuaW5kZXhPZignaVBhZCcpID49IDAgfHwgX3VzZXJBZ2VudC5pbmRleE9mKCdpUGhvbmUnKSA+PSAwKSAmJiAhIW5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xuICAgIF9pc0xpbnV4ID0gX3VzZXJBZ2VudC5pbmRleE9mKCdMaW51eCcpID49IDA7XG4gICAgX2lzTW9iaWxlID0gX3VzZXJBZ2VudD8uaW5kZXhPZignTW9iaScpID49IDA7XG4gICAgX2lzV2ViID0gdHJ1ZTtcbiAgICBfbGFuZ3VhZ2UgPSBubHMuZ2V0TkxTTGFuZ3VhZ2UoKSB8fCBMQU5HVUFHRV9ERUZBVUxUO1xuICAgIF9sb2NhbGUgPSBuYXZpZ2F0b3IubGFuZ3VhZ2UudG9Mb3dlckNhc2UoKTtcbiAgICBfcGxhdGZvcm1Mb2NhbGUgPSBfbG9jYWxlO1xufVxuLy8gVW5rbm93biBlbnZpcm9ubWVudFxuZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIHJlc29sdmUgcGxhdGZvcm0uJyk7XG59XG5sZXQgX3BsYXRmb3JtID0gMCAvKiBQbGF0Zm9ybS5XZWIgKi87XG5pZiAoX2lzTWFjaW50b3NoKSB7XG4gICAgX3BsYXRmb3JtID0gMSAvKiBQbGF0Zm9ybS5NYWMgKi87XG59XG5lbHNlIGlmIChfaXNXaW5kb3dzKSB7XG4gICAgX3BsYXRmb3JtID0gMyAvKiBQbGF0Zm9ybS5XaW5kb3dzICovO1xufVxuZWxzZSBpZiAoX2lzTGludXgpIHtcbiAgICBfcGxhdGZvcm0gPSAyIC8qIFBsYXRmb3JtLkxpbnV4ICovO1xufVxuZXhwb3J0IGNvbnN0IGlzV2luZG93cyA9IF9pc1dpbmRvd3M7XG5leHBvcnQgY29uc3QgaXNNYWNpbnRvc2ggPSBfaXNNYWNpbnRvc2g7XG5leHBvcnQgY29uc3QgaXNMaW51eCA9IF9pc0xpbnV4O1xuZXhwb3J0IGNvbnN0IGlzTmF0aXZlID0gX2lzTmF0aXZlO1xuZXhwb3J0IGNvbnN0IGlzV2ViID0gX2lzV2ViO1xuZXhwb3J0IGNvbnN0IGlzV2ViV29ya2VyID0gKF9pc1dlYiAmJiB0eXBlb2YgJGdsb2JhbFRoaXMuaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJyk7XG5leHBvcnQgY29uc3Qgd2ViV29ya2VyT3JpZ2luID0gaXNXZWJXb3JrZXIgPyAkZ2xvYmFsVGhpcy5vcmlnaW4gOiB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3QgaXNJT1MgPSBfaXNJT1M7XG5leHBvcnQgY29uc3QgaXNNb2JpbGUgPSBfaXNNb2JpbGU7XG5leHBvcnQgY29uc3QgdXNlckFnZW50ID0gX3VzZXJBZ2VudDtcbi8qKlxuICogVGhlIGxhbmd1YWdlIHVzZWQgZm9yIHRoZSB1c2VyIGludGVyZmFjZS4gVGhlIGZvcm1hdCBvZlxuICogdGhlIHN0cmluZyBpcyBhbGwgbG93ZXIgY2FzZSAoZS5nLiB6aC10dyBmb3IgVHJhZGl0aW9uYWxcbiAqIENoaW5lc2Ugb3IgZGUgZm9yIEdlcm1hbilcbiAqL1xuZXhwb3J0IGNvbnN0IGxhbmd1YWdlID0gX2xhbmd1YWdlO1xuZXhwb3J0IGNvbnN0IHNldFRpbWVvdXQwSXNGYXN0ZXIgPSAodHlwZW9mICRnbG9iYWxUaGlzLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nICYmICEkZ2xvYmFsVGhpcy5pbXBvcnRTY3JpcHRzKTtcbi8qKlxuICogU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjOn46dGV4dD10aGFuJTIwNCUyQyUyMHRoZW4tLHNldCUyMHRpbWVvdXQlMjB0byUyMDQsLS5cbiAqXG4gKiBXb3JrcyBzaW1pbGFybHkgdG8gYHNldFRpbWVvdXQoMClgIGJ1dCBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoZSA0bXMgYXJ0aWZpY2lhbCBkZWxheVxuICogdGhhdCBicm93c2VycyBzZXQgd2hlbiB0aGUgbmVzdGluZyBsZXZlbCBpcyA+IDUuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRUaW1lb3V0MCA9ICgoKSA9PiB7XG4gICAgaWYgKHNldFRpbWVvdXQwSXNGYXN0ZXIpIHtcbiAgICAgICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgICAgICAkZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmRhdGEgJiYgZS5kYXRhLnZzY29kZVNjaGVkdWxlQXN5bmNXb3JrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBlbmRpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gcGVuZGluZ1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5pZCA9PT0gZS5kYXRhLnZzY29kZVNjaGVkdWxlQXN5bmNXb3JrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZS5jYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxhc3RJZCA9IDA7XG4gICAgICAgIHJldHVybiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG15SWQgPSArK2xhc3RJZDtcbiAgICAgICAgICAgIHBlbmRpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IG15SWQsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRnbG9iYWxUaGlzLnBvc3RNZXNzYWdlKHsgdnNjb2RlU2NoZWR1bGVBc3luY1dvcms6IG15SWQgfSwgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4gc2V0VGltZW91dChjYWxsYmFjayk7XG59KSgpO1xuZXhwb3J0IGNvbnN0IE9TID0gKF9pc01hY2ludG9zaCB8fCBfaXNJT1MgPyAyIC8qIE9wZXJhdGluZ1N5c3RlbS5NYWNpbnRvc2ggKi8gOiAoX2lzV2luZG93cyA/IDEgLyogT3BlcmF0aW5nU3lzdGVtLldpbmRvd3MgKi8gOiAzIC8qIE9wZXJhdGluZ1N5c3RlbS5MaW51eCAqLykpO1xubGV0IF9pc0xpdHRsZUVuZGlhbiA9IHRydWU7XG5sZXQgX2lzTGl0dGxlRW5kaWFuQ29tcHV0ZWQgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgICBpZiAoIV9pc0xpdHRsZUVuZGlhbkNvbXB1dGVkKSB7XG4gICAgICAgIF9pc0xpdHRsZUVuZGlhbkNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdGVzdCA9IG5ldyBVaW50OEFycmF5KDIpO1xuICAgICAgICB0ZXN0WzBdID0gMTtcbiAgICAgICAgdGVzdFsxXSA9IDI7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDE2QXJyYXkodGVzdC5idWZmZXIpO1xuICAgICAgICBfaXNMaXR0bGVFbmRpYW4gPSAodmlld1swXSA9PT0gKDIgPDwgOCkgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc0xpdHRsZUVuZGlhbjtcbn1cbmV4cG9ydCBjb25zdCBpc0Nocm9tZSA9ICEhKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPj0gMCk7XG5leHBvcnQgY29uc3QgaXNGaXJlZm94ID0gISEodXNlckFnZW50ICYmIHVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPj0gMCk7XG5leHBvcnQgY29uc3QgaXNTYWZhcmkgPSAhISghaXNDaHJvbWUgJiYgKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignU2FmYXJpJykgPj0gMCkpO1xuZXhwb3J0IGNvbnN0IGlzRWRnZSA9ICEhKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignRWRnLycpID49IDApO1xuZXhwb3J0IGNvbnN0IGlzQW5kcm9pZCA9ICEhKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignQW5kcm9pZCcpID49IDApO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBpc01hY2ludG9zaCwgaXNXaW5kb3dzIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5sZXQgc2FmZVByb2Nlc3M7XG4vLyBOYXRpdmUgc2FuZGJveCBlbnZpcm9ubWVudFxuY29uc3QgdnNjb2RlR2xvYmFsID0gZ2xvYmFsVGhpcy52c2NvZGU7XG5pZiAodHlwZW9mIHZzY29kZUdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHZzY29kZUdsb2JhbC5wcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IHNhbmRib3hQcm9jZXNzID0gdnNjb2RlR2xvYmFsLnByb2Nlc3M7XG4gICAgc2FmZVByb2Nlc3MgPSB7XG4gICAgICAgIGdldCBwbGF0Zm9ybSgpIHsgcmV0dXJuIHNhbmRib3hQcm9jZXNzLnBsYXRmb3JtOyB9LFxuICAgICAgICBnZXQgYXJjaCgpIHsgcmV0dXJuIHNhbmRib3hQcm9jZXNzLmFyY2g7IH0sXG4gICAgICAgIGdldCBlbnYoKSB7IHJldHVybiBzYW5kYm94UHJvY2Vzcy5lbnY7IH0sXG4gICAgICAgIGN3ZCgpIHsgcmV0dXJuIHNhbmRib3hQcm9jZXNzLmN3ZCgpOyB9XG4gICAgfTtcbn1cbi8vIE5hdGl2ZSBub2RlLmpzIGVudmlyb25tZW50XG5lbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3M/LnZlcnNpb25zPy5ub2RlID09PSAnc3RyaW5nJykge1xuICAgIHNhZmVQcm9jZXNzID0ge1xuICAgICAgICBnZXQgcGxhdGZvcm0oKSB7IHJldHVybiBwcm9jZXNzLnBsYXRmb3JtOyB9LFxuICAgICAgICBnZXQgYXJjaCgpIHsgcmV0dXJuIHByb2Nlc3MuYXJjaDsgfSxcbiAgICAgICAgZ2V0IGVudigpIHsgcmV0dXJuIHByb2Nlc3MuZW52OyB9LFxuICAgICAgICBjd2QoKSB7IHJldHVybiBwcm9jZXNzLmVudlsnVlNDT0RFX0NXRCddIHx8IHByb2Nlc3MuY3dkKCk7IH1cbiAgICB9O1xufVxuLy8gV2ViIGVudmlyb25tZW50XG5lbHNlIHtcbiAgICBzYWZlUHJvY2VzcyA9IHtcbiAgICAgICAgLy8gU3VwcG9ydGVkXG4gICAgICAgIGdldCBwbGF0Zm9ybSgpIHsgcmV0dXJuIGlzV2luZG93cyA/ICd3aW4zMicgOiBpc01hY2ludG9zaCA/ICdkYXJ3aW4nIDogJ2xpbnV4JzsgfSxcbiAgICAgICAgZ2V0IGFyY2goKSB7IHJldHVybiB1bmRlZmluZWQ7IC8qIGFyY2ggaXMgdW5kZWZpbmVkIGluIHdlYiAqLyB9LFxuICAgICAgICAvLyBVbnN1cHBvcnRlZFxuICAgICAgICBnZXQgZW52KCkgeyByZXR1cm4ge307IH0sXG4gICAgICAgIGN3ZCgpIHsgcmV0dXJuICcvJzsgfVxuICAgIH07XG59XG4vKipcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBgY3dkYCBwcm9wZXJ0eSBpbiBub2RlLmpzLCBzYW5kYm94ZWQgb3Igd2ViXG4gKiBlbnZpcm9ubWVudHMuXG4gKlxuICogTm90ZTogaW4gd2ViLCB0aGlzIHByb3BlcnR5IGlzIGhhcmRjb2RlZCB0byBiZSBgL2AuXG4gKlxuICogQHNraXBNYW5nbGVcbiAqL1xuZXhwb3J0IGNvbnN0IGN3ZCA9IHNhZmVQcm9jZXNzLmN3ZDtcbi8qKlxuICogUHJvdmlkZXMgc2FmZSBhY2Nlc3MgdG8gdGhlIGBlbnZgIHByb3BlcnR5IGluIG5vZGUuanMsIHNhbmRib3hlZCBvciB3ZWJcbiAqIGVudmlyb25tZW50cy5cbiAqXG4gKiBOb3RlOiBpbiB3ZWIsIHRoaXMgcHJvcGVydHkgaXMgaGFyZGNvZGVkIHRvIGJlIGB7fWAuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnYgPSBzYWZlUHJvY2Vzcy5lbnY7XG4vKipcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBgcGxhdGZvcm1gIHByb3BlcnR5IGluIG5vZGUuanMsIHNhbmRib3hlZCBvciB3ZWJcbiAqIGVudmlyb25tZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IHBsYXRmb3JtID0gc2FmZVByb2Nlc3MucGxhdGZvcm07XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmNvbnN0IGhhc1BlcmZvcm1hbmNlTm93ID0gKGdsb2JhbFRoaXMucGVyZm9ybWFuY2UgJiYgdHlwZW9mIGdsb2JhbFRoaXMucGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nKTtcbmV4cG9ydCBjbGFzcyBTdG9wV2F0Y2gge1xuICAgIHN0YXRpYyBjcmVhdGUoaGlnaFJlc29sdXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdG9wV2F0Y2goaGlnaFJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihoaWdoUmVzb2x1dGlvbikge1xuICAgICAgICB0aGlzLl9ub3cgPSBoYXNQZXJmb3JtYW5jZU5vdyAmJiBoaWdoUmVzb2x1dGlvbiA9PT0gZmFsc2UgPyBEYXRlLm5vdyA6IGdsb2JhbFRoaXMucGVyZm9ybWFuY2Uubm93LmJpbmQoZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSk7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuX25vdygpO1xuICAgICAgICB0aGlzLl9zdG9wVGltZSA9IC0xO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLl9zdG9wVGltZSA9IHRoaXMuX25vdygpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGhpcy5fbm93KCk7XG4gICAgICAgIHRoaXMuX3N0b3BUaW1lID0gLTE7XG4gICAgfVxuICAgIGVsYXBzZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdG9wVGltZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbm93KCkgLSB0aGlzLl9zdGFydFRpbWU7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBMUlVDYWNoZWRGdW5jdGlvbiB9IGZyb20gJy4vY2FjaGUuanMnO1xuaW1wb3J0IHsgTGF6eSB9IGZyb20gJy4vbGF6eS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaXNGYWxzeU9yV2hpdGVzcGFjZShzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCB0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci50cmltKCkubGVuZ3RoID09PSAwO1xufVxuY29uc3QgX2Zvcm1hdFJlZ2V4cCA9IC97KFxcZCspfS9nO1xuLyoqXG4gKiBIZWxwZXIgdG8gcHJvZHVjZSBhIHN0cmluZyB3aXRoIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cy4gSW5zZXJ0IHZhcmlhYmxlIHNlZ21lbnRzXG4gKiBpbnRvIHRoZSBzdHJpbmcgdXNpbmcgdGhlIHtufSBub3RhdGlvbiB3aGVyZSBOIGlzIHRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQgZm9sbG93aW5nIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0gdmFsdWUgc3RyaW5nIHRvIHdoaWNoIGZvcm1hdHRpbmcgaXMgYXBwbGllZFxuICogQHBhcmFtIGFyZ3MgcmVwbGFjZW1lbnRzIGZvciB7bn0tZW50cmllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCAuLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoX2Zvcm1hdFJlZ2V4cCwgZnVuY3Rpb24gKG1hdGNoLCBncm91cCkge1xuICAgICAgICBjb25zdCBpZHggPSBwYXJzZUludChncm91cCwgMTApO1xuICAgICAgICByZXR1cm4gaXNOYU4oaWR4KSB8fCBpZHggPCAwIHx8IGlkeCA+PSBhcmdzLmxlbmd0aCA/XG4gICAgICAgICAgICBtYXRjaCA6XG4gICAgICAgICAgICBhcmdzW2lkeF07XG4gICAgfSk7XG59XG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHZhbHVlIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgbGl0ZXJhbCB2YWx1ZSBpbiBodG1sIGF0dHJpYnV0ZXMuXG4gKlxuICogSW4gb3RoZXIgd29yZHMsIGNvbXB1dGVzIGAkdmFsYCwgc3VjaCB0aGF0IGBhdHRyYCBpbiBgPGRpdiBhdHRyPVwiJHZhbFwiIC8+YCBoYXMgdGhlIHJ1bnRpbWUgdmFsdWUgYHZhbHVlYC5cbiAqIFRoaXMgcHJldmVudHMgWFNTIGluamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh0bWxBdHRyaWJ1dGVFbmNvZGVWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bPD5cIicmXS9nLCBjaCA9PiB7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgIGNhc2UgJzwnOiByZXR1cm4gJyZsdDsnO1xuICAgICAgICAgICAgY2FzZSAnPic6IHJldHVybiAnJmd0Oyc7XG4gICAgICAgICAgICBjYXNlICdcIic6IHJldHVybiAnJnF1b3Q7JztcbiAgICAgICAgICAgIGNhc2UgJ1xcJyc6IHJldHVybiAnJmFwb3M7JztcbiAgICAgICAgICAgIGNhc2UgJyYnOiByZXR1cm4gJyZhbXA7JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIEhUTUwgY2hhcmFjdGVycyBpbnNpZGUgdGhlIHN0cmluZyB0byB1c2UgZW50aXRpZXMgaW5zdGVhZC4gTWFrZXMgdGhlIHN0cmluZyBzYWZlIGZyb21cbiAqIGJlaW5nIHVzZWQgZS5nLiBpbiBIVE1MRWxlbWVudC5pbm5lckhUTUwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGUoaHRtbCkge1xuICAgIHJldHVybiBodG1sLnJlcGxhY2UoL1s8PiZdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgICAgICBjYXNlICc8JzogcmV0dXJuICcmbHQ7JztcbiAgICAgICAgICAgIGNhc2UgJz4nOiByZXR1cm4gJyZndDsnO1xuICAgICAgICAgICAgY2FzZSAnJic6IHJldHVybiAnJmFtcDsnO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEVzY2FwZXMgcmVndWxhciBleHByZXNzaW9uIGNoYXJhY3RlcnMgaW4gYSBnaXZlbiBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cENoYXJhY3RlcnModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW1xcXFxcXHtcXH1cXCpcXCtcXD9cXHxcXF5cXCRcXC5cXFtcXF1cXChcXCldL2csICdcXFxcJCYnKTtcbn1cbi8qKlxuICogUmVtb3ZlcyBhbGwgb2NjdXJyZW5jZXMgb2YgbmVlZGxlIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGhheXN0YWNrLlxuICogQHBhcmFtIGhheXN0YWNrIHN0cmluZyB0byB0cmltXG4gKiBAcGFyYW0gbmVlZGxlIHRoZSB0aGluZyB0byB0cmltIChkZWZhdWx0IGlzIGEgYmxhbmspXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltKGhheXN0YWNrLCBuZWVkbGUgPSAnICcpIHtcbiAgICBjb25zdCB0cmltbWVkID0gbHRyaW0oaGF5c3RhY2ssIG5lZWRsZSk7XG4gICAgcmV0dXJuIHJ0cmltKHRyaW1tZWQsIG5lZWRsZSk7XG59XG4vKipcbiAqIFJlbW92ZXMgYWxsIG9jY3VycmVuY2VzIG9mIG5lZWRsZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgaGF5c3RhY2suXG4gKiBAcGFyYW0gaGF5c3RhY2sgc3RyaW5nIHRvIHRyaW1cbiAqIEBwYXJhbSBuZWVkbGUgdGhlIHRoaW5nIHRvIHRyaW1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGx0cmltKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICBpZiAoIWhheXN0YWNrIHx8ICFuZWVkbGUpIHtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrO1xuICAgIH1cbiAgICBjb25zdCBuZWVkbGVMZW4gPSBuZWVkbGUubGVuZ3RoO1xuICAgIGlmIChuZWVkbGVMZW4gPT09IDAgfHwgaGF5c3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKGhheXN0YWNrLmluZGV4T2YobmVlZGxlLCBvZmZzZXQpID09PSBvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgbmVlZGxlTGVuO1xuICAgIH1cbiAgICByZXR1cm4gaGF5c3RhY2suc3Vic3RyaW5nKG9mZnNldCk7XG59XG4vKipcbiAqIFJlbW92ZXMgYWxsIG9jY3VycmVuY2VzIG9mIG5lZWRsZSBmcm9tIHRoZSBlbmQgb2YgaGF5c3RhY2suXG4gKiBAcGFyYW0gaGF5c3RhY2sgc3RyaW5nIHRvIHRyaW1cbiAqIEBwYXJhbSBuZWVkbGUgdGhlIHRoaW5nIHRvIHRyaW1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ0cmltKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICBpZiAoIWhheXN0YWNrIHx8ICFuZWVkbGUpIHtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrO1xuICAgIH1cbiAgICBjb25zdCBuZWVkbGVMZW4gPSBuZWVkbGUubGVuZ3RoLCBoYXlzdGFja0xlbiA9IGhheXN0YWNrLmxlbmd0aDtcbiAgICBpZiAobmVlZGxlTGVuID09PSAwIHx8IGhheXN0YWNrTGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IGhheXN0YWNrTGVuLCBpZHggPSAtMTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZHggPSBoYXlzdGFjay5sYXN0SW5kZXhPZihuZWVkbGUsIG9mZnNldCAtIDEpO1xuICAgICAgICBpZiAoaWR4ID09PSAtMSB8fCBpZHggKyBuZWVkbGVMZW4gIT09IG9mZnNldCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IGlkeDtcbiAgICB9XG4gICAgcmV0dXJuIGhheXN0YWNrLnN1YnN0cmluZygwLCBvZmZzZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRTaW1wbGUyUmVnRXhwUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvW1xcLVxcXFxcXHtcXH1cXCtcXD9cXHxcXF5cXCRcXC5cXCxcXFtcXF1cXChcXClcXCNcXHNdL2csICdcXFxcJCYnKS5yZXBsYWNlKC9bXFwqXS9nLCAnLionKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFdpbGRjYXJkcyhwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvXFwqL2csICcnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWdFeHAoc2VhcmNoU3RyaW5nLCBpc1JlZ2V4LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXNlYXJjaFN0cmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgcmVnZXggZnJvbSBlbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCFpc1JlZ2V4KSB7XG4gICAgICAgIHNlYXJjaFN0cmluZyA9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoc2VhcmNoU3RyaW5nKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud2hvbGVXb3JkKSB7XG4gICAgICAgIGlmICghL1xcQi8udGVzdChzZWFyY2hTdHJpbmcuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgc2VhcmNoU3RyaW5nID0gJ1xcXFxiJyArIHNlYXJjaFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIS9cXEIvLnRlc3Qoc2VhcmNoU3RyaW5nLmNoYXJBdChzZWFyY2hTdHJpbmcubGVuZ3RoIC0gMSkpKSB7XG4gICAgICAgICAgICBzZWFyY2hTdHJpbmcgPSBzZWFyY2hTdHJpbmcgKyAnXFxcXGInO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtb2RpZmllcnMgPSAnJztcbiAgICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcbiAgICAgICAgbW9kaWZpZXJzICs9ICdnJztcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLm1hdGNoQ2FzZSkge1xuICAgICAgICBtb2RpZmllcnMgKz0gJ2knO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tdWx0aWxpbmUpIHtcbiAgICAgICAgbW9kaWZpZXJzICs9ICdtJztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudW5pY29kZSkge1xuICAgICAgICBtb2RpZmllcnMgKz0gJ3UnO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChzZWFyY2hTdHJpbmcsIG1vZGlmaWVycyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVnRXhwTGVhZHNUb0VuZGxlc3NMb29wKHJlZ2V4cCkge1xuICAgIC8vIEV4aXQgZWFybHkgaWYgaXQncyBvbmUgb2YgdGhlc2Ugc3BlY2lhbCBjYXNlcyB3aGljaCBhcmUgbWVhbnQgdG8gbWF0Y2hcbiAgICAvLyBhZ2FpbnN0IGFuIGVtcHR5IHN0cmluZ1xuICAgIGlmIChyZWdleHAuc291cmNlID09PSAnXicgfHwgcmVnZXhwLnNvdXJjZSA9PT0gJ14kJyB8fCByZWdleHAuc291cmNlID09PSAnJCcgfHwgcmVnZXhwLnNvdXJjZSA9PT0gJ15cXFxccyokJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFdlIGNoZWNrIGFnYWluc3QgYW4gZW1wdHkgc3RyaW5nLiBJZiB0aGUgcmVndWxhciBleHByZXNzaW9uIGRvZXNuJ3QgYWR2YW5jZVxuICAgIC8vIChlLmcuIGVuZHMgaW4gYW4gZW5kbGVzcyBsb29wKSBpdCB3aWxsIG1hdGNoIGFuIGVtcHR5IHN0cmluZy5cbiAgICBjb25zdCBtYXRjaCA9IHJlZ2V4cC5leGVjKCcnKTtcbiAgICByZXR1cm4gISEobWF0Y2ggJiYgcmVnZXhwLmxhc3RJbmRleCA9PT0gMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXRMaW5lcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0TGluZXNJbmNsdWRlU2VwYXJhdG9ycyhzdHIpIHtcbiAgICBjb25zdCBsaW5lc1dpdGhTZXBhcmF0b3JzID0gW107XG4gICAgY29uc3Qgc3BsaXRMaW5lc0FuZFNlcGFyYXRvcnMgPSBzdHIuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGguY2VpbChzcGxpdExpbmVzQW5kU2VwYXJhdG9ycy5sZW5ndGggLyAyKTsgaSsrKSB7XG4gICAgICAgIGxpbmVzV2l0aFNlcGFyYXRvcnMucHVzaChzcGxpdExpbmVzQW5kU2VwYXJhdG9yc1syICogaV0gKyAoc3BsaXRMaW5lc0FuZFNlcGFyYXRvcnNbMiAqIGkgKyAxXSA/PyAnJykpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXNXaXRoU2VwYXJhdG9ycztcbn1cbi8qKlxuICogUmV0dXJucyBmaXJzdCBpbmRleCBvZiB0aGUgc3RyaW5nIHRoYXQgaXMgbm90IHdoaXRlc3BhY2UuXG4gKiBJZiBzdHJpbmcgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyAtMVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXgoc3RyKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjaENvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoQ29kZSAhPT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8gJiYgY2hDb2RlICE9PSA5IC8qIENoYXJDb2RlLlRhYiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2Ugb2YgdGhlIHN0cmluZy5cbiAqIElmIHRoZSBzdHJpbmcgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyBlbnRpcmUgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWFkaW5nV2hpdGVzcGFjZShzdHIsIHN0YXJ0ID0gMCwgZW5kID0gc3RyLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hDb2RlICE9PSAzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLyAmJiBjaENvZGUgIT09IDkgLyogQ2hhckNvZGUuVGFiICovKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdGFydCwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG59XG4vKipcbiAqIFJldHVybnMgbGFzdCBpbmRleCBvZiB0aGUgc3RyaW5nIHRoYXQgaXMgbm90IHdoaXRlc3BhY2UuXG4gKiBJZiBzdHJpbmcgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyAtMVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGFzdE5vbldoaXRlc3BhY2VJbmRleChzdHIsIHN0YXJ0SW5kZXggPSBzdHIubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBjaENvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoQ29kZSAhPT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8gJiYgY2hDb2RlICE9PSA5IC8qIENoYXJDb2RlLlRhYiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVTdWJzdHJpbmcoYSwgYiwgYVN0YXJ0ID0gMCwgYUVuZCA9IGEubGVuZ3RoLCBiU3RhcnQgPSAwLCBiRW5kID0gYi5sZW5ndGgpIHtcbiAgICBmb3IgKDsgYVN0YXJ0IDwgYUVuZCAmJiBiU3RhcnQgPCBiRW5kOyBhU3RhcnQrKywgYlN0YXJ0KyspIHtcbiAgICAgICAgY29uc3QgY29kZUEgPSBhLmNoYXJDb2RlQXQoYVN0YXJ0KTtcbiAgICAgICAgY29uc3QgY29kZUIgPSBiLmNoYXJDb2RlQXQoYlN0YXJ0KTtcbiAgICAgICAgaWYgKGNvZGVBIDwgY29kZUIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlQSA+IGNvZGVCKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhTGVuID0gYUVuZCAtIGFTdGFydDtcbiAgICBjb25zdCBiTGVuID0gYkVuZCAtIGJTdGFydDtcbiAgICBpZiAoYUxlbiA8IGJMZW4pIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChhTGVuID4gYkxlbikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUlnbm9yZUNhc2UoYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlU3Vic3RyaW5nSWdub3JlQ2FzZShhLCBiLCAwLCBhLmxlbmd0aCwgMCwgYi5sZW5ndGgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVTdWJzdHJpbmdJZ25vcmVDYXNlKGEsIGIsIGFTdGFydCA9IDAsIGFFbmQgPSBhLmxlbmd0aCwgYlN0YXJ0ID0gMCwgYkVuZCA9IGIubGVuZ3RoKSB7XG4gICAgZm9yICg7IGFTdGFydCA8IGFFbmQgJiYgYlN0YXJ0IDwgYkVuZDsgYVN0YXJ0KyssIGJTdGFydCsrKSB7XG4gICAgICAgIGxldCBjb2RlQSA9IGEuY2hhckNvZGVBdChhU3RhcnQpO1xuICAgICAgICBsZXQgY29kZUIgPSBiLmNoYXJDb2RlQXQoYlN0YXJ0KTtcbiAgICAgICAgaWYgKGNvZGVBID09PSBjb2RlQikge1xuICAgICAgICAgICAgLy8gZXF1YWxcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlQSA+PSAxMjggfHwgY29kZUIgPj0gMTI4KSB7XG4gICAgICAgICAgICAvLyBub3QgQVNDSUkgbGV0dGVycyAtPiBmYWxsYmFjayB0byBsb3dlci1jYXNpbmcgc3RyaW5nc1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVTdWJzdHJpbmcoYS50b0xvd2VyQ2FzZSgpLCBiLnRvTG93ZXJDYXNlKCksIGFTdGFydCwgYUVuZCwgYlN0YXJ0LCBiRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXBwZXIgbG93ZXItY2FzZSBhc2NpaSBsZXR0ZXIgb250byB1cHBlci1jYXNlIHZhcmluYXRzXG4gICAgICAgIC8vIFs5Ny0xMjJdIChsb3dlciBhc2NpaSkgLS0+IFs2NS05MF0gKHVwcGVyIGFzY2lpKVxuICAgICAgICBpZiAoaXNMb3dlckFzY2lpTGV0dGVyKGNvZGVBKSkge1xuICAgICAgICAgICAgY29kZUEgLT0gMzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTG93ZXJBc2NpaUxldHRlcihjb2RlQikpIHtcbiAgICAgICAgICAgIGNvZGVCIC09IDMyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXBhcmUgYm90aCBjb2RlIHBvaW50c1xuICAgICAgICBjb25zdCBkaWZmID0gY29kZUEgLSBjb2RlQjtcbiAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cbiAgICBjb25zdCBhTGVuID0gYUVuZCAtIGFTdGFydDtcbiAgICBjb25zdCBiTGVuID0gYkVuZCAtIGJTdGFydDtcbiAgICBpZiAoYUxlbiA8IGJMZW4pIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChhTGVuID4gYkxlbikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBc2NpaURpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSA0OCAvKiBDaGFyQ29kZS5EaWdpdDAgKi8gJiYgY29kZSA8PSA1NyAvKiBDaGFyQ29kZS5EaWdpdDkgKi87XG59XG5leHBvcnQgZnVuY3Rpb24gaXNMb3dlckFzY2lpTGV0dGVyKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSA5NyAvKiBDaGFyQ29kZS5hICovICYmIGNvZGUgPD0gMTIyIC8qIENoYXJDb2RlLnogKi87XG59XG5leHBvcnQgZnVuY3Rpb24gaXNVcHBlckFzY2lpTGV0dGVyKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSA2NSAvKiBDaGFyQ29kZS5BICovICYmIGNvZGUgPD0gOTAgLyogQ2hhckNvZGUuWiAqLztcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHNJZ25vcmVDYXNlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGNvbXBhcmVTdWJzdHJpbmdJZ25vcmVDYXNlKGEsIGIpID09PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0c1dpdGhJZ25vcmVDYXNlKHN0ciwgY2FuZGlkYXRlKSB7XG4gICAgY29uc3QgY2FuZGlkYXRlTGVuZ3RoID0gY2FuZGlkYXRlLmxlbmd0aDtcbiAgICBpZiAoY2FuZGlkYXRlLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGFyZVN1YnN0cmluZ0lnbm9yZUNhc2Uoc3RyLCBjYW5kaWRhdGUsIDAsIGNhbmRpZGF0ZUxlbmd0aCkgPT09IDA7XG59XG4vKipcbiAqIEByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGNvbW1vbiBwcmVmaXggb2YgdGhlIHR3byBzdHJpbmdzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uUHJlZml4TGVuZ3RoKGEsIGIpIHtcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoYS5jaGFyQ29kZUF0KGkpICE9PSBiLmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGNvbW1vbiBzdWZmaXggb2YgdGhlIHR3byBzdHJpbmdzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uU3VmZml4TGVuZ3RoKGEsIGIpIHtcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGFMYXN0SW5kZXggPSBhLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgYkxhc3RJbmRleCA9IGIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGEuY2hhckNvZGVBdChhTGFzdEluZGV4IC0gaSkgIT09IGIuY2hhckNvZGVBdChiTGFzdEluZGV4IC0gaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1cnJvZ2F0ZV9wYWlyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gKDB4RDgwMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAweERCRkYpO1xufVxuLyoqXG4gKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXJyb2dhdGVfcGFpclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb3dTdXJyb2dhdGUoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gKDB4REMwMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAweERGRkYpO1xufVxuLyoqXG4gKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXJyb2dhdGVfcGFpclxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUNvZGVQb2ludChoaWdoU3Vycm9nYXRlLCBsb3dTdXJyb2dhdGUpIHtcbiAgICByZXR1cm4gKChoaWdoU3Vycm9nYXRlIC0gMHhEODAwKSA8PCAxMCkgKyAobG93U3Vycm9nYXRlIC0gMHhEQzAwKSArIDB4MTAwMDA7XG59XG4vKipcbiAqIGdldCB0aGUgY29kZSBwb2ludCB0aGF0IGJlZ2lucyBhdCBvZmZzZXQgYG9mZnNldGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHRDb2RlUG9pbnQoc3RyLCBsZW4sIG9mZnNldCkge1xuICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSAmJiBvZmZzZXQgKyAxIDwgbGVuKSB7XG4gICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCArIDEpO1xuICAgICAgICBpZiAoaXNMb3dTdXJyb2dhdGUobmV4dENoYXJDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVDb2RlUG9pbnQoY2hhckNvZGUsIG5leHRDaGFyQ29kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xufVxuLyoqXG4gKiBnZXQgdGhlIGNvZGUgcG9pbnQgdGhhdCBlbmRzIHJpZ2h0IGJlZm9yZSBvZmZzZXQgYG9mZnNldGBcbiAqL1xuZnVuY3Rpb24gZ2V0UHJldkNvZGVQb2ludChzdHIsIG9mZnNldCkge1xuICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQob2Zmc2V0IC0gMSk7XG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNoYXJDb2RlKSAmJiBvZmZzZXQgPiAxKSB7XG4gICAgICAgIGNvbnN0IHByZXZDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCAtIDIpO1xuICAgICAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKHByZXZDaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQ29kZVBvaW50KHByZXZDaGFyQ29kZSwgY2hhckNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFyQ29kZTtcbn1cbmV4cG9ydCBjbGFzcyBDb2RlUG9pbnRJdGVyYXRvciB7XG4gICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3RyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHRoaXMuX3N0ciA9IHN0cjtcbiAgICAgICAgdGhpcy5fbGVuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICBzZXRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgcHJldkNvZGVQb2ludCgpIHtcbiAgICAgICAgY29uc3QgY29kZVBvaW50ID0gZ2V0UHJldkNvZGVQb2ludCh0aGlzLl9zdHIsIHRoaXMuX29mZnNldCk7XG4gICAgICAgIHRoaXMuX29mZnNldCAtPSAoY29kZVBvaW50ID49IDY1NTM2IC8qIENvbnN0YW50cy5VTklDT0RFX1NVUFBMRU1FTlRBUllfUExBTkVfQkVHSU4gKi8gPyAyIDogMSk7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgfVxuICAgIG5leHRDb2RlUG9pbnQoKSB7XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGdldE5leHRDb2RlUG9pbnQodGhpcy5fc3RyLCB0aGlzLl9sZW4sIHRoaXMuX29mZnNldCk7XG4gICAgICAgIHRoaXMuX29mZnNldCArPSAoY29kZVBvaW50ID49IDY1NTM2IC8qIENvbnN0YW50cy5VTklDT0RFX1NVUFBMRU1FTlRBUllfUExBTkVfQkVHSU4gKi8gPyAyIDogMSk7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgfVxuICAgIGVvbCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9vZmZzZXQgPj0gdGhpcy5fbGVuKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR3JhcGhlbWVJdGVyYXRvciB7XG4gICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZXJhdG9yLm9mZnNldDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3RyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHRoaXMuX2l0ZXJhdG9yID0gbmV3IENvZGVQb2ludEl0ZXJhdG9yKHN0ciwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbmV4dEdyYXBoZW1lTGVuZ3RoKCkge1xuICAgICAgICBjb25zdCBncmFwaGVtZUJyZWFrVHJlZSA9IEdyYXBoZW1lQnJlYWtUcmVlLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5faXRlcmF0b3I7XG4gICAgICAgIGNvbnN0IGluaXRpYWxPZmZzZXQgPSBpdGVyYXRvci5vZmZzZXQ7XG4gICAgICAgIGxldCBncmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKGl0ZXJhdG9yLm5leHRDb2RlUG9pbnQoKSk7XG4gICAgICAgIHdoaWxlICghaXRlcmF0b3IuZW9sKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGl0ZXJhdG9yLm9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IG5leHRHcmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKGl0ZXJhdG9yLm5leHRDb2RlUG9pbnQoKSk7XG4gICAgICAgICAgICBpZiAoYnJlYWtCZXR3ZWVuR3JhcGhlbWVCcmVha1R5cGUoZ3JhcGhlbWVCcmVha1R5cGUsIG5leHRHcmFwaGVtZUJyZWFrVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGl0ZXJhdG9yIGJhY2tcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5zZXRPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYXBoZW1lQnJlYWtUeXBlID0gbmV4dEdyYXBoZW1lQnJlYWtUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaXRlcmF0b3Iub2Zmc2V0IC0gaW5pdGlhbE9mZnNldCk7XG4gICAgfVxuICAgIHByZXZHcmFwaGVtZUxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgZ3JhcGhlbWVCcmVha1RyZWUgPSBHcmFwaGVtZUJyZWFrVHJlZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX2l0ZXJhdG9yO1xuICAgICAgICBjb25zdCBpbml0aWFsT2Zmc2V0ID0gaXRlcmF0b3Iub2Zmc2V0O1xuICAgICAgICBsZXQgZ3JhcGhlbWVCcmVha1R5cGUgPSBncmFwaGVtZUJyZWFrVHJlZS5nZXRHcmFwaGVtZUJyZWFrVHlwZShpdGVyYXRvci5wcmV2Q29kZVBvaW50KCkpO1xuICAgICAgICB3aGlsZSAoaXRlcmF0b3Iub2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXRlcmF0b3Iub2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgcHJldkdyYXBoZW1lQnJlYWtUeXBlID0gZ3JhcGhlbWVCcmVha1RyZWUuZ2V0R3JhcGhlbWVCcmVha1R5cGUoaXRlcmF0b3IucHJldkNvZGVQb2ludCgpKTtcbiAgICAgICAgICAgIGlmIChicmVha0JldHdlZW5HcmFwaGVtZUJyZWFrVHlwZShwcmV2R3JhcGhlbWVCcmVha1R5cGUsIGdyYXBoZW1lQnJlYWtUeXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgaXRlcmF0b3IgYmFja1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnNldE9mZnNldChvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhcGhlbWVCcmVha1R5cGUgPSBwcmV2R3JhcGhlbWVCcmVha1R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpbml0aWFsT2Zmc2V0IC0gaXRlcmF0b3Iub2Zmc2V0KTtcbiAgICB9XG4gICAgZW9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlcmF0b3IuZW9sKCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIG5leHRDaGFyTGVuZ3RoKHN0ciwgaW5pdGlhbE9mZnNldCkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gbmV3IEdyYXBoZW1lSXRlcmF0b3Ioc3RyLCBpbml0aWFsT2Zmc2V0KTtcbiAgICByZXR1cm4gaXRlcmF0b3IubmV4dEdyYXBoZW1lTGVuZ3RoKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJldkNoYXJMZW5ndGgoc3RyLCBpbml0aWFsT2Zmc2V0KSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBuZXcgR3JhcGhlbWVJdGVyYXRvcihzdHIsIGluaXRpYWxPZmZzZXQpO1xuICAgIHJldHVybiBpdGVyYXRvci5wcmV2R3JhcGhlbWVMZW5ndGgoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFyQ29udGFpbmluZ09mZnNldChzdHIsIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPiAwICYmIGlzTG93U3Vycm9nYXRlKHN0ci5jaGFyQ29kZUF0KG9mZnNldCkpKSB7XG4gICAgICAgIG9mZnNldC0tO1xuICAgIH1cbiAgICBjb25zdCBlbmRPZmZzZXQgPSBvZmZzZXQgKyBuZXh0Q2hhckxlbmd0aChzdHIsIG9mZnNldCk7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBlbmRPZmZzZXQgLSBwcmV2Q2hhckxlbmd0aChzdHIsIGVuZE9mZnNldCk7XG4gICAgcmV0dXJuIFtzdGFydE9mZnNldCwgZW5kT2Zmc2V0XTtcbn1cbmxldCBDT05UQUlOU19SVEwgPSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBtYWtlQ29udGFpbnNSdGwoKSB7XG4gICAgLy8gR2VuZXJhdGVkIHVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4ZGltYS91bmljb2RlLXV0aWxzL2Jsb2IvbWFpbi9ydGwtdGVzdC5qc1xuICAgIHJldHVybiAvKD86W1xcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUQwLVxcdTA1RjRcXHUwNjA4XFx1MDYwQlxcdTA2MERcXHUwNjFCLVxcdTA2NEFcXHUwNjZELVxcdTA2NkZcXHUwNjcxLVxcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDdGRS1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDgzMC1cXHUwODU4XFx1MDg1RS1cXHUwODhFXFx1MDhBMC1cXHUwOEM5XFx1MjAwRlxcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZEM0RcXHVGRDUwLVxcdUZEQzdcXHVGREYwLVxcdUZERkNcXHVGRTcwLVxcdUZFRkNdfFxcdUQ4MDJbXFx1REMwMC1cXHVERDFCXFx1REQyMC1cXHVERTAwXFx1REUxMC1cXHVERTM1XFx1REU0MC1cXHVERUU0XFx1REVFQi1cXHVERjM1XFx1REY0MC1cXHVERkZGXXxcXHVEODAzW1xcdURDMDAtXFx1REQyM1xcdURFODAtXFx1REVBOVxcdURFQUQtXFx1REY0NVxcdURGNTEtXFx1REY4MVxcdURGODYtXFx1REZGNl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQ0ZcXHVERDAwLVxcdURENDNcXHVERDRCLVxcdURGRkZdfFxcdUQ4M0JbXFx1REMwMC1cXHVERUJCXSkvO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHN0cmAgY29udGFpbnMgYW55IFVuaWNvZGUgY2hhcmFjdGVyIHRoYXQgaXMgY2xhc3NpZmllZCBhcyBcIlJcIiBvciBcIkFMXCIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1JUTChzdHIpIHtcbiAgICBpZiAoIUNPTlRBSU5TX1JUTCkge1xuICAgICAgICBDT05UQUlOU19SVEwgPSBtYWtlQ29udGFpbnNSdGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIENPTlRBSU5TX1JUTC50ZXN0KHN0cik7XG59XG5jb25zdCBJU19CQVNJQ19BU0NJSSA9IC9eW1xcdFxcblxcclxceDIwLVxceDdFXSokLztcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIGNvbnRhaW5zIG9ubHkgYmFzaWMgQVNDSUkgY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgMzIgLSAxMjYgKGluY2x1ZGluZyAzMiBhbmQgMTI2KSBvciBcXG4sIFxcciwgXFx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2ljQVNDSUkoc3RyKSB7XG4gICAgcmV0dXJuIElTX0JBU0lDX0FTQ0lJLnRlc3Qoc3RyKTtcbn1cbmV4cG9ydCBjb25zdCBVTlVTVUFMX0xJTkVfVEVSTUlOQVRPUlMgPSAvW1xcdTIwMjhcXHUyMDI5XS87IC8vIExJTkUgU0VQQVJBVE9SIChMUykgb3IgUEFSQUdSQVBIIFNFUEFSQVRPUiAoUFMpXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgc3RyYCBjb250YWlucyB1bnVzdWFsIGxpbmUgdGVybWluYXRvcnMsIGxpa2UgTFMgb3IgUFNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zVW51c3VhbExpbmVUZXJtaW5hdG9ycyhzdHIpIHtcbiAgICByZXR1cm4gVU5VU1VBTF9MSU5FX1RFUk1JTkFUT1JTLnRlc3Qoc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bGxXaWR0aENoYXJhY3RlcihjaGFyQ29kZSkge1xuICAgIC8vIERvIGEgY2hlYXAgdHJpY2sgdG8gYmV0dGVyIHN1cHBvcnQgd3JhcHBpbmcgb2Ygd2lkZSBjaGFyYWN0ZXJzLCB0cmVhdCB0aGVtIGFzIDIgY29sdW1uc1xuICAgIC8vIGh0dHA6Ly9qcmdyYXBoaXgubmV0L3Jlc2VhcmNoL3VuaWNvZGVfYmxvY2tzLnBocFxuICAgIC8vICAgICAgICAgIDJFODAgLSAyRUZGICAgQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnRcbiAgICAvLyAgICAgICAgICAyRjAwIC0gMkZERiAgIEthbmd4aSBSYWRpY2Fsc1xuICAgIC8vICAgICAgICAgIDJGRjAgLSAyRkZGICAgSWRlb2dyYXBoaWMgRGVzY3JpcHRpb24gQ2hhcmFjdGVyc1xuICAgIC8vICAgICAgICAgIDMwMDAgLSAzMDNGICAgQ0pLIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXG4gICAgLy8gICAgICAgICAgMzA0MCAtIDMwOUYgICBIaXJhZ2FuYVxuICAgIC8vICAgICAgICAgIDMwQTAgLSAzMEZGICAgS2F0YWthbmFcbiAgICAvLyAgICAgICAgICAzMTAwIC0gMzEyRiAgIEJvcG9tb2ZvXG4gICAgLy8gICAgICAgICAgMzEzMCAtIDMxOEYgICBIYW5ndWwgQ29tcGF0aWJpbGl0eSBKYW1vXG4gICAgLy8gICAgICAgICAgMzE5MCAtIDMxOUYgICBLYW5idW5cbiAgICAvLyAgICAgICAgICAzMUEwIC0gMzFCRiAgIEJvcG9tb2ZvIEV4dGVuZGVkXG4gICAgLy8gICAgICAgICAgMzFGMCAtIDMxRkYgICBLYXRha2FuYSBQaG9uZXRpYyBFeHRlbnNpb25zXG4gICAgLy8gICAgICAgICAgMzIwMCAtIDMyRkYgICBFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzXG4gICAgLy8gICAgICAgICAgMzMwMCAtIDMzRkYgICBDSksgQ29tcGF0aWJpbGl0eVxuICAgIC8vICAgICAgICAgIDM0MDAgLSA0REJGICAgQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQVxuICAgIC8vICAgICAgICAgIDREQzAgLSA0REZGICAgWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcbiAgICAvLyAgICAgICAgICA0RTAwIC0gOUZGRiAgIENKSyBVbmlmaWVkIElkZW9ncmFwaHNcbiAgICAvLyAgICAgICAgICBBMDAwIC0gQTQ4RiAgIFlpIFN5bGxhYmxlc1xuICAgIC8vICAgICAgICAgIEE0OTAgLSBBNENGICAgWWkgUmFkaWNhbHNcbiAgICAvLyAgICAgICAgICBBQzAwIC0gRDdBRiAgIEhhbmd1bCBTeWxsYWJsZXNcbiAgICAvLyBbSUdOT1JFXSBEODAwIC0gREI3RiAgIEhpZ2ggU3Vycm9nYXRlc1xuICAgIC8vIFtJR05PUkVdIERCODAgLSBEQkZGICAgSGlnaCBQcml2YXRlIFVzZSBTdXJyb2dhdGVzXG4gICAgLy8gW0lHTk9SRV0gREMwMCAtIERGRkYgICBMb3cgU3Vycm9nYXRlc1xuICAgIC8vIFtJR05PUkVdIEUwMDAgLSBGOEZGICAgUHJpdmF0ZSBVc2UgQXJlYVxuICAgIC8vICAgICAgICAgIEY5MDAgLSBGQUZGICAgQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBoc1xuICAgIC8vIFtJR05PUkVdIEZCMDAgLSBGQjRGICAgQWxwaGFiZXRpYyBQcmVzZW50YXRpb24gRm9ybXNcbiAgICAvLyBbSUdOT1JFXSBGQjUwIC0gRkRGRiAgIEFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQVxuICAgIC8vIFtJR05PUkVdIEZFMDAgLSBGRTBGICAgVmFyaWF0aW9uIFNlbGVjdG9yc1xuICAgIC8vIFtJR05PUkVdIEZFMjAgLSBGRTJGICAgQ29tYmluaW5nIEhhbGYgTWFya3NcbiAgICAvLyBbSUdOT1JFXSBGRTMwIC0gRkU0RiAgIENKSyBDb21wYXRpYmlsaXR5IEZvcm1zXG4gICAgLy8gW0lHTk9SRV0gRkU1MCAtIEZFNkYgICBTbWFsbCBGb3JtIFZhcmlhbnRzXG4gICAgLy8gW0lHTk9SRV0gRkU3MCAtIEZFRkYgICBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcbiAgICAvLyAgICAgICAgICBGRjAwIC0gRkZFRiAgIEhhbGZ3aWR0aCBhbmQgRnVsbHdpZHRoIEZvcm1zXG4gICAgLy8gICAgICAgICAgICAgICBbaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFsZndpZHRoX2FuZF9mdWxsd2lkdGhfZm9ybXNdXG4gICAgLy8gICAgICAgICAgICAgICBvZiB3aGljaCBGRjAxIC0gRkY1RSBmdWxsd2lkdGggQVNDSUkgb2YgMjEgdG8gN0VcbiAgICAvLyBbSUdOT1JFXSAgICBhbmQgRkY2NSAtIEZGREMgaGFsZndpZHRoIG9mIEthdGFrYW5hIGFuZCBIYW5ndWxcbiAgICAvLyBbSUdOT1JFXSBGRkYwIC0gRkZGRiAgIFNwZWNpYWxzXG4gICAgcmV0dXJuICgoY2hhckNvZGUgPj0gMHgyRTgwICYmIGNoYXJDb2RlIDw9IDB4RDdBRilcbiAgICAgICAgfHwgKGNoYXJDb2RlID49IDB4RjkwMCAmJiBjaGFyQ29kZSA8PSAweEZBRkYpXG4gICAgICAgIHx8IChjaGFyQ29kZSA+PSAweEZGMDEgJiYgY2hhckNvZGUgPD0gMHhGRjVFKSk7XG59XG4vKipcbiAqIEEgZmFzdCBmdW5jdGlvbiAodGhlcmVmb3JlIGltcHJlY2lzZSkgdG8gY2hlY2sgaWYgY29kZSBwb2ludHMgYXJlIGVtb2ppcy5cbiAqIEdlbmVyYXRlZCB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vYWxleGRpbWEvdW5pY29kZS11dGlscy9ibG9iL21haW4vZW1vamktdGVzdC5qc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbW9qaUltcHJlY2lzZSh4KSB7XG4gICAgcmV0dXJuICgoeCA+PSAweDFGMUU2ICYmIHggPD0gMHgxRjFGRikgfHwgKHggPT09IDg5ODYpIHx8ICh4ID09PSA4OTg3KSB8fCAoeCA9PT0gOTIwMClcbiAgICAgICAgfHwgKHggPT09IDkyMDMpIHx8ICh4ID49IDk3MjggJiYgeCA8PSAxMDE3NSkgfHwgKHggPT09IDExMDg4KSB8fCAoeCA9PT0gMTEwOTMpXG4gICAgICAgIHx8ICh4ID49IDEyNzc0NCAmJiB4IDw9IDEyODU5MSkgfHwgKHggPj0gMTI4NjQwICYmIHggPD0gMTI4NzY0KVxuICAgICAgICB8fCAoeCA+PSAxMjg5OTIgJiYgeCA8PSAxMjkwMDgpIHx8ICh4ID49IDEyOTI4MCAmJiB4IDw9IDEyOTUzNSlcbiAgICAgICAgfHwgKHggPj0gMTI5NjQ4ICYmIHggPD0gMTI5NzgyKSk7XG59XG4vLyAtLSBVVEYtOCBCT01cbmV4cG9ydCBjb25zdCBVVEY4X0JPTV9DSEFSQUNURVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1Mjc5IC8qIENoYXJDb2RlLlVURjhfQk9NICovKTtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydHNXaXRoVVRGOEJPTShzdHIpIHtcbiAgICByZXR1cm4gISEoc3RyICYmIHN0ci5sZW5ndGggPiAwICYmIHN0ci5jaGFyQ29kZUF0KDApID09PSA2NTI3OSAvKiBDaGFyQ29kZS5VVEY4X0JPTSAqLyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIodGFyZ2V0LCBpZ25vcmVFc2NhcGVkQ2hhcnMgPSBmYWxzZSkge1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlnbm9yZUVzY2FwZWRDaGFycykge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucmVwbGFjZSgvXFxcXC4vZywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LnRvTG93ZXJDYXNlKCkgIT09IHRhcmdldDtcbn1cbi8qKlxuICogUHJvZHVjZXMgJ2EnLSd6JywgZm9sbG93ZWQgYnkgJ0EnLSdaJy4uLiBmb2xsb3dlZCBieSAnYSctJ3onLCBldGMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGVMZXR0ZXJIYXNoKG4pIHtcbiAgICBjb25zdCBMRVRURVJTX0NOVCA9ICg5MCAvKiBDaGFyQ29kZS5aICovIC0gNjUgLyogQ2hhckNvZGUuQSAqLyArIDEpO1xuICAgIG4gPSBuICUgKDIgKiBMRVRURVJTX0NOVCk7XG4gICAgaWYgKG4gPCBMRVRURVJTX0NOVCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyAvKiBDaGFyQ29kZS5hICovICsgbik7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1IC8qIENoYXJDb2RlLkEgKi8gKyBuIC0gTEVUVEVSU19DTlQpO1xufVxuZnVuY3Rpb24gYnJlYWtCZXR3ZWVuR3JhcGhlbWVCcmVha1R5cGUoYnJlYWtUeXBlQSwgYnJlYWtUeXBlQikge1xuICAgIC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjI5LyNHcmFwaGVtZV9DbHVzdGVyX0JvdW5kYXJ5X1J1bGVzXG4gICAgLy8gISEhIExldCdzIG1ha2UgdGhlIGNvbW1vbiBjYXNlIGEgYml0IGZhc3RlclxuICAgIGlmIChicmVha1R5cGVBID09PSAwIC8qIEdyYXBoZW1lQnJlYWtUeXBlLk90aGVyICovKSB7XG4gICAgICAgIC8vIHNlZSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvMTMuMC4wL3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QtMTMuMC4wZDEwLmh0bWwjdGFibGVcbiAgICAgICAgcmV0dXJuIChicmVha1R5cGVCICE9PSA1IC8qIEdyYXBoZW1lQnJlYWtUeXBlLkV4dGVuZCAqLyAmJiBicmVha1R5cGVCICE9PSA3IC8qIEdyYXBoZW1lQnJlYWtUeXBlLlNwYWNpbmdNYXJrICovKTtcbiAgICB9XG4gICAgLy8gRG8gbm90IGJyZWFrIGJldHdlZW4gYSBDUiBhbmQgTEYuIE90aGVyd2lzZSwgYnJlYWsgYmVmb3JlIGFuZCBhZnRlciBjb250cm9scy5cbiAgICAvLyBHQjMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1Igw5cgTEZcbiAgICAvLyBHQjQgICAgICAgICAgICAgICAgICAgICAgIChDb250cm9sIHwgQ1IgfCBMRikgw7dcbiAgICAvLyBHQjUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgw7cgKENvbnRyb2wgfCBDUiB8IExGKVxuICAgIGlmIChicmVha1R5cGVBID09PSAyIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkNSICovKSB7XG4gICAgICAgIGlmIChicmVha1R5cGVCID09PSAzIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkxGICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCM1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChicmVha1R5cGVBID09PSA0IC8qIEdyYXBoZW1lQnJlYWtUeXBlLkNvbnRyb2wgKi8gfHwgYnJlYWtUeXBlQSA9PT0gMiAvKiBHcmFwaGVtZUJyZWFrVHlwZS5DUiAqLyB8fCBicmVha1R5cGVBID09PSAzIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkxGICovKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBHQjRcbiAgICB9XG4gICAgaWYgKGJyZWFrVHlwZUIgPT09IDQgLyogR3JhcGhlbWVCcmVha1R5cGUuQ29udHJvbCAqLyB8fCBicmVha1R5cGVCID09PSAyIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkNSICovIHx8IGJyZWFrVHlwZUIgPT09IDMgLyogR3JhcGhlbWVCcmVha1R5cGUuTEYgKi8pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEdCNVxuICAgIH1cbiAgICAvLyBEbyBub3QgYnJlYWsgSGFuZ3VsIHN5bGxhYmxlIHNlcXVlbmNlcy5cbiAgICAvLyBHQjYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwgw5cgKEwgfCBWIHwgTFYgfCBMVlQpXG4gICAgLy8gR0I3ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChMViB8IFYpIMOXIChWIHwgVClcbiAgICAvLyBHQjggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoTFZUIHwgVCkgw5cgVFxuICAgIGlmIChicmVha1R5cGVBID09PSA4IC8qIEdyYXBoZW1lQnJlYWtUeXBlLkwgKi8pIHtcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDggLyogR3JhcGhlbWVCcmVha1R5cGUuTCAqLyB8fCBicmVha1R5cGVCID09PSA5IC8qIEdyYXBoZW1lQnJlYWtUeXBlLlYgKi8gfHwgYnJlYWtUeXBlQiA9PT0gMTEgLyogR3JhcGhlbWVCcmVha1R5cGUuTFYgKi8gfHwgYnJlYWtUeXBlQiA9PT0gMTIgLyogR3JhcGhlbWVCcmVha1R5cGUuTFZUICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCNlxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChicmVha1R5cGVBID09PSAxMSAvKiBHcmFwaGVtZUJyZWFrVHlwZS5MViAqLyB8fCBicmVha1R5cGVBID09PSA5IC8qIEdyYXBoZW1lQnJlYWtUeXBlLlYgKi8pIHtcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDkgLyogR3JhcGhlbWVCcmVha1R5cGUuViAqLyB8fCBicmVha1R5cGVCID09PSAxMCAvKiBHcmFwaGVtZUJyZWFrVHlwZS5UICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCN1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChicmVha1R5cGVBID09PSAxMiAvKiBHcmFwaGVtZUJyZWFrVHlwZS5MVlQgKi8gfHwgYnJlYWtUeXBlQSA9PT0gMTAgLyogR3JhcGhlbWVCcmVha1R5cGUuVCAqLykge1xuICAgICAgICBpZiAoYnJlYWtUeXBlQiA9PT0gMTAgLyogR3JhcGhlbWVCcmVha1R5cGUuVCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjhcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEbyBub3QgYnJlYWsgYmVmb3JlIGV4dGVuZGluZyBjaGFyYWN0ZXJzIG9yIFpXSi5cbiAgICAvLyBHQjkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgw5cgKEV4dGVuZCB8IFpXSilcbiAgICBpZiAoYnJlYWtUeXBlQiA9PT0gNSAvKiBHcmFwaGVtZUJyZWFrVHlwZS5FeHRlbmQgKi8gfHwgYnJlYWtUeXBlQiA9PT0gMTMgLyogR3JhcGhlbWVCcmVha1R5cGUuWldKICovKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I5XG4gICAgfVxuICAgIC8vIFRoZSBHQjlhIGFuZCBHQjliIHJ1bGVzIG9ubHkgYXBwbHkgdG8gZXh0ZW5kZWQgZ3JhcGhlbWUgY2x1c3RlcnM6XG4gICAgLy8gRG8gbm90IGJyZWFrIGJlZm9yZSBTcGFjaW5nTWFya3MsIG9yIGFmdGVyIFByZXBlbmQgY2hhcmFjdGVycy5cbiAgICAvLyBHQjlhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgw5cgU3BhY2luZ01hcmtcbiAgICAvLyBHQjliICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByZXBlbmQgw5dcbiAgICBpZiAoYnJlYWtUeXBlQiA9PT0gNyAvKiBHcmFwaGVtZUJyZWFrVHlwZS5TcGFjaW5nTWFyayAqLykge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCOWFcbiAgICB9XG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDEgLyogR3JhcGhlbWVCcmVha1R5cGUuUHJlcGVuZCAqLykge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCOWJcbiAgICB9XG4gICAgLy8gRG8gbm90IGJyZWFrIHdpdGhpbiBlbW9qaSBtb2RpZmllciBzZXF1ZW5jZXMgb3IgZW1vamkgendqIHNlcXVlbmNlcy5cbiAgICAvLyBHQjExICAgIFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9IEV4dGVuZCogWldKIMOXIFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9XG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDEzIC8qIEdyYXBoZW1lQnJlYWtUeXBlLlpXSiAqLyAmJiBicmVha1R5cGVCID09PSAxNCAvKiBHcmFwaGVtZUJyZWFrVHlwZS5FeHRlbmRlZF9QaWN0b2dyYXBoaWMgKi8pIHtcbiAgICAgICAgLy8gTm90ZTogd2UgYXJlIG5vdCBpbXBsZW1lbnRpbmcgdGhlIHJ1bGUgZW50aXJlbHkgaGVyZSB0byBhdm9pZCBpbnRyb2R1Y2luZyBzdGF0ZXNcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjExXG4gICAgfVxuICAgIC8vIEdCMTIgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdCAoUkkgUkkpKiBSSSDDlyBSSVxuICAgIC8vIEdCMTMgICAgICAgICAgICAgICAgICAgICAgICBbXlJJXSAoUkkgUkkpKiBSSSDDlyBSSVxuICAgIGlmIChicmVha1R5cGVBID09PSA2IC8qIEdyYXBoZW1lQnJlYWtUeXBlLlJlZ2lvbmFsX0luZGljYXRvciAqLyAmJiBicmVha1R5cGVCID09PSA2IC8qIEdyYXBoZW1lQnJlYWtUeXBlLlJlZ2lvbmFsX0luZGljYXRvciAqLykge1xuICAgICAgICAvLyBOb3RlOiB3ZSBhcmUgbm90IGltcGxlbWVudGluZyB0aGUgcnVsZSBlbnRpcmVseSBoZXJlIHRvIGF2b2lkIGludHJvZHVjaW5nIHN0YXRlc1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCMTIgJiBHQjEzXG4gICAgfVxuICAgIC8vIEdCOTk5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFueSDDtyBBbnlcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIEdyYXBoZW1lQnJlYWtUcmVlIHtcbiAgICBzdGF0aWMgeyB0aGlzLl9JTlNUQU5DRSA9IG51bGw7IH1cbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIGlmICghR3JhcGhlbWVCcmVha1RyZWUuX0lOU1RBTkNFKSB7XG4gICAgICAgICAgICBHcmFwaGVtZUJyZWFrVHJlZS5fSU5TVEFOQ0UgPSBuZXcgR3JhcGhlbWVCcmVha1RyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR3JhcGhlbWVCcmVha1RyZWUuX0lOU1RBTkNFO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGdldEdyYXBoZW1lQnJlYWtSYXdEYXRhKCk7XG4gICAgfVxuICAgIGdldEdyYXBoZW1lQnJlYWtUeXBlKGNvZGVQb2ludCkge1xuICAgICAgICAvLyAhISEgTGV0J3MgbWFrZSA3Yml0IEFTQ0lJIGEgYml0IGZhc3RlcjogMC4uMzFcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiAzIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkxGICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBHcmFwaGVtZUJyZWFrVHlwZS5DUiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiA0IC8qIEdyYXBoZW1lQnJlYWtUeXBlLkNvbnRyb2wgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gISEhIExldCdzIG1ha2UgN2JpdCBBU0NJSSBhIGJpdCBmYXN0ZXI6IDMyLi4xMjZcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDEyNykge1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogR3JhcGhlbWVCcmVha1R5cGUuT3RoZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGNvbnN0IG5vZGVDb3VudCA9IGRhdGEubGVuZ3RoIC8gMztcbiAgICAgICAgbGV0IG5vZGVJbmRleCA9IDE7XG4gICAgICAgIHdoaWxlIChub2RlSW5kZXggPD0gbm9kZUNvdW50KSB7XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgZGF0YVszICogbm9kZUluZGV4XSkge1xuICAgICAgICAgICAgICAgIC8vIGdvIGxlZnRcbiAgICAgICAgICAgICAgICBub2RlSW5kZXggPSAyICogbm9kZUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50ID4gZGF0YVszICogbm9kZUluZGV4ICsgMV0pIHtcbiAgICAgICAgICAgICAgICAvLyBnbyByaWdodFxuICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IDIgKiBub2RlSW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaGl0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbMyAqIG5vZGVJbmRleCArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdyYXBoZW1lQnJlYWtUeXBlLk90aGVyICovO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEdyYXBoZW1lQnJlYWtSYXdEYXRhKCkge1xuICAgIC8vIGdlbmVyYXRlZCB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vYWxleGRpbWEvdW5pY29kZS11dGlscy9ibG9iL21haW4vZ3JhcGhlbWUtYnJlYWsuanNcbiAgICByZXR1cm4gSlNPTi5wYXJzZSgnWzAsMCwwLDUxMjI5LDUxMjU1LDEyLDQ0MDYxLDQ0MDg3LDEyLDEyNzQ2MiwxMjc0ODcsNiw3MDgzLDcwODUsNSw0NzY0NSw0NzY3MSwxMiw1NDgxMyw1NDgzOSwxMiwxMjg2NzgsMTI4Njc4LDE0LDMyNzAsMzI3MCw1LDk5MTksOTkyMywxNCw0NTg1Myw0NTg3OSwxMiw0OTQzNyw0OTQ2MywxMiw1MzAyMSw1MzA0NywxMiw3MTIxNiw3MTIxOCw3LDEyODM5OCwxMjgzOTksMTQsMTI5MzYwLDEyOTM3NCwxNCwyNTE5LDI1MTksNSw0NDQ4LDQ1MTksOSw5NzQyLDk3NDIsMTQsMTIzMzYsMTIzMzYsMTQsNDQ5NTcsNDQ5ODMsMTIsNDY3NDksNDY3NzUsMTIsNDg1NDEsNDg1NjcsMTIsNTAzMzMsNTAzNTksMTIsNTIxMjUsNTIxNTEsMTIsNTM5MTcsNTM5NDMsMTIsNjk4ODgsNjk4OTAsNSw3MzAxOCw3MzAxOCw1LDEyNzk5MCwxMjc5OTAsMTQsMTI4NTU4LDEyODU1OSwxNCwxMjg3NTksMTI4NzYwLDE0LDEyOTY1MywxMjk2NTUsMTQsMjAyNywyMDM1LDUsMjg5MSwyODkyLDcsMzc2MSwzNzYxLDUsNjY4Myw2NjgzLDUsODI5Myw4MjkzLDQsOTgyNSw5ODI2LDE0LDk5OTksOTk5OSwxNCw0MzQ1Miw0MzQ1Myw1LDQ0NTA5LDQ0NTM1LDEyLDQ1NDA1LDQ1NDMxLDEyLDQ2MzAxLDQ2MzI3LDEyLDQ3MTk3LDQ3MjIzLDEyLDQ4MDkzLDQ4MTE5LDEyLDQ4OTg5LDQ5MDE1LDEyLDQ5ODg1LDQ5OTExLDEyLDUwNzgxLDUwODA3LDEyLDUxNjc3LDUxNzAzLDEyLDUyNTczLDUyNTk5LDEyLDUzNDY5LDUzNDk1LDEyLDU0MzY1LDU0MzkxLDEyLDY1Mjc5LDY1Mjc5LDQsNzA0NzEsNzA0NzIsNyw3MjE0NSw3MjE0Nyw3LDExOTE3MywxMTkxNzksNSwxMjc3OTksMTI3ODE4LDE0LDEyODI0MCwxMjgyNDQsMTQsMTI4NTEyLDEyODUxMiwxNCwxMjg2NTIsMTI4NjUyLDE0LDEyODcyMSwxMjg3MjIsMTQsMTI5MjkyLDEyOTI5MiwxNCwxMjk0NDUsMTI5NDUwLDE0LDEyOTczNCwxMjk3NDMsMTQsMTQ3NiwxNDc3LDUsMjM2NiwyMzY4LDcsMjc1MCwyNzUyLDcsMzA3NiwzMDc2LDUsMzQxNSwzNDE1LDUsNDE0MSw0MTQ0LDUsNjEwOSw2MTA5LDUsNjk2NCw2OTY0LDUsNzM5NCw3NDAwLDUsOTE5Nyw5MTk4LDE0LDk3NzAsOTc3MCwxNCw5ODc3LDk4NzcsMTQsOTk2OCw5OTY5LDE0LDEwMDg0LDEwMDg0LDE0LDQzMDUyLDQzMDUyLDUsNDM3MTMsNDM3MTMsNSw0NDI4NSw0NDMxMSwxMiw0NDczMyw0NDc1OSwxMiw0NTE4MSw0NTIwNywxMiw0NTYyOSw0NTY1NSwxMiw0NjA3Nyw0NjEwMywxMiw0NjUyNSw0NjU1MSwxMiw0Njk3Myw0Njk5OSwxMiw0NzQyMSw0NzQ0NywxMiw0Nzg2OSw0Nzg5NSwxMiw0ODMxNyw0ODM0MywxMiw0ODc2NSw0ODc5MSwxMiw0OTIxMyw0OTIzOSwxMiw0OTY2MSw0OTY4NywxMiw1MDEwOSw1MDEzNSwxMiw1MDU1Nyw1MDU4MywxMiw1MTAwNSw1MTAzMSwxMiw1MTQ1Myw1MTQ3OSwxMiw1MTkwMSw1MTkyNywxMiw1MjM0OSw1MjM3NSwxMiw1Mjc5Nyw1MjgyMywxMiw1MzI0NSw1MzI3MSwxMiw1MzY5Myw1MzcxOSwxMiw1NDE0MSw1NDE2NywxMiw1NDU4OSw1NDYxNSwxMiw1NTAzNyw1NTA2MywxMiw2OTUwNiw2OTUwOSw1LDcwMTkxLDcwMTkzLDUsNzA4NDEsNzA4NDEsNyw3MTQ2Myw3MTQ2Nyw1LDcyMzMwLDcyMzQyLDUsOTQwMzEsOTQwMzEsNSwxMjM2MjgsMTIzNjMxLDUsMTI3NzYzLDEyNzc2NSwxNCwxMjc5NDEsMTI3OTQxLDE0LDEyODA0MywxMjgwNjIsMTQsMTI4MzAyLDEyODMxNywxNCwxMjg0NjUsMTI4NDY3LDE0LDEyODUzOSwxMjg1MzksMTQsMTI4NjQwLDEyODY0MCwxNCwxMjg2NjIsMTI4NjYyLDE0LDEyODcwMywxMjg3MDMsMTQsMTI4NzQ1LDEyODc0NSwxNCwxMjkwMDQsMTI5MDA3LDE0LDEyOTMyOSwxMjkzMzAsMTQsMTI5NDAyLDEyOTQwMiwxNCwxMjk0ODMsMTI5NDgzLDE0LDEyOTY4NiwxMjk3MDQsMTQsMTMwMDQ4LDEzMTA2OSwxNCwxNzMsMTczLDQsMTc1NywxNzU3LDEsMjIwMCwyMjA3LDUsMjQzNCwyNDM1LDcsMjYzMSwyNjMyLDUsMjgxNywyODE3LDUsMzAwOCwzMDA4LDUsMzIwMSwzMjAxLDUsMzM4NywzMzg4LDUsMzU0MiwzNTQyLDUsMzkwMiwzOTAzLDcsNDE5MCw0MTkyLDUsNjAwMiw2MDAzLDUsNjQzOSw2NDQwLDUsNjc2NSw2NzcwLDcsNzAxOSw3MDI3LDUsNzE1NCw3MTU1LDcsODIwNSw4MjA1LDEzLDg1MDUsODUwNSwxNCw5NjU0LDk2NTQsMTQsOTc1Nyw5NzU3LDE0LDk3OTIsOTc5MiwxNCw5ODUyLDk4NTMsMTQsOTg5MCw5ODk0LDE0LDk5MzcsOTkzNywxNCw5OTgxLDk5ODEsMTQsMTAwMzUsMTAwMzYsMTQsMTEwMzUsMTEwMzYsMTQsNDI2NTQsNDI2NTUsNSw0MzM0Niw0MzM0Nyw3LDQzNTg3LDQzNTg3LDUsNDQwMDYsNDQwMDcsNyw0NDE3Myw0NDE5OSwxMiw0NDM5Nyw0NDQyMywxMiw0NDYyMSw0NDY0NywxMiw0NDg0NSw0NDg3MSwxMiw0NTA2OSw0NTA5NSwxMiw0NTI5Myw0NTMxOSwxMiw0NTUxNyw0NTU0MywxMiw0NTc0MSw0NTc2NywxMiw0NTk2NSw0NTk5MSwxMiw0NjE4OSw0NjIxNSwxMiw0NjQxMyw0NjQzOSwxMiw0NjYzNyw0NjY2MywxMiw0Njg2MSw0Njg4NywxMiw0NzA4NSw0NzExMSwxMiw0NzMwOSw0NzMzNSwxMiw0NzUzMyw0NzU1OSwxMiw0Nzc1Nyw0Nzc4MywxMiw0Nzk4MSw0ODAwNywxMiw0ODIwNSw0ODIzMSwxMiw0ODQyOSw0ODQ1NSwxMiw0ODY1Myw0ODY3OSwxMiw0ODg3Nyw0ODkwMywxMiw0OTEwMSw0OTEyNywxMiw0OTMyNSw0OTM1MSwxMiw0OTU0OSw0OTU3NSwxMiw0OTc3Myw0OTc5OSwxMiw0OTk5Nyw1MDAyMywxMiw1MDIyMSw1MDI0NywxMiw1MDQ0NSw1MDQ3MSwxMiw1MDY2OSw1MDY5NSwxMiw1MDg5Myw1MDkxOSwxMiw1MTExNyw1MTE0MywxMiw1MTM0MSw1MTM2NywxMiw1MTU2NSw1MTU5MSwxMiw1MTc4OSw1MTgxNSwxMiw1MjAxMyw1MjAzOSwxMiw1MjIzNyw1MjI2MywxMiw1MjQ2MSw1MjQ4NywxMiw1MjY4NSw1MjcxMSwxMiw1MjkwOSw1MjkzNSwxMiw1MzEzMyw1MzE1OSwxMiw1MzM1Nyw1MzM4MywxMiw1MzU4MSw1MzYwNywxMiw1MzgwNSw1MzgzMSwxMiw1NDAyOSw1NDA1NSwxMiw1NDI1Myw1NDI3OSwxMiw1NDQ3Nyw1NDUwMywxMiw1NDcwMSw1NDcyNywxMiw1NDkyNSw1NDk1MSwxMiw1NTE0OSw1NTE3NSwxMiw2ODEwMSw2ODEwMiw1LDY5NzYyLDY5NzYyLDcsNzAwNjcsNzAwNjksNyw3MDM3MSw3MDM3OCw1LDcwNzIwLDcwNzIxLDcsNzEwODcsNzEwODcsNSw3MTM0MSw3MTM0MSw1LDcxOTk1LDcxOTk2LDUsNzIyNDksNzIyNDksNyw3Mjg1MCw3Mjg3MSw1LDczMTA5LDczMTA5LDUsMTE4NTc2LDExODU5OCw1LDEyMTUwNSwxMjE1MTksNSwxMjcyNDUsMTI3MjQ3LDE0LDEyNzU2OCwxMjc1NjksMTQsMTI3Nzc3LDEyNzc3NywxNCwxMjc4NzIsMTI3ODkxLDE0LDEyNzk1NiwxMjc5NjcsMTQsMTI4MDE1LDEyODAxNiwxNCwxMjgxMTAsMTI4MTcyLDE0LDEyODI1OSwxMjgyNTksMTQsMTI4MzY3LDEyODM2OCwxNCwxMjg0MjQsMTI4NDI0LDE0LDEyODQ4OCwxMjg0ODgsMTQsMTI4NTMwLDEyODUzMiwxNCwxMjg1NTAsMTI4NTUxLDE0LDEyODU2NiwxMjg1NjYsMTQsMTI4NjQ3LDEyODY0NywxNCwxMjg2NTYsMTI4NjU2LDE0LDEyODY2NywxMjg2NzMsMTQsMTI4NjkxLDEyODY5MywxNCwxMjg3MTUsMTI4NzE1LDE0LDEyODcyOCwxMjg3MzIsMTQsMTI4NzUyLDEyODc1MiwxNCwxMjg3NjUsMTI4NzY3LDE0LDEyOTA5NiwxMjkxMDMsMTQsMTI5MzExLDEyOTMxMSwxNCwxMjkzNDQsMTI5MzQ5LDE0LDEyOTM5NCwxMjkzOTQsMTQsMTI5NDEzLDEyOTQyNSwxNCwxMjk0NjYsMTI5NDcxLDE0LDEyOTUxMSwxMjk1MzUsMTQsMTI5NjY0LDEyOTY2NiwxNCwxMjk3MTksMTI5NzIyLDE0LDEyOTc2MCwxMjk3NjcsMTQsOTE3NTM2LDkxNzYzMSw1LDEzLDEzLDIsMTE2MCwxMTYxLDUsMTU2NCwxNTY0LDQsMTgwNywxODA3LDEsMjA4NSwyMDg3LDUsMjMwNywyMzA3LDcsMjM4MiwyMzgzLDcsMjQ5NywyNTAwLDUsMjU2MywyNTYzLDcsMjY3NywyNjc3LDUsMjc2MywyNzY0LDcsMjg3OSwyODc5LDUsMjkxNCwyOTE1LDUsMzAyMSwzMDIxLDUsMzE0MiwzMTQ0LDUsMzI2MywzMjYzLDUsMzI4NSwzMjg2LDUsMzM5OCwzNDAwLDcsMzUzMCwzNTMwLDUsMzYzMywzNjMzLDUsMzg2NCwzODY1LDUsMzk3NCwzOTc1LDUsNDE1NSw0MTU2LDcsNDIyOSw0MjMwLDUsNTkwOSw1OTA5LDcsNjA3OCw2MDg1LDcsNjI3Nyw2Mjc4LDUsNjQ1MSw2NDU2LDcsNjc0NCw2NzUwLDUsNjg0Niw2ODQ2LDUsNjk3Miw2OTcyLDUsNzA3NCw3MDc3LDUsNzE0Niw3MTQ4LDcsNzIyMiw3MjIzLDUsNzQxNiw3NDE3LDUsODIzNCw4MjM4LDQsODQxNyw4NDE3LDUsOTAwMCw5MDAwLDE0LDkyMDMsOTIwMywxNCw5NzMwLDk3MzEsMTQsOTc0OCw5NzQ5LDE0LDk3NjIsOTc2MywxNCw5Nzc2LDk3ODMsMTQsOTgwMCw5ODExLDE0LDk4MzEsOTgzMSwxNCw5ODcyLDk4NzMsMTQsOTg4Miw5ODgyLDE0LDk5MDAsOTkwMywxNCw5OTI5LDk5MzMsMTQsOTk0MSw5OTYwLDE0LDk5NzQsOTk3NCwxNCw5OTg5LDk5ODksMTQsMTAwMDYsMTAwMDYsMTQsMTAwNjIsMTAwNjIsMTQsMTAxNjAsMTAxNjAsMTQsMTE2NDcsMTE2NDcsNSwxMjk1MywxMjk1MywxNCw0MzAxOSw0MzAxOSw1LDQzMjMyLDQzMjQ5LDUsNDM0NDMsNDM0NDMsNSw0MzU2Nyw0MzU2OCw3LDQzNjk2LDQzNjk2LDUsNDM3NjUsNDM3NjUsNyw0NDAxMyw0NDAxMyw1LDQ0MTE3LDQ0MTQzLDEyLDQ0MjI5LDQ0MjU1LDEyLDQ0MzQxLDQ0MzY3LDEyLDQ0NDUzLDQ0NDc5LDEyLDQ0NTY1LDQ0NTkxLDEyLDQ0Njc3LDQ0NzAzLDEyLDQ0Nzg5LDQ0ODE1LDEyLDQ0OTAxLDQ0OTI3LDEyLDQ1MDEzLDQ1MDM5LDEyLDQ1MTI1LDQ1MTUxLDEyLDQ1MjM3LDQ1MjYzLDEyLDQ1MzQ5LDQ1Mzc1LDEyLDQ1NDYxLDQ1NDg3LDEyLDQ1NTczLDQ1NTk5LDEyLDQ1Njg1LDQ1NzExLDEyLDQ1Nzk3LDQ1ODIzLDEyLDQ1OTA5LDQ1OTM1LDEyLDQ2MDIxLDQ2MDQ3LDEyLDQ2MTMzLDQ2MTU5LDEyLDQ2MjQ1LDQ2MjcxLDEyLDQ2MzU3LDQ2MzgzLDEyLDQ2NDY5LDQ2NDk1LDEyLDQ2NTgxLDQ2NjA3LDEyLDQ2NjkzLDQ2NzE5LDEyLDQ2ODA1LDQ2ODMxLDEyLDQ2OTE3LDQ2OTQzLDEyLDQ3MDI5LDQ3MDU1LDEyLDQ3MTQxLDQ3MTY3LDEyLDQ3MjUzLDQ3Mjc5LDEyLDQ3MzY1LDQ3MzkxLDEyLDQ3NDc3LDQ3NTAzLDEyLDQ3NTg5LDQ3NjE1LDEyLDQ3NzAxLDQ3NzI3LDEyLDQ3ODEzLDQ3ODM5LDEyLDQ3OTI1LDQ3OTUxLDEyLDQ4MDM3LDQ4MDYzLDEyLDQ4MTQ5LDQ4MTc1LDEyLDQ4MjYxLDQ4Mjg3LDEyLDQ4MzczLDQ4Mzk5LDEyLDQ4NDg1LDQ4NTExLDEyLDQ4NTk3LDQ4NjIzLDEyLDQ4NzA5LDQ4NzM1LDEyLDQ4ODIxLDQ4ODQ3LDEyLDQ4OTMzLDQ4OTU5LDEyLDQ5MDQ1LDQ5MDcxLDEyLDQ5MTU3LDQ5MTgzLDEyLDQ5MjY5LDQ5Mjk1LDEyLDQ5MzgxLDQ5NDA3LDEyLDQ5NDkzLDQ5NTE5LDEyLDQ5NjA1LDQ5NjMxLDEyLDQ5NzE3LDQ5NzQzLDEyLDQ5ODI5LDQ5ODU1LDEyLDQ5OTQxLDQ5OTY3LDEyLDUwMDUzLDUwMDc5LDEyLDUwMTY1LDUwMTkxLDEyLDUwMjc3LDUwMzAzLDEyLDUwMzg5LDUwNDE1LDEyLDUwNTAxLDUwNTI3LDEyLDUwNjEzLDUwNjM5LDEyLDUwNzI1LDUwNzUxLDEyLDUwODM3LDUwODYzLDEyLDUwOTQ5LDUwOTc1LDEyLDUxMDYxLDUxMDg3LDEyLDUxMTczLDUxMTk5LDEyLDUxMjg1LDUxMzExLDEyLDUxMzk3LDUxNDIzLDEyLDUxNTA5LDUxNTM1LDEyLDUxNjIxLDUxNjQ3LDEyLDUxNzMzLDUxNzU5LDEyLDUxODQ1LDUxODcxLDEyLDUxOTU3LDUxOTgzLDEyLDUyMDY5LDUyMDk1LDEyLDUyMTgxLDUyMjA3LDEyLDUyMjkzLDUyMzE5LDEyLDUyNDA1LDUyNDMxLDEyLDUyNTE3LDUyNTQzLDEyLDUyNjI5LDUyNjU1LDEyLDUyNzQxLDUyNzY3LDEyLDUyODUzLDUyODc5LDEyLDUyOTY1LDUyOTkxLDEyLDUzMDc3LDUzMTAzLDEyLDUzMTg5LDUzMjE1LDEyLDUzMzAxLDUzMzI3LDEyLDUzNDEzLDUzNDM5LDEyLDUzNTI1LDUzNTUxLDEyLDUzNjM3LDUzNjYzLDEyLDUzNzQ5LDUzNzc1LDEyLDUzODYxLDUzODg3LDEyLDUzOTczLDUzOTk5LDEyLDU0MDg1LDU0MTExLDEyLDU0MTk3LDU0MjIzLDEyLDU0MzA5LDU0MzM1LDEyLDU0NDIxLDU0NDQ3LDEyLDU0NTMzLDU0NTU5LDEyLDU0NjQ1LDU0NjcxLDEyLDU0NzU3LDU0NzgzLDEyLDU0ODY5LDU0ODk1LDEyLDU0OTgxLDU1MDA3LDEyLDU1MDkzLDU1MTE5LDEyLDU1MjQzLDU1MjkxLDEwLDY2MDQ1LDY2MDQ1LDUsNjgzMjUsNjgzMjYsNSw2OTY4OCw2OTcwMiw1LDY5ODE3LDY5ODE4LDUsNjk5NTcsNjk5NTgsNyw3MDA4OSw3MDA5Miw1LDcwMTk4LDcwMTk5LDUsNzA0NjIsNzA0NjIsNSw3MDUwMiw3MDUwOCw1LDcwNzUwLDcwNzUwLDUsNzA4NDYsNzA4NDYsNyw3MTEwMCw3MTEwMSw1LDcxMjMwLDcxMjMwLDcsNzEzNTEsNzEzNTEsNSw3MTczNyw3MTczOCw1LDcyMDAwLDcyMDAwLDcsNzIxNjAsNzIxNjAsNSw3MjI3Myw3MjI3OCw1LDcyNzUyLDcyNzU4LDUsNzI4ODIsNzI4ODMsNSw3MzAzMSw3MzAzMSw1LDczNDYxLDczNDYyLDcsOTQxOTIsOTQxOTMsNywxMTkxNDksMTE5MTQ5LDcsMTIxNDAzLDEyMTQ1Miw1LDEyMjkxNSwxMjI5MTYsNSwxMjY5ODAsMTI2OTgwLDE0LDEyNzM1OCwxMjczNTksMTQsMTI3NTM1LDEyNzUzNSwxNCwxMjc3NTksMTI3NzU5LDE0LDEyNzc3MSwxMjc3NzEsMTQsMTI3NzkyLDEyNzc5MywxNCwxMjc4MjUsMTI3ODY3LDE0LDEyNzg5NywxMjc4OTksMTQsMTI3OTQ1LDEyNzk0NSwxNCwxMjc5ODUsMTI3OTg2LDE0LDEyODAwMCwxMjgwMDcsMTQsMTI4MDIxLDEyODAyMSwxNCwxMjgwNjYsMTI4MTAwLDE0LDEyODE4NCwxMjgyMzUsMTQsMTI4MjQ5LDEyODI1MiwxNCwxMjgyNjYsMTI4Mjc2LDE0LDEyODMzNSwxMjgzMzUsMTQsMTI4Mzc5LDEyODM5MCwxNCwxMjg0MDcsMTI4NDE5LDE0LDEyODQ0NCwxMjg0NDQsMTQsMTI4NDgxLDEyODQ4MSwxNCwxMjg0OTksMTI4NDk5LDE0LDEyODUyNiwxMjg1MjYsMTQsMTI4NTM2LDEyODUzNiwxNCwxMjg1NDMsMTI4NTQzLDE0LDEyODU1NiwxMjg1NTYsMTQsMTI4NTY0LDEyODU2NCwxNCwxMjg1NzcsMTI4NTgwLDE0LDEyODY0MywxMjg2NDUsMTQsMTI4NjQ5LDEyODY0OSwxNCwxMjg2NTQsMTI4NjU0LDE0LDEyODY2MCwxMjg2NjAsMTQsMTI4NjY0LDEyODY2NCwxNCwxMjg2NzUsMTI4Njc1LDE0LDEyODY4NiwxMjg2ODksMTQsMTI4Njk1LDEyODY5NiwxNCwxMjg3MDUsMTI4NzA5LDE0LDEyODcxNywxMjg3MTksMTQsMTI4NzI1LDEyODcyNSwxNCwxMjg3MzYsMTI4NzQxLDE0LDEyODc0NywxMjg3NDgsMTQsMTI4NzU1LDEyODc1NSwxNCwxMjg3NjIsMTI4NzYyLDE0LDEyODk4MSwxMjg5OTEsMTQsMTI5MDA5LDEyOTAyMywxNCwxMjkxNjAsMTI5MTY3LDE0LDEyOTI5NiwxMjkzMDQsMTQsMTI5MzIwLDEyOTMyNywxNCwxMjkzNDAsMTI5MzQyLDE0LDEyOTM1NiwxMjkzNTYsMTQsMTI5Mzg4LDEyOTM5MiwxNCwxMjkzOTksMTI5NDAwLDE0LDEyOTQwNCwxMjk0MDcsMTQsMTI5NDMyLDEyOTQ0MiwxNCwxMjk0NTQsMTI5NDU1LDE0LDEyOTQ3MywxMjk0NzQsMTQsMTI5NDg1LDEyOTQ4NywxNCwxMjk2NDgsMTI5NjUxLDE0LDEyOTY1OSwxMjk2NjAsMTQsMTI5NjcxLDEyOTY3OSwxNCwxMjk3MDksMTI5NzExLDE0LDEyOTcyOCwxMjk3MzAsMTQsMTI5NzUxLDEyOTc1MywxNCwxMjk3NzYsMTI5NzgyLDE0LDkxNzUwNSw5MTc1MDUsNCw5MTc3NjAsOTE3OTk5LDUsMTAsMTAsMywxMjcsMTU5LDQsNzY4LDg3OSw1LDE0NzEsMTQ3MSw1LDE1MzYsMTU0MSwxLDE2NDgsMTY0OCw1LDE3NjcsMTc2OCw1LDE4NDAsMTg2Niw1LDIwNzAsMjA3Myw1LDIxMzcsMjEzOSw1LDIyNzQsMjI3NCwxLDIzNjMsMjM2Myw3LDIzNzcsMjM4MCw3LDI0MDIsMjQwMyw1LDI0OTQsMjQ5NCw1LDI1MDcsMjUwOCw3LDI1NTgsMjU1OCw1LDI2MjIsMjYyNCw3LDI2NDEsMjY0MSw1LDI2OTEsMjY5MSw3LDI3NTksMjc2MCw1LDI3ODYsMjc4Nyw1LDI4NzYsMjg3Niw1LDI4ODEsMjg4NCw1LDI5MDEsMjkwMiw1LDMwMDYsMzAwNiw1LDMwMTQsMzAxNiw3LDMwNzIsMzA3Miw1LDMxMzQsMzEzNiw1LDMxNTcsMzE1OCw1LDMyNjAsMzI2MCw1LDMyNjYsMzI2Niw1LDMyNzQsMzI3NSw3LDMzMjgsMzMyOSw1LDMzOTEsMzM5Miw3LDM0MDUsMzQwNSw1LDM0NTcsMzQ1Nyw1LDM1MzYsMzUzNyw3LDM1NTEsMzU1MSw1LDM2MzYsMzY0Miw1LDM3NjQsMzc3Miw1LDM4OTUsMzg5NSw1LDM5NjcsMzk2Nyw3LDM5OTMsNDAyOCw1LDQxNDYsNDE1MSw1LDQxODIsNDE4Myw3LDQyMjYsNDIyNiw1LDQyNTMsNDI1Myw1LDQ5NTcsNDk1OSw1LDU5NDAsNTk0MCw3LDYwNzAsNjA3MCw3LDYwODcsNjA4OCw3LDYxNTgsNjE1OCw0LDY0MzIsNjQzNCw1LDY0NDgsNjQ0OSw3LDY2NzksNjY4MCw1LDY3NDIsNjc0Miw1LDY3NTQsNjc1NCw1LDY3ODMsNjc4Myw1LDY5MTIsNjkxNSw1LDY5NjYsNjk3MCw1LDY5NzgsNjk3OCw1LDcwNDIsNzA0Miw3LDcwODAsNzA4MSw1LDcxNDMsNzE0Myw3LDcxNTAsNzE1MCw3LDcyMTIsNzIxOSw1LDczODAsNzM5Miw1LDc0MTIsNzQxMiw1LDgyMDMsODIwMyw0LDgyMzIsODIzMiw0LDgyNjUsODI2NSwxNCw4NDAwLDg0MTIsNSw4NDIxLDg0MzIsNSw4NjE3LDg2MTgsMTQsOTE2Nyw5MTY3LDE0LDkyMDAsOTIwMCwxNCw5NDEwLDk0MTAsMTQsOTcyMyw5NzI2LDE0LDk3MzMsOTczMywxNCw5NzQ1LDk3NDUsMTQsOTc1Miw5NzUyLDE0LDk3NjAsOTc2MCwxNCw5NzY2LDk3NjYsMTQsOTc3NCw5Nzc0LDE0LDk3ODYsOTc4NiwxNCw5Nzk0LDk3OTQsMTQsOTgyMyw5ODIzLDE0LDk4MjgsOTgyOCwxNCw5ODMzLDk4NTAsMTQsOTg1NSw5ODU1LDE0LDk4NzUsOTg3NSwxNCw5ODgwLDk4ODAsMTQsOTg4NSw5ODg3LDE0LDk4OTYsOTg5NywxNCw5OTA2LDk5MTYsMTQsOTkyNiw5OTI3LDE0LDk5MzUsOTkzNSwxNCw5OTM5LDk5MzksMTQsOTk2Miw5OTYyLDE0LDk5NzIsOTk3MiwxNCw5OTc4LDk5NzgsMTQsOTk4Niw5OTg2LDE0LDk5OTcsOTk5NywxNCwxMDAwMiwxMDAwMiwxNCwxMDAxNywxMDAxNywxNCwxMDA1NSwxMDA1NSwxNCwxMDA3MSwxMDA3MSwxNCwxMDEzMywxMDEzNSwxNCwxMDU0OCwxMDU0OSwxNCwxMTA5MywxMTA5MywxNCwxMjMzMCwxMjMzMyw1LDEyNDQxLDEyNDQyLDUsNDI2MDgsNDI2MTAsNSw0MzAxMCw0MzAxMCw1LDQzMDQ1LDQzMDQ2LDUsNDMxODgsNDMyMDMsNyw0MzMwMiw0MzMwOSw1LDQzMzkyLDQzMzk0LDUsNDM0NDYsNDM0NDksNSw0MzQ5Myw0MzQ5Myw1LDQzNTcxLDQzNTcyLDcsNDM1OTcsNDM1OTcsNyw0MzcwMyw0MzcwNCw1LDQzNzU2LDQzNzU3LDUsNDQwMDMsNDQwMDQsNyw0NDAwOSw0NDAxMCw3LDQ0MDMzLDQ0MDU5LDEyLDQ0MDg5LDQ0MTE1LDEyLDQ0MTQ1LDQ0MTcxLDEyLDQ0MjAxLDQ0MjI3LDEyLDQ0MjU3LDQ0MjgzLDEyLDQ0MzEzLDQ0MzM5LDEyLDQ0MzY5LDQ0Mzk1LDEyLDQ0NDI1LDQ0NDUxLDEyLDQ0NDgxLDQ0NTA3LDEyLDQ0NTM3LDQ0NTYzLDEyLDQ0NTkzLDQ0NjE5LDEyLDQ0NjQ5LDQ0Njc1LDEyLDQ0NzA1LDQ0NzMxLDEyLDQ0NzYxLDQ0Nzg3LDEyLDQ0ODE3LDQ0ODQzLDEyLDQ0ODczLDQ0ODk5LDEyLDQ0OTI5LDQ0OTU1LDEyLDQ0OTg1LDQ1MDExLDEyLDQ1MDQxLDQ1MDY3LDEyLDQ1MDk3LDQ1MTIzLDEyLDQ1MTUzLDQ1MTc5LDEyLDQ1MjA5LDQ1MjM1LDEyLDQ1MjY1LDQ1MjkxLDEyLDQ1MzIxLDQ1MzQ3LDEyLDQ1Mzc3LDQ1NDAzLDEyLDQ1NDMzLDQ1NDU5LDEyLDQ1NDg5LDQ1NTE1LDEyLDQ1NTQ1LDQ1NTcxLDEyLDQ1NjAxLDQ1NjI3LDEyLDQ1NjU3LDQ1NjgzLDEyLDQ1NzEzLDQ1NzM5LDEyLDQ1NzY5LDQ1Nzk1LDEyLDQ1ODI1LDQ1ODUxLDEyLDQ1ODgxLDQ1OTA3LDEyLDQ1OTM3LDQ1OTYzLDEyLDQ1OTkzLDQ2MDE5LDEyLDQ2MDQ5LDQ2MDc1LDEyLDQ2MTA1LDQ2MTMxLDEyLDQ2MTYxLDQ2MTg3LDEyLDQ2MjE3LDQ2MjQzLDEyLDQ2MjczLDQ2Mjk5LDEyLDQ2MzI5LDQ2MzU1LDEyLDQ2Mzg1LDQ2NDExLDEyLDQ2NDQxLDQ2NDY3LDEyLDQ2NDk3LDQ2NTIzLDEyLDQ2NTUzLDQ2NTc5LDEyLDQ2NjA5LDQ2NjM1LDEyLDQ2NjY1LDQ2NjkxLDEyLDQ2NzIxLDQ2NzQ3LDEyLDQ2Nzc3LDQ2ODAzLDEyLDQ2ODMzLDQ2ODU5LDEyLDQ2ODg5LDQ2OTE1LDEyLDQ2OTQ1LDQ2OTcxLDEyLDQ3MDAxLDQ3MDI3LDEyLDQ3MDU3LDQ3MDgzLDEyLDQ3MTEzLDQ3MTM5LDEyLDQ3MTY5LDQ3MTk1LDEyLDQ3MjI1LDQ3MjUxLDEyLDQ3MjgxLDQ3MzA3LDEyLDQ3MzM3LDQ3MzYzLDEyLDQ3MzkzLDQ3NDE5LDEyLDQ3NDQ5LDQ3NDc1LDEyLDQ3NTA1LDQ3NTMxLDEyLDQ3NTYxLDQ3NTg3LDEyLDQ3NjE3LDQ3NjQzLDEyLDQ3NjczLDQ3Njk5LDEyLDQ3NzI5LDQ3NzU1LDEyLDQ3Nzg1LDQ3ODExLDEyLDQ3ODQxLDQ3ODY3LDEyLDQ3ODk3LDQ3OTIzLDEyLDQ3OTUzLDQ3OTc5LDEyLDQ4MDA5LDQ4MDM1LDEyLDQ4MDY1LDQ4MDkxLDEyLDQ4MTIxLDQ4MTQ3LDEyLDQ4MTc3LDQ4MjAzLDEyLDQ4MjMzLDQ4MjU5LDEyLDQ4Mjg5LDQ4MzE1LDEyLDQ4MzQ1LDQ4MzcxLDEyLDQ4NDAxLDQ4NDI3LDEyLDQ4NDU3LDQ4NDgzLDEyLDQ4NTEzLDQ4NTM5LDEyLDQ4NTY5LDQ4NTk1LDEyLDQ4NjI1LDQ4NjUxLDEyLDQ4NjgxLDQ4NzA3LDEyLDQ4NzM3LDQ4NzYzLDEyLDQ4NzkzLDQ4ODE5LDEyLDQ4ODQ5LDQ4ODc1LDEyLDQ4OTA1LDQ4OTMxLDEyLDQ4OTYxLDQ4OTg3LDEyLDQ5MDE3LDQ5MDQzLDEyLDQ5MDczLDQ5MDk5LDEyLDQ5MTI5LDQ5MTU1LDEyLDQ5MTg1LDQ5MjExLDEyLDQ5MjQxLDQ5MjY3LDEyLDQ5Mjk3LDQ5MzIzLDEyLDQ5MzUzLDQ5Mzc5LDEyLDQ5NDA5LDQ5NDM1LDEyLDQ5NDY1LDQ5NDkxLDEyLDQ5NTIxLDQ5NTQ3LDEyLDQ5NTc3LDQ5NjAzLDEyLDQ5NjMzLDQ5NjU5LDEyLDQ5Njg5LDQ5NzE1LDEyLDQ5NzQ1LDQ5NzcxLDEyLDQ5ODAxLDQ5ODI3LDEyLDQ5ODU3LDQ5ODgzLDEyLDQ5OTEzLDQ5OTM5LDEyLDQ5OTY5LDQ5OTk1LDEyLDUwMDI1LDUwMDUxLDEyLDUwMDgxLDUwMTA3LDEyLDUwMTM3LDUwMTYzLDEyLDUwMTkzLDUwMjE5LDEyLDUwMjQ5LDUwMjc1LDEyLDUwMzA1LDUwMzMxLDEyLDUwMzYxLDUwMzg3LDEyLDUwNDE3LDUwNDQzLDEyLDUwNDczLDUwNDk5LDEyLDUwNTI5LDUwNTU1LDEyLDUwNTg1LDUwNjExLDEyLDUwNjQxLDUwNjY3LDEyLDUwNjk3LDUwNzIzLDEyLDUwNzUzLDUwNzc5LDEyLDUwODA5LDUwODM1LDEyLDUwODY1LDUwODkxLDEyLDUwOTIxLDUwOTQ3LDEyLDUwOTc3LDUxMDAzLDEyLDUxMDMzLDUxMDU5LDEyLDUxMDg5LDUxMTE1LDEyLDUxMTQ1LDUxMTcxLDEyLDUxMjAxLDUxMjI3LDEyLDUxMjU3LDUxMjgzLDEyLDUxMzEzLDUxMzM5LDEyLDUxMzY5LDUxMzk1LDEyLDUxNDI1LDUxNDUxLDEyLDUxNDgxLDUxNTA3LDEyLDUxNTM3LDUxNTYzLDEyLDUxNTkzLDUxNjE5LDEyLDUxNjQ5LDUxNjc1LDEyLDUxNzA1LDUxNzMxLDEyLDUxNzYxLDUxNzg3LDEyLDUxODE3LDUxODQzLDEyLDUxODczLDUxODk5LDEyLDUxOTI5LDUxOTU1LDEyLDUxOTg1LDUyMDExLDEyLDUyMDQxLDUyMDY3LDEyLDUyMDk3LDUyMTIzLDEyLDUyMTUzLDUyMTc5LDEyLDUyMjA5LDUyMjM1LDEyLDUyMjY1LDUyMjkxLDEyLDUyMzIxLDUyMzQ3LDEyLDUyMzc3LDUyNDAzLDEyLDUyNDMzLDUyNDU5LDEyLDUyNDg5LDUyNTE1LDEyLDUyNTQ1LDUyNTcxLDEyLDUyNjAxLDUyNjI3LDEyLDUyNjU3LDUyNjgzLDEyLDUyNzEzLDUyNzM5LDEyLDUyNzY5LDUyNzk1LDEyLDUyODI1LDUyODUxLDEyLDUyODgxLDUyOTA3LDEyLDUyOTM3LDUyOTYzLDEyLDUyOTkzLDUzMDE5LDEyLDUzMDQ5LDUzMDc1LDEyLDUzMTA1LDUzMTMxLDEyLDUzMTYxLDUzMTg3LDEyLDUzMjE3LDUzMjQzLDEyLDUzMjczLDUzMjk5LDEyLDUzMzI5LDUzMzU1LDEyLDUzMzg1LDUzNDExLDEyLDUzNDQxLDUzNDY3LDEyLDUzNDk3LDUzNTIzLDEyLDUzNTUzLDUzNTc5LDEyLDUzNjA5LDUzNjM1LDEyLDUzNjY1LDUzNjkxLDEyLDUzNzIxLDUzNzQ3LDEyLDUzNzc3LDUzODAzLDEyLDUzODMzLDUzODU5LDEyLDUzODg5LDUzOTE1LDEyLDUzOTQ1LDUzOTcxLDEyLDU0MDAxLDU0MDI3LDEyLDU0MDU3LDU0MDgzLDEyLDU0MTEzLDU0MTM5LDEyLDU0MTY5LDU0MTk1LDEyLDU0MjI1LDU0MjUxLDEyLDU0MjgxLDU0MzA3LDEyLDU0MzM3LDU0MzYzLDEyLDU0MzkzLDU0NDE5LDEyLDU0NDQ5LDU0NDc1LDEyLDU0NTA1LDU0NTMxLDEyLDU0NTYxLDU0NTg3LDEyLDU0NjE3LDU0NjQzLDEyLDU0NjczLDU0Njk5LDEyLDU0NzI5LDU0NzU1LDEyLDU0Nzg1LDU0ODExLDEyLDU0ODQxLDU0ODY3LDEyLDU0ODk3LDU0OTIzLDEyLDU0OTUzLDU0OTc5LDEyLDU1MDA5LDU1MDM1LDEyLDU1MDY1LDU1MDkxLDEyLDU1MTIxLDU1MTQ3LDEyLDU1MTc3LDU1MjAzLDEyLDY1MDI0LDY1MDM5LDUsNjU1MjAsNjU1MjgsNCw2NjQyMiw2NjQyNiw1LDY4MTUyLDY4MTU0LDUsNjkyOTEsNjkyOTIsNSw2OTYzMyw2OTYzMyw1LDY5NzQ3LDY5NzQ4LDUsNjk4MTEsNjk4MTQsNSw2OTgyNiw2OTgyNiw1LDY5OTMyLDY5OTMyLDcsNzAwMTYsNzAwMTcsNSw3MDA3OSw3MDA4MCw3LDcwMDk1LDcwMDk1LDUsNzAxOTYsNzAxOTYsNSw3MDM2Nyw3MDM2Nyw1LDcwNDAyLDcwNDAzLDcsNzA0NjQsNzA0NjQsNSw3MDQ4Nyw3MDQ4Nyw1LDcwNzA5LDcwNzExLDcsNzA3MjUsNzA3MjUsNyw3MDgzMyw3MDgzNCw3LDcwODQzLDcwODQ0LDcsNzA4NDksNzA4NDksNyw3MTA5MCw3MTA5Myw1LDcxMTAzLDcxMTA0LDUsNzEyMjcsNzEyMjgsNyw3MTMzOSw3MTMzOSw1LDcxMzQ0LDcxMzQ5LDUsNzE0NTgsNzE0NjEsNSw3MTcyNyw3MTczNSw1LDcxOTg1LDcxOTg5LDcsNzE5OTgsNzE5OTgsNSw3MjAwMiw3MjAwMiw3LDcyMTU0LDcyMTU1LDUsNzIxOTMsNzIyMDIsNSw3MjI1MSw3MjI1NCw1LDcyMjgxLDcyMjgzLDUsNzIzNDQsNzIzNDUsNSw3Mjc2Niw3Mjc2Niw3LDcyODc0LDcyODgwLDUsNzI4ODUsNzI4ODYsNSw3MzAyMyw3MzAyOSw1LDczMTA0LDczMTA1LDUsNzMxMTEsNzMxMTEsNSw5MjkxMiw5MjkxNiw1LDk0MDk1LDk0MDk4LDUsMTEzODI0LDExMzgyNyw0LDExOTE0MiwxMTkxNDIsNywxMTkxNTUsMTE5MTYyLDQsMTE5MzYyLDExOTM2NCw1LDEyMTQ3NiwxMjE0NzYsNSwxMjI4ODgsMTIyOTA0LDUsMTIzMTg0LDEyMzE5MCw1LDEyNTI1MiwxMjUyNTgsNSwxMjcxODMsMTI3MTgzLDE0LDEyNzM0MCwxMjczNDMsMTQsMTI3Mzc3LDEyNzM4NiwxNCwxMjc0OTEsMTI3NTAzLDE0LDEyNzU0OCwxMjc1NTEsMTQsMTI3NzQ0LDEyNzc1NiwxNCwxMjc3NjEsMTI3NzYxLDE0LDEyNzc2OSwxMjc3NjksMTQsMTI3NzczLDEyNzc3NCwxNCwxMjc3ODAsMTI3Nzg4LDE0LDEyNzc5NiwxMjc3OTcsMTQsMTI3ODIwLDEyNzgyMywxNCwxMjc4NjksMTI3ODY5LDE0LDEyNzg5NCwxMjc4OTUsMTQsMTI3OTAyLDEyNzkwMywxNCwxMjc5NDMsMTI3OTQzLDE0LDEyNzk0NywxMjc5NTAsMTQsMTI3OTcyLDEyNzk3MiwxNCwxMjc5ODgsMTI3OTg4LDE0LDEyNzk5MiwxMjc5OTQsMTQsMTI4MDA5LDEyODAxMSwxNCwxMjgwMTksMTI4MDE5LDE0LDEyODAyMywxMjgwNDEsMTQsMTI4MDY0LDEyODA2NCwxNCwxMjgxMDIsMTI4MTA3LDE0LDEyODE3NCwxMjgxODEsMTQsMTI4MjM4LDEyODIzOCwxNCwxMjgyNDYsMTI4MjQ3LDE0LDEyODI1NCwxMjgyNTQsMTQsMTI4MjY0LDEyODI2NCwxNCwxMjgyNzgsMTI4Mjk5LDE0LDEyODMyOSwxMjgzMzAsMTQsMTI4MzQ4LDEyODM1OSwxNCwxMjgzNzEsMTI4Mzc3LDE0LDEyODM5MiwxMjgzOTMsMTQsMTI4NDAxLDEyODQwNCwxNCwxMjg0MjEsMTI4NDIxLDE0LDEyODQzMywxMjg0MzQsMTQsMTI4NDUwLDEyODQ1MiwxNCwxMjg0NzYsMTI4NDc4LDE0LDEyODQ4MywxMjg0ODMsMTQsMTI4NDk1LDEyODQ5NSwxNCwxMjg1MDYsMTI4NTA2LDE0LDEyODUxOSwxMjg1MjAsMTQsMTI4NTI4LDEyODUyOCwxNCwxMjg1MzQsMTI4NTM0LDE0LDEyODUzOCwxMjg1MzgsMTQsMTI4NTQwLDEyODU0MiwxNCwxMjg1NDQsMTI4NTQ5LDE0LDEyODU1MiwxMjg1NTUsMTQsMTI4NTU3LDEyODU1NywxNCwxMjg1NjAsMTI4NTYzLDE0LDEyODU2NSwxMjg1NjUsMTQsMTI4NTY3LDEyODU3NiwxNCwxMjg1ODEsMTI4NTkxLDE0LDEyODY0MSwxMjg2NDIsMTQsMTI4NjQ2LDEyODY0NiwxNCwxMjg2NDgsMTI4NjQ4LDE0LDEyODY1MCwxMjg2NTEsMTQsMTI4NjUzLDEyODY1MywxNCwxMjg2NTUsMTI4NjU1LDE0LDEyODY1NywxMjg2NTksMTQsMTI4NjYxLDEyODY2MSwxNCwxMjg2NjMsMTI4NjYzLDE0LDEyODY2NSwxMjg2NjYsMTQsMTI4Njc0LDEyODY3NCwxNCwxMjg2NzYsMTI4Njc3LDE0LDEyODY3OSwxMjg2ODUsMTQsMTI4NjkwLDEyODY5MCwxNCwxMjg2OTQsMTI4Njk0LDE0LDEyODY5NywxMjg3MDIsMTQsMTI4NzA0LDEyODcwNCwxNCwxMjg3MTAsMTI4NzE0LDE0LDEyODcxNiwxMjg3MTYsMTQsMTI4NzIwLDEyODcyMCwxNCwxMjg3MjMsMTI4NzI0LDE0LDEyODcyNiwxMjg3MjcsMTQsMTI4NzMzLDEyODczNSwxNCwxMjg3NDIsMTI4NzQ0LDE0LDEyODc0NiwxMjg3NDYsMTQsMTI4NzQ5LDEyODc1MSwxNCwxMjg3NTMsMTI4NzU0LDE0LDEyODc1NiwxMjg3NTgsMTQsMTI4NzYxLDEyODc2MSwxNCwxMjg3NjMsMTI4NzY0LDE0LDEyODg4NCwxMjg4OTUsMTQsMTI4OTkyLDEyOTAwMywxNCwxMjkwMDgsMTI5MDA4LDE0LDEyOTAzNiwxMjkwMzksMTQsMTI5MTE0LDEyOTExOSwxNCwxMjkxOTgsMTI5Mjc5LDE0LDEyOTI5MywxMjkyOTUsMTQsMTI5MzA1LDEyOTMxMCwxNCwxMjkzMTIsMTI5MzE5LDE0LDEyOTMyOCwxMjkzMjgsMTQsMTI5MzMxLDEyOTMzOCwxNCwxMjkzNDMsMTI5MzQzLDE0LDEyOTM1MSwxMjkzNTUsMTQsMTI5MzU3LDEyOTM1OSwxNCwxMjkzNzUsMTI5Mzg3LDE0LDEyOTM5MywxMjkzOTMsMTQsMTI5Mzk1LDEyOTM5OCwxNCwxMjk0MDEsMTI5NDAxLDE0LDEyOTQwMywxMjk0MDMsMTQsMTI5NDA4LDEyOTQxMiwxNCwxMjk0MjYsMTI5NDMxLDE0LDEyOTQ0MywxMjk0NDQsMTQsMTI5NDUxLDEyOTQ1MywxNCwxMjk0NTYsMTI5NDY1LDE0LDEyOTQ3MiwxMjk0NzIsMTQsMTI5NDc1LDEyOTQ4MiwxNCwxMjk0ODQsMTI5NDg0LDE0LDEyOTQ4OCwxMjk1MTAsMTQsMTI5NTM2LDEyOTY0NywxNCwxMjk2NTIsMTI5NjUyLDE0LDEyOTY1NiwxMjk2NTgsMTQsMTI5NjYxLDEyOTY2MywxNCwxMjk2NjcsMTI5NjcwLDE0LDEyOTY4MCwxMjk2ODUsMTQsMTI5NzA1LDEyOTcwOCwxNCwxMjk3MTIsMTI5NzE4LDE0LDEyOTcyMywxMjk3MjcsMTQsMTI5NzMxLDEyOTczMywxNCwxMjk3NDQsMTI5NzUwLDE0LDEyOTc1NCwxMjk3NTksMTQsMTI5NzY4LDEyOTc3NSwxNCwxMjk3ODMsMTI5NzkxLDE0LDkxNzUwNCw5MTc1MDQsNCw5MTc1MDYsOTE3NTM1LDQsOTE3NjMyLDkxNzc1OSw0LDkxODAwMCw5MjE1OTksNCwwLDksNCwxMSwxMiw0LDE0LDMxLDQsMTY5LDE2OSwxNCwxNzQsMTc0LDE0LDExNTUsMTE1OSw1LDE0MjUsMTQ2OSw1LDE0NzMsMTQ3NCw1LDE0NzksMTQ3OSw1LDE1NTIsMTU2Miw1LDE2MTEsMTYzMSw1LDE3NTAsMTc1Niw1LDE3NTksMTc2NCw1LDE3NzAsMTc3Myw1LDE4MDksMTgwOSw1LDE5NTgsMTk2OCw1LDIwNDUsMjA0NSw1LDIwNzUsMjA4Myw1LDIwODksMjA5Myw1LDIxOTIsMjE5MywxLDIyNTAsMjI3Myw1LDIyNzUsMjMwNiw1LDIzNjIsMjM2Miw1LDIzNjQsMjM2NCw1LDIzNjksMjM3Niw1LDIzODEsMjM4MSw1LDIzODUsMjM5MSw1LDI0MzMsMjQzMyw1LDI0OTIsMjQ5Miw1LDI0OTUsMjQ5Niw3LDI1MDMsMjUwNCw3LDI1MDksMjUwOSw1LDI1MzAsMjUzMSw1LDI1NjEsMjU2Miw1LDI2MjAsMjYyMCw1LDI2MjUsMjYyNiw1LDI2MzUsMjYzNyw1LDI2NzIsMjY3Myw1LDI2ODksMjY5MCw1LDI3NDgsMjc0OCw1LDI3NTMsMjc1Nyw1LDI3NjEsMjc2MSw3LDI3NjUsMjc2NSw1LDI4MTAsMjgxNSw1LDI4MTgsMjgxOSw3LDI4NzgsMjg3OCw1LDI4ODAsMjg4MCw3LDI4ODcsMjg4OCw3LDI4OTMsMjg5Myw1LDI5MDMsMjkwMyw1LDI5NDYsMjk0Niw1LDMwMDcsMzAwNyw3LDMwMDksMzAxMCw3LDMwMTgsMzAyMCw3LDMwMzEsMzAzMSw1LDMwNzMsMzA3NSw3LDMxMzIsMzEzMiw1LDMxMzcsMzE0MCw3LDMxNDYsMzE0OSw1LDMxNzAsMzE3MSw1LDMyMDIsMzIwMyw3LDMyNjIsMzI2Miw3LDMyNjQsMzI2NSw3LDMyNjcsMzI2OCw3LDMyNzEsMzI3Miw3LDMyNzYsMzI3Nyw1LDMyOTgsMzI5OSw1LDMzMzAsMzMzMSw3LDMzOTAsMzM5MCw1LDMzOTMsMzM5Niw1LDM0MDIsMzQwNCw3LDM0MDYsMzQwNiwxLDM0MjYsMzQyNyw1LDM0NTgsMzQ1OSw3LDM1MzUsMzUzNSw1LDM1MzgsMzU0MCw1LDM1NDQsMzU1MCw3LDM1NzAsMzU3MSw3LDM2MzUsMzYzNSw3LDM2NTUsMzY2Miw1LDM3NjMsMzc2Myw3LDM3ODQsMzc4OSw1LDM4OTMsMzg5Myw1LDM4OTcsMzg5Nyw1LDM5NTMsMzk2Niw1LDM5NjgsMzk3Miw1LDM5ODEsMzk5MSw1LDQwMzgsNDAzOCw1LDQxNDUsNDE0NSw3LDQxNTMsNDE1NCw1LDQxNTcsNDE1OCw1LDQxODQsNDE4NSw1LDQyMDksNDIxMiw1LDQyMjgsNDIyOCw3LDQyMzcsNDIzNyw1LDQzNTIsNDQ0Nyw4LDQ1MjAsNDYwNywxMCw1OTA2LDU5MDgsNSw1OTM4LDU5MzksNSw1OTcwLDU5NzEsNSw2MDY4LDYwNjksNSw2MDcxLDYwNzcsNSw2MDg2LDYwODYsNSw2MDg5LDYwOTksNSw2MTU1LDYxNTcsNSw2MTU5LDYxNTksNSw2MzEzLDYzMTMsNSw2NDM1LDY0MzgsNyw2NDQxLDY0NDMsNyw2NDUwLDY0NTAsNSw2NDU3LDY0NTksNSw2NjgxLDY2ODIsNyw2NzQxLDY3NDEsNyw2NzQzLDY3NDMsNyw2NzUyLDY3NTIsNSw2NzU3LDY3NjQsNSw2NzcxLDY3ODAsNSw2ODMyLDY4NDUsNSw2ODQ3LDY4NjIsNSw2OTE2LDY5MTYsNyw2OTY1LDY5NjUsNSw2OTcxLDY5NzEsNyw2OTczLDY5NzcsNyw2OTc5LDY5ODAsNyw3MDQwLDcwNDEsNSw3MDczLDcwNzMsNyw3MDc4LDcwNzksNyw3MDgyLDcwODIsNyw3MTQyLDcxNDIsNSw3MTQ0LDcxNDUsNSw3MTQ5LDcxNDksNSw3MTUxLDcxNTMsNSw3MjA0LDcyMTEsNyw3MjIwLDcyMjEsNyw3Mzc2LDczNzgsNSw3MzkzLDczOTMsNyw3NDA1LDc0MDUsNSw3NDE1LDc0MTUsNyw3NjE2LDc2NzksNSw4MjA0LDgyMDQsNSw4MjA2LDgyMDcsNCw4MjMzLDgyMzMsNCw4MjUyLDgyNTIsMTQsODI4OCw4MjkyLDQsODI5NCw4MzAzLDQsODQxMyw4NDE2LDUsODQxOCw4NDIwLDUsODQ4Miw4NDgyLDE0LDg1OTYsODYwMSwxNCw4OTg2LDg5ODcsMTQsOTA5Niw5MDk2LDE0LDkxOTMsOTE5NiwxNCw5MTk5LDkxOTksMTQsOTIwMSw5MjAyLDE0LDkyMDgsOTIxMCwxNCw5NjQyLDk2NDMsMTQsOTY2NCw5NjY0LDE0LDk3MjgsOTcyOSwxNCw5NzMyLDk3MzIsMTQsOTczNSw5NzQxLDE0LDk3NDMsOTc0NCwxNCw5NzQ2LDk3NDYsMTQsOTc1MCw5NzUxLDE0LDk3NTMsOTc1NiwxNCw5NzU4LDk3NTksMTQsOTc2MSw5NzYxLDE0LDk3NjQsOTc2NSwxNCw5NzY3LDk3NjksMTQsOTc3MSw5NzczLDE0LDk3NzUsOTc3NSwxNCw5Nzg0LDk3ODUsMTQsOTc4Nyw5NzkxLDE0LDk3OTMsOTc5MywxNCw5Nzk1LDk3OTksMTQsOTgxMiw5ODIyLDE0LDk4MjQsOTgyNCwxNCw5ODI3LDk4MjcsMTQsOTgyOSw5ODMwLDE0LDk4MzIsOTgzMiwxNCw5ODUxLDk4NTEsMTQsOTg1NCw5ODU0LDE0LDk4NTYsOTg2MSwxNCw5ODc0LDk4NzQsMTQsOTg3Niw5ODc2LDE0LDk4NzgsOTg3OSwxNCw5ODgxLDk4ODEsMTQsOTg4Myw5ODg0LDE0LDk4ODgsOTg4OSwxNCw5ODk1LDk4OTUsMTQsOTg5OCw5ODk5LDE0LDk5MDQsOTkwNSwxNCw5OTE3LDk5MTgsMTQsOTkyNCw5OTI1LDE0LDk5MjgsOTkyOCwxNCw5OTM0LDk5MzQsMTQsOTkzNiw5OTM2LDE0LDk5MzgsOTkzOCwxNCw5OTQwLDk5NDAsMTQsOTk2MSw5OTYxLDE0LDk5NjMsOTk2NywxNCw5OTcwLDk5NzEsMTQsOTk3Myw5OTczLDE0LDk5NzUsOTk3NywxNCw5OTc5LDk5ODAsMTQsOTk4Miw5OTg1LDE0LDk5ODcsOTk4OCwxNCw5OTkyLDk5OTYsMTQsOTk5OCw5OTk4LDE0LDEwMDAwLDEwMDAxLDE0LDEwMDA0LDEwMDA0LDE0LDEwMDEzLDEwMDEzLDE0LDEwMDI0LDEwMDI0LDE0LDEwMDUyLDEwMDUyLDE0LDEwMDYwLDEwMDYwLDE0LDEwMDY3LDEwMDY5LDE0LDEwMDgzLDEwMDgzLDE0LDEwMDg1LDEwMDg3LDE0LDEwMTQ1LDEwMTQ1LDE0LDEwMTc1LDEwMTc1LDE0LDExMDEzLDExMDE1LDE0LDExMDg4LDExMDg4LDE0LDExNTAzLDExNTA1LDUsMTE3NDQsMTE3NzUsNSwxMjMzNCwxMjMzNSw1LDEyMzQ5LDEyMzQ5LDE0LDEyOTUxLDEyOTUxLDE0LDQyNjA3LDQyNjA3LDUsNDI2MTIsNDI2MjEsNSw0MjczNiw0MjczNyw1LDQzMDE0LDQzMDE0LDUsNDMwNDMsNDMwNDQsNyw0MzA0Nyw0MzA0Nyw3LDQzMTM2LDQzMTM3LDcsNDMyMDQsNDMyMDUsNSw0MzI2Myw0MzI2Myw1LDQzMzM1LDQzMzQ1LDUsNDMzNjAsNDMzODgsOCw0MzM5NSw0MzM5NSw3LDQzNDQ0LDQzNDQ1LDcsNDM0NTAsNDM0NTEsNyw0MzQ1NCw0MzQ1Niw3LDQzNTYxLDQzNTY2LDUsNDM1NjksNDM1NzAsNSw0MzU3Myw0MzU3NCw1LDQzNTk2LDQzNTk2LDUsNDM2NDQsNDM2NDQsNSw0MzY5OCw0MzcwMCw1LDQzNzEwLDQzNzExLDUsNDM3NTUsNDM3NTUsNyw0Mzc1OCw0Mzc1OSw3LDQzNzY2LDQzNzY2LDUsNDQwMDUsNDQwMDUsNSw0NDAwOCw0NDAwOCw1LDQ0MDEyLDQ0MDEyLDcsNDQwMzIsNDQwMzIsMTEsNDQwNjAsNDQwNjAsMTEsNDQwODgsNDQwODgsMTEsNDQxMTYsNDQxMTYsMTEsNDQxNDQsNDQxNDQsMTEsNDQxNzIsNDQxNzIsMTEsNDQyMDAsNDQyMDAsMTEsNDQyMjgsNDQyMjgsMTEsNDQyNTYsNDQyNTYsMTEsNDQyODQsNDQyODQsMTEsNDQzMTIsNDQzMTIsMTEsNDQzNDAsNDQzNDAsMTEsNDQzNjgsNDQzNjgsMTEsNDQzOTYsNDQzOTYsMTEsNDQ0MjQsNDQ0MjQsMTEsNDQ0NTIsNDQ0NTIsMTEsNDQ0ODAsNDQ0ODAsMTEsNDQ1MDgsNDQ1MDgsMTEsNDQ1MzYsNDQ1MzYsMTEsNDQ1NjQsNDQ1NjQsMTEsNDQ1OTIsNDQ1OTIsMTEsNDQ2MjAsNDQ2MjAsMTEsNDQ2NDgsNDQ2NDgsMTEsNDQ2NzYsNDQ2NzYsMTEsNDQ3MDQsNDQ3MDQsMTEsNDQ3MzIsNDQ3MzIsMTEsNDQ3NjAsNDQ3NjAsMTEsNDQ3ODgsNDQ3ODgsMTEsNDQ4MTYsNDQ4MTYsMTEsNDQ4NDQsNDQ4NDQsMTEsNDQ4NzIsNDQ4NzIsMTEsNDQ5MDAsNDQ5MDAsMTEsNDQ5MjgsNDQ5MjgsMTEsNDQ5NTYsNDQ5NTYsMTEsNDQ5ODQsNDQ5ODQsMTEsNDUwMTIsNDUwMTIsMTEsNDUwNDAsNDUwNDAsMTEsNDUwNjgsNDUwNjgsMTEsNDUwOTYsNDUwOTYsMTEsNDUxMjQsNDUxMjQsMTEsNDUxNTIsNDUxNTIsMTEsNDUxODAsNDUxODAsMTEsNDUyMDgsNDUyMDgsMTEsNDUyMzYsNDUyMzYsMTEsNDUyNjQsNDUyNjQsMTEsNDUyOTIsNDUyOTIsMTEsNDUzMjAsNDUzMjAsMTEsNDUzNDgsNDUzNDgsMTEsNDUzNzYsNDUzNzYsMTEsNDU0MDQsNDU0MDQsMTEsNDU0MzIsNDU0MzIsMTEsNDU0NjAsNDU0NjAsMTEsNDU0ODgsNDU0ODgsMTEsNDU1MTYsNDU1MTYsMTEsNDU1NDQsNDU1NDQsMTEsNDU1NzIsNDU1NzIsMTEsNDU2MDAsNDU2MDAsMTEsNDU2MjgsNDU2MjgsMTEsNDU2NTYsNDU2NTYsMTEsNDU2ODQsNDU2ODQsMTEsNDU3MTIsNDU3MTIsMTEsNDU3NDAsNDU3NDAsMTEsNDU3NjgsNDU3NjgsMTEsNDU3OTYsNDU3OTYsMTEsNDU4MjQsNDU4MjQsMTEsNDU4NTIsNDU4NTIsMTEsNDU4ODAsNDU4ODAsMTEsNDU5MDgsNDU5MDgsMTEsNDU5MzYsNDU5MzYsMTEsNDU5NjQsNDU5NjQsMTEsNDU5OTIsNDU5OTIsMTEsNDYwMjAsNDYwMjAsMTEsNDYwNDgsNDYwNDgsMTEsNDYwNzYsNDYwNzYsMTEsNDYxMDQsNDYxMDQsMTEsNDYxMzIsNDYxMzIsMTEsNDYxNjAsNDYxNjAsMTEsNDYxODgsNDYxODgsMTEsNDYyMTYsNDYyMTYsMTEsNDYyNDQsNDYyNDQsMTEsNDYyNzIsNDYyNzIsMTEsNDYzMDAsNDYzMDAsMTEsNDYzMjgsNDYzMjgsMTEsNDYzNTYsNDYzNTYsMTEsNDYzODQsNDYzODQsMTEsNDY0MTIsNDY0MTIsMTEsNDY0NDAsNDY0NDAsMTEsNDY0NjgsNDY0NjgsMTEsNDY0OTYsNDY0OTYsMTEsNDY1MjQsNDY1MjQsMTEsNDY1NTIsNDY1NTIsMTEsNDY1ODAsNDY1ODAsMTEsNDY2MDgsNDY2MDgsMTEsNDY2MzYsNDY2MzYsMTEsNDY2NjQsNDY2NjQsMTEsNDY2OTIsNDY2OTIsMTEsNDY3MjAsNDY3MjAsMTEsNDY3NDgsNDY3NDgsMTEsNDY3NzYsNDY3NzYsMTEsNDY4MDQsNDY4MDQsMTEsNDY4MzIsNDY4MzIsMTEsNDY4NjAsNDY4NjAsMTEsNDY4ODgsNDY4ODgsMTEsNDY5MTYsNDY5MTYsMTEsNDY5NDQsNDY5NDQsMTEsNDY5NzIsNDY5NzIsMTEsNDcwMDAsNDcwMDAsMTEsNDcwMjgsNDcwMjgsMTEsNDcwNTYsNDcwNTYsMTEsNDcwODQsNDcwODQsMTEsNDcxMTIsNDcxMTIsMTEsNDcxNDAsNDcxNDAsMTEsNDcxNjgsNDcxNjgsMTEsNDcxOTYsNDcxOTYsMTEsNDcyMjQsNDcyMjQsMTEsNDcyNTIsNDcyNTIsMTEsNDcyODAsNDcyODAsMTEsNDczMDgsNDczMDgsMTEsNDczMzYsNDczMzYsMTEsNDczNjQsNDczNjQsMTEsNDczOTIsNDczOTIsMTEsNDc0MjAsNDc0MjAsMTEsNDc0NDgsNDc0NDgsMTEsNDc0NzYsNDc0NzYsMTEsNDc1MDQsNDc1MDQsMTEsNDc1MzIsNDc1MzIsMTEsNDc1NjAsNDc1NjAsMTEsNDc1ODgsNDc1ODgsMTEsNDc2MTYsNDc2MTYsMTEsNDc2NDQsNDc2NDQsMTEsNDc2NzIsNDc2NzIsMTEsNDc3MDAsNDc3MDAsMTEsNDc3MjgsNDc3MjgsMTEsNDc3NTYsNDc3NTYsMTEsNDc3ODQsNDc3ODQsMTEsNDc4MTIsNDc4MTIsMTEsNDc4NDAsNDc4NDAsMTEsNDc4NjgsNDc4NjgsMTEsNDc4OTYsNDc4OTYsMTEsNDc5MjQsNDc5MjQsMTEsNDc5NTIsNDc5NTIsMTEsNDc5ODAsNDc5ODAsMTEsNDgwMDgsNDgwMDgsMTEsNDgwMzYsNDgwMzYsMTEsNDgwNjQsNDgwNjQsMTEsNDgwOTIsNDgwOTIsMTEsNDgxMjAsNDgxMjAsMTEsNDgxNDgsNDgxNDgsMTEsNDgxNzYsNDgxNzYsMTEsNDgyMDQsNDgyMDQsMTEsNDgyMzIsNDgyMzIsMTEsNDgyNjAsNDgyNjAsMTEsNDgyODgsNDgyODgsMTEsNDgzMTYsNDgzMTYsMTEsNDgzNDQsNDgzNDQsMTEsNDgzNzIsNDgzNzIsMTEsNDg0MDAsNDg0MDAsMTEsNDg0MjgsNDg0MjgsMTEsNDg0NTYsNDg0NTYsMTEsNDg0ODQsNDg0ODQsMTEsNDg1MTIsNDg1MTIsMTEsNDg1NDAsNDg1NDAsMTEsNDg1NjgsNDg1NjgsMTEsNDg1OTYsNDg1OTYsMTEsNDg2MjQsNDg2MjQsMTEsNDg2NTIsNDg2NTIsMTEsNDg2ODAsNDg2ODAsMTEsNDg3MDgsNDg3MDgsMTEsNDg3MzYsNDg3MzYsMTEsNDg3NjQsNDg3NjQsMTEsNDg3OTIsNDg3OTIsMTEsNDg4MjAsNDg4MjAsMTEsNDg4NDgsNDg4NDgsMTEsNDg4NzYsNDg4NzYsMTEsNDg5MDQsNDg5MDQsMTEsNDg5MzIsNDg5MzIsMTEsNDg5NjAsNDg5NjAsMTEsNDg5ODgsNDg5ODgsMTEsNDkwMTYsNDkwMTYsMTEsNDkwNDQsNDkwNDQsMTEsNDkwNzIsNDkwNzIsMTEsNDkxMDAsNDkxMDAsMTEsNDkxMjgsNDkxMjgsMTEsNDkxNTYsNDkxNTYsMTEsNDkxODQsNDkxODQsMTEsNDkyMTIsNDkyMTIsMTEsNDkyNDAsNDkyNDAsMTEsNDkyNjgsNDkyNjgsMTEsNDkyOTYsNDkyOTYsMTEsNDkzMjQsNDkzMjQsMTEsNDkzNTIsNDkzNTIsMTEsNDkzODAsNDkzODAsMTEsNDk0MDgsNDk0MDgsMTEsNDk0MzYsNDk0MzYsMTEsNDk0NjQsNDk0NjQsMTEsNDk0OTIsNDk0OTIsMTEsNDk1MjAsNDk1MjAsMTEsNDk1NDgsNDk1NDgsMTEsNDk1NzYsNDk1NzYsMTEsNDk2MDQsNDk2MDQsMTEsNDk2MzIsNDk2MzIsMTEsNDk2NjAsNDk2NjAsMTEsNDk2ODgsNDk2ODgsMTEsNDk3MTYsNDk3MTYsMTEsNDk3NDQsNDk3NDQsMTEsNDk3NzIsNDk3NzIsMTEsNDk4MDAsNDk4MDAsMTEsNDk4MjgsNDk4MjgsMTEsNDk4NTYsNDk4NTYsMTEsNDk4ODQsNDk4ODQsMTEsNDk5MTIsNDk5MTIsMTEsNDk5NDAsNDk5NDAsMTEsNDk5NjgsNDk5NjgsMTEsNDk5OTYsNDk5OTYsMTEsNTAwMjQsNTAwMjQsMTEsNTAwNTIsNTAwNTIsMTEsNTAwODAsNTAwODAsMTEsNTAxMDgsNTAxMDgsMTEsNTAxMzYsNTAxMzYsMTEsNTAxNjQsNTAxNjQsMTEsNTAxOTIsNTAxOTIsMTEsNTAyMjAsNTAyMjAsMTEsNTAyNDgsNTAyNDgsMTEsNTAyNzYsNTAyNzYsMTEsNTAzMDQsNTAzMDQsMTEsNTAzMzIsNTAzMzIsMTEsNTAzNjAsNTAzNjAsMTEsNTAzODgsNTAzODgsMTEsNTA0MTYsNTA0MTYsMTEsNTA0NDQsNTA0NDQsMTEsNTA0NzIsNTA0NzIsMTEsNTA1MDAsNTA1MDAsMTEsNTA1MjgsNTA1MjgsMTEsNTA1NTYsNTA1NTYsMTEsNTA1ODQsNTA1ODQsMTEsNTA2MTIsNTA2MTIsMTEsNTA2NDAsNTA2NDAsMTEsNTA2NjgsNTA2NjgsMTEsNTA2OTYsNTA2OTYsMTEsNTA3MjQsNTA3MjQsMTEsNTA3NTIsNTA3NTIsMTEsNTA3ODAsNTA3ODAsMTEsNTA4MDgsNTA4MDgsMTEsNTA4MzYsNTA4MzYsMTEsNTA4NjQsNTA4NjQsMTEsNTA4OTIsNTA4OTIsMTEsNTA5MjAsNTA5MjAsMTEsNTA5NDgsNTA5NDgsMTEsNTA5NzYsNTA5NzYsMTEsNTEwMDQsNTEwMDQsMTEsNTEwMzIsNTEwMzIsMTEsNTEwNjAsNTEwNjAsMTEsNTEwODgsNTEwODgsMTEsNTExMTYsNTExMTYsMTEsNTExNDQsNTExNDQsMTEsNTExNzIsNTExNzIsMTEsNTEyMDAsNTEyMDAsMTEsNTEyMjgsNTEyMjgsMTEsNTEyNTYsNTEyNTYsMTEsNTEyODQsNTEyODQsMTEsNTEzMTIsNTEzMTIsMTEsNTEzNDAsNTEzNDAsMTEsNTEzNjgsNTEzNjgsMTEsNTEzOTYsNTEzOTYsMTEsNTE0MjQsNTE0MjQsMTEsNTE0NTIsNTE0NTIsMTEsNTE0ODAsNTE0ODAsMTEsNTE1MDgsNTE1MDgsMTEsNTE1MzYsNTE1MzYsMTEsNTE1NjQsNTE1NjQsMTEsNTE1OTIsNTE1OTIsMTEsNTE2MjAsNTE2MjAsMTEsNTE2NDgsNTE2NDgsMTEsNTE2NzYsNTE2NzYsMTEsNTE3MDQsNTE3MDQsMTEsNTE3MzIsNTE3MzIsMTEsNTE3NjAsNTE3NjAsMTEsNTE3ODgsNTE3ODgsMTEsNTE4MTYsNTE4MTYsMTEsNTE4NDQsNTE4NDQsMTEsNTE4NzIsNTE4NzIsMTEsNTE5MDAsNTE5MDAsMTEsNTE5MjgsNTE5MjgsMTEsNTE5NTYsNTE5NTYsMTEsNTE5ODQsNTE5ODQsMTEsNTIwMTIsNTIwMTIsMTEsNTIwNDAsNTIwNDAsMTEsNTIwNjgsNTIwNjgsMTEsNTIwOTYsNTIwOTYsMTEsNTIxMjQsNTIxMjQsMTEsNTIxNTIsNTIxNTIsMTEsNTIxODAsNTIxODAsMTEsNTIyMDgsNTIyMDgsMTEsNTIyMzYsNTIyMzYsMTEsNTIyNjQsNTIyNjQsMTEsNTIyOTIsNTIyOTIsMTEsNTIzMjAsNTIzMjAsMTEsNTIzNDgsNTIzNDgsMTEsNTIzNzYsNTIzNzYsMTEsNTI0MDQsNTI0MDQsMTEsNTI0MzIsNTI0MzIsMTEsNTI0NjAsNTI0NjAsMTEsNTI0ODgsNTI0ODgsMTEsNTI1MTYsNTI1MTYsMTEsNTI1NDQsNTI1NDQsMTEsNTI1NzIsNTI1NzIsMTEsNTI2MDAsNTI2MDAsMTEsNTI2MjgsNTI2MjgsMTEsNTI2NTYsNTI2NTYsMTEsNTI2ODQsNTI2ODQsMTEsNTI3MTIsNTI3MTIsMTEsNTI3NDAsNTI3NDAsMTEsNTI3NjgsNTI3NjgsMTEsNTI3OTYsNTI3OTYsMTEsNTI4MjQsNTI4MjQsMTEsNTI4NTIsNTI4NTIsMTEsNTI4ODAsNTI4ODAsMTEsNTI5MDgsNTI5MDgsMTEsNTI5MzYsNTI5MzYsMTEsNTI5NjQsNTI5NjQsMTEsNTI5OTIsNTI5OTIsMTEsNTMwMjAsNTMwMjAsMTEsNTMwNDgsNTMwNDgsMTEsNTMwNzYsNTMwNzYsMTEsNTMxMDQsNTMxMDQsMTEsNTMxMzIsNTMxMzIsMTEsNTMxNjAsNTMxNjAsMTEsNTMxODgsNTMxODgsMTEsNTMyMTYsNTMyMTYsMTEsNTMyNDQsNTMyNDQsMTEsNTMyNzIsNTMyNzIsMTEsNTMzMDAsNTMzMDAsMTEsNTMzMjgsNTMzMjgsMTEsNTMzNTYsNTMzNTYsMTEsNTMzODQsNTMzODQsMTEsNTM0MTIsNTM0MTIsMTEsNTM0NDAsNTM0NDAsMTEsNTM0NjgsNTM0NjgsMTEsNTM0OTYsNTM0OTYsMTEsNTM1MjQsNTM1MjQsMTEsNTM1NTIsNTM1NTIsMTEsNTM1ODAsNTM1ODAsMTEsNTM2MDgsNTM2MDgsMTEsNTM2MzYsNTM2MzYsMTEsNTM2NjQsNTM2NjQsMTEsNTM2OTIsNTM2OTIsMTEsNTM3MjAsNTM3MjAsMTEsNTM3NDgsNTM3NDgsMTEsNTM3NzYsNTM3NzYsMTEsNTM4MDQsNTM4MDQsMTEsNTM4MzIsNTM4MzIsMTEsNTM4NjAsNTM4NjAsMTEsNTM4ODgsNTM4ODgsMTEsNTM5MTYsNTM5MTYsMTEsNTM5NDQsNTM5NDQsMTEsNTM5NzIsNTM5NzIsMTEsNTQwMDAsNTQwMDAsMTEsNTQwMjgsNTQwMjgsMTEsNTQwNTYsNTQwNTYsMTEsNTQwODQsNTQwODQsMTEsNTQxMTIsNTQxMTIsMTEsNTQxNDAsNTQxNDAsMTEsNTQxNjgsNTQxNjgsMTEsNTQxOTYsNTQxOTYsMTEsNTQyMjQsNTQyMjQsMTEsNTQyNTIsNTQyNTIsMTEsNTQyODAsNTQyODAsMTEsNTQzMDgsNTQzMDgsMTEsNTQzMzYsNTQzMzYsMTEsNTQzNjQsNTQzNjQsMTEsNTQzOTIsNTQzOTIsMTEsNTQ0MjAsNTQ0MjAsMTEsNTQ0NDgsNTQ0NDgsMTEsNTQ0NzYsNTQ0NzYsMTEsNTQ1MDQsNTQ1MDQsMTEsNTQ1MzIsNTQ1MzIsMTEsNTQ1NjAsNTQ1NjAsMTEsNTQ1ODgsNTQ1ODgsMTEsNTQ2MTYsNTQ2MTYsMTEsNTQ2NDQsNTQ2NDQsMTEsNTQ2NzIsNTQ2NzIsMTEsNTQ3MDAsNTQ3MDAsMTEsNTQ3MjgsNTQ3MjgsMTEsNTQ3NTYsNTQ3NTYsMTEsNTQ3ODQsNTQ3ODQsMTEsNTQ4MTIsNTQ4MTIsMTEsNTQ4NDAsNTQ4NDAsMTEsNTQ4NjgsNTQ4NjgsMTEsNTQ4OTYsNTQ4OTYsMTEsNTQ5MjQsNTQ5MjQsMTEsNTQ5NTIsNTQ5NTIsMTEsNTQ5ODAsNTQ5ODAsMTEsNTUwMDgsNTUwMDgsMTEsNTUwMzYsNTUwMzYsMTEsNTUwNjQsNTUwNjQsMTEsNTUwOTIsNTUwOTIsMTEsNTUxMjAsNTUxMjAsMTEsNTUxNDgsNTUxNDgsMTEsNTUxNzYsNTUxNzYsMTEsNTUyMTYsNTUyMzgsOSw2NDI4Niw2NDI4Niw1LDY1MDU2LDY1MDcxLDUsNjU0MzgsNjU0MzksNSw2NTUyOSw2NTUzMSw0LDY2MjcyLDY2MjcyLDUsNjgwOTcsNjgwOTksNSw2ODEwOCw2ODExMSw1LDY4MTU5LDY4MTU5LDUsNjg5MDAsNjg5MDMsNSw2OTQ0Niw2OTQ1Niw1LDY5NjMyLDY5NjMyLDcsNjk2MzQsNjk2MzQsNyw2OTc0NCw2OTc0NCw1LDY5NzU5LDY5NzYxLDUsNjk4MDgsNjk4MTAsNyw2OTgxNSw2OTgxNiw3LDY5ODIxLDY5ODIxLDEsNjk4MzcsNjk4MzcsMSw2OTkyNyw2OTkzMSw1LDY5OTMzLDY5OTQwLDUsNzAwMDMsNzAwMDMsNSw3MDAxOCw3MDAxOCw3LDcwMDcwLDcwMDc4LDUsNzAwODIsNzAwODMsMSw3MDA5NCw3MDA5NCw3LDcwMTg4LDcwMTkwLDcsNzAxOTQsNzAxOTUsNyw3MDE5Nyw3MDE5Nyw3LDcwMjA2LDcwMjA2LDUsNzAzNjgsNzAzNzAsNyw3MDQwMCw3MDQwMSw1LDcwNDU5LDcwNDYwLDUsNzA0NjMsNzA0NjMsNyw3MDQ2NSw3MDQ2OCw3LDcwNDc1LDcwNDc3LDcsNzA0OTgsNzA0OTksNyw3MDUxMiw3MDUxNiw1LDcwNzEyLDcwNzE5LDUsNzA3MjIsNzA3MjQsNSw3MDcyNiw3MDcyNiw1LDcwODMyLDcwODMyLDUsNzA4MzUsNzA4NDAsNSw3MDg0Miw3MDg0Miw1LDcwODQ1LDcwODQ1LDUsNzA4NDcsNzA4NDgsNSw3MDg1MCw3MDg1MSw1LDcxMDg4LDcxMDg5LDcsNzEwOTYsNzEwOTksNyw3MTEwMiw3MTEwMiw3LDcxMTMyLDcxMTMzLDUsNzEyMTksNzEyMjYsNSw3MTIyOSw3MTIyOSw1LDcxMjMxLDcxMjMyLDUsNzEzNDAsNzEzNDAsNyw3MTM0Miw3MTM0Myw3LDcxMzUwLDcxMzUwLDcsNzE0NTMsNzE0NTUsNSw3MTQ2Miw3MTQ2Miw3LDcxNzI0LDcxNzI2LDcsNzE3MzYsNzE3MzYsNyw3MTk4NCw3MTk4NCw1LDcxOTkxLDcxOTkyLDcsNzE5OTcsNzE5OTcsNyw3MTk5OSw3MTk5OSwxLDcyMDAxLDcyMDAxLDEsNzIwMDMsNzIwMDMsNSw3MjE0OCw3MjE1MSw1LDcyMTU2LDcyMTU5LDcsNzIxNjQsNzIxNjQsNyw3MjI0Myw3MjI0OCw1LDcyMjUwLDcyMjUwLDEsNzIyNjMsNzIyNjMsNSw3MjI3OSw3MjI4MCw3LDcyMzI0LDcyMzI5LDEsNzIzNDMsNzIzNDMsNyw3Mjc1MSw3Mjc1MSw3LDcyNzYwLDcyNzY1LDUsNzI3NjcsNzI3NjcsNSw3Mjg3Myw3Mjg3Myw3LDcyODgxLDcyODgxLDcsNzI4ODQsNzI4ODQsNyw3MzAwOSw3MzAxNCw1LDczMDIwLDczMDIxLDUsNzMwMzAsNzMwMzAsMSw3MzA5OCw3MzEwMiw3LDczMTA3LDczMTA4LDcsNzMxMTAsNzMxMTAsNyw3MzQ1OSw3MzQ2MCw1LDc4ODk2LDc4OTA0LDQsOTI5NzYsOTI5ODIsNSw5NDAzMyw5NDA4Nyw3LDk0MTgwLDk0MTgwLDUsMTEzODIxLDExMzgyMiw1LDExODUyOCwxMTg1NzMsNSwxMTkxNDEsMTE5MTQxLDUsMTE5MTQzLDExOTE0NSw1LDExOTE1MCwxMTkxNTQsNSwxMTkxNjMsMTE5MTcwLDUsMTE5MjEwLDExOTIxMyw1LDEyMTM0NCwxMjEzOTgsNSwxMjE0NjEsMTIxNDYxLDUsMTIxNDk5LDEyMTUwMyw1LDEyMjg4MCwxMjI4ODYsNSwxMjI5MDcsMTIyOTEzLDUsMTIyOTE4LDEyMjkyMiw1LDEyMzU2NiwxMjM1NjYsNSwxMjUxMzYsMTI1MTQyLDUsMTI2OTc2LDEyNjk3OSwxNCwxMjY5ODEsMTI3MTgyLDE0LDEyNzE4NCwxMjcyMzEsMTQsMTI3Mjc5LDEyNzI3OSwxNCwxMjczNDQsMTI3MzQ1LDE0LDEyNzM3NCwxMjczNzQsMTQsMTI3NDA1LDEyNzQ2MSwxNCwxMjc0ODksMTI3NDkwLDE0LDEyNzUxNCwxMjc1MTQsMTQsMTI3NTM4LDEyNzU0NiwxNCwxMjc1NjEsMTI3NTY3LDE0LDEyNzU3MCwxMjc3NDMsMTQsMTI3NzU3LDEyNzc1OCwxNCwxMjc3NjAsMTI3NzYwLDE0LDEyNzc2MiwxMjc3NjIsMTQsMTI3NzY2LDEyNzc2OCwxNCwxMjc3NzAsMTI3NzcwLDE0LDEyNzc3MiwxMjc3NzIsMTQsMTI3Nzc1LDEyNzc3NiwxNCwxMjc3NzgsMTI3Nzc5LDE0LDEyNzc4OSwxMjc3OTEsMTQsMTI3Nzk0LDEyNzc5NSwxNCwxMjc3OTgsMTI3Nzk4LDE0LDEyNzgxOSwxMjc4MTksMTQsMTI3ODI0LDEyNzgyNCwxNCwxMjc4NjgsMTI3ODY4LDE0LDEyNzg3MCwxMjc4NzEsMTQsMTI3ODkyLDEyNzg5MywxNCwxMjc4OTYsMTI3ODk2LDE0LDEyNzkwMCwxMjc5MDEsMTQsMTI3OTA0LDEyNzk0MCwxNCwxMjc5NDIsMTI3OTQyLDE0LDEyNzk0NCwxMjc5NDQsMTQsMTI3OTQ2LDEyNzk0NiwxNCwxMjc5NTEsMTI3OTU1LDE0LDEyNzk2OCwxMjc5NzEsMTQsMTI3OTczLDEyNzk4NCwxNCwxMjc5ODcsMTI3OTg3LDE0LDEyNzk4OSwxMjc5ODksMTQsMTI3OTkxLDEyNzk5MSwxNCwxMjc5OTUsMTI3OTk5LDUsMTI4MDA4LDEyODAwOCwxNCwxMjgwMTIsMTI4MDE0LDE0LDEyODAxNywxMjgwMTgsMTQsMTI4MDIwLDEyODAyMCwxNCwxMjgwMjIsMTI4MDIyLDE0LDEyODA0MiwxMjgwNDIsMTQsMTI4MDYzLDEyODA2MywxNCwxMjgwNjUsMTI4MDY1LDE0LDEyODEwMSwxMjgxMDEsMTQsMTI4MTA4LDEyODEwOSwxNCwxMjgxNzMsMTI4MTczLDE0LDEyODE4MiwxMjgxODMsMTQsMTI4MjM2LDEyODIzNywxNCwxMjgyMzksMTI4MjM5LDE0LDEyODI0NSwxMjgyNDUsMTQsMTI4MjQ4LDEyODI0OCwxNCwxMjgyNTMsMTI4MjUzLDE0LDEyODI1NSwxMjgyNTgsMTQsMTI4MjYwLDEyODI2MywxNCwxMjgyNjUsMTI4MjY1LDE0LDEyODI3NywxMjgyNzcsMTQsMTI4MzAwLDEyODMwMSwxNCwxMjgzMjYsMTI4MzI4LDE0LDEyODMzMSwxMjgzMzQsMTQsMTI4MzM2LDEyODM0NywxNCwxMjgzNjAsMTI4MzY2LDE0LDEyODM2OSwxMjgzNzAsMTQsMTI4Mzc4LDEyODM3OCwxNCwxMjgzOTEsMTI4MzkxLDE0LDEyODM5NCwxMjgzOTcsMTQsMTI4NDAwLDEyODQwMCwxNCwxMjg0MDUsMTI4NDA2LDE0LDEyODQyMCwxMjg0MjAsMTQsMTI4NDIyLDEyODQyMywxNCwxMjg0MjUsMTI4NDMyLDE0LDEyODQzNSwxMjg0NDMsMTQsMTI4NDQ1LDEyODQ0OSwxNCwxMjg0NTMsMTI4NDY0LDE0LDEyODQ2OCwxMjg0NzUsMTQsMTI4NDc5LDEyODQ4MCwxNCwxMjg0ODIsMTI4NDgyLDE0LDEyODQ4NCwxMjg0ODcsMTQsMTI4NDg5LDEyODQ5NCwxNCwxMjg0OTYsMTI4NDk4LDE0LDEyODUwMCwxMjg1MDUsMTQsMTI4NTA3LDEyODUxMSwxNCwxMjg1MTMsMTI4NTE4LDE0LDEyODUyMSwxMjg1MjUsMTQsMTI4NTI3LDEyODUyNywxNCwxMjg1MjksMTI4NTI5LDE0LDEyODUzMywxMjg1MzMsMTQsMTI4NTM1LDEyODUzNSwxNCwxMjg1MzcsMTI4NTM3LDE0XScpO1xufVxuLy8jZW5kcmVnaW9uXG4vKipcbiAqIENvbXB1dGVzIHRoZSBvZmZzZXQgYWZ0ZXIgcGVyZm9ybWluZyBhIGxlZnQgZGVsZXRlIG9uIHRoZSBnaXZlbiBzdHJpbmcsXG4gKiB3aGlsZSBjb25zaWRlcmluZyB1bmljb2RlIGdyYXBoZW1lL2Vtb2ppIHJ1bGVzLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWZ0RGVsZXRlT2Zmc2V0KG9mZnNldCwgc3RyKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGRlbGV0ZSBlbW9qaSBwYXJ0LlxuICAgIGNvbnN0IGVtb2ppT2Zmc2V0ID0gZ2V0T2Zmc2V0QmVmb3JlTGFzdEVtb2ppQ29tcG9uZW50KG9mZnNldCwgc3RyKTtcbiAgICBpZiAoZW1vamlPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZW1vamlPZmZzZXQ7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwganVzdCBza2lwIGEgc2luZ2xlIGNvZGUgcG9pbnQuXG4gICAgY29uc3QgaXRlcmF0b3IgPSBuZXcgQ29kZVBvaW50SXRlcmF0b3Ioc3RyLCBvZmZzZXQpO1xuICAgIGl0ZXJhdG9yLnByZXZDb2RlUG9pbnQoKTtcbiAgICByZXR1cm4gaXRlcmF0b3Iub2Zmc2V0O1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0QmVmb3JlTGFzdEVtb2ppQ29tcG9uZW50KGluaXRpYWxPZmZzZXQsIHN0cikge1xuICAgIC8vIFNlZSBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyNTEvdHI1MS0xNC5odG1sI0VCTkZfYW5kX1JlZ2V4IGZvciB0aGVcbiAgICAvLyBzdHJ1Y3R1cmUgb2YgZW1vamlzLlxuICAgIGNvbnN0IGl0ZXJhdG9yID0gbmV3IENvZGVQb2ludEl0ZXJhdG9yKHN0ciwgaW5pdGlhbE9mZnNldCk7XG4gICAgbGV0IGNvZGVQb2ludCA9IGl0ZXJhdG9yLnByZXZDb2RlUG9pbnQoKTtcbiAgICAvLyBTa2lwIG1vZGlmaWVyc1xuICAgIHdoaWxlICgoaXNFbW9qaU1vZGlmaWVyKGNvZGVQb2ludCkgfHwgY29kZVBvaW50ID09PSA2NTAzOSAvKiBDb2RlUG9pbnQuZW1vamlWYXJpYW50U2VsZWN0b3IgKi8gfHwgY29kZVBvaW50ID09PSA4NDE5IC8qIENvZGVQb2ludC5lbmNsb3NpbmdLZXlDYXAgKi8pKSB7XG4gICAgICAgIGlmIChpdGVyYXRvci5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIENhbm5vdCBza2lwIG1vZGlmaWVyLCBubyBwcmVjZWRpbmcgZW1vamkgYmFzZS5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50ID0gaXRlcmF0b3IucHJldkNvZGVQb2ludCgpO1xuICAgIH1cbiAgICAvLyBFeHBlY3QgYmFzZSBlbW9qaVxuICAgIGlmICghaXNFbW9qaUltcHJlY2lzZShjb2RlUG9pbnQpKSB7XG4gICAgICAgIC8vIFVuZXhwZWN0ZWQgY29kZSBwb2ludCwgbm90IGEgdmFsaWQgZW1vamkuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCByZXN1bHRPZmZzZXQgPSBpdGVyYXRvci5vZmZzZXQ7XG4gICAgaWYgKHJlc3VsdE9mZnNldCA+IDApIHtcbiAgICAgICAgLy8gU2tpcCBvcHRpb25hbCBaV0ogY29kZSBwb2ludHMgdGhhdCBjb21iaW5lIG11bHRpcGxlIGVtb2ppcy5cbiAgICAgICAgLy8gSW4gdGhlb3J5LCB3ZSBzaG91bGQgY2hlY2sgaWYgdGhhdCBaV0ogYWN0dWFsbHkgY29tYmluZXMgbXVsdGlwbGUgZW1vamlzXG4gICAgICAgIC8vIHRvIHByZXZlbnQgZGVsZXRpbmcgWldKcyBpbiBzaXR1YXRpb25zIHdlIGRpZG4ndCBhY2NvdW50IGZvci5cbiAgICAgICAgY29uc3Qgb3B0aW9uYWxad2pDb2RlUG9pbnQgPSBpdGVyYXRvci5wcmV2Q29kZVBvaW50KCk7XG4gICAgICAgIGlmIChvcHRpb25hbFp3akNvZGVQb2ludCA9PT0gODIwNSAvKiBDb2RlUG9pbnQuendqICovKSB7XG4gICAgICAgICAgICByZXN1bHRPZmZzZXQgPSBpdGVyYXRvci5vZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcbn1cbmZ1bmN0aW9uIGlzRW1vamlNb2RpZmllcihjb2RlUG9pbnQpIHtcbiAgICByZXR1cm4gMHgxRjNGQiA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4MUYzRkY7XG59XG5leHBvcnQgY29uc3Qgbm9CcmVha1doaXRlc3BhY2UgPSAnXFx4YTAnO1xuZXhwb3J0IGNsYXNzIEFtYmlndW91c0NoYXJhY3RlcnMge1xuICAgIHN0YXRpYyB7IHRoaXMuYW1iaWd1b3VzQ2hhcmFjdGVyRGF0YSA9IG5ldyBMYXp5KCgpID0+IHtcbiAgICAgICAgLy8gR2VuZXJhdGVkIHVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9oZWRpZXQvdnNjb2RlLXVuaWNvZGUtZGF0YVxuICAgICAgICAvLyBTdG9yZWQgYXMga2V5MSwgdmFsdWUxLCBrZXkyLCB2YWx1ZTIsIC4uLlxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSgne1xcXCJfY29tbW9uXFxcIjpbODIzMiwzMiw4MjMzLDMyLDU3NjAsMzIsODE5MiwzMiw4MTkzLDMyLDgxOTQsMzIsODE5NSwzMiw4MTk2LDMyLDgxOTcsMzIsODE5OCwzMiw4MjAwLDMyLDgyMDEsMzIsODIwMiwzMiw4Mjg3LDMyLDgxOTksMzIsODIzOSwzMiwyMDQyLDk1LDY1MTAxLDk1LDY1MTAyLDk1LDY1MTAzLDk1LDgyMDgsNDUsODIwOSw0NSw4MjEwLDQ1LDY1MTEyLDQ1LDE3NDgsNDUsODI1OSw0NSw3MjcsNDUsODcyMiw0NSwxMDEzNCw0NSwxMTQ1MCw0NSwxNTQ5LDQ0LDE2NDMsNDQsODIxOCw0NCwxODQsNDQsNDIyMzMsNDQsODk0LDU5LDIzMDcsNTgsMjY5MSw1OCwxNDE3LDU4LDE3OTUsNTgsMTc5Niw1OCw1ODY4LDU4LDY1MDcyLDU4LDYxNDcsNTgsNjE1Myw1OCw4MjgyLDU4LDE0NzUsNTgsNzYwLDU4LDQyODg5LDU4LDg3NTgsNTgsNzIwLDU4LDQyMjM3LDU4LDQ1MSwzMywxMTYwMSwzMyw2NjAsNjMsNTc3LDYzLDI0MjksNjMsNTAzOCw2Myw0MjczMSw2MywxMTkxNDksNDYsODIyOCw0NiwxNzkzLDQ2LDE3OTQsNDYsNDI1MTAsNDYsNjgxNzYsNDYsMTYzMiw0NiwxNzc2LDQ2LDQyMjMyLDQ2LDEzNzMsOTYsNjUyODcsOTYsODIxOSw5Niw4MjQyLDk2LDEzNzAsOTYsMTUyMyw5Niw4MTc1LDk2LDY1MzQ0LDk2LDkwMCw5Niw4MTg5LDk2LDgxMjUsOTYsODEyNyw5Niw4MTkwLDk2LDY5Nyw5Niw4ODQsOTYsNzEyLDk2LDcxNCw5Niw3MTUsOTYsNzU2LDk2LDY5OSw5Niw3MDEsOTYsNzAwLDk2LDcwMiw5Niw0Mjg5Miw5NiwxNDk3LDk2LDIwMzYsOTYsMjAzNyw5Niw1MTk0LDk2LDU4MzYsOTYsOTQwMzMsOTYsOTQwMzQsOTYsNjUzMzksOTEsMTAwODgsNDAsMTAwOTgsNDAsMTIzMDgsNDAsNjQ4MzAsNDAsNjUzNDEsOTMsMTAwODksNDEsMTAwOTksNDEsMTIzMDksNDEsNjQ4MzEsNDEsMTAxMDAsMTIzLDExOTA2MCwxMjMsMTAxMDEsMTI1LDY1MzQyLDk0LDgyNzAsNDIsMTY0NSw0Miw4NzI3LDQyLDY2MzM1LDQyLDU5NDEsNDcsODI1Nyw0Nyw4NzI1LDQ3LDgyNjAsNDcsOTU4NSw0NywxMDE4Nyw0NywxMDc0NCw0NywxMTkzNTQsNDcsMTI3NTUsNDcsMTIzMzksNDcsMTE0NjIsNDcsMjAwMzEsNDcsMTIwMzUsNDcsNjUzNDAsOTIsNjUxMjgsOTIsODcyNiw5MiwxMDE4OSw5MiwxMDc0MSw5MiwxMDc0NSw5MiwxMTkzMTEsOTIsMTE5MzU1LDkyLDEyNzU2LDkyLDIwMDIyLDkyLDEyMDM0LDkyLDQyODcyLDM4LDcwOCw5NCw3MTAsOTQsNTg2OSw0MywxMDEzMyw0Myw2NjIwMyw0Myw4MjQ5LDYwLDEwMDk0LDYwLDcwNiw2MCwxMTkzNTAsNjAsNTE3Niw2MCw1ODEwLDYwLDUxMjAsNjEsMTE4NDAsNjEsMTI0NDgsNjEsNDIyMzksNjEsODI1MCw2MiwxMDA5NSw2Miw3MDcsNjIsMTE5MzUxLDYyLDUxNzEsNjIsOTQwMTUsNjIsODI3NSwxMjYsNzMyLDEyNiw4MTI4LDEyNiw4NzY0LDEyNiw2NTM3MiwxMjQsNjUyOTMsNDUsMTIwNzg0LDUwLDEyMDc5NCw1MCwxMjA4MDQsNTAsMTIwODE0LDUwLDEyMDgyNCw1MCwxMzAwMzQsNTAsNDI4NDIsNTAsNDIzLDUwLDEwMDAsNTAsNDI1NjQsNTAsNTMxMSw1MCw0MjczNSw1MCwxMTkzMDIsNTEsMTIwNzg1LDUxLDEyMDc5NSw1MSwxMjA4MDUsNTEsMTIwODE1LDUxLDEyMDgyNSw1MSwxMzAwMzUsNTEsNDI5MjMsNTEsNTQwLDUxLDQzOSw1MSw0Mjg1OCw1MSwxMTQ2OCw1MSwxMjQ4LDUxLDk0MDExLDUxLDcxODgyLDUxLDEyMDc4Niw1MiwxMjA3OTYsNTIsMTIwODA2LDUyLDEyMDgxNiw1MiwxMjA4MjYsNTIsMTMwMDM2LDUyLDUwNzAsNTIsNzE4NTUsNTIsMTIwNzg3LDUzLDEyMDc5Nyw1MywxMjA4MDcsNTMsMTIwODE3LDUzLDEyMDgyNyw1MywxMzAwMzcsNTMsNDQ0LDUzLDcxODY3LDUzLDEyMDc4OCw1NCwxMjA3OTgsNTQsMTIwODA4LDU0LDEyMDgxOCw1NCwxMjA4MjgsNTQsMTMwMDM4LDU0LDExNDc0LDU0LDUxMDIsNTQsNzE4OTMsNTQsMTE5MzE0LDU1LDEyMDc4OSw1NSwxMjA3OTksNTUsMTIwODA5LDU1LDEyMDgxOSw1NSwxMjA4MjksNTUsMTMwMDM5LDU1LDY2NzcwLDU1LDcxODc4LDU1LDI4MTksNTYsMjUzOCw1NiwyNjY2LDU2LDEyNTEzMSw1NiwxMjA3OTAsNTYsMTIwODAwLDU2LDEyMDgxMCw1NiwxMjA4MjAsNTYsMTIwODMwLDU2LDEzMDA0MCw1Niw1NDcsNTYsNTQ2LDU2LDY2MzMwLDU2LDI2NjMsNTcsMjkyMCw1NywyNTQxLDU3LDM0MzcsNTcsMTIwNzkxLDU3LDEyMDgwMSw1NywxMjA4MTEsNTcsMTIwODIxLDU3LDEyMDgzMSw1NywxMzAwNDEsNTcsNDI4NjIsNTcsMTE0NjYsNTcsNzE4ODQsNTcsNzE4NTIsNTcsNzE4OTQsNTcsOTA4Miw5Nyw2NTM0NSw5NywxMTk4MzQsOTcsMTE5ODg2LDk3LDExOTkzOCw5NywxMTk5OTAsOTcsMTIwMDQyLDk3LDEyMDA5NCw5NywxMjAxNDYsOTcsMTIwMTk4LDk3LDEyMDI1MCw5NywxMjAzMDIsOTcsMTIwMzU0LDk3LDEyMDQwNiw5NywxMjA0NTgsOTcsNTkzLDk3LDk0NSw5NywxMjA1MTQsOTcsMTIwNTcyLDk3LDEyMDYzMCw5NywxMjA2ODgsOTcsMTIwNzQ2LDk3LDY1MzEzLDY1LDExOTgwOCw2NSwxMTk4NjAsNjUsMTE5OTEyLDY1LDExOTk2NCw2NSwxMjAwMTYsNjUsMTIwMDY4LDY1LDEyMDEyMCw2NSwxMjAxNzIsNjUsMTIwMjI0LDY1LDEyMDI3Niw2NSwxMjAzMjgsNjUsMTIwMzgwLDY1LDEyMDQzMiw2NSw5MTMsNjUsMTIwNDg4LDY1LDEyMDU0Niw2NSwxMjA2MDQsNjUsMTIwNjYyLDY1LDEyMDcyMCw2NSw1MDM0LDY1LDU1NzMsNjUsNDIyMjIsNjUsOTQwMTYsNjUsNjYyMDgsNjUsMTE5ODM1LDk4LDExOTg4Nyw5OCwxMTk5MzksOTgsMTE5OTkxLDk4LDEyMDA0Myw5OCwxMjAwOTUsOTgsMTIwMTQ3LDk4LDEyMDE5OSw5OCwxMjAyNTEsOTgsMTIwMzAzLDk4LDEyMDM1NSw5OCwxMjA0MDcsOTgsMTIwNDU5LDk4LDM4OCw5OCw1MDcxLDk4LDUyMzQsOTgsNTU1MSw5OCw2NTMxNCw2Niw4NDkyLDY2LDExOTgwOSw2NiwxMTk4NjEsNjYsMTE5OTEzLDY2LDEyMDAxNyw2NiwxMjAwNjksNjYsMTIwMTIxLDY2LDEyMDE3Myw2NiwxMjAyMjUsNjYsMTIwMjc3LDY2LDEyMDMyOSw2NiwxMjAzODEsNjYsMTIwNDMzLDY2LDQyOTMyLDY2LDkxNCw2NiwxMjA0ODksNjYsMTIwNTQ3LDY2LDEyMDYwNSw2NiwxMjA2NjMsNjYsMTIwNzIxLDY2LDUxMDgsNjYsNTYyMyw2Niw0MjE5Miw2Niw2NjE3OCw2Niw2NjIwOSw2Niw2NjMwNSw2Niw2NTM0Nyw5OSw4NTczLDk5LDExOTgzNiw5OSwxMTk4ODgsOTksMTE5OTQwLDk5LDExOTk5Miw5OSwxMjAwNDQsOTksMTIwMDk2LDk5LDEyMDE0OCw5OSwxMjAyMDAsOTksMTIwMjUyLDk5LDEyMDMwNCw5OSwxMjAzNTYsOTksMTIwNDA4LDk5LDEyMDQ2MCw5OSw3NDI4LDk5LDEwMTAsOTksMTE0MjksOTksNDM5NTEsOTksNjY2MjEsOTksMTI4ODQ0LDY3LDcxOTIyLDY3LDcxOTEzLDY3LDY1MzE1LDY3LDg1NTcsNjcsODQ1MCw2Nyw4NDkzLDY3LDExOTgxMCw2NywxMTk4NjIsNjcsMTE5OTE0LDY3LDExOTk2Niw2NywxMjAwMTgsNjcsMTIwMTc0LDY3LDEyMDIyNiw2NywxMjAyNzgsNjcsMTIwMzMwLDY3LDEyMDM4Miw2NywxMjA0MzQsNjcsMTAxNyw2NywxMTQyOCw2Nyw1MDg3LDY3LDQyMjAyLDY3LDY2MjEwLDY3LDY2MzA2LDY3LDY2NTgxLDY3LDY2ODQ0LDY3LDg1NzQsMTAwLDg1MTgsMTAwLDExOTgzNywxMDAsMTE5ODg5LDEwMCwxMTk5NDEsMTAwLDExOTk5MywxMDAsMTIwMDQ1LDEwMCwxMjAwOTcsMTAwLDEyMDE0OSwxMDAsMTIwMjAxLDEwMCwxMjAyNTMsMTAwLDEyMDMwNSwxMDAsMTIwMzU3LDEwMCwxMjA0MDksMTAwLDEyMDQ2MSwxMDAsMTI4MSwxMDAsNTA5NSwxMDAsNTIzMSwxMDAsNDIxOTQsMTAwLDg1NTgsNjgsODUxNyw2OCwxMTk4MTEsNjgsMTE5ODYzLDY4LDExOTkxNSw2OCwxMTk5NjcsNjgsMTIwMDE5LDY4LDEyMDA3MSw2OCwxMjAxMjMsNjgsMTIwMTc1LDY4LDEyMDIyNyw2OCwxMjAyNzksNjgsMTIwMzMxLDY4LDEyMDM4Myw2OCwxMjA0MzUsNjgsNTAyNCw2OCw1NTk4LDY4LDU2MTAsNjgsNDIxOTUsNjgsODQ5NCwxMDEsNjUzNDksMTAxLDg0OTUsMTAxLDg1MTksMTAxLDExOTgzOCwxMDEsMTE5ODkwLDEwMSwxMTk5NDIsMTAxLDEyMDA0NiwxMDEsMTIwMDk4LDEwMSwxMjAxNTAsMTAxLDEyMDIwMiwxMDEsMTIwMjU0LDEwMSwxMjAzMDYsMTAxLDEyMDM1OCwxMDEsMTIwNDEwLDEwMSwxMjA0NjIsMTAxLDQzODI2LDEwMSwxMjEzLDEwMSw4OTU5LDY5LDY1MzE3LDY5LDg0OTYsNjksMTE5ODEyLDY5LDExOTg2NCw2OSwxMTk5MTYsNjksMTIwMDIwLDY5LDEyMDA3Miw2OSwxMjAxMjQsNjksMTIwMTc2LDY5LDEyMDIyOCw2OSwxMjAyODAsNjksMTIwMzMyLDY5LDEyMDM4NCw2OSwxMjA0MzYsNjksOTE3LDY5LDEyMDQ5Miw2OSwxMjA1NTAsNjksMTIwNjA4LDY5LDEyMDY2Niw2OSwxMjA3MjQsNjksMTE1NzcsNjksNTAzNiw2OSw0MjIyNCw2OSw3MTg0Niw2OSw3MTg1NCw2OSw2NjE4Miw2OSwxMTk4MzksMTAyLDExOTg5MSwxMDIsMTE5OTQzLDEwMiwxMTk5OTUsMTAyLDEyMDA0NywxMDIsMTIwMDk5LDEwMiwxMjAxNTEsMTAyLDEyMDIwMywxMDIsMTIwMjU1LDEwMiwxMjAzMDcsMTAyLDEyMDM1OSwxMDIsMTIwNDExLDEwMiwxMjA0NjMsMTAyLDQzODI5LDEwMiw0MjkwNSwxMDIsMzgzLDEwMiw3ODM3LDEwMiwxNDEyLDEwMiwxMTkzMTUsNzAsODQ5Nyw3MCwxMTk4MTMsNzAsMTE5ODY1LDcwLDExOTkxNyw3MCwxMjAwMjEsNzAsMTIwMDczLDcwLDEyMDEyNSw3MCwxMjAxNzcsNzAsMTIwMjI5LDcwLDEyMDI4MSw3MCwxMjAzMzMsNzAsMTIwMzg1LDcwLDEyMDQzNyw3MCw0MjkwNCw3MCw5ODgsNzAsMTIwNzc4LDcwLDU1NTYsNzAsNDIyMDUsNzAsNzE4NzQsNzAsNzE4NDIsNzAsNjYxODMsNzAsNjYyMTMsNzAsNjY4NTMsNzAsNjUzNTEsMTAzLDg0NTgsMTAzLDExOTg0MCwxMDMsMTE5ODkyLDEwMywxMTk5NDQsMTAzLDEyMDA0OCwxMDMsMTIwMTAwLDEwMywxMjAxNTIsMTAzLDEyMDIwNCwxMDMsMTIwMjU2LDEwMywxMjAzMDgsMTAzLDEyMDM2MCwxMDMsMTIwNDEyLDEwMywxMjA0NjQsMTAzLDYwOSwxMDMsNzU1NSwxMDMsMzk3LDEwMywxNDA5LDEwMywxMTk4MTQsNzEsMTE5ODY2LDcxLDExOTkxOCw3MSwxMTk5NzAsNzEsMTIwMDIyLDcxLDEyMDA3NCw3MSwxMjAxMjYsNzEsMTIwMTc4LDcxLDEyMDIzMCw3MSwxMjAyODIsNzEsMTIwMzM0LDcxLDEyMDM4Niw3MSwxMjA0MzgsNzEsMTI5Miw3MSw1MDU2LDcxLDUxMDcsNzEsNDIxOTgsNzEsNjUzNTIsMTA0LDg0NjIsMTA0LDExOTg0MSwxMDQsMTE5OTQ1LDEwNCwxMTk5OTcsMTA0LDEyMDA0OSwxMDQsMTIwMTAxLDEwNCwxMjAxNTMsMTA0LDEyMDIwNSwxMDQsMTIwMjU3LDEwNCwxMjAzMDksMTA0LDEyMDM2MSwxMDQsMTIwNDEzLDEwNCwxMjA0NjUsMTA0LDEyMTEsMTA0LDEzOTIsMTA0LDUwNTgsMTA0LDY1MzIwLDcyLDg0NTksNzIsODQ2MCw3Miw4NDYxLDcyLDExOTgxNSw3MiwxMTk4NjcsNzIsMTE5OTE5LDcyLDEyMDAyMyw3MiwxMjAxNzksNzIsMTIwMjMxLDcyLDEyMDI4Myw3MiwxMjAzMzUsNzIsMTIwMzg3LDcyLDEyMDQzOSw3Miw5MTksNzIsMTIwNDk0LDcyLDEyMDU1Miw3MiwxMjA2MTAsNzIsMTIwNjY4LDcyLDEyMDcyNiw3MiwxMTQwNiw3Miw1MDUxLDcyLDU1MDAsNzIsNDIyMTUsNzIsNjYyNTUsNzIsNzMxLDEwNSw5MDc1LDEwNSw2NTM1MywxMDUsODU2MCwxMDUsODUwNSwxMDUsODUyMCwxMDUsMTE5ODQyLDEwNSwxMTk4OTQsMTA1LDExOTk0NiwxMDUsMTE5OTk4LDEwNSwxMjAwNTAsMTA1LDEyMDEwMiwxMDUsMTIwMTU0LDEwNSwxMjAyMDYsMTA1LDEyMDI1OCwxMDUsMTIwMzEwLDEwNSwxMjAzNjIsMTA1LDEyMDQxNCwxMDUsMTIwNDY2LDEwNSwxMjA0ODQsMTA1LDYxOCwxMDUsNjE3LDEwNSw5NTMsMTA1LDgxMjYsMTA1LDg5MCwxMDUsMTIwNTIyLDEwNSwxMjA1ODAsMTA1LDEyMDYzOCwxMDUsMTIwNjk2LDEwNSwxMjA3NTQsMTA1LDExMTAsMTA1LDQyNTY3LDEwNSwxMjMxLDEwNSw0Mzg5MywxMDUsNTAyOSwxMDUsNzE4NzUsMTA1LDY1MzU0LDEwNiw4NTIxLDEwNiwxMTk4NDMsMTA2LDExOTg5NSwxMDYsMTE5OTQ3LDEwNiwxMTk5OTksMTA2LDEyMDA1MSwxMDYsMTIwMTAzLDEwNiwxMjAxNTUsMTA2LDEyMDIwNywxMDYsMTIwMjU5LDEwNiwxMjAzMTEsMTA2LDEyMDM2MywxMDYsMTIwNDE1LDEwNiwxMjA0NjcsMTA2LDEwMTEsMTA2LDExMTIsMTA2LDY1MzIyLDc0LDExOTgxNyw3NCwxMTk4NjksNzQsMTE5OTIxLDc0LDExOTk3Myw3NCwxMjAwMjUsNzQsMTIwMDc3LDc0LDEyMDEyOSw3NCwxMjAxODEsNzQsMTIwMjMzLDc0LDEyMDI4NSw3NCwxMjAzMzcsNzQsMTIwMzg5LDc0LDEyMDQ0MSw3NCw0MjkzMCw3NCw4OTUsNzQsMTAzMiw3NCw1MDM1LDc0LDUyNjEsNzQsNDIyMDEsNzQsMTE5ODQ0LDEwNywxMTk4OTYsMTA3LDExOTk0OCwxMDcsMTIwMDAwLDEwNywxMjAwNTIsMTA3LDEyMDEwNCwxMDcsMTIwMTU2LDEwNywxMjAyMDgsMTA3LDEyMDI2MCwxMDcsMTIwMzEyLDEwNywxMjAzNjQsMTA3LDEyMDQxNiwxMDcsMTIwNDY4LDEwNyw4NDkwLDc1LDY1MzIzLDc1LDExOTgxOCw3NSwxMTk4NzAsNzUsMTE5OTIyLDc1LDExOTk3NCw3NSwxMjAwMjYsNzUsMTIwMDc4LDc1LDEyMDEzMCw3NSwxMjAxODIsNzUsMTIwMjM0LDc1LDEyMDI4Niw3NSwxMjAzMzgsNzUsMTIwMzkwLDc1LDEyMDQ0Miw3NSw5MjIsNzUsMTIwNDk3LDc1LDEyMDU1NSw3NSwxMjA2MTMsNzUsMTIwNjcxLDc1LDEyMDcyOSw3NSwxMTQxMiw3NSw1MDk0LDc1LDU4NDUsNzUsNDIxOTksNzUsNjY4NDAsNzUsMTQ3MiwxMDgsODczOSw3Myw5MjEzLDczLDY1NTEyLDczLDE2MzMsMTA4LDE3NzcsNzMsNjYzMzYsMTA4LDEyNTEyNywxMDgsMTIwNzgzLDczLDEyMDc5Myw3MywxMjA4MDMsNzMsMTIwODEzLDczLDEyMDgyMyw3MywxMzAwMzMsNzMsNjUzMjEsNzMsODU0NCw3Myw4NDY0LDczLDg0NjUsNzMsMTE5ODE2LDczLDExOTg2OCw3MywxMTk5MjAsNzMsMTIwMDI0LDczLDEyMDEyOCw3MywxMjAxODAsNzMsMTIwMjMyLDczLDEyMDI4NCw3MywxMjAzMzYsNzMsMTIwMzg4LDczLDEyMDQ0MCw3Myw2NTM1NiwxMDgsODU3Miw3Myw4NDY3LDEwOCwxMTk4NDUsMTA4LDExOTg5NywxMDgsMTE5OTQ5LDEwOCwxMjAwMDEsMTA4LDEyMDA1MywxMDgsMTIwMTA1LDczLDEyMDE1Nyw3MywxMjAyMDksNzMsMTIwMjYxLDczLDEyMDMxMyw3MywxMjAzNjUsNzMsMTIwNDE3LDczLDEyMDQ2OSw3Myw0NDgsNzMsMTIwNDk2LDczLDEyMDU1NCw3MywxMjA2MTIsNzMsMTIwNjcwLDczLDEyMDcyOCw3MywxMTQxMCw3MywxMDMwLDczLDEyMTYsNzMsMTQ5MywxMDgsMTUwMywxMDgsMTU3NSwxMDgsMTI2NDY0LDEwOCwxMjY1OTIsMTA4LDY1MTY2LDEwOCw2NTE2NSwxMDgsMTk5NCwxMDgsMTE1OTksNzMsNTgyNSw3Myw0MjIyNiw3Myw5Mzk5Miw3Myw2NjE4NiwxMjQsNjYzMTMsMTI0LDExOTMzOCw3Niw4NTU2LDc2LDg0NjYsNzYsMTE5ODE5LDc2LDExOTg3MSw3NiwxMTk5MjMsNzYsMTIwMDI3LDc2LDEyMDA3OSw3NiwxMjAxMzEsNzYsMTIwMTgzLDc2LDEyMDIzNSw3NiwxMjAyODcsNzYsMTIwMzM5LDc2LDEyMDM5MSw3NiwxMjA0NDMsNzYsMTE0NzIsNzYsNTA4Niw3Niw1MjkwLDc2LDQyMjA5LDc2LDkzOTc0LDc2LDcxODQzLDc2LDcxODU4LDc2LDY2NTg3LDc2LDY2ODU0LDc2LDY1MzI1LDc3LDg1NTksNzcsODQ5OSw3NywxMTk4MjAsNzcsMTE5ODcyLDc3LDExOTkyNCw3NywxMjAwMjgsNzcsMTIwMDgwLDc3LDEyMDEzMiw3NywxMjAxODQsNzcsMTIwMjM2LDc3LDEyMDI4OCw3NywxMjAzNDAsNzcsMTIwMzkyLDc3LDEyMDQ0NCw3Nyw5MjQsNzcsMTIwNDk5LDc3LDEyMDU1Nyw3NywxMjA2MTUsNzcsMTIwNjczLDc3LDEyMDczMSw3NywxMDE4LDc3LDExNDE2LDc3LDUwNDcsNzcsNTYxNiw3Nyw1ODQ2LDc3LDQyMjA3LDc3LDY2MjI0LDc3LDY2MzIxLDc3LDExOTg0NywxMTAsMTE5ODk5LDExMCwxMTk5NTEsMTEwLDEyMDAwMywxMTAsMTIwMDU1LDExMCwxMjAxMDcsMTEwLDEyMDE1OSwxMTAsMTIwMjExLDExMCwxMjAyNjMsMTEwLDEyMDMxNSwxMTAsMTIwMzY3LDExMCwxMjA0MTksMTEwLDEyMDQ3MSwxMTAsMTQwMCwxMTAsMTQwNCwxMTAsNjUzMjYsNzgsODQ2OSw3OCwxMTk4MjEsNzgsMTE5ODczLDc4LDExOTkyNSw3OCwxMTk5NzcsNzgsMTIwMDI5LDc4LDEyMDA4MSw3OCwxMjAxODUsNzgsMTIwMjM3LDc4LDEyMDI4OSw3OCwxMjAzNDEsNzgsMTIwMzkzLDc4LDEyMDQ0NSw3OCw5MjUsNzgsMTIwNTAwLDc4LDEyMDU1OCw3OCwxMjA2MTYsNzgsMTIwNjc0LDc4LDEyMDczMiw3OCwxMTQxOCw3OCw0MjIwOCw3OCw2NjgzNSw3OCwzMDc0LDExMSwzMjAyLDExMSwzMzMwLDExMSwzNDU4LDExMSwyNDA2LDExMSwyNjYyLDExMSwyNzkwLDExMSwzMDQ2LDExMSwzMTc0LDExMSwzMzAyLDExMSwzNDMwLDExMSwzNjY0LDExMSwzNzkyLDExMSw0MTYwLDExMSwxNjM3LDExMSwxNzgxLDExMSw2NTM1OSwxMTEsODUwMCwxMTEsMTE5ODQ4LDExMSwxMTk5MDAsMTExLDExOTk1MiwxMTEsMTIwMDU2LDExMSwxMjAxMDgsMTExLDEyMDE2MCwxMTEsMTIwMjEyLDExMSwxMjAyNjQsMTExLDEyMDMxNiwxMTEsMTIwMzY4LDExMSwxMjA0MjAsMTExLDEyMDQ3MiwxMTEsNzQzOSwxMTEsNzQ0MSwxMTEsNDM4MzcsMTExLDk1OSwxMTEsMTIwNTI4LDExMSwxMjA1ODYsMTExLDEyMDY0NCwxMTEsMTIwNzAyLDExMSwxMjA3NjAsMTExLDk2MywxMTEsMTIwNTMyLDExMSwxMjA1OTAsMTExLDEyMDY0OCwxMTEsMTIwNzA2LDExMSwxMjA3NjQsMTExLDExNDIzLDExMSw0MzUxLDExMSwxNDEzLDExMSwxNTA1LDExMSwxNjA3LDExMSwxMjY1MDAsMTExLDEyNjU2NCwxMTEsMTI2NTk2LDExMSw2NTI1OSwxMTEsNjUyNjAsMTExLDY1MjU4LDExMSw2NTI1NywxMTEsMTcyNiwxMTEsNjQ0MjgsMTExLDY0NDI5LDExMSw2NDQyNywxMTEsNjQ0MjYsMTExLDE3MjksMTExLDY0NDI0LDExMSw2NDQyNSwxMTEsNjQ0MjMsMTExLDY0NDIyLDExMSwxNzQ5LDExMSwzMzYwLDExMSw0MTI1LDExMSw2Njc5NCwxMTEsNzE4ODAsMTExLDcxODk1LDExMSw2NjYwNCwxMTEsMTk4NCw3OSwyNTM0LDc5LDI5MTgsNzksMTIyOTUsNzksNzA4NjQsNzksNzE5MDQsNzksMTIwNzgyLDc5LDEyMDc5Miw3OSwxMjA4MDIsNzksMTIwODEyLDc5LDEyMDgyMiw3OSwxMzAwMzIsNzksNjUzMjcsNzksMTE5ODIyLDc5LDExOTg3NCw3OSwxMTk5MjYsNzksMTE5OTc4LDc5LDEyMDAzMCw3OSwxMjAwODIsNzksMTIwMTM0LDc5LDEyMDE4Niw3OSwxMjAyMzgsNzksMTIwMjkwLDc5LDEyMDM0Miw3OSwxMjAzOTQsNzksMTIwNDQ2LDc5LDkyNyw3OSwxMjA1MDIsNzksMTIwNTYwLDc5LDEyMDYxOCw3OSwxMjA2NzYsNzksMTIwNzM0LDc5LDExNDIyLDc5LDEzNjUsNzksMTE2MDQsNzksNDgxNiw3OSwyODQ4LDc5LDY2NzU0LDc5LDQyMjI3LDc5LDcxODYxLDc5LDY2MTk0LDc5LDY2MjE5LDc5LDY2NTY0LDc5LDY2ODM4LDc5LDkwNzYsMTEyLDY1MzYwLDExMiwxMTk4NDksMTEyLDExOTkwMSwxMTIsMTE5OTUzLDExMiwxMjAwMDUsMTEyLDEyMDA1NywxMTIsMTIwMTA5LDExMiwxMjAxNjEsMTEyLDEyMDIxMywxMTIsMTIwMjY1LDExMiwxMjAzMTcsMTEyLDEyMDM2OSwxMTIsMTIwNDIxLDExMiwxMjA0NzMsMTEyLDk2MSwxMTIsMTIwNTMwLDExMiwxMjA1NDQsMTEyLDEyMDU4OCwxMTIsMTIwNjAyLDExMiwxMjA2NDYsMTEyLDEyMDY2MCwxMTIsMTIwNzA0LDExMiwxMjA3MTgsMTEyLDEyMDc2MiwxMTIsMTIwNzc2LDExMiwxMTQyNywxMTIsNjUzMjgsODAsODQ3Myw4MCwxMTk4MjMsODAsMTE5ODc1LDgwLDExOTkyNyw4MCwxMTk5NzksODAsMTIwMDMxLDgwLDEyMDA4Myw4MCwxMjAxODcsODAsMTIwMjM5LDgwLDEyMDI5MSw4MCwxMjAzNDMsODAsMTIwMzk1LDgwLDEyMDQ0Nyw4MCw5MjksODAsMTIwNTA0LDgwLDEyMDU2Miw4MCwxMjA2MjAsODAsMTIwNjc4LDgwLDEyMDczNiw4MCwxMTQyNiw4MCw1MDkwLDgwLDUyMjksODAsNDIxOTMsODAsNjYxOTcsODAsMTE5ODUwLDExMywxMTk5MDIsMTEzLDExOTk1NCwxMTMsMTIwMDA2LDExMywxMjAwNTgsMTEzLDEyMDExMCwxMTMsMTIwMTYyLDExMywxMjAyMTQsMTEzLDEyMDI2NiwxMTMsMTIwMzE4LDExMywxMjAzNzAsMTEzLDEyMDQyMiwxMTMsMTIwNDc0LDExMywxMzA3LDExMywxMzc5LDExMywxMzgyLDExMyw4NDc0LDgxLDExOTgyNCw4MSwxMTk4NzYsODEsMTE5OTI4LDgxLDExOTk4MCw4MSwxMjAwMzIsODEsMTIwMDg0LDgxLDEyMDE4OCw4MSwxMjAyNDAsODEsMTIwMjkyLDgxLDEyMDM0NCw4MSwxMjAzOTYsODEsMTIwNDQ4LDgxLDExNjA1LDgxLDExOTg1MSwxMTQsMTE5OTAzLDExNCwxMTk5NTUsMTE0LDEyMDAwNywxMTQsMTIwMDU5LDExNCwxMjAxMTEsMTE0LDEyMDE2MywxMTQsMTIwMjE1LDExNCwxMjAyNjcsMTE0LDEyMDMxOSwxMTQsMTIwMzcxLDExNCwxMjA0MjMsMTE0LDEyMDQ3NSwxMTQsNDM4NDcsMTE0LDQzODQ4LDExNCw3NDYyLDExNCwxMTM5NywxMTQsNDM5MDUsMTE0LDExOTMxOCw4Miw4NDc1LDgyLDg0NzYsODIsODQ3Nyw4MiwxMTk4MjUsODIsMTE5ODc3LDgyLDExOTkyOSw4MiwxMjAwMzMsODIsMTIwMTg5LDgyLDEyMDI0MSw4MiwxMjAyOTMsODIsMTIwMzQ1LDgyLDEyMDM5Nyw4MiwxMjA0NDksODIsNDIyLDgyLDUwMjUsODIsNTA3NCw4Miw2Njc0MCw4Miw1NTExLDgyLDQyMjExLDgyLDk0MDA1LDgyLDY1MzYzLDExNSwxMTk4NTIsMTE1LDExOTkwNCwxMTUsMTE5OTU2LDExNSwxMjAwMDgsMTE1LDEyMDA2MCwxMTUsMTIwMTEyLDExNSwxMjAxNjQsMTE1LDEyMDIxNiwxMTUsMTIwMjY4LDExNSwxMjAzMjAsMTE1LDEyMDM3MiwxMTUsMTIwNDI0LDExNSwxMjA0NzYsMTE1LDQyODAxLDExNSw0NDUsMTE1LDExMDksMTE1LDQzOTQ2LDExNSw3MTg3MywxMTUsNjY2MzIsMTE1LDY1MzMxLDgzLDExOTgyNiw4MywxMTk4NzgsODMsMTE5OTMwLDgzLDExOTk4Miw4MywxMjAwMzQsODMsMTIwMDg2LDgzLDEyMDEzOCw4MywxMjAxOTAsODMsMTIwMjQyLDgzLDEyMDI5NCw4MywxMjAzNDYsODMsMTIwMzk4LDgzLDEyMDQ1MCw4MywxMDI5LDgzLDEzNTksODMsNTA3Nyw4Myw1MDgyLDgzLDQyMjEwLDgzLDk0MDEwLDgzLDY2MTk4LDgzLDY2NTkyLDgzLDExOTg1MywxMTYsMTE5OTA1LDExNiwxMTk5NTcsMTE2LDEyMDAwOSwxMTYsMTIwMDYxLDExNiwxMjAxMTMsMTE2LDEyMDE2NSwxMTYsMTIwMjE3LDExNiwxMjAyNjksMTE2LDEyMDMyMSwxMTYsMTIwMzczLDExNiwxMjA0MjUsMTE2LDEyMDQ3NywxMTYsODg2OCw4NCwxMDIwMSw4NCwxMjg4NzIsODQsNjUzMzIsODQsMTE5ODI3LDg0LDExOTg3OSw4NCwxMTk5MzEsODQsMTE5OTgzLDg0LDEyMDAzNSw4NCwxMjAwODcsODQsMTIwMTM5LDg0LDEyMDE5MSw4NCwxMjAyNDMsODQsMTIwMjk1LDg0LDEyMDM0Nyw4NCwxMjAzOTksODQsMTIwNDUxLDg0LDkzMiw4NCwxMjA1MDcsODQsMTIwNTY1LDg0LDEyMDYyMyw4NCwxMjA2ODEsODQsMTIwNzM5LDg0LDExNDMwLDg0LDUwMjYsODQsNDIxOTYsODQsOTM5NjIsODQsNzE4NjgsODQsNjYxOTksODQsNjYyMjUsODQsNjYzMjUsODQsMTE5ODU0LDExNywxMTk5MDYsMTE3LDExOTk1OCwxMTcsMTIwMDEwLDExNywxMjAwNjIsMTE3LDEyMDExNCwxMTcsMTIwMTY2LDExNywxMjAyMTgsMTE3LDEyMDI3MCwxMTcsMTIwMzIyLDExNywxMjAzNzQsMTE3LDEyMDQyNiwxMTcsMTIwNDc4LDExNyw0MjkxMSwxMTcsNzQ1MiwxMTcsNDM4NTQsMTE3LDQzODU4LDExNyw2NTEsMTE3LDk2NSwxMTcsMTIwNTM0LDExNywxMjA1OTIsMTE3LDEyMDY1MCwxMTcsMTIwNzA4LDExNywxMjA3NjYsMTE3LDE0MDUsMTE3LDY2ODA2LDExNyw3MTg5NiwxMTcsODc0Niw4NSw4ODk5LDg1LDExOTgyOCw4NSwxMTk4ODAsODUsMTE5OTMyLDg1LDExOTk4NCw4NSwxMjAwMzYsODUsMTIwMDg4LDg1LDEyMDE0MCw4NSwxMjAxOTIsODUsMTIwMjQ0LDg1LDEyMDI5Niw4NSwxMjAzNDgsODUsMTIwNDAwLDg1LDEyMDQ1Miw4NSwxMzU3LDg1LDQ2MDgsODUsNjY3NjYsODUsNTE5Niw4NSw0MjIyOCw4NSw5NDAxOCw4NSw3MTg2NCw4NSw4NzQ0LDExOCw4ODk3LDExOCw2NTM2NiwxMTgsODU2NCwxMTgsMTE5ODU1LDExOCwxMTk5MDcsMTE4LDExOTk1OSwxMTgsMTIwMDExLDExOCwxMjAwNjMsMTE4LDEyMDExNSwxMTgsMTIwMTY3LDExOCwxMjAyMTksMTE4LDEyMDI3MSwxMTgsMTIwMzIzLDExOCwxMjAzNzUsMTE4LDEyMDQyNywxMTgsMTIwNDc5LDExOCw3NDU2LDExOCw5NTcsMTE4LDEyMDUyNiwxMTgsMTIwNTg0LDExOCwxMjA2NDIsMTE4LDEyMDcwMCwxMTgsMTIwNzU4LDExOCwxMTQxLDExOCwxNDk2LDExOCw3MTQzMCwxMTgsNDM5NDUsMTE4LDcxODcyLDExOCwxMTkzMDksODYsMTYzOSw4NiwxNzgzLDg2LDg1NDgsODYsMTE5ODI5LDg2LDExOTg4MSw4NiwxMTk5MzMsODYsMTE5OTg1LDg2LDEyMDAzNyw4NiwxMjAwODksODYsMTIwMTQxLDg2LDEyMDE5Myw4NiwxMjAyNDUsODYsMTIwMjk3LDg2LDEyMDM0OSw4NiwxMjA0MDEsODYsMTIwNDUzLDg2LDExNDAsODYsMTE1NzYsODYsNTA4MSw4Niw1MTY3LDg2LDQyNzE5LDg2LDQyMjE0LDg2LDkzOTYwLDg2LDcxODQwLDg2LDY2ODQ1LDg2LDYyMywxMTksMTE5ODU2LDExOSwxMTk5MDgsMTE5LDExOTk2MCwxMTksMTIwMDEyLDExOSwxMjAwNjQsMTE5LDEyMDExNiwxMTksMTIwMTY4LDExOSwxMjAyMjAsMTE5LDEyMDI3MiwxMTksMTIwMzI0LDExOSwxMjAzNzYsMTE5LDEyMDQyOCwxMTksMTIwNDgwLDExOSw3NDU3LDExOSwxMTIxLDExOSwxMzA5LDExOSwxMzc3LDExOSw3MTQzNCwxMTksNzE0MzgsMTE5LDcxNDM5LDExOSw0MzkwNywxMTksNzE5MTksODcsNzE5MTAsODcsMTE5ODMwLDg3LDExOTg4Miw4NywxMTk5MzQsODcsMTE5OTg2LDg3LDEyMDAzOCw4NywxMjAwOTAsODcsMTIwMTQyLDg3LDEyMDE5NCw4NywxMjAyNDYsODcsMTIwMjk4LDg3LDEyMDM1MCw4NywxMjA0MDIsODcsMTIwNDU0LDg3LDEzMDgsODcsNTA0Myw4Nyw1MDc2LDg3LDQyMjE4LDg3LDU3NDIsMTIwLDEwNTM5LDEyMCwxMDU0MCwxMjAsMTA3OTksMTIwLDY1MzY4LDEyMCw4NTY5LDEyMCwxMTk4NTcsMTIwLDExOTkwOSwxMjAsMTE5OTYxLDEyMCwxMjAwMTMsMTIwLDEyMDA2NSwxMjAsMTIwMTE3LDEyMCwxMjAxNjksMTIwLDEyMDIyMSwxMjAsMTIwMjczLDEyMCwxMjAzMjUsMTIwLDEyMDM3NywxMjAsMTIwNDI5LDEyMCwxMjA0ODEsMTIwLDU0NDEsMTIwLDU1MDEsMTIwLDU3NDEsODgsOTU4Nyw4OCw2NjMzOCw4OCw3MTkxNiw4OCw2NTMzNiw4OCw4NTUzLDg4LDExOTgzMSw4OCwxMTk4ODMsODgsMTE5OTM1LDg4LDExOTk4Nyw4OCwxMjAwMzksODgsMTIwMDkxLDg4LDEyMDE0Myw4OCwxMjAxOTUsODgsMTIwMjQ3LDg4LDEyMDI5OSw4OCwxMjAzNTEsODgsMTIwNDAzLDg4LDEyMDQ1NSw4OCw0MjkzMSw4OCw5MzUsODgsMTIwNTEwLDg4LDEyMDU2OCw4OCwxMjA2MjYsODgsMTIwNjg0LDg4LDEyMDc0Miw4OCwxMTQzNiw4OCwxMTYxMyw4OCw1ODE1LDg4LDQyMjE5LDg4LDY2MTkyLDg4LDY2MjI4LDg4LDY2MzI3LDg4LDY2ODU1LDg4LDYxMSwxMjEsNzU2NCwxMjEsNjUzNjksMTIxLDExOTg1OCwxMjEsMTE5OTEwLDEyMSwxMTk5NjIsMTIxLDEyMDAxNCwxMjEsMTIwMDY2LDEyMSwxMjAxMTgsMTIxLDEyMDE3MCwxMjEsMTIwMjIyLDEyMSwxMjAyNzQsMTIxLDEyMDMyNiwxMjEsMTIwMzc4LDEyMSwxMjA0MzAsMTIxLDEyMDQ4MiwxMjEsNjU1LDEyMSw3OTM1LDEyMSw0Mzg2NiwxMjEsOTQ3LDEyMSw4NTA5LDEyMSwxMjA1MTYsMTIxLDEyMDU3NCwxMjEsMTIwNjMyLDEyMSwxMjA2OTAsMTIxLDEyMDc0OCwxMjEsMTE5OSwxMjEsNDMyNywxMjEsNzE5MDAsMTIxLDY1MzM3LDg5LDExOTgzMiw4OSwxMTk4ODQsODksMTE5OTM2LDg5LDExOTk4OCw4OSwxMjAwNDAsODksMTIwMDkyLDg5LDEyMDE0NCw4OSwxMjAxOTYsODksMTIwMjQ4LDg5LDEyMDMwMCw4OSwxMjAzNTIsODksMTIwNDA0LDg5LDEyMDQ1Niw4OSw5MzMsODksOTc4LDg5LDEyMDUwOCw4OSwxMjA1NjYsODksMTIwNjI0LDg5LDEyMDY4Miw4OSwxMjA3NDAsODksMTE0MzIsODksMTE5OCw4OSw1MDMzLDg5LDUwNTMsODksNDIyMjAsODksOTQwMTksODksNzE4NDQsODksNjYyMjYsODksMTE5ODU5LDEyMiwxMTk5MTEsMTIyLDExOTk2MywxMjIsMTIwMDE1LDEyMiwxMjAwNjcsMTIyLDEyMDExOSwxMjIsMTIwMTcxLDEyMiwxMjAyMjMsMTIyLDEyMDI3NSwxMjIsMTIwMzI3LDEyMiwxMjAzNzksMTIyLDEyMDQzMSwxMjIsMTIwNDgzLDEyMiw3NDU4LDEyMiw0MzkyMywxMjIsNzE4NzYsMTIyLDY2MjkzLDkwLDcxOTA5LDkwLDY1MzM4LDkwLDg0ODQsOTAsODQ4OCw5MCwxMTk4MzMsOTAsMTE5ODg1LDkwLDExOTkzNyw5MCwxMTk5ODksOTAsMTIwMDQxLDkwLDEyMDE5Nyw5MCwxMjAyNDksOTAsMTIwMzAxLDkwLDEyMDM1Myw5MCwxMjA0MDUsOTAsMTIwNDU3LDkwLDkxOCw5MCwxMjA0OTMsOTAsMTIwNTUxLDkwLDEyMDYwOSw5MCwxMjA2NjcsOTAsMTIwNzI1LDkwLDUwNTksOTAsNDIyMDQsOTAsNzE4NDksOTAsNjUyODIsMzQsNjUyODQsMzYsNjUyODUsMzcsNjUyODYsMzgsNjUyOTAsNDIsNjUyOTEsNDMsNjUyOTQsNDYsNjUyOTUsNDcsNjUyOTYsNDgsNjUyOTcsNDksNjUyOTgsNTAsNjUyOTksNTEsNjUzMDAsNTIsNjUzMDEsNTMsNjUzMDIsNTQsNjUzMDMsNTUsNjUzMDQsNTYsNjUzMDUsNTcsNjUzMDgsNjAsNjUzMDksNjEsNjUzMTAsNjIsNjUzMTIsNjQsNjUzMTYsNjgsNjUzMTgsNzAsNjUzMTksNzEsNjUzMjQsNzYsNjUzMjksODEsNjUzMzAsODIsNjUzMzMsODUsNjUzMzQsODYsNjUzMzUsODcsNjUzNDMsOTUsNjUzNDYsOTgsNjUzNDgsMTAwLDY1MzUwLDEwMiw2NTM1NSwxMDcsNjUzNTcsMTA5LDY1MzU4LDExMCw2NTM2MSwxMTMsNjUzNjIsMTE0LDY1MzY0LDExNiw2NTM2NSwxMTcsNjUzNjcsMTE5LDY1MzcwLDEyMiw2NTM3MSwxMjMsNjUzNzMsMTI1LDExOTg0NiwxMDldLFxcXCJfZGVmYXVsdFxcXCI6WzE2MCwzMiw4MjExLDQ1LDY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyMTcsOTYsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJjc1xcXCI6WzY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyMTcsOTYsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwiZGVcXFwiOls2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjE3LDk2LDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcImVzXFxcIjpbODIxMSw0NSw2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcImZyXFxcIjpbNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODI0NSw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcIml0XFxcIjpbMTYwLDMyLDgyMTEsNDUsNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJqYVxcXCI6WzgyMTEsNDUsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjE3LDk2LDgyNDUsOTYsMTgwLDk2LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1MjkyLDQ0LDY1MzA3LDU5XSxcXFwia29cXFwiOls4MjExLDQ1LDY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcInBsXFxcIjpbNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcInB0LUJSXFxcIjpbNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcInFwcy1wbG9jXFxcIjpbMTYwLDMyLDgyMTEsNDUsNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcInJ1XFxcIjpbNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywzMDUsMTA1LDkyMSw3MywxMDA5LDExMiwyMTUsMTIwLDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwidHJcXFwiOlsxNjAsMzIsODIxMSw0NSw2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwiemgtaGFuc1xcXCI6WzY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4OCw0MCw2NTI4OSw0MV0sXFxcInpoLWhhbnRcXFwiOls4MjExLDQ1LDY1Mzc0LDEyNiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUzMDcsNTldfScpO1xuICAgIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy5jYWNoZSA9IG5ldyBMUlVDYWNoZWRGdW5jdGlvbih7IGdldENhY2hlS2V5OiBKU09OLnN0cmluZ2lmeSB9LCAobG9jYWxlcykgPT4ge1xuICAgICAgICBmdW5jdGlvbiBhcnJheVRvTWFwKGFycikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGFycltpXSwgYXJyW2kgKyAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlTWFwcyhtYXAxLCBtYXAyKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKG1hcDEpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGludGVyc2VjdE1hcHMobWFwMSwgbWFwMikge1xuICAgICAgICAgICAgaWYgKCFtYXAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcDIuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmFtYmlndW91c0NoYXJhY3RlckRhdGEudmFsdWU7XG4gICAgICAgIGxldCBmaWx0ZXJlZExvY2FsZXMgPSBsb2NhbGVzLmZpbHRlcigobCkgPT4gIWwuc3RhcnRzV2l0aCgnXycpICYmIGwgaW4gZGF0YSk7XG4gICAgICAgIGlmIChmaWx0ZXJlZExvY2FsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZExvY2FsZXMgPSBbJ19kZWZhdWx0J107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhbmd1YWdlU3BlY2lmaWNNYXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxlIG9mIGZpbHRlcmVkTG9jYWxlcykge1xuICAgICAgICAgICAgY29uc3QgbWFwID0gYXJyYXlUb01hcChkYXRhW2xvY2FsZV0pO1xuICAgICAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpY01hcCA9IGludGVyc2VjdE1hcHMobGFuZ3VhZ2VTcGVjaWZpY01hcCwgbWFwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21tb25NYXAgPSBhcnJheVRvTWFwKGRhdGFbJ19jb21tb24nXSk7XG4gICAgICAgIGNvbnN0IG1hcCA9IG1lcmdlTWFwcyhjb21tb25NYXAsIGxhbmd1YWdlU3BlY2lmaWNNYXApO1xuICAgICAgICByZXR1cm4gbmV3IEFtYmlndW91c0NoYXJhY3RlcnMobWFwKTtcbiAgICB9KTsgfVxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZShsb2NhbGVzKSB7XG4gICAgICAgIHJldHVybiBBbWJpZ3VvdXNDaGFyYWN0ZXJzLmNhY2hlLmdldChBcnJheS5mcm9tKGxvY2FsZXMpKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy5fbG9jYWxlcyA9IG5ldyBMYXp5KCgpID0+IE9iamVjdC5rZXlzKEFtYmlndW91c0NoYXJhY3RlcnMuYW1iaWd1b3VzQ2hhcmFjdGVyRGF0YS52YWx1ZSkuZmlsdGVyKChrKSA9PiAhay5zdGFydHNXaXRoKCdfJykpKTsgfVxuICAgIHN0YXRpYyBnZXRMb2NhbGVzKCkge1xuICAgICAgICByZXR1cm4gQW1iaWd1b3VzQ2hhcmFjdGVycy5fbG9jYWxlcy52YWx1ZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29uZnVzYWJsZURpY3Rpb25hcnkpIHtcbiAgICAgICAgdGhpcy5jb25mdXNhYmxlRGljdGlvbmFyeSA9IGNvbmZ1c2FibGVEaWN0aW9uYXJ5O1xuICAgIH1cbiAgICBpc0FtYmlndW91cyhjb2RlUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZnVzYWJsZURpY3Rpb25hcnkuaGFzKGNvZGVQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5vbiBiYXNpYyBBU0NJSSBjb2RlIHBvaW50IHRoYXQgdGhlIGdpdmVuIGNvZGUgcG9pbnQgY2FuIGJlIGNvbmZ1c2VkLFxuICAgICAqIG9yIHVuZGVmaW5lZCBpZiBzdWNoIGNvZGUgcG9pbnQgZG9lcyBub3RlIGV4aXN0LlxuICAgICAqL1xuICAgIGdldFByaW1hcnlDb25mdXNhYmxlKGNvZGVQb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25mdXNhYmxlRGljdGlvbmFyeS5nZXQoY29kZVBvaW50KTtcbiAgICB9XG4gICAgZ2V0Q29uZnVzYWJsZUNvZGVQb2ludHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuY29uZnVzYWJsZURpY3Rpb25hcnkua2V5cygpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW52aXNpYmxlQ2hhcmFjdGVycyB7XG4gICAgc3RhdGljIGdldFJhd0RhdGEoKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlZCB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vaGVkaWV0L3ZzY29kZS11bmljb2RlLWRhdGFcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoJ1s5LDEwLDExLDEyLDEzLDMyLDEyNywxNjAsMTczLDg0NywxNTY0LDQ0NDcsNDQ0OCw2MDY4LDYwNjksNjE1NSw2MTU2LDYxNTcsNjE1OCw3MzU1LDczNTYsODE5Miw4MTkzLDgxOTQsODE5NSw4MTk2LDgxOTcsODE5OCw4MTk5LDgyMDAsODIwMSw4MjAyLDgyMDMsODIwNCw4MjA1LDgyMDYsODIwNyw4MjM0LDgyMzUsODIzNiw4MjM3LDgyMzgsODIzOSw4Mjg3LDgyODgsODI4OSw4MjkwLDgyOTEsODI5Miw4MjkzLDgyOTQsODI5NSw4Mjk2LDgyOTcsODI5OCw4Mjk5LDgzMDAsODMwMSw4MzAyLDgzMDMsMTAyNDAsMTIyODgsMTI2NDQsNjUwMjQsNjUwMjUsNjUwMjYsNjUwMjcsNjUwMjgsNjUwMjksNjUwMzAsNjUwMzEsNjUwMzIsNjUwMzMsNjUwMzQsNjUwMzUsNjUwMzYsNjUwMzcsNjUwMzgsNjUwMzksNjUyNzksNjU0NDAsNjU1MjAsNjU1MjEsNjU1MjIsNjU1MjMsNjU1MjQsNjU1MjUsNjU1MjYsNjU1MjcsNjU1MjgsNjU1MzIsNzg4NDQsMTE5MTU1LDExOTE1NiwxMTkxNTcsMTE5MTU4LDExOTE1OSwxMTkxNjAsMTE5MTYxLDExOTE2Miw5MTc1MDQsOTE3NTA1LDkxNzUwNiw5MTc1MDcsOTE3NTA4LDkxNzUwOSw5MTc1MTAsOTE3NTExLDkxNzUxMiw5MTc1MTMsOTE3NTE0LDkxNzUxNSw5MTc1MTYsOTE3NTE3LDkxNzUxOCw5MTc1MTksOTE3NTIwLDkxNzUyMSw5MTc1MjIsOTE3NTIzLDkxNzUyNCw5MTc1MjUsOTE3NTI2LDkxNzUyNyw5MTc1MjgsOTE3NTI5LDkxNzUzMCw5MTc1MzEsOTE3NTMyLDkxNzUzMyw5MTc1MzQsOTE3NTM1LDkxNzUzNiw5MTc1MzcsOTE3NTM4LDkxNzUzOSw5MTc1NDAsOTE3NTQxLDkxNzU0Miw5MTc1NDMsOTE3NTQ0LDkxNzU0NSw5MTc1NDYsOTE3NTQ3LDkxNzU0OCw5MTc1NDksOTE3NTUwLDkxNzU1MSw5MTc1NTIsOTE3NTUzLDkxNzU1NCw5MTc1NTUsOTE3NTU2LDkxNzU1Nyw5MTc1NTgsOTE3NTU5LDkxNzU2MCw5MTc1NjEsOTE3NTYyLDkxNzU2Myw5MTc1NjQsOTE3NTY1LDkxNzU2Niw5MTc1NjcsOTE3NTY4LDkxNzU2OSw5MTc1NzAsOTE3NTcxLDkxNzU3Miw5MTc1NzMsOTE3NTc0LDkxNzU3NSw5MTc1NzYsOTE3NTc3LDkxNzU3OCw5MTc1NzksOTE3NTgwLDkxNzU4MSw5MTc1ODIsOTE3NTgzLDkxNzU4NCw5MTc1ODUsOTE3NTg2LDkxNzU4Nyw5MTc1ODgsOTE3NTg5LDkxNzU5MCw5MTc1OTEsOTE3NTkyLDkxNzU5Myw5MTc1OTQsOTE3NTk1LDkxNzU5Niw5MTc1OTcsOTE3NTk4LDkxNzU5OSw5MTc2MDAsOTE3NjAxLDkxNzYwMiw5MTc2MDMsOTE3NjA0LDkxNzYwNSw5MTc2MDYsOTE3NjA3LDkxNzYwOCw5MTc2MDksOTE3NjEwLDkxNzYxMSw5MTc2MTIsOTE3NjEzLDkxNzYxNCw5MTc2MTUsOTE3NjE2LDkxNzYxNyw5MTc2MTgsOTE3NjE5LDkxNzYyMCw5MTc2MjEsOTE3NjIyLDkxNzYyMyw5MTc2MjQsOTE3NjI1LDkxNzYyNiw5MTc2MjcsOTE3NjI4LDkxNzYyOSw5MTc2MzAsOTE3NjMxLDkxNzc2MCw5MTc3NjEsOTE3NzYyLDkxNzc2Myw5MTc3NjQsOTE3NzY1LDkxNzc2Niw5MTc3NjcsOTE3NzY4LDkxNzc2OSw5MTc3NzAsOTE3NzcxLDkxNzc3Miw5MTc3NzMsOTE3Nzc0LDkxNzc3NSw5MTc3NzYsOTE3Nzc3LDkxNzc3OCw5MTc3NzksOTE3NzgwLDkxNzc4MSw5MTc3ODIsOTE3NzgzLDkxNzc4NCw5MTc3ODUsOTE3Nzg2LDkxNzc4Nyw5MTc3ODgsOTE3Nzg5LDkxNzc5MCw5MTc3OTEsOTE3NzkyLDkxNzc5Myw5MTc3OTQsOTE3Nzk1LDkxNzc5Niw5MTc3OTcsOTE3Nzk4LDkxNzc5OSw5MTc4MDAsOTE3ODAxLDkxNzgwMiw5MTc4MDMsOTE3ODA0LDkxNzgwNSw5MTc4MDYsOTE3ODA3LDkxNzgwOCw5MTc4MDksOTE3ODEwLDkxNzgxMSw5MTc4MTIsOTE3ODEzLDkxNzgxNCw5MTc4MTUsOTE3ODE2LDkxNzgxNyw5MTc4MTgsOTE3ODE5LDkxNzgyMCw5MTc4MjEsOTE3ODIyLDkxNzgyMyw5MTc4MjQsOTE3ODI1LDkxNzgyNiw5MTc4MjcsOTE3ODI4LDkxNzgyOSw5MTc4MzAsOTE3ODMxLDkxNzgzMiw5MTc4MzMsOTE3ODM0LDkxNzgzNSw5MTc4MzYsOTE3ODM3LDkxNzgzOCw5MTc4MzksOTE3ODQwLDkxNzg0MSw5MTc4NDIsOTE3ODQzLDkxNzg0NCw5MTc4NDUsOTE3ODQ2LDkxNzg0Nyw5MTc4NDgsOTE3ODQ5LDkxNzg1MCw5MTc4NTEsOTE3ODUyLDkxNzg1Myw5MTc4NTQsOTE3ODU1LDkxNzg1Niw5MTc4NTcsOTE3ODU4LDkxNzg1OSw5MTc4NjAsOTE3ODYxLDkxNzg2Miw5MTc4NjMsOTE3ODY0LDkxNzg2NSw5MTc4NjYsOTE3ODY3LDkxNzg2OCw5MTc4NjksOTE3ODcwLDkxNzg3MSw5MTc4NzIsOTE3ODczLDkxNzg3NCw5MTc4NzUsOTE3ODc2LDkxNzg3Nyw5MTc4NzgsOTE3ODc5LDkxNzg4MCw5MTc4ODEsOTE3ODgyLDkxNzg4Myw5MTc4ODQsOTE3ODg1LDkxNzg4Niw5MTc4ODcsOTE3ODg4LDkxNzg4OSw5MTc4OTAsOTE3ODkxLDkxNzg5Miw5MTc4OTMsOTE3ODk0LDkxNzg5NSw5MTc4OTYsOTE3ODk3LDkxNzg5OCw5MTc4OTksOTE3OTAwLDkxNzkwMSw5MTc5MDIsOTE3OTAzLDkxNzkwNCw5MTc5MDUsOTE3OTA2LDkxNzkwNyw5MTc5MDgsOTE3OTA5LDkxNzkxMCw5MTc5MTEsOTE3OTEyLDkxNzkxMyw5MTc5MTQsOTE3OTE1LDkxNzkxNiw5MTc5MTcsOTE3OTE4LDkxNzkxOSw5MTc5MjAsOTE3OTIxLDkxNzkyMiw5MTc5MjMsOTE3OTI0LDkxNzkyNSw5MTc5MjYsOTE3OTI3LDkxNzkyOCw5MTc5MjksOTE3OTMwLDkxNzkzMSw5MTc5MzIsOTE3OTMzLDkxNzkzNCw5MTc5MzUsOTE3OTM2LDkxNzkzNyw5MTc5MzgsOTE3OTM5LDkxNzk0MCw5MTc5NDEsOTE3OTQyLDkxNzk0Myw5MTc5NDQsOTE3OTQ1LDkxNzk0Niw5MTc5NDcsOTE3OTQ4LDkxNzk0OSw5MTc5NTAsOTE3OTUxLDkxNzk1Miw5MTc5NTMsOTE3OTU0LDkxNzk1NSw5MTc5NTYsOTE3OTU3LDkxNzk1OCw5MTc5NTksOTE3OTYwLDkxNzk2MSw5MTc5NjIsOTE3OTYzLDkxNzk2NCw5MTc5NjUsOTE3OTY2LDkxNzk2Nyw5MTc5NjgsOTE3OTY5LDkxNzk3MCw5MTc5NzEsOTE3OTcyLDkxNzk3Myw5MTc5NzQsOTE3OTc1LDkxNzk3Niw5MTc5NzcsOTE3OTc4LDkxNzk3OSw5MTc5ODAsOTE3OTgxLDkxNzk4Miw5MTc5ODMsOTE3OTg0LDkxNzk4NSw5MTc5ODYsOTE3OTg3LDkxNzk4OCw5MTc5ODksOTE3OTkwLDkxNzk5MSw5MTc5OTIsOTE3OTkzLDkxNzk5NCw5MTc5OTUsOTE3OTk2LDkxNzk5Nyw5MTc5OTgsOTE3OTk5XScpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLl9kYXRhID0gdW5kZWZpbmVkOyB9XG4gICAgc3RhdGljIGdldERhdGEoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBTZXQoSW52aXNpYmxlQ2hhcmFjdGVycy5nZXRSYXdEYXRhKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cbiAgICBzdGF0aWMgaXNJbnZpc2libGVDaGFyYWN0ZXIoY29kZVBvaW50KSB7XG4gICAgICAgIHJldHVybiBJbnZpc2libGVDaGFyYWN0ZXJzLmdldERhdGEoKS5oYXMoY29kZVBvaW50KTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb2RlUG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gSW52aXNpYmxlQ2hhcmFjdGVycy5nZXREYXRhKCk7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIENhbiBiZSBwYXNzZWQgaW50byB0aGUgRGVsYXllZCB0byBkZWZlciB1c2luZyBhIG1pY3JvdGFza1xuICogKi9cbmV4cG9ydCBjb25zdCBNaWNyb3Rhc2tEZWxheSA9IFN5bWJvbCgnTWljcm90YXNrRGVsYXknKTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgYSBKYXZhU2NyaXB0IFN0cmluZyBvciBub3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKTtcbn1cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgYG9iamVjdGAgYnV0ICoqbm90KipcbiAqXHRgbnVsbGAsIGFuIGBhcnJheWAsIGEgYHJlZ2V4cGAsIG5vciBhIGBkYXRlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIC8vIFRoZSBtZXRob2QgY2FuJ3QgZG8gYSB0eXBlIGNhc3Qgc2luY2UgdGhlcmUgYXJlIHR5cGUgKGxpa2Ugc3RyaW5ncykgd2hpY2hcbiAgICAvLyBhcmUgc3ViY2xhc3NlcyBvZiBhbnkgcHV0IG5vdCBwb3NpdHZlbHkgbWF0Y2hlZCBieSB0aGUgZnVuY3Rpb24uIEhlbmNlIHR5cGVcbiAgICAvLyBuYXJyb3dpbmcgcmVzdWx0cyBpbiB3cm9uZyByZXN1bHRzLlxuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xuICAgICAgICAmJiBvYmogIT09IG51bGxcbiAgICAgICAgJiYgIUFycmF5LmlzQXJyYXkob2JqKVxuICAgICAgICAmJiAhKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgJiYgIShvYmogaW5zdGFuY2VvZiBEYXRlKTtcbn1cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgYEJ1ZmZlcmAgb3IgVWludDhBcnJheSBkZXJ2aXZlZCB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGVkQXJyYXkob2JqKSB7XG4gICAgY29uc3QgVHlwZWRBcnJheSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5KTtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbiAgICAgICAgJiYgb2JqIGluc3RhbmNlb2YgVHlwZWRBcnJheTtcbn1cbi8qKlxuICogSW4gKipjb250cmFzdCoqIHRvIGp1c3QgY2hlY2tpbmcgYHR5cGVvZmAgdGhpcyB3aWxsIHJldHVybiBgZmFsc2VgIGZvciBgTmFOYC5cbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhIEphdmFTY3JpcHQgTnVtYmVyIG9yIG5vdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG9iaikpO1xufVxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgYW4gSXRlcmFibGUsIGNhc3RpbmcgdG8gdGhlIGdpdmVuIGdlbmVyaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSXRlcmFibGUob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmpbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGEgSmF2YVNjcmlwdCBCb29sZWFuIG9yIG5vdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHtcbiAgICByZXR1cm4gKG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlKTtcbn1cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpO1xufVxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5lZChhcmcpIHtcbiAgICByZXR1cm4gIWlzVW5kZWZpbmVkT3JOdWxsKGFyZyk7XG59XG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKG9iaikge1xuICAgIHJldHVybiAoaXNVbmRlZmluZWQob2JqKSB8fCBvYmogPT09IG51bGwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFR5cGUoY29uZGl0aW9uLCB0eXBlKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgPyBgVW5leHBlY3RlZCB0eXBlLCBleHBlY3RlZCAnJHt0eXBlfSdgIDogJ1VuZXhwZWN0ZWQgdHlwZScpO1xuICAgIH1cbn1cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBhcmd1bWVudCBwYXNzZWQgaW4gaXMgbmVpdGhlciB1bmRlZmluZWQgbm9yIG51bGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJc0RlZmluZWQoYXJnKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGFyZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gRmFpbGVkOiBhcmd1bWVudCBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xufVxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgYSBKYXZhU2NyaXB0IEZ1bmN0aW9uIG9yIG5vdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbnN0cmFpbnRzKGFyZ3MsIGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgbGVuID0gTWF0aC5taW4oYXJncy5sZW5ndGgsIGNvbnN0cmFpbnRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNvbnN0cmFpbnQoYXJnc1tpXSwgY29uc3RyYWludHNbaV0pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbnN0cmFpbnQoYXJnLCBjb25zdHJhaW50KSB7XG4gICAgaWYgKGlzU3RyaW5nKGNvbnN0cmFpbnQpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnICE9PSBjb25zdHJhaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50IGRvZXMgbm90IG1hdGNoIGNvbnN0cmFpbnQ6IHR5cGVvZiAke2NvbnN0cmFpbnR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihjb25zdHJhaW50KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZE9yTnVsbChhcmcpICYmIGFyZy5jb25zdHJ1Y3RvciA9PT0gY29uc3RyYWludCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJhaW50Lmxlbmd0aCA9PT0gMSAmJiBjb25zdHJhaW50LmNhbGwodW5kZWZpbmVkLCBhcmcpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcmd1bWVudCBkb2VzIG5vdCBtYXRjaCBvbmUgb2YgdGhlc2UgY29uc3RyYWludHM6IGFyZyBpbnN0YW5jZW9mIGNvbnN0cmFpbnQsIGFyZy5jb25zdHJ1Y3RvciA9PT0gY29uc3RyYWludCwgbm9yIGNvbnN0cmFpbnQoYXJnKSA9PT0gdHJ1ZWApO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVWludDgodikge1xuICAgIGlmICh2IDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHYgPiAyNTUgLyogQ29uc3RhbnRzLk1BWF9VSU5UXzggKi8pIHtcbiAgICAgICAgcmV0dXJuIDI1NSAvKiBDb25zdGFudHMuTUFYX1VJTlRfOCAqLztcbiAgICB9XG4gICAgcmV0dXJuIHYgfCAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvVWludDMyKHYpIHtcbiAgICBpZiAodiA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh2ID4gNDI5NDk2NzI5NSAvKiBDb25zdGFudHMuTUFYX1VJTlRfMzIgKi8pIHtcbiAgICAgICAgcmV0dXJuIDQyOTQ5NjcyOTUgLyogQ29uc3RhbnRzLk1BWF9VSU5UXzMyICovO1xuICAgIH1cbiAgICByZXR1cm4gdiB8IDA7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIHBhdGhzIGZyb20gJy4vcGF0aC5qcyc7XG5pbXBvcnQgeyBpc1dpbmRvd3MgfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmNvbnN0IF9zY2hlbWVQYXR0ZXJuID0gL15cXHdbXFx3XFxkKy4tXSokLztcbmNvbnN0IF9zaW5nbGVTbGFzaFN0YXJ0ID0gL15cXC8vO1xuY29uc3QgX2RvdWJsZVNsYXNoU3RhcnQgPSAvXlxcL1xcLy87XG5mdW5jdGlvbiBfdmFsaWRhdGVVcmkocmV0LCBfc3RyaWN0KSB7XG4gICAgLy8gc2NoZW1lLCBtdXN0IGJlIHNldFxuICAgIGlmICghcmV0LnNjaGVtZSAmJiBfc3RyaWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW1VyaUVycm9yXTogU2NoZW1lIGlzIG1pc3Npbmc6IHtzY2hlbWU6IFwiXCIsIGF1dGhvcml0eTogXCIke3JldC5hdXRob3JpdHl9XCIsIHBhdGg6IFwiJHtyZXQucGF0aH1cIiwgcXVlcnk6IFwiJHtyZXQucXVlcnl9XCIsIGZyYWdtZW50OiBcIiR7cmV0LmZyYWdtZW50fVwifWApO1xuICAgIH1cbiAgICAvLyBzY2hlbWUsIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4gICAgLy8gQUxQSEEgKiggQUxQSEEgLyBESUdJVCAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiApXG4gICAgaWYgKHJldC5zY2hlbWUgJiYgIV9zY2hlbWVQYXR0ZXJuLnRlc3QocmV0LnNjaGVtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBTY2hlbWUgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzLicpO1xuICAgIH1cbiAgICAvLyBwYXRoLCBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4zXG4gICAgLy8gSWYgYSBVUkkgY29udGFpbnMgYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjb21wb25lbnRcbiAgICAvLyBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXIuICBJZiBhIFVSSVxuICAgIC8vIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjYW5ub3QgYmVnaW5cbiAgICAvLyB3aXRoIHR3byBzbGFzaCBjaGFyYWN0ZXJzIChcIi8vXCIpLlxuICAgIGlmIChyZXQucGF0aCkge1xuICAgICAgICBpZiAocmV0LmF1dGhvcml0eSkge1xuICAgICAgICAgICAgaWYgKCFfc2luZ2xlU2xhc2hTdGFydC50ZXN0KHJldC5wYXRoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgY29udGFpbnMgYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjb21wb25lbnQgbXVzdCBlaXRoZXIgYmUgZW1wdHkgb3IgYmVnaW4gd2l0aCBhIHNsYXNoIChcIi9cIikgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoX2RvdWJsZVNsYXNoU3RhcnQudGVzdChyZXQucGF0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IElmIGEgVVJJIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjYW5ub3QgYmVnaW4gd2l0aCB0d28gc2xhc2ggY2hhcmFjdGVycyAoXCIvL1wiKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gZm9yIGEgd2hpbGUgd2UgYWxsb3dlZCB1cmlzICp3aXRob3V0KiBzY2hlbWVzIGFuZCB0aGlzIGlzIHRoZSBtaWdyYXRpb25cbi8vIGZvciB0aGVtLCBlLmcuIGFuIHVyaSB3aXRob3V0IHNjaGVtZSBhbmQgd2l0aG91dCBzdHJpY3QtbW9kZSB3YXJucyBhbmQgZmFsbHNcbi8vIGJhY2sgdG8gdGhlIGZpbGUtc2NoZW1lLiB0aGF0IHNob3VsZCBjYXVzZSB0aGUgbGVhc3QgY2FybmFnZSBhbmQgc3RpbGwgYmUgYVxuLy8gY2xlYXIgd2FybmluZ1xuZnVuY3Rpb24gX3NjaGVtZUZpeChzY2hlbWUsIF9zdHJpY3QpIHtcbiAgICBpZiAoIXNjaGVtZSAmJiAhX3N0cmljdCkge1xuICAgICAgICByZXR1cm4gJ2ZpbGUnO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1lO1xufVxuLy8gaW1wbGVtZW50cyBhIGJpdCBvZiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTVcbmZ1bmN0aW9uIF9yZWZlcmVuY2VSZXNvbHV0aW9uKHNjaGVtZSwgcGF0aCkge1xuICAgIC8vIHRoZSBzbGFzaC1jaGFyYWN0ZXIgaXMgb3VyICdkZWZhdWx0IGJhc2UnIGFzIHdlIGRvbid0XG4gICAgLy8gc3VwcG9ydCBjb25zdHJ1Y3RpbmcgVVJJcyByZWxhdGl2ZSB0byBvdGhlciBVUklzLiBUaGlzXG4gICAgLy8gYWxzbyBtZWFucyB0aGF0IHdlIGFsdGVyIGFuZCBwb3RlbnRpYWxseSBicmVhayBwYXRocy5cbiAgICAvLyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjEuNFxuICAgIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgICAgIGNhc2UgJ2h0dHBzJzpcbiAgICAgICAgY2FzZSAnaHR0cCc6XG4gICAgICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IF9zbGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdGhbMF0gIT09IF9zbGFzaCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBfc2xhc2ggKyBwYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuY29uc3QgX2VtcHR5ID0gJyc7XG5jb25zdCBfc2xhc2ggPSAnLyc7XG5jb25zdCBfcmVnZXhwID0gL14oKFteOi8/I10rPyk6KT8oXFwvXFwvKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpPy87XG4vKipcbiAqIFVuaWZvcm0gUmVzb3VyY2UgSWRlbnRpZmllciAoVVJJKSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2LlxuICogVGhpcyBjbGFzcyBpcyBhIHNpbXBsZSBwYXJzZXIgd2hpY2ggY3JlYXRlcyB0aGUgYmFzaWMgY29tcG9uZW50IHBhcnRzXG4gKiAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMpIHdpdGggbWluaW1hbCB2YWxpZGF0aW9uXG4gKiBhbmQgZW5jb2RpbmcuXG4gKlxuICogYGBgdHh0XG4gKiAgICAgICBmb286Ly9leGFtcGxlLmNvbTo4MDQyL292ZXIvdGhlcmU/bmFtZT1mZXJyZXQjbm9zZVxuICogICAgICAgXFxfLyAgIFxcX19fX19fX19fX19fX18vXFxfX19fX19fX18vIFxcX19fX19fX19fLyBcXF9fL1xuICogICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICB8ICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgIHNjaGVtZSAgICAgYXV0aG9yaXR5ICAgICAgIHBhdGggICAgICAgIHF1ZXJ5ICAgZnJhZ21lbnRcbiAqICAgICAgICB8ICAgX19fX19fX19fX19fX19fX19fX19ffF9fXG4gKiAgICAgICAvIFxcIC8gICAgICAgICAgICAgICAgICAgICAgICBcXFxuICogICAgICAgdXJuOmV4YW1wbGU6YW5pbWFsOmZlcnJldDpub3NlXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFVSSSB7XG4gICAgc3RhdGljIGlzVXJpKHRoaW5nKSB7XG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIFVSSSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpbmcuYXV0aG9yaXR5ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLmZyYWdtZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLnBhdGggPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcucXVlcnkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcuc2NoZW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLmZzUGF0aCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy53aXRoID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcudG9TdHJpbmcgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtZU9yRGF0YSwgYXV0aG9yaXR5LCBwYXRoLCBxdWVyeSwgZnJhZ21lbnQsIF9zdHJpY3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtZU9yRGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1lID0gc2NoZW1lT3JEYXRhLnNjaGVtZSB8fCBfZW1wdHk7XG4gICAgICAgICAgICB0aGlzLmF1dGhvcml0eSA9IHNjaGVtZU9yRGF0YS5hdXRob3JpdHkgfHwgX2VtcHR5O1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gc2NoZW1lT3JEYXRhLnBhdGggfHwgX2VtcHR5O1xuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHNjaGVtZU9yRGF0YS5xdWVyeSB8fCBfZW1wdHk7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gc2NoZW1lT3JEYXRhLmZyYWdtZW50IHx8IF9lbXB0eTtcbiAgICAgICAgICAgIC8vIG5vIHZhbGlkYXRpb24gYmVjYXVzZSBpdCdzIHRoaXMgVVJJXG4gICAgICAgICAgICAvLyB0aGF0IGNyZWF0ZXMgdXJpIGNvbXBvbmVudHMuXG4gICAgICAgICAgICAvLyBfdmFsaWRhdGVVcmkodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtZSA9IF9zY2hlbWVGaXgoc2NoZW1lT3JEYXRhLCBfc3RyaWN0KTtcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5ID0gYXV0aG9yaXR5IHx8IF9lbXB0eTtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IF9yZWZlcmVuY2VSZXNvbHV0aW9uKHRoaXMuc2NoZW1lLCBwYXRoIHx8IF9lbXB0eSk7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnkgfHwgX2VtcHR5O1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50IHx8IF9lbXB0eTtcbiAgICAgICAgICAgIF92YWxpZGF0ZVVyaSh0aGlzLCBfc3RyaWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0tIGZpbGVzeXN0ZW0gcGF0aCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb3JyZXNwb25kaW5nIGZpbGUgc3lzdGVtIHBhdGggb2YgdGhpcyBVUkkuXG4gICAgICogV2lsbCBoYW5kbGUgVU5DIHBhdGhzLCBub3JtYWxpemVzIHdpbmRvd3MgZHJpdmUgbGV0dGVycyB0byBsb3dlci1jYXNlLCBhbmQgdXNlcyB0aGVcbiAgICAgKiBwbGF0Zm9ybSBzcGVjaWZpYyBwYXRoIHNlcGFyYXRvci5cbiAgICAgKlxuICAgICAqICogV2lsbCAqbm90KiB2YWxpZGF0ZSB0aGUgcGF0aCBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzIGFuZCBzZW1hbnRpY3MuXG4gICAgICogKiBXaWxsICpub3QqIGxvb2sgYXQgdGhlIHNjaGVtZSBvZiB0aGlzIFVSSS5cbiAgICAgKiAqIFRoZSByZXN1bHQgc2hhbGwgKm5vdCogYmUgdXNlZCBmb3IgZGlzcGxheSBwdXJwb3NlcyBidXQgZm9yIGFjY2Vzc2luZyBhIGZpbGUgb24gZGlzay5cbiAgICAgKlxuICAgICAqXG4gICAgICogVGhlICpkaWZmZXJlbmNlKiB0byBgVVJJI3BhdGhgIGlzIHRoZSB1c2Ugb2YgdGhlIHBsYXRmb3JtIHNwZWNpZmljIHNlcGFyYXRvciBhbmQgdGhlIGhhbmRsaW5nXG4gICAgICogb2YgVU5DIHBhdGhzLiBTZWUgdGhlIGJlbG93IHNhbXBsZSBvZiBhIGZpbGUtdXJpIHdpdGggYW4gYXV0aG9yaXR5IChVTkMgcGF0aCkuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAgICBjb25zdCB1ID0gVVJJLnBhcnNlKCdmaWxlOi8vc2VydmVyL2MkL2ZvbGRlci9maWxlLnR4dCcpXG4gICAgICAgIHUuYXV0aG9yaXR5ID09PSAnc2VydmVyJ1xuICAgICAgICB1LnBhdGggPT09ICcvc2hhcmVzL2MkL2ZpbGUudHh0J1xuICAgICAgICB1LmZzUGF0aCA9PT0gJ1xcXFxzZXJ2ZXJcXGMkXFxmb2xkZXJcXGZpbGUudHh0J1xuICAgIGBgYFxuICAgICAqXG4gICAgICogVXNpbmcgYFVSSSNwYXRoYCB0byByZWFkIGEgZmlsZSAodXNpbmcgZnMtYXBpcykgd291bGQgbm90IGJlIGVub3VnaCBiZWNhdXNlIHBhcnRzIG9mIHRoZSBwYXRoLFxuICAgICAqIG5hbWVseSB0aGUgc2VydmVyIG5hbWUsIHdvdWxkIGJlIG1pc3NpbmcuIFRoZXJlZm9yZSBgVVJJI2ZzUGF0aGAgZXhpc3RzIC0gaXQncyBzdWdhciB0byBlYXNlIHdvcmtpbmdcbiAgICAgKiB3aXRoIFVSSXMgdGhhdCByZXByZXNlbnQgZmlsZXMgb24gZGlzayAoYGZpbGVgIHNjaGVtZSkuXG4gICAgICovXG4gICAgZ2V0IGZzUGF0aCgpIHtcbiAgICAgICAgLy8gaWYgKHRoaXMuc2NoZW1lICE9PSAnZmlsZScpIHtcbiAgICAgICAgLy8gXHRjb25zb2xlLndhcm4oYFtVcmlFcnJvcl0gY2FsbGluZyBmc1BhdGggd2l0aCBzY2hlbWUgJHt0aGlzLnNjaGVtZX1gKTtcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gdXJpVG9Gc1BhdGgodGhpcywgZmFsc2UpO1xuICAgIH1cbiAgICAvLyAtLS0tIG1vZGlmeSB0byBuZXcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHdpdGgoY2hhbmdlKSB7XG4gICAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBzY2hlbWUsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50IH0gPSBjaGFuZ2U7XG4gICAgICAgIGlmIChzY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NoZW1lID0gdGhpcy5zY2hlbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICBzY2hlbWUgPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhdXRob3JpdHkgPSB0aGlzLmF1dGhvcml0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdXRob3JpdHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGF1dGhvcml0eSA9IF9lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGggPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxdWVyeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcXVlcnkgPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcmFnbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gdGhpcy5zY2hlbWVcbiAgICAgICAgICAgICYmIGF1dGhvcml0eSA9PT0gdGhpcy5hdXRob3JpdHlcbiAgICAgICAgICAgICYmIHBhdGggPT09IHRoaXMucGF0aFxuICAgICAgICAgICAgJiYgcXVlcnkgPT09IHRoaXMucXVlcnlcbiAgICAgICAgICAgICYmIGZyYWdtZW50ID09PSB0aGlzLmZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVyaShzY2hlbWUsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50KTtcbiAgICB9XG4gICAgLy8gLS0tLSBwYXJzZSAmIHZhbGlkYXRlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVVJJIGZyb20gYSBzdHJpbmcsIGUuZy4gYGh0dHA6Ly93d3cuZXhhbXBsZS5jb20vc29tZS9wYXRoYCxcbiAgICAgKiBgZmlsZTovLy91c3IvaG9tZWAsIG9yIGBzY2hlbWU6d2l0aC9wYXRoYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBBIHN0cmluZyB3aGljaCByZXByZXNlbnRzIGFuIFVSSSAoc2VlIGBVUkkjdG9TdHJpbmdgKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIF9zdHJpY3QgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IF9yZWdleHAuZXhlYyh2YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJpKF9lbXB0eSwgX2VtcHR5LCBfZW1wdHksIF9lbXB0eSwgX2VtcHR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVyaShtYXRjaFsyXSB8fCBfZW1wdHksIHBlcmNlbnREZWNvZGUobWF0Y2hbNF0gfHwgX2VtcHR5KSwgcGVyY2VudERlY29kZShtYXRjaFs1XSB8fCBfZW1wdHkpLCBwZXJjZW50RGVjb2RlKG1hdGNoWzddIHx8IF9lbXB0eSksIHBlcmNlbnREZWNvZGUobWF0Y2hbOV0gfHwgX2VtcHR5KSwgX3N0cmljdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVVJJIGZyb20gYSBmaWxlIHN5c3RlbSBwYXRoLCBlLmcuIGBjOlxcbXlcXGZpbGVzYCxcbiAgICAgKiBgL3Vzci9ob21lYCwgb3IgYFxcXFxzZXJ2ZXJcXHNoYXJlXFxzb21lXFxwYXRoYC5cbiAgICAgKlxuICAgICAqIFRoZSAqZGlmZmVyZW5jZSogYmV0d2VlbiBgVVJJI3BhcnNlYCBhbmQgYFVSSSNmaWxlYCBpcyB0aGF0IHRoZSBsYXR0ZXIgdHJlYXRzIHRoZSBhcmd1bWVudFxuICAgICAqIGFzIHBhdGgsIG5vdCBhcyBzdHJpbmdpZmllZC11cmkuIEUuZy4gYFVSSS5maWxlKHBhdGgpYCBpcyAqKm5vdCB0aGUgc2FtZSBhcyoqXG4gICAgICogYFVSSS5wYXJzZSgnZmlsZTovLycgKyBwYXRoKWAgYmVjYXVzZSB0aGUgcGF0aCBtaWdodCBjb250YWluIGNoYXJhY3RlcnMgdGhhdCBhcmVcbiAgICAgKiBpbnRlcnByZXRlZCAoIyBhbmQgPykuIFNlZSB0aGUgZm9sbG93aW5nIHNhbXBsZTpcbiAgICAgKiBgYGB0c1xuICAgIGNvbnN0IGdvb2QgPSBVUkkuZmlsZSgnL2NvZGluZy9jIy9wcm9qZWN0MScpO1xuICAgIGdvb2Quc2NoZW1lID09PSAnZmlsZSc7XG4gICAgZ29vZC5wYXRoID09PSAnL2NvZGluZy9jIy9wcm9qZWN0MSc7XG4gICAgZ29vZC5mcmFnbWVudCA9PT0gJyc7XG4gICAgY29uc3QgYmFkID0gVVJJLnBhcnNlKCdmaWxlOi8vJyArICcvY29kaW5nL2MjL3Byb2plY3QxJyk7XG4gICAgYmFkLnNjaGVtZSA9PT0gJ2ZpbGUnO1xuICAgIGJhZC5wYXRoID09PSAnL2NvZGluZy9jJzsgLy8gcGF0aCBpcyBub3cgYnJva2VuXG4gICAgYmFkLmZyYWdtZW50ID09PSAnL3Byb2plY3QxJztcbiAgICBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIEEgZmlsZSBzeXN0ZW0gcGF0aCAoc2VlIGBVUkkjZnNQYXRoYClcbiAgICAgKi9cbiAgICBzdGF0aWMgZmlsZShwYXRoKSB7XG4gICAgICAgIGxldCBhdXRob3JpdHkgPSBfZW1wdHk7XG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0byBmd2Qtc2xhc2hlcyBvbiB3aW5kb3dzLFxuICAgICAgICAvLyBvbiBvdGhlciBzeXN0ZW1zIGJ3ZC1zbGFzaGVzIGFyZSB2YWxpZFxuICAgICAgICAvLyBmaWxlbmFtZSBjaGFyYWN0ZXIsIGVnIC9mXFxvby9iYVxcci50eHRcbiAgICAgICAgaWYgKGlzV2luZG93cykge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCBfc2xhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBhdXRob3JpdHkgYXMgdXNlZCBpbiBVTkMgc2hhcmVzXG4gICAgICAgIC8vIG9yIHVzZSB0aGUgcGF0aCBhcyBnaXZlblxuICAgICAgICBpZiAocGF0aFswXSA9PT0gX3NsYXNoICYmIHBhdGhbMV0gPT09IF9zbGFzaCkge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gcGF0aC5pbmRleE9mKF9zbGFzaCwgMik7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGF1dGhvcml0eSA9IHBhdGguc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBfc2xhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdXRob3JpdHkgPSBwYXRoLnN1YnN0cmluZygyLCBpZHgpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZyhpZHgpIHx8IF9zbGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVyaSgnZmlsZScsIGF1dGhvcml0eSwgcGF0aCwgX2VtcHR5LCBfZW1wdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBVUkkgZnJvbSB1cmkgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqIFVubGVzcyBgc3RyaWN0YCBpcyBgdHJ1ZWAgdGhlIHNjaGVtZSBpcyBkZWZhdWx0cyB0byBiZSBgZmlsZWAuIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXNcbiAgICAgKiB2YWxpZGF0aW9uIGFuZCBzaG91bGQgYmUgdXNlZCBmb3IgdW50cnVzdGVkIHVyaSBjb21wb25lbnRzIHJldHJpZXZlZCBmcm9tIHN0b3JhZ2UsXG4gICAgICogdXNlciBpbnB1dCwgY29tbWFuZCBhcmd1bWVudHMgZXRjXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oY29tcG9uZW50cywgc3RyaWN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVcmkoY29tcG9uZW50cy5zY2hlbWUsIGNvbXBvbmVudHMuYXV0aG9yaXR5LCBjb21wb25lbnRzLnBhdGgsIGNvbXBvbmVudHMucXVlcnksIGNvbXBvbmVudHMuZnJhZ21lbnQsIHN0cmljdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW4gYSBVUkkgcGF0aCB3aXRoIHBhdGggZnJhZ21lbnRzIGFuZCBub3JtYWxpemVzIHRoZSByZXN1bHRpbmcgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGlucHV0IFVSSS5cbiAgICAgKiBAcGFyYW0gcGF0aEZyYWdtZW50IFRoZSBwYXRoIGZyYWdtZW50IHRvIGFkZCB0byB0aGUgVVJJIHBhdGguXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBVUkkuXG4gICAgICovXG4gICAgc3RhdGljIGpvaW5QYXRoKHVyaSwgLi4ucGF0aEZyYWdtZW50KSB7XG4gICAgICAgIGlmICghdXJpLnBhdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW1VyaUVycm9yXTogY2Fubm90IGNhbGwgam9pblBhdGggb24gVVJJIHdpdGhvdXQgcGF0aGApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdQYXRoO1xuICAgICAgICBpZiAoaXNXaW5kb3dzICYmIHVyaS5zY2hlbWUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgbmV3UGF0aCA9IFVSSS5maWxlKHBhdGhzLndpbjMyLmpvaW4odXJpVG9Gc1BhdGgodXJpLCB0cnVlKSwgLi4ucGF0aEZyYWdtZW50KSkucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1BhdGggPSBwYXRocy5wb3NpeC5qb2luKHVyaS5wYXRoLCAuLi5wYXRoRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkud2l0aCh7IHBhdGg6IG5ld1BhdGggfSk7XG4gICAgfVxuICAgIC8vIC0tLS0gcHJpbnRpbmcvZXh0ZXJuYWxpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgdGhpcyBVUkkuIEl0J3MgZ3VhcmFudGVlZCB0aGF0IGNhbGxpbmdcbiAgICAgKiBgVVJJLnBhcnNlYCB3aXRoIHRoZSByZXN1bHQgb2YgdGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuIFVSSSB3aGljaCBpcyBlcXVhbFxuICAgICAqIHRvIHRoaXMgVVJJLlxuICAgICAqXG4gICAgICogKiBUaGUgcmVzdWx0IHNoYWxsICpub3QqIGJlIHVzZWQgZm9yIGRpc3BsYXkgcHVycG9zZXMgYnV0IGZvciBleHRlcm5hbGl6YXRpb24gb3IgdHJhbnNwb3J0LlxuICAgICAqICogVGhlIHJlc3VsdCB3aWxsIGJlIGVuY29kZWQgdXNpbmcgdGhlIHBlcmNlbnRhZ2UgZW5jb2RpbmcgYW5kIGVuY29kaW5nIGhhcHBlbnMgbW9zdGx5XG4gICAgICogaWdub3JlIHRoZSBzY2hlbWUtc3BlY2lmaWMgZW5jb2RpbmcgcnVsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2tpcEVuY29kaW5nIERvIG5vdCBlbmNvZGUgdGhlIHJlc3VsdCwgZGVmYXVsdCBpcyBgZmFsc2VgXG4gICAgICovXG4gICAgdG9TdHJpbmcoc2tpcEVuY29kaW5nID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIF9hc0Zvcm1hdHRlZCh0aGlzLCBza2lwRW5jb2RpbmcpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgcmV2aXZlKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVVJJKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVcmkoZGF0YSk7XG4gICAgICAgICAgICByZXN1bHQuX2Zvcm1hdHRlZCA9IGRhdGEuZXh0ZXJuYWwgPz8gbnVsbDtcbiAgICAgICAgICAgIHJlc3VsdC5fZnNQYXRoID0gZGF0YS5fc2VwID09PSBfcGF0aFNlcE1hcmtlciA/IGRhdGEuZnNQYXRoID8/IG51bGwgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IF9wYXRoU2VwTWFya2VyID0gaXNXaW5kb3dzID8gMSA6IHVuZGVmaW5lZDtcbi8vIFRoaXMgY2xhc3MgZXhpc3RzIHNvIHRoYXQgVVJJIGlzIGNvbXBhdGlibGUgd2l0aCB2c2NvZGUuVXJpIChBUEkpLlxuY2xhc3MgVXJpIGV4dGVuZHMgVVJJIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fZm9ybWF0dGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZnNQYXRoID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGZzUGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mc1BhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZzUGF0aCA9IHVyaVRvRnNQYXRoKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZnNQYXRoO1xuICAgIH1cbiAgICB0b1N0cmluZyhza2lwRW5jb2RpbmcgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXNraXBFbmNvZGluZykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9mb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JtYXR0ZWQgPSBfYXNGb3JtYXR0ZWQodGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdHRlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNhY2hlIHRoYXRcbiAgICAgICAgICAgIHJldHVybiBfYXNGb3JtYXR0ZWQodGhpcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICAkbWlkOiAxIC8qIE1hcnNoYWxsZWRJZC5VcmkgKi9cbiAgICAgICAgfTtcbiAgICAgICAgLy8gY2FjaGVkIHN0YXRlXG4gICAgICAgIGlmICh0aGlzLl9mc1BhdGgpIHtcbiAgICAgICAgICAgIHJlcy5mc1BhdGggPSB0aGlzLl9mc1BhdGg7XG4gICAgICAgICAgICByZXMuX3NlcCA9IF9wYXRoU2VwTWFya2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIHJlcy5leHRlcm5hbCA9IHRoaXMuX2Zvcm1hdHRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSB1cmkgY29tcG9uZW50c1xuICAgICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgICAgICByZXMucGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIHRoaXMgaXNuJ3QgY29ycmVjdCBhbmQgY2FuIHZpb2xhdGUgdGhlIFVyaUNvbXBvbmVudHMgY29udHJhY3QgYnV0XG4gICAgICAgIC8vIHRoaXMgaXMgcGFydCBvZiB0aGUgdnNjb2RlLlVyaSBBUEkgYW5kIHdlIHNob3VsZG4ndCBjaGFuZ2UgaG93IHRoYXRcbiAgICAgICAgLy8gd29ya3MgYW55bW9yZVxuICAgICAgICBpZiAodGhpcy5zY2hlbWUpIHtcbiAgICAgICAgICAgIHJlcy5zY2hlbWUgPSB0aGlzLnNjaGVtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRob3JpdHkpIHtcbiAgICAgICAgICAgIHJlcy5hdXRob3JpdHkgPSB0aGlzLmF1dGhvcml0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeSkge1xuICAgICAgICAgICAgcmVzLnF1ZXJ5ID0gdGhpcy5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcmFnbWVudCkge1xuICAgICAgICAgICAgcmVzLmZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbi8vIHJlc2VydmVkIGNoYXJhY3RlcnM6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMi4yXG5jb25zdCBlbmNvZGVUYWJsZSA9IHtcbiAgICBbNTggLyogQ2hhckNvZGUuQ29sb24gKi9dOiAnJTNBJywgLy8gZ2VuLWRlbGltc1xuICAgIFs0NyAvKiBDaGFyQ29kZS5TbGFzaCAqL106ICclMkYnLFxuICAgIFs2MyAvKiBDaGFyQ29kZS5RdWVzdGlvbk1hcmsgKi9dOiAnJTNGJyxcbiAgICBbMzUgLyogQ2hhckNvZGUuSGFzaCAqL106ICclMjMnLFxuICAgIFs5MSAvKiBDaGFyQ29kZS5PcGVuU3F1YXJlQnJhY2tldCAqL106ICclNUInLFxuICAgIFs5MyAvKiBDaGFyQ29kZS5DbG9zZVNxdWFyZUJyYWNrZXQgKi9dOiAnJTVEJyxcbiAgICBbNjQgLyogQ2hhckNvZGUuQXRTaWduICovXTogJyU0MCcsXG4gICAgWzMzIC8qIENoYXJDb2RlLkV4Y2xhbWF0aW9uTWFyayAqL106ICclMjEnLCAvLyBzdWItZGVsaW1zXG4gICAgWzM2IC8qIENoYXJDb2RlLkRvbGxhclNpZ24gKi9dOiAnJTI0JyxcbiAgICBbMzggLyogQ2hhckNvZGUuQW1wZXJzYW5kICovXTogJyUyNicsXG4gICAgWzM5IC8qIENoYXJDb2RlLlNpbmdsZVF1b3RlICovXTogJyUyNycsXG4gICAgWzQwIC8qIENoYXJDb2RlLk9wZW5QYXJlbiAqL106ICclMjgnLFxuICAgIFs0MSAvKiBDaGFyQ29kZS5DbG9zZVBhcmVuICovXTogJyUyOScsXG4gICAgWzQyIC8qIENoYXJDb2RlLkFzdGVyaXNrICovXTogJyUyQScsXG4gICAgWzQzIC8qIENoYXJDb2RlLlBsdXMgKi9dOiAnJTJCJyxcbiAgICBbNDQgLyogQ2hhckNvZGUuQ29tbWEgKi9dOiAnJTJDJyxcbiAgICBbNTkgLyogQ2hhckNvZGUuU2VtaWNvbG9uICovXTogJyUzQicsXG4gICAgWzYxIC8qIENoYXJDb2RlLkVxdWFscyAqL106ICclM0QnLFxuICAgIFszMiAvKiBDaGFyQ29kZS5TcGFjZSAqL106ICclMjAnLFxufTtcbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudEZhc3QodXJpQ29tcG9uZW50LCBpc1BhdGgsIGlzQXV0aG9yaXR5KSB7XG4gICAgbGV0IHJlcyA9IHVuZGVmaW5lZDtcbiAgICBsZXQgbmF0aXZlRW5jb2RlUG9zID0gLTE7XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgdXJpQ29tcG9uZW50Lmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHVyaUNvbXBvbmVudC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIC8vIHVucmVzZXJ2ZWQgY2hhcmFjdGVyczogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0yLjNcbiAgICAgICAgaWYgKChjb2RlID49IDk3IC8qIENoYXJDb2RlLmEgKi8gJiYgY29kZSA8PSAxMjIgLyogQ2hhckNvZGUueiAqLylcbiAgICAgICAgICAgIHx8IChjb2RlID49IDY1IC8qIENoYXJDb2RlLkEgKi8gJiYgY29kZSA8PSA5MCAvKiBDaGFyQ29kZS5aICovKVxuICAgICAgICAgICAgfHwgKGNvZGUgPj0gNDggLyogQ2hhckNvZGUuRGlnaXQwICovICYmIGNvZGUgPD0gNTcgLyogQ2hhckNvZGUuRGlnaXQ5ICovKVxuICAgICAgICAgICAgfHwgY29kZSA9PT0gNDUgLyogQ2hhckNvZGUuRGFzaCAqL1xuICAgICAgICAgICAgfHwgY29kZSA9PT0gNDYgLyogQ2hhckNvZGUuUGVyaW9kICovXG4gICAgICAgICAgICB8fCBjb2RlID09PSA5NSAvKiBDaGFyQ29kZS5VbmRlcmxpbmUgKi9cbiAgICAgICAgICAgIHx8IGNvZGUgPT09IDEyNiAvKiBDaGFyQ29kZS5UaWxkZSAqL1xuICAgICAgICAgICAgfHwgKGlzUGF0aCAmJiBjb2RlID09PSA0NyAvKiBDaGFyQ29kZS5TbGFzaCAqLylcbiAgICAgICAgICAgIHx8IChpc0F1dGhvcml0eSAmJiBjb2RlID09PSA5MSAvKiBDaGFyQ29kZS5PcGVuU3F1YXJlQnJhY2tldCAqLylcbiAgICAgICAgICAgIHx8IChpc0F1dGhvcml0eSAmJiBjb2RlID09PSA5MyAvKiBDaGFyQ29kZS5DbG9zZVNxdWFyZUJyYWNrZXQgKi8pXG4gICAgICAgICAgICB8fCAoaXNBdXRob3JpdHkgJiYgY29kZSA9PT0gNTggLyogQ2hhckNvZGUuQ29sb24gKi8pKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgZGVsYXlpbmcgbmF0aXZlIGVuY29kZVxuICAgICAgICAgICAgaWYgKG5hdGl2ZUVuY29kZVBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHVyaUNvbXBvbmVudC5zdWJzdHJpbmcobmF0aXZlRW5jb2RlUG9zLCBwb3MpKTtcbiAgICAgICAgICAgICAgICBuYXRpdmVFbmNvZGVQb3MgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIHdyaXRlIGludG8gYSBuZXcgc3RyaW5nIChieSBkZWZhdWx0IHdlIHRyeSB0byByZXR1cm4gdGhlIHBhcmFtKVxuICAgICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IHVyaUNvbXBvbmVudC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVuY29kaW5nIG5lZWRlZCwgd2UgbmVlZCB0byBhbGxvY2F0ZSBhIG5ldyBzdHJpbmdcbiAgICAgICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcyA9IHVyaUNvbXBvbmVudC5zdWJzdHIoMCwgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIHdpdGggZGVmYXVsdCB0YWJsZSBmaXJzdFxuICAgICAgICAgICAgY29uc3QgZXNjYXBlZCA9IGVuY29kZVRhYmxlW2NvZGVdO1xuICAgICAgICAgICAgaWYgKGVzY2FwZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBkZWxheWluZyBuYXRpdmUgZW5jb2RlXG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUVuY29kZVBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZVVSSUNvbXBvbmVudCh1cmlDb21wb25lbnQuc3Vic3RyaW5nKG5hdGl2ZUVuY29kZVBvcywgcG9zKSk7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUVuY29kZVBvcyA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgZXNjYXBlZCB2YXJpYW50IHRvIHJlc3VsdFxuICAgICAgICAgICAgICAgIHJlcyArPSBlc2NhcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmF0aXZlRW5jb2RlUG9zID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBuYXRpdmUgZW5jb2RlIG9ubHkgd2hlbiBuZWVkZWRcbiAgICAgICAgICAgICAgICBuYXRpdmVFbmNvZGVQb3MgPSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hdGl2ZUVuY29kZVBvcyAhPT0gLTEpIHtcbiAgICAgICAgcmVzICs9IGVuY29kZVVSSUNvbXBvbmVudCh1cmlDb21wb25lbnQuc3Vic3RyaW5nKG5hdGl2ZUVuY29kZVBvcykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzICE9PSB1bmRlZmluZWQgPyByZXMgOiB1cmlDb21wb25lbnQ7XG59XG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRNaW5pbWFsKHBhdGgpIHtcbiAgICBsZXQgcmVzID0gdW5kZWZpbmVkO1xuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHBhdGgubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChjb2RlID09PSAzNSAvKiBDaGFyQ29kZS5IYXNoICovIHx8IGNvZGUgPT09IDYzIC8qIENoYXJDb2RlLlF1ZXN0aW9uTWFyayAqLykge1xuICAgICAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcGF0aC5zdWJzdHIoMCwgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyArPSBlbmNvZGVUYWJsZVtjb2RlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcyArPSBwYXRoW3Bvc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcyAhPT0gdW5kZWZpbmVkID8gcmVzIDogcGF0aDtcbn1cbi8qKlxuICogQ29tcHV0ZSBgZnNQYXRoYCBmb3IgdGhlIGdpdmVuIHVyaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXJpVG9Gc1BhdGgodXJpLCBrZWVwRHJpdmVMZXR0ZXJDYXNpbmcpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKHVyaS5hdXRob3JpdHkgJiYgdXJpLnBhdGgubGVuZ3RoID4gMSAmJiB1cmkuc2NoZW1lID09PSAnZmlsZScpIHtcbiAgICAgICAgLy8gdW5jIHBhdGg6IGZpbGU6Ly9zaGFyZXMvYyQvZmFyL2Jvb1xuICAgICAgICB2YWx1ZSA9IGAvLyR7dXJpLmF1dGhvcml0eX0ke3VyaS5wYXRofWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVyaS5wYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qIENoYXJDb2RlLlNsYXNoICovXG4gICAgICAgICYmICh1cmkucGF0aC5jaGFyQ29kZUF0KDEpID49IDY1IC8qIENoYXJDb2RlLkEgKi8gJiYgdXJpLnBhdGguY2hhckNvZGVBdCgxKSA8PSA5MCAvKiBDaGFyQ29kZS5aICovIHx8IHVyaS5wYXRoLmNoYXJDb2RlQXQoMSkgPj0gOTcgLyogQ2hhckNvZGUuYSAqLyAmJiB1cmkucGF0aC5jaGFyQ29kZUF0KDEpIDw9IDEyMiAvKiBDaGFyQ29kZS56ICovKVxuICAgICAgICAmJiB1cmkucGF0aC5jaGFyQ29kZUF0KDIpID09PSA1OCAvKiBDaGFyQ29kZS5Db2xvbiAqLykge1xuICAgICAgICBpZiAoIWtlZXBEcml2ZUxldHRlckNhc2luZykge1xuICAgICAgICAgICAgLy8gd2luZG93cyBkcml2ZSBsZXR0ZXI6IGZpbGU6Ly8vYzovZmFyL2Jvb1xuICAgICAgICAgICAgdmFsdWUgPSB1cmkucGF0aFsxXS50b0xvd2VyQ2FzZSgpICsgdXJpLnBhdGguc3Vic3RyKDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB1cmkucGF0aC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG90aGVyIHBhdGhcbiAgICAgICAgdmFsdWUgPSB1cmkucGF0aDtcbiAgICB9XG4gICAgaWYgKGlzV2luZG93cykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcLy9nLCAnXFxcXCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgZXh0ZXJuYWwgdmVyc2lvbiBvZiBhIHVyaVxuICovXG5mdW5jdGlvbiBfYXNGb3JtYXR0ZWQodXJpLCBza2lwRW5jb2RpbmcpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gIXNraXBFbmNvZGluZ1xuICAgICAgICA/IGVuY29kZVVSSUNvbXBvbmVudEZhc3RcbiAgICAgICAgOiBlbmNvZGVVUklDb21wb25lbnRNaW5pbWFsO1xuICAgIGxldCByZXMgPSAnJztcbiAgICBsZXQgeyBzY2hlbWUsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50IH0gPSB1cmk7XG4gICAgaWYgKHNjaGVtZSkge1xuICAgICAgICByZXMgKz0gc2NoZW1lO1xuICAgICAgICByZXMgKz0gJzonO1xuICAgIH1cbiAgICBpZiAoYXV0aG9yaXR5IHx8IHNjaGVtZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgIHJlcyArPSBfc2xhc2g7XG4gICAgICAgIHJlcyArPSBfc2xhc2g7XG4gICAgfVxuICAgIGlmIChhdXRob3JpdHkpIHtcbiAgICAgICAgbGV0IGlkeCA9IGF1dGhvcml0eS5pbmRleE9mKCdAJyk7XG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAvLyA8dXNlcj5APGF1dGg+XG4gICAgICAgICAgICBjb25zdCB1c2VyaW5mbyA9IGF1dGhvcml0eS5zdWJzdHIoMCwgaWR4KTtcbiAgICAgICAgICAgIGF1dGhvcml0eSA9IGF1dGhvcml0eS5zdWJzdHIoaWR4ICsgMSk7XG4gICAgICAgICAgICBpZHggPSB1c2VyaW5mby5sYXN0SW5kZXhPZignOicpO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gZW5jb2Rlcih1c2VyaW5mbywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDx1c2VyPjo8cGFzcz5APGF1dGg+XG4gICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZXIodXNlcmluZm8uc3Vic3RyKDAsIGlkeCksIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVzICs9ICc6JztcbiAgICAgICAgICAgICAgICByZXMgKz0gZW5jb2Rlcih1c2VyaW5mby5zdWJzdHIoaWR4ICsgMSksIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyArPSAnQCc7XG4gICAgICAgIH1cbiAgICAgICAgYXV0aG9yaXR5ID0gYXV0aG9yaXR5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlkeCA9IGF1dGhvcml0eS5sYXN0SW5kZXhPZignOicpO1xuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgcmVzICs9IGVuY29kZXIoYXV0aG9yaXR5LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyA8YXV0aD46PHBvcnQ+XG4gICAgICAgICAgICByZXMgKz0gZW5jb2RlcihhdXRob3JpdHkuc3Vic3RyKDAsIGlkeCksIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIHJlcyArPSBhdXRob3JpdHkuc3Vic3RyKGlkeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgICAgLy8gbG93ZXItY2FzZSB3aW5kb3dzIGRyaXZlIGxldHRlcnMgaW4gL0M6L2ZmZiBvciBDOi9mZmZcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID49IDMgJiYgcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKiBDaGFyQ29kZS5TbGFzaCAqLyAmJiBwYXRoLmNoYXJDb2RlQXQoMikgPT09IDU4IC8qIENoYXJDb2RlLkNvbG9uICovKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDEpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPj0gNjUgLyogQ2hhckNvZGUuQSAqLyAmJiBjb2RlIDw9IDkwIC8qIENoYXJDb2RlLlogKi8pIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gYC8ke1N0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIDMyKX06JHtwYXRoLnN1YnN0cigzKX1gOyAvLyBcIi9jOlwiLmxlbmd0aCA9PT0gM1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGgubGVuZ3RoID49IDIgJiYgcGF0aC5jaGFyQ29kZUF0KDEpID09PSA1OCAvKiBDaGFyQ29kZS5Db2xvbiAqLykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDY1IC8qIENoYXJDb2RlLkEgKi8gJiYgY29kZSA8PSA5MCAvKiBDaGFyQ29kZS5aICovKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IGAke1N0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIDMyKX06JHtwYXRoLnN1YnN0cigyKX1gOyAvLyBcIi9jOlwiLmxlbmd0aCA9PT0gM1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgcGF0aFxuICAgICAgICByZXMgKz0gZW5jb2RlcihwYXRoLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChxdWVyeSkge1xuICAgICAgICByZXMgKz0gJz8nO1xuICAgICAgICByZXMgKz0gZW5jb2RlcihxdWVyeSwgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgIHJlcyArPSAnIyc7XG4gICAgICAgIHJlcyArPSAhc2tpcEVuY29kaW5nID8gZW5jb2RlVVJJQ29tcG9uZW50RmFzdChmcmFnbWVudCwgZmFsc2UsIGZhbHNlKSA6IGZyYWdtZW50O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gLS0tIGRlY29kZVxuZnVuY3Rpb24gZGVjb2RlVVJJQ29tcG9uZW50R3JhY2VmdWwoc3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgMykgKyBkZWNvZGVVUklDb21wb25lbnRHcmFjZWZ1bChzdHIuc3Vic3RyKDMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBfckVuY29kZWRBc0hleCA9IC8oJVswLTlBLVphLXpdWzAtOUEtWmEtel0pKy9nO1xuZnVuY3Rpb24gcGVyY2VudERlY29kZShzdHIpIHtcbiAgICBpZiAoIXN0ci5tYXRjaChfckVuY29kZWRBc0hleCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKF9yRW5jb2RlZEFzSGV4LCAobWF0Y2gpID0+IGRlY29kZVVSSUNvbXBvbmVudEdyYWNlZnVsKG1hdGNoKSk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IG9uVW5leHBlY3RlZEVycm9yLCB0cmFuc2Zvcm1FcnJvckZvclNlcmlhbGl6YXRpb24gfSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uL2V2ZW50LmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgRmlsZUFjY2VzcyB9IGZyb20gJy4uL25ldHdvcmsuanMnO1xuaW1wb3J0IHsgaXNXZWIgfSBmcm9tICcuLi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgKiBhcyBzdHJpbmdzIGZyb20gJy4uL3N0cmluZ3MuanMnO1xuLy8gRVNNLWNvbW1lbnQtYmVnaW5cbi8vIGNvbnN0IGlzRVNNID0gZmFsc2U7XG4vLyBFU00tY29tbWVudC1lbmRcbi8vIEVTTS11bmNvbW1lbnQtYmVnaW5cbmNvbnN0IGlzRVNNID0gdHJ1ZTtcbi8vIEVTTS11bmNvbW1lbnQtZW5kXG5jb25zdCBERUZBVUxUX0NIQU5ORUwgPSAnZGVmYXVsdCc7XG5jb25zdCBJTklUSUFMSVpFID0gJyRpbml0aWFsaXplJztcbmxldCB3ZWJXb3JrZXJXYXJuaW5nTG9nZ2VkID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gbG9nT25jZVdlYldvcmtlcldhcm5pbmcoZXJyKSB7XG4gICAgaWYgKCFpc1dlYikge1xuICAgICAgICAvLyBydW5uaW5nIHRlc3RzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF3ZWJXb3JrZXJXYXJuaW5nTG9nZ2VkKSB7XG4gICAgICAgIHdlYldvcmtlcldhcm5pbmdMb2dnZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBjcmVhdGUgd2ViIHdvcmtlcihzKS4gRmFsbGluZyBiYWNrIHRvIGxvYWRpbmcgd2ViIHdvcmtlciBjb2RlIGluIG1haW4gdGhyZWFkLCB3aGljaCBtaWdodCBjYXVzZSBVSSBmcmVlemVzLiBQbGVhc2Ugc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvbW9uYWNvLWVkaXRvciNmYXEnKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKGVyci5tZXNzYWdlKTtcbn1cbmNsYXNzIFJlcXVlc3RNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcih2c1dvcmtlciwgcmVxLCBjaGFubmVsLCBtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy52c1dvcmtlciA9IHZzV29ya2VyO1xuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTWVzc2FnZVR5cGUuUmVxdWVzdCAqLztcbiAgICB9XG59XG5jbGFzcyBSZXBseU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZzV29ya2VyLCBzZXEsIHJlcywgZXJyKSB7XG4gICAgICAgIHRoaXMudnNXb3JrZXIgPSB2c1dvcmtlcjtcbiAgICAgICAgdGhpcy5zZXEgPSBzZXE7XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICB0aGlzLmVyciA9IGVycjtcbiAgICAgICAgdGhpcy50eXBlID0gMSAvKiBNZXNzYWdlVHlwZS5SZXBseSAqLztcbiAgICB9XG59XG5jbGFzcyBTdWJzY3JpYmVFdmVudE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZzV29ya2VyLCByZXEsIGNoYW5uZWwsIGV2ZW50TmFtZSwgYXJnKSB7XG4gICAgICAgIHRoaXMudnNXb3JrZXIgPSB2c1dvcmtlcjtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLmFyZyA9IGFyZztcbiAgICAgICAgdGhpcy50eXBlID0gMiAvKiBNZXNzYWdlVHlwZS5TdWJzY3JpYmVFdmVudCAqLztcbiAgICB9XG59XG5jbGFzcyBFdmVudE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZzV29ya2VyLCByZXEsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMudnNXb3JrZXIgPSB2c1dvcmtlcjtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy50eXBlID0gMyAvKiBNZXNzYWdlVHlwZS5FdmVudCAqLztcbiAgICB9XG59XG5jbGFzcyBVbnN1YnNjcmliZUV2ZW50TWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IodnNXb3JrZXIsIHJlcSkge1xuICAgICAgICB0aGlzLnZzV29ya2VyID0gdnNXb3JrZXI7XG4gICAgICAgIHRoaXMucmVxID0gcmVxO1xuICAgICAgICB0aGlzLnR5cGUgPSA0IC8qIE1lc3NhZ2VUeXBlLlVuc3Vic2NyaWJlRXZlbnQgKi87XG4gICAgfVxufVxuY2xhc3MgU2ltcGxlV29ya2VyUHJvdG9jb2wge1xuICAgIGNvbnN0cnVjdG9yKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fd29ya2VySWQgPSAtMTtcbiAgICAgICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMuX2xhc3RTZW50UmVxID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcGxpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRW1pdHRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdFdmVudHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHNldFdvcmtlcklkKHdvcmtlcklkKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlcklkID0gd29ya2VySWQ7XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlKGNoYW5uZWwsIG1ldGhvZCwgYXJncykge1xuICAgICAgICBjb25zdCByZXEgPSBTdHJpbmcoKyt0aGlzLl9sYXN0U2VudFJlcSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVwbGllc1tyZXFdID0ge1xuICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9zZW5kKG5ldyBSZXF1ZXN0TWVzc2FnZSh0aGlzLl93b3JrZXJJZCwgcmVxLCBjaGFubmVsLCBtZXRob2QsIGFyZ3MpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3RlbihjaGFubmVsLCBldmVudE5hbWUsIGFyZykge1xuICAgICAgICBsZXQgcmVxID0gbnVsbDtcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcbiAgICAgICAgICAgIG9uV2lsbEFkZEZpcnN0TGlzdGVuZXI6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXEgPSBTdHJpbmcoKyt0aGlzLl9sYXN0U2VudFJlcSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0VtaXR0ZXJzLnNldChyZXEsIGVtaXR0ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmQobmV3IFN1YnNjcmliZUV2ZW50TWVzc2FnZSh0aGlzLl93b3JrZXJJZCwgcmVxLCBjaGFubmVsLCBldmVudE5hbWUsIGFyZykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0VtaXR0ZXJzLmRlbGV0ZShyZXEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmQobmV3IFVuc3Vic2NyaWJlRXZlbnRNZXNzYWdlKHRoaXMuX3dvcmtlcklkLCByZXEpKTtcbiAgICAgICAgICAgICAgICByZXEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UgfHwgIW1lc3NhZ2UudnNXb3JrZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fd29ya2VySWQgIT09IC0xICYmIG1lc3NhZ2UudnNXb3JrZXIgIT09IHRoaXMuX3dvcmtlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG4gICAgY3JlYXRlUHJveHlUb1JlbW90ZUNoYW5uZWwoY2hhbm5lbCwgc2VuZE1lc3NhZ2VCYXJyaWVyKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmICF0YXJnZXRbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5SXNEeW5hbWljRXZlbnQobmFtZSkpIHsgLy8gb25EeW5hbWljLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuKGNoYW5uZWwsIG5hbWUsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5SXNFdmVudChuYW1lKSkgeyAvLyBvbi4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gdGhpcy5saXN0ZW4oY2hhbm5lbCwgbmFtZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDM2IC8qIENoYXJDb2RlLkRvbGxhclNpZ24gKi8pIHsgLy8gJC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gYXN5bmMgKC4uLm15QXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlbmRNZXNzYWdlQmFycmllcj8uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoY2hhbm5lbCwgbmFtZSwgbXlBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShPYmplY3QuY3JlYXRlKG51bGwpLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgX2hhbmRsZU1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBNZXNzYWdlVHlwZS5SZXBseSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlUmVwbHlNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICBjYXNlIDAgLyogTWVzc2FnZVR5cGUuUmVxdWVzdCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlUmVxdWVzdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNZXNzYWdlVHlwZS5TdWJzY3JpYmVFdmVudCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU3Vic2NyaWJlRXZlbnRNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICBjYXNlIDMgLyogTWVzc2FnZVR5cGUuRXZlbnQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUV2ZW50TWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgY2FzZSA0IC8qIE1lc3NhZ2VUeXBlLlVuc3Vic2NyaWJlRXZlbnQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVVuc3Vic2NyaWJlRXZlbnRNZXNzYWdlKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2hhbmRsZVJlcGx5TWVzc2FnZShyZXBseU1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wZW5kaW5nUmVwbGllc1tyZXBseU1lc3NhZ2Uuc2VxXSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdHb3QgcmVwbHkgdG8gdW5rbm93biBzZXEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBseSA9IHRoaXMuX3BlbmRpbmdSZXBsaWVzW3JlcGx5TWVzc2FnZS5zZXFdO1xuICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1JlcGxpZXNbcmVwbHlNZXNzYWdlLnNlcV07XG4gICAgICAgIGlmIChyZXBseU1lc3NhZ2UuZXJyKSB7XG4gICAgICAgICAgICBsZXQgZXJyID0gcmVwbHlNZXNzYWdlLmVycjtcbiAgICAgICAgICAgIGlmIChyZXBseU1lc3NhZ2UuZXJyLiRpc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgZXJyLm5hbWUgPSByZXBseU1lc3NhZ2UuZXJyLm5hbWU7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSByZXBseU1lc3NhZ2UuZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgZXJyLnN0YWNrID0gcmVwbHlNZXNzYWdlLmVyci5zdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGx5LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlcGx5LnJlc29sdmUocmVwbHlNZXNzYWdlLnJlcyk7XG4gICAgfVxuICAgIF9oYW5kbGVSZXF1ZXN0TWVzc2FnZShyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICBjb25zdCByZXEgPSByZXF1ZXN0TWVzc2FnZS5yZXE7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2hhbmRsZXIuaGFuZGxlTWVzc2FnZShyZXF1ZXN0TWVzc2FnZS5jaGFubmVsLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHJlcXVlc3RNZXNzYWdlLmFyZ3MpO1xuICAgICAgICByZXN1bHQudGhlbigocikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2VuZChuZXcgUmVwbHlNZXNzYWdlKHRoaXMuX3dvcmtlcklkLCByZXEsIHIsIHVuZGVmaW5lZCkpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUuZGV0YWlsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2FkaW5nIGVycm9ycyBoYXZlIGEgZGV0YWlsIHByb3BlcnR5IHRoYXQgcG9pbnRzIHRvIHRoZSBhY3R1YWwgZXJyb3JcbiAgICAgICAgICAgICAgICBlLmRldGFpbCA9IHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbihlLmRldGFpbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZW5kKG5ldyBSZXBseU1lc3NhZ2UodGhpcy5fd29ya2VySWQsIHJlcSwgdW5kZWZpbmVkLCB0cmFuc2Zvcm1FcnJvckZvclNlcmlhbGl6YXRpb24oZSkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9oYW5kbGVTdWJzY3JpYmVFdmVudE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIGNvbnN0IHJlcSA9IG1zZy5yZXE7XG4gICAgICAgIGNvbnN0IGRpc3Bvc2FibGUgPSB0aGlzLl9oYW5kbGVyLmhhbmRsZUV2ZW50KG1zZy5jaGFubmVsLCBtc2cuZXZlbnROYW1lLCBtc2cuYXJnKSgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmQobmV3IEV2ZW50TWVzc2FnZSh0aGlzLl93b3JrZXJJZCwgcmVxLCBldmVudCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0V2ZW50cy5zZXQocmVxLCBkaXNwb3NhYmxlKTtcbiAgICB9XG4gICAgX2hhbmRsZUV2ZW50TWVzc2FnZShtc2cpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wZW5kaW5nRW1pdHRlcnMuaGFzKG1zZy5yZXEpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dvdCBldmVudCBmb3IgdW5rbm93biByZXEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZW5kaW5nRW1pdHRlcnMuZ2V0KG1zZy5yZXEpLmZpcmUobXNnLmV2ZW50KTtcbiAgICB9XG4gICAgX2hhbmRsZVVuc3Vic2NyaWJlRXZlbnRNZXNzYWdlKG1zZykge1xuICAgICAgICBpZiAoIXRoaXMuX3BlbmRpbmdFdmVudHMuaGFzKG1zZy5yZXEpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dvdCB1bnN1YnNjcmliZSBmb3IgdW5rbm93biByZXEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZW5kaW5nRXZlbnRzLmdldChtc2cucmVxKS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdFdmVudHMuZGVsZXRlKG1zZy5yZXEpO1xuICAgIH1cbiAgICBfc2VuZChtc2cpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmZXIgPSBbXTtcbiAgICAgICAgaWYgKG1zZy50eXBlID09PSAwIC8qIE1lc3NhZ2VUeXBlLlJlcXVlc3QgKi8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNnLmFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobXNnLmFyZ3NbaV0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zlci5wdXNoKG1zZy5hcmdzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXNnLnR5cGUgPT09IDEgLyogTWVzc2FnZVR5cGUuUmVwbHkgKi8pIHtcbiAgICAgICAgICAgIGlmIChtc2cucmVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zlci5wdXNoKG1zZy5yZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hhbmRsZXIuc2VuZE1lc3NhZ2UobXNnLCB0cmFuc2Zlcik7XG4gICAgfVxufVxuLyoqXG4gKiBNYWluIHRocmVhZCBzaWRlXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW1wbGVXb3JrZXJDbGllbnQgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcih3b3JrZXJGYWN0b3J5LCB3b3JrZXJEZXNjcmlwdG9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2xvY2FsQ2hhbm5lbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHRoaXMuX3JlZ2lzdGVyKHdvcmtlckZhY3RvcnkuY3JlYXRlKHtcbiAgICAgICAgICAgIGFtZE1vZHVsZUlkOiAndnMvYmFzZS9jb21tb24vd29ya2VyL3NpbXBsZVdvcmtlcicsXG4gICAgICAgICAgICBlc21Nb2R1bGVMb2NhdGlvbjogd29ya2VyRGVzY3JpcHRvci5lc21Nb2R1bGVMb2NhdGlvbixcbiAgICAgICAgICAgIGxhYmVsOiB3b3JrZXJEZXNjcmlwdG9yLmxhYmVsXG4gICAgICAgIH0sIChtc2cpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLmhhbmRsZU1lc3NhZ2UobXNnKTtcbiAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgLy8gaW4gRmlyZWZveCwgd2ViIHdvcmtlcnMgZmFpbCBsYXppbHkgOihcbiAgICAgICAgICAgIC8vIHdlIHdpbGwgcmVqZWN0IHRoZSBwcm94eVxuICAgICAgICAgICAgb25VbmV4cGVjdGVkRXJyb3IoZXJyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IG5ldyBTaW1wbGVXb3JrZXJQcm90b2NvbCh7XG4gICAgICAgICAgICBzZW5kTWVzc2FnZTogKG1zZywgdHJhbnNmZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2UobXNnLCB0cmFuc2Zlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlTWVzc2FnZTogKGNoYW5uZWwsIG1ldGhvZCwgYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVNZXNzYWdlKGNoYW5uZWwsIG1ldGhvZCwgYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlRXZlbnQ6IChjaGFubmVsLCBldmVudE5hbWUsIGFyZykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVFdmVudChjaGFubmVsLCBldmVudE5hbWUsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcm90b2NvbC5zZXRXb3JrZXJJZCh0aGlzLl93b3JrZXIuZ2V0SWQoKSk7XG4gICAgICAgIC8vIEdhdGhlciBsb2FkZXIgY29uZmlndXJhdGlvblxuICAgICAgICBsZXQgbG9hZGVyQ29uZmlndXJhdGlvbiA9IG51bGw7XG4gICAgICAgIGNvbnN0IGdsb2JhbFJlcXVpcmUgPSBnbG9iYWxUaGlzLnJlcXVpcmU7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsUmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbFJlcXVpcmUuZ2V0Q29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgTW9uYWNvIEFNRCBMb2FkZXJcbiAgICAgICAgICAgIGxvYWRlckNvbmZpZ3VyYXRpb24gPSBnbG9iYWxSZXF1aXJlLmdldENvbmZpZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLnJlcXVpcmVqcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY29uZmlndXJhdGlvbiBmcm9tIHJlcXVpcmVqc1xuICAgICAgICAgICAgbG9hZGVyQ29uZmlndXJhdGlvbiA9IGdsb2JhbFRoaXMucmVxdWlyZWpzLnMuY29udGV4dHMuXy5jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VuZCBpbml0aWFsaXplIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5fb25Nb2R1bGVMb2FkZWQgPSB0aGlzLl9wcm90b2NvbC5zZW5kTWVzc2FnZShERUZBVUxUX0NIQU5ORUwsIElOSVRJQUxJWkUsIFtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci5nZXRJZCgpLFxuICAgICAgICAgICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsb2FkZXJDb25maWd1cmF0aW9uKSksXG4gICAgICAgICAgICB3b3JrZXJEZXNjcmlwdG9yLmFtZE1vZHVsZUlkLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5wcm94eSA9IHRoaXMuX3Byb3RvY29sLmNyZWF0ZVByb3h5VG9SZW1vdGVDaGFubmVsKERFRkFVTFRfQ0hBTk5FTCwgYXN5bmMgKCkgPT4geyBhd2FpdCB0aGlzLl9vbk1vZHVsZUxvYWRlZDsgfSk7XG4gICAgICAgIHRoaXMuX29uTW9kdWxlTG9hZGVkLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKCdXb3JrZXIgZmFpbGVkIHRvIGxvYWQgJyArIHdvcmtlckRlc2NyaXB0b3IuYW1kTW9kdWxlSWQsIGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2hhbmRsZU1lc3NhZ2UoY2hhbm5lbE5hbWUsIG1ldGhvZCwgYXJncykge1xuICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5fbG9jYWxDaGFubmVscy5nZXQoY2hhbm5lbE5hbWUpO1xuICAgICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYE1pc3NpbmcgY2hhbm5lbCAke2NoYW5uZWxOYW1lfSBvbiBtYWluIHRocmVhZGApKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNoYW5uZWxbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgTWlzc2luZyBtZXRob2QgJHttZXRob2R9IG9uIG1haW4gdGhyZWFkIGNoYW5uZWwgJHtjaGFubmVsTmFtZX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2hhbm5lbFttZXRob2RdLmFwcGx5KGNoYW5uZWwsIGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9oYW5kbGVFdmVudChjaGFubmVsTmFtZSwgZXZlbnROYW1lLCBhcmcpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuX2xvY2FsQ2hhbm5lbHMuZ2V0KGNoYW5uZWxOYW1lKTtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgY2hhbm5lbCAke2NoYW5uZWxOYW1lfSBvbiBtYWluIHRocmVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRHluYW1pY0V2ZW50KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY2hhbm5lbFtldmVudE5hbWVdLmNhbGwoY2hhbm5lbCwgYXJnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZHluYW1pYyBldmVudCAke2V2ZW50TmFtZX0gb24gbWFpbiB0aHJlYWQgY2hhbm5lbCAke2NoYW5uZWxOYW1lfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHlJc0V2ZW50KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY2hhbm5lbFtldmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBldmVudCAke2V2ZW50TmFtZX0gb24gbWFpbiB0aHJlYWQgY2hhbm5lbCAke2NoYW5uZWxOYW1lfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBldmVudCBuYW1lICR7ZXZlbnROYW1lfWApO1xuICAgIH1cbiAgICBzZXRDaGFubmVsKGNoYW5uZWwsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxDaGFubmVscy5zZXQoY2hhbm5lbCwgaGFuZGxlcik7XG4gICAgfVxuICAgIF9vbkVycm9yKG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhlcnJvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvcGVydHlJc0V2ZW50KG5hbWUpIHtcbiAgICAvLyBBc3N1bWUgYSBwcm9wZXJ0eSBpcyBhbiBldmVudCBpZiBpdCBoYXMgYSBmb3JtIG9mIFwib25Tb21ldGhpbmdcIlxuICAgIHJldHVybiBuYW1lWzBdID09PSAnbycgJiYgbmFtZVsxXSA9PT0gJ24nICYmIHN0cmluZ3MuaXNVcHBlckFzY2lpTGV0dGVyKG5hbWUuY2hhckNvZGVBdCgyKSk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0eUlzRHluYW1pY0V2ZW50KG5hbWUpIHtcbiAgICAvLyBBc3N1bWUgYSBwcm9wZXJ0eSBpcyBhIGR5bmFtaWMgZXZlbnQgKGEgbWV0aG9kIHRoYXQgcmV0dXJucyBhbiBldmVudCkgaWYgaXQgaGFzIGEgZm9ybSBvZiBcIm9uRHluYW1pY1NvbWV0aGluZ1wiXG4gICAgcmV0dXJuIC9eb25EeW5hbWljLy50ZXN0KG5hbWUpICYmIHN0cmluZ3MuaXNVcHBlckFzY2lpTGV0dGVyKG5hbWUuY2hhckNvZGVBdCg5KSk7XG59XG4vKipcbiAqIFdvcmtlciBzaWRlXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW1wbGVXb3JrZXJTZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvc3RNZXNzYWdlLCByZXF1ZXN0SGFuZGxlckZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxDaGFubmVscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlQ2hhbm5lbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyRmFjdG9yeSA9IHJlcXVlc3RIYW5kbGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IG5ldyBTaW1wbGVXb3JrZXJQcm90b2NvbCh7XG4gICAgICAgICAgICBzZW5kTWVzc2FnZTogKG1zZywgdHJhbnNmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZShtc2csIHRyYW5zZmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVNZXNzYWdlOiAoY2hhbm5lbCwgbWV0aG9kLCBhcmdzKSA9PiB0aGlzLl9oYW5kbGVNZXNzYWdlKGNoYW5uZWwsIG1ldGhvZCwgYXJncyksXG4gICAgICAgICAgICBoYW5kbGVFdmVudDogKGNoYW5uZWwsIGV2ZW50TmFtZSwgYXJnKSA9PiB0aGlzLl9oYW5kbGVFdmVudChjaGFubmVsLCBldmVudE5hbWUsIGFyZylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9ubWVzc2FnZShtc2cpIHtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuaGFuZGxlTWVzc2FnZShtc2cpO1xuICAgIH1cbiAgICBfaGFuZGxlTWVzc2FnZShjaGFubmVsLCBtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGNoYW5uZWwgPT09IERFRkFVTFRfQ0hBTk5FTCAmJiBtZXRob2QgPT09IElOSVRJQUxJWkUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemUoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdEhhbmRsZXIgPSAoY2hhbm5lbCA9PT0gREVGQVVMVF9DSEFOTkVMID8gdGhpcy5fcmVxdWVzdEhhbmRsZXIgOiB0aGlzLl9sb2NhbENoYW5uZWxzLmdldChjaGFubmVsKSk7XG4gICAgICAgIGlmICghcmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYE1pc3NpbmcgY2hhbm5lbCAke2NoYW5uZWx9IG9uIHdvcmtlciB0aHJlYWRgKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0SGFuZGxlclttZXRob2RdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBNaXNzaW5nIG1ldGhvZCAke21ldGhvZH0gb24gd29ya2VyIHRocmVhZCBjaGFubmVsICR7Y2hhbm5lbH1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVxdWVzdEhhbmRsZXJbbWV0aG9kXS5hcHBseShyZXF1ZXN0SGFuZGxlciwgYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2hhbmRsZUV2ZW50KGNoYW5uZWwsIGV2ZW50TmFtZSwgYXJnKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYW5kbGVyID0gKGNoYW5uZWwgPT09IERFRkFVTFRfQ0hBTk5FTCA/IHRoaXMuX3JlcXVlc3RIYW5kbGVyIDogdGhpcy5fbG9jYWxDaGFubmVscy5nZXQoY2hhbm5lbCkpO1xuICAgICAgICBpZiAoIXJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgY2hhbm5lbCAke2NoYW5uZWx9IG9uIHdvcmtlciB0aHJlYWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHlJc0R5bmFtaWNFdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHJlcXVlc3RIYW5kbGVyW2V2ZW50TmFtZV0uY2FsbChyZXF1ZXN0SGFuZGxlciwgYXJnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZHluYW1pYyBldmVudCAke2V2ZW50TmFtZX0gb24gcmVxdWVzdCBoYW5kbGVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRXZlbnQoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSByZXF1ZXN0SGFuZGxlcltldmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBldmVudCAke2V2ZW50TmFtZX0gb24gcmVxdWVzdCBoYW5kbGVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIGV2ZW50IG5hbWUgJHtldmVudE5hbWV9YCk7XG4gICAgfVxuICAgIGdldENoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JlbW90ZUNoYW5uZWxzLmhhcyhjaGFubmVsKSkge1xuICAgICAgICAgICAgY29uc3QgaW5zdCA9IHRoaXMuX3Byb3RvY29sLmNyZWF0ZVByb3h5VG9SZW1vdGVDaGFubmVsKGNoYW5uZWwpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlQ2hhbm5lbHMuc2V0KGNoYW5uZWwsIGluc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVDaGFubmVscy5nZXQoY2hhbm5lbCk7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUod29ya2VySWQsIGxvYWRlckNvbmZpZywgbW9kdWxlSWQpIHtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuc2V0V29ya2VySWQod29ya2VySWQpO1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdEhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICAgICAgICAvLyBzdGF0aWMgcmVxdWVzdCBoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlciA9IHRoaXMuX3JlcXVlc3RIYW5kbGVyRmFjdG9yeSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9hZGVyQ29uZmlnKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgJ2Jhc2VVcmwnLCBoYW5kbGluZyBpdCBpcyBiZXlvbmQgc2NvcGUgZm9yIG5vd1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2FkZXJDb25maWcuYmFzZVVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbG9hZGVyQ29uZmlnWydiYXNlVXJsJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlckNvbmZpZy5wYXRocyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlckNvbmZpZy5wYXRocy52cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvYWRlckNvbmZpZy5wYXRoc1sndnMnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlckNvbmZpZy50cnVzdGVkVHlwZXNQb2xpY3kgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgdXNlLCBpdCBoYXMgYmVlbiBkZXN0cm95ZWQgZHVyaW5nIHNlcmlhbGl6ZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2FkZXJDb25maWdbJ3RydXN0ZWRUeXBlc1BvbGljeSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBpbiBhIHdlYiB3b3JrZXIsIGVuYWJsZSBjYXRjaGluZyBlcnJvcnNcbiAgICAgICAgICAgIGxvYWRlckNvbmZpZy5jYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMucmVxdWlyZS5jb25maWcobG9hZGVyQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFU00pIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IEZpbGVBY2Nlc3MuYXNCcm93c2VyVXJpKGAke21vZHVsZUlkfS5qc2ApLnRvU3RyaW5nKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydChgJHt1cmx9YCkudGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXIgPSBtb2R1bGUuY3JlYXRlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBSZXF1ZXN0SGFuZGxlciFgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBnbG9iYWwgcmVxdWlyZSB0byBiZSBzdXJlIHRvIGdldCB0aGUgZ2xvYmFsIGNvbmZpZ1xuICAgICAgICAgICAgLy8gRVNNLWNvbW1lbnQtYmVnaW5cbiAgICAgICAgICAgIC8vIFx0XHRcdGNvbnN0IHJlcSA9IChnbG9iYWxUaGlzLnJlcXVpcmUgfHwgcmVxdWlyZSk7XG4gICAgICAgICAgICAvLyBFU00tY29tbWVudC1lbmRcbiAgICAgICAgICAgIC8vIEVTTS11bmNvbW1lbnQtYmVnaW5cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGdsb2JhbFRoaXMucmVxdWlyZTtcbiAgICAgICAgICAgIC8vIEVTTS11bmNvbW1lbnQtZW5kXG4gICAgICAgICAgICByZXEoW21vZHVsZUlkXSwgKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyID0gbW9kdWxlLmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYE5vIFJlcXVlc3RIYW5kbGVyIWApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIERlZmluZXMgdGhlIHdvcmtlciBlbnRyeSBwb2ludC4gTXVzdCBiZSBleHBvcnRlZCBhbmQgbmFtZWQgYGNyZWF0ZWAuXG4gKiBAc2tpcE1hbmdsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHBvc3RNZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVXb3JrZXJTZXJ2ZXIocG9zdE1lc3NhZ2UsIG51bGwpO1xufVxuIiwidmFyIG1hcCA9IHtcblx0XCIuL3NpbXBsZVdvcmtlclwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3dvcmtlci9zaW1wbGVXb3JrZXIuanNcIixcblx0XCIuL3NpbXBsZVdvcmtlci5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3dvcmtlci9zaW1wbGVXb3JrZXIuanNcIlxufTtcblxuZnVuY3Rpb24gd2VicGFja0FzeW5jQ29udGV4dChyZXEpIHtcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblxuXHRcdHZhciBpZCA9IG1hcFtyZXFdO1xuXHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcblx0fSk7XG59XG53ZWJwYWNrQXN5bmNDb250ZXh0LmtleXMgPSAoKSA9PiAoT2JqZWN0LmtleXMobWFwKSk7XG53ZWJwYWNrQXN5bmNDb250ZXh0LmlkID0gXCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi93b3JrZXIgbGF6eSByZWN1cnNpdmUgXi4qJFwiO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQXN5bmNDb250ZXh0OyIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgdG9VaW50OCB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3VpbnQuanMnO1xuLyoqXG4gKiBBIGZhc3QgY2hhcmFjdGVyIGNsYXNzaWZpZXIgdGhhdCB1c2VzIGEgY29tcGFjdCBhcnJheSBmb3IgQVNDSUkgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgQ2hhcmFjdGVyQ2xhc3NpZmllciB7XG4gICAgY29uc3RydWN0b3IoX2RlZmF1bHRWYWx1ZSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0b1VpbnQ4KF9kZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuX2FzY2lpTWFwID0gQ2hhcmFjdGVyQ2xhc3NpZmllci5fY3JlYXRlQXNjaWlNYXAoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZUFzY2lpTWFwKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBjb25zdCBhc2NpaU1hcCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICAgIGFzY2lpTWFwLmZpbGwoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFzY2lpTWFwO1xuICAgIH1cbiAgICBzZXQoY2hhckNvZGUsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvVWludDgoX3ZhbHVlKTtcbiAgICAgICAgaWYgKGNoYXJDb2RlID49IDAgJiYgY2hhckNvZGUgPCAyNTYpIHtcbiAgICAgICAgICAgIHRoaXMuX2FzY2lpTWFwW2NoYXJDb2RlXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChjaGFyQ29kZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChjaGFyQ29kZSkge1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gMCAmJiBjaGFyQ29kZSA8IDI1Nikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzY2lpTWFwW2NoYXJDb2RlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fbWFwLmdldChjaGFyQ29kZSkgfHwgdGhpcy5fZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fYXNjaWlNYXAuZmlsbCh0aGlzLl9kZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2hhcmFjdGVyU2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fYWN0dWFsID0gbmV3IENoYXJhY3RlckNsYXNzaWZpZXIoMCAvKiBCb29sZWFuLkZhbHNlICovKTtcbiAgICB9XG4gICAgYWRkKGNoYXJDb2RlKSB7XG4gICAgICAgIHRoaXMuX2FjdHVhbC5zZXQoY2hhckNvZGUsIDEgLyogQm9vbGVhbi5UcnVlICovKTtcbiAgICB9XG4gICAgaGFzKGNoYXJDb2RlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYWN0dWFsLmdldChjaGFyQ29kZSkgPT09IDEgLyogQm9vbGVhbi5UcnVlICovKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3R1YWwuY2xlYXIoKTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEJ1Z0luZGljYXRpbmdFcnJvciB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4vb2Zmc2V0UmFuZ2UuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuL3JhbmdlLmpzJztcbmltcG9ydCB7IGZpbmRGaXJzdElkeE1vbm90b25vdXNPckFyckxlbiwgZmluZExhc3RJZHhNb25vdG9ub3VzLCBmaW5kTGFzdE1vbm90b25vdXMgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXNGaW5kLmpzJztcbi8qKlxuICogQSByYW5nZSBvZiBsaW5lcyAoMS1iYXNlZCkuXG4gKi9cbmV4cG9ydCBjbGFzcyBMaW5lUmFuZ2Uge1xuICAgIHN0YXRpYyBmcm9tUmFuZ2VJbmNsdXNpdmUocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2UocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsaW5lUmFuZ2VzIEFuIGFycmF5IG9mIHNvcnRlZCBsaW5lIHJhbmdlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgam9pbk1hbnkobGluZVJhbmdlcykge1xuICAgICAgICBpZiAobGluZVJhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IExpbmVSYW5nZVNldChsaW5lUmFuZ2VzWzBdLnNsaWNlKCkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5nZXRVbmlvbihuZXcgTGluZVJhbmdlU2V0KGxpbmVSYW5nZXNbaV0uc2xpY2UoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQucmFuZ2VzO1xuICAgIH1cbiAgICBzdGF0aWMgam9pbihsaW5lUmFuZ2VzKSB7XG4gICAgICAgIGlmIChsaW5lUmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcignbGluZVJhbmdlcyBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRMaW5lTnVtYmVyID0gbGluZVJhbmdlc1swXS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGxldCBlbmRMaW5lTnVtYmVyRXhjbHVzaXZlID0gbGluZVJhbmdlc1swXS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlciA9IE1hdGgubWluKHN0YXJ0TGluZU51bWJlciwgbGluZVJhbmdlc1tpXS5zdGFydExpbmVOdW1iZXIpO1xuICAgICAgICAgICAgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9IE1hdGgubWF4KGVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIGxpbmVSYW5nZXNbaV0uZW5kTGluZU51bWJlckV4Y2x1c2l2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBlbmRMaW5lTnVtYmVyRXhjbHVzaXZlKTtcbiAgICB9XG4gICAgc3RhdGljIG9mTGVuZ3RoKHN0YXJ0TGluZU51bWJlciwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlKHN0YXJ0TGluZU51bWJlciwgc3RhcnRMaW5lTnVtYmVyICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGxpbmVSYW5nZSkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZShsaW5lUmFuZ2VbMF0sIGxpbmVSYW5nZVsxXSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0YXJ0TGluZU51bWJlciwgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSkge1xuICAgICAgICBpZiAoc3RhcnRMaW5lTnVtYmVyID4gZW5kTGluZU51bWJlckV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcihgc3RhcnRMaW5lTnVtYmVyICR7c3RhcnRMaW5lTnVtYmVyfSBjYW5ub3QgYmUgYWZ0ZXIgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAke2VuZExpbmVOdW1iZXJFeGNsdXNpdmV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydExpbmVOdW1iZXIgPSBzdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9IGVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGlzIGxpbmUgcmFuZ2UgY29udGFpbnMgdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxuICAgICAqL1xuICAgIGNvbnRhaW5zKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRMaW5lTnVtYmVyIDw9IGxpbmVOdW1iZXIgJiYgbGluZU51bWJlciA8IHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoaXMgbGluZSByYW5nZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRMaW5lTnVtYmVyID09PSB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoaXMgbGluZSByYW5nZSBieSB0aGUgZ2l2ZW4gb2Zmc2V0IG9mIGxpbmUgbnVtYmVycy5cbiAgICAgKi9cbiAgICBkZWx0YShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIgKyBvZmZzZXQsIHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSArIG9mZnNldCk7XG4gICAgfVxuICAgIGRlbHRhTGVuZ3RoKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZSh0aGlzLnN0YXJ0TGluZU51bWJlciwgdGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICsgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBsaW5lcyB0aGlzIGxpbmUgcmFuZ2Ugc3BhbnMuXG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAtIHRoaXMuc3RhcnRMaW5lTnVtYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGluZSByYW5nZSB0aGF0IGNvbWJpbmVzIHRoaXMgYW5kIHRoZSBnaXZlbiBsaW5lIHJhbmdlLlxuICAgICAqL1xuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2UoTWF0aC5taW4odGhpcy5zdGFydExpbmVOdW1iZXIsIG90aGVyLnN0YXJ0TGluZU51bWJlciksIE1hdGgubWF4KHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgb3RoZXIuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YXJ0TGluZU51bWJlcn0sJHt0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmV9KWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcgcmFuZ2UgaXMgZW1wdHkgaWYgdGhlIHJhbmdlcyBkbyBub3QgaW50ZXJzZWN0LCBidXQgdG91Y2guXG4gICAgICogSWYgdGhlIHJhbmdlcyBkb24ndCBldmVuIHRvdWNoLCB0aGUgcmVzdWx0IGlzIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBpbnRlcnNlY3Qob3RoZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lTnVtYmVyID0gTWF0aC5tYXgodGhpcy5zdGFydExpbmVOdW1iZXIsIG90aGVyLnN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IGVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPSBNYXRoLm1pbih0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIG90aGVyLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xuICAgICAgICBpZiAoc3RhcnRMaW5lTnVtYmVyIDw9IGVuZExpbmVOdW1iZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlKHN0YXJ0TGluZU51bWJlciwgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaW50ZXJzZWN0c1N0cmljdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydExpbmVOdW1iZXIgPCBvdGhlci5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICYmIG90aGVyLnN0YXJ0TGluZU51bWJlciA8IHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgb3ZlcmxhcE9yVG91Y2gob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRMaW5lTnVtYmVyIDw9IG90aGVyLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgJiYgb3RoZXIuc3RhcnRMaW5lTnVtYmVyIDw9IHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgZXF1YWxzKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRMaW5lTnVtYmVyID09PSBiLnN0YXJ0TGluZU51bWJlciAmJiB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPT09IGIuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgdG9JbmNsdXNpdmVSYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0TGluZU51bWJlciwgMSwgdGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gMSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2luZyB0aGlzIGZ1bmN0aW9uIGlzIGRpc2NvdXJhZ2VkIGJlY2F1c2UgaXQgbWlnaHQgbGVhZCB0byBidWdzOiBUaGUgZW5kIHBvc2l0aW9uIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGEgdmFsaWQgcG9zaXRpb24hXG4gICAgKi9cbiAgICB0b0V4Y2x1c2l2ZVJhbmdlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnRMaW5lTnVtYmVyLCAxLCB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIDEpO1xuICAgIH1cbiAgICBtYXBUb0xpbmVBcnJheShmKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gdGhpcy5zdGFydExpbmVOdW1iZXI7IGxpbmVOdW1iZXIgPCB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7IGxpbmVOdW1iZXIrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZihsaW5lTnVtYmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSB0aGlzLnN0YXJ0TGluZU51bWJlcjsgbGluZU51bWJlciA8IHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTsgbGluZU51bWJlcisrKSB7XG4gICAgICAgICAgICBmKGxpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXJ0TGluZU51bWJlciwgdGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlXTtcbiAgICB9XG4gICAgaW5jbHVkZXMobGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydExpbmVOdW1iZXIgPD0gbGluZU51bWJlciAmJiBsaW5lTnVtYmVyIDwgdGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIDEtYmFzZWQgbGluZSByYW5nZSB0byBhIDAtYmFzZWQgb2Zmc2V0IHJhbmdlIChzdWJ0cmFjdHMgMSEpLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRvT2Zmc2V0UmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIgLSAxLCB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSAxKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTGluZVJhbmdlU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBTb3J0ZWQgYnkgc3RhcnQgbGluZSBudW1iZXIuXG4gICAgICogTm8gdHdvIGxpbmUgcmFuZ2VzIGFyZSB0b3VjaGluZyBvciBpbnRlcnNlY3RpbmcuXG4gICAgICovXG4gICAgX25vcm1hbGl6ZWRSYW5nZXMgPSBbXSkge1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzID0gX25vcm1hbGl6ZWRSYW5nZXM7XG4gICAgfVxuICAgIGdldCByYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzO1xuICAgIH1cbiAgICBhZGRSYW5nZShyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWRlYTogRmluZCBqb2luUmFuZ2Ugc3VjaCB0aGF0OlxuICAgICAgICAvLyByZXBsYWNlUmFuZ2UgPSBfbm9ybWFsaXplZFJhbmdlcy5yZXBsYWNlUmFuZ2Uoam9pblJhbmdlLCByYW5nZS5qb2luQWxsKGpvaW5SYW5nZS5tYXAoaWR4ID0+IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXNbaWR4XSkpKVxuICAgICAgICAvLyBpZHggb2YgZmlyc3QgZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2Ugb3IgdGhhdCBpcyBhZnRlciByYW5nZVxuICAgICAgICBjb25zdCBqb2luUmFuZ2VTdGFydElkeCA9IGZpbmRGaXJzdElkeE1vbm90b25vdXNPckFyckxlbih0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLCByID0+IHIuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA+PSByYW5nZS5zdGFydExpbmVOdW1iZXIpO1xuICAgICAgICAvLyBpZHggb2YgZWxlbWVudCBhZnRlciB7IGxhc3QgZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2Ugb3IgdGhhdCBpcyBiZWZvcmUgcmFuZ2UgfVxuICAgICAgICBjb25zdCBqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUgPSBmaW5kTGFzdElkeE1vbm90b25vdXModGhpcy5fbm9ybWFsaXplZFJhbmdlcywgciA9PiByLnN0YXJ0TGluZU51bWJlciA8PSByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSArIDE7XG4gICAgICAgIGlmIChqb2luUmFuZ2VTdGFydElkeCA9PT0gam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBlbGVtZW50IHRoYXQgdG91Y2hlcyByYW5nZSwgdGhlbiBqb2luUmFuZ2VTdGFydElkeCA9PT0gam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlIGFuZCB0aGF0IHZhbHVlIGlzIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBhZnRlciByYW5nZVxuICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplZFJhbmdlcy5zcGxpY2Uoam9pblJhbmdlU3RhcnRJZHgsIDAsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqb2luUmFuZ2VTdGFydElkeCA9PT0gam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlIC0gMSkge1xuICAgICAgICAgICAgLy8gRWxzZSwgdGhlcmUgaXMgYW4gZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2UgYW5kIGluIHRoaXMgY2FzZSBpdCBpcyBib3RoIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50LiBUaHVzIHdlIGNhbiByZXBsYWNlIGl0XG4gICAgICAgICAgICBjb25zdCBqb2luUmFuZ2UgPSB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2pvaW5SYW5nZVN0YXJ0SWR4XTtcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZWRSYW5nZXNbam9pblJhbmdlU3RhcnRJZHhdID0gam9pblJhbmdlLmpvaW4ocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyc3QgYW5kIGxhc3QgZWxlbWVudCBhcmUgZGlmZmVyZW50IC0gd2UgbmVlZCB0byByZXBsYWNlIHRoZSBlbnRpcmUgcmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IGpvaW5SYW5nZSA9IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXNbam9pblJhbmdlU3RhcnRJZHhdLmpvaW4odGhpcy5fbm9ybWFsaXplZFJhbmdlc1tqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUgLSAxXSkuam9pbihyYW5nZSk7XG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLnNwbGljZShqb2luUmFuZ2VTdGFydElkeCwgam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlIC0gam9pblJhbmdlU3RhcnRJZHgsIGpvaW5SYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udGFpbnMobGluZU51bWJlcikge1xuICAgICAgICBjb25zdCByYW5nZVRoYXRTdGFydHNCZWZvcmVFbmQgPSBmaW5kTGFzdE1vbm90b25vdXModGhpcy5fbm9ybWFsaXplZFJhbmdlcywgciA9PiByLnN0YXJ0TGluZU51bWJlciA8PSBsaW5lTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuICEhcmFuZ2VUaGF0U3RhcnRzQmVmb3JlRW5kICYmIHJhbmdlVGhhdFN0YXJ0c0JlZm9yZUVuZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlID4gbGluZU51bWJlcjtcbiAgICB9XG4gICAgaW50ZXJzZWN0cyhyYW5nZSkge1xuICAgICAgICBjb25zdCByYW5nZVRoYXRTdGFydHNCZWZvcmVFbmQgPSBmaW5kTGFzdE1vbm90b25vdXModGhpcy5fbm9ybWFsaXplZFJhbmdlcywgciA9PiByLnN0YXJ0TGluZU51bWJlciA8IHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xuICAgICAgICByZXR1cm4gISFyYW5nZVRoYXRTdGFydHNCZWZvcmVFbmQgJiYgcmFuZ2VUaGF0U3RhcnRzQmVmb3JlRW5kLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPiByYW5nZS5zdGFydExpbmVOdW1iZXI7XG4gICAgfVxuICAgIGdldFVuaW9uKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci5fbm9ybWFsaXplZFJhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgaTEgPSAwO1xuICAgICAgICBsZXQgaTIgPSAwO1xuICAgICAgICBsZXQgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHdoaWxlIChpMSA8IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMubGVuZ3RoIHx8IGkyIDwgb3RoZXIuX25vcm1hbGl6ZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaTEgPCB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCAmJiBpMiA8IG90aGVyLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVSYW5nZTEgPSB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2kxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lUmFuZ2UyID0gb3RoZXIuX25vcm1hbGl6ZWRSYW5nZXNbaTJdO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lUmFuZ2UxLnN0YXJ0TGluZU51bWJlciA8IGxpbmVSYW5nZTIuc3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBsaW5lUmFuZ2UxO1xuICAgICAgICAgICAgICAgICAgICBpMSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGxpbmVSYW5nZTI7XG4gICAgICAgICAgICAgICAgICAgIGkyKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaTEgPCB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2kxXTtcbiAgICAgICAgICAgICAgICBpMSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG90aGVyLl9ub3JtYWxpemVkUmFuZ2VzW2kyXTtcbiAgICAgICAgICAgICAgICBpMisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPj0gbmV4dC5zdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBMaW5lUmFuZ2UoY3VycmVudC5zdGFydExpbmVOdW1iZXIsIE1hdGgubWF4KGN1cnJlbnQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgbmV4dC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlU2V0KHJlc3VsdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhbGwgcmFuZ2VzIGluIHRoaXMgc2V0IGZyb20gYHJhbmdlYCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHN1YnRyYWN0RnJvbShyYW5nZSkge1xuICAgICAgICAvLyBpZHggb2YgZmlyc3QgZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2Ugb3IgdGhhdCBpcyBhZnRlciByYW5nZVxuICAgICAgICBjb25zdCBqb2luUmFuZ2VTdGFydElkeCA9IGZpbmRGaXJzdElkeE1vbm90b25vdXNPckFyckxlbih0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLCByID0+IHIuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA+PSByYW5nZS5zdGFydExpbmVOdW1iZXIpO1xuICAgICAgICAvLyBpZHggb2YgZWxlbWVudCBhZnRlciB7IGxhc3QgZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2Ugb3IgdGhhdCBpcyBiZWZvcmUgcmFuZ2UgfVxuICAgICAgICBjb25zdCBqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUgPSBmaW5kTGFzdElkeE1vbm90b25vdXModGhpcy5fbm9ybWFsaXplZFJhbmdlcywgciA9PiByLnN0YXJ0TGluZU51bWJlciA8PSByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSArIDE7XG4gICAgICAgIGlmIChqb2luUmFuZ2VTdGFydElkeCA9PT0gam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZVNldChbcmFuZ2VdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IHN0YXJ0TGluZU51bWJlciA9IHJhbmdlLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IGpvaW5SYW5nZVN0YXJ0SWR4OyBpIDwgam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKHIuc3RhcnRMaW5lTnVtYmVyID4gc3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IExpbmVSYW5nZShzdGFydExpbmVOdW1iZXIsIHIuc3RhcnRMaW5lTnVtYmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSByLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0TGluZU51bWJlciA8IHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2VTZXQocmVzdWx0KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLm1hcChyID0+IHIudG9TdHJpbmcoKSkuam9pbignLCAnKTtcbiAgICB9XG4gICAgZ2V0SW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgaTEgPSAwO1xuICAgICAgICBsZXQgaTIgPSAwO1xuICAgICAgICB3aGlsZSAoaTEgPCB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCAmJiBpMiA8IG90aGVyLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcjEgPSB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2kxXTtcbiAgICAgICAgICAgIGNvbnN0IHIyID0gb3RoZXIuX25vcm1hbGl6ZWRSYW5nZXNbaTJdO1xuICAgICAgICAgICAgY29uc3QgaSA9IHIxLmludGVyc2VjdChyMik7XG4gICAgICAgICAgICBpZiAoaSAmJiAhaS5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjEuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA8IHIyLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICBpMSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaTIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZVNldChyZXN1bHQpO1xuICAgIH1cbiAgICBnZXRXaXRoRGVsdGEodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2VTZXQodGhpcy5fbm9ybWFsaXplZFJhbmdlcy5tYXAociA9PiByLmRlbHRhKHZhbHVlKSkpO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgQnVnSW5kaWNhdGluZ0Vycm9yIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZXJyb3JzLmpzJztcbi8qKlxuICogQSByYW5nZSBvZiBvZmZzZXRzICgwLWJhc2VkKS5cbiovXG5leHBvcnQgY2xhc3MgT2Zmc2V0UmFuZ2Uge1xuICAgIHN0YXRpYyBhZGRSYW5nZShyYW5nZSwgc29ydGVkUmFuZ2VzKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzb3J0ZWRSYW5nZXMubGVuZ3RoICYmIHNvcnRlZFJhbmdlc1tpXS5lbmRFeGNsdXNpdmUgPCByYW5nZS5zdGFydCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBqID0gaTtcbiAgICAgICAgd2hpbGUgKGogPCBzb3J0ZWRSYW5nZXMubGVuZ3RoICYmIHNvcnRlZFJhbmdlc1tqXS5zdGFydCA8PSByYW5nZS5lbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgc29ydGVkUmFuZ2VzLnNwbGljZShpLCAwLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKHJhbmdlLnN0YXJ0LCBzb3J0ZWRSYW5nZXNbaV0uc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5tYXgocmFuZ2UuZW5kRXhjbHVzaXZlLCBzb3J0ZWRSYW5nZXNbaiAtIDFdLmVuZEV4Y2x1c2l2ZSk7XG4gICAgICAgICAgICBzb3J0ZWRSYW5nZXMuc3BsaWNlKGksIGogLSBpLCBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB0cnlDcmVhdGUoc3RhcnQsIGVuZEV4Y2x1c2l2ZSkge1xuICAgICAgICBpZiAoc3RhcnQgPiBlbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRSYW5nZShzdGFydCwgZW5kRXhjbHVzaXZlKTtcbiAgICB9XG4gICAgc3RhdGljIG9mTGVuZ3RoKGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIHN0YXRpYyBvZlN0YXJ0QW5kTGVuZ3RoKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRSYW5nZShzdGFydCwgc3RhcnQgKyBsZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kRXhjbHVzaXZlKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmRFeGNsdXNpdmUgPSBlbmRFeGNsdXNpdmU7XG4gICAgICAgIGlmIChzdGFydCA+IGVuZEV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcihgSW52YWxpZCByYW5nZTogJHt0aGlzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ID09PSB0aGlzLmVuZEV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgZGVsdGEob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2UodGhpcy5zdGFydCArIG9mZnNldCwgdGhpcy5lbmRFeGNsdXNpdmUgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBkZWx0YVN0YXJ0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKHRoaXMuc3RhcnQgKyBvZmZzZXQsIHRoaXMuZW5kRXhjbHVzaXZlKTtcbiAgICB9XG4gICAgZGVsdGFFbmQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2UodGhpcy5zdGFydCwgdGhpcy5lbmRFeGNsdXNpdmUgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRFeGNsdXNpdmUgLSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YXJ0fSwgJHt0aGlzLmVuZEV4Y2x1c2l2ZX0pYDtcbiAgICB9XG4gICAgY29udGFpbnMob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0IDw9IG9mZnNldCAmJiBvZmZzZXQgPCB0aGlzLmVuZEV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZm9yIGFsbCBudW1iZXJzIG46IHJhbmdlMS5jb250YWlucyhuKSBvciByYW5nZTIuY29udGFpbnMobikgPT4gcmFuZ2UxLmpvaW4ocmFuZ2UyKS5jb250YWlucyhuKVxuICAgICAqIFRoZSBqb2luZWQgcmFuZ2UgaXMgdGhlIHNtYWxsZXN0IHJhbmdlIHRoYXQgY29udGFpbnMgYm90aCByYW5nZXMuXG4gICAgICovXG4gICAgam9pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKE1hdGgubWluKHRoaXMuc3RhcnQsIG90aGVyLnN0YXJ0KSwgTWF0aC5tYXgodGhpcy5lbmRFeGNsdXNpdmUsIG90aGVyLmVuZEV4Y2x1c2l2ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmb3IgYWxsIG51bWJlcnMgbjogcmFuZ2UxLmNvbnRhaW5zKG4pIGFuZCByYW5nZTIuY29udGFpbnMobikgPD0+IHJhbmdlMS5pbnRlcnNlY3QocmFuZ2UyKS5jb250YWlucyhuKVxuICAgICAqXG4gICAgICogVGhlIHJlc3VsdGluZyByYW5nZSBpcyBlbXB0eSBpZiB0aGUgcmFuZ2VzIGRvIG5vdCBpbnRlcnNlY3QsIGJ1dCB0b3VjaC5cbiAgICAgKiBJZiB0aGUgcmFuZ2VzIGRvbid0IGV2ZW4gdG91Y2gsIHRoZSByZXN1bHQgaXMgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGludGVyc2VjdChvdGhlcikge1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHRoaXMuc3RhcnQsIG90aGVyLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4odGhpcy5lbmRFeGNsdXNpdmUsIG90aGVyLmVuZEV4Y2x1c2l2ZSk7XG4gICAgICAgIGlmIChzdGFydCA8PSBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaW50ZXJzZWN0cyhvdGhlcikge1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHRoaXMuc3RhcnQsIG90aGVyLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4odGhpcy5lbmRFeGNsdXNpdmUsIG90aGVyLmVuZEV4Y2x1c2l2ZSk7XG4gICAgICAgIHJldHVybiBzdGFydCA8IGVuZDtcbiAgICB9XG4gICAgaXNCZWZvcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kRXhjbHVzaXZlIDw9IG90aGVyLnN0YXJ0O1xuICAgIH1cbiAgICBpc0FmdGVyKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ID49IG90aGVyLmVuZEV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgc2xpY2UoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnIuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmRFeGNsdXNpdmUpO1xuICAgIH1cbiAgICBzdWJzdHJpbmcoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXMuc3RhcnQsIHRoaXMuZW5kRXhjbHVzaXZlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZ2l2ZW4gdmFsdWUgaWYgaXQgaXMgY29udGFpbmVkIGluIHRoaXMgaW5zdGFuY2UsIG90aGVyd2lzZSB0aGUgY2xvc2VzdCB2YWx1ZSB0aGF0IGlzIGNvbnRhaW5lZC5cbiAgICAgKiBUaGUgcmFuZ2UgbXVzdCBub3QgYmUgZW1wdHkuXG4gICAgICovXG4gICAgY2xpcCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKGBJbnZhbGlkIGNsaXBwaW5nIHJhbmdlOiAke3RoaXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5zdGFydCwgTWF0aC5taW4odGhpcy5lbmRFeGNsdXNpdmUgLSAxLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGByIDo9IHZhbHVlICsgayAqIGxlbmd0aGAgc3VjaCB0aGF0IGByYCBpcyBjb250YWluZWQgaW4gdGhpcyByYW5nZS5cbiAgICAgKiBUaGUgcmFuZ2UgbXVzdCBub3QgYmUgZW1wdHkuXG4gICAgICpcbiAgICAgKiBFLmcuIGBbNSwgMTApLmNsaXBDeWNsaWMoMTApID09PSA1YCwgYFs1LCAxMCkuY2xpcEN5Y2xpYygxMSkgPT09IDZgIGFuZCBgWzUsIDEwKS5jbGlwQ3ljbGljKDQpID09PSA5YC5cbiAgICAgKi9cbiAgICBjbGlwQ3ljbGljKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoYEludmFsaWQgY2xpcHBpbmcgcmFuZ2U6ICR7dGhpcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IHRoaXMuc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZEV4Y2x1c2l2ZSAtICgodGhpcy5zdGFydCAtIHZhbHVlKSAlIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5lbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgKCh2YWx1ZSAtIHRoaXMuc3RhcnQpICUgdGhpcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXJ0OyBpIDwgdGhpcy5lbmRFeGNsdXNpdmU7IGkrKykge1xuICAgICAgICAgICAgZihpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPZmZzZXRSYW5nZVNldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3NvcnRlZFJhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBhZGRSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5fc29ydGVkUmFuZ2VzLmxlbmd0aCAmJiB0aGlzLl9zb3J0ZWRSYW5nZXNbaV0uZW5kRXhjbHVzaXZlIDwgcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaiA9IGk7XG4gICAgICAgIHdoaWxlIChqIDwgdGhpcy5fc29ydGVkUmFuZ2VzLmxlbmd0aCAmJiB0aGlzLl9zb3J0ZWRSYW5nZXNbal0uc3RhcnQgPD0gcmFuZ2UuZW5kRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZFJhbmdlcy5zcGxpY2UoaSwgMCwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihyYW5nZS5zdGFydCwgdGhpcy5fc29ydGVkUmFuZ2VzW2ldLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWF4KHJhbmdlLmVuZEV4Y2x1c2l2ZSwgdGhpcy5fc29ydGVkUmFuZ2VzW2ogLSAxXS5lbmRFeGNsdXNpdmUpO1xuICAgICAgICAgICAgdGhpcy5fc29ydGVkUmFuZ2VzLnNwbGljZShpLCBqIC0gaSwgbmV3IE9mZnNldFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvcnRlZFJhbmdlcy5tYXAociA9PiByLnRvU3RyaW5nKCkpLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2YgdGhlcmUgaXMgYSB2YWx1ZSB0aGF0IGlzIGNvbnRhaW5lZCBpbiB0aGlzIGluc3RhbmNlIGFuZCB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgICovXG4gICAgaW50ZXJzZWN0c1N0cmljdChvdGhlcikge1xuICAgICAgICAvLyBUT0RPIHVzZSBiaW5hcnkgc2VhcmNoXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLl9zb3J0ZWRSYW5nZXMubGVuZ3RoICYmIHRoaXMuX3NvcnRlZFJhbmdlc1tpXS5lbmRFeGNsdXNpdmUgPD0gb3RoZXIuc3RhcnQpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaSA8IHRoaXMuX3NvcnRlZFJhbmdlcy5sZW5ndGggJiYgdGhpcy5fc29ydGVkUmFuZ2VzW2ldLnN0YXJ0IDwgb3RoZXIuZW5kRXhjbHVzaXZlO1xuICAgIH1cbiAgICBpbnRlcnNlY3RXaXRoUmFuZ2Uob3RoZXIpIHtcbiAgICAgICAgLy8gVE9ETyB1c2UgYmluYXJ5IHNlYXJjaCArIHNsaWNlXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBPZmZzZXRSYW5nZVNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHJhbmdlIG9mIHRoaXMuX3NvcnRlZFJhbmdlcykge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gcmFuZ2UuaW50ZXJzZWN0KG90aGVyKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkUmFuZ2UoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpbnRlcnNlY3RXaXRoUmFuZ2VMZW5ndGgob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0V2l0aFJhbmdlKG90aGVyKS5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3J0ZWRSYW5nZXMucmVkdWNlKChwcmV2LCBjdXIpID0+IHByZXYgKyBjdXIubGVuZ3RoLCAwKTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogQSBwb3NpdGlvbiBpbiB0aGUgZWRpdG9yLlxuICovXG5leHBvcnQgY2xhc3MgUG9zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVOdW1iZXIsIGNvbHVtbikge1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHBvc2l0aW9uIGZyb20gdGhpcyBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdMaW5lTnVtYmVyIG5ldyBsaW5lIG51bWJlclxuICAgICAqIEBwYXJhbSBuZXdDb2x1bW4gbmV3IGNvbHVtblxuICAgICAqL1xuICAgIHdpdGgobmV3TGluZU51bWJlciA9IHRoaXMubGluZU51bWJlciwgbmV3Q29sdW1uID0gdGhpcy5jb2x1bW4pIHtcbiAgICAgICAgaWYgKG5ld0xpbmVOdW1iZXIgPT09IHRoaXMubGluZU51bWJlciAmJiBuZXdDb2x1bW4gPT09IHRoaXMuY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obmV3TGluZU51bWJlciwgbmV3Q29sdW1uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXJpdmUgYSBuZXcgcG9zaXRpb24gZnJvbSB0aGlzIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlbHRhTGluZU51bWJlciBsaW5lIG51bWJlciBkZWx0YVxuICAgICAqIEBwYXJhbSBkZWx0YUNvbHVtbiBjb2x1bW4gZGVsdGFcbiAgICAgKi9cbiAgICBkZWx0YShkZWx0YUxpbmVOdW1iZXIgPSAwLCBkZWx0YUNvbHVtbiA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aCh0aGlzLmxpbmVOdW1iZXIgKyBkZWx0YUxpbmVOdW1iZXIsIHRoaXMuY29sdW1uICsgZGVsdGFDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoaXMgcG9zaXRpb24gZXF1YWxzIG90aGVyIHBvc2l0aW9uXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBQb3NpdGlvbi5lcXVhbHModGhpcywgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHBvc2l0aW9uIGBhYCBlcXVhbHMgcG9zaXRpb24gYGJgXG4gICAgICovXG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICghIWEgJiZcbiAgICAgICAgICAgICEhYiAmJlxuICAgICAgICAgICAgYS5saW5lTnVtYmVyID09PSBiLmxpbmVOdW1iZXIgJiZcbiAgICAgICAgICAgIGEuY29sdW1uID09PSBiLmNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBpcyBiZWZvcmUgb3RoZXIgcG9zaXRpb24uXG4gICAgICogSWYgdGhlIHR3byBwb3NpdGlvbnMgYXJlIGVxdWFsLCB0aGUgcmVzdWx0IHdpbGwgYmUgZmFsc2UuXG4gICAgICovXG4gICAgaXNCZWZvcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmlzQmVmb3JlKHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBgYWAgaXMgYmVmb3JlIHBvc2l0aW9uIGBiYC5cbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSBmYWxzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNCZWZvcmUoYSwgYikge1xuICAgICAgICBpZiAoYS5saW5lTnVtYmVyIDwgYi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYi5saW5lTnVtYmVyIDwgYS5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuY29sdW1uIDwgYi5jb2x1bW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBpcyBiZWZvcmUgb3RoZXIgcG9zaXRpb24uXG4gICAgICogSWYgdGhlIHR3byBwb3NpdGlvbnMgYXJlIGVxdWFsLCB0aGUgcmVzdWx0IHdpbGwgYmUgdHJ1ZS5cbiAgICAgKi9cbiAgICBpc0JlZm9yZU9yRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmlzQmVmb3JlT3JFcXVhbCh0aGlzLCBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgcG9zaXRpb24gYGFgIGlzIGJlZm9yZSBwb3NpdGlvbiBgYmAuXG4gICAgICogSWYgdGhlIHR3byBwb3NpdGlvbnMgYXJlIGVxdWFsLCB0aGUgcmVzdWx0IHdpbGwgYmUgdHJ1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNCZWZvcmVPckVxdWFsKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGluZU51bWJlciA8IGIubGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIubGluZU51bWJlciA8IGEubGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLmNvbHVtbiA8PSBiLmNvbHVtbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHBvc2l0aW9ucywgdXNlZnVsIGZvciBzb3J0aW5nXG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmUoYSwgYikge1xuICAgICAgICBjb25zdCBhTGluZU51bWJlciA9IGEubGluZU51bWJlciB8IDA7XG4gICAgICAgIGNvbnN0IGJMaW5lTnVtYmVyID0gYi5saW5lTnVtYmVyIHwgMDtcbiAgICAgICAgaWYgKGFMaW5lTnVtYmVyID09PSBiTGluZU51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgYUNvbHVtbiA9IGEuY29sdW1uIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGJDb2x1bW4gPSBiLmNvbHVtbiB8IDA7XG4gICAgICAgICAgICByZXR1cm4gYUNvbHVtbiAtIGJDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFMaW5lTnVtYmVyIC0gYkxpbmVOdW1iZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lIHRoaXMgcG9zaXRpb24uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lTnVtYmVyLCB0aGlzLmNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdG8gYSBodW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICcoJyArIHRoaXMubGluZU51bWJlciArICcsJyArIHRoaXMuY29sdW1uICsgJyknO1xuICAgIH1cbiAgICAvLyAtLS1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgUG9zaXRpb25gIGZyb20gYW4gYElQb3NpdGlvbmAuXG4gICAgICovXG4gICAgc3RhdGljIGxpZnQocG9zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocG9zLmxpbmVOdW1iZXIsIHBvcy5jb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGBvYmpgIGlzIGFuIGBJUG9zaXRpb25gLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0lQb3NpdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIChvYmpcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouY29sdW1uID09PSAnbnVtYmVyJykpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgT2Zmc2V0UmFuZ2UgfSBmcm9tICcuL29mZnNldFJhbmdlLmpzJztcbmltcG9ydCB7IFRleHRMZW5ndGggfSBmcm9tICcuL3RleHRMZW5ndGguanMnO1xuZXhwb3J0IGNsYXNzIFBvc2l0aW9uT2Zmc2V0VHJhbnNmb3JtZXIge1xuICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5saW5lU3RhcnRPZmZzZXRCeUxpbmVJZHggPSBbXTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnRPZmZzZXRCeUxpbmVJZHgucHVzaCgwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnRPZmZzZXRCeUxpbmVJZHgucHVzaChpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0T2Zmc2V0KHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVTdGFydE9mZnNldEJ5TGluZUlkeFtwb3NpdGlvbi5saW5lTnVtYmVyIC0gMV0gKyBwb3NpdGlvbi5jb2x1bW4gLSAxO1xuICAgIH1cbiAgICBnZXRPZmZzZXRSYW5nZShyYW5nZSkge1xuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKHRoaXMuZ2V0T2Zmc2V0KHJhbmdlLmdldFN0YXJ0UG9zaXRpb24oKSksIHRoaXMuZ2V0T2Zmc2V0KHJhbmdlLmdldEVuZFBvc2l0aW9uKCkpKTtcbiAgICB9XG4gICAgZ2V0IHRleHRMZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IGxpbmVJZHggPSB0aGlzLmxpbmVTdGFydE9mZnNldEJ5TGluZUlkeC5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRMZW5ndGgobGluZUlkeCwgdGhpcy50ZXh0Lmxlbmd0aCAtIHRoaXMubGluZVN0YXJ0T2Zmc2V0QnlMaW5lSWR4W2xpbmVJZHhdKTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi9wb3NpdGlvbi5qcyc7XG4vKipcbiAqIEEgcmFuZ2UgaW4gdGhlIGVkaXRvci4gKHN0YXJ0TGluZU51bWJlcixzdGFydENvbHVtbikgaXMgPD0gKGVuZExpbmVOdW1iZXIsZW5kQ29sdW1uKVxuICovXG5leHBvcnQgY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbikge1xuICAgICAgICBpZiAoKHN0YXJ0TGluZU51bWJlciA+IGVuZExpbmVOdW1iZXIpIHx8IChzdGFydExpbmVOdW1iZXIgPT09IGVuZExpbmVOdW1iZXIgJiYgc3RhcnRDb2x1bW4gPiBlbmRDb2x1bW4pKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TGluZU51bWJlciA9IGVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29sdW1uID0gZW5kQ29sdW1uO1xuICAgICAgICAgICAgdGhpcy5lbmRMaW5lTnVtYmVyID0gc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5lbmRDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRMaW5lTnVtYmVyID0gc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgdGhpcy5lbmRMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sdW1uID0gZW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhpcyByYW5nZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gUmFuZ2UuaXNFbXB0eSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBgcmFuZ2VgIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0VtcHR5KHJhbmdlKSB7XG4gICAgICAgIHJldHVybiAocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyICYmIHJhbmdlLnN0YXJ0Q29sdW1uID09PSByYW5nZS5lbmRDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHBvc2l0aW9uIGlzIGluIHRoaXMgcmFuZ2UuIElmIHRoZSBwb3NpdGlvbiBpcyBhdCB0aGUgZWRnZXMsIHdpbGwgcmV0dXJuIHRydWUuXG4gICAgICovXG4gICAgY29udGFpbnNQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gUmFuZ2UuY29udGFpbnNQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYHBvc2l0aW9uYCBpcyBpbiBgcmFuZ2VgLiBJZiB0aGUgcG9zaXRpb24gaXMgYXQgdGhlIGVkZ2VzLCB3aWxsIHJldHVybiB0cnVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb250YWluc1Bvc2l0aW9uKHJhbmdlLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlciB8fCBwb3NpdGlvbi5saW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lTnVtYmVyID09PSByYW5nZS5zdGFydExpbmVOdW1iZXIgJiYgcG9zaXRpb24uY29sdW1uIDwgcmFuZ2Uuc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlciAmJiBwb3NpdGlvbi5jb2x1bW4gPiByYW5nZS5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBgcG9zaXRpb25gIGlzIGluIGByYW5nZWAuIElmIHRoZSBwb3NpdGlvbiBpcyBhdCB0aGUgZWRnZXMsIHdpbGwgcmV0dXJuIGZhbHNlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpY3RDb250YWluc1Bvc2l0aW9uKHJhbmdlLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlciB8fCBwb3NpdGlvbi5saW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lTnVtYmVyID09PSByYW5nZS5zdGFydExpbmVOdW1iZXIgJiYgcG9zaXRpb24uY29sdW1uIDw9IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgcG9zaXRpb24uY29sdW1uID49IHJhbmdlLmVuZENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHJhbmdlIGlzIGluIHRoaXMgcmFuZ2UuIElmIHRoZSByYW5nZSBpcyBlcXVhbCB0byB0aGlzIHJhbmdlLCB3aWxsIHJldHVybiB0cnVlLlxuICAgICAqL1xuICAgIGNvbnRhaW5zUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmNvbnRhaW5zUmFuZ2UodGhpcywgcmFuZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGBvdGhlclJhbmdlYCBpcyBpbiBgcmFuZ2VgLiBJZiB0aGUgcmFuZ2VzIGFyZSBlcXVhbCwgd2lsbCByZXR1cm4gdHJ1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udGFpbnNSYW5nZShyYW5nZSwgb3RoZXJSYW5nZSkge1xuICAgICAgICBpZiAob3RoZXJSYW5nZS5zdGFydExpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIgfHwgb3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlciB8fCBvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPiByYW5nZS5lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5zdGFydExpbmVOdW1iZXIgJiYgb3RoZXJSYW5nZS5zdGFydENvbHVtbiA8IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlciAmJiBvdGhlclJhbmdlLmVuZENvbHVtbiA+IHJhbmdlLmVuZENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGByYW5nZWAgaXMgc3RyaWN0bHkgaW4gdGhpcyByYW5nZS4gYHJhbmdlYCBtdXN0IHN0YXJ0IGFmdGVyIGFuZCBlbmQgYmVmb3JlIHRoaXMgcmFuZ2UgZm9yIHRoZSByZXN1bHQgdG8gYmUgdHJ1ZS5cbiAgICAgKi9cbiAgICBzdHJpY3RDb250YWluc1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5zdHJpY3RDb250YWluc1JhbmdlKHRoaXMsIHJhbmdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBgb3RoZXJSYW5nZWAgaXMgc3RyaWN0bHkgaW4gYHJhbmdlYCAobXVzdCBzdGFydCBhZnRlciwgYW5kIGVuZCBiZWZvcmUpLiBJZiB0aGUgcmFuZ2VzIGFyZSBlcXVhbCwgd2lsbCByZXR1cm4gZmFsc2UuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmljdENvbnRhaW5zUmFuZ2UocmFuZ2UsIG90aGVyUmFuZ2UpIHtcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIHx8IG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIgfHwgb3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIG90aGVyUmFuZ2Uuc3RhcnRDb2x1bW4gPD0gcmFuZ2Uuc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyICYmIG90aGVyUmFuZ2UuZW5kQ29sdW1uID49IHJhbmdlLmVuZENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJldW5pb24gb2YgdGhlIHR3byByYW5nZXMuXG4gICAgICogVGhlIHNtYWxsZXN0IHBvc2l0aW9uIHdpbGwgYmUgdXNlZCBhcyB0aGUgc3RhcnQgcG9pbnQsIGFuZCB0aGUgbGFyZ2VzdCBvbmUgYXMgdGhlIGVuZCBwb2ludC5cbiAgICAgKi9cbiAgICBwbHVzUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLnBsdXNSYW5nZSh0aGlzLCByYW5nZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmV1bmlvbiBvZiB0aGUgdHdvIHJhbmdlcy5cbiAgICAgKiBUaGUgc21hbGxlc3QgcG9zaXRpb24gd2lsbCBiZSB1c2VkIGFzIHRoZSBzdGFydCBwb2ludCwgYW5kIHRoZSBsYXJnZXN0IG9uZSBhcyB0aGUgZW5kIHBvaW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBwbHVzUmFuZ2UoYSwgYikge1xuICAgICAgICBsZXQgc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICBsZXQgc3RhcnRDb2x1bW47XG4gICAgICAgIGxldCBlbmRMaW5lTnVtYmVyO1xuICAgICAgICBsZXQgZW5kQ29sdW1uO1xuICAgICAgICBpZiAoYi5zdGFydExpbmVOdW1iZXIgPCBhLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IGIuc3RhcnRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5zdGFydExpbmVOdW1iZXIgPT09IGEuc3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBiLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gTWF0aC5taW4oYi5zdGFydENvbHVtbiwgYS5zdGFydENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBhLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gYS5zdGFydENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYi5lbmRMaW5lTnVtYmVyID4gYS5lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gYi5lbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgZW5kQ29sdW1uID0gYi5lbmRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5lbmRMaW5lTnVtYmVyID09PSBhLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBiLmVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICBlbmRDb2x1bW4gPSBNYXRoLm1heChiLmVuZENvbHVtbiwgYS5lbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kTGluZU51bWJlciA9IGEuZW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgIGVuZENvbHVtbiA9IGEuZW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByYW5nZXMuXG4gICAgICovXG4gICAgaW50ZXJzZWN0UmFuZ2VzKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5pbnRlcnNlY3RSYW5nZXModGhpcywgcmFuZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJhbmdlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ZXJzZWN0UmFuZ2VzKGEsIGIpIHtcbiAgICAgICAgbGV0IHJlc3VsdFN0YXJ0TGluZU51bWJlciA9IGEuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICBsZXQgcmVzdWx0U3RhcnRDb2x1bW4gPSBhLnN0YXJ0Q29sdW1uO1xuICAgICAgICBsZXQgcmVzdWx0RW5kTGluZU51bWJlciA9IGEuZW5kTGluZU51bWJlcjtcbiAgICAgICAgbGV0IHJlc3VsdEVuZENvbHVtbiA9IGEuZW5kQ29sdW1uO1xuICAgICAgICBjb25zdCBvdGhlclN0YXJ0TGluZU51bWJlciA9IGIuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICBjb25zdCBvdGhlclN0YXJ0Q29sdW1uID0gYi5zdGFydENvbHVtbjtcbiAgICAgICAgY29uc3Qgb3RoZXJFbmRMaW5lTnVtYmVyID0gYi5lbmRMaW5lTnVtYmVyO1xuICAgICAgICBjb25zdCBvdGhlckVuZENvbHVtbiA9IGIuZW5kQ29sdW1uO1xuICAgICAgICBpZiAocmVzdWx0U3RhcnRMaW5lTnVtYmVyIDwgb3RoZXJTdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdFN0YXJ0TGluZU51bWJlciA9IG90aGVyU3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgcmVzdWx0U3RhcnRDb2x1bW4gPSBvdGhlclN0YXJ0Q29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA9PT0gb3RoZXJTdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdFN0YXJ0Q29sdW1uID0gTWF0aC5tYXgocmVzdWx0U3RhcnRDb2x1bW4sIG90aGVyU3RhcnRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRFbmRMaW5lTnVtYmVyID4gb3RoZXJFbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXN1bHRFbmRMaW5lTnVtYmVyID0gb3RoZXJFbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgcmVzdWx0RW5kQ29sdW1uID0gb3RoZXJFbmRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0RW5kTGluZU51bWJlciA9PT0gb3RoZXJFbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXN1bHRFbmRDb2x1bW4gPSBNYXRoLm1pbihyZXN1bHRFbmRDb2x1bW4sIG90aGVyRW5kQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBzZWxlY3Rpb24gaXMgbm93IGVtcHR5XG4gICAgICAgIGlmIChyZXN1bHRTdGFydExpbmVOdW1iZXIgPiByZXN1bHRFbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0U3RhcnRMaW5lTnVtYmVyID09PSByZXN1bHRFbmRMaW5lTnVtYmVyICYmIHJlc3VsdFN0YXJ0Q29sdW1uID4gcmVzdWx0RW5kQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJlc3VsdFN0YXJ0TGluZU51bWJlciwgcmVzdWx0U3RhcnRDb2x1bW4sIHJlc3VsdEVuZExpbmVOdW1iZXIsIHJlc3VsdEVuZENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhpcyByYW5nZSBlcXVhbHMgb3RoZXIuXG4gICAgICovXG4gICAgZXF1YWxzUmFuZ2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmVxdWFsc1JhbmdlKHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiByYW5nZSBgYWAgZXF1YWxzIGBiYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZXF1YWxzUmFuZ2UoYSwgYikge1xuICAgICAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoISFhICYmXG4gICAgICAgICAgICAhIWIgJiZcbiAgICAgICAgICAgIGEuc3RhcnRMaW5lTnVtYmVyID09PSBiLnN0YXJ0TGluZU51bWJlciAmJlxuICAgICAgICAgICAgYS5zdGFydENvbHVtbiA9PT0gYi5zdGFydENvbHVtbiAmJlxuICAgICAgICAgICAgYS5lbmRMaW5lTnVtYmVyID09PSBiLmVuZExpbmVOdW1iZXIgJiZcbiAgICAgICAgICAgIGEuZW5kQ29sdW1uID09PSBiLmVuZENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZW5kIHBvc2l0aW9uICh3aGljaCB3aWxsIGJlIGFmdGVyIG9yIGVxdWFsIHRvIHRoZSBzdGFydCBwb3NpdGlvbilcbiAgICAgKi9cbiAgICBnZXRFbmRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmdldEVuZFBvc2l0aW9uKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVuZCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBhZnRlciBvciBlcXVhbCB0byB0aGUgc3RhcnQgcG9zaXRpb24pXG4gICAgICovXG4gICAgc3RhdGljIGdldEVuZFBvc2l0aW9uKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzdGFydCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGVuZCBwb3NpdGlvbilcbiAgICAgKi9cbiAgICBnZXRTdGFydFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzdGFydCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGVuZCBwb3NpdGlvbilcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U3RhcnRQb3NpdGlvbihyYW5nZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdG8gYSB1c2VyIHByZXNlbnRhYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICdbJyArIHRoaXMuc3RhcnRMaW5lTnVtYmVyICsgJywnICsgdGhpcy5zdGFydENvbHVtbiArICcgLT4gJyArIHRoaXMuZW5kTGluZU51bWJlciArICcsJyArIHRoaXMuZW5kQ29sdW1uICsgJ10nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLCBhbmQgdXNpbmcgZW5kTGluZU51bWJlciBhbmQgZW5kQ29sdW1uIGFzIHRoZSBlbmQgcG9zaXRpb24uXG4gICAgICovXG4gICAgc2V0RW5kUG9zaXRpb24oZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3MgZW5kIHBvc2l0aW9uLCBhbmQgdXNpbmcgc3RhcnRMaW5lTnVtYmVyIGFuZCBzdGFydENvbHVtbiBhcyB0aGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgc2V0U3RhcnRQb3NpdGlvbihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgdGhpcy5lbmRMaW5lTnVtYmVyLCB0aGlzLmVuZENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBlbXB0eSByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgY29sbGFwc2VUb1N0YXJ0KCkge1xuICAgICAgICByZXR1cm4gUmFuZ2UuY29sbGFwc2VUb1N0YXJ0KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZW1wdHkgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb2xsYXBzZVRvU3RhcnQocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uLCByYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGVtcHR5IHJhbmdlIHVzaW5nIHRoaXMgcmFuZ2UncyBlbmQgcG9zaXRpb24uXG4gICAgICovXG4gICAgY29sbGFwc2VUb0VuZCgpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmNvbGxhcHNlVG9FbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBlbXB0eSByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3MgZW5kIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb2xsYXBzZVRvRW5kKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uLCByYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgcmFuZ2UgYnkgdGhlIGdpdmVuIGFtb3VudCBvZiBsaW5lcy5cbiAgICAgKi9cbiAgICBkZWx0YShsaW5lQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0TGluZU51bWJlciArIGxpbmVDb3VudCwgdGhpcy5zdGFydENvbHVtbiwgdGhpcy5lbmRMaW5lTnVtYmVyICsgbGluZUNvdW50LCB0aGlzLmVuZENvbHVtbik7XG4gICAgfVxuICAgIC8vIC0tLVxuICAgIHN0YXRpYyBmcm9tUG9zaXRpb25zKHN0YXJ0LCBlbmQgPSBzdGFydCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LmxpbmVOdW1iZXIsIHN0YXJ0LmNvbHVtbiwgZW5kLmxpbmVOdW1iZXIsIGVuZC5jb2x1bW4pO1xuICAgIH1cbiAgICBzdGF0aWMgbGlmdChyYW5nZSkge1xuICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4sIHJhbmdlLmVuZExpbmVOdW1iZXIsIHJhbmdlLmVuZENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYG9iamAgaXMgYW4gYElSYW5nZWAuXG4gICAgICovXG4gICAgc3RhdGljIGlzSVJhbmdlKG9iaikge1xuICAgICAgICByZXR1cm4gKG9ialxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc3RhcnRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLnN0YXJ0Q29sdW1uID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLmVuZExpbmVOdW1iZXIgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouZW5kQ29sdW1uID09PSAnbnVtYmVyJykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoZSB0d28gcmFuZ2VzIGFyZSB0b3VjaGluZyBpbiBhbnkgd2F5LlxuICAgICAqL1xuICAgIHN0YXRpYyBhcmVJbnRlcnNlY3RpbmdPclRvdWNoaW5nKGEsIGIpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYGFgIGlzIGJlZm9yZSBgYmBcbiAgICAgICAgaWYgKGEuZW5kTGluZU51bWJlciA8IGIuc3RhcnRMaW5lTnVtYmVyIHx8IChhLmVuZExpbmVOdW1iZXIgPT09IGIuc3RhcnRMaW5lTnVtYmVyICYmIGEuZW5kQ29sdW1uIDwgYi5zdGFydENvbHVtbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBgYmAgaXMgYmVmb3JlIGBhYFxuICAgICAgICBpZiAoYi5lbmRMaW5lTnVtYmVyIDwgYS5zdGFydExpbmVOdW1iZXIgfHwgKGIuZW5kTGluZU51bWJlciA9PT0gYS5zdGFydExpbmVOdW1iZXIgJiYgYi5lbmRDb2x1bW4gPCBhLnN0YXJ0Q29sdW1uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXNlIHJhbmdlcyBtdXN0IGludGVyc2VjdFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGUgdHdvIHJhbmdlcyBhcmUgaW50ZXJzZWN0aW5nLiBJZiB0aGUgcmFuZ2VzIGFyZSB0b3VjaGluZyBpdCByZXR1cm5zIHRydWUuXG4gICAgICovXG4gICAgc3RhdGljIGFyZUludGVyc2VjdGluZyhhLCBiKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGBhYCBpcyBiZWZvcmUgYGJgXG4gICAgICAgIGlmIChhLmVuZExpbmVOdW1iZXIgPCBiLnN0YXJ0TGluZU51bWJlciB8fCAoYS5lbmRMaW5lTnVtYmVyID09PSBiLnN0YXJ0TGluZU51bWJlciAmJiBhLmVuZENvbHVtbiA8PSBiLnN0YXJ0Q29sdW1uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIGBiYCBpcyBiZWZvcmUgYGFgXG4gICAgICAgIGlmIChiLmVuZExpbmVOdW1iZXIgPCBhLnN0YXJ0TGluZU51bWJlciB8fCAoYi5lbmRMaW5lTnVtYmVyID09PSBhLnN0YXJ0TGluZU51bWJlciAmJiBiLmVuZENvbHVtbiA8PSBhLnN0YXJ0Q29sdW1uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXNlIHJhbmdlcyBtdXN0IGludGVyc2VjdFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHJhbmdlcywgdXNlZnVsIGZvciBzb3J0aW5nIHJhbmdlc1xuICAgICAqIEl0IHdpbGwgZmlyc3QgY29tcGFyZSByYW5nZXMgb24gdGhlIHN0YXJ0UG9zaXRpb24gYW5kIHRoZW4gb24gdGhlIGVuZFBvc2l0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVSYW5nZXNVc2luZ1N0YXJ0cyhhLCBiKSB7XG4gICAgICAgIGlmIChhICYmIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFTdGFydExpbmVOdW1iZXIgPSBhLnN0YXJ0TGluZU51bWJlciB8IDA7XG4gICAgICAgICAgICBjb25zdCBiU3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXIgfCAwO1xuICAgICAgICAgICAgaWYgKGFTdGFydExpbmVOdW1iZXIgPT09IGJTdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhU3RhcnRDb2x1bW4gPSBhLnN0YXJ0Q29sdW1uIHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCBiU3RhcnRDb2x1bW4gPSBiLnN0YXJ0Q29sdW1uIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoYVN0YXJ0Q29sdW1uID09PSBiU3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYUVuZExpbmVOdW1iZXIgPSBhLmVuZExpbmVOdW1iZXIgfCAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiRW5kTGluZU51bWJlciA9IGIuZW5kTGluZU51bWJlciB8IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhRW5kTGluZU51bWJlciA9PT0gYkVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFFbmRDb2x1bW4gPSBhLmVuZENvbHVtbiB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiRW5kQ29sdW1uID0gYi5lbmRDb2x1bW4gfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFFbmRDb2x1bW4gLSBiRW5kQ29sdW1uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhRW5kTGluZU51bWJlciAtIGJFbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYVN0YXJ0Q29sdW1uIC0gYlN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFTdGFydExpbmVOdW1iZXIgLSBiU3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFFeGlzdHMgPSAoYSA/IDEgOiAwKTtcbiAgICAgICAgY29uc3QgYkV4aXN0cyA9IChiID8gMSA6IDApO1xuICAgICAgICByZXR1cm4gYUV4aXN0cyAtIGJFeGlzdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBjb21wYXJlcyByYW5nZXMsIHVzZWZ1bCBmb3Igc29ydGluZyByYW5nZXNcbiAgICAgKiBJdCB3aWxsIGZpcnN0IGNvbXBhcmUgcmFuZ2VzIG9uIHRoZSBlbmRQb3NpdGlvbiBhbmQgdGhlbiBvbiB0aGUgc3RhcnRQb3NpdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlUmFuZ2VzVXNpbmdFbmRzKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZW5kTGluZU51bWJlciA9PT0gYi5lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoYS5lbmRDb2x1bW4gPT09IGIuZW5kQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEuc3RhcnRMaW5lTnVtYmVyID09PSBiLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydENvbHVtbiAtIGIuc3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0TGluZU51bWJlciAtIGIuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEuZW5kQ29sdW1uIC0gYi5lbmRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuZW5kTGluZU51bWJlciAtIGIuZW5kTGluZU51bWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGUgcmFuZ2Ugc3BhbnMgbXVsdGlwbGUgbGluZXMuXG4gICAgICovXG4gICAgc3RhdGljIHNwYW5zTXVsdGlwbGVMaW5lcyhyYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2UuZW5kTGluZU51bWJlciA+IHJhbmdlLnN0YXJ0TGluZU51bWJlcjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi9wb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4vcmFuZ2UuanMnO1xuLyoqXG4gKiBBIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yLlxuICogVGhlIHNlbGVjdGlvbiBpcyBhIHJhbmdlIHRoYXQgaGFzIGFuIG9yaWVudGF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uIGV4dGVuZHMgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdGlvblN0YXJ0TGluZU51bWJlciwgc2VsZWN0aW9uU3RhcnRDb2x1bW4sIHBvc2l0aW9uTGluZU51bWJlciwgcG9zaXRpb25Db2x1bW4pIHtcbiAgICAgICAgc3VwZXIoc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCBzZWxlY3Rpb25TdGFydENvbHVtbiwgcG9zaXRpb25MaW5lTnVtYmVyLCBwb3NpdGlvbkNvbHVtbik7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyID0gc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0Q29sdW1uID0gc2VsZWN0aW9uU3RhcnRDb2x1bW47XG4gICAgICAgIHRoaXMucG9zaXRpb25MaW5lTnVtYmVyID0gcG9zaXRpb25MaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLnBvc2l0aW9uQ29sdW1uID0gcG9zaXRpb25Db2x1bW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0byBhIGh1bWFuLXJlYWRhYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ1snICsgdGhpcy5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgKyAnLCcgKyB0aGlzLnNlbGVjdGlvblN0YXJ0Q29sdW1uICsgJyAtPiAnICsgdGhpcy5wb3NpdGlvbkxpbmVOdW1iZXIgKyAnLCcgKyB0aGlzLnBvc2l0aW9uQ29sdW1uICsgJ10nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGVxdWFscyBvdGhlciBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgZXF1YWxzU2VsZWN0aW9uKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAoU2VsZWN0aW9uLnNlbGVjdGlvbnNFcXVhbCh0aGlzLCBvdGhlcikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoZSB0d28gc2VsZWN0aW9ucyBhcmUgZXF1YWwuXG4gICAgICovXG4gICAgc3RhdGljIHNlbGVjdGlvbnNFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYS5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgPT09IGIuc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyICYmXG4gICAgICAgICAgICBhLnNlbGVjdGlvblN0YXJ0Q29sdW1uID09PSBiLnNlbGVjdGlvblN0YXJ0Q29sdW1uICYmXG4gICAgICAgICAgICBhLnBvc2l0aW9uTGluZU51bWJlciA9PT0gYi5wb3NpdGlvbkxpbmVOdW1iZXIgJiZcbiAgICAgICAgICAgIGEucG9zaXRpb25Db2x1bW4gPT09IGIucG9zaXRpb25Db2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZGlyZWN0aW9ucyAoTFRSIG9yIFJUTCkuXG4gICAgICovXG4gICAgZ2V0RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgPT09IHRoaXMuc3RhcnRMaW5lTnVtYmVyICYmIHRoaXMuc2VsZWN0aW9uU3RhcnRDb2x1bW4gPT09IHRoaXMuc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIFNlbGVjdGlvbkRpcmVjdGlvbi5MVFIgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDEgLyogU2VsZWN0aW9uRGlyZWN0aW9uLlJUTCAqLztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlbGVjdGlvbiB3aXRoIGEgZGlmZmVyZW50IGBwb3NpdGlvbkxpbmVOdW1iZXJgIGFuZCBgcG9zaXRpb25Db2x1bW5gLlxuICAgICAqL1xuICAgIHNldEVuZFBvc2l0aW9uKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24oKSA9PT0gMCAvKiBTZWxlY3Rpb25EaXJlY3Rpb24uTFRSICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLnN0YXJ0TGluZU51bWJlciwgdGhpcy5zdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4sIHRoaXMuc3RhcnRMaW5lTnVtYmVyLCB0aGlzLnN0YXJ0Q29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb3NpdGlvbiBhdCBgcG9zaXRpb25MaW5lTnVtYmVyYCBhbmQgYHBvc2l0aW9uQ29sdW1uYC5cbiAgICAgKi9cbiAgICBnZXRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLnBvc2l0aW9uTGluZU51bWJlciwgdGhpcy5wb3NpdGlvbkNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBnZXRTZWxlY3Rpb25TdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciwgdGhpcy5zZWxlY3Rpb25TdGFydENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzZWxlY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBgc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyYCBhbmQgYHNlbGVjdGlvblN0YXJ0Q29sdW1uYC5cbiAgICAgKi9cbiAgICBzZXRTdGFydFBvc2l0aW9uKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0RGlyZWN0aW9uKCkgPT09IDAgLyogU2VsZWN0aW9uRGlyZWN0aW9uLkxUUiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgdGhpcy5lbmRMaW5lTnVtYmVyLCB0aGlzLmVuZENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5lbmRMaW5lTnVtYmVyLCB0aGlzLmVuZENvbHVtbiwgc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbik7XG4gICAgfVxuICAgIC8vIC0tLS1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBmcm9tIG9uZSBvciB0d28gcG9zaXRpb25zXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Qb3NpdGlvbnMoc3RhcnQsIGVuZCA9IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHN0YXJ0LmxpbmVOdW1iZXIsIHN0YXJ0LmNvbHVtbiwgZW5kLmxpbmVOdW1iZXIsIGVuZC5jb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYFNlbGVjdGlvbmAgZnJvbSBhIHJhbmdlLCBnaXZlbiBhIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVJhbmdlKHJhbmdlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMCAvKiBTZWxlY3Rpb25EaXJlY3Rpb24uTFRSICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uLCByYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ocmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uLCByYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBmcm9tIGFuIGBJU2VsZWN0aW9uYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGlmdFNlbGVjdGlvbihzZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc2VsLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciwgc2VsLnNlbGVjdGlvblN0YXJ0Q29sdW1uLCBzZWwucG9zaXRpb25MaW5lTnVtYmVyLCBzZWwucG9zaXRpb25Db2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgYWAgZXF1YWxzIGBiYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2VsZWN0aW9uc0FyckVxdWFsKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgJiYgIWIgfHwgIWEgJiYgYikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uc0VxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGBvYmpgIGlzIGFuIGBJU2VsZWN0aW9uYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNJU2VsZWN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gKG9ialxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLnNlbGVjdGlvblN0YXJ0Q29sdW1uID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLnBvc2l0aW9uTGluZU51bWJlciA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5wb3NpdGlvbkNvbHVtbiA9PT0gJ251bWJlcicpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHdpdGggYSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVdpdGhEaXJlY3Rpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMCAvKiBTZWxlY3Rpb25EaXJlY3Rpb24uTFRSICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbiwgc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbik7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBhc3NlcnRGbiwgY2hlY2tBZGphY2VudEl0ZW1zIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vYXNzZXJ0LmpzJztcbmltcG9ydCB7IEJ1Z0luZGljYXRpbmdFcnJvciB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4vcG9zaXRpb24uanMnO1xuaW1wb3J0IHsgUG9zaXRpb25PZmZzZXRUcmFuc2Zvcm1lciB9IGZyb20gJy4vcG9zaXRpb25Ub09mZnNldC5qcyc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4vcmFuZ2UuanMnO1xuaW1wb3J0IHsgVGV4dExlbmd0aCB9IGZyb20gJy4vdGV4dExlbmd0aC5qcyc7XG5leHBvcnQgY2xhc3MgVGV4dEVkaXQge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRzKSB7XG4gICAgICAgIHRoaXMuZWRpdHMgPSBlZGl0cztcbiAgICAgICAgYXNzZXJ0Rm4oKCkgPT4gY2hlY2tBZGphY2VudEl0ZW1zKGVkaXRzLCAoYSwgYikgPT4gYS5yYW5nZS5nZXRFbmRQb3NpdGlvbigpLmlzQmVmb3JlT3JFcXVhbChiLnJhbmdlLmdldFN0YXJ0UG9zaXRpb24oKSkpKTtcbiAgICB9XG4gICAgYXBwbHkodGV4dCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGxldCBsYXN0RWRpdEVuZCA9IG5ldyBQb3NpdGlvbigxLCAxKTtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0IG9mIHRoaXMuZWRpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRSYW5nZSA9IGVkaXQucmFuZ2U7XG4gICAgICAgICAgICBjb25zdCBlZGl0U3RhcnQgPSBlZGl0UmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgZWRpdEVuZCA9IGVkaXRSYW5nZS5nZXRFbmRQb3NpdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgciA9IHJhbmdlRnJvbVBvc2l0aW9ucyhsYXN0RWRpdEVuZCwgZWRpdFN0YXJ0KTtcbiAgICAgICAgICAgIGlmICghci5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5nZXRWYWx1ZU9mUmFuZ2Uocik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gZWRpdC50ZXh0O1xuICAgICAgICAgICAgbGFzdEVkaXRFbmQgPSBlZGl0RW5kO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSByYW5nZUZyb21Qb3NpdGlvbnMobGFzdEVkaXRFbmQsIHRleHQuZW5kUG9zaXRpb25FeGNsdXNpdmUpO1xuICAgICAgICBpZiAoIXIuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5nZXRWYWx1ZU9mUmFuZ2Uocik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXBwbHlUb1N0cmluZyhzdHIpIHtcbiAgICAgICAgY29uc3Qgc3RyVGV4dCA9IG5ldyBTdHJpbmdUZXh0KHN0cik7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5KHN0clRleHQpO1xuICAgIH1cbiAgICBnZXROZXdSYW5nZXMoKSB7XG4gICAgICAgIGNvbnN0IG5ld1JhbmdlcyA9IFtdO1xuICAgICAgICBsZXQgcHJldmlvdXNFZGl0RW5kTGluZU51bWJlciA9IDA7XG4gICAgICAgIGxldCBsaW5lT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGNvbHVtbk9mZnNldCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdCBvZiB0aGlzLmVkaXRzKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0TGVuZ3RoID0gVGV4dExlbmd0aC5vZlRleHQoZWRpdC50ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JhbmdlU3RhcnQgPSBQb3NpdGlvbi5saWZ0KHtcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBlZGl0LnJhbmdlLnN0YXJ0TGluZU51bWJlciArIGxpbmVPZmZzZXQsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBlZGl0LnJhbmdlLnN0YXJ0Q29sdW1uICsgKGVkaXQucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSBwcmV2aW91c0VkaXRFbmRMaW5lTnVtYmVyID8gY29sdW1uT2Zmc2V0IDogMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV3UmFuZ2UgPSB0ZXh0TGVuZ3RoLmNyZWF0ZVJhbmdlKG5ld1JhbmdlU3RhcnQpO1xuICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2gobmV3UmFuZ2UpO1xuICAgICAgICAgICAgbGluZU9mZnNldCA9IG5ld1JhbmdlLmVuZExpbmVOdW1iZXIgLSBlZGl0LnJhbmdlLmVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICBjb2x1bW5PZmZzZXQgPSBuZXdSYW5nZS5lbmRDb2x1bW4gLSBlZGl0LnJhbmdlLmVuZENvbHVtbjtcbiAgICAgICAgICAgIHByZXZpb3VzRWRpdEVuZExpbmVOdW1iZXIgPSBlZGl0LnJhbmdlLmVuZExpbmVOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1JhbmdlcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU2luZ2xlVGV4dEVkaXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgdG9TaW5nbGVFZGl0T3BlcmF0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2U6IHRoaXMucmFuZ2UsXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gcmFuZ2VGcm9tUG9zaXRpb25zKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoc3RhcnQubGluZU51bWJlciA9PT0gZW5kLmxpbmVOdW1iZXIgJiYgc3RhcnQuY29sdW1uID09PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvc2l0aW9ucyhlbmQsIGVuZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzdGFydC5pc0JlZm9yZU9yRXF1YWwoZW5kKSkge1xuICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKCdzdGFydCBtdXN0IGJlIGJlZm9yZSBlbmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydC5saW5lTnVtYmVyLCBzdGFydC5jb2x1bW4sIGVuZC5saW5lTnVtYmVyLCBlbmQuY29sdW1uKTtcbn1cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFRleHQge1xuICAgIGdldCBlbmRQb3NpdGlvbkV4Y2x1c2l2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoLmFkZFRvUG9zaXRpb24obmV3IFBvc2l0aW9uKDEsIDEpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3RyaW5nVGV4dCBleHRlbmRzIEFic3RyYWN0VGV4dCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl90ID0gbmV3IFBvc2l0aW9uT2Zmc2V0VHJhbnNmb3JtZXIodGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIGdldFZhbHVlT2ZSYW5nZShyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdC5nZXRPZmZzZXRSYW5nZShyYW5nZSkuc3Vic3RyaW5nKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdC50ZXh0TGVuZ3RoO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi9yYW5nZS5qcyc7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBub24tbmVnYXRpdmUgbGVuZ3RoIG9mIHRleHQgaW4gdGVybXMgb2YgbGluZSBhbmQgY29sdW1uIGNvdW50LlxuKi9cbmV4cG9ydCBjbGFzcyBUZXh0TGVuZ3RoIHtcbiAgICBzdGF0aWMgeyB0aGlzLnplcm8gPSBuZXcgVGV4dExlbmd0aCgwLCAwKTsgfVxuICAgIHN0YXRpYyBiZXR3ZWVuUG9zaXRpb25zKHBvc2l0aW9uMSwgcG9zaXRpb24yKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbjEubGluZU51bWJlciA9PT0gcG9zaXRpb24yLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlbmd0aCgwLCBwb3NpdGlvbjIuY29sdW1uIC0gcG9zaXRpb24xLmNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZW5ndGgocG9zaXRpb24yLmxpbmVOdW1iZXIgLSBwb3NpdGlvbjEubGluZU51bWJlciwgcG9zaXRpb24yLmNvbHVtbiAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBvZlJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBUZXh0TGVuZ3RoLmJldHdlZW5Qb3NpdGlvbnMocmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbigpLCByYW5nZS5nZXRFbmRQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgc3RhdGljIG9mVGV4dCh0ZXh0KSB7XG4gICAgICAgIGxldCBsaW5lID0gMDtcbiAgICAgICAgbGV0IGNvbHVtbiA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0ZXh0KSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbHVtbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGV4dExlbmd0aChsaW5lLCBjb2x1bW4pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihsaW5lQ291bnQsIGNvbHVtbkNvdW50KSB7XG4gICAgICAgIHRoaXMubGluZUNvdW50ID0gbGluZUNvdW50O1xuICAgICAgICB0aGlzLmNvbHVtbkNvdW50ID0gY29sdW1uQ291bnQ7XG4gICAgfVxuICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8ob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZUNvdW50ICE9PSBvdGhlci5saW5lQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVDb3VudCA+IG90aGVyLmxpbmVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5Db3VudCA+PSBvdGhlci5jb2x1bW5Db3VudDtcbiAgICB9XG4gICAgY3JlYXRlUmFuZ2Uoc3RhcnRQb3NpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5saW5lQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRQb3NpdGlvbi5saW5lTnVtYmVyLCBzdGFydFBvc2l0aW9uLmNvbHVtbiwgc3RhcnRQb3NpdGlvbi5saW5lTnVtYmVyLCBzdGFydFBvc2l0aW9uLmNvbHVtbiArIHRoaXMuY29sdW1uQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydFBvc2l0aW9uLmxpbmVOdW1iZXIsIHN0YXJ0UG9zaXRpb24uY29sdW1uLCBzdGFydFBvc2l0aW9uLmxpbmVOdW1iZXIgKyB0aGlzLmxpbmVDb3VudCwgdGhpcy5jb2x1bW5Db3VudCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRvUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMubGluZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHBvc2l0aW9uLmxpbmVOdW1iZXIsIHBvc2l0aW9uLmNvbHVtbiArIHRoaXMuY29sdW1uQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihwb3NpdGlvbi5saW5lTnVtYmVyICsgdGhpcy5saW5lQ291bnQsIHRoaXMuY29sdW1uQ291bnQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGluZUNvdW50fSwke3RoaXMuY29sdW1uQ291bnR9YDtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IExSVUNhY2hlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IENoYXJhY3RlckNsYXNzaWZpZXIgfSBmcm9tICcuL2NoYXJhY3RlckNsYXNzaWZpZXIuanMnO1xuZXhwb3J0IGNsYXNzIFdvcmRDaGFyYWN0ZXJDbGFzc2lmaWVyIGV4dGVuZHMgQ2hhcmFjdGVyQ2xhc3NpZmllciB7XG4gICAgY29uc3RydWN0b3Iod29yZFNlcGFyYXRvcnMsIGludGxTZWdtZW50ZXJMb2NhbGVzKSB7XG4gICAgICAgIHN1cGVyKDAgLyogV29yZENoYXJhY3RlckNsYXNzLlJlZ3VsYXIgKi8pO1xuICAgICAgICB0aGlzLl9zZWdtZW50ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWNoZWRMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FjaGVkU2VnbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnRsU2VnbWVudGVyTG9jYWxlcyA9IGludGxTZWdtZW50ZXJMb2NhbGVzO1xuICAgICAgICBpZiAodGhpcy5pbnRsU2VnbWVudGVyTG9jYWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50ZXIgPSBuZXcgSW50bC5TZWdtZW50ZXIodGhpcy5pbnRsU2VnbWVudGVyTG9jYWxlcywgeyBncmFudWxhcml0eTogJ3dvcmQnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2VnbWVudGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gd29yZFNlcGFyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KHdvcmRTZXBhcmF0b3JzLmNoYXJDb2RlQXQoaSksIDIgLyogV29yZENoYXJhY3RlckNsYXNzLldvcmRTZXBhcmF0b3IgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KDMyIC8qIENoYXJDb2RlLlNwYWNlICovLCAxIC8qIFdvcmRDaGFyYWN0ZXJDbGFzcy5XaGl0ZXNwYWNlICovKTtcbiAgICAgICAgdGhpcy5zZXQoOSAvKiBDaGFyQ29kZS5UYWIgKi8sIDEgLyogV29yZENoYXJhY3RlckNsYXNzLldoaXRlc3BhY2UgKi8pO1xuICAgIH1cbiAgICBmaW5kUHJldkludGxXb3JkQmVmb3JlT3JBdE9mZnNldChsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiB0aGlzLl9nZXRJbnRsU2VnbWVudGVyV29yZHNPbkxpbmUobGluZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWdtZW50LmluZGV4ID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBzZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfVxuICAgIGZpbmROZXh0SW50bFdvcmRBdE9yQWZ0ZXJPZmZzZXQobGluZUNvbnRlbnQsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgdGhpcy5fZ2V0SW50bFNlZ21lbnRlcldvcmRzT25MaW5lKGxpbmVDb250ZW50KSkge1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfZ2V0SW50bFNlZ21lbnRlcldvcmRzT25MaW5lKGxpbmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZWdtZW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbGluZSBoYXMgY2hhbmdlZCBmcm9tIHRoZSBwcmV2aW91cyBjYWxsXG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWRMaW5lID09PSBsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkU2VnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgbGluZVxuICAgICAgICB0aGlzLl9jYWNoZWRMaW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5fY2FjaGVkU2VnbWVudHMgPSB0aGlzLl9maWx0ZXJXb3JkU2VnbWVudHModGhpcy5fc2VnbWVudGVyLnNlZ21lbnQobGluZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkU2VnbWVudHM7XG4gICAgfVxuICAgIF9maWx0ZXJXb3JkU2VnbWVudHMoc2VnbWVudHMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzV29yZExpa2Uoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfaXNXb3JkTGlrZShzZWdtZW50KSB7XG4gICAgICAgIGlmIChzZWdtZW50LmlzV29yZExpa2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCB3b3JkQ2xhc3NpZmllckNhY2hlID0gbmV3IExSVUNhY2hlKDEwKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBGb3JXb3JkU2VwYXJhdG9ycyh3b3JkU2VwYXJhdG9ycywgaW50bFNlZ21lbnRlckxvY2FsZXMpIHtcbiAgICBjb25zdCBrZXkgPSBgJHt3b3JkU2VwYXJhdG9yc30vJHtpbnRsU2VnbWVudGVyTG9jYWxlcy5qb2luKCcsJyl9YDtcbiAgICBsZXQgcmVzdWx0ID0gd29yZENsYXNzaWZpZXJDYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXN1bHQgPSBuZXcgV29yZENoYXJhY3RlckNsYXNzaWZpZXIod29yZFNlcGFyYXRvcnMsIGludGxTZWdtZW50ZXJMb2NhbGVzKTtcbiAgICAgICAgd29yZENsYXNzaWZpZXJDYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBJdGVyYWJsZSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2l0ZXJhdG9yLmpzJztcbmltcG9ydCB7IExpbmtlZExpc3QgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9saW5rZWRMaXN0LmpzJztcbmV4cG9ydCBjb25zdCBVU1VBTF9XT1JEX1NFUEFSQVRPUlMgPSAnYH4hQCMkJV4mKigpLT0rW3tdfVxcXFx8OzpcXCdcIiwuPD4vPyc7XG4vKipcbiAqIENyZWF0ZSBhIHdvcmQgZGVmaW5pdGlvbiByZWd1bGFyIGV4cHJlc3Npb24gYmFzZWQgb24gZGVmYXVsdCB3b3JkIHNlcGFyYXRvcnMuXG4gKiBPcHRpb25hbGx5IHByb3ZpZGUgYWxsb3dlZCBzZXBhcmF0b3JzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHdvcmRzLlxuICpcbiAqIFRoZSBkZWZhdWx0IHdvdWxkIGxvb2sgbGlrZSB0aGlzOlxuICogLygtP1xcZCpcXC5cXGRcXHcqKXwoW15cXGBcXH5cXCFcXEBcXCNcXCRcXCVcXF5cXCZcXCpcXChcXClcXC1cXD1cXCtcXFtcXHtcXF1cXH1cXFxcXFx8XFw7XFw6XFwnXFxcIlxcLFxcLlxcPFxcPlxcL1xcP1xcc10rKS9nXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdvcmRSZWdFeHAoYWxsb3dJbldvcmRzID0gJycpIHtcbiAgICBsZXQgc291cmNlID0gJygtP1xcXFxkKlxcXFwuXFxcXGRcXFxcdyopfChbXic7XG4gICAgZm9yIChjb25zdCBzZXAgb2YgVVNVQUxfV09SRF9TRVBBUkFUT1JTKSB7XG4gICAgICAgIGlmIChhbGxvd0luV29yZHMuaW5kZXhPZihzZXApID49IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSArPSAnXFxcXCcgKyBzZXA7XG4gICAgfVxuICAgIHNvdXJjZSArPSAnXFxcXHNdKyknO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbn1cbi8vIGNhdGNoZXMgbnVtYmVycyAoaW5jbHVkaW5nIGZsb2F0aW5nIG51bWJlcnMpIGluIHRoZSBmaXJzdCBncm91cCwgYW5kIGFscGhhbnVtIGluIHRoZSBzZWNvbmRcbmV4cG9ydCBjb25zdCBERUZBVUxUX1dPUkRfUkVHRVhQID0gY3JlYXRlV29yZFJlZ0V4cCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVZhbGlkV29yZERlZmluaXRpb24od29yZERlZmluaXRpb24pIHtcbiAgICBsZXQgcmVzdWx0ID0gREVGQVVMVF9XT1JEX1JFR0VYUDtcbiAgICBpZiAod29yZERlZmluaXRpb24gJiYgKHdvcmREZWZpbml0aW9uIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICBpZiAoIXdvcmREZWZpbml0aW9uLmdsb2JhbCkge1xuICAgICAgICAgICAgbGV0IGZsYWdzID0gJ2cnO1xuICAgICAgICAgICAgaWYgKHdvcmREZWZpbml0aW9uLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBmbGFncyArPSAnaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod29yZERlZmluaXRpb24ubXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ20nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdvcmREZWZpbml0aW9uLnVuaWNvZGUpIHtcbiAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHdvcmREZWZpbml0aW9uLnNvdXJjZSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gd29yZERlZmluaXRpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IF9kZWZhdWx0Q29uZmlnID0gbmV3IExpbmtlZExpc3QoKTtcbl9kZWZhdWx0Q29uZmlnLnVuc2hpZnQoe1xuICAgIG1heExlbjogMTAwMCxcbiAgICB3aW5kb3dTaXplOiAxNSxcbiAgICB0aW1lQnVkZ2V0OiAxNTBcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmRBdFRleHQoY29sdW1uLCB3b3JkRGVmaW5pdGlvbiwgdGV4dCwgdGV4dE9mZnNldCwgY29uZmlnKSB7XG4gICAgLy8gRW5zdXJlIHRoZSByZWdleCBoYXMgdGhlICdnJyBmbGFnLCBvdGhlcndpc2UgdGhpcyB3aWxsIGxvb3AgZm9yZXZlclxuICAgIHdvcmREZWZpbml0aW9uID0gZW5zdXJlVmFsaWRXb3JkRGVmaW5pdGlvbih3b3JkRGVmaW5pdGlvbik7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gSXRlcmFibGUuZmlyc3QoX2RlZmF1bHRDb25maWcpO1xuICAgIH1cbiAgICBpZiAodGV4dC5sZW5ndGggPiBjb25maWcubWF4TGVuKSB7XG4gICAgICAgIC8vIGRvbid0IHRocm93IHN0cmluZ3MgdGhhdCBsb25nIGF0IHRoZSByZWdleHBcbiAgICAgICAgLy8gYnV0IHVzZSBhIHN1Yi1zdHJpbmcgaW4gd2hpY2ggYSB3b3JkIG11c3Qgb2NjdXJcbiAgICAgICAgbGV0IHN0YXJ0ID0gY29sdW1uIC0gY29uZmlnLm1heExlbiAvIDI7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgKz0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBjb2x1bW4gKyBjb25maWcubWF4TGVuIC8gMik7XG4gICAgICAgIHJldHVybiBnZXRXb3JkQXRUZXh0KGNvbHVtbiwgd29yZERlZmluaXRpb24sIHRleHQsIHRleHRPZmZzZXQsIGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IHQxID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBwb3MgPSBjb2x1bW4gLSAxIC0gdGV4dE9mZnNldDtcbiAgICBsZXQgcHJldlJlZ2V4SW5kZXggPSAtMTtcbiAgICBsZXQgbWF0Y2ggPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAxOzsgaSsrKSB7XG4gICAgICAgIC8vIGNoZWNrIHRpbWUgYnVkZ2V0XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdDEgPj0gY29uZmlnLnRpbWVCdWRnZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2V0IHRoZSBpbmRleCBhdCB3aGljaCB0aGUgcmVnZXhwIHNob3VsZCBzdGFydCBtYXRjaGluZywgYWxzbyBrbm93IHdoZXJlIGl0XG4gICAgICAgIC8vIHNob3VsZCBzdG9wIHNvIHRoYXQgc3Vic2VxdWVudCBzZWFyY2ggZG9uJ3QgcmVwZWF0IHByZXZpb3VzIHNlYXJjaGVzXG4gICAgICAgIGNvbnN0IHJlZ2V4SW5kZXggPSBwb3MgLSBjb25maWcud2luZG93U2l6ZSAqIGk7XG4gICAgICAgIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA9IE1hdGgubWF4KDAsIHJlZ2V4SW5kZXgpO1xuICAgICAgICBjb25zdCB0aGlzTWF0Y2ggPSBfZmluZFJlZ2V4TWF0Y2hFbmNsb3NpbmdQb3NpdGlvbih3b3JkRGVmaW5pdGlvbiwgdGV4dCwgcG9zLCBwcmV2UmVnZXhJbmRleCk7XG4gICAgICAgIGlmICghdGhpc01hdGNoICYmIG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBzdG9wOiB3ZSBoYXZlIHNvbWV0aGluZ1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSB0aGlzTWF0Y2g7XG4gICAgICAgIC8vIHN0b3A6IHNlYXJjaGVkIGF0IHN0YXJ0XG4gICAgICAgIGlmIChyZWdleEluZGV4IDw9IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHByZXZSZWdleEluZGV4ID0gcmVnZXhJbmRleDtcbiAgICB9XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHdvcmQ6IG1hdGNoWzBdLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IHRleHRPZmZzZXQgKyAxICsgbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICBlbmRDb2x1bW46IHRleHRPZmZzZXQgKyAxICsgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgd29yZERlZmluaXRpb24ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfZmluZFJlZ2V4TWF0Y2hFbmNsb3NpbmdQb3NpdGlvbih3b3JkRGVmaW5pdGlvbiwgdGV4dCwgcG9zLCBzdG9wUG9zKSB7XG4gICAgbGV0IG1hdGNoO1xuICAgIHdoaWxlIChtYXRjaCA9IHdvcmREZWZpbml0aW9uLmV4ZWModGV4dCkpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hJbmRleCA9IG1hdGNoLmluZGV4IHx8IDA7XG4gICAgICAgIGlmIChtYXRjaEluZGV4IDw9IHBvcyAmJiB3b3JkRGVmaW5pdGlvbi5sYXN0SW5kZXggPj0gcG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RvcFBvcyA+IDAgJiYgbWF0Y2hJbmRleCA+IHN0b3BQb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBmb3JFYWNoQWRqYWNlbnQgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xuaW1wb3J0IHsgQnVnSW5kaWNhdGluZ0Vycm9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vZXJyb3JzLmpzJztcbmltcG9ydCB7IE9mZnNldFJhbmdlIH0gZnJvbSAnLi4vLi4vLi4vY29yZS9vZmZzZXRSYW5nZS5qcyc7XG5leHBvcnQgY2xhc3MgRGlmZkFsZ29yaXRobVJlc3VsdCB7XG4gICAgc3RhdGljIHRyaXZpYWwoc2VxMSwgc2VxMikge1xuICAgICAgICByZXR1cm4gbmV3IERpZmZBbGdvcml0aG1SZXN1bHQoW25ldyBTZXF1ZW5jZURpZmYoT2Zmc2V0UmFuZ2Uub2ZMZW5ndGgoc2VxMS5sZW5ndGgpLCBPZmZzZXRSYW5nZS5vZkxlbmd0aChzZXEyLmxlbmd0aCkpXSwgZmFsc2UpO1xuICAgIH1cbiAgICBzdGF0aWMgdHJpdmlhbFRpbWVkT3V0KHNlcTEsIHNlcTIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaWZmQWxnb3JpdGhtUmVzdWx0KFtuZXcgU2VxdWVuY2VEaWZmKE9mZnNldFJhbmdlLm9mTGVuZ3RoKHNlcTEubGVuZ3RoKSwgT2Zmc2V0UmFuZ2Uub2ZMZW5ndGgoc2VxMi5sZW5ndGgpKV0sIHRydWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkaWZmcywgXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSB0aW1lIG91dCB3YXMgcmVhY2hlZC5cbiAgICAgKiBJbiB0aGF0IGNhc2UsIHRoZSBkaWZmcyBtaWdodCBiZSBhbiBhcHByb3hpbWF0aW9uIGFuZCB0aGUgdXNlciBzaG91bGQgYmUgYXNrZWQgdG8gcmVydW4gdGhlIGRpZmYgd2l0aCBtb3JlIHRpbWUuXG4gICAgICovXG4gICAgaGl0VGltZW91dCkge1xuICAgICAgICB0aGlzLmRpZmZzID0gZGlmZnM7XG4gICAgICAgIHRoaXMuaGl0VGltZW91dCA9IGhpdFRpbWVvdXQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNlcXVlbmNlRGlmZiB7XG4gICAgc3RhdGljIGludmVydChzZXF1ZW5jZURpZmZzLCBkb2MxTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3JFYWNoQWRqYWNlbnQoc2VxdWVuY2VEaWZmcywgKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFNlcXVlbmNlRGlmZi5mcm9tT2Zmc2V0UGFpcnMoYSA/IGEuZ2V0RW5kRXhjbHVzaXZlcygpIDogT2Zmc2V0UGFpci56ZXJvLCBiID8gYi5nZXRTdGFydHMoKSA6IG5ldyBPZmZzZXRQYWlyKGRvYzFMZW5ndGgsIChhID8gYS5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlIC0gYS5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlIDogMCkgKyBkb2MxTGVuZ3RoKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PZmZzZXRQYWlycyhzdGFydCwgZW5kRXhjbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VEaWZmKG5ldyBPZmZzZXRSYW5nZShzdGFydC5vZmZzZXQxLCBlbmRFeGNsdXNpdmUub2Zmc2V0MSksIG5ldyBPZmZzZXRSYW5nZShzdGFydC5vZmZzZXQyLCBlbmRFeGNsdXNpdmUub2Zmc2V0MikpO1xuICAgIH1cbiAgICBzdGF0aWMgYXNzZXJ0U29ydGVkKHNlcXVlbmNlRGlmZnMpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY3VyIG9mIHNlcXVlbmNlRGlmZnMpIHtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobGFzdC5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlIDw9IGN1ci5zZXExUmFuZ2Uuc3RhcnQgJiYgbGFzdC5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlIDw9IGN1ci5zZXEyUmFuZ2Uuc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ1NlcXVlbmNlIGRpZmZzIG11c3QgYmUgc29ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdCA9IGN1cjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzZXExUmFuZ2UsIHNlcTJSYW5nZSkge1xuICAgICAgICB0aGlzLnNlcTFSYW5nZSA9IHNlcTFSYW5nZTtcbiAgICAgICAgdGhpcy5zZXEyUmFuZ2UgPSBzZXEyUmFuZ2U7XG4gICAgfVxuICAgIHN3YXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VEaWZmKHRoaXMuc2VxMlJhbmdlLCB0aGlzLnNlcTFSYW5nZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5zZXExUmFuZ2V9IDwtPiAke3RoaXMuc2VxMlJhbmdlfWA7XG4gICAgfVxuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZURpZmYodGhpcy5zZXExUmFuZ2Uuam9pbihvdGhlci5zZXExUmFuZ2UpLCB0aGlzLnNlcTJSYW5nZS5qb2luKG90aGVyLnNlcTJSYW5nZSkpO1xuICAgIH1cbiAgICBkZWx0YShvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZURpZmYodGhpcy5zZXExUmFuZ2UuZGVsdGEob2Zmc2V0KSwgdGhpcy5zZXEyUmFuZ2UuZGVsdGEob2Zmc2V0KSk7XG4gICAgfVxuICAgIGRlbHRhU3RhcnQob2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VEaWZmKHRoaXMuc2VxMVJhbmdlLmRlbHRhU3RhcnQob2Zmc2V0KSwgdGhpcy5zZXEyUmFuZ2UuZGVsdGFTdGFydChvZmZzZXQpKTtcbiAgICB9XG4gICAgZGVsdGFFbmQob2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VEaWZmKHRoaXMuc2VxMVJhbmdlLmRlbHRhRW5kKG9mZnNldCksIHRoaXMuc2VxMlJhbmdlLmRlbHRhRW5kKG9mZnNldCkpO1xuICAgIH1cbiAgICBpbnRlcnNlY3Qob3RoZXIpIHtcbiAgICAgICAgY29uc3QgaTEgPSB0aGlzLnNlcTFSYW5nZS5pbnRlcnNlY3Qob3RoZXIuc2VxMVJhbmdlKTtcbiAgICAgICAgY29uc3QgaTIgPSB0aGlzLnNlcTJSYW5nZS5pbnRlcnNlY3Qob3RoZXIuc2VxMlJhbmdlKTtcbiAgICAgICAgaWYgKCFpMSB8fCAhaTIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZURpZmYoaTEsIGkyKTtcbiAgICB9XG4gICAgZ2V0U3RhcnRzKCkge1xuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFBhaXIodGhpcy5zZXExUmFuZ2Uuc3RhcnQsIHRoaXMuc2VxMlJhbmdlLnN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0RW5kRXhjbHVzaXZlcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRQYWlyKHRoaXMuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSwgdGhpcy5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT2Zmc2V0UGFpciB7XG4gICAgc3RhdGljIHsgdGhpcy56ZXJvID0gbmV3IE9mZnNldFBhaXIoMCwgMCk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLm1heCA9IG5ldyBPZmZzZXRQYWlyKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7IH1cbiAgICBjb25zdHJ1Y3RvcihvZmZzZXQxLCBvZmZzZXQyKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0MSA9IG9mZnNldDE7XG4gICAgICAgIHRoaXMub2Zmc2V0MiA9IG9mZnNldDI7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5vZmZzZXQxfSA8LT4gJHt0aGlzLm9mZnNldDJ9YDtcbiAgICB9XG4gICAgZGVsdGEob2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UGFpcih0aGlzLm9mZnNldDEgKyBvZmZzZXQsIHRoaXMub2Zmc2V0MiArIG9mZnNldCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQxID09PSBvdGhlci5vZmZzZXQxICYmIHRoaXMub2Zmc2V0MiA9PT0gb3RoZXIub2Zmc2V0MjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW5maW5pdGVUaW1lb3V0IHtcbiAgICBzdGF0aWMgeyB0aGlzLmluc3RhbmNlID0gbmV3IEluZmluaXRlVGltZW91dCgpOyB9XG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIERhdGVUaW1lb3V0IHtcbiAgICBjb25zdHJ1Y3Rvcih0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ3RpbWVvdXQgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlY29tbWVuZGF0aW9uOiBTZXQgYSBsb2ctcG9pbnQgYHt0aGlzLmRpc2FibGUoKX1gIGluIHRoZSBib2R5XG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWUgPCB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGlmICghdmFsaWQgJiYgdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlOyAvLyB0aW1lb3V0IHJlYWNoZWRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kZWJ1Z2dlclxuICAgICAgICAgICAgZGVidWdnZXI7IC8vIFdBUk5JTkc6IE1vc3QgbGlrZWx5IGRlYnVnZ2luZyBjYXVzZWQgdGhlIHRpbWVvdXQuIENhbGwgYHRoaXMuZGlzYWJsZSgpYCB0byBjb250aW51ZSB3aXRob3V0IHRpbWluZyBvdXQuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWQ7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4uLy4uLy4uL2NvcmUvb2Zmc2V0UmFuZ2UuanMnO1xuaW1wb3J0IHsgU2VxdWVuY2VEaWZmLCBJbmZpbml0ZVRpbWVvdXQsIERpZmZBbGdvcml0aG1SZXN1bHQgfSBmcm9tICcuL2RpZmZBbGdvcml0aG0uanMnO1xuaW1wb3J0IHsgQXJyYXkyRCB9IGZyb20gJy4uL3V0aWxzLmpzJztcbi8qKlxuICogQSBPKE1OKSBkaWZmaW5nIGFsZ29yaXRobSB0aGF0IHN1cHBvcnRzIGEgc2NvcmUgZnVuY3Rpb24uXG4gKiBUaGUgYWxnb3JpdGhtIGNhbiBiZSBpbXByb3ZlZCBieSBwcm9jZXNzaW5nIHRoZSAyZCBhcnJheSBkaWFnb25hbGx5LlxuKi9cbmV4cG9ydCBjbGFzcyBEeW5hbWljUHJvZ3JhbW1pbmdEaWZmaW5nIHtcbiAgICBjb21wdXRlKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCB0aW1lb3V0ID0gSW5maW5pdGVUaW1lb3V0Lmluc3RhbmNlLCBlcXVhbGl0eVNjb3JlKSB7XG4gICAgICAgIGlmIChzZXF1ZW5jZTEubGVuZ3RoID09PSAwIHx8IHNlcXVlbmNlMi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBEaWZmQWxnb3JpdGhtUmVzdWx0LnRyaXZpYWwoc2VxdWVuY2UxLCBzZXF1ZW5jZTIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsY3NMZW5ndGhzLmdldChpLCBqKTogTGVuZ3RoIG9mIHRoZSBsb25nZXN0IGNvbW1vbiBzdWJzZXF1ZW5jZSBvZiBzZXF1ZW5jZTEuc3Vic3RyaW5nKDAsIGkgKyAxKSBhbmQgc2VxdWVuY2UyLnN1YnN0cmluZygwLCBqICsgMSkuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBsY3NMZW5ndGhzID0gbmV3IEFycmF5MkQoc2VxdWVuY2UxLmxlbmd0aCwgc2VxdWVuY2UyLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbnMgPSBuZXcgQXJyYXkyRChzZXF1ZW5jZTEubGVuZ3RoLCBzZXF1ZW5jZTIubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RocyA9IG5ldyBBcnJheTJEKHNlcXVlbmNlMS5sZW5ndGgsIHNlcXVlbmNlMi5sZW5ndGgpO1xuICAgICAgICAvLyA9PT09IEluaXRpYWxpemluZyBsY3NMZW5ndGhzID09PT1cbiAgICAgICAgZm9yIChsZXQgczEgPSAwOyBzMSA8IHNlcXVlbmNlMS5sZW5ndGg7IHMxKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHMyID0gMDsgczIgPCBzZXF1ZW5jZTIubGVuZ3RoOyBzMisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aW1lb3V0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGlmZkFsZ29yaXRobVJlc3VsdC50cml2aWFsVGltZWRPdXQoc2VxdWVuY2UxLCBzZXF1ZW5jZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBob3Jpem9udGFsTGVuID0gczEgPT09IDAgPyAwIDogbGNzTGVuZ3Rocy5nZXQoczEgLSAxLCBzMik7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGljYWxMZW4gPSBzMiA9PT0gMCA/IDAgOiBsY3NMZW5ndGhzLmdldChzMSwgczIgLSAxKTtcbiAgICAgICAgICAgICAgICBsZXQgZXh0ZW5kZWRTZXFTY29yZTtcbiAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2UxLmdldEVsZW1lbnQoczEpID09PSBzZXF1ZW5jZTIuZ2V0RWxlbWVudChzMikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMxID09PSAwIHx8IHMyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFNlcVNjb3JlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkU2VxU2NvcmUgPSBsY3NMZW5ndGhzLmdldChzMSAtIDEsIHMyIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMxID4gMCAmJiBzMiA+IDAgJiYgZGlyZWN0aW9ucy5nZXQoczEgLSAxLCBzMiAtIDEpID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmZXIgY29uc2VjdXRpdmUgZGlhZ29uYWxzXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFNlcVNjb3JlICs9IGxlbmd0aHMuZ2V0KHMxIC0gMSwgczIgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFNlcVNjb3JlICs9IChlcXVhbGl0eVNjb3JlID8gZXF1YWxpdHlTY29yZShzMSwgczIpIDogMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFNlcVNjb3JlID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gTWF0aC5tYXgoaG9yaXpvbnRhbExlbiwgdmVydGljYWxMZW4sIGV4dGVuZGVkU2VxU2NvcmUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gZXh0ZW5kZWRTZXFTY29yZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmVmZXIgZGlhZ29uYWxzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZMZW4gPSBzMSA+IDAgJiYgczIgPiAwID8gbGVuZ3Rocy5nZXQoczEgLSAxLCBzMiAtIDEpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3Rocy5zZXQoczEsIHMyLCBwcmV2TGVuICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMuc2V0KHMxLCBzMiwgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlID09PSBob3Jpem9udGFsTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aHMuc2V0KHMxLCBzMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMuc2V0KHMxLCBzMiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlID09PSB2ZXJ0aWNhbExlbikge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhzLnNldChzMSwgczIsIDApO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25zLnNldChzMSwgczIsIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsY3NMZW5ndGhzLnNldChzMSwgczIsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyA9PT09IEJhY2t0cmFja2luZyA9PT09XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbGFzdEFsaWduaW5nUG9zUzEgPSBzZXF1ZW5jZTEubGVuZ3RoO1xuICAgICAgICBsZXQgbGFzdEFsaWduaW5nUG9zUzIgPSBzZXF1ZW5jZTIubGVuZ3RoO1xuICAgICAgICBmdW5jdGlvbiByZXBvcnREZWNyZWFzaW5nQWxpZ25pbmdQb3NpdGlvbnMoczEsIHMyKSB7XG4gICAgICAgICAgICBpZiAoczEgKyAxICE9PSBsYXN0QWxpZ25pbmdQb3NTMSB8fCBzMiArIDEgIT09IGxhc3RBbGlnbmluZ1Bvc1MyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFNlcXVlbmNlRGlmZihuZXcgT2Zmc2V0UmFuZ2UoczEgKyAxLCBsYXN0QWxpZ25pbmdQb3NTMSksIG5ldyBPZmZzZXRSYW5nZShzMiArIDEsIGxhc3RBbGlnbmluZ1Bvc1MyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEFsaWduaW5nUG9zUzEgPSBzMTtcbiAgICAgICAgICAgIGxhc3RBbGlnbmluZ1Bvc1MyID0gczI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHMxID0gc2VxdWVuY2UxLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBzMiA9IHNlcXVlbmNlMi5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoczEgPj0gMCAmJiBzMiA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9ucy5nZXQoczEsIHMyKSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJlcG9ydERlY3JlYXNpbmdBbGlnbmluZ1Bvc2l0aW9ucyhzMSwgczIpO1xuICAgICAgICAgICAgICAgIHMxLS07XG4gICAgICAgICAgICAgICAgczItLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zLmdldChzMSwgczIpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHMxLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzMi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXBvcnREZWNyZWFzaW5nQWxpZ25pbmdQb3NpdGlvbnMoLTEsIC0xKTtcbiAgICAgICAgcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEaWZmQWxnb3JpdGhtUmVzdWx0KHJlc3VsdCwgZmFsc2UpO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgT2Zmc2V0UmFuZ2UgfSBmcm9tICcuLi8uLi8uLi9jb3JlL29mZnNldFJhbmdlLmpzJztcbmltcG9ydCB7IERpZmZBbGdvcml0aG1SZXN1bHQsIEluZmluaXRlVGltZW91dCwgU2VxdWVuY2VEaWZmIH0gZnJvbSAnLi9kaWZmQWxnb3JpdGhtLmpzJztcbi8qKlxuICogQW4gTyhORCkgZGlmZiBhbGdvcml0aG0gdGhhdCBoYXMgYSBxdWFkcmF0aWMgc3BhY2Ugd29yc3QtY2FzZSBjb21wbGV4aXR5LlxuKi9cbmV4cG9ydCBjbGFzcyBNeWVyc0RpZmZBbGdvcml0aG0ge1xuICAgIGNvbXB1dGUoc2VxMSwgc2VxMiwgdGltZW91dCA9IEluZmluaXRlVGltZW91dC5pbnN0YW5jZSkge1xuICAgICAgICAvLyBUaGVzZSBhcmUgY29tbW9uIHNwZWNpYWwgY2FzZXMuXG4gICAgICAgIC8vIFRoZSBlYXJseSByZXR1cm4gaW1wcm92ZXMgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5LlxuICAgICAgICBpZiAoc2VxMS5sZW5ndGggPT09IDAgfHwgc2VxMi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBEaWZmQWxnb3JpdGhtUmVzdWx0LnRyaXZpYWwoc2VxMSwgc2VxMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VxWCA9IHNlcTE7IC8vIFRleHQgb24gdGhlIHggYXhpc1xuICAgICAgICBjb25zdCBzZXFZID0gc2VxMjsgLy8gVGV4dCBvbiB0aGUgeSBheGlzXG4gICAgICAgIGZ1bmN0aW9uIGdldFhBZnRlclNuYWtlKHgsIHkpIHtcbiAgICAgICAgICAgIHdoaWxlICh4IDwgc2VxWC5sZW5ndGggJiYgeSA8IHNlcVkubGVuZ3RoICYmIHNlcVguZ2V0RWxlbWVudCh4KSA9PT0gc2VxWS5nZXRFbGVtZW50KHkpKSB7XG4gICAgICAgICAgICAgICAgeCsrO1xuICAgICAgICAgICAgICAgIHkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgICAgIGxldCBkID0gMDtcbiAgICAgICAgLy8gVltrXTogWCB2YWx1ZSBvZiBsb25nZXN0IGQtbGluZSB0aGF0IGVuZHMgaW4gZGlhZ29uYWwgay5cbiAgICAgICAgLy8gZC1saW5lOiBwYXRoIGZyb20gKDAsMCkgdG8gKHgseSkgdGhhdCB1c2VzIGV4YWN0bHkgZCBub24tZGlhZ29uYWxzLlxuICAgICAgICAvLyBkaWFnb25hbCBrOiBTZXQgb2YgcG9pbnRzICh4LHkpIHdpdGggeC15ID0gay5cbiAgICAgICAgLy8gaz0xIC0+ICgxLDApLCgyLDEpXG4gICAgICAgIGNvbnN0IFYgPSBuZXcgRmFzdEludDMyQXJyYXkoKTtcbiAgICAgICAgVi5zZXQoMCwgZ2V0WEFmdGVyU25ha2UoMCwgMCkpO1xuICAgICAgICBjb25zdCBwYXRocyA9IG5ldyBGYXN0QXJyYXlOZWdhdGl2ZUluZGljZXMoKTtcbiAgICAgICAgcGF0aHMuc2V0KDAsIFYuZ2V0KDApID09PSAwID8gbnVsbCA6IG5ldyBTbmFrZVBhdGgobnVsbCwgMCwgMCwgVi5nZXQoMCkpKTtcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICBsb29wOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgZCsrO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEaWZmQWxnb3JpdGhtUmVzdWx0LnRyaXZpYWxUaW1lZE91dChzZXFYLCBzZXFZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBwYXBlciBoYXMgYGZvciAoayA9IC1kOyBrIDw9IGQ7IGsgKz0gMilgLCBidXQgd2UgY2FuIGlnbm9yZSBkaWFnb25hbHMgdGhhdCBjYW5ub3QgaW5mbHVlbmNlIHRoZSByZXN1bHQuXG4gICAgICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gLU1hdGgubWluKGQsIHNlcVkubGVuZ3RoICsgKGQgJSAyKSk7XG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gTWF0aC5taW4oZCwgc2VxWC5sZW5ndGggKyAoZCAlIDIpKTtcbiAgICAgICAgICAgIGZvciAoayA9IGxvd2VyQm91bmQ7IGsgPD0gdXBwZXJCb3VuZDsgayArPSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSAwO1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgdGhlIFggdmFsdWVzIG9mIChkLTEpLWxpbmVzIHRvIGNvbXB1dGUgWCB2YWx1ZSBvZiB0aGUgbG9uZ2VzdCBkLWxpbmVzLlxuICAgICAgICAgICAgICAgIGNvbnN0IG1heFhvZkRMaW5lVG9wID0gayA9PT0gdXBwZXJCb3VuZCA/IC0xIDogVi5nZXQoayArIDEpOyAvLyBXZSB0YWtlIGEgdmVydGljYWwgbm9uLWRpYWdvbmFsIChhZGQgYSBzeW1ib2wgaW4gc2VxWClcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhYb2ZETGluZUxlZnQgPSBrID09PSBsb3dlckJvdW5kID8gLTEgOiBWLmdldChrIC0gMSkgKyAxOyAvLyBXZSB0YWtlIGEgaG9yaXpvbnRhbCBub24tZGlhZ29uYWwgKCsxIHgpIChkZWxldGUgYSBzeW1ib2wgaW4gc2VxWClcbiAgICAgICAgICAgICAgICBzdGVwKys7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKE1hdGgubWF4KG1heFhvZkRMaW5lVG9wLCBtYXhYb2ZETGluZUxlZnQpLCBzZXFYLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHggLSBrO1xuICAgICAgICAgICAgICAgIHN0ZXArKztcbiAgICAgICAgICAgICAgICBpZiAoeCA+IHNlcVgubGVuZ3RoIHx8IHkgPiBzZXFZLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGRpYWdvbmFsIGlzIGlycmVsZXZhbnQgZm9yIHRoZSByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IERvbid0IHBheSB0aGUgY29zdCBmb3IgdGhpcyBpbiB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdNYXhYID0gZ2V0WEFmdGVyU25ha2UoeCwgeSk7XG4gICAgICAgICAgICAgICAgVi5zZXQoaywgbmV3TWF4WCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFBhdGggPSB4ID09PSBtYXhYb2ZETGluZVRvcCA/IHBhdGhzLmdldChrICsgMSkgOiBwYXRocy5nZXQoayAtIDEpO1xuICAgICAgICAgICAgICAgIHBhdGhzLnNldChrLCBuZXdNYXhYICE9PSB4ID8gbmV3IFNuYWtlUGF0aChsYXN0UGF0aCwgeCwgeSwgbmV3TWF4WCAtIHgpIDogbGFzdFBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChWLmdldChrKSA9PT0gc2VxWC5sZW5ndGggJiYgVi5nZXQoaykgLSBrID09PSBzZXFZLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcGF0aCA9IHBhdGhzLmdldChrKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBsYXN0QWxpZ25pbmdQb3NTMSA9IHNlcVgubGVuZ3RoO1xuICAgICAgICBsZXQgbGFzdEFsaWduaW5nUG9zUzIgPSBzZXFZLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuZFggPSBwYXRoID8gcGF0aC54ICsgcGF0aC5sZW5ndGggOiAwO1xuICAgICAgICAgICAgY29uc3QgZW5kWSA9IHBhdGggPyBwYXRoLnkgKyBwYXRoLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBpZiAoZW5kWCAhPT0gbGFzdEFsaWduaW5nUG9zUzEgfHwgZW5kWSAhPT0gbGFzdEFsaWduaW5nUG9zUzIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU2VxdWVuY2VEaWZmKG5ldyBPZmZzZXRSYW5nZShlbmRYLCBsYXN0QWxpZ25pbmdQb3NTMSksIG5ldyBPZmZzZXRSYW5nZShlbmRZLCBsYXN0QWxpZ25pbmdQb3NTMikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEFsaWduaW5nUG9zUzEgPSBwYXRoLng7XG4gICAgICAgICAgICBsYXN0QWxpZ25pbmdQb3NTMiA9IHBhdGgueTtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEaWZmQWxnb3JpdGhtUmVzdWx0KHJlc3VsdCwgZmFsc2UpO1xuICAgIH1cbn1cbmNsYXNzIFNuYWtlUGF0aCB7XG4gICAgY29uc3RydWN0b3IocHJldiwgeCwgeSwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbn1cbi8qKlxuICogQW4gYXJyYXkgdGhhdCBzdXBwb3J0cyBmYXN0IG5lZ2F0aXZlIGluZGljZXMuXG4qL1xuY2xhc3MgRmFzdEludDMyQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBvc2l0aXZlQXJyID0gbmV3IEludDMyQXJyYXkoMTApO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlQXJyID0gbmV3IEludDMyQXJyYXkoMTApO1xuICAgIH1cbiAgICBnZXQoaWR4KSB7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICBpZHggPSAtaWR4IC0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlQXJyW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGl2ZUFycltpZHhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChpZHgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICBpZHggPSAtaWR4IC0gMTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gdGhpcy5uZWdhdGl2ZUFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSB0aGlzLm5lZ2F0aXZlQXJyO1xuICAgICAgICAgICAgICAgIHRoaXMubmVnYXRpdmVBcnIgPSBuZXcgSW50MzJBcnJheShhcnIubGVuZ3RoICogMik7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWdhdGl2ZUFyci5zZXQoYXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmVnYXRpdmVBcnJbaWR4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlkeCA+PSB0aGlzLnBvc2l0aXZlQXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IHRoaXMucG9zaXRpdmVBcnI7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZUFyciA9IG5ldyBJbnQzMkFycmF5KGFyci5sZW5ndGggKiAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aXZlQXJyLnNldChhcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZUFycltpZHhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFuIGFycmF5IHRoYXQgc3VwcG9ydHMgZmFzdCBuZWdhdGl2ZSBpbmRpY2VzLlxuKi9cbmNsYXNzIEZhc3RBcnJheU5lZ2F0aXZlSW5kaWNlcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucG9zaXRpdmVBcnIgPSBbXTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZUFyciA9IFtdO1xuICAgIH1cbiAgICBnZXQoaWR4KSB7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICBpZHggPSAtaWR4IC0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlQXJyW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGl2ZUFycltpZHhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChpZHgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICBpZHggPSAtaWR4IC0gMTtcbiAgICAgICAgICAgIHRoaXMubmVnYXRpdmVBcnJbaWR4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZUFycltpZHhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IFNlcXVlbmNlRGlmZiB9IGZyb20gJy4vYWxnb3JpdGhtcy9kaWZmQWxnb3JpdGhtLmpzJztcbmltcG9ydCB7IExpbmVSYW5nZU1hcHBpbmcgfSBmcm9tICcuLi9yYW5nZU1hcHBpbmcuanMnO1xuaW1wb3J0IHsgcHVzaE1hbnksIGNvbXBhcmVCeSwgbnVtYmVyQ29tcGFyYXRvciwgcmV2ZXJzZU9yZGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzLmpzJztcbmltcG9ydCB7IE1vbm90b25vdXNBcnJheSwgZmluZExhc3RNb25vdG9ub3VzIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzRmluZC5qcyc7XG5pbXBvcnQgeyBTZXRNYXAgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgTGluZVJhbmdlLCBMaW5lUmFuZ2VTZXQgfSBmcm9tICcuLi8uLi9jb3JlL2xpbmVSYW5nZS5qcyc7XG5pbXBvcnQgeyBMaW5lc1NsaWNlQ2hhclNlcXVlbmNlIH0gZnJvbSAnLi9saW5lc1NsaWNlQ2hhclNlcXVlbmNlLmpzJztcbmltcG9ydCB7IExpbmVSYW5nZUZyYWdtZW50LCBpc1NwYWNlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBNeWVyc0RpZmZBbGdvcml0aG0gfSBmcm9tICcuL2FsZ29yaXRobXMvbXllcnNEaWZmQWxnb3JpdGhtLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9yYW5nZS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZU1vdmVkTGluZXMoY2hhbmdlcywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgaGFzaGVkT3JpZ2luYWxMaW5lcywgaGFzaGVkTW9kaWZpZWRMaW5lcywgdGltZW91dCkge1xuICAgIGxldCB7IG1vdmVzLCBleGNsdWRlZENoYW5nZXMgfSA9IGNvbXB1dGVNb3Zlc0Zyb21TaW1wbGVEZWxldGlvbnNUb1NpbXBsZUluc2VydGlvbnMoY2hhbmdlcywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgdGltZW91dCk7XG4gICAgaWYgKCF0aW1lb3V0LmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkQ2hhbmdlcyA9IGNoYW5nZXMuZmlsdGVyKGMgPT4gIWV4Y2x1ZGVkQ2hhbmdlcy5oYXMoYykpO1xuICAgIGNvbnN0IHVuY2hhbmdlZE1vdmVzID0gY29tcHV0ZVVuY2hhbmdlZE1vdmVzKGZpbHRlcmVkQ2hhbmdlcywgaGFzaGVkT3JpZ2luYWxMaW5lcywgaGFzaGVkTW9kaWZpZWRMaW5lcywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgdGltZW91dCk7XG4gICAgcHVzaE1hbnkobW92ZXMsIHVuY2hhbmdlZE1vdmVzKTtcbiAgICBtb3ZlcyA9IGpvaW5DbG9zZUNvbnNlY3V0aXZlTW92ZXMobW92ZXMpO1xuICAgIC8vIElnbm9yZSB0b28gc2hvcnQgbW92ZXNcbiAgICBtb3ZlcyA9IG1vdmVzLmZpbHRlcihjdXJyZW50ID0+IHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBjdXJyZW50Lm9yaWdpbmFsLnRvT2Zmc2V0UmFuZ2UoKS5zbGljZShvcmlnaW5hbExpbmVzKS5tYXAobCA9PiBsLnRyaW0oKSk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVGV4dCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxUZXh0Lmxlbmd0aCA+PSAxNSAmJiBjb3VudFdoZXJlKGxpbmVzLCBsID0+IGwubGVuZ3RoID49IDIpID49IDI7XG4gICAgfSk7XG4gICAgbW92ZXMgPSByZW1vdmVNb3Zlc0luU2FtZURpZmYoY2hhbmdlcywgbW92ZXMpO1xuICAgIHJldHVybiBtb3Zlcztcbn1cbmZ1bmN0aW9uIGNvdW50V2hlcmUoYXJyLCBwcmVkaWNhdGUpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgdCBvZiBhcnIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh0KSkge1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBjb21wdXRlTW92ZXNGcm9tU2ltcGxlRGVsZXRpb25zVG9TaW1wbGVJbnNlcnRpb25zKGNoYW5nZXMsIG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIHRpbWVvdXQpIHtcbiAgICBjb25zdCBtb3ZlcyA9IFtdO1xuICAgIGNvbnN0IGRlbGV0aW9ucyA9IGNoYW5nZXNcbiAgICAgICAgLmZpbHRlcihjID0+IGMubW9kaWZpZWQuaXNFbXB0eSAmJiBjLm9yaWdpbmFsLmxlbmd0aCA+PSAzKVxuICAgICAgICAubWFwKGQgPT4gbmV3IExpbmVSYW5nZUZyYWdtZW50KGQub3JpZ2luYWwsIG9yaWdpbmFsTGluZXMsIGQpKTtcbiAgICBjb25zdCBpbnNlcnRpb25zID0gbmV3IFNldChjaGFuZ2VzXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjLm9yaWdpbmFsLmlzRW1wdHkgJiYgYy5tb2RpZmllZC5sZW5ndGggPj0gMylcbiAgICAgICAgLm1hcChkID0+IG5ldyBMaW5lUmFuZ2VGcmFnbWVudChkLm1vZGlmaWVkLCBtb2RpZmllZExpbmVzLCBkKSkpO1xuICAgIGNvbnN0IGV4Y2x1ZGVkQ2hhbmdlcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGRlbGV0aW9uIG9mIGRlbGV0aW9ucykge1xuICAgICAgICBsZXQgaGlnaGVzdFNpbWlsYXJpdHkgPSAtMTtcbiAgICAgICAgbGV0IGJlc3Q7XG4gICAgICAgIGZvciAoY29uc3QgaW5zZXJ0aW9uIG9mIGluc2VydGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBkZWxldGlvbi5jb21wdXRlU2ltaWxhcml0eShpbnNlcnRpb24pO1xuICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiBoaWdoZXN0U2ltaWxhcml0eSkge1xuICAgICAgICAgICAgICAgIGhpZ2hlc3RTaW1pbGFyaXR5ID0gc2ltaWxhcml0eTtcbiAgICAgICAgICAgICAgICBiZXN0ID0gaW5zZXJ0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoaWdoZXN0U2ltaWxhcml0eSA+IDAuOTAgJiYgYmVzdCkge1xuICAgICAgICAgICAgaW5zZXJ0aW9ucy5kZWxldGUoYmVzdCk7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKG5ldyBMaW5lUmFuZ2VNYXBwaW5nKGRlbGV0aW9uLnJhbmdlLCBiZXN0LnJhbmdlKSk7XG4gICAgICAgICAgICBleGNsdWRlZENoYW5nZXMuYWRkKGRlbGV0aW9uLnNvdXJjZSk7XG4gICAgICAgICAgICBleGNsdWRlZENoYW5nZXMuYWRkKGJlc3Quc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRpbWVvdXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtb3ZlcywgZXhjbHVkZWRDaGFuZ2VzIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW92ZXMsIGV4Y2x1ZGVkQ2hhbmdlcyB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZVVuY2hhbmdlZE1vdmVzKGNoYW5nZXMsIGhhc2hlZE9yaWdpbmFsTGluZXMsIGhhc2hlZE1vZGlmaWVkTGluZXMsIG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIHRpbWVvdXQpIHtcbiAgICBjb25zdCBtb3ZlcyA9IFtdO1xuICAgIGNvbnN0IG9yaWdpbmFsM0xpbmVIYXNoZXMgPSBuZXcgU2V0TWFwKCk7XG4gICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcjsgaSA8IGNoYW5nZS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtoYXNoZWRPcmlnaW5hbExpbmVzW2kgLSAxXX06JHtoYXNoZWRPcmlnaW5hbExpbmVzW2kgKyAxIC0gMV19OiR7aGFzaGVkT3JpZ2luYWxMaW5lc1tpICsgMiAtIDFdfWA7XG4gICAgICAgICAgICBvcmlnaW5hbDNMaW5lSGFzaGVzLmFkZChrZXksIHsgcmFuZ2U6IG5ldyBMaW5lUmFuZ2UoaSwgaSArIDMpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBvc3NpYmxlTWFwcGluZ3MgPSBbXTtcbiAgICBjaGFuZ2VzLnNvcnQoY29tcGFyZUJ5KGMgPT4gYy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIsIG51bWJlckNvbXBhcmF0b3IpKTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBsYXN0TWFwcGluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZS5tb2RpZmllZC5zdGFydExpbmVOdW1iZXI7IGkgPCBjaGFuZ2UubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAtIDI7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7aGFzaGVkTW9kaWZpZWRMaW5lc1tpIC0gMV19OiR7aGFzaGVkTW9kaWZpZWRMaW5lc1tpICsgMSAtIDFdfToke2hhc2hlZE1vZGlmaWVkTGluZXNbaSArIDIgLSAxXX1gO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE1vZGlmaWVkUmFuZ2UgPSBuZXcgTGluZVJhbmdlKGksIGkgKyAzKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRNYXBwaW5ncyA9IFtdO1xuICAgICAgICAgICAgb3JpZ2luYWwzTGluZUhhc2hlcy5mb3JFYWNoKGtleSwgKHsgcmFuZ2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGFzdE1hcHBpbmcgb2YgbGFzdE1hcHBpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvZXMgdGhpcyBtYXRjaCBleHRlbmQgc29tZSBsYXN0IG1hdGNoP1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE1hcHBpbmcub3JpZ2luYWxMaW5lUmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSArIDEgPT09IHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNYXBwaW5nLm1vZGlmaWVkTGluZVJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgKyAxID09PSBjdXJyZW50TW9kaWZpZWRSYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWFwcGluZy5vcmlnaW5hbExpbmVSYW5nZSA9IG5ldyBMaW5lUmFuZ2UobGFzdE1hcHBpbmcub3JpZ2luYWxMaW5lUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNYXBwaW5nLm1vZGlmaWVkTGluZVJhbmdlID0gbmV3IExpbmVSYW5nZShsYXN0TWFwcGluZy5tb2RpZmllZExpbmVSYW5nZS5zdGFydExpbmVOdW1iZXIsIGN1cnJlbnRNb2RpZmllZFJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE1hcHBpbmdzLnB1c2gobGFzdE1hcHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkTGluZVJhbmdlOiBjdXJyZW50TW9kaWZpZWRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxMaW5lUmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zc2libGVNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIG5leHRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYXN0TWFwcGluZ3MgPSBuZXh0TWFwcGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aW1lb3V0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc3NpYmxlTWFwcGluZ3Muc29ydChyZXZlcnNlT3JkZXIoY29tcGFyZUJ5KG0gPT4gbS5tb2RpZmllZExpbmVSYW5nZS5sZW5ndGgsIG51bWJlckNvbXBhcmF0b3IpKSk7XG4gICAgY29uc3QgbW9kaWZpZWRTZXQgPSBuZXcgTGluZVJhbmdlU2V0KCk7XG4gICAgY29uc3Qgb3JpZ2luYWxTZXQgPSBuZXcgTGluZVJhbmdlU2V0KCk7XG4gICAgZm9yIChjb25zdCBtYXBwaW5nIG9mIHBvc3NpYmxlTWFwcGluZ3MpIHtcbiAgICAgICAgY29uc3QgZGlmZk9yaWdUb01vZCA9IG1hcHBpbmcubW9kaWZpZWRMaW5lUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gbWFwcGluZy5vcmlnaW5hbExpbmVSYW5nZS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkU2VjdGlvbnMgPSBtb2RpZmllZFNldC5zdWJ0cmFjdEZyb20obWFwcGluZy5tb2RpZmllZExpbmVSYW5nZSk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVHJhbnNsYXRlZFNlY3Rpb25zID0gb3JpZ2luYWxTZXQuc3VidHJhY3RGcm9tKG1hcHBpbmcub3JpZ2luYWxMaW5lUmFuZ2UpLmdldFdpdGhEZWx0YShkaWZmT3JpZ1RvTW9kKTtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRJbnRlcnNlY3RlZFNlY3Rpb25zID0gbW9kaWZpZWRTZWN0aW9ucy5nZXRJbnRlcnNlY3Rpb24ob3JpZ2luYWxUcmFuc2xhdGVkU2VjdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgbW9kaWZpZWRJbnRlcnNlY3RlZFNlY3Rpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKHMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lUmFuZ2UgPSBzO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxMaW5lUmFuZ2UgPSBzLmRlbHRhKC1kaWZmT3JpZ1RvTW9kKTtcbiAgICAgICAgICAgIG1vdmVzLnB1c2gobmV3IExpbmVSYW5nZU1hcHBpbmcob3JpZ2luYWxMaW5lUmFuZ2UsIG1vZGlmaWVkTGluZVJhbmdlKSk7XG4gICAgICAgICAgICBtb2RpZmllZFNldC5hZGRSYW5nZShtb2RpZmllZExpbmVSYW5nZSk7XG4gICAgICAgICAgICBvcmlnaW5hbFNldC5hZGRSYW5nZShvcmlnaW5hbExpbmVSYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZXMuc29ydChjb21wYXJlQnkobSA9PiBtLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciwgbnVtYmVyQ29tcGFyYXRvcikpO1xuICAgIGNvbnN0IG1vbm90b25vdXNDaGFuZ2VzID0gbmV3IE1vbm90b25vdXNBcnJheShjaGFuZ2VzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1vdmUgPSBtb3Zlc1tpXTtcbiAgICAgICAgY29uc3QgZmlyc3RUb3VjaGluZ0NoYW5nZU9yaWcgPSBtb25vdG9ub3VzQ2hhbmdlcy5maW5kTGFzdE1vbm90b25vdXMoYyA9PiBjLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciA8PSBtb3ZlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IGZpcnN0VG91Y2hpbmdDaGFuZ2VNb2QgPSBmaW5kTGFzdE1vbm90b25vdXMoY2hhbmdlcywgYyA9PiBjLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciA8PSBtb3ZlLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IGxpbmVzQWJvdmUgPSBNYXRoLm1heChtb3ZlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAtIGZpcnN0VG91Y2hpbmdDaGFuZ2VPcmlnLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciwgbW92ZS5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgLSBmaXJzdFRvdWNoaW5nQ2hhbmdlTW9kLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IGxhc3RUb3VjaGluZ0NoYW5nZU9yaWcgPSBtb25vdG9ub3VzQ2hhbmdlcy5maW5kTGFzdE1vbm90b25vdXMoYyA9PiBjLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciA8IG1vdmUub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSk7XG4gICAgICAgIGNvbnN0IGxhc3RUb3VjaGluZ0NoYW5nZU1vZCA9IGZpbmRMYXN0TW9ub3Rvbm91cyhjaGFuZ2VzLCBjID0+IGMubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIDwgbW92ZS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKTtcbiAgICAgICAgY29uc3QgbGluZXNCZWxvdyA9IE1hdGgubWF4KGxhc3RUb3VjaGluZ0NoYW5nZU9yaWcub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAtIG1vdmUub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgbGFzdFRvdWNoaW5nQ2hhbmdlTW9kLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSBtb3ZlLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xuICAgICAgICBsZXQgZXh0ZW5kVG9Ub3A7XG4gICAgICAgIGZvciAoZXh0ZW5kVG9Ub3AgPSAwOyBleHRlbmRUb1RvcCA8IGxpbmVzQWJvdmU7IGV4dGVuZFRvVG9wKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdMaW5lID0gbW92ZS5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgLSBleHRlbmRUb1RvcCAtIDE7XG4gICAgICAgICAgICBjb25zdCBtb2RMaW5lID0gbW92ZS5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgLSBleHRlbmRUb1RvcCAtIDE7XG4gICAgICAgICAgICBpZiAob3JpZ0xpbmUgPiBvcmlnaW5hbExpbmVzLmxlbmd0aCB8fCBtb2RMaW5lID4gbW9kaWZpZWRMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RpZmllZFNldC5jb250YWlucyhtb2RMaW5lKSB8fCBvcmlnaW5hbFNldC5jb250YWlucyhvcmlnTGluZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXJlTGluZXNTaW1pbGFyKG9yaWdpbmFsTGluZXNbb3JpZ0xpbmUgLSAxXSwgbW9kaWZpZWRMaW5lc1ttb2RMaW5lIC0gMV0sIHRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dGVuZFRvVG9wID4gMCkge1xuICAgICAgICAgICAgb3JpZ2luYWxTZXQuYWRkUmFuZ2UobmV3IExpbmVSYW5nZShtb3ZlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAtIGV4dGVuZFRvVG9wLCBtb3ZlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcikpO1xuICAgICAgICAgICAgbW9kaWZpZWRTZXQuYWRkUmFuZ2UobmV3IExpbmVSYW5nZShtb3ZlLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciAtIGV4dGVuZFRvVG9wLCBtb3ZlLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlcikpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBleHRlbmRUb0JvdHRvbTtcbiAgICAgICAgZm9yIChleHRlbmRUb0JvdHRvbSA9IDA7IGV4dGVuZFRvQm90dG9tIDwgbGluZXNCZWxvdzsgZXh0ZW5kVG9Cb3R0b20rKykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ0xpbmUgPSBtb3ZlLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgKyBleHRlbmRUb0JvdHRvbTtcbiAgICAgICAgICAgIGNvbnN0IG1vZExpbmUgPSBtb3ZlLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgKyBleHRlbmRUb0JvdHRvbTtcbiAgICAgICAgICAgIGlmIChvcmlnTGluZSA+IG9yaWdpbmFsTGluZXMubGVuZ3RoIHx8IG1vZExpbmUgPiBtb2RpZmllZExpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGlmaWVkU2V0LmNvbnRhaW5zKG1vZExpbmUpIHx8IG9yaWdpbmFsU2V0LmNvbnRhaW5zKG9yaWdMaW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcmVMaW5lc1NpbWlsYXIob3JpZ2luYWxMaW5lc1tvcmlnTGluZSAtIDFdLCBtb2RpZmllZExpbmVzW21vZExpbmUgLSAxXSwgdGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0ZW5kVG9Cb3R0b20gPiAwKSB7XG4gICAgICAgICAgICBvcmlnaW5hbFNldC5hZGRSYW5nZShuZXcgTGluZVJhbmdlKG1vdmUub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgbW92ZS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICsgZXh0ZW5kVG9Cb3R0b20pKTtcbiAgICAgICAgICAgIG1vZGlmaWVkU2V0LmFkZFJhbmdlKG5ldyBMaW5lUmFuZ2UobW92ZS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCBtb3ZlLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgKyBleHRlbmRUb0JvdHRvbSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHRlbmRUb1RvcCA+IDAgfHwgZXh0ZW5kVG9Cb3R0b20gPiAwKSB7XG4gICAgICAgICAgICBtb3Zlc1tpXSA9IG5ldyBMaW5lUmFuZ2VNYXBwaW5nKG5ldyBMaW5lUmFuZ2UobW92ZS5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgLSBleHRlbmRUb1RvcCwgbW92ZS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICsgZXh0ZW5kVG9Cb3R0b20pLCBuZXcgTGluZVJhbmdlKG1vdmUubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIC0gZXh0ZW5kVG9Ub3AsIG1vdmUubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSArIGV4dGVuZFRvQm90dG9tKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vdmVzO1xufVxuZnVuY3Rpb24gYXJlTGluZXNTaW1pbGFyKGxpbmUxLCBsaW5lMiwgdGltZW91dCkge1xuICAgIGlmIChsaW5lMS50cmltKCkgPT09IGxpbmUyLnRyaW0oKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxpbmUxLmxlbmd0aCA+IDMwMCAmJiBsaW5lMi5sZW5ndGggPiAzMDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBteWVyc0RpZmZpbmdBbGdvcml0aG0gPSBuZXcgTXllcnNEaWZmQWxnb3JpdGhtKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbXllcnNEaWZmaW5nQWxnb3JpdGhtLmNvbXB1dGUobmV3IExpbmVzU2xpY2VDaGFyU2VxdWVuY2UoW2xpbmUxXSwgbmV3IFJhbmdlKDEsIDEsIDEsIGxpbmUxLmxlbmd0aCksIGZhbHNlKSwgbmV3IExpbmVzU2xpY2VDaGFyU2VxdWVuY2UoW2xpbmUyXSwgbmV3IFJhbmdlKDEsIDEsIDEsIGxpbmUyLmxlbmd0aCksIGZhbHNlKSwgdGltZW91dCk7XG4gICAgbGV0IGNvbW1vbk5vblNwYWNlQ2hhckNvdW50ID0gMDtcbiAgICBjb25zdCBpbnZlcnRlZCA9IFNlcXVlbmNlRGlmZi5pbnZlcnQocmVzdWx0LmRpZmZzLCBsaW5lMS5sZW5ndGgpO1xuICAgIGZvciAoY29uc3Qgc2VxIG9mIGludmVydGVkKSB7XG4gICAgICAgIHNlcS5zZXExUmFuZ2UuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1NwYWNlKGxpbmUxLmNoYXJDb2RlQXQoaWR4KSkpIHtcbiAgICAgICAgICAgICAgICBjb21tb25Ob25TcGFjZUNoYXJDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY291bnROb25Xc0NoYXJzKHN0cikge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWlzU3BhY2Uoc3RyLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIGNvbnN0IGxvbmdlckxpbmVMZW5ndGggPSBjb3VudE5vbldzQ2hhcnMobGluZTEubGVuZ3RoID4gbGluZTIubGVuZ3RoID8gbGluZTEgOiBsaW5lMik7XG4gICAgY29uc3QgciA9IGNvbW1vbk5vblNwYWNlQ2hhckNvdW50IC8gbG9uZ2VyTGluZUxlbmd0aCA+IDAuNiAmJiBsb25nZXJMaW5lTGVuZ3RoID4gMTA7XG4gICAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBqb2luQ2xvc2VDb25zZWN1dGl2ZU1vdmVzKG1vdmVzKSB7XG4gICAgaWYgKG1vdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbW92ZXM7XG4gICAgfVxuICAgIG1vdmVzLnNvcnQoY29tcGFyZUJ5KG0gPT4gbS5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIsIG51bWJlckNvbXBhcmF0b3IpKTtcbiAgICBjb25zdCByZXN1bHQgPSBbbW92ZXNbMF1dO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBtb3Zlc1tpXTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxEaXN0ID0gY3VycmVudC5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgLSBsYXN0Lm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkRGlzdCA9IGN1cnJlbnQubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIC0gbGFzdC5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xuICAgICAgICBjb25zdCBjdXJyZW50TW92ZUFmdGVyTGFzdCA9IG9yaWdpbmFsRGlzdCA+PSAwICYmIG1vZGlmaWVkRGlzdCA+PSAwO1xuICAgICAgICBpZiAoY3VycmVudE1vdmVBZnRlckxhc3QgJiYgb3JpZ2luYWxEaXN0ICsgbW9kaWZpZWREaXN0IDw9IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBsYXN0LmpvaW4oY3VycmVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlbW92ZU1vdmVzSW5TYW1lRGlmZihjaGFuZ2VzLCBtb3Zlcykge1xuICAgIGNvbnN0IGNoYW5nZXNNb25vdG9ub3VzID0gbmV3IE1vbm90b25vdXNBcnJheShjaGFuZ2VzKTtcbiAgICBtb3ZlcyA9IG1vdmVzLmZpbHRlcihtID0+IHtcbiAgICAgICAgY29uc3QgZGlmZkJlZm9yZUVuZE9mTW92ZU9yaWdpbmFsID0gY2hhbmdlc01vbm90b25vdXMuZmluZExhc3RNb25vdG9ub3VzKGMgPT4gYy5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgPCBtLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpXG4gICAgICAgICAgICB8fCBuZXcgTGluZVJhbmdlTWFwcGluZyhuZXcgTGluZVJhbmdlKDEsIDEpLCBuZXcgTGluZVJhbmdlKDEsIDEpKTtcbiAgICAgICAgY29uc3QgZGlmZkJlZm9yZUVuZE9mTW92ZU1vZGlmaWVkID0gZmluZExhc3RNb25vdG9ub3VzKGNoYW5nZXMsIGMgPT4gYy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgPCBtLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xuICAgICAgICBjb25zdCBkaWZmZXJlbnREaWZmcyA9IGRpZmZCZWZvcmVFbmRPZk1vdmVPcmlnaW5hbCAhPT0gZGlmZkJlZm9yZUVuZE9mTW92ZU1vZGlmaWVkO1xuICAgICAgICByZXR1cm4gZGlmZmVyZW50RGlmZnM7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1vdmVzO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBlcXVhbHMsIGdyb3VwQWRqYWNlbnRCeSB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2FycmF5cy5qcyc7XG5pbXBvcnQgeyBhc3NlcnRGbiwgY2hlY2tBZGphY2VudEl0ZW1zIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vYXNzZXJ0LmpzJztcbmltcG9ydCB7IExpbmVSYW5nZSB9IGZyb20gJy4uLy4uL2NvcmUvbGluZVJhbmdlLmpzJztcbmltcG9ydCB7IE9mZnNldFJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9vZmZzZXRSYW5nZS5qcyc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uLy4uL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgRGF0ZVRpbWVvdXQsIEluZmluaXRlVGltZW91dCwgU2VxdWVuY2VEaWZmIH0gZnJvbSAnLi9hbGdvcml0aG1zL2RpZmZBbGdvcml0aG0uanMnO1xuaW1wb3J0IHsgRHluYW1pY1Byb2dyYW1taW5nRGlmZmluZyB9IGZyb20gJy4vYWxnb3JpdGhtcy9keW5hbWljUHJvZ3JhbW1pbmdEaWZmaW5nLmpzJztcbmltcG9ydCB7IE15ZXJzRGlmZkFsZ29yaXRobSB9IGZyb20gJy4vYWxnb3JpdGhtcy9teWVyc0RpZmZBbGdvcml0aG0uanMnO1xuaW1wb3J0IHsgY29tcHV0ZU1vdmVkTGluZXMgfSBmcm9tICcuL2NvbXB1dGVNb3ZlZExpbmVzLmpzJztcbmltcG9ydCB7IGV4dGVuZERpZmZzVG9FbnRpcmVXb3JkSWZBcHByb3ByaWF0ZSwgb3B0aW1pemVTZXF1ZW5jZURpZmZzLCByZW1vdmVTaG9ydE1hdGNoZXMsIHJlbW92ZVZlcnlTaG9ydE1hdGNoaW5nTGluZXNCZXR3ZWVuRGlmZnMsIHJlbW92ZVZlcnlTaG9ydE1hdGNoaW5nVGV4dEJldHdlZW5Mb25nRGlmZnMgfSBmcm9tICcuL2hldXJpc3RpY1NlcXVlbmNlT3B0aW1pemF0aW9ucy5qcyc7XG5pbXBvcnQgeyBMaW5lU2VxdWVuY2UgfSBmcm9tICcuL2xpbmVTZXF1ZW5jZS5qcyc7XG5pbXBvcnQgeyBMaW5lc1NsaWNlQ2hhclNlcXVlbmNlIH0gZnJvbSAnLi9saW5lc1NsaWNlQ2hhclNlcXVlbmNlLmpzJztcbmltcG9ydCB7IExpbmVzRGlmZiwgTW92ZWRUZXh0IH0gZnJvbSAnLi4vbGluZXNEaWZmQ29tcHV0ZXIuanMnO1xuaW1wb3J0IHsgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nLCBMaW5lUmFuZ2VNYXBwaW5nLCBSYW5nZU1hcHBpbmcgfSBmcm9tICcuLi9yYW5nZU1hcHBpbmcuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRMaW5lc0RpZmZDb21wdXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY1Byb2dyYW1taW5nRGlmZmluZyA9IG5ldyBEeW5hbWljUHJvZ3JhbW1pbmdEaWZmaW5nKCk7XG4gICAgICAgIHRoaXMubXllcnNEaWZmaW5nQWxnb3JpdGhtID0gbmV3IE15ZXJzRGlmZkFsZ29yaXRobSgpO1xuICAgIH1cbiAgICBjb21wdXRlRGlmZihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbExpbmVzLmxlbmd0aCA8PSAxICYmIGVxdWFscyhvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCAoYSwgYikgPT4gYSA9PT0gYikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGluZXNEaWZmKFtdLCBbXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnaW5hbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBvcmlnaW5hbExpbmVzWzBdLmxlbmd0aCA9PT0gMCB8fCBtb2RpZmllZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBtb2RpZmllZExpbmVzWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lc0RpZmYoW1xuICAgICAgICAgICAgICAgIG5ldyBEZXRhaWxlZExpbmVSYW5nZU1hcHBpbmcobmV3IExpbmVSYW5nZSgxLCBvcmlnaW5hbExpbmVzLmxlbmd0aCArIDEpLCBuZXcgTGluZVJhbmdlKDEsIG1vZGlmaWVkTGluZXMubGVuZ3RoICsgMSksIFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJhbmdlTWFwcGluZyhuZXcgUmFuZ2UoMSwgMSwgb3JpZ2luYWxMaW5lcy5sZW5ndGgsIG9yaWdpbmFsTGluZXNbb3JpZ2luYWxMaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggKyAxKSwgbmV3IFJhbmdlKDEsIDEsIG1vZGlmaWVkTGluZXMubGVuZ3RoLCBtb2RpZmllZExpbmVzW21vZGlmaWVkTGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoICsgMSkpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0sIFtdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMubWF4Q29tcHV0YXRpb25UaW1lTXMgPT09IDAgPyBJbmZpbml0ZVRpbWVvdXQuaW5zdGFuY2UgOiBuZXcgRGF0ZVRpbWVvdXQob3B0aW9ucy5tYXhDb21wdXRhdGlvblRpbWVNcyk7XG4gICAgICAgIGNvbnN0IGNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMgPSAhb3B0aW9ucy5pZ25vcmVUcmltV2hpdGVzcGFjZTtcbiAgICAgICAgY29uc3QgcGVyZmVjdEhhc2hlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0T3JDcmVhdGVIYXNoKHRleHQpIHtcbiAgICAgICAgICAgIGxldCBoYXNoID0gcGVyZmVjdEhhc2hlcy5nZXQodGV4dCk7XG4gICAgICAgICAgICBpZiAoaGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaGFzaCA9IHBlcmZlY3RIYXNoZXMuc2l6ZTtcbiAgICAgICAgICAgICAgICBwZXJmZWN0SGFzaGVzLnNldCh0ZXh0LCBoYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZXNIYXNoZXMgPSBvcmlnaW5hbExpbmVzLm1hcCgobCkgPT4gZ2V0T3JDcmVhdGVIYXNoKGwudHJpbSgpKSk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZXNIYXNoZXMgPSBtb2RpZmllZExpbmVzLm1hcCgobCkgPT4gZ2V0T3JDcmVhdGVIYXNoKGwudHJpbSgpKSk7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlMSA9IG5ldyBMaW5lU2VxdWVuY2Uob3JpZ2luYWxMaW5lc0hhc2hlcywgb3JpZ2luYWxMaW5lcyk7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlMiA9IG5ldyBMaW5lU2VxdWVuY2UobW9kaWZpZWRMaW5lc0hhc2hlcywgbW9kaWZpZWRMaW5lcyk7XG4gICAgICAgIGNvbnN0IGxpbmVBbGlnbm1lbnRSZXN1bHQgPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlcXVlbmNlMS5sZW5ndGggKyBzZXF1ZW5jZTIubGVuZ3RoIDwgMTcwMCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgaW1wcm92ZWQgYWxnb3JpdGhtIGZvciBzbWFsbCBmaWxlc1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmR5bmFtaWNQcm9ncmFtbWluZ0RpZmZpbmcuY29tcHV0ZShzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgdGltZW91dCwgKG9mZnNldDEsIG9mZnNldDIpID0+IG9yaWdpbmFsTGluZXNbb2Zmc2V0MV0gPT09IG1vZGlmaWVkTGluZXNbb2Zmc2V0Ml1cbiAgICAgICAgICAgICAgICAgICAgPyBtb2RpZmllZExpbmVzW29mZnNldDJdLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAwLjFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMSArIE1hdGgubG9nKDEgKyBtb2RpZmllZExpbmVzW29mZnNldDJdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgOiAwLjk5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm15ZXJzRGlmZmluZ0FsZ29yaXRobS5jb21wdXRlKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCB0aW1lb3V0KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgbGV0IGxpbmVBbGlnbm1lbnRzID0gbGluZUFsaWdubWVudFJlc3VsdC5kaWZmcztcbiAgICAgICAgbGV0IGhpdFRpbWVvdXQgPSBsaW5lQWxpZ25tZW50UmVzdWx0LmhpdFRpbWVvdXQ7XG4gICAgICAgIGxpbmVBbGlnbm1lbnRzID0gb3B0aW1pemVTZXF1ZW5jZURpZmZzKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCBsaW5lQWxpZ25tZW50cyk7XG4gICAgICAgIGxpbmVBbGlnbm1lbnRzID0gcmVtb3ZlVmVyeVNob3J0TWF0Y2hpbmdMaW5lc0JldHdlZW5EaWZmcyhzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgbGluZUFsaWdubWVudHMpO1xuICAgICAgICBjb25zdCBhbGlnbm1lbnRzID0gW107XG4gICAgICAgIGNvbnN0IHNjYW5Gb3JXaGl0ZXNwYWNlQ2hhbmdlcyA9IChlcXVhbExpbmVzQ291bnQpID0+IHtcbiAgICAgICAgICAgIGlmICghY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXF1YWxMaW5lc0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXExT2Zmc2V0ID0gc2VxMUxhc3RTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VxMk9mZnNldCA9IHNlcTJMYXN0U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbExpbmVzW3NlcTFPZmZzZXRdICE9PSBtb2RpZmllZExpbmVzW3NlcTJPZmZzZXRdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBvZiB3aGl0ZXNwYWNlIGNoYW5nZXMsIGRpZmYgdGhlc2UgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhcmFjdGVyRGlmZnMgPSB0aGlzLnJlZmluZURpZmYob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgbmV3IFNlcXVlbmNlRGlmZihuZXcgT2Zmc2V0UmFuZ2Uoc2VxMU9mZnNldCwgc2VxMU9mZnNldCArIDEpLCBuZXcgT2Zmc2V0UmFuZ2Uoc2VxMk9mZnNldCwgc2VxMk9mZnNldCArIDEpKSwgdGltZW91dCwgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYSBvZiBjaGFyYWN0ZXJEaWZmcy5tYXBwaW5ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50cy5wdXNoKGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJEaWZmcy5oaXRUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXRUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNlcTFMYXN0U3RhcnQgPSAwO1xuICAgICAgICBsZXQgc2VxMkxhc3RTdGFydCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZGlmZiBvZiBsaW5lQWxpZ25tZW50cykge1xuICAgICAgICAgICAgYXNzZXJ0Rm4oKCkgPT4gZGlmZi5zZXExUmFuZ2Uuc3RhcnQgLSBzZXExTGFzdFN0YXJ0ID09PSBkaWZmLnNlcTJSYW5nZS5zdGFydCAtIHNlcTJMYXN0U3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgZXF1YWxMaW5lc0NvdW50ID0gZGlmZi5zZXExUmFuZ2Uuc3RhcnQgLSBzZXExTGFzdFN0YXJ0O1xuICAgICAgICAgICAgc2NhbkZvcldoaXRlc3BhY2VDaGFuZ2VzKGVxdWFsTGluZXNDb3VudCk7XG4gICAgICAgICAgICBzZXExTGFzdFN0YXJ0ID0gZGlmZi5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlO1xuICAgICAgICAgICAgc2VxMkxhc3RTdGFydCA9IGRpZmYuc2VxMlJhbmdlLmVuZEV4Y2x1c2l2ZTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlckRpZmZzID0gdGhpcy5yZWZpbmVEaWZmKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIGRpZmYsIHRpbWVvdXQsIGNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKGNoYXJhY3RlckRpZmZzLmhpdFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBoaXRUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgYSBvZiBjaGFyYWN0ZXJEaWZmcy5tYXBwaW5ncykge1xuICAgICAgICAgICAgICAgIGFsaWdubWVudHMucHVzaChhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY2FuRm9yV2hpdGVzcGFjZUNoYW5nZXMob3JpZ2luYWxMaW5lcy5sZW5ndGggLSBzZXExTGFzdFN0YXJ0KTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGxpbmVSYW5nZU1hcHBpbmdGcm9tUmFuZ2VNYXBwaW5ncyhhbGlnbm1lbnRzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzKTtcbiAgICAgICAgbGV0IG1vdmVzID0gW107XG4gICAgICAgIGlmIChvcHRpb25zLmNvbXB1dGVNb3Zlcykge1xuICAgICAgICAgICAgbW92ZXMgPSB0aGlzLmNvbXB1dGVNb3ZlcyhjaGFuZ2VzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBvcmlnaW5hbExpbmVzSGFzaGVzLCBtb2RpZmllZExpbmVzSGFzaGVzLCB0aW1lb3V0LCBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIHJhbmdlcyBhcmUgdmFsaWRcbiAgICAgICAgYXNzZXJ0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQb3NpdGlvbihwb3MsIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy5saW5lTnVtYmVyIDwgMSB8fCBwb3MubGluZU51bWJlciA+IGxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1twb3MubGluZU51bWJlciAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChwb3MuY29sdW1uIDwgMSB8fCBwb3MuY29sdW1uID4gbGluZS5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVJhbmdlKHJhbmdlLCBsaW5lcykge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydExpbmVOdW1iZXIgPCAxIHx8IHJhbmdlLnN0YXJ0TGluZU51bWJlciA+IGxpbmVzLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA8IDEgfHwgcmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA+IGxpbmVzLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjLmlubmVyQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWMgb2YgYy5pbm5lckNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSB2YWxpZGF0ZVBvc2l0aW9uKGljLm1vZGlmaWVkUmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbigpLCBtb2RpZmllZExpbmVzKSAmJiB2YWxpZGF0ZVBvc2l0aW9uKGljLm1vZGlmaWVkUmFuZ2UuZ2V0RW5kUG9zaXRpb24oKSwgbW9kaWZpZWRMaW5lcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUG9zaXRpb24oaWMub3JpZ2luYWxSYW5nZS5nZXRTdGFydFBvc2l0aW9uKCksIG9yaWdpbmFsTGluZXMpICYmIHZhbGlkYXRlUG9zaXRpb24oaWMub3JpZ2luYWxSYW5nZS5nZXRFbmRQb3NpdGlvbigpLCBvcmlnaW5hbExpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVSYW5nZShjLm1vZGlmaWVkLCBtb2RpZmllZExpbmVzKSB8fCAhdmFsaWRhdGVSYW5nZShjLm9yaWdpbmFsLCBvcmlnaW5hbExpbmVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExpbmVzRGlmZihjaGFuZ2VzLCBtb3ZlcywgaGl0VGltZW91dCk7XG4gICAgfVxuICAgIGNvbXB1dGVNb3ZlcyhjaGFuZ2VzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBoYXNoZWRPcmlnaW5hbExpbmVzLCBoYXNoZWRNb2RpZmllZExpbmVzLCB0aW1lb3V0LCBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IG1vdmVzID0gY29tcHV0ZU1vdmVkTGluZXMoY2hhbmdlcywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgaGFzaGVkT3JpZ2luYWxMaW5lcywgaGFzaGVkTW9kaWZpZWRMaW5lcywgdGltZW91dCk7XG4gICAgICAgIGNvbnN0IG1vdmVzV2l0aERpZmZzID0gbW92ZXMubWFwKG0gPT4ge1xuICAgICAgICAgICAgY29uc3QgbW92ZUNoYW5nZXMgPSB0aGlzLnJlZmluZURpZmYob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgbmV3IFNlcXVlbmNlRGlmZihtLm9yaWdpbmFsLnRvT2Zmc2V0UmFuZ2UoKSwgbS5tb2RpZmllZC50b09mZnNldFJhbmdlKCkpLCB0aW1lb3V0LCBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmdzID0gbGluZVJhbmdlTWFwcGluZ0Zyb21SYW5nZU1hcHBpbmdzKG1vdmVDaGFuZ2VzLm1hcHBpbmdzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW92ZWRUZXh0KG0sIG1hcHBpbmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtb3Zlc1dpdGhEaWZmcztcbiAgICB9XG4gICAgcmVmaW5lRGlmZihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBkaWZmLCB0aW1lb3V0LCBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGxpbmVSYW5nZU1hcHBpbmcgPSB0b0xpbmVSYW5nZU1hcHBpbmcoZGlmZik7XG4gICAgICAgIGNvbnN0IHJhbmdlTWFwcGluZyA9IGxpbmVSYW5nZU1hcHBpbmcudG9SYW5nZU1hcHBpbmcyKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMpO1xuICAgICAgICBjb25zdCBzbGljZTEgPSBuZXcgTGluZXNTbGljZUNoYXJTZXF1ZW5jZShvcmlnaW5hbExpbmVzLCByYW5nZU1hcHBpbmcub3JpZ2luYWxSYW5nZSwgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcyk7XG4gICAgICAgIGNvbnN0IHNsaWNlMiA9IG5ldyBMaW5lc1NsaWNlQ2hhclNlcXVlbmNlKG1vZGlmaWVkTGluZXMsIHJhbmdlTWFwcGluZy5tb2RpZmllZFJhbmdlLCBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzKTtcbiAgICAgICAgY29uc3QgZGlmZlJlc3VsdCA9IHNsaWNlMS5sZW5ndGggKyBzbGljZTIubGVuZ3RoIDwgNTAwXG4gICAgICAgICAgICA/IHRoaXMuZHluYW1pY1Byb2dyYW1taW5nRGlmZmluZy5jb21wdXRlKHNsaWNlMSwgc2xpY2UyLCB0aW1lb3V0KVxuICAgICAgICAgICAgOiB0aGlzLm15ZXJzRGlmZmluZ0FsZ29yaXRobS5jb21wdXRlKHNsaWNlMSwgc2xpY2UyLCB0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgbGV0IGRpZmZzID0gZGlmZlJlc3VsdC5kaWZmcztcbiAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICBTZXF1ZW5jZURpZmYuYXNzZXJ0U29ydGVkKGRpZmZzKTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmcyA9IG9wdGltaXplU2VxdWVuY2VEaWZmcyhzbGljZTEsIHNsaWNlMiwgZGlmZnMpO1xuICAgICAgICBpZiAoY2hlY2spIHtcbiAgICAgICAgICAgIFNlcXVlbmNlRGlmZi5hc3NlcnRTb3J0ZWQoZGlmZnMpO1xuICAgICAgICB9XG4gICAgICAgIGRpZmZzID0gZXh0ZW5kRGlmZnNUb0VudGlyZVdvcmRJZkFwcHJvcHJpYXRlKHNsaWNlMSwgc2xpY2UyLCBkaWZmcyk7XG4gICAgICAgIGlmIChjaGVjaykge1xuICAgICAgICAgICAgU2VxdWVuY2VEaWZmLmFzc2VydFNvcnRlZChkaWZmcyk7XG4gICAgICAgIH1cbiAgICAgICAgZGlmZnMgPSByZW1vdmVTaG9ydE1hdGNoZXMoc2xpY2UxLCBzbGljZTIsIGRpZmZzKTtcbiAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICBTZXF1ZW5jZURpZmYuYXNzZXJ0U29ydGVkKGRpZmZzKTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmcyA9IHJlbW92ZVZlcnlTaG9ydE1hdGNoaW5nVGV4dEJldHdlZW5Mb25nRGlmZnMoc2xpY2UxLCBzbGljZTIsIGRpZmZzKTtcbiAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICBTZXF1ZW5jZURpZmYuYXNzZXJ0U29ydGVkKGRpZmZzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBkaWZmcy5tYXAoKGQpID0+IG5ldyBSYW5nZU1hcHBpbmcoc2xpY2UxLnRyYW5zbGF0ZVJhbmdlKGQuc2VxMVJhbmdlKSwgc2xpY2UyLnRyYW5zbGF0ZVJhbmdlKGQuc2VxMlJhbmdlKSkpO1xuICAgICAgICBpZiAoY2hlY2spIHtcbiAgICAgICAgICAgIFJhbmdlTWFwcGluZy5hc3NlcnRTb3J0ZWQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBc3NlcnQ6IHJlc3VsdCBhcHBsaWVkIG9uIG9yaWdpbmFsIHNob3VsZCBiZSB0aGUgc2FtZSBhcyBkaWZmIGFwcGxpZWQgdG8gb3JpZ2luYWxcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hcHBpbmdzOiByZXN1bHQsXG4gICAgICAgICAgICBoaXRUaW1lb3V0OiBkaWZmUmVzdWx0LmhpdFRpbWVvdXQsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVSYW5nZU1hcHBpbmdGcm9tUmFuZ2VNYXBwaW5ncyhhbGlnbm1lbnRzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBkb250QXNzZXJ0U3RhcnRMaW5lID0gZmFsc2UpIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBnIG9mIGdyb3VwQWRqYWNlbnRCeShhbGlnbm1lbnRzLm1hcChhID0+IGdldExpbmVSYW5nZU1hcHBpbmcoYSwgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcykpLCAoYTEsIGEyKSA9PiBhMS5vcmlnaW5hbC5vdmVybGFwT3JUb3VjaChhMi5vcmlnaW5hbClcbiAgICAgICAgfHwgYTEubW9kaWZpZWQub3ZlcmxhcE9yVG91Y2goYTIubW9kaWZpZWQpKSkge1xuICAgICAgICBjb25zdCBmaXJzdCA9IGdbMF07XG4gICAgICAgIGNvbnN0IGxhc3QgPSBnW2cubGVuZ3RoIC0gMV07XG4gICAgICAgIGNoYW5nZXMucHVzaChuZXcgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nKGZpcnN0Lm9yaWdpbmFsLmpvaW4obGFzdC5vcmlnaW5hbCksIGZpcnN0Lm1vZGlmaWVkLmpvaW4obGFzdC5tb2RpZmllZCksIGcubWFwKGEgPT4gYS5pbm5lckNoYW5nZXNbMF0pKSk7XG4gICAgfVxuICAgIGFzc2VydEZuKCgpID0+IHtcbiAgICAgICAgaWYgKCFkb250QXNzZXJ0U3RhcnRMaW5lICYmIGNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXNbMF0ubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyICE9PSBjaGFuZ2VzWzBdLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RpZmllZExpbmVzLmxlbmd0aCAtIGNoYW5nZXNbY2hhbmdlcy5sZW5ndGggLSAxXS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICE9PSBvcmlnaW5hbExpbmVzLmxlbmd0aCAtIGNoYW5nZXNbY2hhbmdlcy5sZW5ndGggLSAxXS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGVja0FkamFjZW50SXRlbXMoY2hhbmdlcywgKG0xLCBtMikgPT4gbTIub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIC0gbTEub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9PT0gbTIubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIC0gbTEubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAmJlxuICAgICAgICAgICAgLy8gVGhlcmUgaGFzIHRvIGJlIGFuIHVuY2hhbmdlZCBsaW5lIGluIGJldHdlZW4gKG90aGVyd2lzZSBib3RoIGRpZmZzIHNob3VsZCBoYXZlIGJlZW4gam9pbmVkKVxuICAgICAgICAgICAgbTEub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA8IG0yLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAmJlxuICAgICAgICAgICAgbTEubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA8IG0yLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGluZVJhbmdlTWFwcGluZyhyYW5nZU1hcHBpbmcsIG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMpIHtcbiAgICBsZXQgbGluZVN0YXJ0RGVsdGEgPSAwO1xuICAgIGxldCBsaW5lRW5kRGVsdGEgPSAwO1xuICAgIC8vIHJhbmdlTWFwcGluZyBkZXNjcmliZXMgdGhlIGVkaXQgdGhhdCByZXBsYWNlcyBgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2VgIHdpdGggYG5ld1RleHQgOj0gZ2V0VGV4dChtb2RpZmllZExpbmVzLCByYW5nZU1hcHBpbmcubW9kaWZpZWRSYW5nZSlgLlxuICAgIC8vIG9yaWdpbmFsOiBdeHh4IFxcbiA8LSB0aGlzIGxpbmUgaXMgbm90IG1vZGlmaWVkXG4gICAgLy8gbW9kaWZpZWQ6IF14eCAgXFxuXG4gICAgaWYgKHJhbmdlTWFwcGluZy5tb2RpZmllZFJhbmdlLmVuZENvbHVtbiA9PT0gMSAmJiByYW5nZU1hcHBpbmcub3JpZ2luYWxSYW5nZS5lbmRDb2x1bW4gPT09IDFcbiAgICAgICAgJiYgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICsgbGluZVN0YXJ0RGVsdGEgPD0gcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2UuZW5kTGluZU51bWJlclxuICAgICAgICAmJiByYW5nZU1hcHBpbmcubW9kaWZpZWRSYW5nZS5zdGFydExpbmVOdW1iZXIgKyBsaW5lU3RhcnREZWx0YSA8PSByYW5nZU1hcHBpbmcubW9kaWZpZWRSYW5nZS5lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGRvIHRoaXMgaWYgdGhlIHJhbmdlIGlzIG5vdCBlbXB0eSB5ZXRcbiAgICAgICAgbGluZUVuZERlbHRhID0gLTE7XG4gICAgfVxuICAgIC8vIG9yaWdpbmFsOiB4eHhbIFxcbiA8LSB0aGlzIGxpbmUgaXMgbm90IG1vZGlmaWVkXG4gICAgLy8gbW9kaWZpZWQ6IHh4eFsgXFxuXG4gICAgaWYgKHJhbmdlTWFwcGluZy5tb2RpZmllZFJhbmdlLnN0YXJ0Q29sdW1uIC0gMSA+PSBtb2RpZmllZExpbmVzW3JhbmdlTWFwcGluZy5tb2RpZmllZFJhbmdlLnN0YXJ0TGluZU51bWJlciAtIDFdLmxlbmd0aFxuICAgICAgICAmJiByYW5nZU1hcHBpbmcub3JpZ2luYWxSYW5nZS5zdGFydENvbHVtbiAtIDEgPj0gb3JpZ2luYWxMaW5lc1tyYW5nZU1hcHBpbmcub3JpZ2luYWxSYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxXS5sZW5ndGhcbiAgICAgICAgJiYgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDw9IHJhbmdlTWFwcGluZy5vcmlnaW5hbFJhbmdlLmVuZExpbmVOdW1iZXIgKyBsaW5lRW5kRGVsdGFcbiAgICAgICAgJiYgcmFuZ2VNYXBwaW5nLm1vZGlmaWVkUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDw9IHJhbmdlTWFwcGluZy5tb2RpZmllZFJhbmdlLmVuZExpbmVOdW1iZXIgKyBsaW5lRW5kRGVsdGEpIHtcbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgZG8gdGhpcyBpZiB0aGUgcmFuZ2UgaXMgbm90IGVtcHR5IHlldFxuICAgICAgICBsaW5lU3RhcnREZWx0YSA9IDE7XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsTGluZVJhbmdlID0gbmV3IExpbmVSYW5nZShyYW5nZU1hcHBpbmcub3JpZ2luYWxSYW5nZS5zdGFydExpbmVOdW1iZXIgKyBsaW5lU3RhcnREZWx0YSwgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2UuZW5kTGluZU51bWJlciArIDEgKyBsaW5lRW5kRGVsdGEpO1xuICAgIGNvbnN0IG1vZGlmaWVkTGluZVJhbmdlID0gbmV3IExpbmVSYW5nZShyYW5nZU1hcHBpbmcubW9kaWZpZWRSYW5nZS5zdGFydExpbmVOdW1iZXIgKyBsaW5lU3RhcnREZWx0YSwgcmFuZ2VNYXBwaW5nLm1vZGlmaWVkUmFuZ2UuZW5kTGluZU51bWJlciArIDEgKyBsaW5lRW5kRGVsdGEpO1xuICAgIHJldHVybiBuZXcgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nKG9yaWdpbmFsTGluZVJhbmdlLCBtb2RpZmllZExpbmVSYW5nZSwgW3JhbmdlTWFwcGluZ10pO1xufVxuZnVuY3Rpb24gdG9MaW5lUmFuZ2VNYXBwaW5nKHNlcXVlbmNlRGlmZikge1xuICAgIHJldHVybiBuZXcgTGluZVJhbmdlTWFwcGluZyhuZXcgTGluZVJhbmdlKHNlcXVlbmNlRGlmZi5zZXExUmFuZ2Uuc3RhcnQgKyAxLCBzZXF1ZW5jZURpZmYuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSArIDEpLCBuZXcgTGluZVJhbmdlKHNlcXVlbmNlRGlmZi5zZXEyUmFuZ2Uuc3RhcnQgKyAxLCBzZXF1ZW5jZURpZmYuc2VxMlJhbmdlLmVuZEV4Y2x1c2l2ZSArIDEpKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgZm9yRWFjaFdpdGhOZWlnaGJvcnMgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xuaW1wb3J0IHsgT2Zmc2V0UmFuZ2UgfSBmcm9tICcuLi8uLi9jb3JlL29mZnNldFJhbmdlLmpzJztcbmltcG9ydCB7IE9mZnNldFBhaXIsIFNlcXVlbmNlRGlmZiB9IGZyb20gJy4vYWxnb3JpdGhtcy9kaWZmQWxnb3JpdGhtLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBvcHRpbWl6ZVNlcXVlbmNlRGlmZnMoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcXVlbmNlRGlmZnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gc2VxdWVuY2VEaWZmcztcbiAgICByZXN1bHQgPSBqb2luU2VxdWVuY2VEaWZmc0J5U2hpZnRpbmcoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHJlc3VsdCk7XG4gICAgLy8gU29tZXRpbWVzLCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gdHdpY2UgaW1wcm92ZXMgdGhlIHJlc3VsdC5cbiAgICAvLyBVbmNvbW1lbnQgdGhlIHNlY29uZCBpbnZvY2F0aW9uIGFuZCBydW4gdGhlIHRlc3RzIHRvIHNlZSB0aGUgZGlmZmVyZW5jZS5cbiAgICByZXN1bHQgPSBqb2luU2VxdWVuY2VEaWZmc0J5U2hpZnRpbmcoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHJlc3VsdCk7XG4gICAgcmVzdWx0ID0gc2hpZnRTZXF1ZW5jZURpZmZzKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZml4ZXMgaXNzdWVzIGxpa2UgdGhpczpcbiAqIGBgYFxuICogaW1wb3J0IHsgQmF6LCBCYXIgfSBmcm9tIFwiZm9vXCI7XG4gKiBgYGBcbiAqIDwtPlxuICogYGBgXG4gKiBpbXBvcnQgeyBCYXosIEJhciwgRm9vIH0gZnJvbSBcImZvb1wiO1xuICogYGBgXG4gKiBDb21wdXRlZCBkaWZmOiBbIHtBZGQgXCIsXCIgYWZ0ZXIgQmFyfSwge0FkZCBcIkZvbyBcIiBhZnRlciBzcGFjZX0gfVxuICogSW1wcm92ZWQgZGlmZjogW3tBZGQgXCIsIEZvb1wiIGFmdGVyIEJhcn1dXG4gKi9cbmZ1bmN0aW9uIGpvaW5TZXF1ZW5jZURpZmZzQnlTaGlmdGluZyhzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgc2VxdWVuY2VEaWZmcykge1xuICAgIGlmIChzZXF1ZW5jZURpZmZzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VxdWVuY2VEaWZmcztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0LnB1c2goc2VxdWVuY2VEaWZmc1swXSk7XG4gICAgLy8gRmlyc3QgbW92ZSB0aGVtIGFsbCB0byB0aGUgbGVmdCBhcyBtdWNoIGFzIHBvc3NpYmxlIGFuZCBqb2luIHRoZW0gaWYgcG9zc2libGVcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNlcXVlbmNlRGlmZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldlJlc3VsdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBjdXIgPSBzZXF1ZW5jZURpZmZzW2ldO1xuICAgICAgICBpZiAoY3VyLnNlcTFSYW5nZS5pc0VtcHR5IHx8IGN1ci5zZXEyUmFuZ2UuaXNFbXB0eSkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gY3VyLnNlcTFSYW5nZS5zdGFydCAtIHByZXZSZXN1bHQuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZTtcbiAgICAgICAgICAgIGxldCBkO1xuICAgICAgICAgICAgZm9yIChkID0gMTsgZCA8PSBsZW5ndGg7IGQrKykge1xuICAgICAgICAgICAgICAgIGlmIChzZXF1ZW5jZTEuZ2V0RWxlbWVudChjdXIuc2VxMVJhbmdlLnN0YXJ0IC0gZCkgIT09IHNlcXVlbmNlMS5nZXRFbGVtZW50KGN1ci5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlIC0gZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2UyLmdldEVsZW1lbnQoY3VyLnNlcTJSYW5nZS5zdGFydCAtIGQpICE9PSBzZXF1ZW5jZTIuZ2V0RWxlbWVudChjdXIuc2VxMlJhbmdlLmVuZEV4Y2x1c2l2ZSAtIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQtLTtcbiAgICAgICAgICAgIGlmIChkID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBwcmV2aW91cyBhbmQgY3VycmVudCBkaWZmXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IG5ldyBTZXF1ZW5jZURpZmYobmV3IE9mZnNldFJhbmdlKHByZXZSZXN1bHQuc2VxMVJhbmdlLnN0YXJ0LCBjdXIuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSAtIGxlbmd0aCksIG5ldyBPZmZzZXRSYW5nZShwcmV2UmVzdWx0LnNlcTJSYW5nZS5zdGFydCwgY3VyLnNlcTJSYW5nZS5lbmRFeGNsdXNpdmUgLSBsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGN1ci5kZWx0YSgtZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY3VyKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0MiA9IFtdO1xuICAgIC8vIFRoZW4gbW92ZSB0aGVtIGFsbCB0byB0aGUgcmlnaHQgYW5kIGpvaW4gdGhlbSBhZ2FpbiBpZiBwb3NzaWJsZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCBuZXh0UmVzdWx0ID0gcmVzdWx0W2kgKyAxXTtcbiAgICAgICAgbGV0IGN1ciA9IHJlc3VsdFtpXTtcbiAgICAgICAgaWYgKGN1ci5zZXExUmFuZ2UuaXNFbXB0eSB8fCBjdXIuc2VxMlJhbmdlLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG5leHRSZXN1bHQuc2VxMVJhbmdlLnN0YXJ0IC0gY3VyLnNlcTFSYW5nZS5lbmRFeGNsdXNpdmU7XG4gICAgICAgICAgICBsZXQgZDtcbiAgICAgICAgICAgIGZvciAoZCA9IDA7IGQgPCBsZW5ndGg7IGQrKykge1xuICAgICAgICAgICAgICAgIGlmICghc2VxdWVuY2UxLmlzU3Ryb25nbHlFcXVhbChjdXIuc2VxMVJhbmdlLnN0YXJ0ICsgZCwgY3VyLnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUgKyBkKSB8fFxuICAgICAgICAgICAgICAgICAgICAhc2VxdWVuY2UyLmlzU3Ryb25nbHlFcXVhbChjdXIuc2VxMlJhbmdlLnN0YXJ0ICsgZCwgY3VyLnNlcTJSYW5nZS5lbmRFeGNsdXNpdmUgKyBkKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgcHJldmlvdXMgYW5kIGN1cnJlbnQgZGlmZiwgd3JpdGUgdG8gcmVzdWx0IVxuICAgICAgICAgICAgICAgIHJlc3VsdFtpICsgMV0gPSBuZXcgU2VxdWVuY2VEaWZmKG5ldyBPZmZzZXRSYW5nZShjdXIuc2VxMVJhbmdlLnN0YXJ0ICsgbGVuZ3RoLCBuZXh0UmVzdWx0LnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUpLCBuZXcgT2Zmc2V0UmFuZ2UoY3VyLnNlcTJSYW5nZS5zdGFydCArIGxlbmd0aCwgbmV4dFJlc3VsdC5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIuZGVsdGEoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Mi5wdXNoKGN1cik7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQyLnB1c2gocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xufVxuLy8gYWxpZ24gY2hhcmFjdGVyIGxldmVsIGRpZmZzIGF0IHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuLy8gaW1wb3J0IHsgSUJhciB9IGZyb20gXCJmb29cIjtcbi8vIGltcG9ydCB7IElbQXJyLCBJXUJhciB9IGZyb20gXCJmb29cIjtcbi8vIC0+XG4vLyBpbXBvcnQgeyBbSUFyciwgXUlCYXIgfSBmcm9tIFwiZm9vXCI7XG4vLyBpbXBvcnQgeyBJVHJhbnNhY3Rpb24sIG9ic2VydmFibGVWYWx1ZSwgdHJhbnNhY3Rpb24gfSBmcm9tICd2cy9iYXNlL2NvbW1vbi9vYnNlcnZhYmxlJztcbi8vIGltcG9ydCB7IElUcmFuc2FjdGlvbiwgb2JzZXJ2YWJsZVtGcm9tRXZlbnQsIG9ic2VydmFibGVdVmFsdWUsIHRyYW5zYWN0aW9uIH0gZnJvbSAndnMvYmFzZS9jb21tb24vb2JzZXJ2YWJsZSc7XG4vLyAtPlxuLy8gaW1wb3J0IHsgSVRyYW5zYWN0aW9uLCBbb2JzZXJ2YWJsZUZyb21FdmVudCwgXW9ic2VydmFibGVWYWx1ZSwgdHJhbnNhY3Rpb24gfSBmcm9tICd2cy9iYXNlL2NvbW1vbi9vYnNlcnZhYmxlJztcbi8vIGNvbGxlY3RCcmFja2V0cyhsZXZlbCArIDEsIGxldmVsUGVyQnJhY2tldFR5cGUpO1xuLy8gY29sbGVjdEJyYWNrZXRzKGxldmVsICsgMSwgbGV2ZWxQZXJCcmFja2V0WyArIDEsIGxldmVsUGVyQnJhY2tldF1UeXBlKTtcbi8vIC0+XG4vLyBjb2xsZWN0QnJhY2tldHMobGV2ZWwgKyAxLCBbbGV2ZWxQZXJCcmFja2V0ICsgMSwgXWxldmVsUGVyQnJhY2tldFR5cGUpO1xuZnVuY3Rpb24gc2hpZnRTZXF1ZW5jZURpZmZzKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCBzZXF1ZW5jZURpZmZzKSB7XG4gICAgaWYgKCFzZXF1ZW5jZTEuZ2V0Qm91bmRhcnlTY29yZSB8fCAhc2VxdWVuY2UyLmdldEJvdW5kYXJ5U2NvcmUpIHtcbiAgICAgICAgcmV0dXJuIHNlcXVlbmNlRGlmZnM7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxdWVuY2VEaWZmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2RGlmZiA9IChpID4gMCA/IHNlcXVlbmNlRGlmZnNbaSAtIDFdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgZGlmZiA9IHNlcXVlbmNlRGlmZnNbaV07XG4gICAgICAgIGNvbnN0IG5leHREaWZmID0gKGkgKyAxIDwgc2VxdWVuY2VEaWZmcy5sZW5ndGggPyBzZXF1ZW5jZURpZmZzW2kgKyAxXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IHNlcTFWYWxpZFJhbmdlID0gbmV3IE9mZnNldFJhbmdlKHByZXZEaWZmID8gcHJldkRpZmYuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSArIDEgOiAwLCBuZXh0RGlmZiA/IG5leHREaWZmLnNlcTFSYW5nZS5zdGFydCAtIDEgOiBzZXF1ZW5jZTEubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgc2VxMlZhbGlkUmFuZ2UgPSBuZXcgT2Zmc2V0UmFuZ2UocHJldkRpZmYgPyBwcmV2RGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgMSA6IDAsIG5leHREaWZmID8gbmV4dERpZmYuc2VxMlJhbmdlLnN0YXJ0IC0gMSA6IHNlcXVlbmNlMi5sZW5ndGgpO1xuICAgICAgICBpZiAoZGlmZi5zZXExUmFuZ2UuaXNFbXB0eSkge1xuICAgICAgICAgICAgc2VxdWVuY2VEaWZmc1tpXSA9IHNoaWZ0RGlmZlRvQmV0dGVyUG9zaXRpb24oZGlmZiwgc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcTFWYWxpZFJhbmdlLCBzZXEyVmFsaWRSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlmZi5zZXEyUmFuZ2UuaXNFbXB0eSkge1xuICAgICAgICAgICAgc2VxdWVuY2VEaWZmc1tpXSA9IHNoaWZ0RGlmZlRvQmV0dGVyUG9zaXRpb24oZGlmZi5zd2FwKCksIHNlcXVlbmNlMiwgc2VxdWVuY2UxLCBzZXEyVmFsaWRSYW5nZSwgc2VxMVZhbGlkUmFuZ2UpLnN3YXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VxdWVuY2VEaWZmcztcbn1cbmZ1bmN0aW9uIHNoaWZ0RGlmZlRvQmV0dGVyUG9zaXRpb24oZGlmZiwgc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcTFWYWxpZFJhbmdlLCBzZXEyVmFsaWRSYW5nZSkge1xuICAgIGNvbnN0IG1heFNoaWZ0TGltaXQgPSAxMDA7IC8vIFRvIHByZXZlbnQgcGVyZm9ybWFuY2UgaXNzdWVzXG4gICAgLy8gZG9uJ3QgdG91Y2ggcHJldmlvdXMgb3IgbmV4dCFcbiAgICBsZXQgZGVsdGFCZWZvcmUgPSAxO1xuICAgIHdoaWxlIChkaWZmLnNlcTFSYW5nZS5zdGFydCAtIGRlbHRhQmVmb3JlID49IHNlcTFWYWxpZFJhbmdlLnN0YXJ0ICYmXG4gICAgICAgIGRpZmYuc2VxMlJhbmdlLnN0YXJ0IC0gZGVsdGFCZWZvcmUgPj0gc2VxMlZhbGlkUmFuZ2Uuc3RhcnQgJiZcbiAgICAgICAgc2VxdWVuY2UyLmlzU3Ryb25nbHlFcXVhbChkaWZmLnNlcTJSYW5nZS5zdGFydCAtIGRlbHRhQmVmb3JlLCBkaWZmLnNlcTJSYW5nZS5lbmRFeGNsdXNpdmUgLSBkZWx0YUJlZm9yZSkgJiYgZGVsdGFCZWZvcmUgPCBtYXhTaGlmdExpbWl0KSB7XG4gICAgICAgIGRlbHRhQmVmb3JlKys7XG4gICAgfVxuICAgIGRlbHRhQmVmb3JlLS07XG4gICAgbGV0IGRlbHRhQWZ0ZXIgPSAwO1xuICAgIHdoaWxlIChkaWZmLnNlcTFSYW5nZS5zdGFydCArIGRlbHRhQWZ0ZXIgPCBzZXExVmFsaWRSYW5nZS5lbmRFeGNsdXNpdmUgJiZcbiAgICAgICAgZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgZGVsdGFBZnRlciA8IHNlcTJWYWxpZFJhbmdlLmVuZEV4Y2x1c2l2ZSAmJlxuICAgICAgICBzZXF1ZW5jZTIuaXNTdHJvbmdseUVxdWFsKGRpZmYuc2VxMlJhbmdlLnN0YXJ0ICsgZGVsdGFBZnRlciwgZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgZGVsdGFBZnRlcikgJiYgZGVsdGFBZnRlciA8IG1heFNoaWZ0TGltaXQpIHtcbiAgICAgICAgZGVsdGFBZnRlcisrO1xuICAgIH1cbiAgICBpZiAoZGVsdGFCZWZvcmUgPT09IDAgJiYgZGVsdGFBZnRlciA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gICAgLy8gVmlzdWFsaXplIGBbc2VxdWVuY2UxLnRleHQsIGRpZmYuc2VxMVJhbmdlLnN0YXJ0ICsgZGVsdGFBZnRlcl1gXG4gICAgLy8gYW5kIGBbc2VxdWVuY2UyLnRleHQsIGRpZmYuc2VxMlJhbmdlLnN0YXJ0ICsgZGVsdGFBZnRlciwgZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgZGVsdGFBZnRlcl1gXG4gICAgbGV0IGJlc3REZWx0YSA9IDA7XG4gICAgbGV0IGJlc3RTY29yZSA9IC0xO1xuICAgIC8vIGZpbmQgYmVzdCBzY29yZWQgZGVsdGFcbiAgICBmb3IgKGxldCBkZWx0YSA9IC1kZWx0YUJlZm9yZTsgZGVsdGEgPD0gZGVsdGFBZnRlcjsgZGVsdGErKykge1xuICAgICAgICBjb25zdCBzZXEyT2Zmc2V0U3RhcnQgPSBkaWZmLnNlcTJSYW5nZS5zdGFydCArIGRlbHRhO1xuICAgICAgICBjb25zdCBzZXEyT2Zmc2V0RW5kRXhjbHVzaXZlID0gZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgZGVsdGE7XG4gICAgICAgIGNvbnN0IHNlcTFPZmZzZXQgPSBkaWZmLnNlcTFSYW5nZS5zdGFydCArIGRlbHRhO1xuICAgICAgICBjb25zdCBzY29yZSA9IHNlcXVlbmNlMS5nZXRCb3VuZGFyeVNjb3JlKHNlcTFPZmZzZXQpICsgc2VxdWVuY2UyLmdldEJvdW5kYXJ5U2NvcmUoc2VxMk9mZnNldFN0YXJ0KSArIHNlcXVlbmNlMi5nZXRCb3VuZGFyeVNjb3JlKHNlcTJPZmZzZXRFbmRFeGNsdXNpdmUpO1xuICAgICAgICBpZiAoc2NvcmUgPiBiZXN0U2NvcmUpIHtcbiAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgYmVzdERlbHRhID0gZGVsdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmYuZGVsdGEoYmVzdERlbHRhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVTaG9ydE1hdGNoZXMoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcXVlbmNlRGlmZnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHMgb2Ygc2VxdWVuY2VEaWZmcykge1xuICAgICAgICBjb25zdCBsYXN0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLnNlcTFSYW5nZS5zdGFydCAtIGxhc3Quc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSA8PSAyIHx8IHMuc2VxMlJhbmdlLnN0YXJ0IC0gbGFzdC5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlIDw9IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBuZXcgU2VxdWVuY2VEaWZmKGxhc3Quc2VxMVJhbmdlLmpvaW4ocy5zZXExUmFuZ2UpLCBsYXN0LnNlcTJSYW5nZS5qb2luKHMuc2VxMlJhbmdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZERpZmZzVG9FbnRpcmVXb3JkSWZBcHByb3ByaWF0ZShzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgc2VxdWVuY2VEaWZmcykge1xuICAgIGNvbnN0IGVxdWFsTWFwcGluZ3MgPSBTZXF1ZW5jZURpZmYuaW52ZXJ0KHNlcXVlbmNlRGlmZnMsIHNlcXVlbmNlMS5sZW5ndGgpO1xuICAgIGNvbnN0IGFkZGl0aW9uYWwgPSBbXTtcbiAgICBsZXQgbGFzdFBvaW50ID0gbmV3IE9mZnNldFBhaXIoMCwgMCk7XG4gICAgZnVuY3Rpb24gc2NhbldvcmQocGFpciwgZXF1YWxNYXBwaW5nKSB7XG4gICAgICAgIGlmIChwYWlyLm9mZnNldDEgPCBsYXN0UG9pbnQub2Zmc2V0MSB8fCBwYWlyLm9mZnNldDIgPCBsYXN0UG9pbnQub2Zmc2V0Mikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHcxID0gc2VxdWVuY2UxLmZpbmRXb3JkQ29udGFpbmluZyhwYWlyLm9mZnNldDEpO1xuICAgICAgICBjb25zdCB3MiA9IHNlcXVlbmNlMi5maW5kV29yZENvbnRhaW5pbmcocGFpci5vZmZzZXQyKTtcbiAgICAgICAgaWYgKCF3MSB8fCAhdzIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdyA9IG5ldyBTZXF1ZW5jZURpZmYodzEsIHcyKTtcbiAgICAgICAgY29uc3QgZXF1YWxQYXJ0ID0gdy5pbnRlcnNlY3QoZXF1YWxNYXBwaW5nKTtcbiAgICAgICAgbGV0IGVxdWFsQ2hhcnMxID0gZXF1YWxQYXJ0LnNlcTFSYW5nZS5sZW5ndGg7XG4gICAgICAgIGxldCBlcXVhbENoYXJzMiA9IGVxdWFsUGFydC5zZXEyUmFuZ2UubGVuZ3RoO1xuICAgICAgICAvLyBUaGUgd29yZHMgZG8gbm90IHRvdWNoIHByZXZpb3VzIGVxdWFscyBtYXBwaW5ncywgYXMgd2Ugd291bGQgaGF2ZSBwcm9jZXNzZWQgdGhlbSBhbHJlYWR5LlxuICAgICAgICAvLyBCdXQgdGhleSBtaWdodCB0b3VjaCB0aGUgbmV4dCBvbmVzLlxuICAgICAgICB3aGlsZSAoZXF1YWxNYXBwaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gZXF1YWxNYXBwaW5nc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdHMgPSBuZXh0LnNlcTFSYW5nZS5pbnRlcnNlY3RzKHcuc2VxMVJhbmdlKSB8fCBuZXh0LnNlcTJSYW5nZS5pbnRlcnNlY3RzKHcuc2VxMlJhbmdlKTtcbiAgICAgICAgICAgIGlmICghaW50ZXJzZWN0cykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdjEgPSBzZXF1ZW5jZTEuZmluZFdvcmRDb250YWluaW5nKG5leHQuc2VxMVJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IHYyID0gc2VxdWVuY2UyLmZpbmRXb3JkQ29udGFpbmluZyhuZXh0LnNlcTJSYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbiwgd2Uga25vdyB0aGF0IHRoZSB3b3JkcyBhcmUgbm90IGVtcHR5LlxuICAgICAgICAgICAgY29uc3QgdiA9IG5ldyBTZXF1ZW5jZURpZmYodjEsIHYyKTtcbiAgICAgICAgICAgIGNvbnN0IGVxdWFsUGFydCA9IHYuaW50ZXJzZWN0KG5leHQpO1xuICAgICAgICAgICAgZXF1YWxDaGFyczEgKz0gZXF1YWxQYXJ0LnNlcTFSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICBlcXVhbENoYXJzMiArPSBlcXVhbFBhcnQuc2VxMlJhbmdlLmxlbmd0aDtcbiAgICAgICAgICAgIHcgPSB3LmpvaW4odik7XG4gICAgICAgICAgICBpZiAody5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlID49IG5leHQuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JkIGV4dGVuZHMgYmV5b25kIHRoZSBuZXh0IGVxdWFsIG1hcHBpbmcuXG4gICAgICAgICAgICAgICAgZXF1YWxNYXBwaW5ncy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVxdWFsQ2hhcnMxICsgZXF1YWxDaGFyczIgPCAody5zZXExUmFuZ2UubGVuZ3RoICsgdy5zZXEyUmFuZ2UubGVuZ3RoKSAqIDIgLyAzKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsLnB1c2godyk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBvaW50ID0gdy5nZXRFbmRFeGNsdXNpdmVzKCk7XG4gICAgfVxuICAgIHdoaWxlIChlcXVhbE1hcHBpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGVxdWFsTWFwcGluZ3Muc2hpZnQoKTtcbiAgICAgICAgaWYgKG5leHQuc2VxMVJhbmdlLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNjYW5Xb3JkKG5leHQuZ2V0U3RhcnRzKCksIG5leHQpO1xuICAgICAgICAvLyBUaGUgZXF1YWwgcGFydHMgYXJlIG5vdCBlbXB0eSwgc28gLTEgZ2l2ZXMgdXMgYSBjaGFyYWN0ZXIgdGhhdCBpcyBlcXVhbCBpbiBib3RoIHBhcnRzLlxuICAgICAgICBzY2FuV29yZChuZXh0LmdldEVuZEV4Y2x1c2l2ZXMoKS5kZWx0YSgtMSksIG5leHQpO1xuICAgIH1cbiAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVNlcXVlbmNlRGlmZnMoc2VxdWVuY2VEaWZmcywgYWRkaXRpb25hbCk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlU2VxdWVuY2VEaWZmcyhzZXF1ZW5jZURpZmZzMSwgc2VxdWVuY2VEaWZmczIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoc2VxdWVuY2VEaWZmczEubGVuZ3RoID4gMCB8fCBzZXF1ZW5jZURpZmZzMi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHNkMSA9IHNlcXVlbmNlRGlmZnMxWzBdO1xuICAgICAgICBjb25zdCBzZDIgPSBzZXF1ZW5jZURpZmZzMlswXTtcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIGlmIChzZDEgJiYgKCFzZDIgfHwgc2QxLnNlcTFSYW5nZS5zdGFydCA8IHNkMi5zZXExUmFuZ2Uuc3RhcnQpKSB7XG4gICAgICAgICAgICBuZXh0ID0gc2VxdWVuY2VEaWZmczEuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHQgPSBzZXF1ZW5jZURpZmZzMi5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUgPj0gbmV4dC5zZXExUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLmpvaW4obmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVZlcnlTaG9ydE1hdGNoaW5nTGluZXNCZXR3ZWVuRGlmZnMoc2VxdWVuY2UxLCBfc2VxdWVuY2UyLCBzZXF1ZW5jZURpZmZzKSB7XG4gICAgbGV0IGRpZmZzID0gc2VxdWVuY2VEaWZmcztcbiAgICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkaWZmcztcbiAgICB9XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGxldCBzaG91bGRSZXBlYXQ7XG4gICAgZG8ge1xuICAgICAgICBzaG91bGRSZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW1xuICAgICAgICAgICAgZGlmZnNbMF1cbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyID0gZGlmZnNbaV07XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVzdWx0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZEpvaW5EaWZmcyhiZWZvcmUsIGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5jaGFuZ2VkUmFuZ2UgPSBuZXcgT2Zmc2V0UmFuZ2UobGFzdFJlc3VsdC5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlLCBjdXIuc2VxMVJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmNoYW5nZWRUZXh0ID0gc2VxdWVuY2UxLmdldFRleHQodW5jaGFuZ2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZFRleHRXaXRob3V0V3MgPSB1bmNoYW5nZWRUZXh0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHVuY2hhbmdlZFRleHRXaXRob3V0V3MubGVuZ3RoIDw9IDRcbiAgICAgICAgICAgICAgICAgICAgJiYgKGJlZm9yZS5zZXExUmFuZ2UubGVuZ3RoICsgYmVmb3JlLnNlcTJSYW5nZS5sZW5ndGggPiA1IHx8IGFmdGVyLnNlcTFSYW5nZS5sZW5ndGggKyBhZnRlci5zZXEyUmFuZ2UubGVuZ3RoID4gNSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEpvaW4gPSBzaG91bGRKb2luRGlmZnMobGFzdFJlc3VsdCwgY3VyKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRKb2luKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkUmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5qb2luKGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpZmZzID0gcmVzdWx0O1xuICAgIH0gd2hpbGUgKGNvdW50ZXIrKyA8IDEwICYmIHNob3VsZFJlcGVhdCk7XG4gICAgcmV0dXJuIGRpZmZzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVZlcnlTaG9ydE1hdGNoaW5nVGV4dEJldHdlZW5Mb25nRGlmZnMoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcXVlbmNlRGlmZnMpIHtcbiAgICBsZXQgZGlmZnMgPSBzZXF1ZW5jZURpZmZzO1xuICAgIGlmIChkaWZmcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGRpZmZzO1xuICAgIH1cbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgbGV0IHNob3VsZFJlcGVhdDtcbiAgICBkbyB7XG4gICAgICAgIHNob3VsZFJlcGVhdCA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXG4gICAgICAgICAgICBkaWZmc1swXVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRpZmZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXIgPSBkaWZmc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSZXN1bHQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgZnVuY3Rpb24gc2hvdWxkSm9pbkRpZmZzKGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmNoYW5nZWRSYW5nZSA9IG5ldyBPZmZzZXRSYW5nZShsYXN0UmVzdWx0LnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUsIGN1ci5zZXExUmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZExpbmVDb3VudCA9IHNlcXVlbmNlMS5jb3VudExpbmVzSW4odW5jaGFuZ2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmICh1bmNoYW5nZWRMaW5lQ291bnQgPiA1IHx8IHVuY2hhbmdlZFJhbmdlLmxlbmd0aCA+IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZFRleHQgPSBzZXF1ZW5jZTEuZ2V0VGV4dCh1bmNoYW5nZWRSYW5nZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmICh1bmNoYW5nZWRUZXh0Lmxlbmd0aCA+IDIwIHx8IHVuY2hhbmdlZFRleHQuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZUxpbmVDb3VudDEgPSBzZXF1ZW5jZTEuY291bnRMaW5lc0luKGJlZm9yZS5zZXExUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZVNlcTFMZW5ndGggPSBiZWZvcmUuc2VxMVJhbmdlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVMaW5lQ291bnQyID0gc2VxdWVuY2UyLmNvdW50TGluZXNJbihiZWZvcmUuc2VxMlJhbmdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVTZXEyTGVuZ3RoID0gYmVmb3JlLnNlcTJSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJMaW5lQ291bnQxID0gc2VxdWVuY2UxLmNvdW50TGluZXNJbihhZnRlci5zZXExUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyU2VxMUxlbmd0aCA9IGFmdGVyLnNlcTFSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJMaW5lQ291bnQyID0gc2VxdWVuY2UyLmNvdW50TGluZXNJbihhZnRlci5zZXEyUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyU2VxMkxlbmd0aCA9IGFmdGVyLnNlcTJSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYSBuZXVyYWwgbmV0IGNhbiBiZSB1c2VkIHRvIGRlcml2ZSB0aGUgcmVzdWx0IGZyb20gdGhlc2UgbnVtYmVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IDIgKiA0MCArIDUwO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhcCh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih2LCBtYXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5wb3coTWF0aC5wb3coY2FwKGJlZm9yZUxpbmVDb3VudDEgKiA0MCArIGJlZm9yZVNlcTFMZW5ndGgpLCAxLjUpICsgTWF0aC5wb3coY2FwKGJlZm9yZUxpbmVDb3VudDIgKiA0MCArIGJlZm9yZVNlcTJMZW5ndGgpLCAxLjUpLCAxLjUpXG4gICAgICAgICAgICAgICAgICAgICsgTWF0aC5wb3coTWF0aC5wb3coY2FwKGFmdGVyTGluZUNvdW50MSAqIDQwICsgYWZ0ZXJTZXExTGVuZ3RoKSwgMS41KSArIE1hdGgucG93KGNhcChhZnRlckxpbmVDb3VudDIgKiA0MCArIGFmdGVyU2VxMkxlbmd0aCksIDEuNSksIDEuNSkgPiAoKG1heCAqKiAxLjUpICoqIDEuNSkgKiAxLjMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEpvaW4gPSBzaG91bGRKb2luRGlmZnMobGFzdFJlc3VsdCwgY3VyKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRKb2luKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkUmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5qb2luKGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpZmZzID0gcmVzdWx0O1xuICAgIH0gd2hpbGUgKGNvdW50ZXIrKyA8IDEwICYmIHNob3VsZFJlcGVhdCk7XG4gICAgY29uc3QgbmV3RGlmZnMgPSBbXTtcbiAgICAvLyBSZW1vdmUgc2hvcnQgc3VmZml4ZXMvcHJlZml4ZXNcbiAgICBmb3JFYWNoV2l0aE5laWdoYm9ycyhkaWZmcywgKHByZXYsIGN1ciwgbmV4dCkgPT4ge1xuICAgICAgICBsZXQgbmV3RGlmZiA9IGN1cjtcbiAgICAgICAgZnVuY3Rpb24gc2hvdWxkTWFya0FzQ2hhbmdlZCh0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGggPiAwICYmIHRleHQudHJpbSgpLmxlbmd0aCA8PSAzICYmIGN1ci5zZXExUmFuZ2UubGVuZ3RoICsgY3VyLnNlcTJSYW5nZS5sZW5ndGggPiAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVsbFJhbmdlMSA9IHNlcXVlbmNlMS5leHRlbmRUb0Z1bGxMaW5lcyhjdXIuc2VxMVJhbmdlKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc2VxdWVuY2UxLmdldFRleHQobmV3IE9mZnNldFJhbmdlKGZ1bGxSYW5nZTEuc3RhcnQsIGN1ci5zZXExUmFuZ2Uuc3RhcnQpKTtcbiAgICAgICAgaWYgKHNob3VsZE1hcmtBc0NoYW5nZWQocHJlZml4KSkge1xuICAgICAgICAgICAgbmV3RGlmZiA9IG5ld0RpZmYuZGVsdGFTdGFydCgtcHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VmZml4ID0gc2VxdWVuY2UxLmdldFRleHQobmV3IE9mZnNldFJhbmdlKGN1ci5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlLCBmdWxsUmFuZ2UxLmVuZEV4Y2x1c2l2ZSkpO1xuICAgICAgICBpZiAoc2hvdWxkTWFya0FzQ2hhbmdlZChzdWZmaXgpKSB7XG4gICAgICAgICAgICBuZXdEaWZmID0gbmV3RGlmZi5kZWx0YUVuZChzdWZmaXgubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdmFpbGFibGVTcGFjZSA9IFNlcXVlbmNlRGlmZi5mcm9tT2Zmc2V0UGFpcnMocHJldiA/IHByZXYuZ2V0RW5kRXhjbHVzaXZlcygpIDogT2Zmc2V0UGFpci56ZXJvLCBuZXh0ID8gbmV4dC5nZXRTdGFydHMoKSA6IE9mZnNldFBhaXIubWF4KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3RGlmZi5pbnRlcnNlY3QoYXZhaWxhYmxlU3BhY2UpO1xuICAgICAgICBpZiAobmV3RGlmZnMubGVuZ3RoID4gMCAmJiByZXN1bHQuZ2V0U3RhcnRzKCkuZXF1YWxzKG5ld0RpZmZzW25ld0RpZmZzLmxlbmd0aCAtIDFdLmdldEVuZEV4Y2x1c2l2ZXMoKSkpIHtcbiAgICAgICAgICAgIG5ld0RpZmZzW25ld0RpZmZzLmxlbmd0aCAtIDFdID0gbmV3RGlmZnNbbmV3RGlmZnMubGVuZ3RoIC0gMV0uam9pbihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3RGlmZnMucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0RpZmZzO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgY2xhc3MgTGluZVNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmltbWVkSGFzaCwgbGluZXMpIHtcbiAgICAgICAgdGhpcy50cmltbWVkSGFzaCA9IHRyaW1tZWRIYXNoO1xuICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgfVxuICAgIGdldEVsZW1lbnQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaW1tZWRIYXNoW29mZnNldF07XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaW1tZWRIYXNoLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0Qm91bmRhcnlTY29yZShsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaW5kZW50YXRpb25CZWZvcmUgPSBsZW5ndGggPT09IDAgPyAwIDogZ2V0SW5kZW50YXRpb24odGhpcy5saW5lc1tsZW5ndGggLSAxXSk7XG4gICAgICAgIGNvbnN0IGluZGVudGF0aW9uQWZ0ZXIgPSBsZW5ndGggPT09IHRoaXMubGluZXMubGVuZ3RoID8gMCA6IGdldEluZGVudGF0aW9uKHRoaXMubGluZXNbbGVuZ3RoXSk7XG4gICAgICAgIHJldHVybiAxMDAwIC0gKGluZGVudGF0aW9uQmVmb3JlICsgaW5kZW50YXRpb25BZnRlcik7XG4gICAgfVxuICAgIGdldFRleHQocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXMuc2xpY2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZEV4Y2x1c2l2ZSkuam9pbignXFxuJyk7XG4gICAgfVxuICAgIGlzU3Ryb25nbHlFcXVhbChvZmZzZXQxLCBvZmZzZXQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVzW29mZnNldDFdID09PSB0aGlzLmxpbmVzW29mZnNldDJdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uKHN0cikge1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGggJiYgKHN0ci5jaGFyQ29kZUF0KGkpID09PSAzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLyB8fCBzdHIuY2hhckNvZGVBdChpKSA9PT0gOSAvKiBDaGFyQ29kZS5UYWIgKi8pKSB7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGZpbmRMYXN0SWR4TW9ub3Rvbm91cywgZmluZExhc3RNb25vdG9ub3VzLCBmaW5kRmlyc3RNb25vdG9ub3VzIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzRmluZC5qcyc7XG5pbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4uLy4uL2NvcmUvb2Zmc2V0UmFuZ2UuanMnO1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuLi8uLi9jb3JlL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9yYW5nZS5qcyc7XG5pbXBvcnQgeyBpc1NwYWNlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgY2xhc3MgTGluZXNTbGljZUNoYXJTZXF1ZW5jZSB7XG4gICAgY29uc3RydWN0b3IobGluZXMsIHJhbmdlLCBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICB0aGlzLmNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMgPSBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuZmlyc3RFbGVtZW50T2Zmc2V0QnlMaW5lSWR4ID0gW107XG4gICAgICAgIHRoaXMubGluZVN0YXJ0T2Zmc2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyaW1tZWRXc0xlbmd0aHNCeUxpbmVJZHggPSBbXTtcbiAgICAgICAgdGhpcy5maXJzdEVsZW1lbnRPZmZzZXRCeUxpbmVJZHgucHVzaCgwKTtcbiAgICAgICAgZm9yIChsZXQgbGluZU51bWJlciA9IHRoaXMucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyIDw9IHRoaXMucmFuZ2UuZW5kTGluZU51bWJlcjsgbGluZU51bWJlcisrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGxpbmVzW2xpbmVOdW1iZXIgLSAxXTtcbiAgICAgICAgICAgIGxldCBsaW5lU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXIgPT09IHRoaXMucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIHRoaXMucmFuZ2Uuc3RhcnRDb2x1bW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0T2Zmc2V0ID0gdGhpcy5yYW5nZS5zdGFydENvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKGxpbmVTdGFydE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxpbmVTdGFydE9mZnNldHMucHVzaChsaW5lU3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IHRyaW1tZWRXc0xlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoIWNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkU3RhcnRMaW5lID0gbGluZS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB0cmltbWVkV3NMZW5ndGggPSBsaW5lLmxlbmd0aCAtIHRyaW1tZWRTdGFydExpbmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxpbmUgPSB0cmltbWVkU3RhcnRMaW5lLnRyaW1FbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJpbW1lZFdzTGVuZ3Roc0J5TGluZUlkeC5wdXNoKHRyaW1tZWRXc0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZU51bWJlciA9PT0gdGhpcy5yYW5nZS5lbmRMaW5lTnVtYmVyID8gTWF0aC5taW4odGhpcy5yYW5nZS5lbmRDb2x1bW4gLSAxIC0gbGluZVN0YXJ0T2Zmc2V0IC0gdHJpbW1lZFdzTGVuZ3RoLCBsaW5lLmxlbmd0aCkgOiBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKGxpbmUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZU51bWJlciA8IHRoaXMucmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMucHVzaCgnXFxuJy5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0RWxlbWVudE9mZnNldEJ5TGluZUlkeC5wdXNoKHRoaXMuZWxlbWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBTbGljZTogXCIke3RoaXMudGV4dH1cImA7XG4gICAgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KG5ldyBPZmZzZXRSYW5nZSgwLCB0aGlzLmxlbmd0aCkpO1xuICAgIH1cbiAgICBnZXRUZXh0KHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLnNsaWNlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmRFeGNsdXNpdmUpLm1hcChlID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpLmpvaW4oJycpO1xuICAgIH1cbiAgICBnZXRFbGVtZW50KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c1tvZmZzZXRdO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldEJvdW5kYXJ5U2NvcmUobGVuZ3RoKSB7XG4gICAgICAgIC8vICAgYSAgIGIgICBjICAgLCAgICAgICAgICAgZCAgIGUgICBmXG4gICAgICAgIC8vIDExICAwICAgMCAgIDEyICAxNSAgNiAgIDEzICAwICAgMCAgIDExXG4gICAgICAgIGNvbnN0IHByZXZDYXRlZ29yeSA9IGdldENhdGVnb3J5KGxlbmd0aCA+IDAgPyB0aGlzLmVsZW1lbnRzW2xlbmd0aCAtIDFdIDogLTEpO1xuICAgICAgICBjb25zdCBuZXh0Q2F0ZWdvcnkgPSBnZXRDYXRlZ29yeShsZW5ndGggPCB0aGlzLmVsZW1lbnRzLmxlbmd0aCA/IHRoaXMuZWxlbWVudHNbbGVuZ3RoXSA6IC0xKTtcbiAgICAgICAgaWYgKHByZXZDYXRlZ29yeSA9PT0gNyAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5MaW5lQnJlYWtDUiAqLyAmJiBuZXh0Q2F0ZWdvcnkgPT09IDggLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuTGluZUJyZWFrTEYgKi8pIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGJyZWFrIGJldHdlZW4gXFxyIGFuZCBcXG5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2Q2F0ZWdvcnkgPT09IDggLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuTGluZUJyZWFrTEYgKi8pIHtcbiAgICAgICAgICAgIC8vIHByZWZlciB0aGUgbGluZWJyZWFrIGJlZm9yZSB0aGUgY2hhbmdlXG4gICAgICAgICAgICByZXR1cm4gMTUwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG4gICAgICAgIGlmIChwcmV2Q2F0ZWdvcnkgIT09IG5leHRDYXRlZ29yeSkge1xuICAgICAgICAgICAgc2NvcmUgKz0gMTA7XG4gICAgICAgICAgICBpZiAocHJldkNhdGVnb3J5ID09PSAwIC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LldvcmRMb3dlciAqLyAmJiBuZXh0Q2F0ZWdvcnkgPT09IDEgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuV29yZFVwcGVyICovKSB7XG4gICAgICAgICAgICAgICAgc2NvcmUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY29yZSArPSBnZXRDYXRlZ29yeUJvdW5kYXJ5U2NvcmUocHJldkNhdGVnb3J5KTtcbiAgICAgICAgc2NvcmUgKz0gZ2V0Q2F0ZWdvcnlCb3VuZGFyeVNjb3JlKG5leHRDYXRlZ29yeSk7XG4gICAgICAgIHJldHVybiBzY29yZTtcbiAgICB9XG4gICAgdHJhbnNsYXRlT2Zmc2V0KG9mZnNldCwgcHJlZmVyZW5jZSA9ICdyaWdodCcpIHtcbiAgICAgICAgLy8gZmluZCBzbWFsbGVzdCBpLCBzbyB0aGF0IGxpbmVCcmVha09mZnNldHNbaV0gPD0gb2Zmc2V0IHVzaW5nIGJpbmFyeSBzZWFyY2hcbiAgICAgICAgY29uc3QgaSA9IGZpbmRMYXN0SWR4TW9ub3Rvbm91cyh0aGlzLmZpcnN0RWxlbWVudE9mZnNldEJ5TGluZUlkeCwgKHZhbHVlKSA9PiB2YWx1ZSA8PSBvZmZzZXQpO1xuICAgICAgICBjb25zdCBsaW5lT2Zmc2V0ID0gb2Zmc2V0IC0gdGhpcy5maXJzdEVsZW1lbnRPZmZzZXRCeUxpbmVJZHhbaV07XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5yYW5nZS5zdGFydExpbmVOdW1iZXIgKyBpLCAxICsgdGhpcy5saW5lU3RhcnRPZmZzZXRzW2ldICsgbGluZU9mZnNldCArICgobGluZU9mZnNldCA9PT0gMCAmJiBwcmVmZXJlbmNlID09PSAnbGVmdCcpID8gMCA6IHRoaXMudHJpbW1lZFdzTGVuZ3Roc0J5TGluZUlkeFtpXSkpO1xuICAgIH1cbiAgICB0cmFuc2xhdGVSYW5nZShyYW5nZSkge1xuICAgICAgICBjb25zdCBwb3MxID0gdGhpcy50cmFuc2xhdGVPZmZzZXQocmFuZ2Uuc3RhcnQsICdyaWdodCcpO1xuICAgICAgICBjb25zdCBwb3MyID0gdGhpcy50cmFuc2xhdGVPZmZzZXQocmFuZ2UuZW5kRXhjbHVzaXZlLCAnbGVmdCcpO1xuICAgICAgICBpZiAocG9zMi5pc0JlZm9yZShwb3MxKSkge1xuICAgICAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb3NpdGlvbnMocG9zMiwgcG9zMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb3NpdGlvbnMocG9zMSwgcG9zMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSB3b3JkIHRoYXQgY29udGFpbnMgdGhlIGNoYXJhY3RlciBhdCB0aGUgZ2l2ZW4gb2Zmc2V0XG4gICAgICovXG4gICAgZmluZFdvcmRDb250YWluaW5nKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPj0gdGhpcy5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1dvcmRDaGFyKHRoaXMuZWxlbWVudHNbb2Zmc2V0XSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCBzdGFydFxuICAgICAgICBsZXQgc3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgIHdoaWxlIChzdGFydCA+IDAgJiYgaXNXb3JkQ2hhcih0aGlzLmVsZW1lbnRzW3N0YXJ0IC0gMV0pKSB7XG4gICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgZW5kXG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQ7XG4gICAgICAgIHdoaWxlIChlbmQgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aCAmJiBpc1dvcmRDaGFyKHRoaXMuZWxlbWVudHNbZW5kXSkpIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGNvdW50TGluZXNJbihyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPZmZzZXQocmFuZ2UuZW5kRXhjbHVzaXZlKS5saW5lTnVtYmVyIC0gdGhpcy50cmFuc2xhdGVPZmZzZXQocmFuZ2Uuc3RhcnQpLmxpbmVOdW1iZXI7XG4gICAgfVxuICAgIGlzU3Ryb25nbHlFcXVhbChvZmZzZXQxLCBvZmZzZXQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW29mZnNldDFdID09PSB0aGlzLmVsZW1lbnRzW29mZnNldDJdO1xuICAgIH1cbiAgICBleHRlbmRUb0Z1bGxMaW5lcyhyYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IGZpbmRMYXN0TW9ub3Rvbm91cyh0aGlzLmZpcnN0RWxlbWVudE9mZnNldEJ5TGluZUlkeCwgeCA9PiB4IDw9IHJhbmdlLnN0YXJ0KSA/PyAwO1xuICAgICAgICBjb25zdCBlbmQgPSBmaW5kRmlyc3RNb25vdG9ub3VzKHRoaXMuZmlyc3RFbGVtZW50T2Zmc2V0QnlMaW5lSWR4LCB4ID0+IHJhbmdlLmVuZEV4Y2x1c2l2ZSA8PSB4KSA/PyB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRSYW5nZShzdGFydCwgZW5kKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1dvcmRDaGFyKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlID49IDk3IC8qIENoYXJDb2RlLmEgKi8gJiYgY2hhckNvZGUgPD0gMTIyIC8qIENoYXJDb2RlLnogKi9cbiAgICAgICAgfHwgY2hhckNvZGUgPj0gNjUgLyogQ2hhckNvZGUuQSAqLyAmJiBjaGFyQ29kZSA8PSA5MCAvKiBDaGFyQ29kZS5aICovXG4gICAgICAgIHx8IGNoYXJDb2RlID49IDQ4IC8qIENoYXJDb2RlLkRpZ2l0MCAqLyAmJiBjaGFyQ29kZSA8PSA1NyAvKiBDaGFyQ29kZS5EaWdpdDkgKi87XG59XG5jb25zdCBzY29yZSA9IHtcbiAgICBbMCAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5Xb3JkTG93ZXIgKi9dOiAwLFxuICAgIFsxIC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LldvcmRVcHBlciAqL106IDAsXG4gICAgWzIgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuV29yZE51bWJlciAqL106IDAsXG4gICAgWzMgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuRW5kICovXTogMTAsXG4gICAgWzQgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuT3RoZXIgKi9dOiAyLFxuICAgIFs1IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LlNlcGFyYXRvciAqL106IDMwLFxuICAgIFs2IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LlNwYWNlICovXTogMyxcbiAgICBbNyAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5MaW5lQnJlYWtDUiAqL106IDEwLFxuICAgIFs4IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LkxpbmVCcmVha0xGICovXTogMTAsXG59O1xuZnVuY3Rpb24gZ2V0Q2F0ZWdvcnlCb3VuZGFyeVNjb3JlKGNhdGVnb3J5KSB7XG4gICAgcmV0dXJuIHNjb3JlW2NhdGVnb3J5XTtcbn1cbmZ1bmN0aW9uIGdldENhdGVnb3J5KGNoYXJDb2RlKSB7XG4gICAgaWYgKGNoYXJDb2RlID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICByZXR1cm4gOCAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5MaW5lQnJlYWtMRiAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhckNvZGUgPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovKSB7XG4gICAgICAgIHJldHVybiA3IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LkxpbmVCcmVha0NSICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NwYWNlKGNoYXJDb2RlKSkge1xuICAgICAgICByZXR1cm4gNiAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5TcGFjZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhckNvZGUgPj0gOTcgLyogQ2hhckNvZGUuYSAqLyAmJiBjaGFyQ29kZSA8PSAxMjIgLyogQ2hhckNvZGUueiAqLykge1xuICAgICAgICByZXR1cm4gMCAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5Xb3JkTG93ZXIgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYXJDb2RlID49IDY1IC8qIENoYXJDb2RlLkEgKi8gJiYgY2hhckNvZGUgPD0gOTAgLyogQ2hhckNvZGUuWiAqLykge1xuICAgICAgICByZXR1cm4gMSAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5Xb3JkVXBwZXIgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYXJDb2RlID49IDQ4IC8qIENoYXJDb2RlLkRpZ2l0MCAqLyAmJiBjaGFyQ29kZSA8PSA1NyAvKiBDaGFyQ29kZS5EaWdpdDkgKi8pIHtcbiAgICAgICAgcmV0dXJuIDIgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuV29yZE51bWJlciAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhckNvZGUgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAzIC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LkVuZCAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhckNvZGUgPT09IDQ0IC8qIENoYXJDb2RlLkNvbW1hICovIHx8IGNoYXJDb2RlID09PSA1OSAvKiBDaGFyQ29kZS5TZW1pY29sb24gKi8pIHtcbiAgICAgICAgcmV0dXJuIDUgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuU2VwYXJhdG9yICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDQgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuT3RoZXIgKi87XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgY2xhc3MgQXJyYXkyRCB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmFycmF5ID0gW107XG4gICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgIH1cbiAgICBnZXQoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVt4ICsgeSAqIHRoaXMud2lkdGhdO1xuICAgIH1cbiAgICBzZXQoeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5hcnJheVt4ICsgeSAqIHRoaXMud2lkdGhdID0gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU3BhY2UoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDMyIC8qIENoYXJDb2RlLlNwYWNlICovIHx8IGNoYXJDb2RlID09PSA5IC8qIENoYXJDb2RlLlRhYiAqLztcbn1cbmV4cG9ydCBjbGFzcyBMaW5lUmFuZ2VGcmFnbWVudCB7XG4gICAgc3RhdGljIHsgdGhpcy5jaHJLZXlzID0gbmV3IE1hcCgpOyB9XG4gICAgc3RhdGljIGdldEtleShjaHIpIHtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuY2hyS2V5cy5nZXQoY2hyKTtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmNocktleXMuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuY2hyS2V5cy5zZXQoY2hyLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCBsaW5lcywgc291cmNlKSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5oaXN0b2dyYW0gPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMTsgaSA8IHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICBjb25zdCBjaHIgPSBsaW5lW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IExpbmVSYW5nZUZyYWdtZW50LmdldEtleShjaHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9ncmFtW2tleV0gPSAodGhpcy5oaXN0b2dyYW1ba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBMaW5lUmFuZ2VGcmFnbWVudC5nZXRLZXkoJ1xcbicpO1xuICAgICAgICAgICAgdGhpcy5oaXN0b2dyYW1ba2V5XSA9ICh0aGlzLmhpc3RvZ3JhbVtrZXldIHx8IDApICsgMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFsQ291bnQgPSBjb3VudGVyO1xuICAgIH1cbiAgICBjb21wdXRlU2ltaWxhcml0eShvdGhlcikge1xuICAgICAgICBsZXQgc3VtRGlmZmVyZW5jZXMgPSAwO1xuICAgICAgICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1heCh0aGlzLmhpc3RvZ3JhbS5sZW5ndGgsIG90aGVyLmhpc3RvZ3JhbS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdW1EaWZmZXJlbmNlcyArPSBNYXRoLmFicygodGhpcy5oaXN0b2dyYW1baV0gPz8gMCkgLSAob3RoZXIuaGlzdG9ncmFtW2ldID8/IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMSAtIChzdW1EaWZmZXJlbmNlcyAvICh0aGlzLnRvdGFsQ291bnQgKyBvdGhlci50b3RhbENvdW50KSk7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBMY3NEaWZmIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZGlmZi9kaWZmLmpzJztcbmltcG9ydCB7IExpbmVzRGlmZiB9IGZyb20gJy4vbGluZXNEaWZmQ29tcHV0ZXIuanMnO1xuaW1wb3J0IHsgUmFuZ2VNYXBwaW5nLCBEZXRhaWxlZExpbmVSYW5nZU1hcHBpbmcgfSBmcm9tICcuL3JhbmdlTWFwcGluZy5qcyc7XG5pbXBvcnQgKiBhcyBzdHJpbmdzIGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3N0cmluZ3MuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi9jb3JlL3JhbmdlLmpzJztcbmltcG9ydCB7IGFzc2VydEZuLCBjaGVja0FkamFjZW50SXRlbXMgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9hc3NlcnQuanMnO1xuaW1wb3J0IHsgTGluZVJhbmdlIH0gZnJvbSAnLi4vY29yZS9saW5lUmFuZ2UuanMnO1xuY29uc3QgTUlOSU1VTV9NQVRDSElOR19DSEFSQUNURVJfTEVOR1RIID0gMztcbmV4cG9ydCBjbGFzcyBMZWdhY3lMaW5lc0RpZmZDb21wdXRlciB7XG4gICAgY29tcHV0ZURpZmYob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkaWZmQ29tcHV0ZXIgPSBuZXcgRGlmZkNvbXB1dGVyKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIHtcbiAgICAgICAgICAgIG1heENvbXB1dGF0aW9uVGltZTogb3B0aW9ucy5tYXhDb21wdXRhdGlvblRpbWVNcyxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlOiBvcHRpb25zLmlnbm9yZVRyaW1XaGl0ZXNwYWNlLFxuICAgICAgICAgICAgc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzOiB0cnVlLFxuICAgICAgICAgICAgc2hvdWxkTWFrZVByZXR0eURpZmY6IHRydWUsXG4gICAgICAgICAgICBzaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGlmZkNvbXB1dGVyLmNvbXB1dGVEaWZmKCk7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgbGV0IGxhc3RDaGFuZ2UgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgcmVzdWx0LmNoYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFJhbmdlO1xuICAgICAgICAgICAgaWYgKGMub3JpZ2luYWxFbmRMaW5lTnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxSYW5nZSA9IG5ldyBMaW5lUmFuZ2UoYy5vcmlnaW5hbFN0YXJ0TGluZU51bWJlciArIDEsIGMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsUmFuZ2UgPSBuZXcgTGluZVJhbmdlKGMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIsIGMub3JpZ2luYWxFbmRMaW5lTnVtYmVyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW9kaWZpZWRSYW5nZTtcbiAgICAgICAgICAgIGlmIChjLm1vZGlmaWVkRW5kTGluZU51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIERlbGV0aW9uXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRSYW5nZSA9IG5ldyBMaW5lUmFuZ2UoYy5tb2RpZmllZFN0YXJ0TGluZU51bWJlciArIDEsIGMubW9kaWZpZWRTdGFydExpbmVOdW1iZXIgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkUmFuZ2UgPSBuZXcgTGluZVJhbmdlKGMubW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIGMubW9kaWZpZWRFbmRMaW5lTnVtYmVyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hhbmdlID0gbmV3IERldGFpbGVkTGluZVJhbmdlTWFwcGluZyhvcmlnaW5hbFJhbmdlLCBtb2RpZmllZFJhbmdlLCBjLmNoYXJDaGFuZ2VzPy5tYXAoYyA9PiBuZXcgUmFuZ2VNYXBwaW5nKG5ldyBSYW5nZShjLm9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyLCBjLm9yaWdpbmFsU3RhcnRDb2x1bW4sIGMub3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBjLm9yaWdpbmFsRW5kQ29sdW1uKSwgbmV3IFJhbmdlKGMubW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIGMubW9kaWZpZWRTdGFydENvbHVtbiwgYy5tb2RpZmllZEVuZExpbmVOdW1iZXIsIGMubW9kaWZpZWRFbmRDb2x1bW4pKSkpO1xuICAgICAgICAgICAgaWYgKGxhc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdENoYW5nZS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlID09PSBjaGFuZ2UubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIHx8IGxhc3RDaGFuZ2Uub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9PT0gY2hhbmdlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBqb2luIHRvdWNoaW5nIGRpZmZzLiBQcm9iYWJseSBtb3ZpbmcgZGlmZnMgdXAvZG93biBpbiB0aGUgYWxnb3JpdGhtIGNhdXNlcyB0b3VjaGluZyBkaWZmcy5cbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gbmV3IERldGFpbGVkTGluZVJhbmdlTWFwcGluZyhsYXN0Q2hhbmdlLm9yaWdpbmFsLmpvaW4oY2hhbmdlLm9yaWdpbmFsKSwgbGFzdENoYW5nZS5tb2RpZmllZC5qb2luKGNoYW5nZS5tb2RpZmllZCksIGxhc3RDaGFuZ2UuaW5uZXJDaGFuZ2VzICYmIGNoYW5nZS5pbm5lckNoYW5nZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENoYW5nZS5pbm5lckNoYW5nZXMuY29uY2F0KGNoYW5nZS5pbm5lckNoYW5nZXMpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIGxhc3RDaGFuZ2UgPSBjaGFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrQWRqYWNlbnRJdGVtcyhjaGFuZ2VzLCAobTEsIG0yKSA9PiBtMi5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgLSBtMS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlID09PSBtMi5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgLSBtMS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaGFzIHRvIGJlIGFuIHVuY2hhbmdlZCBsaW5lIGluIGJldHdlZW4gKG90aGVyd2lzZSBib3RoIGRpZmZzIHNob3VsZCBoYXZlIGJlZW4gam9pbmVkKVxuICAgICAgICAgICAgICAgIG0xLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPCBtMi5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgJiZcbiAgICAgICAgICAgICAgICBtMS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIDwgbTIubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTGluZXNEaWZmKGNoYW5nZXMsIFtdLCByZXN1bHQucXVpdEVhcmx5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlRGlmZihvcmlnaW5hbFNlcXVlbmNlLCBtb2RpZmllZFNlcXVlbmNlLCBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUsIHByZXR0eSkge1xuICAgIGNvbnN0IGRpZmZBbGdvID0gbmV3IExjc0RpZmYob3JpZ2luYWxTZXF1ZW5jZSwgbW9kaWZpZWRTZXF1ZW5jZSwgY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKTtcbiAgICByZXR1cm4gZGlmZkFsZ28uQ29tcHV0ZURpZmYocHJldHR5KTtcbn1cbmNsYXNzIExpbmVTZXF1ZW5jZSB7XG4gICAgY29uc3RydWN0b3IobGluZXMpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRDb2x1bW5zID0gW107XG4gICAgICAgIGNvbnN0IGVuZENvbHVtbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdGFydENvbHVtbnNbaV0gPSBnZXRGaXJzdE5vbkJsYW5rQ29sdW1uKGxpbmVzW2ldLCAxKTtcbiAgICAgICAgICAgIGVuZENvbHVtbnNbaV0gPSBnZXRMYXN0Tm9uQmxhbmtDb2x1bW4obGluZXNbaV0sIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5fc3RhcnRDb2x1bW5zID0gc3RhcnRDb2x1bW5zO1xuICAgICAgICB0aGlzLl9lbmRDb2x1bW5zID0gZW5kQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0RWxlbWVudHMoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBlbGVtZW50c1tpXSA9IHRoaXMubGluZXNbaV0uc3Vic3RyaW5nKHRoaXMuX3N0YXJ0Q29sdW1uc1tpXSAtIDEsIHRoaXMuX2VuZENvbHVtbnNbaV0gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuICAgIGdldFN0cmljdEVsZW1lbnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXNbaW5kZXhdO1xuICAgIH1cbiAgICBnZXRTdGFydExpbmVOdW1iZXIoaSkge1xuICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgfVxuICAgIGdldEVuZExpbmVOdW1iZXIoaSkge1xuICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgfVxuICAgIGNyZWF0ZUNoYXJTZXF1ZW5jZShzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICAgICAgY29uc3QgY2hhckNvZGVzID0gW107XG4gICAgICAgIGNvbnN0IGxpbmVOdW1iZXJzID0gW107XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBbXTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPD0gZW5kSW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gdGhpcy5saW5lc1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzdGFydENvbHVtbiA9IChzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSA/IHRoaXMuX3N0YXJ0Q29sdW1uc1tpbmRleF0gOiAxKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZENvbHVtbiA9IChzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSA/IHRoaXMuX2VuZENvbHVtbnNbaW5kZXhdIDogbGluZUNvbnRlbnQubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSBzdGFydENvbHVtbjsgY29sIDwgZW5kQ29sdW1uOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGNoYXJDb2Rlc1tsZW5dID0gbGluZUNvbnRlbnQuY2hhckNvZGVBdChjb2wgLSAxKTtcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyc1tsZW5dID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIGNvbHVtbnNbbGVuXSA9IGNvbDtcbiAgICAgICAgICAgICAgICBsZW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UgJiYgaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBcXG4gaWYgdHJpbSB3aGl0ZXNwYWNlIGlzIG5vdCBpZ25vcmVkXG4gICAgICAgICAgICAgICAgY2hhckNvZGVzW2xlbl0gPSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLztcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyc1tsZW5dID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIGNvbHVtbnNbbGVuXSA9IGxpbmVDb250ZW50Lmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgbGVuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFyU2VxdWVuY2UoY2hhckNvZGVzLCBsaW5lTnVtYmVycywgY29sdW1ucyk7XG4gICAgfVxufVxuY2xhc3MgQ2hhclNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFyQ29kZXMsIGxpbmVOdW1iZXJzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuX2NoYXJDb2RlcyA9IGNoYXJDb2RlcztcbiAgICAgICAgdGhpcy5fbGluZU51bWJlcnMgPSBsaW5lTnVtYmVycztcbiAgICAgICAgdGhpcy5fY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKCdbJyArIHRoaXMuX2NoYXJDb2Rlcy5tYXAoKHMsIGlkeCkgPT4gKHMgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovID8gJ1xcXFxuJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUocykpICsgYC0oJHt0aGlzLl9saW5lTnVtYmVyc1tpZHhdfSwke3RoaXMuX2NvbHVtbnNbaWR4XX0pYCkuam9pbignLCAnKSArICddJyk7XG4gICAgfVxuICAgIF9hc3NlcnRJbmRleChpbmRleCwgYXJyKSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIGluZGV4YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RWxlbWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFyQ29kZXM7XG4gICAgfVxuICAgIGdldFN0YXJ0TGluZU51bWJlcihpKSB7XG4gICAgICAgIGlmIChpID4gMCAmJiBpID09PSB0aGlzLl9saW5lTnVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHRoZSBzdGFydCBsaW5lIG51bWJlciBvZiB0aGUgZWxlbWVudCBhZnRlciB0aGUgbGFzdCBlbGVtZW50XG4gICAgICAgICAgICAvLyBpcyB0aGUgZW5kIGxpbmUgbnVtYmVyIG9mIHRoZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEVuZExpbmVOdW1iZXIoaSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Fzc2VydEluZGV4KGksIHRoaXMuX2xpbmVOdW1iZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVOdW1iZXJzW2ldO1xuICAgIH1cbiAgICBnZXRFbmRMaW5lTnVtYmVyKGkpIHtcbiAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyB0aGUgZW5kIGxpbmUgbnVtYmVyIG9mIHRoZSBlbGVtZW50IGJlZm9yZSB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgLy8gaXMgdGhlIHN0YXJ0IGxpbmUgbnVtYmVyIG9mIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFydExpbmVOdW1iZXIoaSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Fzc2VydEluZGV4KGksIHRoaXMuX2xpbmVOdW1iZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoYXJDb2Rlc1tpXSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lTnVtYmVyc1tpXSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVOdW1iZXJzW2ldO1xuICAgIH1cbiAgICBnZXRTdGFydENvbHVtbihpKSB7XG4gICAgICAgIGlmIChpID4gMCAmJiBpID09PSB0aGlzLl9jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gdGhlIHN0YXJ0IGNvbHVtbiBvZiB0aGUgZWxlbWVudCBhZnRlciB0aGUgbGFzdCBlbGVtZW50XG4gICAgICAgICAgICAvLyBpcyB0aGUgZW5kIGNvbHVtbiBvZiB0aGUgbGFzdCBlbGVtZW50XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmRDb2x1bW4oaSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Fzc2VydEluZGV4KGksIHRoaXMuX2NvbHVtbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uc1tpXTtcbiAgICB9XG4gICAgZ2V0RW5kQ29sdW1uKGkpIHtcbiAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyB0aGUgZW5kIGNvbHVtbiBvZiB0aGUgZWxlbWVudCBiZWZvcmUgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGlzIHRoZSBzdGFydCBjb2x1bW4gb2YgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YXJ0Q29sdW1uKGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hc3NlcnRJbmRleChpLCB0aGlzLl9jb2x1bW5zKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoYXJDb2Rlc1tpXSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zW2ldICsgMTtcbiAgICB9XG59XG5jbGFzcyBDaGFyQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kTGluZU51bWJlciwgbW9kaWZpZWRFbmRDb2x1bW4pIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFN0YXJ0TGluZU51bWJlciA9IG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLm9yaWdpbmFsU3RhcnRDb2x1bW4gPSBvcmlnaW5hbFN0YXJ0Q29sdW1uO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsRW5kTGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVuZENvbHVtbiA9IG9yaWdpbmFsRW5kQ29sdW1uO1xuICAgICAgICB0aGlzLm1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMubW9kaWZpZWRTdGFydENvbHVtbiA9IG1vZGlmaWVkU3RhcnRDb2x1bW47XG4gICAgICAgIHRoaXMubW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gbW9kaWZpZWRFbmRMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLm1vZGlmaWVkRW5kQ29sdW1uID0gbW9kaWZpZWRFbmRDb2x1bW47XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tRGlmZkNoYW5nZShkaWZmQ2hhbmdlLCBvcmlnaW5hbENoYXJTZXF1ZW5jZSwgbW9kaWZpZWRDaGFyU2VxdWVuY2UpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbENoYXJTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0KTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFydENvbHVtbiA9IG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldFN0YXJ0Q29sdW1uKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEVuZENvbHVtbiA9IG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldEVuZENvbHVtbihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRDaGFyU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkU3RhcnRDb2x1bW4gPSBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRTdGFydENvbHVtbihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQpO1xuICAgICAgICBjb25zdCBtb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRFbmRMaW5lTnVtYmVyKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCArIGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRFbmRDb2x1bW4gPSBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRFbmRDb2x1bW4oZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gbmV3IENoYXJDaGFuZ2Uob3JpZ2luYWxTdGFydExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kTGluZU51bWJlciwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzKHJhd0NoYW5nZXMpIHtcbiAgICBpZiAocmF3Q2hhbmdlcy5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gcmF3Q2hhbmdlcztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW3Jhd0NoYW5nZXNbMF1dO1xuICAgIGxldCBwcmV2Q2hhbmdlID0gcmVzdWx0WzBdO1xuICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSByYXdDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJDaGFuZ2UgPSByYXdDaGFuZ2VzW2ldO1xuICAgICAgICBjb25zdCBvcmlnaW5hbE1hdGNoaW5nTGVuZ3RoID0gY3VyckNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gKHByZXZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIHByZXZDaGFuZ2Uub3JpZ2luYWxMZW5ndGgpO1xuICAgICAgICBjb25zdCBtb2RpZmllZE1hdGNoaW5nTGVuZ3RoID0gY3VyckNoYW5nZS5tb2RpZmllZFN0YXJ0IC0gKHByZXZDaGFuZ2UubW9kaWZpZWRTdGFydCArIHByZXZDaGFuZ2UubW9kaWZpZWRMZW5ndGgpO1xuICAgICAgICAvLyBCb3RoIG9mIHRoZSBhYm92ZSBzaG91bGQgYmUgZXF1YWwsIGJ1dCB0aGUgY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlIG1heSBwcmV2ZW50IHRoaXMgZnJvbSBiZWluZyB0cnVlXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nTGVuZ3RoID0gTWF0aC5taW4ob3JpZ2luYWxNYXRjaGluZ0xlbmd0aCwgbW9kaWZpZWRNYXRjaGluZ0xlbmd0aCk7XG4gICAgICAgIGlmIChtYXRjaGluZ0xlbmd0aCA8IE1JTklNVU1fTUFUQ0hJTkdfQ0hBUkFDVEVSX0xFTkdUSCkge1xuICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIGN1cnJlbnQgY2hhbmdlIGludG8gdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICAgICAgcHJldkNoYW5nZS5vcmlnaW5hbExlbmd0aCA9IChjdXJyQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBjdXJyQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoKSAtIHByZXZDaGFuZ2Uub3JpZ2luYWxTdGFydDtcbiAgICAgICAgICAgIHByZXZDaGFuZ2UubW9kaWZpZWRMZW5ndGggPSAoY3VyckNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgY3VyckNoYW5nZS5tb2RpZmllZExlbmd0aCkgLSBwcmV2Q2hhbmdlLm1vZGlmaWVkU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGN1cnJlbnQgY2hhbmdlXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXJyQ2hhbmdlKTtcbiAgICAgICAgICAgIHByZXZDaGFuZ2UgPSBjdXJyQ2hhbmdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBMaW5lQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0TGluZU51bWJlciwgbW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBjaGFyQ2hhbmdlcykge1xuICAgICAgICB0aGlzLm9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gb3JpZ2luYWxFbmRMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLm1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMubW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gbW9kaWZpZWRFbmRMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLmNoYXJDaGFuZ2VzID0gY2hhckNoYW5nZXM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tRGlmZlJlc3VsdChzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSwgZGlmZkNoYW5nZSwgb3JpZ2luYWxMaW5lU2VxdWVuY2UsIG1vZGlmaWVkTGluZVNlcXVlbmNlLCBjb250aW51ZUNoYXJEaWZmLCBzaG91bGRDb21wdXRlQ2hhckNoYW5nZXMsIHNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMpIHtcbiAgICAgICAgbGV0IG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICBsZXQgb3JpZ2luYWxFbmRMaW5lTnVtYmVyO1xuICAgICAgICBsZXQgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGxldCBtb2RpZmllZEVuZExpbmVOdW1iZXI7XG4gICAgICAgIGxldCBjaGFyQ2hhbmdlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxMaW5lU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCkgLSAxO1xuICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxMaW5lU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCk7XG4gICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5nZXRFbmRMaW5lTnVtYmVyKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIgPSBtb2RpZmllZExpbmVTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0KSAtIDE7XG4gICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIgPSBtb2RpZmllZExpbmVTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0KTtcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRDb21wdXRlQ2hhckNoYW5nZXMgJiYgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCA+IDAgJiYgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCA8IDIwICYmIGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggPiAwICYmIGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggPCAyMCAmJiBjb250aW51ZUNoYXJEaWZmKCkpIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgY2hhcmFjdGVyIGNoYW5nZXMgZm9yIGRpZmYgY2h1bmtzIG9mIGF0IG1vc3QgMjAgbGluZXMuLi5cbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQ2hhclNlcXVlbmNlID0gb3JpZ2luYWxMaW5lU2VxdWVuY2UuY3JlYXRlQ2hhclNlcXVlbmNlKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCBkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQsIGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkQ2hhclNlcXVlbmNlID0gbW9kaWZpZWRMaW5lU2VxdWVuY2UuY3JlYXRlQ2hhclNlcXVlbmNlKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCBkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQsIGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCArIGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbENoYXJTZXF1ZW5jZS5nZXRFbGVtZW50cygpLmxlbmd0aCA+IDAgJiYgbW9kaWZpZWRDaGFyU2VxdWVuY2UuZ2V0RWxlbWVudHMoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhd0NoYW5nZXMgPSBjb21wdXRlRGlmZihvcmlnaW5hbENoYXJTZXF1ZW5jZSwgbW9kaWZpZWRDaGFyU2VxdWVuY2UsIGNvbnRpbnVlQ2hhckRpZmYsIHRydWUpLmNoYW5nZXM7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3Q2hhbmdlcyA9IHBvc3RQcm9jZXNzQ2hhckNoYW5nZXMocmF3Q2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYXJDaGFuZ2VzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHJhd0NoYW5nZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNoYW5nZXMucHVzaChDaGFyQ2hhbmdlLmNyZWF0ZUZyb21EaWZmQ2hhbmdlKHJhd0NoYW5nZXNbaV0sIG9yaWdpbmFsQ2hhclNlcXVlbmNlLCBtb2RpZmllZENoYXJTZXF1ZW5jZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVDaGFuZ2Uob3JpZ2luYWxTdGFydExpbmVOdW1iZXIsIG9yaWdpbmFsRW5kTGluZU51bWJlciwgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kTGluZU51bWJlciwgY2hhckNoYW5nZXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEaWZmQ29tcHV0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5zaG91bGRDb21wdXRlQ2hhckNoYW5nZXMgPSBvcHRzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcztcbiAgICAgICAgdGhpcy5zaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzID0gb3B0cy5zaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzO1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlID0gb3B0cy5zaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZTtcbiAgICAgICAgdGhpcy5zaG91bGRNYWtlUHJldHR5RGlmZiA9IG9wdHMuc2hvdWxkTWFrZVByZXR0eURpZmY7XG4gICAgICAgIHRoaXMub3JpZ2luYWxMaW5lcyA9IG9yaWdpbmFsTGluZXM7XG4gICAgICAgIHRoaXMubW9kaWZpZWRMaW5lcyA9IG1vZGlmaWVkTGluZXM7XG4gICAgICAgIHRoaXMub3JpZ2luYWwgPSBuZXcgTGluZVNlcXVlbmNlKG9yaWdpbmFsTGluZXMpO1xuICAgICAgICB0aGlzLm1vZGlmaWVkID0gbmV3IExpbmVTZXF1ZW5jZShtb2RpZmllZExpbmVzKTtcbiAgICAgICAgdGhpcy5jb250aW51ZUxpbmVEaWZmID0gY3JlYXRlQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKG9wdHMubWF4Q29tcHV0YXRpb25UaW1lKTtcbiAgICAgICAgdGhpcy5jb250aW51ZUNoYXJEaWZmID0gY3JlYXRlQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKG9wdHMubWF4Q29tcHV0YXRpb25UaW1lID09PSAwID8gMCA6IE1hdGgubWluKG9wdHMubWF4Q29tcHV0YXRpb25UaW1lLCA1MDAwKSk7IC8vIG5ldmVyIHJ1biBhZnRlciA1cyBmb3IgY2hhcmFjdGVyIGNoYW5nZXMuLi5cbiAgICB9XG4gICAgY29tcHV0ZURpZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbmFsLmxpbmVzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm9yaWdpbmFsLmxpbmVzWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gZW1wdHkgb3JpZ2luYWwgPT4gZmFzdCBwYXRoXG4gICAgICAgICAgICBpZiAodGhpcy5tb2RpZmllZC5saW5lcy5sZW5ndGggPT09IDEgJiYgdGhpcy5tb2RpZmllZC5saW5lc1swXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBxdWl0RWFybHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHF1aXRFYXJseTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2hhbmdlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXI6IHRoaXMubW9kaWZpZWQubGluZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNoYW5nZXM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RpZmllZC5saW5lcy5sZW5ndGggPT09IDEgJiYgdGhpcy5tb2RpZmllZC5saW5lc1swXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IG1vZGlmaWVkID0+IGZhc3QgcGF0aFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBxdWl0RWFybHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlcjogdGhpcy5vcmlnaW5hbC5saW5lcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlcjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDaGFuZ2VzOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlmZlJlc3VsdCA9IGNvbXB1dGVEaWZmKHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIHRoaXMuY29udGludWVMaW5lRGlmZiwgdGhpcy5zaG91bGRNYWtlUHJldHR5RGlmZik7XG4gICAgICAgIGNvbnN0IHJhd0NoYW5nZXMgPSBkaWZmUmVzdWx0LmNoYW5nZXM7XG4gICAgICAgIGNvbnN0IHF1aXRFYXJseSA9IGRpZmZSZXN1bHQucXVpdEVhcmx5O1xuICAgICAgICAvLyBUaGUgZGlmZiBpcyBhbHdheXMgY29tcHV0ZWQgd2l0aCBpZ25vcmluZyB0cmltIHdoaXRlc3BhY2VcbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHdlIGdldCB0aGUgcHJldHRpZXN0IGRpZmZcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gcmF3Q2hhbmdlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpbmVDaGFuZ2VzLnB1c2goTGluZUNoYW5nZS5jcmVhdGVGcm9tRGlmZlJlc3VsdCh0aGlzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCByYXdDaGFuZ2VzW2ldLCB0aGlzLm9yaWdpbmFsLCB0aGlzLm1vZGlmaWVkLCB0aGlzLmNvbnRpbnVlQ2hhckRpZmYsIHRoaXMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzLCB0aGlzLnNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5OiBxdWl0RWFybHksXG4gICAgICAgICAgICAgICAgY2hhbmdlczogbGluZUNoYW5nZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmVlZCB0byBwb3N0LXByb2Nlc3MgYW5kIGludHJvZHVjZSBjaGFuZ2VzIHdoZXJlIHRoZSB0cmltIHdoaXRlc3BhY2UgaXMgZGlmZmVyZW50XG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhcmUgbG9vcGluZyBzdGFydGluZyBhdCAtMSB0byBhbHNvIGNvdmVyIHRoZSBsaW5lcyBiZWZvcmUgdGhlIGZpcnN0IGNoYW5nZVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IG9yaWdpbmFsTGluZUluZGV4ID0gMDtcbiAgICAgICAgbGV0IG1vZGlmaWVkTGluZUluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IC0xIC8qICEhISEgKi8sIGxlbiA9IHJhd0NoYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGFuZ2UgPSAoaSArIDEgPCBsZW4gPyByYXdDaGFuZ2VzW2kgKyAxXSA6IG51bGwpO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gKG5leHRDaGFuZ2UgPyBuZXh0Q2hhbmdlLm9yaWdpbmFsU3RhcnQgOiB0aGlzLm9yaWdpbmFsTGluZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkU3RvcCA9IChuZXh0Q2hhbmdlID8gbmV4dENoYW5nZS5tb2RpZmllZFN0YXJ0IDogdGhpcy5tb2RpZmllZExpbmVzLmxlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxMaW5lSW5kZXggPCBvcmlnaW5hbFN0b3AgJiYgbW9kaWZpZWRMaW5lSW5kZXggPCBtb2RpZmllZFN0b3ApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbExpbmUgPSB0aGlzLm9yaWdpbmFsTGluZXNbb3JpZ2luYWxMaW5lSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZSA9IHRoaXMubW9kaWZpZWRMaW5lc1ttb2RpZmllZExpbmVJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsTGluZSAhPT0gbW9kaWZpZWRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGxpbmVzIGRpZmZlciBvbmx5IGluIHRyaW0gd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbFN0YXJ0Q29sdW1uID0gZ2V0Rmlyc3ROb25CbGFua0NvbHVtbihvcmlnaW5hbExpbmUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGlmaWVkU3RhcnRDb2x1bW4gPSBnZXRGaXJzdE5vbkJsYW5rQ29sdW1uKG1vZGlmaWVkTGluZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxTdGFydENvbHVtbiA+IDEgJiYgbW9kaWZpZWRTdGFydENvbHVtbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbENoYXIgPSBvcmlnaW5hbExpbmUuY2hhckNvZGVBdChvcmlnaW5hbFN0YXJ0Q29sdW1uIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRDaGFyID0gbW9kaWZpZWRMaW5lLmNoYXJDb2RlQXQobW9kaWZpZWRTdGFydENvbHVtbiAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbENoYXIgIT09IG1vZGlmaWVkQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydENvbHVtbi0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRDb2x1bW4tLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0Q29sdW1uID4gMSB8fCBtb2RpZmllZFN0YXJ0Q29sdW1uID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVJbmRleCArIDEsIDEsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG1vZGlmaWVkTGluZUluZGV4ICsgMSwgMSwgbW9kaWZpZWRTdGFydENvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsRW5kQ29sdW1uID0gZ2V0TGFzdE5vbkJsYW5rQ29sdW1uKG9yaWdpbmFsTGluZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRFbmRDb2x1bW4gPSBnZXRMYXN0Tm9uQmxhbmtDb2x1bW4obW9kaWZpZWRMaW5lLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTWF4Q29sdW1uID0gb3JpZ2luYWxMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZE1heENvbHVtbiA9IG1vZGlmaWVkTGluZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9yaWdpbmFsRW5kQ29sdW1uIDwgb3JpZ2luYWxNYXhDb2x1bW4gJiYgbW9kaWZpZWRFbmRDb2x1bW4gPCBtb2RpZmllZE1heENvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQ2hhciA9IG9yaWdpbmFsTGluZS5jaGFyQ29kZUF0KG9yaWdpbmFsRW5kQ29sdW1uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRDaGFyID0gb3JpZ2luYWxMaW5lLmNoYXJDb2RlQXQobW9kaWZpZWRFbmRDb2x1bW4gLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxDaGFyICE9PSBtb2RpZmllZENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kQ29sdW1uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRFbmRDb2x1bW4rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEVuZENvbHVtbiA8IG9yaWdpbmFsTWF4Q29sdW1uIHx8IG1vZGlmaWVkRW5kQ29sdW1uIDwgbW9kaWZpZWRNYXhDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXNoVHJpbVdoaXRlc3BhY2VDaGFyQ2hhbmdlKHJlc3VsdCwgb3JpZ2luYWxMaW5lSW5kZXggKyAxLCBvcmlnaW5hbEVuZENvbHVtbiwgb3JpZ2luYWxNYXhDb2x1bW4sIG1vZGlmaWVkTGluZUluZGV4ICsgMSwgbW9kaWZpZWRFbmRDb2x1bW4sIG1vZGlmaWVkTWF4Q29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmVJbmRleCsrO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkTGluZUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dENoYW5nZSkge1xuICAgICAgICAgICAgICAgIC8vIEVtaXQgdGhlIGFjdHVhbCBjaGFuZ2VcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChMaW5lQ2hhbmdlLmNyZWF0ZUZyb21EaWZmUmVzdWx0KHRoaXMuc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIG5leHRDaGFuZ2UsIHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIHRoaXMuY29udGludWVDaGFyRGlmZiwgdGhpcy5zaG91bGRDb21wdXRlQ2hhckNoYW5nZXMsIHRoaXMuc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcykpO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTGluZUluZGV4ICs9IG5leHRDaGFuZ2Uub3JpZ2luYWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lSW5kZXggKz0gbmV4dENoYW5nZS5tb2RpZmllZExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVpdEVhcmx5OiBxdWl0RWFybHksXG4gICAgICAgICAgICBjaGFuZ2VzOiByZXN1bHRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3B1c2hUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kQ29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kQ29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLl9tZXJnZVRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRFbmRDb2x1bW4pKSB7XG4gICAgICAgICAgICAvLyBNZXJnZWQgaW50byBwcmV2aW91c1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFyQ2hhbmdlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzKSB7XG4gICAgICAgICAgICBjaGFyQ2hhbmdlcyA9IFtuZXcgQ2hhckNoYW5nZShvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZENvbHVtbildO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxMaW5lTnVtYmVyLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkTGluZU51bWJlciwgY2hhckNoYW5nZXMpKTtcbiAgICB9XG4gICAgX21lcmdlVHJpbVdoaXRlc3BhY2VDaGFyQ2hhbmdlKHJlc3VsdCwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbFN0YXJ0Q29sdW1uLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZENvbHVtbikge1xuICAgICAgICBjb25zdCBsZW4gPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkNoYW5nZSA9IHJlc3VsdFtsZW4gLSAxXTtcbiAgICAgICAgaWYgKHByZXZDaGFuZ2Uub3JpZ2luYWxFbmRMaW5lTnVtYmVyID09PSAwIHx8IHByZXZDaGFuZ2UubW9kaWZpZWRFbmRMaW5lTnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBtZXJnZSB3aXRoIGluc2VydHMvZGVsZXRlc1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2Q2hhbmdlLm9yaWdpbmFsRW5kTGluZU51bWJlciA9PT0gb3JpZ2luYWxMaW5lTnVtYmVyICYmIHByZXZDaGFuZ2UubW9kaWZpZWRFbmRMaW5lTnVtYmVyID09PSBtb2RpZmllZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcyAmJiBwcmV2Q2hhbmdlLmNoYXJDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcHJldkNoYW5nZS5jaGFyQ2hhbmdlcy5wdXNoKG5ldyBDaGFyQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkNoYW5nZS5vcmlnaW5hbEVuZExpbmVOdW1iZXIgKyAxID09PSBvcmlnaW5hbExpbmVOdW1iZXIgJiYgcHJldkNoYW5nZS5tb2RpZmllZEVuZExpbmVOdW1iZXIgKyAxID09PSBtb2RpZmllZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHByZXZDaGFuZ2Uub3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gb3JpZ2luYWxMaW5lTnVtYmVyO1xuICAgICAgICAgICAgcHJldkNoYW5nZS5tb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZExpbmVOdW1iZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRDb21wdXRlQ2hhckNoYW5nZXMgJiYgcHJldkNoYW5nZS5jaGFyQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHByZXZDaGFuZ2UuY2hhckNoYW5nZXMucHVzaChuZXcgQ2hhckNoYW5nZShvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZENvbHVtbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEZpcnN0Tm9uQmxhbmtDb2x1bW4odHh0LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCByID0gc3RyaW5ncy5maXJzdE5vbldoaXRlc3BhY2VJbmRleCh0eHQpO1xuICAgIGlmIChyID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gciArIDE7XG59XG5mdW5jdGlvbiBnZXRMYXN0Tm9uQmxhbmtDb2x1bW4odHh0LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCByID0gc3RyaW5ncy5sYXN0Tm9uV2hpdGVzcGFjZUluZGV4KHR4dCk7XG4gICAgaWYgKHIgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByICsgMjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZShtYXhpbXVtUnVudGltZSkge1xuICAgIGlmIChtYXhpbXVtUnVudGltZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IG1heGltdW1SdW50aW1lO1xuICAgIH07XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBjbGFzcyBMaW5lc0RpZmYge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZXMsIFxuICAgIC8qKlxuICAgICAqIFNvcnRlZCBieSBvcmlnaW5hbCBsaW5lIHJhbmdlcy5cbiAgICAgKiBUaGUgb3JpZ2luYWwgbGluZSByYW5nZXMgYW5kIHRoZSBtb2RpZmllZCBsaW5lIHJhbmdlcyBtdXN0IGJlIGRpc2pvaW50IChidXQgY2FuIGJlIHRvdWNoaW5nKS5cbiAgICAgKi9cbiAgICBtb3ZlcywgXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSB0aW1lIG91dCB3YXMgcmVhY2hlZC5cbiAgICAgKiBJbiB0aGF0IGNhc2UsIHRoZSBkaWZmcyBtaWdodCBiZSBhbiBhcHByb3hpbWF0aW9uIGFuZCB0aGUgdXNlciBzaG91bGQgYmUgYXNrZWQgdG8gcmVydW4gdGhlIGRpZmYgd2l0aCBtb3JlIHRpbWUuXG4gICAgICovXG4gICAgaGl0VGltZW91dCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLm1vdmVzID0gbW92ZXM7XG4gICAgICAgIHRoaXMuaGl0VGltZW91dCA9IGhpdFRpbWVvdXQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1vdmVkVGV4dCB7XG4gICAgY29uc3RydWN0b3IobGluZVJhbmdlTWFwcGluZywgY2hhbmdlcykge1xuICAgICAgICB0aGlzLmxpbmVSYW5nZU1hcHBpbmcgPSBsaW5lUmFuZ2VNYXBwaW5nO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgTGVnYWN5TGluZXNEaWZmQ29tcHV0ZXIgfSBmcm9tICcuL2xlZ2FjeUxpbmVzRGlmZkNvbXB1dGVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRMaW5lc0RpZmZDb21wdXRlciB9IGZyb20gJy4vZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci5qcyc7XG5leHBvcnQgY29uc3QgbGluZXNEaWZmQ29tcHV0ZXJzID0ge1xuICAgIGdldExlZ2FjeTogKCkgPT4gbmV3IExlZ2FjeUxpbmVzRGlmZkNvbXB1dGVyKCksXG4gICAgZ2V0RGVmYXVsdDogKCkgPT4gbmV3IERlZmF1bHRMaW5lc0RpZmZDb21wdXRlcigpLFxufTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgQnVnSW5kaWNhdGluZ0Vycm9yIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZXJyb3JzLmpzJztcbmltcG9ydCB7IExpbmVSYW5nZSB9IGZyb20gJy4uL2NvcmUvbGluZVJhbmdlLmpzJztcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgU2luZ2xlVGV4dEVkaXQgfSBmcm9tICcuLi9jb3JlL3RleHRFZGl0LmpzJztcbi8qKlxuICogTWFwcyBhIGxpbmUgcmFuZ2UgaW4gdGhlIG9yaWdpbmFsIHRleHQgbW9kZWwgdG8gYSBsaW5lIHJhbmdlIGluIHRoZSBtb2RpZmllZCB0ZXh0IG1vZGVsLlxuICovXG5leHBvcnQgY2xhc3MgTGluZVJhbmdlTWFwcGluZyB7XG4gICAgc3RhdGljIGludmVyc2UobWFwcGluZywgb3JpZ2luYWxMaW5lQ291bnQsIG1vZGlmaWVkTGluZUNvdW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbGFzdE9yaWdpbmFsRW5kTGluZU51bWJlciA9IDE7XG4gICAgICAgIGxldCBsYXN0TW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gMTtcbiAgICAgICAgZm9yIChjb25zdCBtIG9mIG1hcHBpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBuZXcgTGluZVJhbmdlTWFwcGluZyhuZXcgTGluZVJhbmdlKGxhc3RPcmlnaW5hbEVuZExpbmVOdW1iZXIsIG0ub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyKSwgbmV3IExpbmVSYW5nZShsYXN0TW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBtLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlcikpO1xuICAgICAgICAgICAgaWYgKCFyLm1vZGlmaWVkLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RPcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBtLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gbS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSBuZXcgTGluZVJhbmdlTWFwcGluZyhuZXcgTGluZVJhbmdlKGxhc3RPcmlnaW5hbEVuZExpbmVOdW1iZXIsIG9yaWdpbmFsTGluZUNvdW50ICsgMSksIG5ldyBMaW5lUmFuZ2UobGFzdE1vZGlmaWVkRW5kTGluZU51bWJlciwgbW9kaWZpZWRMaW5lQ291bnQgKyAxKSk7XG4gICAgICAgIGlmICghci5tb2RpZmllZC5pc0VtcHR5KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgY2xpcChtYXBwaW5nLCBvcmlnaW5hbFJhbmdlLCBtb2RpZmllZFJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgbWFwcGluZykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBtLm9yaWdpbmFsLmludGVyc2VjdChvcmlnaW5hbFJhbmdlKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkID0gbS5tb2RpZmllZC5pbnRlcnNlY3QobW9kaWZpZWRSYW5nZSk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwgJiYgIW9yaWdpbmFsLmlzRW1wdHkgJiYgbW9kaWZpZWQgJiYgIW1vZGlmaWVkLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgTGluZVJhbmdlTWFwcGluZyhvcmlnaW5hbCwgbW9kaWZpZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFJhbmdlLCBtb2RpZmllZFJhbmdlKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWwgPSBvcmlnaW5hbFJhbmdlO1xuICAgICAgICB0aGlzLm1vZGlmaWVkID0gbW9kaWZpZWRSYW5nZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgeyR7dGhpcy5vcmlnaW5hbC50b1N0cmluZygpfS0+JHt0aGlzLm1vZGlmaWVkLnRvU3RyaW5nKCl9fWA7XG4gICAgfVxuICAgIGZsaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlTWFwcGluZyh0aGlzLm1vZGlmaWVkLCB0aGlzLm9yaWdpbmFsKTtcbiAgICB9XG4gICAgam9pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZU1hcHBpbmcodGhpcy5vcmlnaW5hbC5qb2luKG90aGVyLm9yaWdpbmFsKSwgdGhpcy5tb2RpZmllZC5qb2luKG90aGVyLm1vZGlmaWVkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgdGhhdCB0aGUgTGluZVJhbmdlTWFwcGluZyBkZXNjcmliZXMgYSB2YWxpZCBkaWZmIVxuICAgICAqIEkuZS4gaWYgb25lIHJhbmdlIGlzIGVtcHR5LCB0aGUgb3RoZXIgcmFuZ2UgY2Fubm90IGJlIHRoZSBlbnRpcmUgZG9jdW1lbnQuXG4gICAgICogSXQgYXZvaWRzIHZhcmlvdXMgcHJvYmxlbXMgd2hlbiB0aGUgbGluZSByYW5nZSBwb2ludHMgdG8gbm9uLWV4aXN0aW5nIGxpbmUtbnVtYmVycy5cbiAgICAqL1xuICAgIHRvUmFuZ2VNYXBwaW5nKCkge1xuICAgICAgICBjb25zdCBvcmlnSW5jbHVzaXZlUmFuZ2UgPSB0aGlzLm9yaWdpbmFsLnRvSW5jbHVzaXZlUmFuZ2UoKTtcbiAgICAgICAgY29uc3QgbW9kSW5jbHVzaXZlUmFuZ2UgPSB0aGlzLm1vZGlmaWVkLnRvSW5jbHVzaXZlUmFuZ2UoKTtcbiAgICAgICAgaWYgKG9yaWdJbmNsdXNpdmVSYW5nZSAmJiBtb2RJbmNsdXNpdmVSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZU1hcHBpbmcob3JpZ0luY2x1c2l2ZVJhbmdlLCBtb2RJbmNsdXNpdmVSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgPT09IDEgfHwgdGhpcy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyID09PSAxICYmIHRoaXMub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyID09PSAxKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIG9uZSBsaW5lIHJhbmdlIHN0YXJ0cyBhdCAxLCB0aGUgb3RoZXIgb25lIG11c3Qgc3RhcnQgYXQgMSBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ25vdCBhIHZhbGlkIGRpZmYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugb25lIHJhbmdlIGlzIGVtcHR5IGFuZCBib3RoIHJhbmdlcyBzdGFydCBhdCBsaW5lIDEsIG5vbmUgb2YgdGhlIHJhbmdlcyBjYW4gY292ZXIgYWxsIGxpbmVzLlxuICAgICAgICAgICAgLy8gVGh1cywgYGVuZExpbmVOdW1iZXJFeGNsdXNpdmVgIGlzIGEgdmFsaWQgbGluZSBudW1iZXIuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlTWFwcGluZyhuZXcgUmFuZ2UodGhpcy5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIsIDEsIHRoaXMub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgMSksIG5ldyBSYW5nZSh0aGlzLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciwgMSwgdGhpcy5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4gYXNzdW1lIGhlcmUgdGhhdCBib3RoIHN0YXJ0TGluZU51bWJlcnMgYXJlIGdyZWF0ZXIgdGhhbiAxLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZU1hcHBpbmcobmV3IFJhbmdlKHRoaXMub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIC0gMSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIHRoaXMub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAtIDEsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgbmV3IFJhbmdlKHRoaXMubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIC0gMSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIHRoaXMubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAtIDEsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYXNzdW1lcyB0aGF0IHRoZSBMaW5lUmFuZ2VNYXBwaW5nIGRlc2NyaWJlcyBhIHZhbGlkIGRpZmYhXG4gICAgICogSS5lLiBpZiBvbmUgcmFuZ2UgaXMgZW1wdHksIHRoZSBvdGhlciByYW5nZSBjYW5ub3QgYmUgdGhlIGVudGlyZSBkb2N1bWVudC5cbiAgICAgKiBJdCBhdm9pZHMgdmFyaW91cyBwcm9ibGVtcyB3aGVuIHRoZSBsaW5lIHJhbmdlIHBvaW50cyB0byBub24tZXhpc3RpbmcgbGluZS1udW1iZXJzLlxuICAgICovXG4gICAgdG9SYW5nZU1hcHBpbmcyKG9yaWdpbmFsLCBtb2RpZmllZCkge1xuICAgICAgICBpZiAoaXNWYWxpZExpbmVOdW1iZXIodGhpcy5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCBvcmlnaW5hbClcbiAgICAgICAgICAgICYmIGlzVmFsaWRMaW5lTnVtYmVyKHRoaXMubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgbW9kaWZpZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlTWFwcGluZyhuZXcgUmFuZ2UodGhpcy5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIsIDEsIHRoaXMub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgMSksIG5ldyBSYW5nZSh0aGlzLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciwgMSwgdGhpcy5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9yaWdpbmFsLmlzRW1wdHkgJiYgIXRoaXMubW9kaWZpZWQuaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZU1hcHBpbmcoUmFuZ2UuZnJvbVBvc2l0aW9ucyhuZXcgUG9zaXRpb24odGhpcy5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIsIDEpLCBub3JtYWxpemVQb3NpdGlvbihuZXcgUG9zaXRpb24odGhpcy5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gMSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLCBvcmlnaW5hbCkpLCBSYW5nZS5mcm9tUG9zaXRpb25zKG5ldyBQb3NpdGlvbih0aGlzLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciwgMSksIG5vcm1hbGl6ZVBvc2l0aW9uKG5ldyBQb3NpdGlvbih0aGlzLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSAxLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiksIG1vZGlmaWVkKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciA+IDEgJiYgdGhpcy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlTWFwcGluZyhSYW5nZS5mcm9tUG9zaXRpb25zKG5vcm1hbGl6ZVBvc2l0aW9uKG5ldyBQb3NpdGlvbih0aGlzLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAtIDEsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgb3JpZ2luYWwpLCBub3JtYWxpemVQb3NpdGlvbihuZXcgUG9zaXRpb24odGhpcy5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gMSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLCBvcmlnaW5hbCkpLCBSYW5nZS5mcm9tUG9zaXRpb25zKG5vcm1hbGl6ZVBvc2l0aW9uKG5ldyBQb3NpdGlvbih0aGlzLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciAtIDEsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgbW9kaWZpZWQpLCBub3JtYWxpemVQb3NpdGlvbihuZXcgUG9zaXRpb24odGhpcy5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gMSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLCBtb2RpZmllZCkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaXR1YXRpb24gbm93OiBvbmUgcmFuZ2UgaXMgZW1wdHkgYW5kIG9uZSByYW5nZSB0b3VjaGVzIHRoZSBsYXN0IGxpbmUgYW5kIG9uZSByYW5nZSBzdGFydHMgYXQgbGluZSAxLlxuICAgICAgICAvLyBJIGRvbid0IHRoaW5rIHRoaXMgY2FuIGhhcHBlbi5cbiAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvc2l0aW9uKHBvc2l0aW9uLCBjb250ZW50KSB7XG4gICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPCAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24oMSwgMSk7XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbi5saW5lTnVtYmVyID4gY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihjb250ZW50Lmxlbmd0aCwgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdLmxlbmd0aCArIDEpO1xuICAgIH1cbiAgICBjb25zdCBsaW5lID0gY29udGVudFtwb3NpdGlvbi5saW5lTnVtYmVyIC0gMV07XG4gICAgaWYgKHBvc2l0aW9uLmNvbHVtbiA+IGxpbmUubGVuZ3RoICsgMSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHBvc2l0aW9uLmxpbmVOdW1iZXIsIGxpbmUubGVuZ3RoICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRMaW5lTnVtYmVyKGxpbmVOdW1iZXIsIGxpbmVzKSB7XG4gICAgcmV0dXJuIGxpbmVOdW1iZXIgPj0gMSAmJiBsaW5lTnVtYmVyIDw9IGxpbmVzLmxlbmd0aDtcbn1cbi8qKlxuICogTWFwcyBhIGxpbmUgcmFuZ2UgaW4gdGhlIG9yaWdpbmFsIHRleHQgbW9kZWwgdG8gYSBsaW5lIHJhbmdlIGluIHRoZSBtb2RpZmllZCB0ZXh0IG1vZGVsLlxuICogQWxzbyBjb250YWlucyBpbm5lciByYW5nZSBtYXBwaW5ncy5cbiAqL1xuZXhwb3J0IGNsYXNzIERldGFpbGVkTGluZVJhbmdlTWFwcGluZyBleHRlbmRzIExpbmVSYW5nZU1hcHBpbmcge1xuICAgIHN0YXRpYyBmcm9tUmFuZ2VNYXBwaW5ncyhyYW5nZU1hcHBpbmdzKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUmFuZ2UgPSBMaW5lUmFuZ2Uuam9pbihyYW5nZU1hcHBpbmdzLm1hcChyID0+IExpbmVSYW5nZS5mcm9tUmFuZ2VJbmNsdXNpdmUoci5vcmlnaW5hbFJhbmdlKSkpO1xuICAgICAgICBjb25zdCBtb2RpZmllZFJhbmdlID0gTGluZVJhbmdlLmpvaW4ocmFuZ2VNYXBwaW5ncy5tYXAociA9PiBMaW5lUmFuZ2UuZnJvbVJhbmdlSW5jbHVzaXZlKHIubW9kaWZpZWRSYW5nZSkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXRhaWxlZExpbmVSYW5nZU1hcHBpbmcob3JpZ2luYWxSYW5nZSwgbW9kaWZpZWRSYW5nZSwgcmFuZ2VNYXBwaW5ncyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsUmFuZ2UsIG1vZGlmaWVkUmFuZ2UsIGlubmVyQ2hhbmdlcykge1xuICAgICAgICBzdXBlcihvcmlnaW5hbFJhbmdlLCBtb2RpZmllZFJhbmdlKTtcbiAgICAgICAgdGhpcy5pbm5lckNoYW5nZXMgPSBpbm5lckNoYW5nZXM7XG4gICAgfVxuICAgIGZsaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nKHRoaXMubW9kaWZpZWQsIHRoaXMub3JpZ2luYWwsIHRoaXMuaW5uZXJDaGFuZ2VzPy5tYXAoYyA9PiBjLmZsaXAoKSkpO1xuICAgIH1cbiAgICB3aXRoSW5uZXJDaGFuZ2VzRnJvbUxpbmVSYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nKHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIFt0aGlzLnRvUmFuZ2VNYXBwaW5nKCldKTtcbiAgICB9XG59XG4vKipcbiAqIE1hcHMgYSByYW5nZSBpbiB0aGUgb3JpZ2luYWwgdGV4dCBtb2RlbCB0byBhIHJhbmdlIGluIHRoZSBtb2RpZmllZCB0ZXh0IG1vZGVsLlxuICovXG5leHBvcnQgY2xhc3MgUmFuZ2VNYXBwaW5nIHtcbiAgICBzdGF0aWMgYXNzZXJ0U29ydGVkKHJhbmdlTWFwcGluZ3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5nZU1hcHBpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IHJhbmdlTWFwcGluZ3NbaSAtIDFdO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHJhbmdlTWFwcGluZ3NbaV07XG4gICAgICAgICAgICBpZiAoIShwcmV2aW91cy5vcmlnaW5hbFJhbmdlLmdldEVuZFBvc2l0aW9uKCkuaXNCZWZvcmVPckVxdWFsKGN1cnJlbnQub3JpZ2luYWxSYW5nZS5nZXRTdGFydFBvc2l0aW9uKCkpXG4gICAgICAgICAgICAgICAgJiYgcHJldmlvdXMubW9kaWZpZWRSYW5nZS5nZXRFbmRQb3NpdGlvbigpLmlzQmVmb3JlT3JFcXVhbChjdXJyZW50Lm1vZGlmaWVkUmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbigpKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKCdSYW5nZSBtYXBwaW5ncyBtdXN0IGJlIHNvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsUmFuZ2UsIG1vZGlmaWVkUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFJhbmdlID0gb3JpZ2luYWxSYW5nZTtcbiAgICAgICAgdGhpcy5tb2RpZmllZFJhbmdlID0gbW9kaWZpZWRSYW5nZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgeyR7dGhpcy5vcmlnaW5hbFJhbmdlLnRvU3RyaW5nKCl9LT4ke3RoaXMubW9kaWZpZWRSYW5nZS50b1N0cmluZygpfX1gO1xuICAgIH1cbiAgICBmbGlwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlTWFwcGluZyh0aGlzLm1vZGlmaWVkUmFuZ2UsIHRoaXMub3JpZ2luYWxSYW5nZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaW5nbGUgdGV4dCBlZGl0IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2UgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIG1vZGlmaWVkIHRleHQuXG4gICAgKi9cbiAgICB0b1RleHRFZGl0KG1vZGlmaWVkKSB7XG4gICAgICAgIGNvbnN0IG5ld1RleHQgPSBtb2RpZmllZC5nZXRWYWx1ZU9mUmFuZ2UodGhpcy5tb2RpZmllZFJhbmdlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVUZXh0RWRpdCh0aGlzLm9yaWdpbmFsUmFuZ2UsIG5ld1RleHQpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENvZGljb24gfSBmcm9tICcuLi8uLi9iYXNlL2NvbW1vbi9jb2RpY29ucy5qcyc7XG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgVG9rZW5pemF0aW9uUmVnaXN0cnkgYXMgVG9rZW5pemF0aW9uUmVnaXN0cnlJbXBsIH0gZnJvbSAnLi90b2tlbml6YXRpb25SZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyBsb2NhbGl6ZSB9IGZyb20gJy4uLy4uL25scy5qcyc7XG5leHBvcnQgY2xhc3MgVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKG9mZnNldCwgdHlwZSwgbGFuZ3VhZ2UpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgdGhpcy5fdG9rZW5CcmFuZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnKCcgKyB0aGlzLm9mZnNldCArICcsICcgKyB0aGlzLnR5cGUgKyAnKSc7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuaXphdGlvblJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IodG9rZW5zLCBlbmRTdGF0ZSkge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5lbmRTdGF0ZSA9IGVuZFN0YXRlO1xuICAgICAgICB0aGlzLl90b2tlbml6YXRpb25SZXN1bHRCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgRW5jb2RlZFRva2VuaXphdGlvblJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIHRva2VucyBpbiBiaW5hcnkgZm9ybWF0LiBFYWNoIHRva2VuIG9jY3VwaWVzIHR3byBhcnJheSBpbmRpY2VzLiBGb3IgdG9rZW4gaTpcbiAgICAgKiAgLSBhdCBvZmZzZXQgMippID0+IHN0YXJ0SW5kZXhcbiAgICAgKiAgLSBhdCBvZmZzZXQgMippICsgMSA9PiBtZXRhZGF0YVxuICAgICAqXG4gICAgICovXG4gICAgdG9rZW5zLCBlbmRTdGF0ZSkge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5lbmRTdGF0ZSA9IGVuZFN0YXRlO1xuICAgICAgICB0aGlzLl9lbmNvZGVkVG9rZW5pemF0aW9uUmVzdWx0QnJhbmQgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IHZhciBIb3ZlclZlcmJvc2l0eUFjdGlvbjtcbihmdW5jdGlvbiAoSG92ZXJWZXJib3NpdHlBY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBJbmNyZWFzZSB0aGUgdmVyYm9zaXR5IG9mIHRoZSBob3ZlclxuICAgICAqL1xuICAgIEhvdmVyVmVyYm9zaXR5QWN0aW9uW0hvdmVyVmVyYm9zaXR5QWN0aW9uW1wiSW5jcmVhc2VcIl0gPSAwXSA9IFwiSW5jcmVhc2VcIjtcbiAgICAvKipcbiAgICAgKiBEZWNyZWFzZSB0aGUgdmVyYm9zaXR5IG9mIHRoZSBob3ZlclxuICAgICAqL1xuICAgIEhvdmVyVmVyYm9zaXR5QWN0aW9uW0hvdmVyVmVyYm9zaXR5QWN0aW9uW1wiRGVjcmVhc2VcIl0gPSAxXSA9IFwiRGVjcmVhc2VcIjtcbn0pKEhvdmVyVmVyYm9zaXR5QWN0aW9uIHx8IChIb3ZlclZlcmJvc2l0eUFjdGlvbiA9IHt9KSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtS2luZHM7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZHMpIHtcbiAgICBjb25zdCBieUtpbmQgPSBuZXcgTWFwKCk7XG4gICAgYnlLaW5kLnNldCgwIC8qIENvbXBsZXRpb25JdGVtS2luZC5NZXRob2QgKi8sIENvZGljb24uc3ltYm9sTWV0aG9kKTtcbiAgICBieUtpbmQuc2V0KDEgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uICovLCBDb2RpY29uLnN5bWJvbEZ1bmN0aW9uKTtcbiAgICBieUtpbmQuc2V0KDIgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0cnVjdG9yICovLCBDb2RpY29uLnN5bWJvbENvbnN0cnVjdG9yKTtcbiAgICBieUtpbmQuc2V0KDMgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkICovLCBDb2RpY29uLnN5bWJvbEZpZWxkKTtcbiAgICBieUtpbmQuc2V0KDQgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlICovLCBDb2RpY29uLnN5bWJvbFZhcmlhYmxlKTtcbiAgICBieUtpbmQuc2V0KDUgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkNsYXNzICovLCBDb2RpY29uLnN5bWJvbENsYXNzKTtcbiAgICBieUtpbmQuc2V0KDYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCAqLywgQ29kaWNvbi5zeW1ib2xTdHJ1Y3QpO1xuICAgIGJ5S2luZC5zZXQoNyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuSW50ZXJmYWNlICovLCBDb2RpY29uLnN5bWJvbEludGVyZmFjZSk7XG4gICAgYnlLaW5kLnNldCg4IC8qIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUgKi8sIENvZGljb24uc3ltYm9sTW9kdWxlKTtcbiAgICBieUtpbmQuc2V0KDkgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ICovLCBDb2RpY29uLnN5bWJvbFByb3BlcnR5KTtcbiAgICBieUtpbmQuc2V0KDEwIC8qIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCAqLywgQ29kaWNvbi5zeW1ib2xFdmVudCk7XG4gICAgYnlLaW5kLnNldCgxMSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuT3BlcmF0b3IgKi8sIENvZGljb24uc3ltYm9sT3BlcmF0b3IpO1xuICAgIGJ5S2luZC5zZXQoMTIgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlVuaXQgKi8sIENvZGljb24uc3ltYm9sVW5pdCk7XG4gICAgYnlLaW5kLnNldCgxMyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgKi8sIENvZGljb24uc3ltYm9sVmFsdWUpO1xuICAgIGJ5S2luZC5zZXQoMTUgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gKi8sIENvZGljb24uc3ltYm9sRW51bSk7XG4gICAgYnlLaW5kLnNldCgxNCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQgKi8sIENvZGljb24uc3ltYm9sQ29uc3RhbnQpO1xuICAgIGJ5S2luZC5zZXQoMTUgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gKi8sIENvZGljb24uc3ltYm9sRW51bSk7XG4gICAgYnlLaW5kLnNldCgxNiAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRW51bU1lbWJlciAqLywgQ29kaWNvbi5zeW1ib2xFbnVtTWVtYmVyKTtcbiAgICBieUtpbmQuc2V0KDE3IC8qIENvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkICovLCBDb2RpY29uLnN5bWJvbEtleXdvcmQpO1xuICAgIGJ5S2luZC5zZXQoMjcgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgKi8sIENvZGljb24uc3ltYm9sU25pcHBldCk7XG4gICAgYnlLaW5kLnNldCgxOCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCAqLywgQ29kaWNvbi5zeW1ib2xUZXh0KTtcbiAgICBieUtpbmQuc2V0KDE5IC8qIENvbXBsZXRpb25JdGVtS2luZC5Db2xvciAqLywgQ29kaWNvbi5zeW1ib2xDb2xvcik7XG4gICAgYnlLaW5kLnNldCgyMCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSAqLywgQ29kaWNvbi5zeW1ib2xGaWxlKTtcbiAgICBieUtpbmQuc2V0KDIxIC8qIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgKi8sIENvZGljb24uc3ltYm9sUmVmZXJlbmNlKTtcbiAgICBieUtpbmQuc2V0KDIyIC8qIENvbXBsZXRpb25JdGVtS2luZC5DdXN0b21jb2xvciAqLywgQ29kaWNvbi5zeW1ib2xDdXN0b21Db2xvcik7XG4gICAgYnlLaW5kLnNldCgyMyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyICovLCBDb2RpY29uLnN5bWJvbEZvbGRlcik7XG4gICAgYnlLaW5kLnNldCgyNCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVHlwZVBhcmFtZXRlciAqLywgQ29kaWNvbi5zeW1ib2xUeXBlUGFyYW1ldGVyKTtcbiAgICBieUtpbmQuc2V0KDI1IC8qIENvbXBsZXRpb25JdGVtS2luZC5Vc2VyICovLCBDb2RpY29uLmFjY291bnQpO1xuICAgIGJ5S2luZC5zZXQoMjYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLklzc3VlICovLCBDb2RpY29uLmlzc3Vlcyk7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JY29uKGtpbmQpIHtcbiAgICAgICAgbGV0IGNvZGljb24gPSBieUtpbmQuZ2V0KGtpbmQpO1xuICAgICAgICBpZiAoIWNvZGljb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnTm8gY29kaWNvbiBmb3VuZCBmb3IgQ29tcGxldGlvbkl0ZW1LaW5kICcgKyBraW5kKTtcbiAgICAgICAgICAgIGNvZGljb24gPSBDb2RpY29uLnN5bWJvbFByb3BlcnR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RpY29uO1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbUtpbmRzLnRvSWNvbiA9IHRvSWNvbjtcbiAgICBjb25zdCBkYXRhID0gbmV3IE1hcCgpO1xuICAgIGRhdGEuc2V0KCdtZXRob2QnLCAwIC8qIENvbXBsZXRpb25JdGVtS2luZC5NZXRob2QgKi8pO1xuICAgIGRhdGEuc2V0KCdmdW5jdGlvbicsIDEgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uICovKTtcbiAgICBkYXRhLnNldCgnY29uc3RydWN0b3InLCAyIC8qIENvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvciAqLyk7XG4gICAgZGF0YS5zZXQoJ2ZpZWxkJywgMyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRmllbGQgKi8pO1xuICAgIGRhdGEuc2V0KCd2YXJpYWJsZScsIDQgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlICovKTtcbiAgICBkYXRhLnNldCgnY2xhc3MnLCA1IC8qIENvbXBsZXRpb25JdGVtS2luZC5DbGFzcyAqLyk7XG4gICAgZGF0YS5zZXQoJ3N0cnVjdCcsIDYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCAqLyk7XG4gICAgZGF0YS5zZXQoJ2ludGVyZmFjZScsIDcgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZSAqLyk7XG4gICAgZGF0YS5zZXQoJ21vZHVsZScsIDggLyogQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSAqLyk7XG4gICAgZGF0YS5zZXQoJ3Byb3BlcnR5JywgOSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHkgKi8pO1xuICAgIGRhdGEuc2V0KCdldmVudCcsIDEwIC8qIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCAqLyk7XG4gICAgZGF0YS5zZXQoJ29wZXJhdG9yJywgMTEgLyogQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yICovKTtcbiAgICBkYXRhLnNldCgndW5pdCcsIDEyIC8qIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ICovKTtcbiAgICBkYXRhLnNldCgndmFsdWUnLCAxMyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgKi8pO1xuICAgIGRhdGEuc2V0KCdjb25zdGFudCcsIDE0IC8qIENvbXBsZXRpb25JdGVtS2luZC5Db25zdGFudCAqLyk7XG4gICAgZGF0YS5zZXQoJ2VudW0nLCAxNSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRW51bSAqLyk7XG4gICAgZGF0YS5zZXQoJ2VudW0tbWVtYmVyJywgMTYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgKi8pO1xuICAgIGRhdGEuc2V0KCdlbnVtTWVtYmVyJywgMTYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgKi8pO1xuICAgIGRhdGEuc2V0KCdrZXl3b3JkJywgMTcgLyogQ29tcGxldGlvbkl0ZW1LaW5kLktleXdvcmQgKi8pO1xuICAgIGRhdGEuc2V0KCdzbmlwcGV0JywgMjcgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgKi8pO1xuICAgIGRhdGEuc2V0KCd0ZXh0JywgMTggLyogQ29tcGxldGlvbkl0ZW1LaW5kLlRleHQgKi8pO1xuICAgIGRhdGEuc2V0KCdjb2xvcicsIDE5IC8qIENvbXBsZXRpb25JdGVtS2luZC5Db2xvciAqLyk7XG4gICAgZGF0YS5zZXQoJ2ZpbGUnLCAyMCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSAqLyk7XG4gICAgZGF0YS5zZXQoJ3JlZmVyZW5jZScsIDIxIC8qIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgKi8pO1xuICAgIGRhdGEuc2V0KCdjdXN0b21jb2xvcicsIDIyIC8qIENvbXBsZXRpb25JdGVtS2luZC5DdXN0b21jb2xvciAqLyk7XG4gICAgZGF0YS5zZXQoJ2ZvbGRlcicsIDIzIC8qIENvbXBsZXRpb25JdGVtS2luZC5Gb2xkZXIgKi8pO1xuICAgIGRhdGEuc2V0KCd0eXBlLXBhcmFtZXRlcicsIDI0IC8qIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyICovKTtcbiAgICBkYXRhLnNldCgndHlwZVBhcmFtZXRlcicsIDI0IC8qIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyICovKTtcbiAgICBkYXRhLnNldCgnYWNjb3VudCcsIDI1IC8qIENvbXBsZXRpb25JdGVtS2luZC5Vc2VyICovKTtcbiAgICBkYXRhLnNldCgnaXNzdWUnLCAyNiAvKiBDb21wbGV0aW9uSXRlbUtpbmQuSXNzdWUgKi8pO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIHN0cmljdCkge1xuICAgICAgICBsZXQgcmVzID0gZGF0YS5nZXQodmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ3VuZGVmaW5lZCcgJiYgIXN0cmljdCkge1xuICAgICAgICAgICAgcmVzID0gOSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHkgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kcy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbn0pKENvbXBsZXRpb25JdGVtS2luZHMgfHwgKENvbXBsZXRpb25JdGVtS2luZHMgPSB7fSkpO1xuLyoqXG4gKiBIb3cgYW4ge0BsaW5rIElubGluZUNvbXBsZXRpb25zUHJvdmlkZXIgaW5saW5lIGNvbXBsZXRpb24gcHJvdmlkZXJ9IHdhcyB0cmlnZ2VyZWQuXG4gKi9cbmV4cG9ydCB2YXIgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB3aGlsZSBlZGl0aW5nLlxuICAgICAqIEl0IGlzIHN1ZmZpY2llbnQgdG8gcmV0dXJuIGEgc2luZ2xlIGNvbXBsZXRpb24gaXRlbSBpbiB0aGlzIGNhc2UuXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW0lubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtcIkF1dG9tYXRpY1wiXSA9IDBdID0gXCJBdXRvbWF0aWNcIjtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgZXhwbGljaXRseSBieSBhIHVzZXIgZ2VzdHVyZS5cbiAgICAgKiBSZXR1cm4gbXVsdGlwbGUgY29tcGxldGlvbiBpdGVtcyB0byBlbmFibGUgY3ljbGluZyB0aHJvdWdoIHRoZW0uXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW0lubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtcIkV4cGxpY2l0XCJdID0gMV0gPSBcIkV4cGxpY2l0XCI7XG59KShJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IHt9KSk7XG5leHBvcnQgY2xhc3MgU2VsZWN0ZWRTdWdnZXN0aW9uSW5mbyB7XG4gICAgY29uc3RydWN0b3IocmFuZ2UsIHRleHQsIGNvbXBsZXRpb25LaW5kLCBpc1NuaXBwZXRUZXh0KSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uS2luZCA9IGNvbXBsZXRpb25LaW5kO1xuICAgICAgICB0aGlzLmlzU25pcHBldFRleHQgPSBpc1NuaXBwZXRUZXh0O1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmxpZnQodGhpcy5yYW5nZSkuZXF1YWxzUmFuZ2Uob3RoZXIucmFuZ2UpXG4gICAgICAgICAgICAmJiB0aGlzLnRleHQgPT09IG90aGVyLnRleHRcbiAgICAgICAgICAgICYmIHRoaXMuY29tcGxldGlvbktpbmQgPT09IG90aGVyLmNvbXBsZXRpb25LaW5kXG4gICAgICAgICAgICAmJiB0aGlzLmlzU25pcHBldFRleHQgPT09IG90aGVyLmlzU25pcHBldFRleHQ7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudFBhc3RlVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50UGFzdGVUcmlnZ2VyS2luZCkge1xuICAgIERvY3VtZW50UGFzdGVUcmlnZ2VyS2luZFtEb2N1bWVudFBhc3RlVHJpZ2dlcktpbmRbXCJBdXRvbWF0aWNcIl0gPSAwXSA9IFwiQXV0b21hdGljXCI7XG4gICAgRG9jdW1lbnRQYXN0ZVRyaWdnZXJLaW5kW0RvY3VtZW50UGFzdGVUcmlnZ2VyS2luZFtcIlBhc3RlQXNcIl0gPSAxXSA9IFwiUGFzdGVBc1wiO1xufSkoRG9jdW1lbnRQYXN0ZVRyaWdnZXJLaW5kIHx8IChEb2N1bWVudFBhc3RlVHJpZ2dlcktpbmQgPSB7fSkpO1xuZXhwb3J0IHZhciBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCkge1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAxXSA9IFwiSW52b2tlXCI7XG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1NpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtcIlRyaWdnZXJDaGFyYWN0ZXJcIl0gPSAyXSA9IFwiVHJpZ2dlckNoYXJhY3RlclwiO1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbXCJDb250ZW50Q2hhbmdlXCJdID0gM10gPSBcIkNvbnRlbnRDaGFuZ2VcIjtcbn0pKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCB8fCAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCBoaWdobGlnaHQga2luZC5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudEhpZ2hsaWdodEtpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0S2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgdGV4dHVhbCBvY2N1cnJlbmNlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJUZXh0XCJdID0gMF0gPSBcIlRleHRcIjtcbiAgICAvKipcbiAgICAgKiBSZWFkLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSByZWFkaW5nIGEgdmFyaWFibGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kW0RvY3VtZW50SGlnaGxpZ2h0S2luZFtcIlJlYWRcIl0gPSAxXSA9IFwiUmVhZFwiO1xuICAgIC8qKlxuICAgICAqIFdyaXRlLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSB3cml0aW5nIHRvIGEgdmFyaWFibGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kW0RvY3VtZW50SGlnaGxpZ2h0S2luZFtcIldyaXRlXCJdID0gMl0gPSBcIldyaXRlXCI7XG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NhdGlvbkxpbmsodGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmdcbiAgICAgICAgJiYgVVJJLmlzVXJpKHRoaW5nLnVyaSlcbiAgICAgICAgJiYgUmFuZ2UuaXNJUmFuZ2UodGhpbmcucmFuZ2UpXG4gICAgICAgICYmIChSYW5nZS5pc0lSYW5nZSh0aGluZy5vcmlnaW5TZWxlY3Rpb25SYW5nZSkgfHwgUmFuZ2UuaXNJUmFuZ2UodGhpbmcudGFyZ2V0U2VsZWN0aW9uUmFuZ2UpKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBzeW1ib2xLaW5kTmFtZXMgPSB7XG4gICAgWzE3IC8qIFN5bWJvbEtpbmQuQXJyYXkgKi9dOiBsb2NhbGl6ZSgnQXJyYXknLCBcImFycmF5XCIpLFxuICAgIFsxNiAvKiBTeW1ib2xLaW5kLkJvb2xlYW4gKi9dOiBsb2NhbGl6ZSgnQm9vbGVhbicsIFwiYm9vbGVhblwiKSxcbiAgICBbNCAvKiBTeW1ib2xLaW5kLkNsYXNzICovXTogbG9jYWxpemUoJ0NsYXNzJywgXCJjbGFzc1wiKSxcbiAgICBbMTMgLyogU3ltYm9sS2luZC5Db25zdGFudCAqL106IGxvY2FsaXplKCdDb25zdGFudCcsIFwiY29uc3RhbnRcIiksXG4gICAgWzggLyogU3ltYm9sS2luZC5Db25zdHJ1Y3RvciAqL106IGxvY2FsaXplKCdDb25zdHJ1Y3RvcicsIFwiY29uc3RydWN0b3JcIiksXG4gICAgWzkgLyogU3ltYm9sS2luZC5FbnVtICovXTogbG9jYWxpemUoJ0VudW0nLCBcImVudW1lcmF0aW9uXCIpLFxuICAgIFsyMSAvKiBTeW1ib2xLaW5kLkVudW1NZW1iZXIgKi9dOiBsb2NhbGl6ZSgnRW51bU1lbWJlcicsIFwiZW51bWVyYXRpb24gbWVtYmVyXCIpLFxuICAgIFsyMyAvKiBTeW1ib2xLaW5kLkV2ZW50ICovXTogbG9jYWxpemUoJ0V2ZW50JywgXCJldmVudFwiKSxcbiAgICBbNyAvKiBTeW1ib2xLaW5kLkZpZWxkICovXTogbG9jYWxpemUoJ0ZpZWxkJywgXCJmaWVsZFwiKSxcbiAgICBbMCAvKiBTeW1ib2xLaW5kLkZpbGUgKi9dOiBsb2NhbGl6ZSgnRmlsZScsIFwiZmlsZVwiKSxcbiAgICBbMTEgLyogU3ltYm9sS2luZC5GdW5jdGlvbiAqL106IGxvY2FsaXplKCdGdW5jdGlvbicsIFwiZnVuY3Rpb25cIiksXG4gICAgWzEwIC8qIFN5bWJvbEtpbmQuSW50ZXJmYWNlICovXTogbG9jYWxpemUoJ0ludGVyZmFjZScsIFwiaW50ZXJmYWNlXCIpLFxuICAgIFsxOSAvKiBTeW1ib2xLaW5kLktleSAqL106IGxvY2FsaXplKCdLZXknLCBcImtleVwiKSxcbiAgICBbNSAvKiBTeW1ib2xLaW5kLk1ldGhvZCAqL106IGxvY2FsaXplKCdNZXRob2QnLCBcIm1ldGhvZFwiKSxcbiAgICBbMSAvKiBTeW1ib2xLaW5kLk1vZHVsZSAqL106IGxvY2FsaXplKCdNb2R1bGUnLCBcIm1vZHVsZVwiKSxcbiAgICBbMiAvKiBTeW1ib2xLaW5kLk5hbWVzcGFjZSAqL106IGxvY2FsaXplKCdOYW1lc3BhY2UnLCBcIm5hbWVzcGFjZVwiKSxcbiAgICBbMjAgLyogU3ltYm9sS2luZC5OdWxsICovXTogbG9jYWxpemUoJ051bGwnLCBcIm51bGxcIiksXG4gICAgWzE1IC8qIFN5bWJvbEtpbmQuTnVtYmVyICovXTogbG9jYWxpemUoJ051bWJlcicsIFwibnVtYmVyXCIpLFxuICAgIFsxOCAvKiBTeW1ib2xLaW5kLk9iamVjdCAqL106IGxvY2FsaXplKCdPYmplY3QnLCBcIm9iamVjdFwiKSxcbiAgICBbMjQgLyogU3ltYm9sS2luZC5PcGVyYXRvciAqL106IGxvY2FsaXplKCdPcGVyYXRvcicsIFwib3BlcmF0b3JcIiksXG4gICAgWzMgLyogU3ltYm9sS2luZC5QYWNrYWdlICovXTogbG9jYWxpemUoJ1BhY2thZ2UnLCBcInBhY2thZ2VcIiksXG4gICAgWzYgLyogU3ltYm9sS2luZC5Qcm9wZXJ0eSAqL106IGxvY2FsaXplKCdQcm9wZXJ0eScsIFwicHJvcGVydHlcIiksXG4gICAgWzE0IC8qIFN5bWJvbEtpbmQuU3RyaW5nICovXTogbG9jYWxpemUoJ1N0cmluZycsIFwic3RyaW5nXCIpLFxuICAgIFsyMiAvKiBTeW1ib2xLaW5kLlN0cnVjdCAqL106IGxvY2FsaXplKCdTdHJ1Y3QnLCBcInN0cnVjdFwiKSxcbiAgICBbMjUgLyogU3ltYm9sS2luZC5UeXBlUGFyYW1ldGVyICovXTogbG9jYWxpemUoJ1R5cGVQYXJhbWV0ZXInLCBcInR5cGUgcGFyYW1ldGVyXCIpLFxuICAgIFsxMiAvKiBTeW1ib2xLaW5kLlZhcmlhYmxlICovXTogbG9jYWxpemUoJ1ZhcmlhYmxlJywgXCJ2YXJpYWJsZVwiKSxcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJpYUxhYmVsRm9yU3ltYm9sKHN5bWJvbE5hbWUsIGtpbmQpIHtcbiAgICByZXR1cm4gbG9jYWxpemUoJ3N5bWJvbEFyaWFMYWJlbCcsICd7MH0gKHsxfSknLCBzeW1ib2xOYW1lLCBzeW1ib2xLaW5kTmFtZXNba2luZF0pO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHZhciBTeW1ib2xLaW5kcztcbihmdW5jdGlvbiAoU3ltYm9sS2luZHMpIHtcbiAgICBjb25zdCBieUtpbmQgPSBuZXcgTWFwKCk7XG4gICAgYnlLaW5kLnNldCgwIC8qIFN5bWJvbEtpbmQuRmlsZSAqLywgQ29kaWNvbi5zeW1ib2xGaWxlKTtcbiAgICBieUtpbmQuc2V0KDEgLyogU3ltYm9sS2luZC5Nb2R1bGUgKi8sIENvZGljb24uc3ltYm9sTW9kdWxlKTtcbiAgICBieUtpbmQuc2V0KDIgLyogU3ltYm9sS2luZC5OYW1lc3BhY2UgKi8sIENvZGljb24uc3ltYm9sTmFtZXNwYWNlKTtcbiAgICBieUtpbmQuc2V0KDMgLyogU3ltYm9sS2luZC5QYWNrYWdlICovLCBDb2RpY29uLnN5bWJvbFBhY2thZ2UpO1xuICAgIGJ5S2luZC5zZXQoNCAvKiBTeW1ib2xLaW5kLkNsYXNzICovLCBDb2RpY29uLnN5bWJvbENsYXNzKTtcbiAgICBieUtpbmQuc2V0KDUgLyogU3ltYm9sS2luZC5NZXRob2QgKi8sIENvZGljb24uc3ltYm9sTWV0aG9kKTtcbiAgICBieUtpbmQuc2V0KDYgLyogU3ltYm9sS2luZC5Qcm9wZXJ0eSAqLywgQ29kaWNvbi5zeW1ib2xQcm9wZXJ0eSk7XG4gICAgYnlLaW5kLnNldCg3IC8qIFN5bWJvbEtpbmQuRmllbGQgKi8sIENvZGljb24uc3ltYm9sRmllbGQpO1xuICAgIGJ5S2luZC5zZXQoOCAvKiBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yICovLCBDb2RpY29uLnN5bWJvbENvbnN0cnVjdG9yKTtcbiAgICBieUtpbmQuc2V0KDkgLyogU3ltYm9sS2luZC5FbnVtICovLCBDb2RpY29uLnN5bWJvbEVudW0pO1xuICAgIGJ5S2luZC5zZXQoMTAgLyogU3ltYm9sS2luZC5JbnRlcmZhY2UgKi8sIENvZGljb24uc3ltYm9sSW50ZXJmYWNlKTtcbiAgICBieUtpbmQuc2V0KDExIC8qIFN5bWJvbEtpbmQuRnVuY3Rpb24gKi8sIENvZGljb24uc3ltYm9sRnVuY3Rpb24pO1xuICAgIGJ5S2luZC5zZXQoMTIgLyogU3ltYm9sS2luZC5WYXJpYWJsZSAqLywgQ29kaWNvbi5zeW1ib2xWYXJpYWJsZSk7XG4gICAgYnlLaW5kLnNldCgxMyAvKiBTeW1ib2xLaW5kLkNvbnN0YW50ICovLCBDb2RpY29uLnN5bWJvbENvbnN0YW50KTtcbiAgICBieUtpbmQuc2V0KDE0IC8qIFN5bWJvbEtpbmQuU3RyaW5nICovLCBDb2RpY29uLnN5bWJvbFN0cmluZyk7XG4gICAgYnlLaW5kLnNldCgxNSAvKiBTeW1ib2xLaW5kLk51bWJlciAqLywgQ29kaWNvbi5zeW1ib2xOdW1iZXIpO1xuICAgIGJ5S2luZC5zZXQoMTYgLyogU3ltYm9sS2luZC5Cb29sZWFuICovLCBDb2RpY29uLnN5bWJvbEJvb2xlYW4pO1xuICAgIGJ5S2luZC5zZXQoMTcgLyogU3ltYm9sS2luZC5BcnJheSAqLywgQ29kaWNvbi5zeW1ib2xBcnJheSk7XG4gICAgYnlLaW5kLnNldCgxOCAvKiBTeW1ib2xLaW5kLk9iamVjdCAqLywgQ29kaWNvbi5zeW1ib2xPYmplY3QpO1xuICAgIGJ5S2luZC5zZXQoMTkgLyogU3ltYm9sS2luZC5LZXkgKi8sIENvZGljb24uc3ltYm9sS2V5KTtcbiAgICBieUtpbmQuc2V0KDIwIC8qIFN5bWJvbEtpbmQuTnVsbCAqLywgQ29kaWNvbi5zeW1ib2xOdWxsKTtcbiAgICBieUtpbmQuc2V0KDIxIC8qIFN5bWJvbEtpbmQuRW51bU1lbWJlciAqLywgQ29kaWNvbi5zeW1ib2xFbnVtTWVtYmVyKTtcbiAgICBieUtpbmQuc2V0KDIyIC8qIFN5bWJvbEtpbmQuU3RydWN0ICovLCBDb2RpY29uLnN5bWJvbFN0cnVjdCk7XG4gICAgYnlLaW5kLnNldCgyMyAvKiBTeW1ib2xLaW5kLkV2ZW50ICovLCBDb2RpY29uLnN5bWJvbEV2ZW50KTtcbiAgICBieUtpbmQuc2V0KDI0IC8qIFN5bWJvbEtpbmQuT3BlcmF0b3IgKi8sIENvZGljb24uc3ltYm9sT3BlcmF0b3IpO1xuICAgIGJ5S2luZC5zZXQoMjUgLyogU3ltYm9sS2luZC5UeXBlUGFyYW1ldGVyICovLCBDb2RpY29uLnN5bWJvbFR5cGVQYXJhbWV0ZXIpO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSWNvbihraW5kKSB7XG4gICAgICAgIGxldCBpY29uID0gYnlLaW5kLmdldChraW5kKTtcbiAgICAgICAgaWYgKCFpY29uKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ05vIGNvZGljb24gZm91bmQgZm9yIFN5bWJvbEtpbmQgJyArIGtpbmQpO1xuICAgICAgICAgICAgaWNvbiA9IENvZGljb24uc3ltYm9sUHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGljb247XG4gICAgfVxuICAgIFN5bWJvbEtpbmRzLnRvSWNvbiA9IHRvSWNvbjtcbn0pKFN5bWJvbEtpbmRzIHx8IChTeW1ib2xLaW5kcyA9IHt9KSk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgVGV4dEVkaXQge1xufVxuZXhwb3J0IGNsYXNzIEZvbGRpbmdSYW5nZUtpbmQge1xuICAgIC8qKlxuICAgICAqIEtpbmQgZm9yIGZvbGRpbmcgcmFuZ2UgcmVwcmVzZW50aW5nIGEgY29tbWVudC4gVGhlIHZhbHVlIG9mIHRoZSBraW5kIGlzICdjb21tZW50Jy5cbiAgICAgKi9cbiAgICBzdGF0aWMgeyB0aGlzLkNvbW1lbnQgPSBuZXcgRm9sZGluZ1JhbmdlS2luZCgnY29tbWVudCcpOyB9XG4gICAgLyoqXG4gICAgICogS2luZCBmb3IgZm9sZGluZyByYW5nZSByZXByZXNlbnRpbmcgYSBpbXBvcnQuIFRoZSB2YWx1ZSBvZiB0aGUga2luZCBpcyAnaW1wb3J0cycuXG4gICAgICovXG4gICAgc3RhdGljIHsgdGhpcy5JbXBvcnRzID0gbmV3IEZvbGRpbmdSYW5nZUtpbmQoJ2ltcG9ydHMnKTsgfVxuICAgIC8qKlxuICAgICAqIEtpbmQgZm9yIGZvbGRpbmcgcmFuZ2UgcmVwcmVzZW50aW5nIHJlZ2lvbnMgKGZvciBleGFtcGxlIG1hcmtlZCBieSBgI3JlZ2lvbmAsIGAjZW5kcmVnaW9uYCkuXG4gICAgICogVGhlIHZhbHVlIG9mIHRoZSBraW5kIGlzICdyZWdpb24nLlxuICAgICAqL1xuICAgIHN0YXRpYyB7IHRoaXMuUmVnaW9uID0gbmV3IEZvbGRpbmdSYW5nZUtpbmQoJ3JlZ2lvbicpOyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBGb2xkaW5nUmFuZ2VLaW5kfSBmb3IgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIG9mIHRoZSBraW5kLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVmFsdWUodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6IHJldHVybiBGb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQ7XG4gICAgICAgICAgICBjYXNlICdpbXBvcnRzJzogcmV0dXJuIEZvbGRpbmdSYW5nZUtpbmQuSW1wb3J0cztcbiAgICAgICAgICAgIGNhc2UgJ3JlZ2lvbic6IHJldHVybiBGb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvbGRpbmdSYW5nZUtpbmQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBGb2xkaW5nUmFuZ2VLaW5kfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBvZiB0aGUga2luZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0IHZhciBOZXdTeW1ib2xOYW1lVGFnO1xuKGZ1bmN0aW9uIChOZXdTeW1ib2xOYW1lVGFnKSB7XG4gICAgTmV3U3ltYm9sTmFtZVRhZ1tOZXdTeW1ib2xOYW1lVGFnW1wiQUlHZW5lcmF0ZWRcIl0gPSAxXSA9IFwiQUlHZW5lcmF0ZWRcIjtcbn0pKE5ld1N5bWJvbE5hbWVUYWcgfHwgKE5ld1N5bWJvbE5hbWVUYWcgPSB7fSkpO1xuZXhwb3J0IHZhciBOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZCkge1xuICAgIE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZFtOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAwXSA9IFwiSW52b2tlXCI7XG4gICAgTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kW05ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZFtcIkF1dG9tYXRpY1wiXSA9IDFdID0gXCJBdXRvbWF0aWNcIjtcbn0pKE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZCB8fCAoTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB2YXIgQ29tbWFuZDtcbihmdW5jdGlvbiAoQ29tbWFuZCkge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKG9iaikge1xuICAgICAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqLmlkID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai50aXRsZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIENvbW1hbmQuaXMgPSBpcztcbn0pKENvbW1hbmQgfHwgKENvbW1hbmQgPSB7fSkpO1xuZXhwb3J0IHZhciBJbmxheUhpbnRLaW5kO1xuKGZ1bmN0aW9uIChJbmxheUhpbnRLaW5kKSB7XG4gICAgSW5sYXlIaW50S2luZFtJbmxheUhpbnRLaW5kW1wiVHlwZVwiXSA9IDFdID0gXCJUeXBlXCI7XG4gICAgSW5sYXlIaW50S2luZFtJbmxheUhpbnRLaW5kW1wiUGFyYW1ldGVyXCJdID0gMl0gPSBcIlBhcmFtZXRlclwiO1xufSkoSW5sYXlIaW50S2luZCB8fCAoSW5sYXlIaW50S2luZCA9IHt9KSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgTGF6eVRva2VuaXphdGlvblN1cHBvcnQge1xuICAgIGNvbnN0cnVjdG9yKGNyZWF0ZVN1cHBvcnQpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVTdXBwb3J0ID0gY3JlYXRlU3VwcG9ydDtcbiAgICAgICAgdGhpcy5fdG9rZW5pemF0aW9uU3VwcG9ydCA9IG51bGw7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0LnRoZW4oKHN1cHBvcnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdG9rZW5pemF0aW9uU3VwcG9ydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0ID0gdGhpcy5jcmVhdGVTdXBwb3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnQ7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IFRva2VuaXphdGlvblJlZ2lzdHJ5ID0gbmV3IFRva2VuaXphdGlvblJlZ2lzdHJ5SW1wbCgpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IFRyZWVTaXR0ZXJUb2tlbml6YXRpb25SZWdpc3RyeSA9IG5ldyBUb2tlbml6YXRpb25SZWdpc3RyeUltcGwoKTtcbmV4cG9ydCB2YXIgSW5saW5lRWRpdFRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChJbmxpbmVFZGl0VHJpZ2dlcktpbmQpIHtcbiAgICBJbmxpbmVFZGl0VHJpZ2dlcktpbmRbSW5saW5lRWRpdFRyaWdnZXJLaW5kW1wiSW52b2tlXCJdID0gMF0gPSBcIkludm9rZVwiO1xuICAgIElubGluZUVkaXRUcmlnZ2VyS2luZFtJbmxpbmVFZGl0VHJpZ2dlcktpbmRbXCJBdXRvbWF0aWNcIl0gPSAxXSA9IFwiQXV0b21hdGljXCI7XG59KShJbmxpbmVFZGl0VHJpZ2dlcktpbmQgfHwgKElubGluZUVkaXRUcmlnZ2VyS2luZCA9IHt9KSk7XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IENvbG9yLCBIU0xBIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vY29sb3IuanMnO1xuZnVuY3Rpb24gX3BhcnNlQ2FwdHVyZUdyb3VwcyhjYXB0dXJlR3JvdXBzKSB7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIChjb25zdCBjYXB0dXJlR3JvdXAgb2YgY2FwdHVyZUdyb3Vwcykge1xuICAgICAgICBjb25zdCBwYXJzZWROdW1iZXIgPSBOdW1iZXIoY2FwdHVyZUdyb3VwKTtcbiAgICAgICAgaWYgKHBhcnNlZE51bWJlciB8fCBwYXJzZWROdW1iZXIgPT09IDAgJiYgY2FwdHVyZUdyb3VwLnJlcGxhY2UoL1xccy9nLCAnJykgIT09ICcnKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChwYXJzZWROdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBfdG9JQ29sb3IociwgZywgYiwgYSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZDogciAvIDI1NSxcbiAgICAgICAgYmx1ZTogYiAvIDI1NSxcbiAgICAgICAgZ3JlZW46IGcgLyAyNTUsXG4gICAgICAgIGFscGhhOiBhXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9maW5kUmFuZ2UobW9kZWwsIG1hdGNoKSB7XG4gICAgY29uc3QgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICBjb25zdCBsZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBtb2RlbC5wb3NpdGlvbkF0KGluZGV4KTtcbiAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBzdGFydFBvc2l0aW9uLmxpbmVOdW1iZXIsXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBzdGFydFBvc2l0aW9uLmNvbHVtbixcbiAgICAgICAgZW5kTGluZU51bWJlcjogc3RhcnRQb3NpdGlvbi5saW5lTnVtYmVyLFxuICAgICAgICBlbmRDb2x1bW46IHN0YXJ0UG9zaXRpb24uY29sdW1uICsgbGVuZ3RoXG4gICAgfTtcbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBfZmluZEhleENvbG9ySW5mb3JtYXRpb24ocmFuZ2UsIGhleFZhbHVlKSB7XG4gICAgaWYgKCFyYW5nZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZEhleENvbG9yID0gQ29sb3IuRm9ybWF0LkNTUy5wYXJzZUhleChoZXhWYWx1ZSk7XG4gICAgaWYgKCFwYXJzZWRIZXhDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgY29sb3I6IF90b0lDb2xvcihwYXJzZWRIZXhDb2xvci5yZ2JhLnIsIHBhcnNlZEhleENvbG9yLnJnYmEuZywgcGFyc2VkSGV4Q29sb3IucmdiYS5iLCBwYXJzZWRIZXhDb2xvci5yZ2JhLmEpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9maW5kUkdCQ29sb3JJbmZvcm1hdGlvbihyYW5nZSwgbWF0Y2hlcywgaXNBbHBoYSkge1xuICAgIGlmICghcmFuZ2UgfHwgbWF0Y2hlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbMF07XG4gICAgY29uc3QgY2FwdHVyZUdyb3VwcyA9IG1hdGNoLnZhbHVlcygpO1xuICAgIGNvbnN0IHBhcnNlZFJlZ2V4ID0gX3BhcnNlQ2FwdHVyZUdyb3VwcyhjYXB0dXJlR3JvdXBzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgIGNvbG9yOiBfdG9JQ29sb3IocGFyc2VkUmVnZXhbMF0sIHBhcnNlZFJlZ2V4WzFdLCBwYXJzZWRSZWdleFsyXSwgaXNBbHBoYSA/IHBhcnNlZFJlZ2V4WzNdIDogMSlcbiAgICB9O1xufVxuZnVuY3Rpb24gX2ZpbmRIU0xDb2xvckluZm9ybWF0aW9uKHJhbmdlLCBtYXRjaGVzLCBpc0FscGhhKSB7XG4gICAgaWYgKCFyYW5nZSB8fCBtYXRjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1swXTtcbiAgICBjb25zdCBjYXB0dXJlR3JvdXBzID0gbWF0Y2gudmFsdWVzKCk7XG4gICAgY29uc3QgcGFyc2VkUmVnZXggPSBfcGFyc2VDYXB0dXJlR3JvdXBzKGNhcHR1cmVHcm91cHMpO1xuICAgIGNvbnN0IGNvbG9yRXF1aXZhbGVudCA9IG5ldyBDb2xvcihuZXcgSFNMQShwYXJzZWRSZWdleFswXSwgcGFyc2VkUmVnZXhbMV0gLyAxMDAsIHBhcnNlZFJlZ2V4WzJdIC8gMTAwLCBpc0FscGhhID8gcGFyc2VkUmVnZXhbM10gOiAxKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICBjb2xvcjogX3RvSUNvbG9yKGNvbG9yRXF1aXZhbGVudC5yZ2JhLnIsIGNvbG9yRXF1aXZhbGVudC5yZ2JhLmcsIGNvbG9yRXF1aXZhbGVudC5yZ2JhLmIsIGNvbG9yRXF1aXZhbGVudC5yZ2JhLmEpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9maW5kTWF0Y2hlcyhtb2RlbCwgcmVnZXgpIHtcbiAgICBpZiAodHlwZW9mIG1vZGVsID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gWy4uLm1vZGVsLm1hdGNoQWxsKHJlZ2V4KV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbW9kZWwuZmluZE1hdGNoZXMocmVnZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb2xvcnMobW9kZWwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAvLyBFYXJseSB2YWxpZGF0aW9uIGZvciBSR0IgYW5kIEhTTFxuICAgIGNvbnN0IGluaXRpYWxWYWxpZGF0aW9uUmVnZXggPSAvXFxiKHJnYnxyZ2JhfGhzbHxoc2xhKShcXChbMC05XFxzLC5cXCVdKlxcKSl8KCMpKFtBLUZhLWYwLTldezN9KVxcYnwoIykoW0EtRmEtZjAtOV17NH0pXFxifCgjKShbQS1GYS1mMC05XXs2fSlcXGJ8KCMpKFtBLUZhLWYwLTldezh9KVxcYi9nbTtcbiAgICBjb25zdCBpbml0aWFsVmFsaWRhdGlvbk1hdGNoZXMgPSBfZmluZE1hdGNoZXMobW9kZWwsIGluaXRpYWxWYWxpZGF0aW9uUmVnZXgpO1xuICAgIC8vIFBvdGVudGlhbCBjb2xvcnMgaGF2ZSBiZWVuIGZvdW5kLCB2YWxpZGF0ZSB0aGUgcGFyYW1ldGVyc1xuICAgIGlmIChpbml0aWFsVmFsaWRhdGlvbk1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IGluaXRpYWxNYXRjaCBvZiBpbml0aWFsVmFsaWRhdGlvbk1hdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxDYXB0dXJlR3JvdXBzID0gaW5pdGlhbE1hdGNoLmZpbHRlcihjYXB0dXJlR3JvdXAgPT4gY2FwdHVyZUdyb3VwICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgY29sb3JTY2hlbWUgPSBpbml0aWFsQ2FwdHVyZUdyb3Vwc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yUGFyYW1ldGVycyA9IGluaXRpYWxDYXB0dXJlR3JvdXBzWzJdO1xuICAgICAgICAgICAgaWYgKCFjb2xvclBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb2xvckluZm9ybWF0aW9uO1xuICAgICAgICAgICAgaWYgKGNvbG9yU2NoZW1lID09PSAncmdiJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4UGFyYW1ldGVycyA9IC9eXFwoXFxzKigyNVswLTVdfDJbMC00XVswLTldfDFbMC05XXsyfXxbMS05XVswLTldfFswLTldKVxccyosXFxzKigyNVswLTVdfDJbMC00XVswLTldfDFbMC05XXsyfXxbMS05XVswLTldfFswLTldKVxccyosXFxzKigyNVswLTVdfDJbMC00XVswLTldfDFbMC05XXsyfXxbMS05XVswLTldfFswLTldKVxccypcXCkkL2dtO1xuICAgICAgICAgICAgICAgIGNvbG9ySW5mb3JtYXRpb24gPSBfZmluZFJHQkNvbG9ySW5mb3JtYXRpb24oX2ZpbmRSYW5nZShtb2RlbCwgaW5pdGlhbE1hdGNoKSwgX2ZpbmRNYXRjaGVzKGNvbG9yUGFyYW1ldGVycywgcmVnZXhQYXJhbWV0ZXJzKSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29sb3JTY2hlbWUgPT09ICdyZ2JhJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4UGFyYW1ldGVycyA9IC9eXFwoXFxzKigyNVswLTVdfDJbMC00XVswLTldfDFbMC05XXsyfXxbMS05XVswLTldfFswLTldKVxccyosXFxzKigyNVswLTVdfDJbMC00XVswLTldfDFbMC05XXsyfXxbMS05XVswLTldfFswLTldKVxccyosXFxzKigyNVswLTVdfDJbMC00XVswLTldfDFbMC05XXsyfXxbMS05XVswLTldfFswLTldKVxccyosXFxzKigwWy5dWzAtOV0rfFsuXVswLTldK3xbMDFdWy5dfFswMV0pXFxzKlxcKSQvZ207XG4gICAgICAgICAgICAgICAgY29sb3JJbmZvcm1hdGlvbiA9IF9maW5kUkdCQ29sb3JJbmZvcm1hdGlvbihfZmluZFJhbmdlKG1vZGVsLCBpbml0aWFsTWF0Y2gpLCBfZmluZE1hdGNoZXMoY29sb3JQYXJhbWV0ZXJzLCByZWdleFBhcmFtZXRlcnMpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yU2NoZW1lID09PSAnaHNsJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4UGFyYW1ldGVycyA9IC9eXFwoXFxzKigzNlswXXwzWzAtNV1bMC05XXxbMTJdWzAtOV1bMC05XXxbMS05XT9bMC05XSlcXHMqLFxccyooMTAwfFxcZHsxLDJ9Wy5dXFxkKnxcXGR7MSwyfSklXFxzKixcXHMqKDEwMHxcXGR7MSwyfVsuXVxcZCp8XFxkezEsMn0pJVxccypcXCkkL2dtO1xuICAgICAgICAgICAgICAgIGNvbG9ySW5mb3JtYXRpb24gPSBfZmluZEhTTENvbG9ySW5mb3JtYXRpb24oX2ZpbmRSYW5nZShtb2RlbCwgaW5pdGlhbE1hdGNoKSwgX2ZpbmRNYXRjaGVzKGNvbG9yUGFyYW1ldGVycywgcmVnZXhQYXJhbWV0ZXJzKSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29sb3JTY2hlbWUgPT09ICdoc2xhJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4UGFyYW1ldGVycyA9IC9eXFwoXFxzKigzNlswXXwzWzAtNV1bMC05XXxbMTJdWzAtOV1bMC05XXxbMS05XT9bMC05XSlcXHMqLFxccyooMTAwfFxcZHsxLDJ9Wy5dXFxkKnxcXGR7MSwyfSklXFxzKixcXHMqKDEwMHxcXGR7MSwyfVsuXVxcZCp8XFxkezEsMn0pJVxccyosXFxzKigwWy5dWzAtOV0rfFsuXVswLTldK3xbMDFdWy5dfFswMV0pXFxzKlxcKSQvZ207XG4gICAgICAgICAgICAgICAgY29sb3JJbmZvcm1hdGlvbiA9IF9maW5kSFNMQ29sb3JJbmZvcm1hdGlvbihfZmluZFJhbmdlKG1vZGVsLCBpbml0aWFsTWF0Y2gpLCBfZmluZE1hdGNoZXMoY29sb3JQYXJhbWV0ZXJzLCByZWdleFBhcmFtZXRlcnMpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yU2NoZW1lID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICBjb2xvckluZm9ybWF0aW9uID0gX2ZpbmRIZXhDb2xvckluZm9ybWF0aW9uKF9maW5kUmFuZ2UobW9kZWwsIGluaXRpYWxNYXRjaCksIGNvbG9yU2NoZW1lICsgY29sb3JQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2xvckluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29sb3JJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGVmYXVsdCBkb2N1bWVudCBjb2xvcnMgaW4gdGhlIHByb3ZpZGVkIGRvY3VtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRGVmYXVsdERvY3VtZW50Q29sb3JzKG1vZGVsKSB7XG4gICAgaWYgKCFtb2RlbCB8fCB0eXBlb2YgbW9kZWwuZ2V0VmFsdWUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG1vZGVsLnBvc2l0aW9uQXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVW5rbm93biBjYWxsZXIhXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXB1dGVDb2xvcnMobW9kZWwpO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBDaGFyYWN0ZXJDbGFzc2lmaWVyIH0gZnJvbSAnLi4vY29yZS9jaGFyYWN0ZXJDbGFzc2lmaWVyLmpzJztcbmNsYXNzIFVpbnQ4TWF0cml4IHtcbiAgICBjb25zdHJ1Y3Rvcihyb3dzLCBjb2xzLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJvd3MgKiBjb2xzOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGRhdGFbaV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuY29scyA9IGNvbHM7XG4gICAgfVxuICAgIGdldChyb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtyb3cgKiB0aGlzLmNvbHMgKyBjb2xdO1xuICAgIH1cbiAgICBzZXQocm93LCBjb2wsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2RhdGFbcm93ICogdGhpcy5jb2xzICsgY29sXSA9IHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTdGF0ZU1hY2hpbmUge1xuICAgIGNvbnN0cnVjdG9yKGVkZ2VzKSB7XG4gICAgICAgIGxldCBtYXhDaGFyQ29kZSA9IDA7XG4gICAgICAgIGxldCBtYXhTdGF0ZSA9IDAgLyogU3RhdGUuSW52YWxpZCAqLztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVkZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBbZnJvbSwgY2hDb2RlLCB0b10gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIGlmIChjaENvZGUgPiBtYXhDaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgIG1heENoYXJDb2RlID0gY2hDb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb20gPiBtYXhTdGF0ZSkge1xuICAgICAgICAgICAgICAgIG1heFN0YXRlID0gZnJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0byA+IG1heFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgbWF4U3RhdGUgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXhDaGFyQ29kZSsrO1xuICAgICAgICBtYXhTdGF0ZSsrO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBuZXcgVWludDhNYXRyaXgobWF4U3RhdGUsIG1heENoYXJDb2RlLCAwIC8qIFN0YXRlLkludmFsaWQgKi8pO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWRnZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFtmcm9tLCBjaENvZGUsIHRvXSA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgc3RhdGVzLnNldChmcm9tLCBjaENvZGUsIHRvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgICAgIHRoaXMuX21heENoYXJDb2RlID0gbWF4Q2hhckNvZGU7XG4gICAgfVxuICAgIG5leHRTdGF0ZShjdXJyZW50U3RhdGUsIGNoQ29kZSkge1xuICAgICAgICBpZiAoY2hDb2RlIDwgMCB8fCBjaENvZGUgPj0gdGhpcy5fbWF4Q2hhckNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIFN0YXRlLkludmFsaWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlcy5nZXQoY3VycmVudFN0YXRlLCBjaENvZGUpO1xuICAgIH1cbn1cbi8vIFN0YXRlIG1hY2hpbmUgZm9yIGh0dHA6Ly8gb3IgaHR0cHM6Ly8gb3IgZmlsZTovL1xubGV0IF9zdGF0ZU1hY2hpbmUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0U3RhdGVNYWNoaW5lKCkge1xuICAgIGlmIChfc3RhdGVNYWNoaW5lID09PSBudWxsKSB7XG4gICAgICAgIF9zdGF0ZU1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKFtcbiAgICAgICAgICAgIFsxIC8qIFN0YXRlLlN0YXJ0ICovLCAxMDQgLyogQ2hhckNvZGUuaCAqLywgMiAvKiBTdGF0ZS5IICovXSxcbiAgICAgICAgICAgIFsxIC8qIFN0YXRlLlN0YXJ0ICovLCA3MiAvKiBDaGFyQ29kZS5IICovLCAyIC8qIFN0YXRlLkggKi9dLFxuICAgICAgICAgICAgWzEgLyogU3RhdGUuU3RhcnQgKi8sIDEwMiAvKiBDaGFyQ29kZS5mICovLCA2IC8qIFN0YXRlLkYgKi9dLFxuICAgICAgICAgICAgWzEgLyogU3RhdGUuU3RhcnQgKi8sIDcwIC8qIENoYXJDb2RlLkYgKi8sIDYgLyogU3RhdGUuRiAqL10sXG4gICAgICAgICAgICBbMiAvKiBTdGF0ZS5IICovLCAxMTYgLyogQ2hhckNvZGUudCAqLywgMyAvKiBTdGF0ZS5IVCAqL10sXG4gICAgICAgICAgICBbMiAvKiBTdGF0ZS5IICovLCA4NCAvKiBDaGFyQ29kZS5UICovLCAzIC8qIFN0YXRlLkhUICovXSxcbiAgICAgICAgICAgIFszIC8qIFN0YXRlLkhUICovLCAxMTYgLyogQ2hhckNvZGUudCAqLywgNCAvKiBTdGF0ZS5IVFQgKi9dLFxuICAgICAgICAgICAgWzMgLyogU3RhdGUuSFQgKi8sIDg0IC8qIENoYXJDb2RlLlQgKi8sIDQgLyogU3RhdGUuSFRUICovXSxcbiAgICAgICAgICAgIFs0IC8qIFN0YXRlLkhUVCAqLywgMTEyIC8qIENoYXJDb2RlLnAgKi8sIDUgLyogU3RhdGUuSFRUUCAqL10sXG4gICAgICAgICAgICBbNCAvKiBTdGF0ZS5IVFQgKi8sIDgwIC8qIENoYXJDb2RlLlAgKi8sIDUgLyogU3RhdGUuSFRUUCAqL10sXG4gICAgICAgICAgICBbNSAvKiBTdGF0ZS5IVFRQICovLCAxMTUgLyogQ2hhckNvZGUucyAqLywgOSAvKiBTdGF0ZS5CZWZvcmVDb2xvbiAqL10sXG4gICAgICAgICAgICBbNSAvKiBTdGF0ZS5IVFRQICovLCA4MyAvKiBDaGFyQ29kZS5TICovLCA5IC8qIFN0YXRlLkJlZm9yZUNvbG9uICovXSxcbiAgICAgICAgICAgIFs1IC8qIFN0YXRlLkhUVFAgKi8sIDU4IC8qIENoYXJDb2RlLkNvbG9uICovLCAxMCAvKiBTdGF0ZS5BZnRlckNvbG9uICovXSxcbiAgICAgICAgICAgIFs2IC8qIFN0YXRlLkYgKi8sIDEwNSAvKiBDaGFyQ29kZS5pICovLCA3IC8qIFN0YXRlLkZJICovXSxcbiAgICAgICAgICAgIFs2IC8qIFN0YXRlLkYgKi8sIDczIC8qIENoYXJDb2RlLkkgKi8sIDcgLyogU3RhdGUuRkkgKi9dLFxuICAgICAgICAgICAgWzcgLyogU3RhdGUuRkkgKi8sIDEwOCAvKiBDaGFyQ29kZS5sICovLCA4IC8qIFN0YXRlLkZJTCAqL10sXG4gICAgICAgICAgICBbNyAvKiBTdGF0ZS5GSSAqLywgNzYgLyogQ2hhckNvZGUuTCAqLywgOCAvKiBTdGF0ZS5GSUwgKi9dLFxuICAgICAgICAgICAgWzggLyogU3RhdGUuRklMICovLCAxMDEgLyogQ2hhckNvZGUuZSAqLywgOSAvKiBTdGF0ZS5CZWZvcmVDb2xvbiAqL10sXG4gICAgICAgICAgICBbOCAvKiBTdGF0ZS5GSUwgKi8sIDY5IC8qIENoYXJDb2RlLkUgKi8sIDkgLyogU3RhdGUuQmVmb3JlQ29sb24gKi9dLFxuICAgICAgICAgICAgWzkgLyogU3RhdGUuQmVmb3JlQ29sb24gKi8sIDU4IC8qIENoYXJDb2RlLkNvbG9uICovLCAxMCAvKiBTdGF0ZS5BZnRlckNvbG9uICovXSxcbiAgICAgICAgICAgIFsxMCAvKiBTdGF0ZS5BZnRlckNvbG9uICovLCA0NyAvKiBDaGFyQ29kZS5TbGFzaCAqLywgMTEgLyogU3RhdGUuQWxtb3N0VGhlcmUgKi9dLFxuICAgICAgICAgICAgWzExIC8qIFN0YXRlLkFsbW9zdFRoZXJlICovLCA0NyAvKiBDaGFyQ29kZS5TbGFzaCAqLywgMTIgLyogU3RhdGUuRW5kICovXSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBfc3RhdGVNYWNoaW5lO1xufVxubGV0IF9jbGFzc2lmaWVyID0gbnVsbDtcbmZ1bmN0aW9uIGdldENsYXNzaWZpZXIoKSB7XG4gICAgaWYgKF9jbGFzc2lmaWVyID09PSBudWxsKSB7XG4gICAgICAgIF9jbGFzc2lmaWVyID0gbmV3IENoYXJhY3RlckNsYXNzaWZpZXIoMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovKTtcbiAgICAgICAgLy8gYWxsb3ctYW55LXVuaWNvZGUtbmV4dC1saW5lXG4gICAgICAgIGNvbnN0IEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMgPSAnIFxcdDw+XFwnXFxcIuOAgeOAgu+9oe+9pO+8jO+8ju+8mu+8m+KAmOOAiOOAjOOAjuOAlO+8iO+8u++9m++9ou+9o++9ne+8ve+8ieOAleOAj+OAjeOAieKAme+9gO+9nuKApic7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgRk9SQ0VfVEVSTUlOQVRJT05fQ0hBUkFDVEVSUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2NsYXNzaWZpZXIuc2V0KEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMuY2hhckNvZGVBdChpKSwgMSAvKiBDaGFyYWN0ZXJDbGFzcy5Gb3JjZVRlcm1pbmF0aW9uICovKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBDQU5OT1RfRU5EX1dJVEhfQ0hBUkFDVEVSUyA9ICcuLDs6JztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDQU5OT1RfRU5EX1dJVEhfQ0hBUkFDVEVSUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2NsYXNzaWZpZXIuc2V0KENBTk5PVF9FTkRfV0lUSF9DSEFSQUNURVJTLmNoYXJDb2RlQXQoaSksIDIgLyogQ2hhcmFjdGVyQ2xhc3MuQ2Fubm90RW5kSW4gKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfY2xhc3NpZmllcjtcbn1cbmV4cG9ydCBjbGFzcyBMaW5rQ29tcHV0ZXIge1xuICAgIHN0YXRpYyBfY3JlYXRlTGluayhjbGFzc2lmaWVyLCBsaW5lLCBsaW5lTnVtYmVyLCBsaW5rQmVnaW5JbmRleCwgbGlua0VuZEluZGV4KSB7XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyB0byBlbmQgbGluayBpbiBjZXJ0YWluIGNoYXJhY3RlcnMuLi5cbiAgICAgICAgbGV0IGxhc3RJbmNsdWRlZENoYXJJbmRleCA9IGxpbmtFbmRJbmRleCAtIDE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IGNoQ29kZSA9IGxpbmUuY2hhckNvZGVBdChsYXN0SW5jbHVkZWRDaGFySW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgY2hDbGFzcyA9IGNsYXNzaWZpZXIuZ2V0KGNoQ29kZSk7XG4gICAgICAgICAgICBpZiAoY2hDbGFzcyAhPT0gMiAvKiBDaGFyYWN0ZXJDbGFzcy5DYW5ub3RFbmRJbiAqLykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEluY2x1ZGVkQ2hhckluZGV4LS07XG4gICAgICAgIH0gd2hpbGUgKGxhc3RJbmNsdWRlZENoYXJJbmRleCA+IGxpbmtCZWdpbkluZGV4KTtcbiAgICAgICAgLy8gSGFuZGxlIGxpbmtzIGVuY2xvc2VkIGluIHBhcmVucywgc3F1YXJlIGJyYWNrZXRzIGFuZCBjdXJseXMuXG4gICAgICAgIGlmIChsaW5rQmVnaW5JbmRleCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlQmVmb3JlTGluayA9IGxpbmUuY2hhckNvZGVBdChsaW5rQmVnaW5JbmRleCAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbGFzdENoYXJDb2RlSW5MaW5rID0gbGluZS5jaGFyQ29kZUF0KGxhc3RJbmNsdWRlZENoYXJJbmRleCk7XG4gICAgICAgICAgICBpZiAoKGNoYXJDb2RlQmVmb3JlTGluayA9PT0gNDAgLyogQ2hhckNvZGUuT3BlblBhcmVuICovICYmIGxhc3RDaGFyQ29kZUluTGluayA9PT0gNDEgLyogQ2hhckNvZGUuQ2xvc2VQYXJlbiAqLylcbiAgICAgICAgICAgICAgICB8fCAoY2hhckNvZGVCZWZvcmVMaW5rID09PSA5MSAvKiBDaGFyQ29kZS5PcGVuU3F1YXJlQnJhY2tldCAqLyAmJiBsYXN0Q2hhckNvZGVJbkxpbmsgPT09IDkzIC8qIENoYXJDb2RlLkNsb3NlU3F1YXJlQnJhY2tldCAqLylcbiAgICAgICAgICAgICAgICB8fCAoY2hhckNvZGVCZWZvcmVMaW5rID09PSAxMjMgLyogQ2hhckNvZGUuT3BlbkN1cmx5QnJhY2UgKi8gJiYgbGFzdENoYXJDb2RlSW5MaW5rID09PSAxMjUgLyogQ2hhckNvZGUuQ2xvc2VDdXJseUJyYWNlICovKSkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBlbmQgaW4gKSBpZiAoIGlzIGJlZm9yZSB0aGUgbGluayBzdGFydFxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBlbmQgaW4gXSBpZiBbIGlzIGJlZm9yZSB0aGUgbGluayBzdGFydFxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBlbmQgaW4gfSBpZiB7IGlzIGJlZm9yZSB0aGUgbGluayBzdGFydFxuICAgICAgICAgICAgICAgIGxhc3RJbmNsdWRlZENoYXJJbmRleC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogbGlua0JlZ2luSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uOiBsYXN0SW5jbHVkZWRDaGFySW5kZXggKyAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXJsOiBsaW5lLnN1YnN0cmluZyhsaW5rQmVnaW5JbmRleCwgbGFzdEluY2x1ZGVkQ2hhckluZGV4ICsgMSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXB1dGVMaW5rcyhtb2RlbCwgc3RhdGVNYWNoaW5lID0gZ2V0U3RhdGVNYWNoaW5lKCkpIHtcbiAgICAgICAgY29uc3QgY2xhc3NpZmllciA9IGdldENsYXNzaWZpZXIoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxLCBsaW5lQ291bnQgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTsgaSA8PSBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IG1vZGVsLmdldExpbmVDb250ZW50KGkpO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICBsZXQgbGlua0JlZ2luSW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IGxpbmtCZWdpbkNoQ29kZSA9IDA7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSAxIC8qIFN0YXRlLlN0YXJ0ICovO1xuICAgICAgICAgICAgbGV0IGhhc09wZW5QYXJlbnMgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGluU3F1YXJlQnJhY2tldHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBoYXNPcGVuQ3VybHlCcmFja2V0ID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgICAgICAgIGxldCByZXNldFN0YXRlTWFjaGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoQ29kZSA9IGxpbmUuY2hhckNvZGVBdChqKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IDEzIC8qIFN0YXRlLkFjY2VwdCAqLykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDAgLyogQ2hhckNvZGUuT3BlblBhcmVuICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc09wZW5QYXJlbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIENoYXJhY3RlckNsYXNzLk5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQxIC8qIENoYXJDb2RlLkNsb3NlUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuUGFyZW5zID8gMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovIDogMSAvKiBDaGFyYWN0ZXJDbGFzcy5Gb3JjZVRlcm1pbmF0aW9uICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTEgLyogQ2hhckNvZGUuT3BlblNxdWFyZUJyYWNrZXQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5TcXVhcmVCcmFja2V0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3BlblNxdWFyZUJyYWNrZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIENoYXJhY3RlckNsYXNzLk5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkzIC8qIENoYXJDb2RlLkNsb3NlU3F1YXJlQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblNxdWFyZUJyYWNrZXRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuU3F1YXJlQnJhY2tldCA/IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLyA6IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyMyAvKiBDaGFyQ29kZS5PcGVuQ3VybHlCcmFjZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuQ3VybHlCcmFja2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjUgLyogQ2hhckNvZGUuQ2xvc2VDdXJseUJyYWNlICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAoaGFzT3BlbkN1cmx5QnJhY2tldCA/IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLyA6IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHRocmVlIHJ1bGVzIG1ha2UgaXQgdGhhdCAnIG9yIFwiIG9yIGAgYXJlIGFsbG93ZWQgaW5zaWRlIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGlmIHRoZSBsaW5rIGlzIHdyYXBwZWQgYnkgc29tZSBvdGhlciBxdW90ZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzkgLyogQ2hhckNvZGUuU2luZ2xlUXVvdGUgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM0IC8qIENoYXJDb2RlLkRvdWJsZVF1b3RlICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5NiAvKiBDaGFyQ29kZS5CYWNrVGljayAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlua0JlZ2luQ2hDb2RlID09PSBjaENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGlua0JlZ2luQ2hDb2RlID09PSAzOSAvKiBDaGFyQ29kZS5TaW5nbGVRdW90ZSAqLyB8fCBsaW5rQmVnaW5DaENvZGUgPT09IDM0IC8qIENoYXJDb2RlLkRvdWJsZVF1b3RlICovIHx8IGxpbmtCZWdpbkNoQ29kZSA9PT0gOTYgLyogQ2hhckNvZGUuQmFja1RpY2sgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAxIC8qIENoYXJhY3RlckNsYXNzLkZvcmNlVGVybWluYXRpb24gKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MiAvKiBDaGFyQ29kZS5Bc3RlcmlzayAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgKmAgdGVybWluYXRlcyBhIGxpbmsgaWYgdGhlIGxpbmsgYmVnYW4gd2l0aCBgKmBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGxpbmtCZWdpbkNoQ29kZSA9PT0gNDIgLyogQ2hhckNvZGUuQXN0ZXJpc2sgKi8pID8gMSAvKiBDaGFyYWN0ZXJDbGFzcy5Gb3JjZVRlcm1pbmF0aW9uICovIDogMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjQgLyogQ2hhckNvZGUuUGlwZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgfGAgdGVybWluYXRlcyBhIGxpbmsgaWYgdGhlIGxpbmsgYmVnYW4gd2l0aCBgfGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGxpbmtCZWdpbkNoQ29kZSA9PT0gMTI0IC8qIENoYXJDb2RlLlBpcGUgKi8pID8gMSAvKiBDaGFyYWN0ZXJDbGFzcy5Gb3JjZVRlcm1pbmF0aW9uICovIDogMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgIGAgYWxsb3cgc3BhY2UgaW4gYmV0d2VlbiBbIGFuZCBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChpblNxdWFyZUJyYWNrZXRzID8gMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovIDogMSAvKiBDaGFyYWN0ZXJDbGFzcy5Gb3JjZVRlcm1pbmF0aW9uICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IGNsYXNzaWZpZXIuZ2V0KGNoQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgY2hhcmFjdGVyIHRlcm1pbmF0ZXMgbGlua1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hDbGFzcyA9PT0gMSAvKiBDaGFyYWN0ZXJDbGFzcy5Gb3JjZVRlcm1pbmF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChMaW5rQ29tcHV0ZXIuX2NyZWF0ZUxpbmsoY2xhc3NpZmllciwgbGluZSwgaSwgbGlua0JlZ2luSW5kZXgsIGopKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U3RhdGVNYWNoaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gMTIgLyogU3RhdGUuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaENsYXNzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hDb2RlID09PSA5MSAvKiBDaGFyQ29kZS5PcGVuU3F1YXJlQnJhY2tldCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgZm9yIHRoZSBhdXRob3JpdHkgcGFydCB0byBjb250YWluIGlwdjYgYWRkcmVzc2VzIHdoaWNoIGNvbnRhaW4gWyBhbmQgXVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3BlblNxdWFyZUJyYWNrZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSBjbGFzc2lmaWVyLmdldChjaENvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGNoYXJhY3RlciB0ZXJtaW5hdGVzIGxpbmtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoQ2xhc3MgPT09IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRTdGF0ZU1hY2hpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxMyAvKiBTdGF0ZS5BY2NlcHQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVNYWNoaW5lLm5leHRTdGF0ZShzdGF0ZSwgY2hDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAwIC8qIFN0YXRlLkludmFsaWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U3RhdGVNYWNoaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzZXRTdGF0ZU1hY2hpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxIC8qIFN0YXRlLlN0YXJ0ICovO1xuICAgICAgICAgICAgICAgICAgICBoYXNPcGVuUGFyZW5zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGhhc09wZW5TcXVhcmVCcmFja2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGhhc09wZW5DdXJseUJyYWNrZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjb3JkIHdoZXJlIHRoZSBsaW5rIHN0YXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgbGlua0JlZ2luSW5kZXggPSBqICsgMTtcbiAgICAgICAgICAgICAgICAgICAgbGlua0JlZ2luQ2hDb2RlID0gY2hDb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IDEzIC8qIFN0YXRlLkFjY2VwdCAqLykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKExpbmtDb21wdXRlci5fY3JlYXRlTGluayhjbGFzc2lmaWVyLCBsaW5lLCBpLCBsaW5rQmVnaW5JbmRleCwgbGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGxpbmtzIGNvbnRhaW5zIGluIHRoZSBwcm92aWRlZFxuICogZG9jdW1lbnQuICpOb3RlKiB0aGF0IHRoaXMgb3BlcmF0aW9uIGlzIGNvbXB1dGF0aW9uYWxcbiAqIGV4cGVuc2l2ZSBhbmQgc2hvdWxkIG5vdCBydW4gaW4gdGhlIFVJIHRocmVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVMaW5rcyhtb2RlbCkge1xuICAgIGlmICghbW9kZWwgfHwgdHlwZW9mIG1vZGVsLmdldExpbmVDb3VudCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbW9kZWwuZ2V0TGluZUNvbnRlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVW5rbm93biBjYWxsZXIhXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIExpbmtDb21wdXRlci5jb21wdXRlTGlua3MobW9kZWwpO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgY2xhc3MgQmFzaWNJbnBsYWNlUmVwbGFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZVNldCA9IFtcbiAgICAgICAgICAgIFsndHJ1ZScsICdmYWxzZSddLFxuICAgICAgICAgICAgWydUcnVlJywgJ0ZhbHNlJ10sXG4gICAgICAgICAgICBbJ1ByaXZhdGUnLCAnUHVibGljJywgJ0ZyaWVuZCcsICdSZWFkT25seScsICdQYXJ0aWFsJywgJ1Byb3RlY3RlZCcsICdXcml0ZU9ubHknXSxcbiAgICAgICAgICAgIFsncHVibGljJywgJ3Byb3RlY3RlZCcsICdwcml2YXRlJ10sXG4gICAgICAgIF07XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuSU5TVEFOQ0UgPSBuZXcgQmFzaWNJbnBsYWNlUmVwbGFjZSgpOyB9XG4gICAgbmF2aWdhdGVWYWx1ZVNldChyYW5nZTEsIHRleHQxLCByYW5nZTIsIHRleHQyLCB1cCkge1xuICAgICAgICBpZiAocmFuZ2UxICYmIHRleHQxKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRvTmF2aWdhdGVWYWx1ZVNldCh0ZXh0MSwgdXApO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZTEsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZTIgJiYgdGV4dDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZG9OYXZpZ2F0ZVZhbHVlU2V0KHRleHQyLCB1cCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlMixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRvTmF2aWdhdGVWYWx1ZVNldCh0ZXh0LCB1cCkge1xuICAgICAgICBjb25zdCBudW1iZXJSZXN1bHQgPSB0aGlzLm51bWJlclJlcGxhY2UodGV4dCwgdXApO1xuICAgICAgICBpZiAobnVtYmVyUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRSZXBsYWNlKHRleHQsIHVwKTtcbiAgICB9XG4gICAgbnVtYmVyUmVwbGFjZSh2YWx1ZSwgdXApIHtcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHZhbHVlLmxlbmd0aCAtICh2YWx1ZS5sYXN0SW5kZXhPZignLicpICsgMSkpO1xuICAgICAgICBsZXQgbjEgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjb25zdCBuMiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBpZiAoIWlzTmFOKG4xKSAmJiAhaXNOYU4objIpICYmIG4xID09PSBuMikge1xuICAgICAgICAgICAgaWYgKG4xID09PSAwICYmICF1cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCBkbyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vXHRcdFx0fSBlbHNlIGlmKG4xID09PSA5ICYmIHVwKSB7XG4gICAgICAgICAgICAgICAgLy9cdFx0XHRcdHJldHVybiBudWxsOyAvLyBkb24ndCBpbnNlcnQgMTAgaW50byBhIG51bWJlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbjEgPSBNYXRoLmZsb29yKG4xICogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICBuMSArPSB1cCA/IHByZWNpc2lvbiA6IC1wcmVjaXNpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhuMSAvIHByZWNpc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRleHRSZXBsYWNlKHZhbHVlLCB1cCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVNldHNSZXBsYWNlKHRoaXMuX2RlZmF1bHRWYWx1ZVNldCwgdmFsdWUsIHVwKTtcbiAgICB9XG4gICAgdmFsdWVTZXRzUmVwbGFjZSh2YWx1ZVNldHMsIHZhbHVlLCB1cCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbHVlU2V0cy5sZW5ndGg7IHJlc3VsdCA9PT0gbnVsbCAmJiBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmFsdWVTZXRSZXBsYWNlKHZhbHVlU2V0c1tpXSwgdmFsdWUsIHVwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YWx1ZVNldFJlcGxhY2UodmFsdWVTZXQsIHZhbHVlLCB1cCkge1xuICAgICAgICBsZXQgaWR4ID0gdmFsdWVTZXQuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgaWR4ICs9IHVwID8gKzEgOiAtMTtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gdmFsdWVTZXQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkeCAlPSB2YWx1ZVNldC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVTZXRbaWR4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGVxdWFscyB9IGZyb20gJy4uLy4uL2Jhc2UvY29tbW9uL29iamVjdHMuanMnO1xuLyoqXG4gKiBWZXJ0aWNhbCBMYW5lIGluIHRoZSBvdmVydmlldyBydWxlciBvZiB0aGUgZWRpdG9yLlxuICovXG5leHBvcnQgdmFyIE92ZXJ2aWV3UnVsZXJMYW5lO1xuKGZ1bmN0aW9uIChPdmVydmlld1J1bGVyTGFuZSkge1xuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiTGVmdFwiXSA9IDFdID0gXCJMZWZ0XCI7XG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJDZW50ZXJcIl0gPSAyXSA9IFwiQ2VudGVyXCI7XG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJSaWdodFwiXSA9IDRdID0gXCJSaWdodFwiO1xuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiRnVsbFwiXSA9IDddID0gXCJGdWxsXCI7XG59KShPdmVydmlld1J1bGVyTGFuZSB8fCAoT3ZlcnZpZXdSdWxlckxhbmUgPSB7fSkpO1xuLyoqXG4gKiBWZXJ0aWNhbCBMYW5lIGluIHRoZSBnbHlwaCBtYXJnaW4gb2YgdGhlIGVkaXRvci5cbiAqL1xuZXhwb3J0IHZhciBHbHlwaE1hcmdpbkxhbmU7XG4oZnVuY3Rpb24gKEdseXBoTWFyZ2luTGFuZSkge1xuICAgIEdseXBoTWFyZ2luTGFuZVtHbHlwaE1hcmdpbkxhbmVbXCJMZWZ0XCJdID0gMV0gPSBcIkxlZnRcIjtcbiAgICBHbHlwaE1hcmdpbkxhbmVbR2x5cGhNYXJnaW5MYW5lW1wiQ2VudGVyXCJdID0gMl0gPSBcIkNlbnRlclwiO1xuICAgIEdseXBoTWFyZ2luTGFuZVtHbHlwaE1hcmdpbkxhbmVbXCJSaWdodFwiXSA9IDNdID0gXCJSaWdodFwiO1xufSkoR2x5cGhNYXJnaW5MYW5lIHx8IChHbHlwaE1hcmdpbkxhbmUgPSB7fSkpO1xuZXhwb3J0IHZhciBJbmplY3RlZFRleHRDdXJzb3JTdG9wcztcbihmdW5jdGlvbiAoSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHMpIHtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIkJvdGhcIl0gPSAwXSA9IFwiQm90aFwiO1xuICAgIEluamVjdGVkVGV4dEN1cnNvclN0b3BzW0luamVjdGVkVGV4dEN1cnNvclN0b3BzW1wiUmlnaHRcIl0gPSAxXSA9IFwiUmlnaHRcIjtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIkxlZnRcIl0gPSAyXSA9IFwiTGVmdFwiO1xuICAgIEluamVjdGVkVGV4dEN1cnNvclN0b3BzW0luamVjdGVkVGV4dEN1cnNvclN0b3BzW1wiTm9uZVwiXSA9IDNdID0gXCJOb25lXCI7XG59KShJbmplY3RlZFRleHRDdXJzb3JTdG9wcyB8fCAoSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHMgPSB7fSkpO1xuZXhwb3J0IGNsYXNzIFRleHRNb2RlbFJlc29sdmVkT3B0aW9ucyB7XG4gICAgZ2V0IG9yaWdpbmFsSW5kZW50U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGVudFNpemVJc1RhYlNpemUgPyAndGFiU2l6ZScgOiB0aGlzLmluZGVudFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNyYykge1xuICAgICAgICB0aGlzLl90ZXh0TW9kZWxSZXNvbHZlZE9wdGlvbnNCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50YWJTaXplID0gTWF0aC5tYXgoMSwgc3JjLnRhYlNpemUgfCAwKTtcbiAgICAgICAgaWYgKHNyYy5pbmRlbnRTaXplID09PSAndGFiU2l6ZScpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50U2l6ZSA9IHRoaXMudGFiU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX2luZGVudFNpemVJc1RhYlNpemUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRTaXplID0gTWF0aC5tYXgoMSwgc3JjLmluZGVudFNpemUgfCAwKTtcbiAgICAgICAgICAgIHRoaXMuX2luZGVudFNpemVJc1RhYlNpemUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluc2VydFNwYWNlcyA9IEJvb2xlYW4oc3JjLmluc2VydFNwYWNlcyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVPTCA9IHNyYy5kZWZhdWx0RU9MIHwgMDtcbiAgICAgICAgdGhpcy50cmltQXV0b1doaXRlc3BhY2UgPSBCb29sZWFuKHNyYy50cmltQXV0b1doaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLmJyYWNrZXRQYWlyQ29sb3JpemF0aW9uT3B0aW9ucyA9IHNyYy5icmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMudGFiU2l6ZSA9PT0gb3RoZXIudGFiU2l6ZVxuICAgICAgICAgICAgJiYgdGhpcy5faW5kZW50U2l6ZUlzVGFiU2l6ZSA9PT0gb3RoZXIuX2luZGVudFNpemVJc1RhYlNpemVcbiAgICAgICAgICAgICYmIHRoaXMuaW5kZW50U2l6ZSA9PT0gb3RoZXIuaW5kZW50U2l6ZVxuICAgICAgICAgICAgJiYgdGhpcy5pbnNlcnRTcGFjZXMgPT09IG90aGVyLmluc2VydFNwYWNlc1xuICAgICAgICAgICAgJiYgdGhpcy5kZWZhdWx0RU9MID09PSBvdGhlci5kZWZhdWx0RU9MXG4gICAgICAgICAgICAmJiB0aGlzLnRyaW1BdXRvV2hpdGVzcGFjZSA9PT0gb3RoZXIudHJpbUF1dG9XaGl0ZXNwYWNlXG4gICAgICAgICAgICAmJiBlcXVhbHModGhpcy5icmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnMsIG90aGVyLmJyYWNrZXRQYWlyQ29sb3JpemF0aW9uT3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjcmVhdGVDaGFuZ2VFdmVudChuZXdPcHRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWJTaXplOiB0aGlzLnRhYlNpemUgIT09IG5ld09wdHMudGFiU2l6ZSxcbiAgICAgICAgICAgIGluZGVudFNpemU6IHRoaXMuaW5kZW50U2l6ZSAhPT0gbmV3T3B0cy5pbmRlbnRTaXplLFxuICAgICAgICAgICAgaW5zZXJ0U3BhY2VzOiB0aGlzLmluc2VydFNwYWNlcyAhPT0gbmV3T3B0cy5pbnNlcnRTcGFjZXMsXG4gICAgICAgICAgICB0cmltQXV0b1doaXRlc3BhY2U6IHRoaXMudHJpbUF1dG9XaGl0ZXNwYWNlICE9PSBuZXdPcHRzLnRyaW1BdXRvV2hpdGVzcGFjZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRmluZE1hdGNoIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgbWF0Y2hlcykge1xuICAgICAgICB0aGlzLl9maW5kTWF0Y2hCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0lUZXh0U25hcHNob3Qob2JqKSB7XG4gICAgcmV0dXJuIChvYmogJiYgdHlwZW9mIG9iai5yZWFkID09PSAnZnVuY3Rpb24nKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBWYWxpZEFubm90YXRlZEVkaXRPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGlkZW50aWZpZXIsIHJhbmdlLCB0ZXh0LCBmb3JjZU1vdmVNYXJrZXJzLCBpc0F1dG9XaGl0ZXNwYWNlRWRpdCwgX2lzVHJhY2tlZCkge1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuZm9yY2VNb3ZlTWFya2VycyA9IGZvcmNlTW92ZU1hcmtlcnM7XG4gICAgICAgIHRoaXMuaXNBdXRvV2hpdGVzcGFjZUVkaXQgPSBpc0F1dG9XaGl0ZXNwYWNlRWRpdDtcbiAgICAgICAgdGhpcy5faXNUcmFja2VkID0gX2lzVHJhY2tlZDtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgU2VhcmNoRGF0YSB7XG4gICAgY29uc3RydWN0b3IocmVnZXgsIHdvcmRTZXBhcmF0b3JzLCBzaW1wbGVTZWFyY2gpIHtcbiAgICAgICAgdGhpcy5yZWdleCA9IHJlZ2V4O1xuICAgICAgICB0aGlzLndvcmRTZXBhcmF0b3JzID0gd29yZFNlcGFyYXRvcnM7XG4gICAgICAgIHRoaXMuc2ltcGxlU2VhcmNoID0gc2ltcGxlU2VhcmNoO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBBcHBseUVkaXRzUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihyZXZlcnNlRWRpdHMsIGNoYW5nZXMsIHRyaW1BdXRvV2hpdGVzcGFjZUxpbmVOdW1iZXJzKSB7XG4gICAgICAgIHRoaXMucmV2ZXJzZUVkaXRzID0gcmV2ZXJzZUVkaXRzO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLnRyaW1BdXRvV2hpdGVzcGFjZUxpbmVOdW1iZXJzID0gdHJpbUF1dG9XaGl0ZXNwYWNlTGluZU51bWJlcnM7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFN5bmNocm9uaXplTW9kZWwobW9kZWwpIHtcbiAgICByZXR1cm4gKCFtb2RlbC5pc1Rvb0xhcmdlRm9yU3luY2luZygpICYmICFtb2RlbC5pc0ZvclNpbXBsZVdpZGdldCk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IHNwbGl0TGluZXMgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBQcmVmaXhTdW1Db21wdXRlciB9IGZyb20gJy4vcHJlZml4U3VtQ29tcHV0ZXIuanMnO1xuZXhwb3J0IGNsYXNzIE1pcnJvclRleHRNb2RlbCB7XG4gICAgY29uc3RydWN0b3IodXJpLCBsaW5lcywgZW9sLCB2ZXJzaW9uSWQpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLl9lb2wgPSBlb2w7XG4gICAgICAgIHRoaXMuX3ZlcnNpb25JZCA9IHZlcnNpb25JZDtcbiAgICAgICAgdGhpcy5fbGluZVN0YXJ0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NhY2hlZFRleHRWYWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX2xpbmVzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbklkO1xuICAgIH1cbiAgICBnZXRUZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkVGV4dFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRUZXh0VmFsdWUgPSB0aGlzLl9saW5lcy5qb2luKHRoaXMuX2VvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFRleHRWYWx1ZTtcbiAgICB9XG4gICAgb25FdmVudHMoZSkge1xuICAgICAgICBpZiAoZS5lb2wgJiYgZS5lb2wgIT09IHRoaXMuX2VvbCkge1xuICAgICAgICAgICAgdGhpcy5fZW9sID0gZS5lb2w7XG4gICAgICAgICAgICB0aGlzLl9saW5lU3RhcnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgbXkgbGluZXNcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGUuY2hhbmdlcztcbiAgICAgICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5fYWNjZXB0RGVsZXRlUmFuZ2UoY2hhbmdlLnJhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuX2FjY2VwdEluc2VydFRleHQobmV3IFBvc2l0aW9uKGNoYW5nZS5yYW5nZS5zdGFydExpbmVOdW1iZXIsIGNoYW5nZS5yYW5nZS5zdGFydENvbHVtbiksIGNoYW5nZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92ZXJzaW9uSWQgPSBlLnZlcnNpb25JZDtcbiAgICAgICAgdGhpcy5fY2FjaGVkVGV4dFZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgX2Vuc3VyZUxpbmVTdGFydHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbGluZVN0YXJ0cykge1xuICAgICAgICAgICAgY29uc3QgZW9sTGVuZ3RoID0gdGhpcy5fZW9sLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzTGVuZ3RoID0gdGhpcy5fbGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbGluZVN0YXJ0VmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KGxpbmVzTGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydFZhbHVlc1tpXSA9IHRoaXMuX2xpbmVzW2ldLmxlbmd0aCArIGVvbExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdGFydHMgPSBuZXcgUHJlZml4U3VtQ29tcHV0ZXIobGluZVN0YXJ0VmFsdWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGwgY2hhbmdlcyB0byBhIGxpbmUncyB0ZXh0IGdvIHRocm91Z2ggdGhpcyBtZXRob2RcbiAgICAgKi9cbiAgICBfc2V0TGluZVRleHQobGluZUluZGV4LCBuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLl9saW5lc1tsaW5lSW5kZXhdID0gbmV3VmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9saW5lU3RhcnRzKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgcHJlZml4IHN1bVxuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cy5zZXRWYWx1ZShsaW5lSW5kZXgsIHRoaXMuX2xpbmVzW2xpbmVJbmRleF0ubGVuZ3RoICsgdGhpcy5fZW9sLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FjY2VwdERlbGV0ZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydENvbHVtbiA9PT0gcmFuZ2UuZW5kQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkZWxldGVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWxldGUgdGV4dCBvbiB0aGUgYWZmZWN0ZWQgbGluZVxuICAgICAgICAgICAgdGhpcy5fc2V0TGluZVRleHQocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMSwgdGhpcy5fbGluZXNbcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSlcbiAgICAgICAgICAgICAgICArIHRoaXMuX2xpbmVzW3JhbmdlLnN0YXJ0TGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhyYW5nZS5lbmRDb2x1bW4gLSAxKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGFrZSByZW1haW5pbmcgdGV4dCBvbiBsYXN0IGxpbmUgYW5kIGFwcGVuZCBpdCB0byByZW1haW5pbmcgdGV4dCBvbiBmaXJzdCBsaW5lXG4gICAgICAgIHRoaXMuX3NldExpbmVUZXh0KHJhbmdlLnN0YXJ0TGluZU51bWJlciAtIDEsIHRoaXMuX2xpbmVzW3JhbmdlLnN0YXJ0TGluZU51bWJlciAtIDFdLnN1YnN0cmluZygwLCByYW5nZS5zdGFydENvbHVtbiAtIDEpXG4gICAgICAgICAgICArIHRoaXMuX2xpbmVzW3JhbmdlLmVuZExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocmFuZ2UuZW5kQ29sdW1uIC0gMSkpO1xuICAgICAgICAvLyBEZWxldGUgbWlkZGxlIGxpbmVzXG4gICAgICAgIHRoaXMuX2xpbmVzLnNwbGljZShyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLmVuZExpbmVOdW1iZXIgLSByYW5nZS5zdGFydExpbmVOdW1iZXIpO1xuICAgICAgICBpZiAodGhpcy5fbGluZVN0YXJ0cykge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHByZWZpeCBzdW1cbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdGFydHMucmVtb3ZlVmFsdWVzKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2UuZW5kTGluZU51bWJlciAtIHJhbmdlLnN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FjY2VwdEluc2VydFRleHQocG9zaXRpb24sIGluc2VydFRleHQpIHtcbiAgICAgICAgaWYgKGluc2VydFRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGluc2VydFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluc2VydExpbmVzID0gc3BsaXRMaW5lcyhpbnNlcnRUZXh0KTtcbiAgICAgICAgaWYgKGluc2VydExpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0aW5nIHRleHQgb24gb25lIGxpbmVcbiAgICAgICAgICAgIHRoaXMuX3NldExpbmVUZXh0KHBvc2l0aW9uLmxpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1twb3NpdGlvbi5saW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHBvc2l0aW9uLmNvbHVtbiAtIDEpXG4gICAgICAgICAgICAgICAgKyBpbnNlcnRMaW5lc1swXVxuICAgICAgICAgICAgICAgICsgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhwb3NpdGlvbi5jb2x1bW4gLSAxKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIG92ZXJmbG93aW5nIHRleHQgZnJvbSBmaXJzdCBsaW5lIHRvIHRoZSBlbmQgb2YgdGV4dCB0byBpbnNlcnRcbiAgICAgICAgaW5zZXJ0TGluZXNbaW5zZXJ0TGluZXMubGVuZ3RoIC0gMV0gKz0gdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhwb3NpdGlvbi5jb2x1bW4gLSAxKTtcbiAgICAgICAgLy8gRGVsZXRlIG92ZXJmbG93aW5nIHRleHQgZnJvbSBmaXJzdCBsaW5lIGFuZCBpbnNlcnQgdGV4dCBvbiBmaXJzdCBsaW5lXG4gICAgICAgIHRoaXMuX3NldExpbmVUZXh0KHBvc2l0aW9uLmxpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1twb3NpdGlvbi5saW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHBvc2l0aW9uLmNvbHVtbiAtIDEpXG4gICAgICAgICAgICArIGluc2VydExpbmVzWzBdKTtcbiAgICAgICAgLy8gSW5zZXJ0IG5ldyBsaW5lcyAmIHN0b3JlIGxlbmd0aHNcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RocyA9IG5ldyBVaW50MzJBcnJheShpbnNlcnRMaW5lcy5sZW5ndGggLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnNlcnRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbGluZXMuc3BsaWNlKHBvc2l0aW9uLmxpbmVOdW1iZXIgKyBpIC0gMSwgMCwgaW5zZXJ0TGluZXNbaV0pO1xuICAgICAgICAgICAgbmV3TGVuZ3Roc1tpIC0gMV0gPSBpbnNlcnRMaW5lc1tpXS5sZW5ndGggKyB0aGlzLl9lb2wubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9saW5lU3RhcnRzKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgcHJlZml4IHN1bVxuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cy5pbnNlcnRWYWx1ZXMocG9zaXRpb24ubGluZU51bWJlciwgbmV3TGVuZ3Rocyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGFycmF5SW5zZXJ0IH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzLmpzJztcbmltcG9ydCB7IHRvVWludDMyIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vdWludC5qcyc7XG5leHBvcnQgY2xhc3MgUHJlZml4U3VtQ29tcHV0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgdGhpcy5wcmVmaXhTdW0gPSBuZXcgVWludDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleCA9IG5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPSAtMTtcbiAgICB9XG4gICAgaW5zZXJ0VmFsdWVzKGluc2VydEluZGV4LCBpbnNlcnRWYWx1ZXMpIHtcbiAgICAgICAgaW5zZXJ0SW5kZXggPSB0b1VpbnQzMihpbnNlcnRJbmRleCk7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICBjb25zdCBvbGRQcmVmaXhTdW0gPSB0aGlzLnByZWZpeFN1bTtcbiAgICAgICAgY29uc3QgaW5zZXJ0VmFsdWVzTGVuID0gaW5zZXJ0VmFsdWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGluc2VydFZhbHVlc0xlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KG9sZFZhbHVlcy5sZW5ndGggKyBpbnNlcnRWYWx1ZXNMZW4pO1xuICAgICAgICB0aGlzLnZhbHVlcy5zZXQob2xkVmFsdWVzLnN1YmFycmF5KDAsIGluc2VydEluZGV4KSwgMCk7XG4gICAgICAgIHRoaXMudmFsdWVzLnNldChvbGRWYWx1ZXMuc3ViYXJyYXkoaW5zZXJ0SW5kZXgpLCBpbnNlcnRJbmRleCArIGluc2VydFZhbHVlc0xlbik7XG4gICAgICAgIHRoaXMudmFsdWVzLnNldChpbnNlcnRWYWx1ZXMsIGluc2VydEluZGV4KTtcbiAgICAgICAgaWYgKGluc2VydEluZGV4IC0gMSA8IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID0gaW5zZXJ0SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlZml4U3VtID0gbmV3IFVpbnQzMkFycmF5KHRoaXMudmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW0uc2V0KG9sZFByZWZpeFN1bS5zdWJhcnJheSgwLCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNldFZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBpbmRleCA9IHRvVWludDMyKGluZGV4KTtcbiAgICAgICAgdmFsdWUgPSB0b1VpbnQzMih2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlc1tpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIGlmIChpbmRleCAtIDEgPCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0pIHtcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IGluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVtb3ZlVmFsdWVzKHN0YXJ0SW5kZXgsIGNvdW50KSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSB0b1VpbnQzMihzdGFydEluZGV4KTtcbiAgICAgICAgY291bnQgPSB0b1VpbnQzMihjb3VudCk7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICBjb25zdCBvbGRQcmVmaXhTdW0gPSB0aGlzLnByZWZpeFN1bTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPj0gb2xkVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heENvdW50ID0gb2xkVmFsdWVzLmxlbmd0aCAtIHN0YXJ0SW5kZXg7XG4gICAgICAgIGlmIChjb3VudCA+PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgY291bnQgPSBtYXhDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShvbGRWYWx1ZXMubGVuZ3RoIC0gY291bnQpO1xuICAgICAgICB0aGlzLnZhbHVlcy5zZXQob2xkVmFsdWVzLnN1YmFycmF5KDAsIHN0YXJ0SW5kZXgpLCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZXMuc2V0KG9sZFZhbHVlcy5zdWJhcnJheShzdGFydEluZGV4ICsgY291bnQpLCBzdGFydEluZGV4KTtcbiAgICAgICAgdGhpcy5wcmVmaXhTdW0gPSBuZXcgVWludDMyQXJyYXkodGhpcy52YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggLSAxIDwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPSBzdGFydEluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID49IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtLnNldChvbGRQcmVmaXhTdW0uc3ViYXJyYXkoMCwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXRUb3RhbFN1bSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByZWZpeFN1bSh0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIHRoZSBmaXJzdCBgaW5kZXggKyAxYCBtYW55IGl0ZW1zLlxuICAgICAqIEByZXR1cm5zIGBTVU0oMCA8PSBqIDw9IGluZGV4LCB2YWx1ZXNbal0pYC5cbiAgICAgKi9cbiAgICBnZXRQcmVmaXhTdW0oaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB0b1VpbnQzMihpbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQcmVmaXhTdW0oaW5kZXgpO1xuICAgIH1cbiAgICBfZ2V0UHJlZml4U3VtKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8PSB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZWZpeFN1bVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gKyAxO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1bMF0gPSB0aGlzLnZhbHVlc1swXTtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPD0gaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1baV0gPSB0aGlzLnByZWZpeFN1bVtpIC0gMV0gKyB0aGlzLnZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPSBNYXRoLm1heCh0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0sIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4U3VtW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0SW5kZXhPZihzdW0pIHtcbiAgICAgICAgc3VtID0gTWF0aC5mbG9vcihzdW0pO1xuICAgICAgICAvLyBDb21wdXRlIGFsbCBzdW1zICh0byBnZXQgYSBmdWxseSB2YWxpZCBwcmVmaXhTdW0pXG4gICAgICAgIHRoaXMuZ2V0VG90YWxTdW0oKTtcbiAgICAgICAgbGV0IGxvdyA9IDA7XG4gICAgICAgIGxldCBoaWdoID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IG1pZCA9IDA7XG4gICAgICAgIGxldCBtaWRTdG9wID0gMDtcbiAgICAgICAgbGV0IG1pZFN0YXJ0ID0gMDtcbiAgICAgICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICAgICAgICBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpIC8gMikgfCAwO1xuICAgICAgICAgICAgbWlkU3RvcCA9IHRoaXMucHJlZml4U3VtW21pZF07XG4gICAgICAgICAgICBtaWRTdGFydCA9IG1pZFN0b3AgLSB0aGlzLnZhbHVlc1ttaWRdO1xuICAgICAgICAgICAgaWYgKHN1bSA8IG1pZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdW0gPj0gbWlkU3RvcCkge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByZWZpeFN1bUluZGV4T2ZSZXN1bHQobWlkLCBzdW0gLSBtaWRTdGFydCk7XG4gICAgfVxufVxuLyoqXG4gKiB7QGxpbmsgZ2V0SW5kZXhPZn0gaGFzIGFuIGFtb3J0aXplZCBydW50aW1lIGNvbXBsZXhpdHkgb2YgTygxKS5cbiAqXG4gKiAoe0BsaW5rIFByZWZpeFN1bUNvbXB1dGVyLmdldEluZGV4T2Z9IGlzIGp1c3QgIE8obG9nIG4pKVxuKi9cbmV4cG9ydCBjbGFzcyBDb25zdGFudFRpbWVQcmVmaXhTdW1Db21wdXRlciB7XG4gICAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl92YWxpZEVuZEluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuX3ByZWZpeFN1bSA9IFtdO1xuICAgICAgICB0aGlzLl9pbmRleEJ5U3VtID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFNVTSgwIDw9IGogPCB2YWx1ZXMubGVuZ3RoLCB2YWx1ZXNbal0pXG4gICAgICovXG4gICAgZ2V0VG90YWxTdW0oKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZVZhbGlkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRleEJ5U3VtLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIHRoZSBmaXJzdCBgY291bnRgIG1hbnkgaXRlbXMuXG4gICAgICogQHJldHVybnMgYFNVTSgwIDw9IGogPCBjb3VudCwgdmFsdWVzW2pdKWAuXG4gICAgICovXG4gICAgZ2V0UHJlZml4U3VtKGNvdW50KSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZVZhbGlkKCk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWZpeFN1bVtjb3VudCAtIDFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBgcmVzdWx0YCwgc3VjaCB0aGF0IGBnZXRQcmVmaXhTdW0ocmVzdWx0LmluZGV4KSArIHJlc3VsdC5yZW1haW5kZXIgPSBzdW1gXG4gICAgICovXG4gICAgZ2V0SW5kZXhPZihzdW0pIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWQoKTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5faW5kZXhCeVN1bVtzdW1dO1xuICAgICAgICBjb25zdCB2aWV3TGluZXNBYm92ZSA9IGlkeCA+IDAgPyB0aGlzLl9wcmVmaXhTdW1baWR4IC0gMV0gOiAwO1xuICAgICAgICByZXR1cm4gbmV3IFByZWZpeFN1bUluZGV4T2ZSZXN1bHQoaWR4LCBzdW0gLSB2aWV3TGluZXNBYm92ZSk7XG4gICAgfVxuICAgIHJlbW92ZVZhbHVlcyhzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlKHN0YXJ0KTtcbiAgICB9XG4gICAgaW5zZXJ0VmFsdWVzKGluc2VydEluZGV4LCBpbnNlcnRBcnIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gYXJyYXlJbnNlcnQodGhpcy5fdmFsdWVzLCBpbnNlcnRJbmRleCwgaW5zZXJ0QXJyKTtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZShpbnNlcnRJbmRleCk7XG4gICAgfVxuICAgIF9pbnZhbGlkYXRlKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdmFsaWRFbmRJbmRleCA9IE1hdGgubWluKHRoaXMuX3ZhbGlkRW5kSW5kZXgsIGluZGV4IC0gMSk7XG4gICAgfVxuICAgIF9lbnN1cmVWYWxpZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fdmFsaWRFbmRJbmRleCArIDEsIGxlbiA9IHRoaXMuX3ZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl92YWx1ZXNbaV07XG4gICAgICAgICAgICBjb25zdCBzdW1BYm92ZSA9IGkgPiAwID8gdGhpcy5fcHJlZml4U3VtW2kgLSAxXSA6IDA7XG4gICAgICAgICAgICB0aGlzLl9wcmVmaXhTdW1baV0gPSBzdW1BYm92ZSArIHZhbHVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXhCeVN1bVtzdW1BYm92ZSArIGpdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0cmltIHRoaW5nc1xuICAgICAgICB0aGlzLl9wcmVmaXhTdW0ubGVuZ3RoID0gdGhpcy5fdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5faW5kZXhCeVN1bS5sZW5ndGggPSB0aGlzLl9wcmVmaXhTdW1bdGhpcy5fcHJlZml4U3VtLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBtYXJrIGFzIHZhbGlkXG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl92YWxpZEVuZEluZGV4ID0gdGhpcy5fdmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIHNldFZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fdmFsdWVzW2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIG5vIGNoYW5nZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZShpbmRleCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFByZWZpeFN1bUluZGV4T2ZSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCByZW1haW5kZXIpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnJlbWFpbmRlciA9IHJlbWFpbmRlcjtcbiAgICAgICAgdGhpcy5fcHJlZml4U3VtSW5kZXhPZlJlc3VsdEJyYW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMucmVtYWluZGVyID0gcmVtYWluZGVyO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcbmltcG9ydCB7IGdldE1hcEZvcldvcmRTZXBhcmF0b3JzIH0gZnJvbSAnLi4vY29yZS93b3JkQ2hhcmFjdGVyQ2xhc3NpZmllci5qcyc7XG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4uL2NvcmUvcG9zaXRpb24uanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi9jb3JlL3JhbmdlLmpzJztcbmltcG9ydCB7IEZpbmRNYXRjaCwgU2VhcmNoRGF0YSB9IGZyb20gJy4uL21vZGVsLmpzJztcbmNvbnN0IExJTUlUX0ZJTkRfQ09VTlQgPSA5OTk7XG5leHBvcnQgY2xhc3MgU2VhcmNoUGFyYW1zIHtcbiAgICBjb25zdHJ1Y3RvcihzZWFyY2hTdHJpbmcsIGlzUmVnZXgsIG1hdGNoQ2FzZSwgd29yZFNlcGFyYXRvcnMpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hTdHJpbmcgPSBzZWFyY2hTdHJpbmc7XG4gICAgICAgIHRoaXMuaXNSZWdleCA9IGlzUmVnZXg7XG4gICAgICAgIHRoaXMubWF0Y2hDYXNlID0gbWF0Y2hDYXNlO1xuICAgICAgICB0aGlzLndvcmRTZXBhcmF0b3JzID0gd29yZFNlcGFyYXRvcnM7XG4gICAgfVxuICAgIHBhcnNlU2VhcmNoUmVxdWVzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VhcmNoU3RyaW5nID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIGNyZWF0ZSBhIFJlZ0V4cCBvdXQgb2YgdGhlIHBhcmFtc1xuICAgICAgICBsZXQgbXVsdGlsaW5lO1xuICAgICAgICBpZiAodGhpcy5pc1JlZ2V4KSB7XG4gICAgICAgICAgICBtdWx0aWxpbmUgPSBpc011bHRpbGluZVJlZ2V4U291cmNlKHRoaXMuc2VhcmNoU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG11bHRpbGluZSA9ICh0aGlzLnNlYXJjaFN0cmluZy5pbmRleE9mKCdcXG4nKSA+PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVnZXggPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVnZXggPSBzdHJpbmdzLmNyZWF0ZVJlZ0V4cCh0aGlzLnNlYXJjaFN0cmluZywgdGhpcy5pc1JlZ2V4LCB7XG4gICAgICAgICAgICAgICAgbWF0Y2hDYXNlOiB0aGlzLm1hdGNoQ2FzZSxcbiAgICAgICAgICAgICAgICB3aG9sZVdvcmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG11bHRpbGluZTogbXVsdGlsaW5lLFxuICAgICAgICAgICAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1bmljb2RlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZ2V4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FuVXNlU2ltcGxlU2VhcmNoID0gKCF0aGlzLmlzUmVnZXggJiYgIW11bHRpbGluZSk7XG4gICAgICAgIGlmIChjYW5Vc2VTaW1wbGVTZWFyY2ggJiYgdGhpcy5zZWFyY2hTdHJpbmcudG9Mb3dlckNhc2UoKSAhPT0gdGhpcy5zZWFyY2hTdHJpbmcudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgLy8gY2FzaW5nIG1pZ2h0IG1ha2UgYSBkaWZmZXJlbmNlXG4gICAgICAgICAgICBjYW5Vc2VTaW1wbGVTZWFyY2ggPSB0aGlzLm1hdGNoQ2FzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlYXJjaERhdGEocmVnZXgsIHRoaXMud29yZFNlcGFyYXRvcnMgPyBnZXRNYXBGb3JXb3JkU2VwYXJhdG9ycyh0aGlzLndvcmRTZXBhcmF0b3JzLCBbXSkgOiBudWxsLCBjYW5Vc2VTaW1wbGVTZWFyY2ggPyB0aGlzLnNlYXJjaFN0cmluZyA6IG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc011bHRpbGluZVJlZ2V4U291cmNlKHNlYXJjaFN0cmluZykge1xuICAgIGlmICghc2VhcmNoU3RyaW5nIHx8IHNlYXJjaFN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc2VhcmNoU3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoQ29kZSA9IHNlYXJjaFN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hDb2RlID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoQ29kZSA9PT0gOTIgLyogQ2hhckNvZGUuQmFja3NsYXNoICovKSB7XG4gICAgICAgICAgICAvLyBtb3ZlIHRvIG5leHQgY2hhclxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nIGVuZHMgd2l0aCBhIFxcXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hDb2RlID0gc2VhcmNoU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAobmV4dENoQ29kZSA9PT0gMTEwIC8qIENoYXJDb2RlLm4gKi8gfHwgbmV4dENoQ29kZSA9PT0gMTE0IC8qIENoYXJDb2RlLnIgKi8gfHwgbmV4dENoQ29kZSA9PT0gODcgLyogQ2hhckNvZGUuVyAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaW5kTWF0Y2gocmFuZ2UsIHJhd01hdGNoZXMsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgaWYgKCFjYXB0dXJlTWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZpbmRNYXRjaChyYW5nZSwgbnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmF3TWF0Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXRjaGVzW2ldID0gcmF3TWF0Y2hlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGaW5kTWF0Y2gocmFuZ2UsIG1hdGNoZXMpO1xufVxuY2xhc3MgTGluZUZlZWRDb3VudGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGxpbmVGZWVkc09mZnNldHMgPSBbXTtcbiAgICAgICAgbGV0IGxpbmVGZWVkc09mZnNldHNMZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgdGV4dExlbiA9IHRleHQubGVuZ3RoOyBpIDwgdGV4dExlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIGxpbmVGZWVkc09mZnNldHNbbGluZUZlZWRzT2Zmc2V0c0xlbisrXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGluZUZlZWRzT2Zmc2V0cyA9IGxpbmVGZWVkc09mZnNldHM7XG4gICAgfVxuICAgIGZpbmRMaW5lRmVlZENvdW50QmVmb3JlT2Zmc2V0KG9mZnNldCkge1xuICAgICAgICBjb25zdCBsaW5lRmVlZHNPZmZzZXRzID0gdGhpcy5fbGluZUZlZWRzT2Zmc2V0cztcbiAgICAgICAgbGV0IG1pbiA9IDA7XG4gICAgICAgIGxldCBtYXggPSBsaW5lRmVlZHNPZmZzZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChtYXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBubyBsaW5lIGZlZWRzXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0IDw9IGxpbmVGZWVkc09mZnNldHNbMF0pIHtcbiAgICAgICAgICAgIC8vIGJlZm9yZSBmaXJzdCBsaW5lIGZlZWRcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChtaW4gPCBtYXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IG1pbiArICgobWF4IC0gbWluKSAvIDIgPj4gMCk7XG4gICAgICAgICAgICBpZiAobGluZUZlZWRzT2Zmc2V0c1ttaWRdID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIG1heCA9IG1pZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZUZlZWRzT2Zmc2V0c1ttaWQgKyAxXSA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmluZ28hXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1pZDtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbiArIDE7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRleHRNb2RlbFNlYXJjaCB7XG4gICAgc3RhdGljIGZpbmRNYXRjaGVzKG1vZGVsLCBzZWFyY2hQYXJhbXMsIHNlYXJjaFJhbmdlLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICBjb25zdCBzZWFyY2hEYXRhID0gc2VhcmNoUGFyYW1zLnBhcnNlU2VhcmNoUmVxdWVzdCgpO1xuICAgICAgICBpZiAoIXNlYXJjaERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VhcmNoRGF0YS5yZWdleC5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb0ZpbmRNYXRjaGVzTXVsdGlsaW5lKG1vZGVsLCBzZWFyY2hSYW5nZSwgbmV3IFNlYXJjaGVyKHNlYXJjaERhdGEud29yZFNlcGFyYXRvcnMsIHNlYXJjaERhdGEucmVnZXgpLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZE1hdGNoZXNMaW5lQnlMaW5lKG1vZGVsLCBzZWFyY2hSYW5nZSwgc2VhcmNoRGF0YSwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aWxpbmUgc2VhcmNoIGFsd2F5cyBleGVjdXRlcyBvbiB0aGUgbGluZXMgY29uY2F0ZW5hdGVkIHdpdGggXFxuLlxuICAgICAqIFdlIG11c3QgdGhlcmVmb3JlIGNvbXBlbnNhdGUgZm9yIHRoZSBjb3VudCBvZiBcXG4gaW4gY2FzZSB0aGUgbW9kZWwgaXMgQ1JMRlxuICAgICAqL1xuICAgIHN0YXRpYyBfZ2V0TXVsdGlsaW5lTWF0Y2hSYW5nZShtb2RlbCwgZGVsdGFPZmZzZXQsIHRleHQsIGxmQ291bnRlciwgbWF0Y2hJbmRleCwgbWF0Y2gwKSB7XG4gICAgICAgIGxldCBzdGFydE9mZnNldDtcbiAgICAgICAgbGV0IGxpbmVGZWVkQ291bnRCZWZvcmVNYXRjaCA9IDA7XG4gICAgICAgIGlmIChsZkNvdW50ZXIpIHtcbiAgICAgICAgICAgIGxpbmVGZWVkQ291bnRCZWZvcmVNYXRjaCA9IGxmQ291bnRlci5maW5kTGluZUZlZWRDb3VudEJlZm9yZU9mZnNldChtYXRjaEluZGV4KTtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gZGVsdGFPZmZzZXQgKyBtYXRjaEluZGV4ICsgbGluZUZlZWRDb3VudEJlZm9yZU1hdGNoIC8qIGFkZCBhcyBtYW55IFxcciBhcyB0aGVyZSB3ZXJlIFxcbiAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gZGVsdGFPZmZzZXQgKyBtYXRjaEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmRPZmZzZXQ7XG4gICAgICAgIGlmIChsZkNvdW50ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVGZWVkQ291bnRCZWZvcmVFbmRPZk1hdGNoID0gbGZDb3VudGVyLmZpbmRMaW5lRmVlZENvdW50QmVmb3JlT2Zmc2V0KG1hdGNoSW5kZXggKyBtYXRjaDAubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVGZWVkQ291bnRJbk1hdGNoID0gbGluZUZlZWRDb3VudEJlZm9yZUVuZE9mTWF0Y2ggLSBsaW5lRmVlZENvdW50QmVmb3JlTWF0Y2g7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIG1hdGNoMC5sZW5ndGggKyBsaW5lRmVlZENvdW50SW5NYXRjaCAvKiBhZGQgYXMgbWFueSBcXHIgYXMgdGhlcmUgd2VyZSBcXG4gKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIG1hdGNoMC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IG1vZGVsLmdldFBvc2l0aW9uQXQoc3RhcnRPZmZzZXQpO1xuICAgICAgICBjb25zdCBlbmRQb3NpdGlvbiA9IG1vZGVsLmdldFBvc2l0aW9uQXQoZW5kT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydFBvc2l0aW9uLmxpbmVOdW1iZXIsIHN0YXJ0UG9zaXRpb24uY29sdW1uLCBlbmRQb3NpdGlvbi5saW5lTnVtYmVyLCBlbmRQb3NpdGlvbi5jb2x1bW4pO1xuICAgIH1cbiAgICBzdGF0aWMgX2RvRmluZE1hdGNoZXNNdWx0aWxpbmUobW9kZWwsIHNlYXJjaFJhbmdlLCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpIHtcbiAgICAgICAgY29uc3QgZGVsdGFPZmZzZXQgPSBtb2RlbC5nZXRPZmZzZXRBdChzZWFyY2hSYW5nZS5nZXRTdGFydFBvc2l0aW9uKCkpO1xuICAgICAgICAvLyBXZSBhbHdheXMgZXhlY3V0ZSBtdWx0aWxpbmUgc2VhcmNoIG92ZXIgdGhlIGxpbmVzIGpvaW5lZCB3aXRoIFxcblxuICAgICAgICAvLyBUaGlzIG1ha2VzIGl0IHRoYXQgXFxuIHdpbGwgbWF0Y2ggdGhlIEVPTCBmb3IgYm90aCBDUkxGIGFuZCBMRiBtb2RlbHNcbiAgICAgICAgLy8gV2UgY29tcGVuc2F0ZSBmb3Igb2Zmc2V0IGVycm9ycyBpbiBgX2dldE11bHRpbGluZU1hdGNoUmFuZ2VgXG4gICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2Uoc2VhcmNoUmFuZ2UsIDEgLyogRW5kT2ZMaW5lUHJlZmVyZW5jZS5MRiAqLyk7XG4gICAgICAgIGNvbnN0IGxmQ291bnRlciA9IChtb2RlbC5nZXRFT0woKSA9PT0gJ1xcclxcbicgPyBuZXcgTGluZUZlZWRDb3VudGVyKHRleHQpIDogbnVsbCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgIGxldCBtO1xuICAgICAgICBzZWFyY2hlci5yZXNldCgwKTtcbiAgICAgICAgd2hpbGUgKChtID0gc2VhcmNoZXIubmV4dCh0ZXh0KSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtjb3VudGVyKytdID0gY3JlYXRlRmluZE1hdGNoKHRoaXMuX2dldE11bHRpbGluZU1hdGNoUmFuZ2UobW9kZWwsIGRlbHRhT2Zmc2V0LCB0ZXh0LCBsZkNvdW50ZXIsIG0uaW5kZXgsIG1bMF0pLCBtLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgICAgICBpZiAoY291bnRlciA+PSBsaW1pdFJlc3VsdENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgX2RvRmluZE1hdGNoZXNMaW5lQnlMaW5lKG1vZGVsLCBzZWFyY2hSYW5nZSwgc2VhcmNoRGF0YSwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCByZXN1bHRMZW4gPSAwO1xuICAgICAgICAvLyBFYXJseSBjYXNlIGZvciBhIHNlYXJjaCByYW5nZSB0aGF0IHN0YXJ0cyAmIHN0b3BzIG9uIHRoZSBzYW1lIGxpbmUgbnVtYmVyXG4gICAgICAgIGlmIChzZWFyY2hSYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHNlYXJjaFJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChzZWFyY2hSYW5nZS5zdGFydExpbmVOdW1iZXIpLnN1YnN0cmluZyhzZWFyY2hSYW5nZS5zdGFydENvbHVtbiAtIDEsIHNlYXJjaFJhbmdlLmVuZENvbHVtbiAtIDEpO1xuICAgICAgICAgICAgcmVzdWx0TGVuID0gdGhpcy5fZmluZE1hdGNoZXNJbkxpbmUoc2VhcmNoRGF0YSwgdGV4dCwgc2VhcmNoUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCBzZWFyY2hSYW5nZS5zdGFydENvbHVtbiAtIDEsIHJlc3VsdExlbiwgcmVzdWx0LCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbGxlY3QgcmVzdWx0cyBmcm9tIGZpcnN0IGxpbmVcbiAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldExpbmVDb250ZW50KHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlcikuc3Vic3RyaW5nKHNlYXJjaFJhbmdlLnN0YXJ0Q29sdW1uIC0gMSk7XG4gICAgICAgIHJlc3VsdExlbiA9IHRoaXMuX2ZpbmRNYXRjaGVzSW5MaW5lKHNlYXJjaERhdGEsIHRleHQsIHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlciwgc2VhcmNoUmFuZ2Uuc3RhcnRDb2x1bW4gLSAxLCByZXN1bHRMZW4sIHJlc3VsdCwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpO1xuICAgICAgICAvLyBDb2xsZWN0IHJlc3VsdHMgZnJvbSBtaWRkbGUgbGluZXNcbiAgICAgICAgZm9yIChsZXQgbGluZU51bWJlciA9IHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlciArIDE7IGxpbmVOdW1iZXIgPCBzZWFyY2hSYW5nZS5lbmRMaW5lTnVtYmVyICYmIHJlc3VsdExlbiA8IGxpbWl0UmVzdWx0Q291bnQ7IGxpbmVOdW1iZXIrKykge1xuICAgICAgICAgICAgcmVzdWx0TGVuID0gdGhpcy5fZmluZE1hdGNoZXNJbkxpbmUoc2VhcmNoRGF0YSwgbW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlciksIGxpbmVOdW1iZXIsIDAsIHJlc3VsdExlbiwgcmVzdWx0LCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29sbGVjdCByZXN1bHRzIGZyb20gbGFzdCBsaW5lXG4gICAgICAgIGlmIChyZXN1bHRMZW4gPCBsaW1pdFJlc3VsdENvdW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQoc2VhcmNoUmFuZ2UuZW5kTGluZU51bWJlcikuc3Vic3RyaW5nKDAsIHNlYXJjaFJhbmdlLmVuZENvbHVtbiAtIDEpO1xuICAgICAgICAgICAgcmVzdWx0TGVuID0gdGhpcy5fZmluZE1hdGNoZXNJbkxpbmUoc2VhcmNoRGF0YSwgdGV4dCwgc2VhcmNoUmFuZ2UuZW5kTGluZU51bWJlciwgMCwgcmVzdWx0TGVuLCByZXN1bHQsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgX2ZpbmRNYXRjaGVzSW5MaW5lKHNlYXJjaERhdGEsIHRleHQsIGxpbmVOdW1iZXIsIGRlbHRhT2Zmc2V0LCByZXN1bHRMZW4sIHJlc3VsdCwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpIHtcbiAgICAgICAgY29uc3Qgd29yZFNlcGFyYXRvcnMgPSBzZWFyY2hEYXRhLndvcmRTZXBhcmF0b3JzO1xuICAgICAgICBpZiAoIWNhcHR1cmVNYXRjaGVzICYmIHNlYXJjaERhdGEuc2ltcGxlU2VhcmNoKSB7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hTdHJpbmcgPSBzZWFyY2hEYXRhLnNpbXBsZVNlYXJjaDtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFN0cmluZ0xlbiA9IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbGFzdE1hdGNoSW5kZXggPSAtc2VhcmNoU3RyaW5nTGVuO1xuICAgICAgICAgICAgd2hpbGUgKChsYXN0TWF0Y2hJbmRleCA9IHRleHQuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGxhc3RNYXRjaEluZGV4ICsgc2VhcmNoU3RyaW5nTGVuKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3b3JkU2VwYXJhdG9ycyB8fCBpc1ZhbGlkTWF0Y2god29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIGxhc3RNYXRjaEluZGV4LCBzZWFyY2hTdHJpbmdMZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBuZXcgRmluZE1hdGNoKG5ldyBSYW5nZShsaW5lTnVtYmVyLCBsYXN0TWF0Y2hJbmRleCArIDEgKyBkZWx0YU9mZnNldCwgbGluZU51bWJlciwgbGFzdE1hdGNoSW5kZXggKyAxICsgc2VhcmNoU3RyaW5nTGVuICsgZGVsdGFPZmZzZXQpLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdExlbiA+PSBsaW1pdFJlc3VsdENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0TGVuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdExlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWFyY2hlciA9IG5ldyBTZWFyY2hlcihzZWFyY2hEYXRhLndvcmRTZXBhcmF0b3JzLCBzZWFyY2hEYXRhLnJlZ2V4KTtcbiAgICAgICAgbGV0IG07XG4gICAgICAgIC8vIFJlc2V0IHJlZ2V4IHRvIHNlYXJjaCBmcm9tIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgc2VhcmNoZXIucmVzZXQoMCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG0gPSBzZWFyY2hlci5uZXh0KHRleHQpO1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0TGVuKytdID0gY3JlYXRlRmluZE1hdGNoKG5ldyBSYW5nZShsaW5lTnVtYmVyLCBtLmluZGV4ICsgMSArIGRlbHRhT2Zmc2V0LCBsaW5lTnVtYmVyLCBtLmluZGV4ICsgMSArIG1bMF0ubGVuZ3RoICsgZGVsdGFPZmZzZXQpLCBtLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdExlbiA+PSBsaW1pdFJlc3VsdENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRMZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChtKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdExlbjtcbiAgICB9XG4gICAgc3RhdGljIGZpbmROZXh0TWF0Y2gobW9kZWwsIHNlYXJjaFBhcmFtcywgc2VhcmNoU3RhcnQsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBzZWFyY2hQYXJhbXMucGFyc2VTZWFyY2hSZXF1ZXN0KCk7XG4gICAgICAgIGlmICghc2VhcmNoRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBuZXcgU2VhcmNoZXIoc2VhcmNoRGF0YS53b3JkU2VwYXJhdG9ycywgc2VhcmNoRGF0YS5yZWdleCk7XG4gICAgICAgIGlmIChzZWFyY2hEYXRhLnJlZ2V4Lm11bHRpbGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZE5leHRNYXRjaE11bHRpbGluZShtb2RlbCwgc2VhcmNoU3RhcnQsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZE5leHRNYXRjaExpbmVCeUxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgX2RvRmluZE5leHRNYXRjaE11bHRpbGluZShtb2RlbCwgc2VhcmNoU3RhcnQsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBzZWFyY2hUZXh0U3RhcnQgPSBuZXcgUG9zaXRpb24oc2VhcmNoU3RhcnQubGluZU51bWJlciwgMSk7XG4gICAgICAgIGNvbnN0IGRlbHRhT2Zmc2V0ID0gbW9kZWwuZ2V0T2Zmc2V0QXQoc2VhcmNoVGV4dFN0YXJ0KTtcbiAgICAgICAgY29uc3QgbGluZUNvdW50ID0gbW9kZWwuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIC8vIFdlIGFsd2F5cyBleGVjdXRlIG11bHRpbGluZSBzZWFyY2ggb3ZlciB0aGUgbGluZXMgam9pbmVkIHdpdGggXFxuXG4gICAgICAgIC8vIFRoaXMgbWFrZXMgaXQgdGhhdCBcXG4gd2lsbCBtYXRjaCB0aGUgRU9MIGZvciBib3RoIENSTEYgYW5kIExGIG1vZGVsc1xuICAgICAgICAvLyBXZSBjb21wZW5zYXRlIGZvciBvZmZzZXQgZXJyb3JzIGluIGBfZ2V0TXVsdGlsaW5lTWF0Y2hSYW5nZWBcbiAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldFZhbHVlSW5SYW5nZShuZXcgUmFuZ2Uoc2VhcmNoVGV4dFN0YXJ0LmxpbmVOdW1iZXIsIHNlYXJjaFRleHRTdGFydC5jb2x1bW4sIGxpbmVDb3VudCwgbW9kZWwuZ2V0TGluZU1heENvbHVtbihsaW5lQ291bnQpKSwgMSAvKiBFbmRPZkxpbmVQcmVmZXJlbmNlLkxGICovKTtcbiAgICAgICAgY29uc3QgbGZDb3VudGVyID0gKG1vZGVsLmdldEVPTCgpID09PSAnXFxyXFxuJyA/IG5ldyBMaW5lRmVlZENvdW50ZXIodGV4dCkgOiBudWxsKTtcbiAgICAgICAgc2VhcmNoZXIucmVzZXQoc2VhcmNoU3RhcnQuY29sdW1uIC0gMSk7XG4gICAgICAgIGNvbnN0IG0gPSBzZWFyY2hlci5uZXh0KHRleHQpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZpbmRNYXRjaCh0aGlzLl9nZXRNdWx0aWxpbmVNYXRjaFJhbmdlKG1vZGVsLCBkZWx0YU9mZnNldCwgdGV4dCwgbGZDb3VudGVyLCBtLmluZGV4LCBtWzBdKSwgbSwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2hTdGFydC5saW5lTnVtYmVyICE9PSAxIHx8IHNlYXJjaFN0YXJ0LmNvbHVtbiAhPT0gMSkge1xuICAgICAgICAgICAgLy8gVHJ5IGFnYWluIGZyb20gdGhlIHRvcFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZE5leHRNYXRjaE11bHRpbGluZShtb2RlbCwgbmV3IFBvc2l0aW9uKDEsIDEpLCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgX2RvRmluZE5leHRNYXRjaExpbmVCeUxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgbGluZUNvdW50ID0gbW9kZWwuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZU51bWJlciA9IHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXI7XG4gICAgICAgIC8vIExvb2sgaW4gZmlyc3QgbGluZVxuICAgICAgICBjb25zdCB0ZXh0ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQoc3RhcnRMaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuX2ZpbmRGaXJzdE1hdGNoSW5MaW5lKHNlYXJjaGVyLCB0ZXh0LCBzdGFydExpbmVOdW1iZXIsIHNlYXJjaFN0YXJ0LmNvbHVtbiwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVJbmRleCA9IChzdGFydExpbmVOdW1iZXIgKyBpIC0gMSkgJSBsaW5lQ291bnQ7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZUluZGV4ICsgMSk7XG4gICAgICAgICAgICBjb25zdCByID0gdGhpcy5fZmluZEZpcnN0TWF0Y2hJbkxpbmUoc2VhcmNoZXIsIHRleHQsIGxpbmVJbmRleCArIDEsIDEsIGNhcHR1cmVNYXRjaGVzKTtcbiAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBfZmluZEZpcnN0TWF0Y2hJbkxpbmUoc2VhcmNoZXIsIHRleHQsIGxpbmVOdW1iZXIsIGZyb21Db2x1bW4sIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIC8vIFNldCByZWdleCB0byBzZWFyY2ggZnJvbSBjb2x1bW5cbiAgICAgICAgc2VhcmNoZXIucmVzZXQoZnJvbUNvbHVtbiAtIDEpO1xuICAgICAgICBjb25zdCBtID0gc2VhcmNoZXIubmV4dCh0ZXh0KTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaW5kTWF0Y2gobmV3IFJhbmdlKGxpbmVOdW1iZXIsIG0uaW5kZXggKyAxLCBsaW5lTnVtYmVyLCBtLmluZGV4ICsgMSArIG1bMF0ubGVuZ3RoKSwgbSwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZmluZFByZXZpb3VzTWF0Y2gobW9kZWwsIHNlYXJjaFBhcmFtcywgc2VhcmNoU3RhcnQsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBzZWFyY2hQYXJhbXMucGFyc2VTZWFyY2hSZXF1ZXN0KCk7XG4gICAgICAgIGlmICghc2VhcmNoRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBuZXcgU2VhcmNoZXIoc2VhcmNoRGF0YS53b3JkU2VwYXJhdG9ycywgc2VhcmNoRGF0YS5yZWdleCk7XG4gICAgICAgIGlmIChzZWFyY2hEYXRhLnJlZ2V4Lm11bHRpbGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZFByZXZpb3VzTWF0Y2hNdWx0aWxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kb0ZpbmRQcmV2aW91c01hdGNoTGluZUJ5TGluZShtb2RlbCwgc2VhcmNoU3RhcnQsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBfZG9GaW5kUHJldmlvdXNNYXRjaE11bHRpbGluZShtb2RlbCwgc2VhcmNoU3RhcnQsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5fZG9GaW5kTWF0Y2hlc011bHRpbGluZShtb2RlbCwgbmV3IFJhbmdlKDEsIDEsIHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXIsIHNlYXJjaFN0YXJ0LmNvbHVtbiksIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcywgMTAgKiBMSU1JVF9GSU5EX0NPVU5UKTtcbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lQ291bnQgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgaWYgKHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXIgIT09IGxpbmVDb3VudCB8fCBzZWFyY2hTdGFydC5jb2x1bW4gIT09IG1vZGVsLmdldExpbmVNYXhDb2x1bW4obGluZUNvdW50KSkge1xuICAgICAgICAgICAgLy8gVHJ5IGFnYWluIHdpdGggYWxsIGNvbnRlbnRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb0ZpbmRQcmV2aW91c01hdGNoTXVsdGlsaW5lKG1vZGVsLCBuZXcgUG9zaXRpb24obGluZUNvdW50LCBtb2RlbC5nZXRMaW5lTWF4Q29sdW1uKGxpbmVDb3VudCkpLCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgX2RvRmluZFByZXZpb3VzTWF0Y2hMaW5lQnlMaW5lKG1vZGVsLCBzZWFyY2hTdGFydCwgc2VhcmNoZXIsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IG1vZGVsLmdldExpbmVDb3VudCgpO1xuICAgICAgICBjb25zdCBzdGFydExpbmVOdW1iZXIgPSBzZWFyY2hTdGFydC5saW5lTnVtYmVyO1xuICAgICAgICAvLyBMb29rIGluIGZpcnN0IGxpbmVcbiAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldExpbmVDb250ZW50KHN0YXJ0TGluZU51bWJlcikuc3Vic3RyaW5nKDAsIHNlYXJjaFN0YXJ0LmNvbHVtbiAtIDEpO1xuICAgICAgICBjb25zdCByID0gdGhpcy5fZmluZExhc3RNYXRjaEluTGluZShzZWFyY2hlciwgdGV4dCwgc3RhcnRMaW5lTnVtYmVyLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZUluZGV4ID0gKGxpbmVDb3VudCArIHN0YXJ0TGluZU51bWJlciAtIGkgLSAxKSAlIGxpbmVDb3VudDtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChsaW5lSW5kZXggKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9maW5kTGFzdE1hdGNoSW5MaW5lKHNlYXJjaGVyLCB0ZXh0LCBsaW5lSW5kZXggKyAxLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgX2ZpbmRMYXN0TWF0Y2hJbkxpbmUoc2VhcmNoZXIsIHRleHQsIGxpbmVOdW1iZXIsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIGxldCBiZXN0UmVzdWx0ID0gbnVsbDtcbiAgICAgICAgbGV0IG07XG4gICAgICAgIHNlYXJjaGVyLnJlc2V0KDApO1xuICAgICAgICB3aGlsZSAoKG0gPSBzZWFyY2hlci5uZXh0KHRleHQpKSkge1xuICAgICAgICAgICAgYmVzdFJlc3VsdCA9IGNyZWF0ZUZpbmRNYXRjaChuZXcgUmFuZ2UobGluZU51bWJlciwgbS5pbmRleCArIDEsIGxpbmVOdW1iZXIsIG0uaW5kZXggKyAxICsgbVswXS5sZW5ndGgpLCBtLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RSZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gbGVmdElzV29yZEJvdW5kYXkod29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpIHtcbiAgICBpZiAobWF0Y2hTdGFydEluZGV4ID09PSAwKSB7XG4gICAgICAgIC8vIE1hdGNoIHN0YXJ0cyBhdCBzdGFydCBvZiBzdHJpbmdcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJCZWZvcmUgPSB0ZXh0LmNoYXJDb2RlQXQobWF0Y2hTdGFydEluZGV4IC0gMSk7XG4gICAgaWYgKHdvcmRTZXBhcmF0b3JzLmdldChjaGFyQmVmb3JlKSAhPT0gMCAvKiBXb3JkQ2hhcmFjdGVyQ2xhc3MuUmVndWxhciAqLykge1xuICAgICAgICAvLyBUaGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgbWF0Y2ggaXMgYSB3b3JkIHNlcGFyYXRvclxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNoYXJCZWZvcmUgPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovIHx8IGNoYXJCZWZvcmUgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XG4gICAgICAgIC8vIFRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBtYXRjaCBpcyBsaW5lIGJyZWFrIG9yIGNhcnJpYWdlIHJldHVybi5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChtYXRjaExlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZmlyc3RDaGFySW5NYXRjaCA9IHRleHQuY2hhckNvZGVBdChtYXRjaFN0YXJ0SW5kZXgpO1xuICAgICAgICBpZiAod29yZFNlcGFyYXRvcnMuZ2V0KGZpcnN0Q2hhckluTWF0Y2gpICE9PSAwIC8qIFdvcmRDaGFyYWN0ZXJDbGFzcy5SZWd1bGFyICovKSB7XG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QgY2hhcmFjdGVyIGluc2lkZSB0aGUgbWF0Y2ggaXMgYSB3b3JkIHNlcGFyYXRvclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmlnaHRJc1dvcmRCb3VuZGF5KHdvcmRTZXBhcmF0b3JzLCB0ZXh0LCB0ZXh0TGVuZ3RoLCBtYXRjaFN0YXJ0SW5kZXgsIG1hdGNoTGVuZ3RoKSB7XG4gICAgaWYgKG1hdGNoU3RhcnRJbmRleCArIG1hdGNoTGVuZ3RoID09PSB0ZXh0TGVuZ3RoKSB7XG4gICAgICAgIC8vIE1hdGNoIGVuZHMgYXQgZW5kIG9mIHN0cmluZ1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgY2hhckFmdGVyID0gdGV4dC5jaGFyQ29kZUF0KG1hdGNoU3RhcnRJbmRleCArIG1hdGNoTGVuZ3RoKTtcbiAgICBpZiAod29yZFNlcGFyYXRvcnMuZ2V0KGNoYXJBZnRlcikgIT09IDAgLyogV29yZENoYXJhY3RlckNsYXNzLlJlZ3VsYXIgKi8pIHtcbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBhZnRlciB0aGUgbWF0Y2ggaXMgYSB3b3JkIHNlcGFyYXRvclxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNoYXJBZnRlciA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8gfHwgY2hhckFmdGVyID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICAvLyBUaGUgY2hhcmFjdGVyIGFmdGVyIHRoZSBtYXRjaCBpcyBsaW5lIGJyZWFrIG9yIGNhcnJpYWdlIHJldHVybi5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChtYXRjaExlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbGFzdENoYXJJbk1hdGNoID0gdGV4dC5jaGFyQ29kZUF0KG1hdGNoU3RhcnRJbmRleCArIG1hdGNoTGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmICh3b3JkU2VwYXJhdG9ycy5nZXQobGFzdENoYXJJbk1hdGNoKSAhPT0gMCAvKiBXb3JkQ2hhcmFjdGVyQ2xhc3MuUmVndWxhciAqLykge1xuICAgICAgICAgICAgLy8gVGhlIGxhc3QgY2hhcmFjdGVyIGluIHRoZSBtYXRjaCBpcyBhIHdvcmQgc2VwYXJhdG9yXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZE1hdGNoKHdvcmRTZXBhcmF0b3JzLCB0ZXh0LCB0ZXh0TGVuZ3RoLCBtYXRjaFN0YXJ0SW5kZXgsIG1hdGNoTGVuZ3RoKSB7XG4gICAgcmV0dXJuIChsZWZ0SXNXb3JkQm91bmRheSh3b3JkU2VwYXJhdG9ycywgdGV4dCwgdGV4dExlbmd0aCwgbWF0Y2hTdGFydEluZGV4LCBtYXRjaExlbmd0aClcbiAgICAgICAgJiYgcmlnaHRJc1dvcmRCb3VuZGF5KHdvcmRTZXBhcmF0b3JzLCB0ZXh0LCB0ZXh0TGVuZ3RoLCBtYXRjaFN0YXJ0SW5kZXgsIG1hdGNoTGVuZ3RoKSk7XG59XG5leHBvcnQgY2xhc3MgU2VhcmNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHdvcmRTZXBhcmF0b3JzLCBzZWFyY2hSZWdleCkge1xuICAgICAgICB0aGlzLl93b3JkU2VwYXJhdG9ycyA9IHdvcmRTZXBhcmF0b3JzO1xuICAgICAgICB0aGlzLl9zZWFyY2hSZWdleCA9IHNlYXJjaFJlZ2V4O1xuICAgICAgICB0aGlzLl9wcmV2TWF0Y2hTdGFydEluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuX3ByZXZNYXRjaExlbmd0aCA9IDA7XG4gICAgfVxuICAgIHJlc2V0KGxhc3RJbmRleCkge1xuICAgICAgICB0aGlzLl9zZWFyY2hSZWdleC5sYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIHRoaXMuX3ByZXZNYXRjaFN0YXJ0SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fcHJldk1hdGNoTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgbmV4dCh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IG07XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2TWF0Y2hTdGFydEluZGV4ICsgdGhpcy5fcHJldk1hdGNoTGVuZ3RoID09PSB0ZXh0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtID0gdGhpcy5fc2VhcmNoUmVnZXguZXhlYyh0ZXh0KTtcbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF0Y2hTdGFydEluZGV4ID0gbS5pbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoTGVuZ3RoID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobWF0Y2hTdGFydEluZGV4ID09PSB0aGlzLl9wcmV2TWF0Y2hTdGFydEluZGV4ICYmIG1hdGNoTGVuZ3RoID09PSB0aGlzLl9wcmV2TWF0Y2hMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlYXJjaCByZXN1bHQgaXMgYW4gZW1wdHkgc3RyaW5nIGFuZCB3b24ndCBhZHZhbmNlIGByZWdleC5sYXN0SW5kZXhgLCBzbyBgcmVnZXguZXhlY2Agd2lsbCBzdHVjayBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGF0dGVtcHQgdG8gcmVjb3ZlciBmcm9tIHRoYXQgYnkgYWR2YW5jaW5nIGJ5IHR3byBpZiBzdXJyb2dhdGUgcGFpciBmb3VuZCBhbmQgYnkgb25lIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5ncy5nZXROZXh0Q29kZVBvaW50KHRleHQsIHRleHRMZW5ndGgsIHRoaXMuX3NlYXJjaFJlZ2V4Lmxhc3RJbmRleCkgPiAweEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlYXJjaFJlZ2V4Lmxhc3RJbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VhcmNoUmVnZXgubGFzdEluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlIHJlZ2V4IG1hdGNoZXMgdGhlIHNhbWUgcmFuZ2UgdHdpY2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZXZNYXRjaFN0YXJ0SW5kZXggPSBtYXRjaFN0YXJ0SW5kZXg7XG4gICAgICAgICAgICB0aGlzLl9wcmV2TWF0Y2hMZW5ndGggPSBtYXRjaExlbmd0aDtcbiAgICAgICAgICAgIGlmICghdGhpcy5fd29yZFNlcGFyYXRvcnMgfHwgaXNWYWxpZE1hdGNoKHRoaXMuX3dvcmRTZXBhcmF0b3JzLCB0ZXh0LCB0ZXh0TGVuZ3RoLCBtYXRjaFN0YXJ0SW5kZXgsIG1hdGNoTGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChtKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZXZlbnQuanMnO1xuaW1wb3J0IHsgS2V5Q2hvcmQgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9rZXlDb2Rlcy5qcyc7XG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuLi9jb3JlL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7XG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICcuLi9jb3JlL3NlbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gJy4uL2xhbmd1YWdlcy5qcyc7XG5pbXBvcnQgKiBhcyBzdGFuZGFsb25lRW51bXMgZnJvbSAnLi4vc3RhbmRhbG9uZS9zdGFuZGFsb25lRW51bXMuanMnO1xuZXhwb3J0IGNsYXNzIEtleU1vZCB7XG4gICAgc3RhdGljIHsgdGhpcy5DdHJsQ21kID0gMjA0OCAvKiBDb25zdEtleU1vZC5DdHJsQ21kICovOyB9XG4gICAgc3RhdGljIHsgdGhpcy5TaGlmdCA9IDEwMjQgLyogQ29uc3RLZXlNb2QuU2hpZnQgKi87IH1cbiAgICBzdGF0aWMgeyB0aGlzLkFsdCA9IDUxMiAvKiBDb25zdEtleU1vZC5BbHQgKi87IH1cbiAgICBzdGF0aWMgeyB0aGlzLldpbkN0cmwgPSAyNTYgLyogQ29uc3RLZXlNb2QuV2luQ3RybCAqLzsgfVxuICAgIHN0YXRpYyBjaG9yZChmaXJzdFBhcnQsIHNlY29uZFBhcnQpIHtcbiAgICAgICAgcmV0dXJuIEtleUNob3JkKGZpcnN0UGFydCwgc2Vjb25kUGFydCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vbmFjb0Jhc2VBUEkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZWRpdG9yOiB1bmRlZmluZWQsIC8vIHVuZGVmaW5lZCBvdmVycmlkZSBleHBlY3RlZCBoZXJlXG4gICAgICAgIGxhbmd1YWdlczogdW5kZWZpbmVkLCAvLyB1bmRlZmluZWQgb3ZlcnJpZGUgZXhwZWN0ZWQgaGVyZVxuICAgICAgICBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZTogQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UsXG4gICAgICAgIEVtaXR0ZXI6IEVtaXR0ZXIsXG4gICAgICAgIEtleUNvZGU6IHN0YW5kYWxvbmVFbnVtcy5LZXlDb2RlLFxuICAgICAgICBLZXlNb2Q6IEtleU1vZCxcbiAgICAgICAgUG9zaXRpb246IFBvc2l0aW9uLFxuICAgICAgICBSYW5nZTogUmFuZ2UsXG4gICAgICAgIFNlbGVjdGlvbjogU2VsZWN0aW9uLFxuICAgICAgICBTZWxlY3Rpb25EaXJlY3Rpb246IHN0YW5kYWxvbmVFbnVtcy5TZWxlY3Rpb25EaXJlY3Rpb24sXG4gICAgICAgIE1hcmtlclNldmVyaXR5OiBzdGFuZGFsb25lRW51bXMuTWFya2VyU2V2ZXJpdHksXG4gICAgICAgIE1hcmtlclRhZzogc3RhbmRhbG9uZUVudW1zLk1hcmtlclRhZyxcbiAgICAgICAgVXJpOiBVUkksXG4gICAgICAgIFRva2VuOiBUb2tlblxuICAgIH07XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IHN0cmluZ0RpZmYgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9kaWZmL2RpZmYuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi9jb3JlL3JhbmdlLmpzJztcbmltcG9ydCB7IGNvbXB1dGVMaW5rcyB9IGZyb20gJy4uL2xhbmd1YWdlcy9saW5rQ29tcHV0ZXIuanMnO1xuaW1wb3J0IHsgQmFzaWNJbnBsYWNlUmVwbGFjZSB9IGZyb20gJy4uL2xhbmd1YWdlcy9zdXBwb3J0cy9pbnBsYWNlUmVwbGFjZVN1cHBvcnQuanMnO1xuaW1wb3J0IHsgY3JlYXRlTW9uYWNvQmFzZUFQSSB9IGZyb20gJy4vZWRpdG9yQmFzZUFwaS5qcyc7XG5pbXBvcnQgeyBFZGl0b3JXb3JrZXJIb3N0IH0gZnJvbSAnLi9lZGl0b3JXb3JrZXJIb3N0LmpzJztcbmltcG9ydCB7IFN0b3BXYXRjaCB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3N0b3B3YXRjaC5qcyc7XG5pbXBvcnQgeyBVbmljb2RlVGV4dE1vZGVsSGlnaGxpZ2h0ZXIgfSBmcm9tICcuL3VuaWNvZGVUZXh0TW9kZWxIaWdobGlnaHRlci5qcyc7XG5pbXBvcnQgeyBsaW5lc0RpZmZDb21wdXRlcnMgfSBmcm9tICcuLi9kaWZmL2xpbmVzRGlmZkNvbXB1dGVycy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVQcm94eU9iamVjdCwgZ2V0QWxsTWV0aG9kTmFtZXMgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9vYmplY3RzLmpzJztcbmltcG9ydCB7IEZpbGVBY2Nlc3MgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9uZXR3b3JrLmpzJztcbmltcG9ydCB7IGNvbXB1dGVEZWZhdWx0RG9jdW1lbnRDb2xvcnMgfSBmcm9tICcuLi9sYW5ndWFnZXMvZGVmYXVsdERvY3VtZW50Q29sb3JzQ29tcHV0ZXIuanMnO1xuaW1wb3J0IHsgZmluZFNlY3Rpb25IZWFkZXJzIH0gZnJvbSAnLi9maW5kU2VjdGlvbkhlYWRlcnMuanMnO1xuaW1wb3J0IHsgV29ya2VyVGV4dE1vZGVsU3luY1NlcnZlciB9IGZyb20gJy4vdGV4dE1vZGVsU3luYy90ZXh0TW9kZWxTeW5jLmltcGwuanMnO1xuLy8gRVNNLWNvbW1lbnQtYmVnaW5cbi8vIGNvbnN0IGlzRVNNID0gZmFsc2U7XG4vLyBFU00tY29tbWVudC1lbmRcbi8vIEVTTS11bmNvbW1lbnQtYmVnaW5cbmNvbnN0IGlzRVNNID0gdHJ1ZTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlRWRpdG9yU2ltcGxlV29ya2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyVGV4dE1vZGVsU3luY1NlcnZlciA9IG5ldyBXb3JrZXJUZXh0TW9kZWxTeW5jU2VydmVyKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgfVxuICAgIF9nZXRNb2RlbCh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtlclRleHRNb2RlbFN5bmNTZXJ2ZXIuZ2V0TW9kZWwodXJpKTtcbiAgICB9XG4gICAgX2dldE1vZGVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtlclRleHRNb2RlbFN5bmNTZXJ2ZXIuZ2V0TW9kZWxzKCk7XG4gICAgfVxuICAgICRhY2NlcHROZXdNb2RlbChkYXRhKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlclRleHRNb2RlbFN5bmNTZXJ2ZXIuJGFjY2VwdE5ld01vZGVsKGRhdGEpO1xuICAgIH1cbiAgICAkYWNjZXB0TW9kZWxDaGFuZ2VkKHVyaSwgZSkge1xuICAgICAgICB0aGlzLl93b3JrZXJUZXh0TW9kZWxTeW5jU2VydmVyLiRhY2NlcHRNb2RlbENoYW5nZWQodXJpLCBlKTtcbiAgICB9XG4gICAgJGFjY2VwdFJlbW92ZWRNb2RlbCh1cmkpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyVGV4dE1vZGVsU3luY1NlcnZlci4kYWNjZXB0UmVtb3ZlZE1vZGVsKHVyaSk7XG4gICAgfVxuICAgIGFzeW5jICRjb21wdXRlVW5pY29kZUhpZ2hsaWdodHModXJsLCBvcHRpb25zLCByYW5nZSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKHVybCk7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlczogW10sIGhhc01vcmU6IGZhbHNlLCBhbWJpZ3VvdXNDaGFyYWN0ZXJDb3VudDogMCwgaW52aXNpYmxlQ2hhcmFjdGVyQ291bnQ6IDAsIG5vbkJhc2ljQXNjaWlDaGFyYWN0ZXJDb3VudDogMCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVbmljb2RlVGV4dE1vZGVsSGlnaGxpZ2h0ZXIuY29tcHV0ZVVuaWNvZGVIaWdobGlnaHRzKG1vZGVsLCBvcHRpb25zLCByYW5nZSk7XG4gICAgfVxuICAgIGFzeW5jICRmaW5kU2VjdGlvbkhlYWRlcnModXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwodXJsKTtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5kU2VjdGlvbkhlYWRlcnMobW9kZWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyAtLS0tIEJFR0lOIGRpZmYgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyAkY29tcHV0ZURpZmYob3JpZ2luYWxVcmwsIG1vZGlmaWVkVXJsLCBvcHRpb25zLCBhbGdvcml0aG0pIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB0aGlzLl9nZXRNb2RlbChvcmlnaW5hbFVybCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkID0gdGhpcy5fZ2V0TW9kZWwobW9kaWZpZWRVcmwpO1xuICAgICAgICBpZiAoIW9yaWdpbmFsIHx8ICFtb2RpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRWRpdG9yU2ltcGxlV29ya2VyLmNvbXB1dGVEaWZmKG9yaWdpbmFsLCBtb2RpZmllZCwgb3B0aW9ucywgYWxnb3JpdGhtKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGNvbXB1dGVEaWZmKG9yaWdpbmFsVGV4dE1vZGVsLCBtb2RpZmllZFRleHRNb2RlbCwgb3B0aW9ucywgYWxnb3JpdGhtKSB7XG4gICAgICAgIGNvbnN0IGRpZmZBbGdvcml0aG0gPSBhbGdvcml0aG0gPT09ICdhZHZhbmNlZCcgPyBsaW5lc0RpZmZDb21wdXRlcnMuZ2V0RGVmYXVsdCgpIDogbGluZXNEaWZmQ29tcHV0ZXJzLmdldExlZ2FjeSgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbExpbmVzID0gb3JpZ2luYWxUZXh0TW9kZWwuZ2V0TGluZXNDb250ZW50KCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZXMgPSBtb2RpZmllZFRleHRNb2RlbC5nZXRMaW5lc0NvbnRlbnQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGlmZkFsZ29yaXRobS5jb21wdXRlRGlmZihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgaWRlbnRpY2FsID0gKHJlc3VsdC5jaGFuZ2VzLmxlbmd0aCA+IDAgPyBmYWxzZSA6IHRoaXMuX21vZGVsc0FyZUlkZW50aWNhbChvcmlnaW5hbFRleHRNb2RlbCwgbW9kaWZpZWRUZXh0TW9kZWwpKTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZUNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZXMubWFwKG0gPT4gKFttLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciwgbS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCBtLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciwgbS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCBtLmlubmVyQ2hhbmdlcz8ubWFwKG0gPT4gW1xuICAgICAgICAgICAgICAgICAgICBtLm9yaWdpbmFsUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBtLm9yaWdpbmFsUmFuZ2Uuc3RhcnRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIG0ub3JpZ2luYWxSYW5nZS5lbmRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBtLm9yaWdpbmFsUmFuZ2UuZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBtLm1vZGlmaWVkUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBtLm1vZGlmaWVkUmFuZ2Uuc3RhcnRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIG0ubW9kaWZpZWRSYW5nZS5lbmRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBtLm1vZGlmaWVkUmFuZ2UuZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgIF0pXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZGVudGljYWwsXG4gICAgICAgICAgICBxdWl0RWFybHk6IHJlc3VsdC5oaXRUaW1lb3V0LFxuICAgICAgICAgICAgY2hhbmdlczogZ2V0TGluZUNoYW5nZXMocmVzdWx0LmNoYW5nZXMpLFxuICAgICAgICAgICAgbW92ZXM6IHJlc3VsdC5tb3Zlcy5tYXAobSA9PiAoW1xuICAgICAgICAgICAgICAgIG0ubGluZVJhbmdlTWFwcGluZy5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbS5saW5lUmFuZ2VNYXBwaW5nLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsXG4gICAgICAgICAgICAgICAgbS5saW5lUmFuZ2VNYXBwaW5nLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBtLmxpbmVSYW5nZU1hcHBpbmcubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSxcbiAgICAgICAgICAgICAgICBnZXRMaW5lQ2hhbmdlcyhtLmNoYW5nZXMpXG4gICAgICAgICAgICBdKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBfbW9kZWxzQXJlSWRlbnRpY2FsKG9yaWdpbmFsLCBtb2RpZmllZCkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbExpbmVDb3VudCA9IG9yaWdpbmFsLmdldExpbmVDb3VudCgpO1xuICAgICAgICBjb25zdCBtb2RpZmllZExpbmVDb3VudCA9IG1vZGlmaWVkLmdldExpbmVDb3VudCgpO1xuICAgICAgICBpZiAob3JpZ2luYWxMaW5lQ291bnQgIT09IG1vZGlmaWVkTGluZUNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbGluZSA9IDE7IGxpbmUgPD0gb3JpZ2luYWxMaW5lQ291bnQ7IGxpbmUrKykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxMaW5lID0gb3JpZ2luYWwuZ2V0TGluZUNvbnRlbnQobGluZSk7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZExpbmUgPSBtb2RpZmllZC5nZXRMaW5lQ29udGVudChsaW5lKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbExpbmUgIT09IG1vZGlmaWVkTGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gLS0tLSBFTkQgZGlmZiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIC0tLS0gQkVHSU4gbWluaW1hbCBlZGl0cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzdGF0aWMgeyB0aGlzLl9kaWZmTGltaXQgPSAxMDAwMDA7IH1cbiAgICBhc3luYyAkY29tcHV0ZU1vcmVNaW5pbWFsRWRpdHMobW9kZWxVcmwsIGVkaXRzLCBwcmV0dHkpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbChtb2RlbFVybCk7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlZGl0cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGxhc3RFb2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGVkaXRzID0gZWRpdHMuc2xpY2UoMCkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEucmFuZ2UgJiYgYi5yYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSYW5nZS5jb21wYXJlUmFuZ2VzVXNpbmdTdGFydHMoYS5yYW5nZSwgYi5yYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlb2wgb25seSBjaGFuZ2VzIHNob3VsZCBnbyB0byB0aGUgZW5kXG4gICAgICAgICAgICBjb25zdCBhUm5nID0gYS5yYW5nZSA/IDAgOiAxO1xuICAgICAgICAgICAgY29uc3QgYlJuZyA9IGIucmFuZ2UgPyAwIDogMTtcbiAgICAgICAgICAgIHJldHVybiBhUm5nIC0gYlJuZztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IGVkaXRzXG4gICAgICAgIGxldCB3cml0ZUluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgcmVhZEluZGV4ID0gMTsgcmVhZEluZGV4IDwgZWRpdHMubGVuZ3RoOyByZWFkSW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKFJhbmdlLmdldEVuZFBvc2l0aW9uKGVkaXRzW3dyaXRlSW5kZXhdLnJhbmdlKS5lcXVhbHMoUmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbihlZGl0c1tyZWFkSW5kZXhdLnJhbmdlKSkpIHtcbiAgICAgICAgICAgICAgICBlZGl0c1t3cml0ZUluZGV4XS5yYW5nZSA9IFJhbmdlLmZyb21Qb3NpdGlvbnMoUmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbihlZGl0c1t3cml0ZUluZGV4XS5yYW5nZSksIFJhbmdlLmdldEVuZFBvc2l0aW9uKGVkaXRzW3JlYWRJbmRleF0ucmFuZ2UpKTtcbiAgICAgICAgICAgICAgICBlZGl0c1t3cml0ZUluZGV4XS50ZXh0ICs9IGVkaXRzW3JlYWRJbmRleF0udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlSW5kZXgrKztcbiAgICAgICAgICAgICAgICBlZGl0c1t3cml0ZUluZGV4XSA9IGVkaXRzW3JlYWRJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWRpdHMubGVuZ3RoID0gd3JpdGVJbmRleCArIDE7XG4gICAgICAgIGZvciAobGV0IHsgcmFuZ2UsIHRleHQsIGVvbCB9IG9mIGVkaXRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVvbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBsYXN0RW9sID0gZW9sO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFJhbmdlLmlzRW1wdHkocmFuZ2UpICYmICF0ZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IG1vZGVsLmdldFZhbHVlSW5SYW5nZShyYW5nZSk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG58XFxufFxcci9nLCBtb2RlbC5lb2wpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsID09PSB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGRpZmYgd29uJ3QgdGFrZSB0b28gbG9uZ1xuICAgICAgICAgICAgaWYgKE1hdGgubWF4KHRleHQubGVuZ3RoLCBvcmlnaW5hbC5sZW5ndGgpID4gRWRpdG9yU2ltcGxlV29ya2VyLl9kaWZmTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHJhbmdlLCB0ZXh0IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29tcHV0ZSBkaWZmIGJldHdlZW4gb3JpZ2luYWwgYW5kIGVkaXQudGV4dFxuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHN0cmluZ0RpZmYob3JpZ2luYWwsIHRleHQsIHByZXR0eSk7XG4gICAgICAgICAgICBjb25zdCBlZGl0T2Zmc2V0ID0gbW9kZWwub2Zmc2V0QXQoUmFuZ2UubGlmdChyYW5nZSkuZ2V0U3RhcnRQb3NpdGlvbigpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IG1vZGVsLnBvc2l0aW9uQXQoZWRpdE9mZnNldCArIGNoYW5nZS5vcmlnaW5hbFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBtb2RlbC5wb3NpdGlvbkF0KGVkaXRPZmZzZXQgKyBjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RWRpdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dC5zdWJzdHIoY2hhbmdlLm1vZGlmaWVkU3RhcnQsIGNoYW5nZS5tb2RpZmllZExlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7IHN0YXJ0TGluZU51bWJlcjogc3RhcnQubGluZU51bWJlciwgc3RhcnRDb2x1bW46IHN0YXJ0LmNvbHVtbiwgZW5kTGluZU51bWJlcjogZW5kLmxpbmVOdW1iZXIsIGVuZENvbHVtbjogZW5kLmNvbHVtbiB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuZ2V0VmFsdWVJblJhbmdlKG5ld0VkaXQucmFuZ2UpICE9PSBuZXdFZGl0LnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3RWRpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGFzdEVvbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZW9sOiBsYXN0RW9sLCB0ZXh0OiAnJywgcmFuZ2U6IHsgc3RhcnRMaW5lTnVtYmVyOiAwLCBzdGFydENvbHVtbjogMCwgZW5kTGluZU51bWJlcjogMCwgZW5kQ29sdW1uOiAwIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gLS0tLSBFTkQgbWluaW1hbCBlZGl0cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyAkY29tcHV0ZUxpbmtzKG1vZGVsVXJsKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwobW9kZWxVcmwpO1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcHV0ZUxpbmtzKG1vZGVsKTtcbiAgICB9XG4gICAgLy8gLS0tIEJFR0lOIGRlZmF1bHQgZG9jdW1lbnQgY29sb3JzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgJGNvbXB1dGVEZWZhdWx0RG9jdW1lbnRDb2xvcnMobW9kZWxVcmwpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbChtb2RlbFVybCk7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wdXRlRGVmYXVsdERvY3VtZW50Q29sb3JzKG1vZGVsKTtcbiAgICB9XG4gICAgLy8gLS0tLSBCRUdJTiBzdWdnZXN0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc3RhdGljIHsgdGhpcy5fc3VnZ2VzdGlvbnNMaW1pdCA9IDEwMDAwOyB9XG4gICAgYXN5bmMgJHRleHR1YWxTdWdnZXN0KG1vZGVsVXJscywgbGVhZGluZ1dvcmQsIHdvcmREZWYsIHdvcmREZWZGbGFncykge1xuICAgICAgICBjb25zdCBzdyA9IG5ldyBTdG9wV2F0Y2goKTtcbiAgICAgICAgY29uc3Qgd29yZERlZlJlZ0V4cCA9IG5ldyBSZWdFeHAod29yZERlZiwgd29yZERlZkZsYWdzKTtcbiAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgb3V0ZXI6IGZvciAoY29uc3QgdXJsIG9mIG1vZGVsVXJscykge1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbCh1cmwpO1xuICAgICAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB3b3JkIG9mIG1vZGVsLndvcmRzKHdvcmREZWZSZWdFeHApKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmQgPT09IGxlYWRpbmdXb3JkIHx8ICFpc05hTihOdW1iZXIod29yZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWVuLmFkZCh3b3JkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5zaXplID4gRWRpdG9yU2ltcGxlV29ya2VyLl9zdWdnZXN0aW9uc0xpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB3b3JkczogQXJyYXkuZnJvbShzZWVuKSwgZHVyYXRpb246IHN3LmVsYXBzZWQoKSB9O1xuICAgIH1cbiAgICAvLyAtLS0tIEVORCBzdWdnZXN0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8jcmVnaW9uIC0tIHdvcmQgcmFuZ2VzIC0tXG4gICAgYXN5bmMgJGNvbXB1dGVXb3JkUmFuZ2VzKG1vZGVsVXJsLCByYW5nZSwgd29yZERlZiwgd29yZERlZkZsYWdzKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwobW9kZWxVcmwpO1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3b3JkRGVmUmVnRXhwID0gbmV3IFJlZ0V4cCh3b3JkRGVmLCB3b3JkRGVmRmxhZ3MpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBsaW5lID0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyOyBsaW5lIDwgcmFuZ2UuZW5kTGluZU51bWJlcjsgbGluZSsrKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IG1vZGVsLmdldExpbmVXb3JkcyhsaW5lLCB3b3JkRGVmUmVnRXhwKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29yZCBvZiB3b3Jkcykge1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oTnVtYmVyKHdvcmQud29yZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYXJyYXkgPSByZXN1bHRbd29yZC53b3JkXTtcbiAgICAgICAgICAgICAgICBpZiAoIWFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFt3b3JkLndvcmRdID0gYXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFycmF5LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiB3b3JkLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBlbmRMaW5lTnVtYmVyOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb2x1bW46IHdvcmQuZW5kQ29sdW1uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gICAgYXN5bmMgJG5hdmlnYXRlVmFsdWVTZXQobW9kZWxVcmwsIHJhbmdlLCB1cCwgd29yZERlZiwgd29yZERlZkZsYWdzKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwobW9kZWxVcmwpO1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3b3JkRGVmUmVnRXhwID0gbmV3IFJlZ0V4cCh3b3JkRGVmLCB3b3JkRGVmRmxhZ3MpO1xuICAgICAgICBpZiAocmFuZ2Uuc3RhcnRDb2x1bW4gPT09IHJhbmdlLmVuZENvbHVtbikge1xuICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiByYW5nZS5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHJhbmdlLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IHJhbmdlLmVuZExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uOiByYW5nZS5lbmRDb2x1bW4gKyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblRleHQgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2UocmFuZ2UpO1xuICAgICAgICBjb25zdCB3b3JkUmFuZ2UgPSBtb2RlbC5nZXRXb3JkQXRQb3NpdGlvbih7IGxpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlciwgY29sdW1uOiByYW5nZS5zdGFydENvbHVtbiB9LCB3b3JkRGVmUmVnRXhwKTtcbiAgICAgICAgaWYgKCF3b3JkUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmQgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2Uod29yZFJhbmdlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQmFzaWNJbnBsYWNlUmVwbGFjZS5JTlNUQU5DRS5uYXZpZ2F0ZVZhbHVlU2V0KHJhbmdlLCBzZWxlY3Rpb25UZXh0LCB3b3JkUmFuZ2UsIHdvcmQsIHVwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgRWRpdG9yU2ltcGxlV29ya2VyIGV4dGVuZHMgQmFzZUVkaXRvclNpbXBsZVdvcmtlciB7XG4gICAgY29uc3RydWN0b3IoX2hvc3QsIF9mb3JlaWduTW9kdWxlRmFjdG9yeSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9ob3N0ID0gX2hvc3Q7XG4gICAgICAgIHRoaXMuX2ZvcmVpZ25Nb2R1bGVGYWN0b3J5ID0gX2ZvcmVpZ25Nb2R1bGVGYWN0b3J5O1xuICAgICAgICB0aGlzLl9mb3JlaWduTW9kdWxlID0gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgJHBpbmcoKSB7XG4gICAgICAgIHJldHVybiAncG9uZyc7XG4gICAgfVxuICAgIC8vIC0tLS0gQkVHSU4gZm9yZWlnbiBtb2R1bGUgc3VwcG9ydCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICRsb2FkRm9yZWlnbk1vZHVsZShtb2R1bGVJZCwgY3JlYXRlRGF0YSwgZm9yZWlnbkhvc3RNZXRob2RzKSB7XG4gICAgICAgIGNvbnN0IHByb3h5TWV0aG9kUmVxdWVzdCA9IChtZXRob2QsIGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ob3N0LiRmaHIobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZm9yZWlnbkhvc3QgPSBjcmVhdGVQcm94eU9iamVjdChmb3JlaWduSG9zdE1ldGhvZHMsIHByb3h5TWV0aG9kUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGhvc3Q6IGZvcmVpZ25Ib3N0LFxuICAgICAgICAgICAgZ2V0TWlycm9yTW9kZWxzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1vZGVscygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fZm9yZWlnbk1vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmVpZ25Nb2R1bGUgPSB0aGlzLl9mb3JlaWduTW9kdWxlRmFjdG9yeShjdHgsIGNyZWF0ZURhdGEpO1xuICAgICAgICAgICAgLy8gc3RhdGljIGZvcmVpbmcgbW9kdWxlXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGdldEFsbE1ldGhvZE5hbWVzKHRoaXMuX2ZvcmVpZ25Nb2R1bGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb25Nb2R1bGVDYWxsYmFjayA9IChmb3JlaWduTW9kdWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9yZWlnbk1vZHVsZSA9IGZvcmVpZ25Nb2R1bGUuY3JlYXRlKGN0eCwgY3JlYXRlRGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShnZXRBbGxNZXRob2ROYW1lcyh0aGlzLl9mb3JlaWduTW9kdWxlKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFpc0VTTSkge1xuICAgICAgICAgICAgICAgIHJlcXVpcmUoW2Ake21vZHVsZUlkfWBdLCBvbk1vZHVsZUNhbGxiYWNrLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gRmlsZUFjY2Vzcy5hc0Jyb3dzZXJVcmkoYCR7bW9kdWxlSWR9LmpzYCkudG9TdHJpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaW1wb3J0KGAke3VybH1gKS50aGVuKG9uTW9kdWxlQ2FsbGJhY2spLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBmb3JlaWduIG1ldGhvZCByZXF1ZXN0XG4gICAgJGZtcihtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mb3JlaWduTW9kdWxlIHx8IHR5cGVvZiB0aGlzLl9mb3JlaWduTW9kdWxlW21ldGhvZF0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWVzdEhhbmRsZXIgb3IgbWV0aG9kOiAnICsgbWV0aG9kKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZm9yZWlnbk1vZHVsZVttZXRob2RdLmFwcGx5KHRoaXMuX2ZvcmVpZ25Nb2R1bGUsIGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBEZWZpbmVzIHRoZSB3b3JrZXIgZW50cnkgcG9pbnQuIE11c3QgYmUgZXhwb3J0ZWQgYW5kIG5hbWVkIGBjcmVhdGVgLlxuICogQHNraXBNYW5nbGVcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHdvcmtlclNlcnZlcikge1xuICAgIHJldHVybiBuZXcgRWRpdG9yU2ltcGxlV29ya2VyKEVkaXRvcldvcmtlckhvc3QuZ2V0Q2hhbm5lbCh3b3JrZXJTZXJ2ZXIpLCBudWxsKTtcbn1cbmlmICh0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFJ1bm5pbmcgaW4gYSB3ZWIgd29ya2VyXG4gICAgZ2xvYmFsVGhpcy5tb25hY28gPSBjcmVhdGVNb25hY29CYXNlQVBJKCk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBjbGFzcyBFZGl0b3JXb3JrZXJIb3N0IHtcbiAgICBzdGF0aWMgeyB0aGlzLkNIQU5ORUxfTkFNRSA9ICdlZGl0b3JXb3JrZXJIb3N0JzsgfVxuICAgIHN0YXRpYyBnZXRDaGFubmVsKHdvcmtlclNlcnZlcikge1xuICAgICAgICByZXR1cm4gd29ya2VyU2VydmVyLmdldENoYW5uZWwoRWRpdG9yV29ya2VySG9zdC5DSEFOTkVMX05BTUUpO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0Q2hhbm5lbCh3b3JrZXJDbGllbnQsIG9iaikge1xuICAgICAgICB3b3JrZXJDbGllbnQuc2V0Q2hhbm5lbChFZGl0b3JXb3JrZXJIb3N0LkNIQU5ORUxfTkFNRSwgb2JqKTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmNvbnN0IG1hcmtSZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFxiTUFSSzpcXFxccyooLiopJCcsICdkJyk7XG5jb25zdCB0cmltRGFzaGVzUmVnZXggPSAvXi0rfC0rJC9nO1xuLyoqXG4gKiBGaW5kIHNlY3Rpb24gaGVhZGVycyBpbiB0aGUgbW9kZWwuXG4gKlxuICogQHBhcmFtIG1vZGVsIHRoZSB0ZXh0IG1vZGVsIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyB0byBzZWFyY2ggd2l0aFxuICogQHJldHVybnMgYW4gYXJyYXkgb2Ygc2VjdGlvbiBoZWFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kU2VjdGlvbkhlYWRlcnMobW9kZWwsIG9wdGlvbnMpIHtcbiAgICBsZXQgaGVhZGVycyA9IFtdO1xuICAgIGlmIChvcHRpb25zLmZpbmRSZWdpb25TZWN0aW9uSGVhZGVycyAmJiBvcHRpb25zLmZvbGRpbmdSdWxlcz8ubWFya2Vycykge1xuICAgICAgICBjb25zdCByZWdpb25IZWFkZXJzID0gY29sbGVjdFJlZ2lvbkhlYWRlcnMobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICBoZWFkZXJzID0gaGVhZGVycy5jb25jYXQocmVnaW9uSGVhZGVycyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZpbmRNYXJrU2VjdGlvbkhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgbWFya0hlYWRlcnMgPSBjb2xsZWN0TWFya0hlYWRlcnMobW9kZWwpO1xuICAgICAgICBoZWFkZXJzID0gaGVhZGVycy5jb25jYXQobWFya0hlYWRlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGNvbGxlY3RSZWdpb25IZWFkZXJzKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVnaW9uSGVhZGVycyA9IFtdO1xuICAgIGNvbnN0IGVuZExpbmVOdW1iZXIgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTtcbiAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gMTsgbGluZU51bWJlciA8PSBlbmRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lQ29udGVudC5tYXRjaChvcHRpb25zLmZvbGRpbmdSdWxlcy5tYXJrZXJzLnN0YXJ0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgc3RhcnRMaW5lTnVtYmVyOiBsaW5lTnVtYmVyLCBzdGFydENvbHVtbjogbWF0Y2hbMF0ubGVuZ3RoICsgMSwgZW5kTGluZU51bWJlcjogbGluZU51bWJlciwgZW5kQ29sdW1uOiBsaW5lQ29udGVudC5sZW5ndGggKyAxIH07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW5kQ29sdW1uID4gcmFuZ2Uuc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uSGVhZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICByYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZ2V0SGVhZGVyVGV4dChsaW5lQ29udGVudC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKSksXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZEJlSW5Db21tZW50czogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uSGVhZGVyLnRleHQgfHwgc2VjdGlvbkhlYWRlci5oYXNTZXBhcmF0b3JMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbkhlYWRlcnMucHVzaChzZWN0aW9uSGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lvbkhlYWRlcnM7XG59XG5mdW5jdGlvbiBjb2xsZWN0TWFya0hlYWRlcnMobW9kZWwpIHtcbiAgICBjb25zdCBtYXJrSGVhZGVycyA9IFtdO1xuICAgIGNvbnN0IGVuZExpbmVOdW1iZXIgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTtcbiAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gMTsgbGluZU51bWJlciA8PSBlbmRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKTtcbiAgICAgICAgYWRkTWFya0hlYWRlcklmRm91bmQobGluZUNvbnRlbnQsIGxpbmVOdW1iZXIsIG1hcmtIZWFkZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtIZWFkZXJzO1xufVxuZnVuY3Rpb24gYWRkTWFya0hlYWRlcklmRm91bmQobGluZUNvbnRlbnQsIGxpbmVOdW1iZXIsIHNlY3Rpb25IZWFkZXJzKSB7XG4gICAgbWFya1JlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgY29uc3QgbWF0Y2ggPSBtYXJrUmVnZXguZXhlYyhsaW5lQ29udGVudCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IG1hdGNoLmluZGljZXNbMV1bMF0gKyAxO1xuICAgICAgICBjb25zdCBlbmRDb2x1bW4gPSBtYXRjaC5pbmRpY2VzWzFdWzFdICsgMTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0TGluZU51bWJlcjogbGluZU51bWJlciwgc3RhcnRDb2x1bW46IGNvbHVtbiwgZW5kTGluZU51bWJlcjogbGluZU51bWJlciwgZW5kQ29sdW1uOiBlbmRDb2x1bW4gfTtcbiAgICAgICAgaWYgKHJhbmdlLmVuZENvbHVtbiA+IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uSGVhZGVyID0ge1xuICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgIC4uLmdldEhlYWRlclRleHQobWF0Y2hbMV0pLFxuICAgICAgICAgICAgICAgIHNob3VsZEJlSW5Db21tZW50czogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uSGVhZGVyLnRleHQgfHwgc2VjdGlvbkhlYWRlci5oYXNTZXBhcmF0b3JMaW5lKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbkhlYWRlcnMucHVzaChzZWN0aW9uSGVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEhlYWRlclRleHQodGV4dCkge1xuICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICBjb25zdCBoYXNTZXBhcmF0b3JMaW5lID0gdGV4dC5zdGFydHNXaXRoKCctJyk7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSh0cmltRGFzaGVzUmVnZXgsICcnKTtcbiAgICByZXR1cm4geyB0ZXh0LCBoYXNTZXBhcmF0b3JMaW5lIH07XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEludGVydmFsVGltZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9hc3luYy5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlLCBEaXNwb3NhYmxlU3RvcmUsIGRpc3Bvc2UsIHRvRGlzcG9zYWJsZSB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2xpZmVjeWNsZS5qcyc7XG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuLi8uLi9jb3JlL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9yYW5nZS5qcyc7XG5pbXBvcnQgeyBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uLCBnZXRXb3JkQXRUZXh0IH0gZnJvbSAnLi4vLi4vY29yZS93b3JkSGVscGVyLmpzJztcbmltcG9ydCB7IE1pcnJvclRleHRNb2RlbCBhcyBCYXNlTWlycm9yTW9kZWwgfSBmcm9tICcuLi8uLi9tb2RlbC9taXJyb3JUZXh0TW9kZWwuanMnO1xuLyoqXG4gKiBTdG9wIHN5bmNpbmcgYSBtb2RlbCB0byB0aGUgd29ya2VyIGlmIGl0IHdhcyBub3QgbmVlZGVkIGZvciAxIG1pbi5cbiAqL1xuZXhwb3J0IGNvbnN0IFNUT1BfU1lOQ19NT0RFTF9ERUxUQV9USU1FX01TID0gNjAgKiAxMDAwO1xuZXhwb3J0IGNsYXNzIFdvcmtlclRleHRNb2RlbFN5bmNDbGllbnQgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm94eSwgbW9kZWxTZXJ2aWNlLCBrZWVwSWRsZU1vZGVscyA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3N5bmNlZE1vZGVscyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX3N5bmNlZE1vZGVsc0xhc3RVc2VkVGltZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX3Byb3h5ID0gcHJveHk7XG4gICAgICAgIHRoaXMuX21vZGVsU2VydmljZSA9IG1vZGVsU2VydmljZTtcbiAgICAgICAgaWYgKCFrZWVwSWRsZU1vZGVscykge1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBuZXcgSW50ZXJ2YWxUaW1lcigpO1xuICAgICAgICAgICAgdGltZXIuY2FuY2VsQW5kU2V0KCgpID0+IHRoaXMuX2NoZWNrU3RvcE1vZGVsU3luYygpLCBNYXRoLnJvdW5kKFNUT1BfU1lOQ19NT0RFTF9ERUxUQV9USU1FX01TIC8gMikpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXIodGltZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGZvciAoY29uc3QgbW9kZWxVcmwgaW4gdGhpcy5fc3luY2VkTW9kZWxzKSB7XG4gICAgICAgICAgICBkaXNwb3NlKHRoaXMuX3N5bmNlZE1vZGVsc1ttb2RlbFVybF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N5bmNlZE1vZGVscyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX3N5bmNlZE1vZGVsc0xhc3RVc2VkVGltZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZW5zdXJlU3luY2VkUmVzb3VyY2VzKHJlc291cmNlcywgZm9yY2VMYXJnZU1vZGVscyA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgcmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZVN0ciA9IHJlc291cmNlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N5bmNlZE1vZGVsc1tyZXNvdXJjZVN0cl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpbk1vZGVsU3luYyhyZXNvdXJjZSwgZm9yY2VMYXJnZU1vZGVscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fc3luY2VkTW9kZWxzW3Jlc291cmNlU3RyXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N5bmNlZE1vZGVsc0xhc3RVc2VkVGltZVtyZXNvdXJjZVN0cl0gPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jaGVja1N0b3BNb2RlbFN5bmMoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgdG9SZW1vdmUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtb2RlbFVybCBpbiB0aGlzLl9zeW5jZWRNb2RlbHNMYXN0VXNlZFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gY3VycmVudFRpbWUgLSB0aGlzLl9zeW5jZWRNb2RlbHNMYXN0VXNlZFRpbWVbbW9kZWxVcmxdO1xuICAgICAgICAgICAgaWYgKGVsYXBzZWRUaW1lID4gU1RPUF9TWU5DX01PREVMX0RFTFRBX1RJTUVfTVMpIHtcbiAgICAgICAgICAgICAgICB0b1JlbW92ZS5wdXNoKG1vZGVsVXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BNb2RlbFN5bmMoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2JlZ2luTW9kZWxTeW5jKHJlc291cmNlLCBmb3JjZUxhcmdlTW9kZWxzKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fbW9kZWxTZXJ2aWNlLmdldE1vZGVsKHJlc291cmNlKTtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm9yY2VMYXJnZU1vZGVscyAmJiBtb2RlbC5pc1Rvb0xhcmdlRm9yU3luY2luZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWxVcmwgPSByZXNvdXJjZS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLl9wcm94eS4kYWNjZXB0TmV3TW9kZWwoe1xuICAgICAgICAgICAgdXJsOiBtb2RlbC51cmkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGxpbmVzOiBtb2RlbC5nZXRMaW5lc0NvbnRlbnQoKSxcbiAgICAgICAgICAgIEVPTDogbW9kZWwuZ2V0RU9MKCksXG4gICAgICAgICAgICB2ZXJzaW9uSWQ6IG1vZGVsLmdldFZlcnNpb25JZCgpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b0Rpc3Bvc2UgPSBuZXcgRGlzcG9zYWJsZVN0b3JlKCk7XG4gICAgICAgIHRvRGlzcG9zZS5hZGQobW9kZWwub25EaWRDaGFuZ2VDb250ZW50KChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm94eS4kYWNjZXB0TW9kZWxDaGFuZ2VkKG1vZGVsVXJsLnRvU3RyaW5nKCksIGUpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRvRGlzcG9zZS5hZGQobW9kZWwub25XaWxsRGlzcG9zZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wTW9kZWxTeW5jKG1vZGVsVXJsKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0b0Rpc3Bvc2UuYWRkKHRvRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm94eS4kYWNjZXB0UmVtb3ZlZE1vZGVsKG1vZGVsVXJsKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLl9zeW5jZWRNb2RlbHNbbW9kZWxVcmxdID0gdG9EaXNwb3NlO1xuICAgIH1cbiAgICBfc3RvcE1vZGVsU3luYyhtb2RlbFVybCkge1xuICAgICAgICBjb25zdCB0b0Rpc3Bvc2UgPSB0aGlzLl9zeW5jZWRNb2RlbHNbbW9kZWxVcmxdO1xuICAgICAgICBkZWxldGUgdGhpcy5fc3luY2VkTW9kZWxzW21vZGVsVXJsXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N5bmNlZE1vZGVsc0xhc3RVc2VkVGltZVttb2RlbFVybF07XG4gICAgICAgIGRpc3Bvc2UodG9EaXNwb3NlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV29ya2VyVGV4dE1vZGVsU3luY1NlcnZlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX21vZGVscyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIGdldE1vZGVsKHVyaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWxzW3VyaV07XG4gICAgfVxuICAgIGdldE1vZGVscygpIHtcbiAgICAgICAgY29uc3QgYWxsID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX21vZGVscykuZm9yRWFjaCgoa2V5KSA9PiBhbGwucHVzaCh0aGlzLl9tb2RlbHNba2V5XSkpO1xuICAgICAgICByZXR1cm4gYWxsO1xuICAgIH1cbiAgICAkYWNjZXB0TmV3TW9kZWwoZGF0YSkge1xuICAgICAgICB0aGlzLl9tb2RlbHNbZGF0YS51cmxdID0gbmV3IE1pcnJvck1vZGVsKFVSSS5wYXJzZShkYXRhLnVybCksIGRhdGEubGluZXMsIGRhdGEuRU9MLCBkYXRhLnZlcnNpb25JZCk7XG4gICAgfVxuICAgICRhY2NlcHRNb2RlbENoYW5nZWQodXJpLCBlKSB7XG4gICAgICAgIGlmICghdGhpcy5fbW9kZWxzW3VyaV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX21vZGVsc1t1cmldO1xuICAgICAgICBtb2RlbC5vbkV2ZW50cyhlKTtcbiAgICB9XG4gICAgJGFjY2VwdFJlbW92ZWRNb2RlbCh1cmkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tb2RlbHNbdXJpXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tb2RlbHNbdXJpXTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTWlycm9yTW9kZWwgZXh0ZW5kcyBCYXNlTWlycm9yTW9kZWwge1xuICAgIGdldCB1cmkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmk7XG4gICAgfVxuICAgIGdldCBlb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lb2w7XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCk7XG4gICAgfVxuICAgIGZpbmRNYXRjaGVzKHJlZ2V4KSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9saW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IHRoaXMuX2xpbmVzW2ldO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0VG9BZGQgPSB0aGlzLm9mZnNldEF0KG5ldyBQb3NpdGlvbihpICsgMSwgMSkpO1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0b3JPdmVyTWF0Y2hlcyA9IGxpbmUubWF0Y2hBbGwocmVnZXgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBpdGVyYXRvck92ZXJNYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4IHx8IG1hdGNoLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoLmluZGV4ID0gbWF0Y2guaW5kZXggKyBvZmZzZXRUb0FkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9XG4gICAgZ2V0TGluZXNDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXMuc2xpY2UoMCk7XG4gICAgfVxuICAgIGdldExpbmVDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdO1xuICAgIH1cbiAgICBnZXRXb3JkQXRQb3NpdGlvbihwb3NpdGlvbiwgd29yZERlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3Qgd29yZEF0VGV4dCA9IGdldFdvcmRBdFRleHQocG9zaXRpb24uY29sdW1uLCBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uKHdvcmREZWZpbml0aW9uKSwgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLCAwKTtcbiAgICAgICAgaWYgKHdvcmRBdFRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UocG9zaXRpb24ubGluZU51bWJlciwgd29yZEF0VGV4dC5zdGFydENvbHVtbiwgcG9zaXRpb24ubGluZU51bWJlciwgd29yZEF0VGV4dC5lbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3b3Jkcyh3b3JkRGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMuX2xpbmVzO1xuICAgICAgICBjb25zdCB3b3JkZW5pemUgPSB0aGlzLl93b3JkZW5pemUuYmluZCh0aGlzKTtcbiAgICAgICAgbGV0IGxpbmVOdW1iZXIgPSAwO1xuICAgICAgICBsZXQgbGluZVRleHQgPSAnJztcbiAgICAgICAgbGV0IHdvcmRSYW5nZXNJZHggPSAwO1xuICAgICAgICBsZXQgd29yZFJhbmdlcyA9IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3b3JkUmFuZ2VzSWR4IDwgd29yZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbGluZVRleHQuc3Vic3RyaW5nKHdvcmRSYW5nZXNbd29yZFJhbmdlc0lkeF0uc3RhcnQsIHdvcmRSYW5nZXNbd29yZFJhbmdlc0lkeF0uZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRSYW5nZXNJZHggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXIgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVGV4dCA9IGxpbmVzW2xpbmVOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRSYW5nZXMgPSB3b3JkZW5pemUobGluZVRleHQsIHdvcmREZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkUmFuZ2VzSWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0TGluZVdvcmRzKGxpbmVOdW1iZXIsIHdvcmREZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9saW5lc1tsaW5lTnVtYmVyIC0gMV07XG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IHRoaXMuX3dvcmRlbml6ZShjb250ZW50LCB3b3JkRGVmaW5pdGlvbik7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgcmFuZ2VzKSB7XG4gICAgICAgICAgICB3b3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB3b3JkOiBjb250ZW50LnN1YnN0cmluZyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKSxcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogcmFuZ2Uuc3RhcnQgKyAxLFxuICAgICAgICAgICAgICAgIGVuZENvbHVtbjogcmFuZ2UuZW5kICsgMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRzO1xuICAgIH1cbiAgICBfd29yZGVuaXplKGNvbnRlbnQsIHdvcmREZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA9IDA7IC8vIHJlc2V0IGxhc3RJbmRleCBqdXN0IHRvIGJlIHN1cmVcbiAgICAgICAgd2hpbGUgKG1hdGNoID0gd29yZERlZmluaXRpb24uZXhlYyhjb250ZW50KSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGl0IGRpZCBtYXRjaCB0aGUgZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHN0YXJ0OiBtYXRjaC5pbmRleCwgZW5kOiBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRWYWx1ZUluUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSB0aGlzLl92YWxpZGF0ZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzW3JhbmdlLnN0YXJ0TGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhyYW5nZS5zdGFydENvbHVtbiAtIDEsIHJhbmdlLmVuZENvbHVtbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVFbmRpbmcgPSB0aGlzLl9lb2w7XG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZUluZGV4ID0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMTtcbiAgICAgICAgY29uc3QgZW5kTGluZUluZGV4ID0gcmFuZ2UuZW5kTGluZU51bWJlciAtIDE7XG4gICAgICAgIGNvbnN0IHJlc3VsdExpbmVzID0gW107XG4gICAgICAgIHJlc3VsdExpbmVzLnB1c2godGhpcy5fbGluZXNbc3RhcnRMaW5lSW5kZXhdLnN1YnN0cmluZyhyYW5nZS5zdGFydENvbHVtbiAtIDEpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZUluZGV4ICsgMTsgaSA8IGVuZExpbmVJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHRoaXMuX2xpbmVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHRoaXMuX2xpbmVzW2VuZExpbmVJbmRleF0uc3Vic3RyaW5nKDAsIHJhbmdlLmVuZENvbHVtbiAtIDEpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdExpbmVzLmpvaW4obGluZUVuZGluZyk7XG4gICAgfVxuICAgIG9mZnNldEF0KHBvc2l0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUxpbmVTdGFydHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVTdGFydHMuZ2V0UHJlZml4U3VtKHBvc2l0aW9uLmxpbmVOdW1iZXIgLSAyKSArIChwb3NpdGlvbi5jb2x1bW4gLSAxKTtcbiAgICB9XG4gICAgcG9zaXRpb25BdChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5mbG9vcihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heCgwLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9lbnN1cmVMaW5lU3RhcnRzKCk7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMuX2xpbmVTdGFydHMuZ2V0SW5kZXhPZihvZmZzZXQpO1xuICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gdGhpcy5fbGluZXNbb3V0LmluZGV4XS5sZW5ndGg7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSByZXR1cm4gYSB2YWxpZCBwb3NpdGlvblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZU51bWJlcjogMSArIG91dC5pbmRleCxcbiAgICAgICAgICAgIGNvbHVtbjogMSArIE1hdGgubWluKG91dC5yZW1haW5kZXIsIGxpbmVMZW5ndGgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIF92YWxpZGF0ZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbih7IGxpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlciwgY29sdW1uOiByYW5nZS5zdGFydENvbHVtbiB9KTtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbih7IGxpbmVOdW1iZXI6IHJhbmdlLmVuZExpbmVOdW1iZXIsIGNvbHVtbjogcmFuZ2UuZW5kQ29sdW1uIH0pO1xuICAgICAgICBpZiAoc3RhcnQubGluZU51bWJlciAhPT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyXG4gICAgICAgICAgICB8fCBzdGFydC5jb2x1bW4gIT09IHJhbmdlLnN0YXJ0Q29sdW1uXG4gICAgICAgICAgICB8fCBlbmQubGluZU51bWJlciAhPT0gcmFuZ2UuZW5kTGluZU51bWJlclxuICAgICAgICAgICAgfHwgZW5kLmNvbHVtbiAhPT0gcmFuZ2UuZW5kQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnQubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogc3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IGVuZC5saW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGVuZENvbHVtbjogZW5kLmNvbHVtblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIF92YWxpZGF0ZVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICghUG9zaXRpb24uaXNJUG9zaXRpb24ocG9zaXRpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb3NpdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGxpbmVOdW1iZXIsIGNvbHVtbiB9ID0gcG9zaXRpb247XG4gICAgICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChsaW5lTnVtYmVyIDwgMSkge1xuICAgICAgICAgICAgbGluZU51bWJlciA9IDE7XG4gICAgICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZU51bWJlciA+IHRoaXMuX2xpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZU51bWJlciA9IHRoaXMuX2xpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuX2xpbmVzW2xpbmVOdW1iZXIgLSAxXS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXhDaGFyYWN0ZXIgPSB0aGlzLl9saW5lc1tsaW5lTnVtYmVyIC0gMV0ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGlmIChjb2x1bW4gPCAxKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbHVtbiA+IG1heENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IG1heENoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmVOdW1iZXIsIGNvbHVtbiB9O1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgU2VhcmNoZXIgfSBmcm9tICcuLi9tb2RlbC90ZXh0TW9kZWxTZWFyY2guanMnO1xuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcbmltcG9ydCB7IGFzc2VydE5ldmVyIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vYXNzZXJ0LmpzJztcbmltcG9ydCB7IERFRkFVTFRfV09SRF9SRUdFWFAsIGdldFdvcmRBdFRleHQgfSBmcm9tICcuLi9jb3JlL3dvcmRIZWxwZXIuanMnO1xuZXhwb3J0IGNsYXNzIFVuaWNvZGVUZXh0TW9kZWxIaWdobGlnaHRlciB7XG4gICAgc3RhdGljIGNvbXB1dGVVbmljb2RlSGlnaGxpZ2h0cyhtb2RlbCwgb3B0aW9ucywgcmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gcmFuZ2UgPyByYW5nZS5zdGFydExpbmVOdW1iZXIgOiAxO1xuICAgICAgICBjb25zdCBlbmRMaW5lID0gcmFuZ2UgPyByYW5nZS5lbmRMaW5lTnVtYmVyIDogbW9kZWwuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludEhpZ2hsaWdodGVyID0gbmV3IENvZGVQb2ludEhpZ2hsaWdodGVyKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gY29kZVBvaW50SGlnaGxpZ2h0ZXIuZ2V0Q2FuZGlkYXRlQ29kZVBvaW50cygpO1xuICAgICAgICBsZXQgcmVnZXg7XG4gICAgICAgIGlmIChjYW5kaWRhdGVzID09PSAnYWxsTm9uQmFzaWNBc2NpaScpIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW15cXFxcdFxcXFxuXFxcXHJcXFxceDIwLVxcXFx4N0VdJywgJ2cnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgJHtidWlsZFJlZ0V4cENoYXJDbGFzc0V4cHIoQXJyYXkuZnJvbShjYW5kaWRhdGVzKSl9YCwgJ2cnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWFyY2hlciA9IG5ldyBTZWFyY2hlcihudWxsLCByZWdleCk7XG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xuICAgICAgICBsZXQgaGFzTW9yZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgbGV0IGFtYmlndW91c0NoYXJhY3RlckNvdW50ID0gMDtcbiAgICAgICAgbGV0IGludmlzaWJsZUNoYXJhY3RlckNvdW50ID0gMDtcbiAgICAgICAgbGV0IG5vbkJhc2ljQXNjaWlDaGFyYWN0ZXJDb3VudCA9IDA7XG4gICAgICAgIGZvckxvb3A6IGZvciAobGV0IGxpbmVOdW1iZXIgPSBzdGFydExpbmUsIGxpbmVDb3VudCA9IGVuZExpbmU7IGxpbmVOdW1iZXIgPD0gbGluZUNvdW50OyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcik7XG4gICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZUNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgLy8gUmVzZXQgcmVnZXggdG8gc2VhcmNoIGZyb20gdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgc2VhcmNoZXIucmVzZXQoMCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbSA9IHNlYXJjaGVyLm5leHQobGluZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gbS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmQgcmFuZ2UgdG8gZW50aXJlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyQ29kZUJlZm9yZSA9IGxpbmVDb250ZW50LmNoYXJDb2RlQXQoc3RhcnRJbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlQmVmb3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggKyAxIDwgbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhckNvZGVCZWZvcmUgPSBsaW5lQ29udGVudC5jaGFyQ29kZUF0KGVuZEluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5ncy5pc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGVCZWZvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHIgPSBsaW5lQ29udGVudC5zdWJzdHJpbmcoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgd29yZCA9IGdldFdvcmRBdFRleHQoc3RhcnRJbmRleCArIDEsIERFRkFVTFRfV09SRF9SRUdFWFAsIGxpbmVDb250ZW50LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmQgJiYgd29yZC5lbmRDb2x1bW4gPD0gc3RhcnRJbmRleCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JkIGRvZXMgbm90IGluY2x1ZGUgdGhlIHByb2JsZW1hdGljIGNoYXJhY3RlciwgaWdub3JlIHRoZSB3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoaWdobGlnaHRSZWFzb24gPSBjb2RlUG9pbnRIaWdobGlnaHRlci5zaG91bGRIaWdobGlnaHROb25CYXNpY0FTQ0lJKHN0ciwgd29yZCA/IHdvcmQud29yZCA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0UmVhc29uICE9PSAwIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0UmVhc29uID09PSAzIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5BbWJpZ3VvdXMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXNDaGFyYWN0ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGlnaGxpZ2h0UmVhc29uID09PSAyIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5JbnZpc2libGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZpc2libGVDaGFyYWN0ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGlnaGxpZ2h0UmVhc29uID09PSAxIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25CYXNpY0FTQ0lJICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uQmFzaWNBc2NpaUNoYXJhY3RlckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnROZXZlcihoaWdobGlnaHRSZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgTUFYX1JFU1VMVF9MRU5HVEggPSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gTUFYX1JFU1VMVF9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNNb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBmb3JMb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGxpbmVOdW1iZXIsIHN0YXJ0SW5kZXggKyAxLCBsaW5lTnVtYmVyLCBlbmRJbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZXMsXG4gICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgYW1iaWd1b3VzQ2hhcmFjdGVyQ291bnQsXG4gICAgICAgICAgICBpbnZpc2libGVDaGFyYWN0ZXJDb3VudCxcbiAgICAgICAgICAgIG5vbkJhc2ljQXNjaWlDaGFyYWN0ZXJDb3VudFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgY29tcHV0ZVVuaWNvZGVIaWdobGlnaHRSZWFzb24oY2hhciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb2RlUG9pbnRIaWdobGlnaHRlciA9IG5ldyBDb2RlUG9pbnRIaWdobGlnaHRlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVhc29uID0gY29kZVBvaW50SGlnaGxpZ2h0ZXIuc2hvdWxkSGlnaGxpZ2h0Tm9uQmFzaWNBU0NJSShjaGFyLCBudWxsKTtcbiAgICAgICAgc3dpdGNoIChyZWFzb24pIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uTm9uZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uSW52aXNpYmxlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6IDEgLyogVW5pY29kZUhpZ2hsaWdodGVyUmVhc29uS2luZC5JbnZpc2libGUgKi8gfTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uQW1iaWd1b3VzICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZVBvaW50ID0gY2hhci5jb2RlUG9pbnRBdCgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmltYXJ5Q29uZnVzYWJsZSA9IGNvZGVQb2ludEhpZ2hsaWdodGVyLmFtYmlndW91c0NoYXJhY3RlcnMuZ2V0UHJpbWFyeUNvbmZ1c2FibGUoY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RBbWJpZ3VvdXNJbkxvY2FsZXMgPSBzdHJpbmdzLkFtYmlndW91c0NoYXJhY3RlcnMuZ2V0TG9jYWxlcygpLmZpbHRlcigobCkgPT4gIXN0cmluZ3MuQW1iaWd1b3VzQ2hhcmFjdGVycy5nZXRJbnN0YW5jZShuZXcgU2V0KFsuLi5vcHRpb25zLmFsbG93ZWRMb2NhbGVzLCBsXSkpLmlzQW1iaWd1b3VzKGNvZGVQb2ludCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6IDAgLyogVW5pY29kZUhpZ2hsaWdodGVyUmVhc29uS2luZC5BbWJpZ3VvdXMgKi8sIGNvbmZ1c2FibGVXaXRoOiBTdHJpbmcuZnJvbUNvZGVQb2ludChwcmltYXJ5Q29uZnVzYWJsZSksIG5vdEFtYmlndW91c0luTG9jYWxlcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25CYXNpY0FTQ0lJICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6IDIgLyogVW5pY29kZUhpZ2hsaWdodGVyUmVhc29uS2luZC5Ob25CYXNpY0FzY2lpICovIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFJlZ0V4cENoYXJDbGFzc0V4cHIoY29kZVBvaW50cywgZmxhZ3MpIHtcbiAgICBjb25zdCBzcmMgPSBgWyR7c3RyaW5ncy5lc2NhcGVSZWdFeHBDaGFyYWN0ZXJzKGNvZGVQb2ludHMubWFwKChpKSA9PiBTdHJpbmcuZnJvbUNvZGVQb2ludChpKSkuam9pbignJykpfV1gO1xuICAgIHJldHVybiBzcmM7XG59XG5jbGFzcyBDb2RlUG9pbnRIaWdobGlnaHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmFsbG93ZWRDb2RlUG9pbnRzID0gbmV3IFNldChvcHRpb25zLmFsbG93ZWRDb2RlUG9pbnRzKTtcbiAgICAgICAgdGhpcy5hbWJpZ3VvdXNDaGFyYWN0ZXJzID0gc3RyaW5ncy5BbWJpZ3VvdXNDaGFyYWN0ZXJzLmdldEluc3RhbmNlKG5ldyBTZXQob3B0aW9ucy5hbGxvd2VkTG9jYWxlcykpO1xuICAgIH1cbiAgICBnZXRDYW5kaWRhdGVDb2RlUG9pbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vbkJhc2ljQVNDSUkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYWxsTm9uQmFzaWNBc2NpaSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmludmlzaWJsZUNoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3Agb2Ygc3RyaW5ncy5JbnZpc2libGVDaGFyYWN0ZXJzLmNvZGVQb2ludHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsb3dlZEludmlzaWJsZUNoYXJhY3RlcihTdHJpbmcuZnJvbUNvZGVQb2ludChjcCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5hZGQoY3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFtYmlndW91c0NoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3Agb2YgdGhpcy5hbWJpZ3VvdXNDaGFyYWN0ZXJzLmdldENvbmZ1c2FibGVDb2RlUG9pbnRzKCkpIHtcbiAgICAgICAgICAgICAgICBzZXQuYWRkKGNwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNwIG9mIHRoaXMuYWxsb3dlZENvZGVQb2ludHMpIHtcbiAgICAgICAgICAgIHNldC5kZWxldGUoY3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIHNob3VsZEhpZ2hsaWdodE5vbkJhc2ljQVNDSUkoY2hhcmFjdGVyLCB3b3JkQ29udGV4dCkge1xuICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjaGFyYWN0ZXIuY29kZVBvaW50QXQoMCk7XG4gICAgICAgIGlmICh0aGlzLmFsbG93ZWRDb2RlUG9pbnRzLmhhcyhjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uTm9uZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vbkJhc2ljQVNDSUkpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25CYXNpY0FTQ0lJICovO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYXNCYXNpY0FTQ0lJQ2hhcmFjdGVycyA9IGZhbHNlO1xuICAgICAgICBsZXQgaGFzTm9uQ29uZnVzYWJsZU5vbkJhc2ljQXNjaWlDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHdvcmRDb250ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoYXIgb2Ygd29yZENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjaGFyLmNvZGVQb2ludEF0KDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmFzaWNBU0NJSSA9IHN0cmluZ3MuaXNCYXNpY0FTQ0lJKGNoYXIpO1xuICAgICAgICAgICAgICAgIGhhc0Jhc2ljQVNDSUlDaGFyYWN0ZXJzID0gaGFzQmFzaWNBU0NJSUNoYXJhY3RlcnMgfHwgaXNCYXNpY0FTQ0lJO1xuICAgICAgICAgICAgICAgIGlmICghaXNCYXNpY0FTQ0lJICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmFtYmlndW91c0NoYXJhY3RlcnMuaXNBbWJpZ3VvdXMoY29kZVBvaW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAhc3RyaW5ncy5JbnZpc2libGVDaGFyYWN0ZXJzLmlzSW52aXNpYmxlQ2hhcmFjdGVyKGNvZGVQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTm9uQ29uZnVzYWJsZU5vbkJhc2ljQXNjaWlDaGFyYWN0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgIC8qIERvbid0IGFsbG93IG1peGluZyB3ZWlyZCBsb29raW5nIGNoYXJhY3RlcnMgd2l0aCBBU0NJSSAqLyAhaGFzQmFzaWNBU0NJSUNoYXJhY3RlcnMgJiZcbiAgICAgICAgICAgIC8qIElzIHRoZXJlIGFuIG9idmlvdXNseSB3ZWlyZCBsb29raW5nIGNoYXJhY3Rlcj8gKi8gaGFzTm9uQ29uZnVzYWJsZU5vbkJhc2ljQXNjaWlDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25lICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW52aXNpYmxlQ2hhcmFjdGVycykge1xuICAgICAgICAgICAgLy8gVE9ETyBjaGVjayBmb3IgZW1vamlzXG4gICAgICAgICAgICBpZiAoIWlzQWxsb3dlZEludmlzaWJsZUNoYXJhY3RlcihjaGFyYWN0ZXIpICYmIHN0cmluZ3MuSW52aXNpYmxlQ2hhcmFjdGVycy5pc0ludmlzaWJsZUNoYXJhY3Rlcihjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogU2ltcGxlSGlnaGxpZ2h0UmVhc29uLkludmlzaWJsZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFtYmlndW91c0NoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFtYmlndW91c0NoYXJhY3RlcnMuaXNBbWJpZ3VvdXMoY29kZVBvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAzIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5BbWJpZ3VvdXMgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogU2ltcGxlSGlnaGxpZ2h0UmVhc29uLk5vbmUgKi87XG4gICAgfVxufVxuZnVuY3Rpb24gaXNBbGxvd2VkSW52aXNpYmxlQ2hhcmFjdGVyKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIgPT09ICcgJyB8fCBjaGFyYWN0ZXIgPT09ICdcXG4nIHx8IGNoYXJhY3RlciA9PT0gJ1xcdCc7XG59XG4iLCJ2YXIgbWFwID0ge1xuXHRcIi4vZWRpdG9yQmFzZUFwaVwiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2VkaXRvckJhc2VBcGkuanNcIlxuXHRdLFxuXHRcIi4vZWRpdG9yQmFzZUFwaS5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2VkaXRvckJhc2VBcGkuanNcIlxuXHRdLFxuXHRcIi4vZWRpdG9yU2ltcGxlV29ya2VyXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZWRpdG9yU2ltcGxlV29ya2VyLmpzXCJcblx0XSxcblx0XCIuL2VkaXRvclNpbXBsZVdvcmtlci5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2VkaXRvclNpbXBsZVdvcmtlci5qc1wiXG5cdF0sXG5cdFwiLi9lZGl0b3JXb3JrZXJcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JXb3JrZXIuanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2VkaXRvcldvcmtlcl9qc1wiXG5cdF0sXG5cdFwiLi9lZGl0b3JXb3JrZXIuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JXb3JrZXIuanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2VkaXRvcldvcmtlcl9qc1wiXG5cdF0sXG5cdFwiLi9lZGl0b3JXb3JrZXJIb3N0XCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZWRpdG9yV29ya2VySG9zdC5qc1wiXG5cdF0sXG5cdFwiLi9lZGl0b3JXb3JrZXJIb3N0LmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZWRpdG9yV29ya2VySG9zdC5qc1wiXG5cdF0sXG5cdFwiLi9maW5kU2VjdGlvbkhlYWRlcnNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9maW5kU2VjdGlvbkhlYWRlcnMuanNcIlxuXHRdLFxuXHRcIi4vZmluZFNlY3Rpb25IZWFkZXJzLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZmluZFNlY3Rpb25IZWFkZXJzLmpzXCJcblx0XSxcblx0XCIuL2dldEljb25DbGFzc2VzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZ2V0SWNvbkNsYXNzZXMuanNcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2Jhc2VfY29tbW9uX3Jlc291cmNlc19qcy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvci02MDk3NjBcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2dldEljb25DbGFzc2VzX2pzXCJcblx0XSxcblx0XCIuL2dldEljb25DbGFzc2VzLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZ2V0SWNvbkNsYXNzZXMuanNcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2Jhc2VfY29tbW9uX3Jlc291cmNlc19qcy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvci02MDk3NjBcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2dldEljb25DbGFzc2VzX2pzXCJcblx0XSxcblx0XCIuL2xhbmd1YWdlRmVhdHVyZURlYm91bmNlXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbGFuZ3VhZ2VGZWF0dXJlRGVib3VuY2UuanNcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX3BsYXRmb3JtX2xvZ19jb21tb25fbG9nX2pzXCIsXG5cdFx0XCJub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19sYW5ndWFnZUZlYXR1cmVEZWJvdW5jZV9qc1wiXG5cdF0sXG5cdFwiLi9sYW5ndWFnZUZlYXR1cmVEZWJvdW5jZS5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2xhbmd1YWdlRmVhdHVyZURlYm91bmNlLmpzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19wbGF0Zm9ybV9sb2dfY29tbW9uX2xvZ19qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfbGFuZ3VhZ2VGZWF0dXJlRGVib3VuY2VfanNcIlxuXHRdLFxuXHRcIi4vbGFuZ3VhZ2VGZWF0dXJlc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2xhbmd1YWdlRmVhdHVyZXMuanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2xhbmd1YWdlRmVhdHVyZXNfanNcIlxuXHRdLFxuXHRcIi4vbGFuZ3VhZ2VGZWF0dXJlcy5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2xhbmd1YWdlRmVhdHVyZXMuanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2xhbmd1YWdlRmVhdHVyZXNfanNcIlxuXHRdLFxuXHRcIi4vbGFuZ3VhZ2VGZWF0dXJlc1NlcnZpY2VcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9sYW5ndWFnZUZlYXR1cmVzU2VydmljZS5qc1wiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfYmFzZV9jb21tb25fZ2xvYl9qc1wiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19sYW5ndWFnZUZlYXR1cmVzU2VydmljZV9qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2Jhc2VfY29tbW9uX2V4dHBhdGhfanMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX3BsLWQxN2MwYlwiXG5cdF0sXG5cdFwiLi9sYW5ndWFnZUZlYXR1cmVzU2VydmljZS5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2xhbmd1YWdlRmVhdHVyZXNTZXJ2aWNlLmpzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19iYXNlX2NvbW1vbl9nbG9iX2pzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2xhbmd1YWdlRmVhdHVyZXNTZXJ2aWNlX2pzXCIsXG5cdFx0XCJub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfYmFzZV9jb21tb25fZXh0cGF0aF9qcy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfcGwtZDE3YzBiXCJcblx0XSxcblx0XCIuL2xhbmd1YWdlU2VydmljZVwiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2xhbmd1YWdlU2VydmljZS5qc1wiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfYmFzZV9jb21tb25fcmVzb3VyY2VzX2pzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yLTYwOTc2MFwiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfYmFzZV9jb21tb25fZ2xvYl9qc1wiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19sYW5ndWFnZXNSZWdpc3RyeV9qc1wiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19sYW5ndWFnZVNlcnZpY2VfanNcIlxuXHRdLFxuXHRcIi4vbGFuZ3VhZ2VTZXJ2aWNlLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbGFuZ3VhZ2VTZXJ2aWNlLmpzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19iYXNlX2NvbW1vbl9yZXNvdXJjZXNfanMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3ItNjA5NzYwXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19iYXNlX2NvbW1vbl9nbG9iX2pzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2xhbmd1YWdlc1JlZ2lzdHJ5X2pzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2xhbmd1YWdlU2VydmljZV9qc1wiXG5cdF0sXG5cdFwiLi9sYW5ndWFnZXNBc3NvY2lhdGlvbnNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9sYW5ndWFnZXNBc3NvY2lhdGlvbnMuanNcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2Jhc2VfY29tbW9uX3Jlc291cmNlc19qcy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvci02MDk3NjBcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2Jhc2VfY29tbW9uX2dsb2JfanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2xhbmd1YWdlc0Fzc29jaWF0aW9uc19qc1wiXG5cdF0sXG5cdFwiLi9sYW5ndWFnZXNBc3NvY2lhdGlvbnMuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9sYW5ndWFnZXNBc3NvY2lhdGlvbnMuanNcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2Jhc2VfY29tbW9uX3Jlc291cmNlc19qcy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvci02MDk3NjBcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2Jhc2VfY29tbW9uX2dsb2JfanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2xhbmd1YWdlc0Fzc29jaWF0aW9uc19qc1wiXG5cdF0sXG5cdFwiLi9sYW5ndWFnZXNSZWdpc3RyeVwiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2xhbmd1YWdlc1JlZ2lzdHJ5LmpzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19iYXNlX2NvbW1vbl9yZXNvdXJjZXNfanMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3ItNjA5NzYwXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19iYXNlX2NvbW1vbl9nbG9iX2pzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX2xhbmd1YWdlc1JlZ2lzdHJ5X2pzXCJcblx0XSxcblx0XCIuL2xhbmd1YWdlc1JlZ2lzdHJ5LmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbGFuZ3VhZ2VzUmVnaXN0cnkuanNcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2Jhc2VfY29tbW9uX3Jlc291cmNlc19qcy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvci02MDk3NjBcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2Jhc2VfY29tbW9uX2dsb2JfanNcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfbGFuZ3VhZ2VzUmVnaXN0cnlfanNcIlxuXHRdLFxuXHRcIi4vbWFya2VyRGVjb3JhdGlvbnNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9tYXJrZXJEZWNvcmF0aW9ucy5qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfbWFya2VyRGVjb3JhdGlvbnNfanNcIlxuXHRdLFxuXHRcIi4vbWFya2VyRGVjb3JhdGlvbnMuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9tYXJrZXJEZWNvcmF0aW9ucy5qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfbWFya2VyRGVjb3JhdGlvbnNfanNcIlxuXHRdLFxuXHRcIi4vbWFya2VyRGVjb3JhdGlvbnNTZXJ2aWNlXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbWFya2VyRGVjb3JhdGlvbnNTZXJ2aWNlLmpzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX2NvcmVfZWRpdG9yQ29sb3JSZWdpc3RyeV9qc1wiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19tYXJrZXJEZWNvcmF0aW9uc1NlcnZpY2VfanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19wbGF0Zm9ybV9pbnN0YW50aWF0aW9uX2NvbW1vbl9pbnN0YW50aWF0aW9uX2pzLW5vZGVfbW9kdWxlcy02NDA1OTVcIlxuXHRdLFxuXHRcIi4vbWFya2VyRGVjb3JhdGlvbnNTZXJ2aWNlLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbWFya2VyRGVjb3JhdGlvbnNTZXJ2aWNlLmpzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX2NvcmVfZWRpdG9yQ29sb3JSZWdpc3RyeV9qc1wiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19tYXJrZXJEZWNvcmF0aW9uc1NlcnZpY2VfanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19wbGF0Zm9ybV9pbnN0YW50aWF0aW9uX2NvbW1vbl9pbnN0YW50aWF0aW9uX2pzLW5vZGVfbW9kdWxlcy02NDA1OTVcIlxuXHRdLFxuXHRcIi4vbW9kZWxcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9tb2RlbC5qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfbW9kZWxfanNcIlxuXHRdLFxuXHRcIi4vbW9kZWwuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9tb2RlbC5qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfbW9kZWxfanNcIlxuXHRdLFxuXHRcIi4vbW9kZWxTZXJ2aWNlXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbW9kZWxTZXJ2aWNlLmpzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19iYXNlX2NvbW1vbl9yZXNvdXJjZXNfanMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3ItNjA5NzYwXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX2NvcmVfZWRpdG9yQ29sb3JSZWdpc3RyeV9qc1wiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19tb2RlbFNlcnZpY2VfanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX2NvcmVfZW9sQ291bnRlcl9qcy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvci00M2E4MGVcIlxuXHRdLFxuXHRcIi4vbW9kZWxTZXJ2aWNlLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbW9kZWxTZXJ2aWNlLmpzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19iYXNlX2NvbW1vbl9yZXNvdXJjZXNfanMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3ItNjA5NzYwXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX2NvcmVfZWRpdG9yQ29sb3JSZWdpc3RyeV9qc1wiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19tb2RlbFNlcnZpY2VfanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX2NvcmVfZW9sQ291bnRlcl9qcy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvci00M2E4MGVcIlxuXHRdLFxuXHRcIi4vcmVzb2x2ZXJTZXJ2aWNlXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvcmVzb2x2ZXJTZXJ2aWNlLmpzXCIsXG5cdFx0XCJub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19yZXNvbHZlclNlcnZpY2VfanNcIlxuXHRdLFxuXHRcIi4vcmVzb2x2ZXJTZXJ2aWNlLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvcmVzb2x2ZXJTZXJ2aWNlLmpzXCIsXG5cdFx0XCJub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19yZXNvbHZlclNlcnZpY2VfanNcIlxuXHRdLFxuXHRcIi4vc2VtYW50aWNUb2tlbnNEdG9cIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9zZW1hbnRpY1Rva2Vuc0R0by5qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfc2VtYW50aWNUb2tlbnNEdG9fanNcIlxuXHRdLFxuXHRcIi4vc2VtYW50aWNUb2tlbnNEdG8uanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9zZW1hbnRpY1Rva2Vuc0R0by5qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfc2VtYW50aWNUb2tlbnNEdG9fanNcIlxuXHRdLFxuXHRcIi4vc2VtYW50aWNUb2tlbnNQcm92aWRlclN0eWxpbmdcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9zZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZy5qc1wiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfcGxhdGZvcm1fbG9nX2NvbW1vbl9sb2dfanNcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfc2VtYW50aWNUb2tlbnNQcm92aWRlclN0eWxpbmdfanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19wbGF0Zm9ybV90aGVtZV9jb21tb25fdGhlbWVTZXJ2aWNlX2pzXCJcblx0XSxcblx0XCIuL3NlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvc2VtYW50aWNUb2tlbnNQcm92aWRlclN0eWxpbmcuanNcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX3BsYXRmb3JtX2xvZ19jb21tb25fbG9nX2pzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX3NlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nX2pzXCIsXG5cdFx0XCJub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfcGxhdGZvcm1fdGhlbWVfY29tbW9uX3RoZW1lU2VydmljZV9qc1wiXG5cdF0sXG5cdFwiLi9zZW1hbnRpY1Rva2Vuc1N0eWxpbmdcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9zZW1hbnRpY1Rva2Vuc1N0eWxpbmcuanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX3NlbWFudGljVG9rZW5zU3R5bGluZ19qc1wiXG5cdF0sXG5cdFwiLi9zZW1hbnRpY1Rva2Vuc1N0eWxpbmcuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9zZW1hbnRpY1Rva2Vuc1N0eWxpbmcuanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX3NlbWFudGljVG9rZW5zU3R5bGluZ19qc1wiXG5cdF0sXG5cdFwiLi9zZW1hbnRpY1Rva2Vuc1N0eWxpbmdTZXJ2aWNlXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvc2VtYW50aWNUb2tlbnNTdHlsaW5nU2VydmljZS5qc1wiLFxuXHRcdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfcGxhdGZvcm1fbG9nX2NvbW1vbl9sb2dfanNcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfc2VtYW50aWNUb2tlbnNQcm92aWRlclN0eWxpbmdfanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX3NlbWFudGljVG9rZW5zU3R5bGluZ1NlcnZpY2VfanNcIlxuXHRdLFxuXHRcIi4vc2VtYW50aWNUb2tlbnNTdHlsaW5nU2VydmljZS5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3NlbWFudGljVG9rZW5zU3R5bGluZ1NlcnZpY2UuanNcIixcblx0XHRcInZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX3BsYXRmb3JtX2xvZ19jb21tb25fbG9nX2pzXCIsXG5cdFx0XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX3NlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nX2pzXCIsXG5cdFx0XCJub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc19zZW1hbnRpY1Rva2Vuc1N0eWxpbmdTZXJ2aWNlX2pzXCJcblx0XSxcblx0XCIuL3RleHRNb2RlbFN5bmMvdGV4dE1vZGVsU3luYy5pbXBsXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdGV4dE1vZGVsU3luYy90ZXh0TW9kZWxTeW5jLmltcGwuanNcIlxuXHRdLFxuXHRcIi4vdGV4dE1vZGVsU3luYy90ZXh0TW9kZWxTeW5jLmltcGwuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy90ZXh0TW9kZWxTeW5jL3RleHRNb2RlbFN5bmMuaW1wbC5qc1wiXG5cdF0sXG5cdFwiLi90ZXh0TW9kZWxTeW5jL3RleHRNb2RlbFN5bmMucHJvdG9jb2xcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy90ZXh0TW9kZWxTeW5jL3RleHRNb2RlbFN5bmMucHJvdG9jb2wuanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX3RleHRNb2RlbFN5bmNfdGV4dE1vZGVsU3luY19wcm90b2NvbF9qc1wiXG5cdF0sXG5cdFwiLi90ZXh0TW9kZWxTeW5jL3RleHRNb2RlbFN5bmMucHJvdG9jb2wuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy90ZXh0TW9kZWxTeW5jL3RleHRNb2RlbFN5bmMucHJvdG9jb2wuanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX3RleHRNb2RlbFN5bmNfdGV4dE1vZGVsU3luY19wcm90b2NvbF9qc1wiXG5cdF0sXG5cdFwiLi90ZXh0UmVzb3VyY2VDb25maWd1cmF0aW9uXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdGV4dFJlc291cmNlQ29uZmlndXJhdGlvbi5qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfdGV4dFJlc291cmNlQ29uZmlndXJhdGlvbl9qc1wiXG5cdF0sXG5cdFwiLi90ZXh0UmVzb3VyY2VDb25maWd1cmF0aW9uLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdGV4dFJlc291cmNlQ29uZmlndXJhdGlvbi5qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfdGV4dFJlc291cmNlQ29uZmlndXJhdGlvbl9qc1wiXG5cdF0sXG5cdFwiLi90cmVlU2l0dGVyUGFyc2VyU2VydmljZVwiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3RyZWVTaXR0ZXJQYXJzZXJTZXJ2aWNlLmpzXCIsXG5cdFx0XCJub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc190cmVlU2l0dGVyUGFyc2VyU2VydmljZV9qc1wiXG5cdF0sXG5cdFwiLi90cmVlU2l0dGVyUGFyc2VyU2VydmljZS5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3RyZWVTaXR0ZXJQYXJzZXJTZXJ2aWNlLmpzXCIsXG5cdFx0XCJub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc190cmVlU2l0dGVyUGFyc2VyU2VydmljZV9qc1wiXG5cdF0sXG5cdFwiLi90cmVlVmlld3NEbmRcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy90cmVlVmlld3NEbmQuanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX3RyZWVWaWV3c0RuZF9qc1wiXG5cdF0sXG5cdFwiLi90cmVlVmlld3NEbmQuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy90cmVlVmlld3NEbmQuanNcIixcblx0XHRcIm5vZGVfbW9kdWxlc19tb25hY28tZWRpdG9yX2VzbV92c19lZGl0b3JfY29tbW9uX3NlcnZpY2VzX3RyZWVWaWV3c0RuZF9qc1wiXG5cdF0sXG5cdFwiLi90cmVlVmlld3NEbmRTZXJ2aWNlXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdHJlZVZpZXdzRG5kU2VydmljZS5qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfdHJlZVZpZXdzRG5kU2VydmljZV9qc1wiXG5cdF0sXG5cdFwiLi90cmVlVmlld3NEbmRTZXJ2aWNlLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdHJlZVZpZXdzRG5kU2VydmljZS5qc1wiLFxuXHRcdFwibm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2VkaXRvcl9jb21tb25fc2VydmljZXNfdHJlZVZpZXdzRG5kU2VydmljZV9qc1wiXG5cdF0sXG5cdFwiLi91bmljb2RlVGV4dE1vZGVsSGlnaGxpZ2h0ZXJcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy91bmljb2RlVGV4dE1vZGVsSGlnaGxpZ2h0ZXIuanNcIlxuXHRdLFxuXHRcIi4vdW5pY29kZVRleHRNb2RlbEhpZ2hsaWdodGVyLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdW5pY29kZVRleHRNb2RlbEhpZ2hsaWdodGVyLmpzXCJcblx0XVxufTtcbmZ1bmN0aW9uIHdlYnBhY2tBc3luY0NvbnRleHQocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9KTtcblx0fVxuXG5cdHZhciBpZHMgPSBtYXBbcmVxXSwgaWQgPSBpZHNbMF07XG5cdHJldHVybiBQcm9taXNlLmFsbChpZHMuc2xpY2UoMSkubWFwKF9fd2VicGFja19yZXF1aXJlX18uZSkpLnRoZW4oKCkgPT4ge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcblx0fSk7XG59XG53ZWJwYWNrQXN5bmNDb250ZXh0LmtleXMgPSAoKSA9PiAoT2JqZWN0LmtleXMobWFwKSk7XG53ZWJwYWNrQXN5bmNDb250ZXh0LmlkID0gXCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzIGxhenkgcmVjdXJzaXZlIF4uKiRcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0FzeW5jQ29udGV4dDsiLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIFRISVMgSVMgQSBHRU5FUkFURUQgRklMRS4gRE8gTk9UIEVESVQgRElSRUNUTFkuXG5leHBvcnQgdmFyIEFjY2Vzc2liaWxpdHlTdXBwb3J0O1xuKGZ1bmN0aW9uIChBY2Nlc3NpYmlsaXR5U3VwcG9ydCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHRoZSBicm93c2VyIGNhc2Ugd2hlcmUgaXQgaXMgbm90IGtub3duIGlmIGEgc2NyZWVuIHJlYWRlciBpcyBhdHRhY2hlZCBvciBuby5cbiAgICAgKi9cbiAgICBBY2Nlc3NpYmlsaXR5U3VwcG9ydFtBY2Nlc3NpYmlsaXR5U3VwcG9ydFtcIlVua25vd25cIl0gPSAwXSA9IFwiVW5rbm93blwiO1xuICAgIEFjY2Vzc2liaWxpdHlTdXBwb3J0W0FjY2Vzc2liaWxpdHlTdXBwb3J0W1wiRGlzYWJsZWRcIl0gPSAxXSA9IFwiRGlzYWJsZWRcIjtcbiAgICBBY2Nlc3NpYmlsaXR5U3VwcG9ydFtBY2Nlc3NpYmlsaXR5U3VwcG9ydFtcIkVuYWJsZWRcIl0gPSAyXSA9IFwiRW5hYmxlZFwiO1xufSkoQWNjZXNzaWJpbGl0eVN1cHBvcnQgfHwgKEFjY2Vzc2liaWxpdHlTdXBwb3J0ID0ge30pKTtcbmV4cG9ydCB2YXIgQ29kZUFjdGlvblRyaWdnZXJUeXBlO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uVHJpZ2dlclR5cGUpIHtcbiAgICBDb2RlQWN0aW9uVHJpZ2dlclR5cGVbQ29kZUFjdGlvblRyaWdnZXJUeXBlW1wiSW52b2tlXCJdID0gMV0gPSBcIkludm9rZVwiO1xuICAgIENvZGVBY3Rpb25UcmlnZ2VyVHlwZVtDb2RlQWN0aW9uVHJpZ2dlclR5cGVbXCJBdXRvXCJdID0gMl0gPSBcIkF1dG9cIjtcbn0pKENvZGVBY3Rpb25UcmlnZ2VyVHlwZSB8fCAoQ29kZUFjdGlvblRyaWdnZXJUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZTtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZSkge1xuICAgIENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIC8qKlxuICAgICAqIEFkanVzdCB3aGl0ZXNwYWNlL2luZGVudGF0aW9uIG9mIG11bHRpbGluZSBpbnNlcnQgdGV4dHMgdG9cbiAgICAgKiBtYXRjaCB0aGUgY3VycmVudCBsaW5lIGluZGVudGF0aW9uLlxuICAgICAqL1xuICAgIENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZVtcIktlZXBXaGl0ZXNwYWNlXCJdID0gMV0gPSBcIktlZXBXaGl0ZXNwYWNlXCI7XG4gICAgLyoqXG4gICAgICogYGluc2VydFRleHRgIGlzIGEgc25pcHBldC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlW0NvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbXCJJbnNlcnRBc1NuaXBwZXRcIl0gPSA0XSA9IFwiSW5zZXJ0QXNTbmlwcGV0XCI7XG59KShDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlIHx8IChDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlID0ge30pKTtcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUtpbmQpIHtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiTWV0aG9kXCJdID0gMF0gPSBcIk1ldGhvZFwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGdW5jdGlvblwiXSA9IDFdID0gXCJGdW5jdGlvblwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJDb25zdHJ1Y3RvclwiXSA9IDJdID0gXCJDb25zdHJ1Y3RvclwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGaWVsZFwiXSA9IDNdID0gXCJGaWVsZFwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJWYXJpYWJsZVwiXSA9IDRdID0gXCJWYXJpYWJsZVwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJDbGFzc1wiXSA9IDVdID0gXCJDbGFzc1wiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJTdHJ1Y3RcIl0gPSA2XSA9IFwiU3RydWN0XCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkludGVyZmFjZVwiXSA9IDddID0gXCJJbnRlcmZhY2VcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiTW9kdWxlXCJdID0gOF0gPSBcIk1vZHVsZVwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJQcm9wZXJ0eVwiXSA9IDldID0gXCJQcm9wZXJ0eVwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJFdmVudFwiXSA9IDEwXSA9IFwiRXZlbnRcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiT3BlcmF0b3JcIl0gPSAxMV0gPSBcIk9wZXJhdG9yXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlVuaXRcIl0gPSAxMl0gPSBcIlVuaXRcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVmFsdWVcIl0gPSAxM10gPSBcIlZhbHVlXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkNvbnN0YW50XCJdID0gMTRdID0gXCJDb25zdGFudFwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJFbnVtXCJdID0gMTVdID0gXCJFbnVtXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkVudW1NZW1iZXJcIl0gPSAxNl0gPSBcIkVudW1NZW1iZXJcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiS2V5d29yZFwiXSA9IDE3XSA9IFwiS2V5d29yZFwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJUZXh0XCJdID0gMThdID0gXCJUZXh0XCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkNvbG9yXCJdID0gMTldID0gXCJDb2xvclwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGaWxlXCJdID0gMjBdID0gXCJGaWxlXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlJlZmVyZW5jZVwiXSA9IDIxXSA9IFwiUmVmZXJlbmNlXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkN1c3RvbWNvbG9yXCJdID0gMjJdID0gXCJDdXN0b21jb2xvclwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGb2xkZXJcIl0gPSAyM10gPSBcIkZvbGRlclwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJUeXBlUGFyYW1ldGVyXCJdID0gMjRdID0gXCJUeXBlUGFyYW1ldGVyXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlVzZXJcIl0gPSAyNV0gPSBcIlVzZXJcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiSXNzdWVcIl0gPSAyNl0gPSBcIklzc3VlXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlNuaXBwZXRcIl0gPSAyN10gPSBcIlNuaXBwZXRcIjtcbn0pKENvbXBsZXRpb25JdGVtS2luZCB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kID0ge30pKTtcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1UYWc7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtVGFnKSB7XG4gICAgQ29tcGxldGlvbkl0ZW1UYWdbQ29tcGxldGlvbkl0ZW1UYWdbXCJEZXByZWNhdGVkXCJdID0gMV0gPSBcIkRlcHJlY2F0ZWRcIjtcbn0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChDb21wbGV0aW9uSXRlbVRhZyA9IHt9KSk7XG4vKipcbiAqIEhvdyBhIHN1Z2dlc3QgcHJvdmlkZXIgd2FzIHRyaWdnZXJlZC5cbiAqL1xuZXhwb3J0IHZhciBDb21wbGV0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25UcmlnZ2VyS2luZCkge1xuICAgIENvbXBsZXRpb25UcmlnZ2VyS2luZFtDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAwXSA9IFwiSW52b2tlXCI7XG4gICAgQ29tcGxldGlvblRyaWdnZXJLaW5kW0NvbXBsZXRpb25UcmlnZ2VyS2luZFtcIlRyaWdnZXJDaGFyYWN0ZXJcIl0gPSAxXSA9IFwiVHJpZ2dlckNoYXJhY3RlclwiO1xuICAgIENvbXBsZXRpb25UcmlnZ2VyS2luZFtDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJUcmlnZ2VyRm9ySW5jb21wbGV0ZUNvbXBsZXRpb25zXCJdID0gMl0gPSBcIlRyaWdnZXJGb3JJbmNvbXBsZXRlQ29tcGxldGlvbnNcIjtcbn0pKENvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogQSBwb3NpdGlvbmluZyBwcmVmZXJlbmNlIGZvciByZW5kZXJpbmcgY29udGVudCB3aWRnZXRzLlxuICovXG5leHBvcnQgdmFyIENvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2U7XG4oZnVuY3Rpb24gKENvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UpIHtcbiAgICAvKipcbiAgICAgKiBQbGFjZSB0aGUgY29udGVudCB3aWRnZXQgZXhhY3RseSBhdCBhIHBvc2l0aW9uXG4gICAgICovXG4gICAgQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiRVhBQ1RcIl0gPSAwXSA9IFwiRVhBQ1RcIjtcbiAgICAvKipcbiAgICAgKiBQbGFjZSB0aGUgY29udGVudCB3aWRnZXQgYWJvdmUgYSBwb3NpdGlvblxuICAgICAqL1xuICAgIENvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtcIkFCT1ZFXCJdID0gMV0gPSBcIkFCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogUGxhY2UgdGhlIGNvbnRlbnQgd2lkZ2V0IGJlbG93IGEgcG9zaXRpb25cbiAgICAgKi9cbiAgICBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW0NvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJCRUxPV1wiXSA9IDJdID0gXCJCRUxPV1wiO1xufSkoQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSB8fCAoQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSA9IHt9KSk7XG4vKipcbiAqIERlc2NyaWJlcyB0aGUgcmVhc29uIHRoZSBjdXJzb3IgaGFzIGNoYW5nZWQgaXRzIHBvc2l0aW9uLlxuICovXG5leHBvcnQgdmFyIEN1cnNvckNoYW5nZVJlYXNvbjtcbihmdW5jdGlvbiAoQ3Vyc29yQ2hhbmdlUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVW5rbm93biBvciBub3Qgc2V0LlxuICAgICAqL1xuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJOb3RTZXRcIl0gPSAwXSA9IFwiTm90U2V0XCI7XG4gICAgLyoqXG4gICAgICogQSBgbW9kZWwuc2V0VmFsdWUoKWAgd2FzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBDdXJzb3JDaGFuZ2VSZWFzb25bQ3Vyc29yQ2hhbmdlUmVhc29uW1wiQ29udGVudEZsdXNoXCJdID0gMV0gPSBcIkNvbnRlbnRGbHVzaFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBgbW9kZWxgIGhhcyBiZWVuIGNoYW5nZWQgb3V0c2lkZSBvZiB0aGlzIGN1cnNvciBhbmQgdGhlIGN1cnNvciByZWNvdmVycyBpdHMgcG9zaXRpb24gZnJvbSBhc3NvY2lhdGVkIG1hcmtlcnMuXG4gICAgICovXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIlJlY292ZXJGcm9tTWFya2Vyc1wiXSA9IDJdID0gXCJSZWNvdmVyRnJvbU1hcmtlcnNcIjtcbiAgICAvKipcbiAgICAgKiBUaGVyZSB3YXMgYW4gZXhwbGljaXQgdXNlciBnZXN0dXJlLlxuICAgICAqL1xuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJFeHBsaWNpdFwiXSA9IDNdID0gXCJFeHBsaWNpdFwiO1xuICAgIC8qKlxuICAgICAqIFRoZXJlIHdhcyBhIFBhc3RlLlxuICAgICAqL1xuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJQYXN0ZVwiXSA9IDRdID0gXCJQYXN0ZVwiO1xuICAgIC8qKlxuICAgICAqIFRoZXJlIHdhcyBhbiBVbmRvLlxuICAgICAqL1xuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJVbmRvXCJdID0gNV0gPSBcIlVuZG9cIjtcbiAgICAvKipcbiAgICAgKiBUaGVyZSB3YXMgYSBSZWRvLlxuICAgICAqL1xuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJSZWRvXCJdID0gNl0gPSBcIlJlZG9cIjtcbn0pKEN1cnNvckNoYW5nZVJlYXNvbiB8fCAoQ3Vyc29yQ2hhbmdlUmVhc29uID0ge30pKTtcbi8qKlxuICogVGhlIGRlZmF1bHQgZW5kIG9mIGxpbmUgdG8gdXNlIHdoZW4gaW5zdGFudGlhdGluZyBtb2RlbHMuXG4gKi9cbmV4cG9ydCB2YXIgRGVmYXVsdEVuZE9mTGluZTtcbihmdW5jdGlvbiAoRGVmYXVsdEVuZE9mTGluZSkge1xuICAgIC8qKlxuICAgICAqIFVzZSBsaW5lIGZlZWQgKFxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBEZWZhdWx0RW5kT2ZMaW5lW0RlZmF1bHRFbmRPZkxpbmVbXCJMRlwiXSA9IDFdID0gXCJMRlwiO1xuICAgIC8qKlxuICAgICAqIFVzZSBjYXJyaWFnZSByZXR1cm4gYW5kIGxpbmUgZmVlZCAoXFxyXFxuKSBhcyB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIERlZmF1bHRFbmRPZkxpbmVbRGVmYXVsdEVuZE9mTGluZVtcIkNSTEZcIl0gPSAyXSA9IFwiQ1JMRlwiO1xufSkoRGVmYXVsdEVuZE9mTGluZSB8fCAoRGVmYXVsdEVuZE9mTGluZSA9IHt9KSk7XG4vKipcbiAqIEEgZG9jdW1lbnQgaGlnaGxpZ2h0IGtpbmQuXG4gKi9cbmV4cG9ydCB2YXIgRG9jdW1lbnRIaWdobGlnaHRLaW5kO1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIHRleHR1YWwgb2NjdXJyZW5jZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmRbRG9jdW1lbnRIaWdobGlnaHRLaW5kW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XG4gICAgLyoqXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJSZWFkXCJdID0gMV0gPSBcIlJlYWRcIjtcbiAgICAvKipcbiAgICAgKiBXcml0ZS1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2Ugd3JpdGluZyB0byBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJXcml0ZVwiXSA9IDJdID0gXCJXcml0ZVwiO1xufSkoRG9jdW1lbnRIaWdobGlnaHRLaW5kIHx8IChEb2N1bWVudEhpZ2hsaWdodEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGF1dG8gaW5kZW50YXRpb24gaW4gdGhlIGVkaXRvclxuICovXG5leHBvcnQgdmFyIEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneTtcbihmdW5jdGlvbiAoRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5KSB7XG4gICAgRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W0VkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbXCJLZWVwXCJdID0gMV0gPSBcIktlZXBcIjtcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiQnJhY2tldHNcIl0gPSAyXSA9IFwiQnJhY2tldHNcIjtcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiQWR2YW5jZWRcIl0gPSAzXSA9IFwiQWR2YW5jZWRcIjtcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiRnVsbFwiXSA9IDRdID0gXCJGdWxsXCI7XG59KShFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3kgfHwgKEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneSA9IHt9KSk7XG5leHBvcnQgdmFyIEVkaXRvck9wdGlvbjtcbihmdW5jdGlvbiAoRWRpdG9yT3B0aW9uKSB7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFjY2VwdFN1Z2dlc3Rpb25PbkNvbW1pdENoYXJhY3RlclwiXSA9IDBdID0gXCJhY2NlcHRTdWdnZXN0aW9uT25Db21taXRDaGFyYWN0ZXJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYWNjZXB0U3VnZ2VzdGlvbk9uRW50ZXJcIl0gPSAxXSA9IFwiYWNjZXB0U3VnZ2VzdGlvbk9uRW50ZXJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYWNjZXNzaWJpbGl0eVN1cHBvcnRcIl0gPSAyXSA9IFwiYWNjZXNzaWJpbGl0eVN1cHBvcnRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYWNjZXNzaWJpbGl0eVBhZ2VTaXplXCJdID0gM10gPSBcImFjY2Vzc2liaWxpdHlQYWdlU2l6ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhcmlhTGFiZWxcIl0gPSA0XSA9IFwiYXJpYUxhYmVsXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFyaWFSZXF1aXJlZFwiXSA9IDVdID0gXCJhcmlhUmVxdWlyZWRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYXV0b0Nsb3NpbmdCcmFja2V0c1wiXSA9IDZdID0gXCJhdXRvQ2xvc2luZ0JyYWNrZXRzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9DbG9zaW5nQ29tbWVudHNcIl0gPSA3XSA9IFwiYXV0b0Nsb3NpbmdDb21tZW50c1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzY3JlZW5SZWFkZXJBbm5vdW5jZUlubGluZVN1Z2dlc3Rpb25cIl0gPSA4XSA9IFwic2NyZWVuUmVhZGVyQW5ub3VuY2VJbmxpbmVTdWdnZXN0aW9uXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9DbG9zaW5nRGVsZXRlXCJdID0gOV0gPSBcImF1dG9DbG9zaW5nRGVsZXRlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9DbG9zaW5nT3ZlcnR5cGVcIl0gPSAxMF0gPSBcImF1dG9DbG9zaW5nT3ZlcnR5cGVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYXV0b0Nsb3NpbmdRdW90ZXNcIl0gPSAxMV0gPSBcImF1dG9DbG9zaW5nUXVvdGVzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9JbmRlbnRcIl0gPSAxMl0gPSBcImF1dG9JbmRlbnRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYXV0b21hdGljTGF5b3V0XCJdID0gMTNdID0gXCJhdXRvbWF0aWNMYXlvdXRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYXV0b1N1cnJvdW5kXCJdID0gMTRdID0gXCJhdXRvU3Vycm91bmRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYnJhY2tldFBhaXJDb2xvcml6YXRpb25cIl0gPSAxNV0gPSBcImJyYWNrZXRQYWlyQ29sb3JpemF0aW9uXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImd1aWRlc1wiXSA9IDE2XSA9IFwiZ3VpZGVzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvZGVMZW5zXCJdID0gMTddID0gXCJjb2RlTGVuc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2RlTGVuc0ZvbnRGYW1pbHlcIl0gPSAxOF0gPSBcImNvZGVMZW5zRm9udEZhbWlseVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2RlTGVuc0ZvbnRTaXplXCJdID0gMTldID0gXCJjb2RlTGVuc0ZvbnRTaXplXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvbG9yRGVjb3JhdG9yc1wiXSA9IDIwXSA9IFwiY29sb3JEZWNvcmF0b3JzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvbG9yRGVjb3JhdG9yc0xpbWl0XCJdID0gMjFdID0gXCJjb2xvckRlY29yYXRvcnNMaW1pdFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2x1bW5TZWxlY3Rpb25cIl0gPSAyMl0gPSBcImNvbHVtblNlbGVjdGlvblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb21tZW50c1wiXSA9IDIzXSA9IFwiY29tbWVudHNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29udGV4dG1lbnVcIl0gPSAyNF0gPSBcImNvbnRleHRtZW51XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvcHlXaXRoU3ludGF4SGlnaGxpZ2h0aW5nXCJdID0gMjVdID0gXCJjb3B5V2l0aFN5bnRheEhpZ2hsaWdodGluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JCbGlua2luZ1wiXSA9IDI2XSA9IFwiY3Vyc29yQmxpbmtpbmdcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY3Vyc29yU21vb3RoQ2FyZXRBbmltYXRpb25cIl0gPSAyN10gPSBcImN1cnNvclNtb290aENhcmV0QW5pbWF0aW9uXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvclN0eWxlXCJdID0gMjhdID0gXCJjdXJzb3JTdHlsZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzXCJdID0gMjldID0gXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvclN1cnJvdW5kaW5nTGluZXNTdHlsZVwiXSA9IDMwXSA9IFwiY3Vyc29yU3Vycm91bmRpbmdMaW5lc1N0eWxlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvcldpZHRoXCJdID0gMzFdID0gXCJjdXJzb3JXaWR0aFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkaXNhYmxlTGF5ZXJIaW50aW5nXCJdID0gMzJdID0gXCJkaXNhYmxlTGF5ZXJIaW50aW5nXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImRpc2FibGVNb25vc3BhY2VPcHRpbWl6YXRpb25zXCJdID0gMzNdID0gXCJkaXNhYmxlTW9ub3NwYWNlT3B0aW1pemF0aW9uc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkb21SZWFkT25seVwiXSA9IDM0XSA9IFwiZG9tUmVhZE9ubHlcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZHJhZ0FuZERyb3BcIl0gPSAzNV0gPSBcImRyYWdBbmREcm9wXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImRyb3BJbnRvRWRpdG9yXCJdID0gMzZdID0gXCJkcm9wSW50b0VkaXRvclwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJlbXB0eVNlbGVjdGlvbkNsaXBib2FyZFwiXSA9IDM3XSA9IFwiZW1wdHlTZWxlY3Rpb25DbGlwYm9hcmRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZXhwZXJpbWVudGFsV2hpdGVzcGFjZVJlbmRlcmluZ1wiXSA9IDM4XSA9IFwiZXhwZXJpbWVudGFsV2hpdGVzcGFjZVJlbmRlcmluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJleHRyYUVkaXRvckNsYXNzTmFtZVwiXSA9IDM5XSA9IFwiZXh0cmFFZGl0b3JDbGFzc05hbWVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZmFzdFNjcm9sbFNlbnNpdGl2aXR5XCJdID0gNDBdID0gXCJmYXN0U2Nyb2xsU2Vuc2l0aXZpdHlcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZmluZFwiXSA9IDQxXSA9IFwiZmluZFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmaXhlZE92ZXJmbG93V2lkZ2V0c1wiXSA9IDQyXSA9IFwiZml4ZWRPdmVyZmxvd1dpZGdldHNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9sZGluZ1wiXSA9IDQzXSA9IFwiZm9sZGluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb2xkaW5nU3RyYXRlZ3lcIl0gPSA0NF0gPSBcImZvbGRpbmdTdHJhdGVneVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb2xkaW5nSGlnaGxpZ2h0XCJdID0gNDVdID0gXCJmb2xkaW5nSGlnaGxpZ2h0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbGRpbmdJbXBvcnRzQnlEZWZhdWx0XCJdID0gNDZdID0gXCJmb2xkaW5nSW1wb3J0c0J5RGVmYXVsdFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb2xkaW5nTWF4aW11bVJlZ2lvbnNcIl0gPSA0N10gPSBcImZvbGRpbmdNYXhpbXVtUmVnaW9uc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1bmZvbGRPbkNsaWNrQWZ0ZXJFbmRPZkxpbmVcIl0gPSA0OF0gPSBcInVuZm9sZE9uQ2xpY2tBZnRlckVuZE9mTGluZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250RmFtaWx5XCJdID0gNDldID0gXCJmb250RmFtaWx5XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbnRJbmZvXCJdID0gNTBdID0gXCJmb250SW5mb1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250TGlnYXR1cmVzXCJdID0gNTFdID0gXCJmb250TGlnYXR1cmVzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbnRTaXplXCJdID0gNTJdID0gXCJmb250U2l6ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250V2VpZ2h0XCJdID0gNTNdID0gXCJmb250V2VpZ2h0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbnRWYXJpYXRpb25zXCJdID0gNTRdID0gXCJmb250VmFyaWF0aW9uc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb3JtYXRPblBhc3RlXCJdID0gNTVdID0gXCJmb3JtYXRPblBhc3RlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvcm1hdE9uVHlwZVwiXSA9IDU2XSA9IFwiZm9ybWF0T25UeXBlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImdseXBoTWFyZ2luXCJdID0gNTddID0gXCJnbHlwaE1hcmdpblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJnb3RvTG9jYXRpb25cIl0gPSA1OF0gPSBcImdvdG9Mb2NhdGlvblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJoaWRlQ3Vyc29ySW5PdmVydmlld1J1bGVyXCJdID0gNTldID0gXCJoaWRlQ3Vyc29ySW5PdmVydmlld1J1bGVyXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImhvdmVyXCJdID0gNjBdID0gXCJob3ZlclwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJpbkRpZmZFZGl0b3JcIl0gPSA2MV0gPSBcImluRGlmZkVkaXRvclwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJpbmxpbmVTdWdnZXN0XCJdID0gNjJdID0gXCJpbmxpbmVTdWdnZXN0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImlubGluZUVkaXRcIl0gPSA2M10gPSBcImlubGluZUVkaXRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGV0dGVyU3BhY2luZ1wiXSA9IDY0XSA9IFwibGV0dGVyU3BhY2luZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaWdodGJ1bGJcIl0gPSA2NV0gPSBcImxpZ2h0YnVsYlwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaW5lRGVjb3JhdGlvbnNXaWR0aFwiXSA9IDY2XSA9IFwibGluZURlY29yYXRpb25zV2lkdGhcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZUhlaWdodFwiXSA9IDY3XSA9IFwibGluZUhlaWdodFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaW5lTnVtYmVyc1wiXSA9IDY4XSA9IFwibGluZU51bWJlcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZU51bWJlcnNNaW5DaGFyc1wiXSA9IDY5XSA9IFwibGluZU51bWJlcnNNaW5DaGFyc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaW5rZWRFZGl0aW5nXCJdID0gNzBdID0gXCJsaW5rZWRFZGl0aW5nXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxpbmtzXCJdID0gNzFdID0gXCJsaW5rc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtYXRjaEJyYWNrZXRzXCJdID0gNzJdID0gXCJtYXRjaEJyYWNrZXRzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm1pbmltYXBcIl0gPSA3M10gPSBcIm1pbmltYXBcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibW91c2VTdHlsZVwiXSA9IDc0XSA9IFwibW91c2VTdHlsZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtb3VzZVdoZWVsU2Nyb2xsU2Vuc2l0aXZpdHlcIl0gPSA3NV0gPSBcIm1vdXNlV2hlZWxTY3JvbGxTZW5zaXRpdml0eVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtb3VzZVdoZWVsWm9vbVwiXSA9IDc2XSA9IFwibW91c2VXaGVlbFpvb21cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibXVsdGlDdXJzb3JNZXJnZU92ZXJsYXBwaW5nXCJdID0gNzddID0gXCJtdWx0aUN1cnNvck1lcmdlT3ZlcmxhcHBpbmdcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibXVsdGlDdXJzb3JNb2RpZmllclwiXSA9IDc4XSA9IFwibXVsdGlDdXJzb3JNb2RpZmllclwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtdWx0aUN1cnNvclBhc3RlXCJdID0gNzldID0gXCJtdWx0aUN1cnNvclBhc3RlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm11bHRpQ3Vyc29yTGltaXRcIl0gPSA4MF0gPSBcIm11bHRpQ3Vyc29yTGltaXRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wib2NjdXJyZW5jZXNIaWdobGlnaHRcIl0gPSA4MV0gPSBcIm9jY3VycmVuY2VzSGlnaGxpZ2h0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm92ZXJ2aWV3UnVsZXJCb3JkZXJcIl0gPSA4Ml0gPSBcIm92ZXJ2aWV3UnVsZXJCb3JkZXJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wib3ZlcnZpZXdSdWxlckxhbmVzXCJdID0gODNdID0gXCJvdmVydmlld1J1bGVyTGFuZXNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicGFkZGluZ1wiXSA9IDg0XSA9IFwicGFkZGluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJwYXN0ZUFzXCJdID0gODVdID0gXCJwYXN0ZUFzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBhcmFtZXRlckhpbnRzXCJdID0gODZdID0gXCJwYXJhbWV0ZXJIaW50c1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJwZWVrV2lkZ2V0RGVmYXVsdEZvY3VzXCJdID0gODddID0gXCJwZWVrV2lkZ2V0RGVmYXVsdEZvY3VzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBsYWNlaG9sZGVyXCJdID0gODhdID0gXCJwbGFjZWhvbGRlclwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkZWZpbml0aW9uTGlua09wZW5zSW5QZWVrXCJdID0gODldID0gXCJkZWZpbml0aW9uTGlua09wZW5zSW5QZWVrXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInF1aWNrU3VnZ2VzdGlvbnNcIl0gPSA5MF0gPSBcInF1aWNrU3VnZ2VzdGlvbnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicXVpY2tTdWdnZXN0aW9uc0RlbGF5XCJdID0gOTFdID0gXCJxdWlja1N1Z2dlc3Rpb25zRGVsYXlcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVhZE9ubHlcIl0gPSA5Ml0gPSBcInJlYWRPbmx5XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlYWRPbmx5TWVzc2FnZVwiXSA9IDkzXSA9IFwicmVhZE9ubHlNZXNzYWdlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmFtZU9uVHlwZVwiXSA9IDk0XSA9IFwicmVuYW1lT25UeXBlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzXCJdID0gOTVdID0gXCJyZW5kZXJDb250cm9sQ2hhcmFjdGVyc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJGaW5hbE5ld2xpbmVcIl0gPSA5Nl0gPSBcInJlbmRlckZpbmFsTmV3bGluZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJMaW5lSGlnaGxpZ2h0XCJdID0gOTddID0gXCJyZW5kZXJMaW5lSGlnaGxpZ2h0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmRlckxpbmVIaWdobGlnaHRPbmx5V2hlbkZvY3VzXCJdID0gOThdID0gXCJyZW5kZXJMaW5lSGlnaGxpZ2h0T25seVdoZW5Gb2N1c1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJWYWxpZGF0aW9uRGVjb3JhdGlvbnNcIl0gPSA5OV0gPSBcInJlbmRlclZhbGlkYXRpb25EZWNvcmF0aW9uc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJXaGl0ZXNwYWNlXCJdID0gMTAwXSA9IFwicmVuZGVyV2hpdGVzcGFjZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZXZlYWxIb3Jpem9udGFsUmlnaHRQYWRkaW5nXCJdID0gMTAxXSA9IFwicmV2ZWFsSG9yaXpvbnRhbFJpZ2h0UGFkZGluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyb3VuZGVkU2VsZWN0aW9uXCJdID0gMTAyXSA9IFwicm91bmRlZFNlbGVjdGlvblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJydWxlcnNcIl0gPSAxMDNdID0gXCJydWxlcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2Nyb2xsYmFyXCJdID0gMTA0XSA9IFwic2Nyb2xsYmFyXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNjcm9sbEJleW9uZExhc3RDb2x1bW5cIl0gPSAxMDVdID0gXCJzY3JvbGxCZXlvbmRMYXN0Q29sdW1uXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNjcm9sbEJleW9uZExhc3RMaW5lXCJdID0gMTA2XSA9IFwic2Nyb2xsQmV5b25kTGFzdExpbmVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2Nyb2xsUHJlZG9taW5hbnRBeGlzXCJdID0gMTA3XSA9IFwic2Nyb2xsUHJlZG9taW5hbnRBeGlzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNlbGVjdGlvbkNsaXBib2FyZFwiXSA9IDEwOF0gPSBcInNlbGVjdGlvbkNsaXBib2FyZFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzZWxlY3Rpb25IaWdobGlnaHRcIl0gPSAxMDldID0gXCJzZWxlY3Rpb25IaWdobGlnaHRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2VsZWN0T25MaW5lTnVtYmVyc1wiXSA9IDExMF0gPSBcInNlbGVjdE9uTGluZU51bWJlcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2hvd0ZvbGRpbmdDb250cm9sc1wiXSA9IDExMV0gPSBcInNob3dGb2xkaW5nQ29udHJvbHNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2hvd1VudXNlZFwiXSA9IDExMl0gPSBcInNob3dVbnVzZWRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic25pcHBldFN1Z2dlc3Rpb25zXCJdID0gMTEzXSA9IFwic25pcHBldFN1Z2dlc3Rpb25zXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNtYXJ0U2VsZWN0XCJdID0gMTE0XSA9IFwic21hcnRTZWxlY3RcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic21vb3RoU2Nyb2xsaW5nXCJdID0gMTE1XSA9IFwic21vb3RoU2Nyb2xsaW5nXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN0aWNreVNjcm9sbFwiXSA9IDExNl0gPSBcInN0aWNreVNjcm9sbFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdGlja3lUYWJTdG9wc1wiXSA9IDExN10gPSBcInN0aWNreVRhYlN0b3BzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN0b3BSZW5kZXJpbmdMaW5lQWZ0ZXJcIl0gPSAxMThdID0gXCJzdG9wUmVuZGVyaW5nTGluZUFmdGVyXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN1Z2dlc3RcIl0gPSAxMTldID0gXCJzdWdnZXN0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN1Z2dlc3RGb250U2l6ZVwiXSA9IDEyMF0gPSBcInN1Z2dlc3RGb250U2l6ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdWdnZXN0TGluZUhlaWdodFwiXSA9IDEyMV0gPSBcInN1Z2dlc3RMaW5lSGVpZ2h0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN1Z2dlc3RPblRyaWdnZXJDaGFyYWN0ZXJzXCJdID0gMTIyXSA9IFwic3VnZ2VzdE9uVHJpZ2dlckNoYXJhY3RlcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3VnZ2VzdFNlbGVjdGlvblwiXSA9IDEyM10gPSBcInN1Z2dlc3RTZWxlY3Rpb25cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widGFiQ29tcGxldGlvblwiXSA9IDEyNF0gPSBcInRhYkNvbXBsZXRpb25cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widGFiSW5kZXhcIl0gPSAxMjVdID0gXCJ0YWJJbmRleFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1bmljb2RlSGlnaGxpZ2h0aW5nXCJdID0gMTI2XSA9IFwidW5pY29kZUhpZ2hsaWdodGluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1bnVzdWFsTGluZVRlcm1pbmF0b3JzXCJdID0gMTI3XSA9IFwidW51c3VhbExpbmVUZXJtaW5hdG9yc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1c2VTaGFkb3dET01cIl0gPSAxMjhdID0gXCJ1c2VTaGFkb3dET01cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widXNlVGFiU3RvcHNcIl0gPSAxMjldID0gXCJ1c2VUYWJTdG9wc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkQnJlYWtcIl0gPSAxMzBdID0gXCJ3b3JkQnJlYWtcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFNlZ21lbnRlckxvY2FsZXNcIl0gPSAxMzFdID0gXCJ3b3JkU2VnbWVudGVyTG9jYWxlc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkU2VwYXJhdG9yc1wiXSA9IDEzMl0gPSBcIndvcmRTZXBhcmF0b3JzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRXcmFwXCJdID0gMTMzXSA9IFwid29yZFdyYXBcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBCcmVha0FmdGVyQ2hhcmFjdGVyc1wiXSA9IDEzNF0gPSBcIndvcmRXcmFwQnJlYWtBZnRlckNoYXJhY3RlcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBCcmVha0JlZm9yZUNoYXJhY3RlcnNcIl0gPSAxMzVdID0gXCJ3b3JkV3JhcEJyZWFrQmVmb3JlQ2hhcmFjdGVyc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkV3JhcENvbHVtblwiXSA9IDEzNl0gPSBcIndvcmRXcmFwQ29sdW1uXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRXcmFwT3ZlcnJpZGUxXCJdID0gMTM3XSA9IFwid29yZFdyYXBPdmVycmlkZTFcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBPdmVycmlkZTJcIl0gPSAxMzhdID0gXCJ3b3JkV3JhcE92ZXJyaWRlMlwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3cmFwcGluZ0luZGVudFwiXSA9IDEzOV0gPSBcIndyYXBwaW5nSW5kZW50XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndyYXBwaW5nU3RyYXRlZ3lcIl0gPSAxNDBdID0gXCJ3cmFwcGluZ1N0cmF0ZWd5XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNob3dEZXByZWNhdGVkXCJdID0gMTQxXSA9IFwic2hvd0RlcHJlY2F0ZWRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaW5sYXlIaW50c1wiXSA9IDE0Ml0gPSBcImlubGF5SGludHNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZWRpdG9yQ2xhc3NOYW1lXCJdID0gMTQzXSA9IFwiZWRpdG9yQ2xhc3NOYW1lXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBpeGVsUmF0aW9cIl0gPSAxNDRdID0gXCJwaXhlbFJhdGlvXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInRhYkZvY3VzTW9kZVwiXSA9IDE0NV0gPSBcInRhYkZvY3VzTW9kZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsYXlvdXRJbmZvXCJdID0gMTQ2XSA9IFwibGF5b3V0SW5mb1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3cmFwcGluZ0luZm9cIl0gPSAxNDddID0gXCJ3cmFwcGluZ0luZm9cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZGVmYXVsdENvbG9yRGVjb3JhdG9yc1wiXSA9IDE0OF0gPSBcImRlZmF1bHRDb2xvckRlY29yYXRvcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29sb3JEZWNvcmF0b3JzQWN0aXZhdGVkT25cIl0gPSAxNDldID0gXCJjb2xvckRlY29yYXRvcnNBY3RpdmF0ZWRPblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJpbmxpbmVDb21wbGV0aW9uc0FjY2Vzc2liaWxpdHlWZXJib3NlXCJdID0gMTUwXSA9IFwiaW5saW5lQ29tcGxldGlvbnNBY2Nlc3NpYmlsaXR5VmVyYm9zZVwiO1xufSkoRWRpdG9yT3B0aW9uIHx8IChFZGl0b3JPcHRpb24gPSB7fSkpO1xuLyoqXG4gKiBFbmQgb2YgbGluZSBjaGFyYWN0ZXIgcHJlZmVyZW5jZS5cbiAqL1xuZXhwb3J0IHZhciBFbmRPZkxpbmVQcmVmZXJlbmNlO1xuKGZ1bmN0aW9uIChFbmRPZkxpbmVQcmVmZXJlbmNlKSB7XG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIgaWRlbnRpZmllZCBpbiB0aGUgdGV4dCBidWZmZXIuXG4gICAgICovXG4gICAgRW5kT2ZMaW5lUHJlZmVyZW5jZVtFbmRPZkxpbmVQcmVmZXJlbmNlW1wiVGV4dERlZmluZWRcIl0gPSAwXSA9IFwiVGV4dERlZmluZWRcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgbGluZSBmZWVkIChcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgRW5kT2ZMaW5lUHJlZmVyZW5jZVtFbmRPZkxpbmVQcmVmZXJlbmNlW1wiTEZcIl0gPSAxXSA9IFwiTEZcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgY2FycmlhZ2UgcmV0dXJuIGFuZCBsaW5lIGZlZWQgKFxcclxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBFbmRPZkxpbmVQcmVmZXJlbmNlW0VuZE9mTGluZVByZWZlcmVuY2VbXCJDUkxGXCJdID0gMl0gPSBcIkNSTEZcIjtcbn0pKEVuZE9mTGluZVByZWZlcmVuY2UgfHwgKEVuZE9mTGluZVByZWZlcmVuY2UgPSB7fSkpO1xuLyoqXG4gKiBFbmQgb2YgbGluZSBjaGFyYWN0ZXIgcHJlZmVyZW5jZS5cbiAqL1xuZXhwb3J0IHZhciBFbmRPZkxpbmVTZXF1ZW5jZTtcbihmdW5jdGlvbiAoRW5kT2ZMaW5lU2VxdWVuY2UpIHtcbiAgICAvKipcbiAgICAgKiBVc2UgbGluZSBmZWVkIChcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgRW5kT2ZMaW5lU2VxdWVuY2VbRW5kT2ZMaW5lU2VxdWVuY2VbXCJMRlwiXSA9IDBdID0gXCJMRlwiO1xuICAgIC8qKlxuICAgICAqIFVzZSBjYXJyaWFnZSByZXR1cm4gYW5kIGxpbmUgZmVlZCAoXFxyXFxuKSBhcyB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIEVuZE9mTGluZVNlcXVlbmNlW0VuZE9mTGluZVNlcXVlbmNlW1wiQ1JMRlwiXSA9IDFdID0gXCJDUkxGXCI7XG59KShFbmRPZkxpbmVTZXF1ZW5jZSB8fCAoRW5kT2ZMaW5lU2VxdWVuY2UgPSB7fSkpO1xuLyoqXG4gKiBWZXJ0aWNhbCBMYW5lIGluIHRoZSBnbHlwaCBtYXJnaW4gb2YgdGhlIGVkaXRvci5cbiAqL1xuZXhwb3J0IHZhciBHbHlwaE1hcmdpbkxhbmU7XG4oZnVuY3Rpb24gKEdseXBoTWFyZ2luTGFuZSkge1xuICAgIEdseXBoTWFyZ2luTGFuZVtHbHlwaE1hcmdpbkxhbmVbXCJMZWZ0XCJdID0gMV0gPSBcIkxlZnRcIjtcbiAgICBHbHlwaE1hcmdpbkxhbmVbR2x5cGhNYXJnaW5MYW5lW1wiQ2VudGVyXCJdID0gMl0gPSBcIkNlbnRlclwiO1xuICAgIEdseXBoTWFyZ2luTGFuZVtHbHlwaE1hcmdpbkxhbmVbXCJSaWdodFwiXSA9IDNdID0gXCJSaWdodFwiO1xufSkoR2x5cGhNYXJnaW5MYW5lIHx8IChHbHlwaE1hcmdpbkxhbmUgPSB7fSkpO1xuZXhwb3J0IHZhciBIb3ZlclZlcmJvc2l0eUFjdGlvbjtcbihmdW5jdGlvbiAoSG92ZXJWZXJib3NpdHlBY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBJbmNyZWFzZSB0aGUgdmVyYm9zaXR5IG9mIHRoZSBob3ZlclxuICAgICAqL1xuICAgIEhvdmVyVmVyYm9zaXR5QWN0aW9uW0hvdmVyVmVyYm9zaXR5QWN0aW9uW1wiSW5jcmVhc2VcIl0gPSAwXSA9IFwiSW5jcmVhc2VcIjtcbiAgICAvKipcbiAgICAgKiBEZWNyZWFzZSB0aGUgdmVyYm9zaXR5IG9mIHRoZSBob3ZlclxuICAgICAqL1xuICAgIEhvdmVyVmVyYm9zaXR5QWN0aW9uW0hvdmVyVmVyYm9zaXR5QWN0aW9uW1wiRGVjcmVhc2VcIl0gPSAxXSA9IFwiRGVjcmVhc2VcIjtcbn0pKEhvdmVyVmVyYm9zaXR5QWN0aW9uIHx8IChIb3ZlclZlcmJvc2l0eUFjdGlvbiA9IHt9KSk7XG4vKipcbiAqIERlc2NyaWJlcyB3aGF0IHRvIGRvIHdpdGggdGhlIGluZGVudGF0aW9uIHdoZW4gcHJlc3NpbmcgRW50ZXIuXG4gKi9cbmV4cG9ydCB2YXIgSW5kZW50QWN0aW9uO1xuKGZ1bmN0aW9uIChJbmRlbnRBY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgbmV3IGxpbmUgYW5kIGNvcHkgdGhlIHByZXZpb3VzIGxpbmUncyBpbmRlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBJbmRlbnRBY3Rpb25bSW5kZW50QWN0aW9uW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IG5ldyBsaW5lIGFuZCBpbmRlbnQgb25jZSAocmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIGxpbmUncyBpbmRlbnRhdGlvbikuXG4gICAgICovXG4gICAgSW5kZW50QWN0aW9uW0luZGVudEFjdGlvbltcIkluZGVudFwiXSA9IDFdID0gXCJJbmRlbnRcIjtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgdHdvIG5ldyBsaW5lczpcbiAgICAgKiAgLSB0aGUgZmlyc3Qgb25lIGluZGVudGVkIHdoaWNoIHdpbGwgaG9sZCB0aGUgY3Vyc29yXG4gICAgICogIC0gdGhlIHNlY29uZCBvbmUgYXQgdGhlIHNhbWUgaW5kZW50YXRpb24gbGV2ZWxcbiAgICAgKi9cbiAgICBJbmRlbnRBY3Rpb25bSW5kZW50QWN0aW9uW1wiSW5kZW50T3V0ZGVudFwiXSA9IDJdID0gXCJJbmRlbnRPdXRkZW50XCI7XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IG5ldyBsaW5lIGFuZCBvdXRkZW50IG9uY2UgKHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBsaW5lJ3MgaW5kZW50YXRpb24pLlxuICAgICAqL1xuICAgIEluZGVudEFjdGlvbltJbmRlbnRBY3Rpb25bXCJPdXRkZW50XCJdID0gM10gPSBcIk91dGRlbnRcIjtcbn0pKEluZGVudEFjdGlvbiB8fCAoSW5kZW50QWN0aW9uID0ge30pKTtcbmV4cG9ydCB2YXIgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHM7XG4oZnVuY3Rpb24gKEluamVjdGVkVGV4dEN1cnNvclN0b3BzKSB7XG4gICAgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbXCJCb3RoXCJdID0gMF0gPSBcIkJvdGhcIjtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIlJpZ2h0XCJdID0gMV0gPSBcIlJpZ2h0XCI7XG4gICAgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbXCJMZWZ0XCJdID0gMl0gPSBcIkxlZnRcIjtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIk5vbmVcIl0gPSAzXSA9IFwiTm9uZVwiO1xufSkoSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHMgfHwgKEluamVjdGVkVGV4dEN1cnNvclN0b3BzID0ge30pKTtcbmV4cG9ydCB2YXIgSW5sYXlIaW50S2luZDtcbihmdW5jdGlvbiAoSW5sYXlIaW50S2luZCkge1xuICAgIElubGF5SGludEtpbmRbSW5sYXlIaW50S2luZFtcIlR5cGVcIl0gPSAxXSA9IFwiVHlwZVwiO1xuICAgIElubGF5SGludEtpbmRbSW5sYXlIaW50S2luZFtcIlBhcmFtZXRlclwiXSA9IDJdID0gXCJQYXJhbWV0ZXJcIjtcbn0pKElubGF5SGludEtpbmQgfHwgKElubGF5SGludEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBIb3cgYW4ge0BsaW5rIElubGluZUNvbXBsZXRpb25zUHJvdmlkZXIgaW5saW5lIGNvbXBsZXRpb24gcHJvdmlkZXJ9IHdhcyB0cmlnZ2VyZWQuXG4gKi9cbmV4cG9ydCB2YXIgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB3aGlsZSBlZGl0aW5nLlxuICAgICAqIEl0IGlzIHN1ZmZpY2llbnQgdG8gcmV0dXJuIGEgc2luZ2xlIGNvbXBsZXRpb24gaXRlbSBpbiB0aGlzIGNhc2UuXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW0lubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtcIkF1dG9tYXRpY1wiXSA9IDBdID0gXCJBdXRvbWF0aWNcIjtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgZXhwbGljaXRseSBieSBhIHVzZXIgZ2VzdHVyZS5cbiAgICAgKiBSZXR1cm4gbXVsdGlwbGUgY29tcGxldGlvbiBpdGVtcyB0byBlbmFibGUgY3ljbGluZyB0aHJvdWdoIHRoZW0uXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW0lubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtcIkV4cGxpY2l0XCJdID0gMV0gPSBcIkV4cGxpY2l0XCI7XG59KShJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IHt9KSk7XG5leHBvcnQgdmFyIElubGluZUVkaXRUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoSW5saW5lRWRpdFRyaWdnZXJLaW5kKSB7XG4gICAgSW5saW5lRWRpdFRyaWdnZXJLaW5kW0lubGluZUVkaXRUcmlnZ2VyS2luZFtcIkludm9rZVwiXSA9IDBdID0gXCJJbnZva2VcIjtcbiAgICBJbmxpbmVFZGl0VHJpZ2dlcktpbmRbSW5saW5lRWRpdFRyaWdnZXJLaW5kW1wiQXV0b21hdGljXCJdID0gMV0gPSBcIkF1dG9tYXRpY1wiO1xufSkoSW5saW5lRWRpdFRyaWdnZXJLaW5kIHx8IChJbmxpbmVFZGl0VHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBWaXJ0dWFsIEtleSBDb2RlcywgdGhlIHZhbHVlIGRvZXMgbm90IGhvbGQgYW55IGluaGVyZW50IG1lYW5pbmcuXG4gKiBJbnNwaXJlZCBzb21ld2hhdCBmcm9tIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2RkMzc1NzMxKHY9dnMuODUpLmFzcHhcbiAqIEJ1dCB0aGVzZSBhcmUgXCJtb3JlIGdlbmVyYWxcIiwgYXMgdGhleSBzaG91bGQgd29yayBhY3Jvc3MgYnJvd3NlcnMgJiBPU2BzLlxuICovXG5leHBvcnQgdmFyIEtleUNvZGU7XG4oZnVuY3Rpb24gKEtleUNvZGUpIHtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEZXBlbmRzT25LYkxheW91dFwiXSA9IC0xXSA9IFwiRGVwZW5kc09uS2JMYXlvdXRcIjtcbiAgICAvKipcbiAgICAgKiBQbGFjZWQgZmlyc3QgdG8gY292ZXIgdGhlIDAgdmFsdWUgb2YgdGhlIGVudW0uXG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVW5rbm93blwiXSA9IDBdID0gXCJVbmtub3duXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQmFja3NwYWNlXCJdID0gMV0gPSBcIkJhY2tzcGFjZVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlRhYlwiXSA9IDJdID0gXCJUYWJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJFbnRlclwiXSA9IDNdID0gXCJFbnRlclwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNoaWZ0XCJdID0gNF0gPSBcIlNoaWZ0XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQ3RybFwiXSA9IDVdID0gXCJDdHJsXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQWx0XCJdID0gNl0gPSBcIkFsdFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlBhdXNlQnJlYWtcIl0gPSA3XSA9IFwiUGF1c2VCcmVha1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkNhcHNMb2NrXCJdID0gOF0gPSBcIkNhcHNMb2NrXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRXNjYXBlXCJdID0gOV0gPSBcIkVzY2FwZVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNwYWNlXCJdID0gMTBdID0gXCJTcGFjZVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlBhZ2VVcFwiXSA9IDExXSA9IFwiUGFnZVVwXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUGFnZURvd25cIl0gPSAxMl0gPSBcIlBhZ2VEb3duXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRW5kXCJdID0gMTNdID0gXCJFbmRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJIb21lXCJdID0gMTRdID0gXCJIb21lXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTGVmdEFycm93XCJdID0gMTVdID0gXCJMZWZ0QXJyb3dcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVcEFycm93XCJdID0gMTZdID0gXCJVcEFycm93XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUmlnaHRBcnJvd1wiXSA9IDE3XSA9IFwiUmlnaHRBcnJvd1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRvd25BcnJvd1wiXSA9IDE4XSA9IFwiRG93bkFycm93XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiSW5zZXJ0XCJdID0gMTldID0gXCJJbnNlcnRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEZWxldGVcIl0gPSAyMF0gPSBcIkRlbGV0ZVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0MFwiXSA9IDIxXSA9IFwiRGlnaXQwXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQxXCJdID0gMjJdID0gXCJEaWdpdDFcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDJcIl0gPSAyM10gPSBcIkRpZ2l0MlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0M1wiXSA9IDI0XSA9IFwiRGlnaXQzXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQ0XCJdID0gMjVdID0gXCJEaWdpdDRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDVcIl0gPSAyNl0gPSBcIkRpZ2l0NVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0NlwiXSA9IDI3XSA9IFwiRGlnaXQ2XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQ3XCJdID0gMjhdID0gXCJEaWdpdDdcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDhcIl0gPSAyOV0gPSBcIkRpZ2l0OFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0OVwiXSA9IDMwXSA9IFwiRGlnaXQ5XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5QVwiXSA9IDMxXSA9IFwiS2V5QVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleUJcIl0gPSAzMl0gPSBcIktleUJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlDXCJdID0gMzNdID0gXCJLZXlDXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5RFwiXSA9IDM0XSA9IFwiS2V5RFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleUVcIl0gPSAzNV0gPSBcIktleUVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlGXCJdID0gMzZdID0gXCJLZXlGXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5R1wiXSA9IDM3XSA9IFwiS2V5R1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleUhcIl0gPSAzOF0gPSBcIktleUhcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlJXCJdID0gMzldID0gXCJLZXlJXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5SlwiXSA9IDQwXSA9IFwiS2V5SlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleUtcIl0gPSA0MV0gPSBcIktleUtcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlMXCJdID0gNDJdID0gXCJLZXlMXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5TVwiXSA9IDQzXSA9IFwiS2V5TVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleU5cIl0gPSA0NF0gPSBcIktleU5cIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlPXCJdID0gNDVdID0gXCJLZXlPXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5UFwiXSA9IDQ2XSA9IFwiS2V5UFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleVFcIl0gPSA0N10gPSBcIktleVFcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlSXCJdID0gNDhdID0gXCJLZXlSXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5U1wiXSA9IDQ5XSA9IFwiS2V5U1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleVRcIl0gPSA1MF0gPSBcIktleVRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlVXCJdID0gNTFdID0gXCJLZXlVXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5VlwiXSA9IDUyXSA9IFwiS2V5VlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleVdcIl0gPSA1M10gPSBcIktleVdcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlYXCJdID0gNTRdID0gXCJLZXlYXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5WVwiXSA9IDU1XSA9IFwiS2V5WVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleVpcIl0gPSA1Nl0gPSBcIktleVpcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJNZXRhXCJdID0gNTddID0gXCJNZXRhXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQ29udGV4dE1lbnVcIl0gPSA1OF0gPSBcIkNvbnRleHRNZW51XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjFcIl0gPSA1OV0gPSBcIkYxXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjJcIl0gPSA2MF0gPSBcIkYyXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjNcIl0gPSA2MV0gPSBcIkYzXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjRcIl0gPSA2Ml0gPSBcIkY0XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjVcIl0gPSA2M10gPSBcIkY1XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjZcIl0gPSA2NF0gPSBcIkY2XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjdcIl0gPSA2NV0gPSBcIkY3XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjhcIl0gPSA2Nl0gPSBcIkY4XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjlcIl0gPSA2N10gPSBcIkY5XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjEwXCJdID0gNjhdID0gXCJGMTBcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTFcIl0gPSA2OV0gPSBcIkYxMVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxMlwiXSA9IDcwXSA9IFwiRjEyXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjEzXCJdID0gNzFdID0gXCJGMTNcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTRcIl0gPSA3Ml0gPSBcIkYxNFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxNVwiXSA9IDczXSA9IFwiRjE1XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE2XCJdID0gNzRdID0gXCJGMTZcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTdcIl0gPSA3NV0gPSBcIkYxN1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxOFwiXSA9IDc2XSA9IFwiRjE4XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE5XCJdID0gNzddID0gXCJGMTlcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMjBcIl0gPSA3OF0gPSBcIkYyMFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYyMVwiXSA9IDc5XSA9IFwiRjIxXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjIyXCJdID0gODBdID0gXCJGMjJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMjNcIl0gPSA4MV0gPSBcIkYyM1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYyNFwiXSA9IDgyXSA9IFwiRjI0XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtTG9ja1wiXSA9IDgzXSA9IFwiTnVtTG9ja1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNjcm9sbExvY2tcIl0gPSA4NF0gPSBcIlNjcm9sbExvY2tcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnOzonIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNlbWljb2xvblwiXSA9IDg1XSA9IFwiU2VtaWNvbG9uXCI7XG4gICAgLyoqXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcrJyBrZXlcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJz0rJyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJFcXVhbFwiXSA9IDg2XSA9IFwiRXF1YWxcIjtcbiAgICAvKipcbiAgICAgKiBGb3IgYW55IGNvdW50cnkvcmVnaW9uLCB0aGUgJywnIGtleVxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnLDwnIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkNvbW1hXCJdID0gODddID0gXCJDb21tYVwiO1xuICAgIC8qKlxuICAgICAqIEZvciBhbnkgY291bnRyeS9yZWdpb24sIHRoZSAnLScga2V5XG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICctXycga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTWludXNcIl0gPSA4OF0gPSBcIk1pbnVzXCI7XG4gICAgLyoqXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcuJyBrZXlcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJy4+JyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJQZXJpb2RcIl0gPSA4OV0gPSBcIlBlcmlvZFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICcvPycga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiU2xhc2hcIl0gPSA5MF0gPSBcIlNsYXNoXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJ2B+JyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCYWNrcXVvdGVcIl0gPSA5MV0gPSBcIkJhY2txdW90ZVwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICdbeycga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJhY2tldExlZnRcIl0gPSA5Ml0gPSBcIkJyYWNrZXRMZWZ0XCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJ1xcfCcga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQmFja3NsYXNoXCJdID0gOTNdID0gXCJCYWNrc2xhc2hcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnXX0nIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkJyYWNrZXRSaWdodFwiXSA9IDk0XSA9IFwiQnJhY2tldFJpZ2h0XCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJydcIicga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUXVvdGVcIl0gPSA5NV0gPSBcIlF1b3RlXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJPRU1fOFwiXSA9IDk2XSA9IFwiT0VNXzhcIjtcbiAgICAvKipcbiAgICAgKiBFaXRoZXIgdGhlIGFuZ2xlIGJyYWNrZXQga2V5IG9yIHRoZSBiYWNrc2xhc2gga2V5IG9uIHRoZSBSVCAxMDIta2V5IGtleWJvYXJkLlxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkludGxCYWNrc2xhc2hcIl0gPSA5N10gPSBcIkludGxCYWNrc2xhc2hcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQwXCJdID0gOThdID0gXCJOdW1wYWQwXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkMVwiXSA9IDk5XSA9IFwiTnVtcGFkMVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZDJcIl0gPSAxMDBdID0gXCJOdW1wYWQyXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkM1wiXSA9IDEwMV0gPSBcIk51bXBhZDNcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQ0XCJdID0gMTAyXSA9IFwiTnVtcGFkNFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZDVcIl0gPSAxMDNdID0gXCJOdW1wYWQ1XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkNlwiXSA9IDEwNF0gPSBcIk51bXBhZDZcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQ3XCJdID0gMTA1XSA9IFwiTnVtcGFkN1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZDhcIl0gPSAxMDZdID0gXCJOdW1wYWQ4XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkOVwiXSA9IDEwN10gPSBcIk51bXBhZDlcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWRNdWx0aXBseVwiXSA9IDEwOF0gPSBcIk51bXBhZE11bHRpcGx5XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkQWRkXCJdID0gMTA5XSA9IFwiTnVtcGFkQWRkXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEX1NFUEFSQVRPUlwiXSA9IDExMF0gPSBcIk5VTVBBRF9TRVBBUkFUT1JcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWRTdWJ0cmFjdFwiXSA9IDExMV0gPSBcIk51bXBhZFN1YnRyYWN0XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkRGVjaW1hbFwiXSA9IDExMl0gPSBcIk51bXBhZERlY2ltYWxcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWREaXZpZGVcIl0gPSAxMTNdID0gXCJOdW1wYWREaXZpZGVcIjtcbiAgICAvKipcbiAgICAgKiBDb3ZlciBhbGwga2V5IGNvZGVzIHdoZW4gSU1FIGlzIHByb2Nlc3NpbmcgaW5wdXQuXG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0lOX0NPTVBPU0lUSU9OXCJdID0gMTE0XSA9IFwiS0VZX0lOX0NPTVBPU0lUSU9OXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQUJOVF9DMVwiXSA9IDExNV0gPSBcIkFCTlRfQzFcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJBQk5UX0MyXCJdID0gMTE2XSA9IFwiQUJOVF9DMlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkF1ZGlvVm9sdW1lTXV0ZVwiXSA9IDExN10gPSBcIkF1ZGlvVm9sdW1lTXV0ZVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkF1ZGlvVm9sdW1lVXBcIl0gPSAxMThdID0gXCJBdWRpb1ZvbHVtZVVwXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQXVkaW9Wb2x1bWVEb3duXCJdID0gMTE5XSA9IFwiQXVkaW9Wb2x1bWVEb3duXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJvd3NlclNlYXJjaFwiXSA9IDEyMF0gPSBcIkJyb3dzZXJTZWFyY2hcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCcm93c2VySG9tZVwiXSA9IDEyMV0gPSBcIkJyb3dzZXJIb21lXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJvd3NlckJhY2tcIl0gPSAxMjJdID0gXCJCcm93c2VyQmFja1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkJyb3dzZXJGb3J3YXJkXCJdID0gMTIzXSA9IFwiQnJvd3NlckZvcndhcmRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJNZWRpYVRyYWNrTmV4dFwiXSA9IDEyNF0gPSBcIk1lZGlhVHJhY2tOZXh0XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTWVkaWFUcmFja1ByZXZpb3VzXCJdID0gMTI1XSA9IFwiTWVkaWFUcmFja1ByZXZpb3VzXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTWVkaWFTdG9wXCJdID0gMTI2XSA9IFwiTWVkaWFTdG9wXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTWVkaWFQbGF5UGF1c2VcIl0gPSAxMjddID0gXCJNZWRpYVBsYXlQYXVzZVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkxhdW5jaE1lZGlhUGxheWVyXCJdID0gMTI4XSA9IFwiTGF1bmNoTWVkaWFQbGF5ZXJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJMYXVuY2hNYWlsXCJdID0gMTI5XSA9IFwiTGF1bmNoTWFpbFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkxhdW5jaEFwcDJcIl0gPSAxMzBdID0gXCJMYXVuY2hBcHAyXCI7XG4gICAgLyoqXG4gICAgICogVktfQ0xFQVIsIDB4MEMsIENMRUFSIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkNsZWFyXCJdID0gMTMxXSA9IFwiQ2xlYXJcIjtcbiAgICAvKipcbiAgICAgKiBQbGFjZWQgbGFzdCB0byBjb3ZlciB0aGUgbGVuZ3RoIG9mIHRoZSBlbnVtLlxuICAgICAqIFBsZWFzZSBkbyBub3QgZGVwZW5kIG9uIHRoaXMgdmFsdWUhXG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTUFYX1ZBTFVFXCJdID0gMTMyXSA9IFwiTUFYX1ZBTFVFXCI7XG59KShLZXlDb2RlIHx8IChLZXlDb2RlID0ge30pKTtcbmV4cG9ydCB2YXIgTWFya2VyU2V2ZXJpdHk7XG4oZnVuY3Rpb24gKE1hcmtlclNldmVyaXR5KSB7XG4gICAgTWFya2VyU2V2ZXJpdHlbTWFya2VyU2V2ZXJpdHlbXCJIaW50XCJdID0gMV0gPSBcIkhpbnRcIjtcbiAgICBNYXJrZXJTZXZlcml0eVtNYXJrZXJTZXZlcml0eVtcIkluZm9cIl0gPSAyXSA9IFwiSW5mb1wiO1xuICAgIE1hcmtlclNldmVyaXR5W01hcmtlclNldmVyaXR5W1wiV2FybmluZ1wiXSA9IDRdID0gXCJXYXJuaW5nXCI7XG4gICAgTWFya2VyU2V2ZXJpdHlbTWFya2VyU2V2ZXJpdHlbXCJFcnJvclwiXSA9IDhdID0gXCJFcnJvclwiO1xufSkoTWFya2VyU2V2ZXJpdHkgfHwgKE1hcmtlclNldmVyaXR5ID0ge30pKTtcbmV4cG9ydCB2YXIgTWFya2VyVGFnO1xuKGZ1bmN0aW9uIChNYXJrZXJUYWcpIHtcbiAgICBNYXJrZXJUYWdbTWFya2VyVGFnW1wiVW5uZWNlc3NhcnlcIl0gPSAxXSA9IFwiVW5uZWNlc3NhcnlcIjtcbiAgICBNYXJrZXJUYWdbTWFya2VyVGFnW1wiRGVwcmVjYXRlZFwiXSA9IDJdID0gXCJEZXByZWNhdGVkXCI7XG59KShNYXJrZXJUYWcgfHwgKE1hcmtlclRhZyA9IHt9KSk7XG4vKipcbiAqIFBvc2l0aW9uIGluIHRoZSBtaW5pbWFwIHRvIHJlbmRlciB0aGUgZGVjb3JhdGlvbi5cbiAqL1xuZXhwb3J0IHZhciBNaW5pbWFwUG9zaXRpb247XG4oZnVuY3Rpb24gKE1pbmltYXBQb3NpdGlvbikge1xuICAgIE1pbmltYXBQb3NpdGlvbltNaW5pbWFwUG9zaXRpb25bXCJJbmxpbmVcIl0gPSAxXSA9IFwiSW5saW5lXCI7XG4gICAgTWluaW1hcFBvc2l0aW9uW01pbmltYXBQb3NpdGlvbltcIkd1dHRlclwiXSA9IDJdID0gXCJHdXR0ZXJcIjtcbn0pKE1pbmltYXBQb3NpdGlvbiB8fCAoTWluaW1hcFBvc2l0aW9uID0ge30pKTtcbi8qKlxuICogU2VjdGlvbiBoZWFkZXIgc3R5bGUuXG4gKi9cbmV4cG9ydCB2YXIgTWluaW1hcFNlY3Rpb25IZWFkZXJTdHlsZTtcbihmdW5jdGlvbiAoTWluaW1hcFNlY3Rpb25IZWFkZXJTdHlsZSkge1xuICAgIE1pbmltYXBTZWN0aW9uSGVhZGVyU3R5bGVbTWluaW1hcFNlY3Rpb25IZWFkZXJTdHlsZVtcIk5vcm1hbFwiXSA9IDFdID0gXCJOb3JtYWxcIjtcbiAgICBNaW5pbWFwU2VjdGlvbkhlYWRlclN0eWxlW01pbmltYXBTZWN0aW9uSGVhZGVyU3R5bGVbXCJVbmRlcmxpbmVkXCJdID0gMl0gPSBcIlVuZGVybGluZWRcIjtcbn0pKE1pbmltYXBTZWN0aW9uSGVhZGVyU3R5bGUgfHwgKE1pbmltYXBTZWN0aW9uSGVhZGVyU3R5bGUgPSB7fSkpO1xuLyoqXG4gKiBUeXBlIG9mIGhpdCBlbGVtZW50IHdpdGggdGhlIG1vdXNlIGluIHRoZSBlZGl0b3IuXG4gKi9cbmV4cG9ydCB2YXIgTW91c2VUYXJnZXRUeXBlO1xuKGZ1bmN0aW9uIChNb3VzZVRhcmdldFR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgYW4gdW5rbm93biBlbGVtZW50LlxuICAgICAqL1xuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJVTktOT1dOXCJdID0gMF0gPSBcIlVOS05PV05cIjtcbiAgICAvKipcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGhlIHRleHRhcmVhIHVzZWQgZm9yIGlucHV0LlxuICAgICAqL1xuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJURVhUQVJFQVwiXSA9IDFdID0gXCJURVhUQVJFQVwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgZ2x5cGggbWFyZ2luXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkdVVFRFUl9HTFlQSF9NQVJHSU5cIl0gPSAyXSA9IFwiR1VUVEVSX0dMWVBIX01BUkdJTlwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgbGluZSBudW1iZXJzXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkdVVFRFUl9MSU5FX05VTUJFUlNcIl0gPSAzXSA9IFwiR1VUVEVSX0xJTkVfTlVNQkVSU1wiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgbGluZSBkZWNvcmF0aW9uc1xuICAgICAqL1xuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJHVVRURVJfTElORV9ERUNPUkFUSU9OU1wiXSA9IDRdID0gXCJHVVRURVJfTElORV9ERUNPUkFUSU9OU1wiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgd2hpdGVzcGFjZSBsZWZ0IGluIHRoZSBndXR0ZXIgYnkgYSB2aWV3IHpvbmUuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkdVVFRFUl9WSUVXX1pPTkVcIl0gPSA1XSA9IFwiR1VUVEVSX1ZJRVdfWk9ORVwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0ZXh0IGluIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJDT05URU5UX1RFWFRcIl0gPSA2XSA9IFwiQ09OVEVOVF9URVhUXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGVtcHR5IHNwYWNlIGluIHRoZSBjb250ZW50IChlLmcuIGFmdGVyIGxpbmUgdGV4dCBvciBiZWxvdyBsYXN0IGxpbmUpXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkNPTlRFTlRfRU1QVFlcIl0gPSA3XSA9IFwiQ09OVEVOVF9FTVBUWVwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiBhIHZpZXcgem9uZSBpbiB0aGUgY29udGVudC5cbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiQ09OVEVOVF9WSUVXX1pPTkVcIl0gPSA4XSA9IFwiQ09OVEVOVF9WSUVXX1pPTkVcIjtcbiAgICAvKipcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgYSBjb250ZW50IHdpZGdldC5cbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiQ09OVEVOVF9XSURHRVRcIl0gPSA5XSA9IFwiQ09OVEVOVF9XSURHRVRcIjtcbiAgICAvKipcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGhlIGRlY29yYXRpb25zIG92ZXJ2aWV3IHJ1bGVyLlxuICAgICAqL1xuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJPVkVSVklFV19SVUxFUlwiXSA9IDEwXSA9IFwiT1ZFUlZJRVdfUlVMRVJcIjtcbiAgICAvKipcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgYSBzY3JvbGxiYXIuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIlNDUk9MTEJBUlwiXSA9IDExXSA9IFwiU0NST0xMQkFSXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGFuIG92ZXJsYXkgd2lkZ2V0LlxuICAgICAqL1xuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJPVkVSTEFZX1dJREdFVFwiXSA9IDEyXSA9IFwiT1ZFUkxBWV9XSURHRVRcIjtcbiAgICAvKipcbiAgICAgKiBNb3VzZSBpcyBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIk9VVFNJREVfRURJVE9SXCJdID0gMTNdID0gXCJPVVRTSURFX0VESVRPUlwiO1xufSkoTW91c2VUYXJnZXRUeXBlIHx8IChNb3VzZVRhcmdldFR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBOZXdTeW1ib2xOYW1lVGFnO1xuKGZ1bmN0aW9uIChOZXdTeW1ib2xOYW1lVGFnKSB7XG4gICAgTmV3U3ltYm9sTmFtZVRhZ1tOZXdTeW1ib2xOYW1lVGFnW1wiQUlHZW5lcmF0ZWRcIl0gPSAxXSA9IFwiQUlHZW5lcmF0ZWRcIjtcbn0pKE5ld1N5bWJvbE5hbWVUYWcgfHwgKE5ld1N5bWJvbE5hbWVUYWcgPSB7fSkpO1xuZXhwb3J0IHZhciBOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZCkge1xuICAgIE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZFtOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAwXSA9IFwiSW52b2tlXCI7XG4gICAgTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kW05ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZFtcIkF1dG9tYXRpY1wiXSA9IDFdID0gXCJBdXRvbWF0aWNcIjtcbn0pKE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZCB8fCAoTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogQSBwb3NpdGlvbmluZyBwcmVmZXJlbmNlIGZvciByZW5kZXJpbmcgb3ZlcmxheSB3aWRnZXRzLlxuICovXG5leHBvcnQgdmFyIE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2U7XG4oZnVuY3Rpb24gKE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UpIHtcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB0aGUgb3ZlcmxheSB3aWRnZXQgaW4gdGhlIHRvcCByaWdodCBjb3JuZXJcbiAgICAgKi9cbiAgICBPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW092ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJUT1BfUklHSFRfQ09STkVSXCJdID0gMF0gPSBcIlRPUF9SSUdIVF9DT1JORVJcIjtcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB0aGUgb3ZlcmxheSB3aWRnZXQgaW4gdGhlIGJvdHRvbSByaWdodCBjb3JuZXJcbiAgICAgKi9cbiAgICBPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW092ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJCT1RUT01fUklHSFRfQ09STkVSXCJdID0gMV0gPSBcIkJPVFRPTV9SSUdIVF9DT1JORVJcIjtcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB0aGUgb3ZlcmxheSB3aWRnZXQgaW4gdGhlIHRvcCBjZW50ZXJcbiAgICAgKi9cbiAgICBPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW092ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJUT1BfQ0VOVEVSXCJdID0gMl0gPSBcIlRPUF9DRU5URVJcIjtcbn0pKE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UgfHwgKE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UgPSB7fSkpO1xuLyoqXG4gKiBWZXJ0aWNhbCBMYW5lIGluIHRoZSBvdmVydmlldyBydWxlciBvZiB0aGUgZWRpdG9yLlxuICovXG5leHBvcnQgdmFyIE92ZXJ2aWV3UnVsZXJMYW5lO1xuKGZ1bmN0aW9uIChPdmVydmlld1J1bGVyTGFuZSkge1xuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiTGVmdFwiXSA9IDFdID0gXCJMZWZ0XCI7XG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJDZW50ZXJcIl0gPSAyXSA9IFwiQ2VudGVyXCI7XG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJSaWdodFwiXSA9IDRdID0gXCJSaWdodFwiO1xuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiRnVsbFwiXSA9IDddID0gXCJGdWxsXCI7XG59KShPdmVydmlld1J1bGVyTGFuZSB8fCAoT3ZlcnZpZXdSdWxlckxhbmUgPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBwYXJ0aWFsIGFjY2VwdGFuY2Ugd2FzIHRyaWdnZXJlZC5cbiAqL1xuZXhwb3J0IHZhciBQYXJ0aWFsQWNjZXB0VHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKFBhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZCkge1xuICAgIFBhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZFtQYXJ0aWFsQWNjZXB0VHJpZ2dlcktpbmRbXCJXb3JkXCJdID0gMF0gPSBcIldvcmRcIjtcbiAgICBQYXJ0aWFsQWNjZXB0VHJpZ2dlcktpbmRbUGFydGlhbEFjY2VwdFRyaWdnZXJLaW5kW1wiTGluZVwiXSA9IDFdID0gXCJMaW5lXCI7XG4gICAgUGFydGlhbEFjY2VwdFRyaWdnZXJLaW5kW1BhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZFtcIlN1Z2dlc3RcIl0gPSAyXSA9IFwiU3VnZ2VzdFwiO1xufSkoUGFydGlhbEFjY2VwdFRyaWdnZXJLaW5kIHx8IChQYXJ0aWFsQWNjZXB0VHJpZ2dlcktpbmQgPSB7fSkpO1xuZXhwb3J0IHZhciBQb3NpdGlvbkFmZmluaXR5O1xuKGZ1bmN0aW9uIChQb3NpdGlvbkFmZmluaXR5KSB7XG4gICAgLyoqXG4gICAgICogUHJlZmVycyB0aGUgbGVmdCBtb3N0IHBvc2l0aW9uLlxuICAgICovXG4gICAgUG9zaXRpb25BZmZpbml0eVtQb3NpdGlvbkFmZmluaXR5W1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XG4gICAgLyoqXG4gICAgICogUHJlZmVycyB0aGUgcmlnaHQgbW9zdCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIFBvc2l0aW9uQWZmaW5pdHlbUG9zaXRpb25BZmZpbml0eVtcIlJpZ2h0XCJdID0gMV0gPSBcIlJpZ2h0XCI7XG4gICAgLyoqXG4gICAgICogTm8gcHJlZmVyZW5jZS5cbiAgICAqL1xuICAgIFBvc2l0aW9uQWZmaW5pdHlbUG9zaXRpb25BZmZpbml0eVtcIk5vbmVcIl0gPSAyXSA9IFwiTm9uZVwiO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBvbiBpbmplY3RlZCB0ZXh0LCBwcmVmZXJzIHRoZSBwb3NpdGlvbiBsZWZ0IG9mIGl0LlxuICAgICovXG4gICAgUG9zaXRpb25BZmZpbml0eVtQb3NpdGlvbkFmZmluaXR5W1wiTGVmdE9mSW5qZWN0ZWRUZXh0XCJdID0gM10gPSBcIkxlZnRPZkluamVjdGVkVGV4dFwiO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBvbiBpbmplY3RlZCB0ZXh0LCBwcmVmZXJzIHRoZSBwb3NpdGlvbiByaWdodCBvZiBpdC5cbiAgICAqL1xuICAgIFBvc2l0aW9uQWZmaW5pdHlbUG9zaXRpb25BZmZpbml0eVtcIlJpZ2h0T2ZJbmplY3RlZFRleHRcIl0gPSA0XSA9IFwiUmlnaHRPZkluamVjdGVkVGV4dFwiO1xufSkoUG9zaXRpb25BZmZpbml0eSB8fCAoUG9zaXRpb25BZmZpbml0eSA9IHt9KSk7XG5leHBvcnQgdmFyIFJlbmRlckxpbmVOdW1iZXJzVHlwZTtcbihmdW5jdGlvbiAoUmVuZGVyTGluZU51bWJlcnNUeXBlKSB7XG4gICAgUmVuZGVyTGluZU51bWJlcnNUeXBlW1JlbmRlckxpbmVOdW1iZXJzVHlwZVtcIk9mZlwiXSA9IDBdID0gXCJPZmZcIjtcbiAgICBSZW5kZXJMaW5lTnVtYmVyc1R5cGVbUmVuZGVyTGluZU51bWJlcnNUeXBlW1wiT25cIl0gPSAxXSA9IFwiT25cIjtcbiAgICBSZW5kZXJMaW5lTnVtYmVyc1R5cGVbUmVuZGVyTGluZU51bWJlcnNUeXBlW1wiUmVsYXRpdmVcIl0gPSAyXSA9IFwiUmVsYXRpdmVcIjtcbiAgICBSZW5kZXJMaW5lTnVtYmVyc1R5cGVbUmVuZGVyTGluZU51bWJlcnNUeXBlW1wiSW50ZXJ2YWxcIl0gPSAzXSA9IFwiSW50ZXJ2YWxcIjtcbiAgICBSZW5kZXJMaW5lTnVtYmVyc1R5cGVbUmVuZGVyTGluZU51bWJlcnNUeXBlW1wiQ3VzdG9tXCJdID0gNF0gPSBcIkN1c3RvbVwiO1xufSkoUmVuZGVyTGluZU51bWJlcnNUeXBlIHx8IChSZW5kZXJMaW5lTnVtYmVyc1R5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBSZW5kZXJNaW5pbWFwO1xuKGZ1bmN0aW9uIChSZW5kZXJNaW5pbWFwKSB7XG4gICAgUmVuZGVyTWluaW1hcFtSZW5kZXJNaW5pbWFwW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgUmVuZGVyTWluaW1hcFtSZW5kZXJNaW5pbWFwW1wiVGV4dFwiXSA9IDFdID0gXCJUZXh0XCI7XG4gICAgUmVuZGVyTWluaW1hcFtSZW5kZXJNaW5pbWFwW1wiQmxvY2tzXCJdID0gMl0gPSBcIkJsb2Nrc1wiO1xufSkoUmVuZGVyTWluaW1hcCB8fCAoUmVuZGVyTWluaW1hcCA9IHt9KSk7XG5leHBvcnQgdmFyIFNjcm9sbFR5cGU7XG4oZnVuY3Rpb24gKFNjcm9sbFR5cGUpIHtcbiAgICBTY3JvbGxUeXBlW1Njcm9sbFR5cGVbXCJTbW9vdGhcIl0gPSAwXSA9IFwiU21vb3RoXCI7XG4gICAgU2Nyb2xsVHlwZVtTY3JvbGxUeXBlW1wiSW1tZWRpYXRlXCJdID0gMV0gPSBcIkltbWVkaWF0ZVwiO1xufSkoU2Nyb2xsVHlwZSB8fCAoU2Nyb2xsVHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIFNjcm9sbGJhclZpc2liaWxpdHk7XG4oZnVuY3Rpb24gKFNjcm9sbGJhclZpc2liaWxpdHkpIHtcbiAgICBTY3JvbGxiYXJWaXNpYmlsaXR5W1Njcm9sbGJhclZpc2liaWxpdHlbXCJBdXRvXCJdID0gMV0gPSBcIkF1dG9cIjtcbiAgICBTY3JvbGxiYXJWaXNpYmlsaXR5W1Njcm9sbGJhclZpc2liaWxpdHlbXCJIaWRkZW5cIl0gPSAyXSA9IFwiSGlkZGVuXCI7XG4gICAgU2Nyb2xsYmFyVmlzaWJpbGl0eVtTY3JvbGxiYXJWaXNpYmlsaXR5W1wiVmlzaWJsZVwiXSA9IDNdID0gXCJWaXNpYmxlXCI7XG59KShTY3JvbGxiYXJWaXNpYmlsaXR5IHx8IChTY3JvbGxiYXJWaXNpYmlsaXR5ID0ge30pKTtcbi8qKlxuICogVGhlIGRpcmVjdGlvbiBvZiBhIHNlbGVjdGlvbi5cbiAqL1xuZXhwb3J0IHZhciBTZWxlY3Rpb25EaXJlY3Rpb247XG4oZnVuY3Rpb24gKFNlbGVjdGlvbkRpcmVjdGlvbikge1xuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gc3RhcnRzIGFib3ZlIHdoZXJlIGl0IGVuZHMuXG4gICAgICovXG4gICAgU2VsZWN0aW9uRGlyZWN0aW9uW1NlbGVjdGlvbkRpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0aW9uIHN0YXJ0cyBiZWxvdyB3aGVyZSBpdCBlbmRzLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbkRpcmVjdGlvbltTZWxlY3Rpb25EaXJlY3Rpb25bXCJSVExcIl0gPSAxXSA9IFwiUlRMXCI7XG59KShTZWxlY3Rpb25EaXJlY3Rpb24gfHwgKFNlbGVjdGlvbkRpcmVjdGlvbiA9IHt9KSk7XG5leHBvcnQgdmFyIFNob3dMaWdodGJ1bGJJY29uTW9kZTtcbihmdW5jdGlvbiAoU2hvd0xpZ2h0YnVsYkljb25Nb2RlKSB7XG4gICAgU2hvd0xpZ2h0YnVsYkljb25Nb2RlW1wiT2ZmXCJdID0gXCJvZmZcIjtcbiAgICBTaG93TGlnaHRidWxiSWNvbk1vZGVbXCJPbkNvZGVcIl0gPSBcIm9uQ29kZVwiO1xuICAgIFNob3dMaWdodGJ1bGJJY29uTW9kZVtcIk9uXCJdID0gXCJvblwiO1xufSkoU2hvd0xpZ2h0YnVsYkljb25Nb2RlIHx8IChTaG93TGlnaHRidWxiSWNvbk1vZGUgPSB7fSkpO1xuZXhwb3J0IHZhciBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCkge1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAxXSA9IFwiSW52b2tlXCI7XG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1NpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtcIlRyaWdnZXJDaGFyYWN0ZXJcIl0gPSAyXSA9IFwiVHJpZ2dlckNoYXJhY3RlclwiO1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbXCJDb250ZW50Q2hhbmdlXCJdID0gM10gPSBcIkNvbnRlbnRDaGFuZ2VcIjtcbn0pKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCB8fCAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogQSBzeW1ib2wga2luZC5cbiAqL1xuZXhwb3J0IHZhciBTeW1ib2xLaW5kO1xuKGZ1bmN0aW9uIChTeW1ib2xLaW5kKSB7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRmlsZVwiXSA9IDBdID0gXCJGaWxlXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTW9kdWxlXCJdID0gMV0gPSBcIk1vZHVsZVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIk5hbWVzcGFjZVwiXSA9IDJdID0gXCJOYW1lc3BhY2VcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJQYWNrYWdlXCJdID0gM10gPSBcIlBhY2thZ2VcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJDbGFzc1wiXSA9IDRdID0gXCJDbGFzc1wiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIk1ldGhvZFwiXSA9IDVdID0gXCJNZXRob2RcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJQcm9wZXJ0eVwiXSA9IDZdID0gXCJQcm9wZXJ0eVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkZpZWxkXCJdID0gN10gPSBcIkZpZWxkXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiQ29uc3RydWN0b3JcIl0gPSA4XSA9IFwiQ29uc3RydWN0b3JcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJFbnVtXCJdID0gOV0gPSBcIkVudW1cIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJJbnRlcmZhY2VcIl0gPSAxMF0gPSBcIkludGVyZmFjZVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkZ1bmN0aW9uXCJdID0gMTFdID0gXCJGdW5jdGlvblwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIlZhcmlhYmxlXCJdID0gMTJdID0gXCJWYXJpYWJsZVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkNvbnN0YW50XCJdID0gMTNdID0gXCJDb25zdGFudFwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIlN0cmluZ1wiXSA9IDE0XSA9IFwiU3RyaW5nXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTnVtYmVyXCJdID0gMTVdID0gXCJOdW1iZXJcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJCb29sZWFuXCJdID0gMTZdID0gXCJCb29sZWFuXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiQXJyYXlcIl0gPSAxN10gPSBcIkFycmF5XCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiT2JqZWN0XCJdID0gMThdID0gXCJPYmplY3RcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJLZXlcIl0gPSAxOV0gPSBcIktleVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIk51bGxcIl0gPSAyMF0gPSBcIk51bGxcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJFbnVtTWVtYmVyXCJdID0gMjFdID0gXCJFbnVtTWVtYmVyXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiU3RydWN0XCJdID0gMjJdID0gXCJTdHJ1Y3RcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJFdmVudFwiXSA9IDIzXSA9IFwiRXZlbnRcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJPcGVyYXRvclwiXSA9IDI0XSA9IFwiT3BlcmF0b3JcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJUeXBlUGFyYW1ldGVyXCJdID0gMjVdID0gXCJUeXBlUGFyYW1ldGVyXCI7XG59KShTeW1ib2xLaW5kIHx8IChTeW1ib2xLaW5kID0ge30pKTtcbmV4cG9ydCB2YXIgU3ltYm9sVGFnO1xuKGZ1bmN0aW9uIChTeW1ib2xUYWcpIHtcbiAgICBTeW1ib2xUYWdbU3ltYm9sVGFnW1wiRGVwcmVjYXRlZFwiXSA9IDFdID0gXCJEZXByZWNhdGVkXCI7XG59KShTeW1ib2xUYWcgfHwgKFN5bWJvbFRhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBraW5kIG9mIGFuaW1hdGlvbiBpbiB3aGljaCB0aGUgZWRpdG9yJ3MgY3Vyc29yIHNob3VsZCBiZSByZW5kZXJlZC5cbiAqL1xuZXhwb3J0IHZhciBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZTtcbihmdW5jdGlvbiAoVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGUpIHtcbiAgICAvKipcbiAgICAgKiBIaWRkZW5cbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIkhpZGRlblwiXSA9IDBdID0gXCJIaWRkZW5cIjtcbiAgICAvKipcbiAgICAgKiBCbGlua2luZ1xuICAgICAqL1xuICAgIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1RleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1wiQmxpbmtcIl0gPSAxXSA9IFwiQmxpbmtcIjtcbiAgICAvKipcbiAgICAgKiBCbGlua2luZyB3aXRoIHNtb290aCBmYWRpbmdcbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIlNtb290aFwiXSA9IDJdID0gXCJTbW9vdGhcIjtcbiAgICAvKipcbiAgICAgKiBCbGlua2luZyB3aXRoIHByb2xvbmdlZCBmaWxsZWQgc3RhdGUgYW5kIHNtb290aCBmYWRpbmdcbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIlBoYXNlXCJdID0gM10gPSBcIlBoYXNlXCI7XG4gICAgLyoqXG4gICAgICogRXhwYW5kIGNvbGxhcHNlIGFuaW1hdGlvbiBvbiB0aGUgeSBheGlzXG4gICAgICovXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJFeHBhbmRcIl0gPSA0XSA9IFwiRXhwYW5kXCI7XG4gICAgLyoqXG4gICAgICogTm8tQmxpbmtpbmdcbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIlNvbGlkXCJdID0gNV0gPSBcIlNvbGlkXCI7XG59KShUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZSB8fCAoVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGUgPSB7fSkpO1xuLyoqXG4gKiBUaGUgc3R5bGUgaW4gd2hpY2ggdGhlIGVkaXRvcidzIGN1cnNvciBzaG91bGQgYmUgcmVuZGVyZWQuXG4gKi9cbmV4cG9ydCB2YXIgVGV4dEVkaXRvckN1cnNvclN0eWxlO1xuKGZ1bmN0aW9uIChUZXh0RWRpdG9yQ3Vyc29yU3R5bGUpIHtcbiAgICAvKipcbiAgICAgKiBBcyBhIHZlcnRpY2FsIGxpbmUgKHNpdHRpbmcgYmV0d2VlbiB0d28gY2hhcmFjdGVycykuXG4gICAgICovXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIkxpbmVcIl0gPSAxXSA9IFwiTGluZVwiO1xuICAgIC8qKlxuICAgICAqIEFzIGEgYmxvY2sgKHNpdHRpbmcgb24gdG9wIG9mIGEgY2hhcmFjdGVyKS5cbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiQmxvY2tcIl0gPSAyXSA9IFwiQmxvY2tcIjtcbiAgICAvKipcbiAgICAgKiBBcyBhIGhvcml6b250YWwgbGluZSAoc2l0dGluZyB1bmRlciBhIGNoYXJhY3RlcikuXG4gICAgICovXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIlVuZGVybGluZVwiXSA9IDNdID0gXCJVbmRlcmxpbmVcIjtcbiAgICAvKipcbiAgICAgKiBBcyBhIHRoaW4gdmVydGljYWwgbGluZSAoc2l0dGluZyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXJzKS5cbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiTGluZVRoaW5cIl0gPSA0XSA9IFwiTGluZVRoaW5cIjtcbiAgICAvKipcbiAgICAgKiBBcyBhbiBvdXRsaW5lZCBibG9jayAoc2l0dGluZyBvbiB0b3Agb2YgYSBjaGFyYWN0ZXIpLlxuICAgICAqL1xuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJCbG9ja091dGxpbmVcIl0gPSA1XSA9IFwiQmxvY2tPdXRsaW5lXCI7XG4gICAgLyoqXG4gICAgICogQXMgYSB0aGluIGhvcml6b250YWwgbGluZSAoc2l0dGluZyB1bmRlciBhIGNoYXJhY3RlcikuXG4gICAgICovXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIlVuZGVybGluZVRoaW5cIl0gPSA2XSA9IFwiVW5kZXJsaW5lVGhpblwiO1xufSkoVGV4dEVkaXRvckN1cnNvclN0eWxlIHx8IChUZXh0RWRpdG9yQ3Vyc29yU3R5bGUgPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIGJlaGF2aW9yIG9mIGRlY29yYXRpb25zIHdoZW4gdHlwaW5nL2VkaXRpbmcgbmVhciB0aGVpciBlZGdlcy5cbiAqIE5vdGU6IFBsZWFzZSBkbyBub3QgZWRpdCB0aGUgdmFsdWVzLCBhcyB0aGV5IHZlcnkgY2FyZWZ1bGx5IG1hdGNoIGBEZWNvcmF0aW9uUmFuZ2VCZWhhdmlvcmBcbiAqL1xuZXhwb3J0IHZhciBUcmFja2VkUmFuZ2VTdGlja2luZXNzO1xuKGZ1bmN0aW9uIChUcmFja2VkUmFuZ2VTdGlja2luZXNzKSB7XG4gICAgVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tUcmFja2VkUmFuZ2VTdGlja2luZXNzW1wiQWx3YXlzR3Jvd3NXaGVuVHlwaW5nQXRFZGdlc1wiXSA9IDBdID0gXCJBbHdheXNHcm93c1doZW5UeXBpbmdBdEVkZ2VzXCI7XG4gICAgVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tUcmFja2VkUmFuZ2VTdGlja2luZXNzW1wiTmV2ZXJHcm93c1doZW5UeXBpbmdBdEVkZ2VzXCJdID0gMV0gPSBcIk5ldmVyR3Jvd3NXaGVuVHlwaW5nQXRFZGdlc1wiO1xuICAgIFRyYWNrZWRSYW5nZVN0aWNraW5lc3NbVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tcIkdyb3dzT25seVdoZW5UeXBpbmdCZWZvcmVcIl0gPSAyXSA9IFwiR3Jvd3NPbmx5V2hlblR5cGluZ0JlZm9yZVwiO1xuICAgIFRyYWNrZWRSYW5nZVN0aWNraW5lc3NbVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tcIkdyb3dzT25seVdoZW5UeXBpbmdBZnRlclwiXSA9IDNdID0gXCJHcm93c09ubHlXaGVuVHlwaW5nQWZ0ZXJcIjtcbn0pKFRyYWNrZWRSYW5nZVN0aWNraW5lc3MgfHwgKFRyYWNrZWRSYW5nZVN0aWNraW5lc3MgPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgaG93IHRvIGluZGVudCB3cmFwcGVkIGxpbmVzLlxuICovXG5leHBvcnQgdmFyIFdyYXBwaW5nSW5kZW50O1xuKGZ1bmN0aW9uIChXcmFwcGluZ0luZGVudCkge1xuICAgIC8qKlxuICAgICAqIE5vIGluZGVudGF0aW9uID0+IHdyYXBwZWQgbGluZXMgYmVnaW4gYXQgY29sdW1uIDEuXG4gICAgICovXG4gICAgV3JhcHBpbmdJbmRlbnRbV3JhcHBpbmdJbmRlbnRbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAvKipcbiAgICAgKiBTYW1lID0+IHdyYXBwZWQgbGluZXMgZ2V0IHRoZSBzYW1lIGluZGVudGF0aW9uIGFzIHRoZSBwYXJlbnQuXG4gICAgICovXG4gICAgV3JhcHBpbmdJbmRlbnRbV3JhcHBpbmdJbmRlbnRbXCJTYW1lXCJdID0gMV0gPSBcIlNhbWVcIjtcbiAgICAvKipcbiAgICAgKiBJbmRlbnQgPT4gd3JhcHBlZCBsaW5lcyBnZXQgKzEgaW5kZW50YXRpb24gdG93YXJkIHRoZSBwYXJlbnQuXG4gICAgICovXG4gICAgV3JhcHBpbmdJbmRlbnRbV3JhcHBpbmdJbmRlbnRbXCJJbmRlbnRcIl0gPSAyXSA9IFwiSW5kZW50XCI7XG4gICAgLyoqXG4gICAgICogRGVlcEluZGVudCA9PiB3cmFwcGVkIGxpbmVzIGdldCArMiBpbmRlbnRhdGlvbiB0b3dhcmQgdGhlIHBhcmVudC5cbiAgICAgKi9cbiAgICBXcmFwcGluZ0luZGVudFtXcmFwcGluZ0luZGVudFtcIkRlZXBJbmRlbnRcIl0gPSAzXSA9IFwiRGVlcEluZGVudFwiO1xufSkoV3JhcHBpbmdJbmRlbnQgfHwgKFdyYXBwaW5nSW5kZW50ID0ge30pKTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uLy4uL2Jhc2UvY29tbW9uL2V2ZW50LmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGUsIHRvRGlzcG9zYWJsZSB9IGZyb20gJy4uLy4uL2Jhc2UvY29tbW9uL2xpZmVjeWNsZS5qcyc7XG5leHBvcnQgY2xhc3MgVG9rZW5pemF0aW9uUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZmFjdG9yaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZSA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25EaWRDaGFuZ2UgPSB0aGlzLl9vbkRpZENoYW5nZS5ldmVudDtcbiAgICAgICAgdGhpcy5fY29sb3JNYXAgPSBudWxsO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UobGFuZ3VhZ2VJZHMpIHtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2UuZmlyZSh7XG4gICAgICAgICAgICBjaGFuZ2VkTGFuZ3VhZ2VzOiBsYW5ndWFnZUlkcyxcbiAgICAgICAgICAgIGNoYW5nZWRDb2xvck1hcDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGxhbmd1YWdlSWQsIHN1cHBvcnQpIHtcbiAgICAgICAgdGhpcy5fdG9rZW5pemF0aW9uU3VwcG9ydHMuc2V0KGxhbmd1YWdlSWQsIHN1cHBvcnQpO1xuICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZShbbGFuZ3VhZ2VJZF0pO1xuICAgICAgICByZXR1cm4gdG9EaXNwb3NhYmxlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0cy5nZXQobGFuZ3VhZ2VJZCkgIT09IHN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0cy5kZWxldGUobGFuZ3VhZ2VJZCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZShbbGFuZ3VhZ2VJZF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0KGxhbmd1YWdlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnRzLmdldChsYW5ndWFnZUlkKSB8fCBudWxsO1xuICAgIH1cbiAgICByZWdpc3RlckZhY3RvcnkobGFuZ3VhZ2VJZCwgZmFjdG9yeSkge1xuICAgICAgICB0aGlzLl9mYWN0b3JpZXMuZ2V0KGxhbmd1YWdlSWQpPy5kaXNwb3NlKCk7XG4gICAgICAgIGNvbnN0IG15RGF0YSA9IG5ldyBUb2tlbml6YXRpb25TdXBwb3J0RmFjdG9yeURhdGEodGhpcywgbGFuZ3VhZ2VJZCwgZmFjdG9yeSk7XG4gICAgICAgIHRoaXMuX2ZhY3Rvcmllcy5zZXQobGFuZ3VhZ2VJZCwgbXlEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRvRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy5fZmFjdG9yaWVzLmdldChsYW5ndWFnZUlkKTtcbiAgICAgICAgICAgIGlmICghdiB8fCB2ICE9PSBteURhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9mYWN0b3JpZXMuZGVsZXRlKGxhbmd1YWdlSWQpO1xuICAgICAgICAgICAgdi5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRPckNyZWF0ZShsYW5ndWFnZUlkKSB7XG4gICAgICAgIC8vIGNoZWNrIGZpcnN0IGlmIHRoZSBzdXBwb3J0IGlzIGFscmVhZHkgc2V0XG4gICAgICAgIGNvbnN0IHRva2VuaXphdGlvblN1cHBvcnQgPSB0aGlzLmdldChsYW5ndWFnZUlkKTtcbiAgICAgICAgaWYgKHRva2VuaXphdGlvblN1cHBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbml6YXRpb25TdXBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLl9mYWN0b3JpZXMuZ2V0KGxhbmd1YWdlSWQpO1xuICAgICAgICBpZiAoIWZhY3RvcnkgfHwgZmFjdG9yeS5pc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAvLyBubyBmYWN0b3J5IG9yIGZhY3RvcnkucmVzb2x2ZSBhbHJlYWR5IGZpbmlzaGVkXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmYWN0b3J5LnJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGxhbmd1YWdlSWQpO1xuICAgIH1cbiAgICBpc1Jlc29sdmVkKGxhbmd1YWdlSWQpIHtcbiAgICAgICAgY29uc3QgdG9rZW5pemF0aW9uU3VwcG9ydCA9IHRoaXMuZ2V0KGxhbmd1YWdlSWQpO1xuICAgICAgICBpZiAodG9rZW5pemF0aW9uU3VwcG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuX2ZhY3Rvcmllcy5nZXQobGFuZ3VhZ2VJZCk7XG4gICAgICAgIGlmICghZmFjdG9yeSB8fCBmYWN0b3J5LmlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2V0Q29sb3JNYXAoY29sb3JNYXApIHtcbiAgICAgICAgdGhpcy5fY29sb3JNYXAgPSBjb2xvck1hcDtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2UuZmlyZSh7XG4gICAgICAgICAgICBjaGFuZ2VkTGFuZ3VhZ2VzOiBBcnJheS5mcm9tKHRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnRzLmtleXMoKSksXG4gICAgICAgICAgICBjaGFuZ2VkQ29sb3JNYXA6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbG9yTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JNYXA7XG4gICAgfVxuICAgIGdldERlZmF1bHRCYWNrZ3JvdW5kKCkge1xuICAgICAgICBpZiAodGhpcy5fY29sb3JNYXAgJiYgdGhpcy5fY29sb3JNYXAubGVuZ3RoID4gMiAvKiBDb2xvcklkLkRlZmF1bHRCYWNrZ3JvdW5kICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JNYXBbMiAvKiBDb2xvcklkLkRlZmF1bHRCYWNrZ3JvdW5kICovXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBUb2tlbml6YXRpb25TdXBwb3J0RmFjdG9yeURhdGEgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgICBnZXQgaXNSZXNvbHZlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUmVzb2x2ZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9yZWdpc3RyeSwgX2xhbmd1YWdlSWQsIF9mYWN0b3J5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdHJ5ID0gX3JlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gX2xhbmd1YWdlSWQ7XG4gICAgICAgIHRoaXMuX2ZhY3RvcnkgPSBfZmFjdG9yeTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXNvbHZlUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVByb21pc2UgPSB0aGlzLl9jcmVhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVByb21pc2U7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5fZmFjdG9yeS50b2tlbml6YXRpb25TdXBwb3J0O1xuICAgICAgICB0aGlzLl9pc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3Rlcih0aGlzLl9yZWdpc3RyeS5yZWdpc3Rlcih0aGlzLl9sYW5ndWFnZUlkLCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbG9jYWwvY29kZS1pbXBvcnQtcGF0dGVybnNcbmltcG9ydCB7IGdldE5MU0xhbmd1YWdlLCBnZXROTFNNZXNzYWdlcyB9IGZyb20gJy4vbmxzLm1lc3NhZ2VzLmpzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBsb2NhbC9jb2RlLWltcG9ydC1wYXR0ZXJuc1xuZXhwb3J0IHsgZ2V0TkxTTGFuZ3VhZ2UsIGdldE5MU01lc3NhZ2VzIH0gZnJvbSAnLi9ubHMubWVzc2FnZXMuanMnO1xuY29uc3QgaXNQc2V1ZG8gPSBnZXROTFNMYW5ndWFnZSgpID09PSAncHNldWRvJyB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5sb2NhdGlvbiAmJiBkb2N1bWVudC5sb2NhdGlvbi5oYXNoLmluZGV4T2YoJ3BzZXVkbz10cnVlJykgPj0gMCk7XG5mdW5jdGlvbiBfZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBtZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbWVzc2FnZS5yZXBsYWNlKC9cXHsoXFxkKylcXH0vZywgKG1hdGNoLCByZXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHJlc3RbMF07XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fCBhcmcgPT09IHZvaWQgMCB8fCBhcmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcoYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNQc2V1ZG8pIHtcbiAgICAgICAgLy8gRkYzQiBhbmQgRkYzRCBpcyB0aGUgVW5pY29kZSB6ZW5rYWt1IHJlcHJlc2VudGF0aW9uIGZvciBbIGFuZCBdXG4gICAgICAgIHJlc3VsdCA9ICdcXHVGRjNCJyArIHJlc3VsdC5yZXBsYWNlKC9bYW91ZWldL2csICckJiQmJykgKyAnXFx1RkYzRCc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBza2lwTWFuZ2xlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbGl6ZShkYXRhIC8qIHwgbnVtYmVyIHdoZW4gYnVpbHQgKi8sIG1lc3NhZ2UgLyogfCBudWxsIHdoZW4gYnVpbHQgKi8sIC4uLmFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBfZm9ybWF0KGxvb2t1cE1lc3NhZ2UoZGF0YSwgbWVzc2FnZSksIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gX2Zvcm1hdChtZXNzYWdlLCBhcmdzKTtcbn1cbi8qKlxuICogT25seSB1c2VkIHdoZW4gYnVpbHQ6IExvb2tzIHVwIHRoZSBtZXNzYWdlIGluIHRoZSBnbG9iYWwgTkxTIHRhYmxlLlxuICogVGhpcyB0YWJsZSBpcyBiZWluZyBtYWRlIGF2YWlsYWJsZSBhcyBhIGdsb2JhbCB0aHJvdWdoIGJvb3RzdHJhcHBpbmdcbiAqIGRlcGVuZGluZyBvbiB0aGUgdGFyZ2V0IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGxvb2t1cE1lc3NhZ2UoaW5kZXgsIGZhbGxiYWNrKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdldE5MU01lc3NhZ2VzKCk/LltpbmRleF07XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGZhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgISEhIE5MUyBNSVNTSU5HOiAke2luZGV4fSAhISFgKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG4vKipcbiAqIEBza2lwTWFuZ2xlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbGl6ZTIoZGF0YSAvKiB8IG51bWJlciB3aGVuIGJ1aWx0ICovLCBvcmlnaW5hbE1lc3NhZ2UsIC4uLmFyZ3MpIHtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBsb29rdXBNZXNzYWdlKGRhdGEsIG9yaWdpbmFsTWVzc2FnZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IF9mb3JtYXQobWVzc2FnZSwgYXJncyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9yaWdpbmFsOiBvcmlnaW5hbE1lc3NhZ2UgPT09IG1lc3NhZ2UgPyB2YWx1ZSA6IF9mb3JtYXQob3JpZ2luYWxNZXNzYWdlLCBhcmdzKVxuICAgIH07XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qXG4gKiBUaGlzIG1vZHVsZSBleGlzdHMgc28gdGhhdCB0aGUgQU1EIGJ1aWxkIG9mIHRoZSBtb25hY28gZWRpdG9yIGNhbiByZXBsYWNlIHRoaXMgd2l0aCBhbiBhc3luYyBsb2FkZXIgcGx1Z2luLlxuICogSWYgeW91IGFkZCBuZXcgZnVuY3Rpb25zIHRvIHRoaXMgbW9kdWxlIG1ha2Ugc3VyZSB0aGF0IHRoZXkgYXJlIGFsc28gcHJvdmlkZWQgaW4gdGhlIEFNRCBidWlsZCBvZiB0aGUgbW9uYWNvIGVkaXRvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5MU01lc3NhZ2VzKCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLl9WU0NPREVfTkxTX01FU1NBR0VTO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5MU0xhbmd1YWdlKCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLl9WU0NPREVfTkxTX0xBTkdVQUdFO1xufVxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmYgPSB7fTtcbi8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbi8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5lID0gKGNodW5rSWQpID0+IHtcblx0cmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uZikucmVkdWNlKChwcm9taXNlcywga2V5KSA9PiB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mW2tleV0oY2h1bmtJZCwgcHJvbWlzZXMpO1xuXHRcdHJldHVybiBwcm9taXNlcztcblx0fSwgW10pKTtcbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYXN5bmMgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnUgPSAoY2h1bmtJZCkgPT4ge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwiXCIgKyBjaHVua0lkICsgXCIuYnVuZGxlLmpzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCJ2YXIgaW5Qcm9ncmVzcyA9IHt9O1xudmFyIGRhdGFXZWJwYWNrUHJlZml4ID0gXCJweWxpbmFjLXlhbWwtZWRpdG9yOlwiO1xuLy8gbG9hZFNjcmlwdCBmdW5jdGlvbiB0byBsb2FkIGEgc2NyaXB0IHZpYSBzY3JpcHQgdGFnXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmwgPSAodXJsLCBkb25lLCBrZXksIGNodW5rSWQpID0+IHtcblx0aWYoaW5Qcm9ncmVzc1t1cmxdKSB7IGluUHJvZ3Jlc3NbdXJsXS5wdXNoKGRvbmUpOyByZXR1cm47IH1cblx0dmFyIHNjcmlwdCwgbmVlZEF0dGFjaDtcblx0aWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcyA9IHNjcmlwdHNbaV07XG5cdFx0XHRpZihzLmdldEF0dHJpYnV0ZShcInNyY1wiKSA9PSB1cmwgfHwgcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIikgPT0gZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpIHsgc2NyaXB0ID0gczsgYnJlYWs7IH1cblx0XHR9XG5cdH1cblx0aWYoIXNjcmlwdCkge1xuXHRcdG5lZWRBdHRhY2ggPSB0cnVlO1xuXHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuXHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwO1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIiwgZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpO1xuXG5cdFx0c2NyaXB0LnNyYyA9IHVybDtcblx0fVxuXHRpblByb2dyZXNzW3VybF0gPSBbZG9uZV07XG5cdHZhciBvblNjcmlwdENvbXBsZXRlID0gKHByZXYsIGV2ZW50KSA9PiB7XG5cdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuXHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdHZhciBkb25lRm5zID0gaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdGRlbGV0ZSBpblByb2dyZXNzW3VybF07XG5cdFx0c2NyaXB0LnBhcmVudE5vZGUgJiYgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRkb25lRm5zICYmIGRvbmVGbnMuZm9yRWFjaCgoZm4pID0+IChmbihldmVudCkpKTtcblx0XHRpZihwcmV2KSByZXR1cm4gcHJldihldmVudCk7XG5cdH1cblx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCB1bmRlZmluZWQsIHsgdHlwZTogJ3RpbWVvdXQnLCB0YXJnZXQ6IHNjcmlwdCB9KSwgMTIwMDAwKTtcblx0c2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuXHRzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuXHRuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn07IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIuL1wiOyIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3Ncbi8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuLy8gW3Jlc29sdmUsIHJlamVjdCwgUHJvbWlzZV0gPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG52YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuXHRcImVkaXRvci53b3JrZXJcIjogMFxufTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5mLmogPSAoY2h1bmtJZCwgcHJvbWlzZXMpID0+IHtcblx0XHQvLyBKU09OUCBjaHVuayBsb2FkaW5nIGZvciBqYXZhc2NyaXB0XG5cdFx0dmFyIGluc3RhbGxlZENodW5rRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpID8gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdIDogdW5kZWZpbmVkO1xuXHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSAhPT0gMCkgeyAvLyAwIG1lYW5zIFwiYWxyZWFkeSBpbnN0YWxsZWRcIi5cblxuXHRcdFx0Ly8gYSBQcm9taXNlIG1lYW5zIFwiY3VycmVudGx5IGxvYWRpbmdcIi5cblx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuXHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0cnVlKSB7IC8vIGFsbCBjaHVua3MgaGF2ZSBKU1xuXHRcdFx0XHRcdC8vIHNldHVwIFByb21pc2UgaW4gY2h1bmsgY2FjaGVcblx0XHRcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IChpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSBbcmVzb2x2ZSwgcmVqZWN0XSkpO1xuXHRcdFx0XHRcdHByb21pc2VzLnB1c2goaW5zdGFsbGVkQ2h1bmtEYXRhWzJdID0gcHJvbWlzZSk7XG5cblx0XHRcdFx0XHQvLyBzdGFydCBjaHVuayBsb2FkaW5nXG5cdFx0XHRcdFx0dmFyIHVybCA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIF9fd2VicGFja19yZXF1aXJlX18udShjaHVua0lkKTtcblx0XHRcdFx0XHQvLyBjcmVhdGUgZXJyb3IgYmVmb3JlIHN0YWNrIHVud291bmQgdG8gZ2V0IHVzZWZ1bCBzdGFja3RyYWNlIGxhdGVyXG5cdFx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCk7XG5cdFx0XHRcdFx0dmFyIGxvYWRpbmdFbmRlZCA9IChldmVudCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkpIHtcblx0XHRcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuXHRcdFx0XHRcdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEgIT09IDApIGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGVycm9yVHlwZSA9IGV2ZW50ICYmIChldmVudC50eXBlID09PSAnbG9hZCcgPyAnbWlzc2luZycgOiBldmVudC50eXBlKTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmVhbFNyYyA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuc3JjO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLm1lc3NhZ2UgPSAnTG9hZGluZyBjaHVuayAnICsgY2h1bmtJZCArICcgZmFpbGVkLlxcbignICsgZXJyb3JUeXBlICsgJzogJyArIHJlYWxTcmMgKyAnKSc7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IubmFtZSA9ICdDaHVua0xvYWRFcnJvcic7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IudHlwZSA9IGVycm9yVHlwZTtcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5yZXF1ZXN0ID0gcmVhbFNyYztcblx0XHRcdFx0XHRcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGFbMV0oZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmwodXJsLCBsb2FkaW5nRW5kZWQsIFwiY2h1bmstXCIgKyBjaHVua0lkLCBjaHVua0lkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cbn07XG5cbi8vIG5vIHByZWZldGNoaW5nXG5cbi8vIG5vIHByZWxvYWRlZFxuXG4vLyBubyBITVJcblxuLy8gbm8gSE1SIG1hbmlmZXN0XG5cbi8vIG5vIG9uIGNodW5rcyBsb2FkZWRcblxuLy8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG52YXIgd2VicGFja0pzb25wQ2FsbGJhY2sgPSAocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24sIGRhdGEpID0+IHtcblx0dmFyIFtjaHVua0lkcywgbW9yZU1vZHVsZXMsIHJ1bnRpbWVdID0gZGF0YTtcblx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG5cdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuXHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwO1xuXHRpZihjaHVua0lkcy5zb21lKChpZCkgPT4gKGluc3RhbGxlZENodW5rc1tpZF0gIT09IDApKSkge1xuXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYocnVudGltZSkgdmFyIHJlc3VsdCA9IHJ1bnRpbWUoX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdH1cblx0aWYocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24pIHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKGRhdGEpO1xuXHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuXHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJiBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcblx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSgpO1xuXHRcdH1cblx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuXHR9XG5cbn1cblxudmFyIGNodW5rTG9hZGluZ0dsb2JhbCA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtweWxpbmFjX3lhbWxfZWRpdG9yXCJdID0gc2VsZltcIndlYnBhY2tDaHVua3B5bGluYWNfeWFtbF9lZGl0b3JcIl0gfHwgW107XG5jaHVua0xvYWRpbmdHbG9iYWwuZm9yRWFjaCh3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIDApKTtcbmNodW5rTG9hZGluZ0dsb2JhbC5wdXNoID0gd2VicGFja0pzb25wQ2FsbGJhY2suYmluZChudWxsLCBjaHVua0xvYWRpbmdHbG9iYWwucHVzaC5iaW5kKGNodW5rTG9hZGluZ0dsb2JhbCkpOyIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgU2ltcGxlV29ya2VyU2VydmVyIH0gZnJvbSAnLi4vYmFzZS9jb21tb24vd29ya2VyL3NpbXBsZVdvcmtlci5qcyc7XG5pbXBvcnQgeyBFZGl0b3JTaW1wbGVXb3JrZXIgfSBmcm9tICcuL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JTaW1wbGVXb3JrZXIuanMnO1xuaW1wb3J0IHsgRWRpdG9yV29ya2VySG9zdCB9IGZyb20gJy4vY29tbW9uL3NlcnZpY2VzL2VkaXRvcldvcmtlckhvc3QuanMnO1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZShmb3JlaWduTW9kdWxlKSB7XG4gICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHNpbXBsZVdvcmtlciA9IG5ldyBTaW1wbGVXb3JrZXJTZXJ2ZXIoKG1zZykgPT4ge1xuICAgICAgICBnbG9iYWxUaGlzLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgfSwgKHdvcmtlclNlcnZlcikgPT4gbmV3IEVkaXRvclNpbXBsZVdvcmtlcihFZGl0b3JXb3JrZXJIb3N0LmdldENoYW5uZWwod29ya2VyU2VydmVyKSwgZm9yZWlnbk1vZHVsZSkpO1xuICAgIGdsb2JhbFRoaXMub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgICAgc2ltcGxlV29ya2VyLm9ubWVzc2FnZShlLmRhdGEpO1xuICAgIH07XG59XG5nbG9iYWxUaGlzLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgLy8gSWdub3JlIGZpcnN0IG1lc3NhZ2UgaW4gdGhpcyBjYXNlIGFuZCBpbml0aWFsaXplIGlmIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcbiAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICAgIGluaXRpYWxpemUobnVsbCk7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==